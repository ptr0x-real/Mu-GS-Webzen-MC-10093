; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?iCount@@3HA					; iCount
_BSS	SEGMENT
?iCount@@3HA DD	01H DUP (?)				; iCount
_BSS	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?set@PWMSG_HEAD@@QAEXPAEEH@Z			; PWMSG_HEAD::set
PUBLIC	?Size@CTerrainManager@@QAE?BHXZ			; CTerrainManager::Size
PUBLIC	?DataServerProtocolCore@@YAXEPAEH@Z		; DataServerProtocolCore
PUBLIC	?DataServerLogin@@YAXH@Z			; DataServerLogin
PUBLIC	?DataServerGetCharListRequest@@YAXF@Z		; DataServerGetCharListRequest
PUBLIC	?GDGameServerInfoSave@@YAXXZ			; GDGameServerInfoSave
PUBLIC	?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z	; GJSetCharacterInfo
PUBLIC	?GDUserItemSave@@YAXPAVOBJECTSTRUCT@@@Z		; GDUserItemSave
PUBLIC	?JGCharacterCreateFailSend@@YAXHPAD@Z		; JGCharacterCreateFailSend
PUBLIC	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z	; ItemSerialCreateSend
PUBLIC	?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z	; PetItemSerialCreateSend
PUBLIC	?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z		; ItemMovePathSave
PUBLIC	?GDGetWarehouseList@@YAXHPAD@Z			; GDGetWarehouseList
PUBLIC	?GDSetWarehouseList@@YAXH@Z			; GDSetWarehouseList
PUBLIC	?GDSetWarehouseMoney@@YAXH@Z			; GDSetWarehouseMoney
PUBLIC	?DGOptionDataSend@@YAXHPADPAEEEEEE@Z		; DGOptionDataSend
PUBLIC	?gObjRequestPetItemInfo@@YAXHH@Z		; gObjRequestPetItemInfo
PUBLIC	?gObjSavePetItemInfo@@YAXHH@Z			; gObjSavePetItemInfo
PUBLIC	?GCItemListSend@@YAXH@Z				; GCItemListSend
PUBLIC	?JGPGetCharList@@YAXPAE@Z			; JGPGetCharList
PUBLIC	?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z ; JGCharacterCreateRequest
PUBLIC	?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z ; JGCharDelRequest
PUBLIC	?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z ; JGGetCharacterInfo
PUBLIC	?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z	; DataServerLoginResult
PUBLIC	?TestDSSend@@YAXXZ				; TestDSSend
PUBLIC	?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z ; ItemSerialCreateRecv
PUBLIC	?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ; DGGetWarehouseList
PUBLIC	?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ; GDGetWarehouseNoItem
PUBLIC	?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z ; DGOptionDataRecv
PUBLIC	?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z ; DGMoveOtherServer
PUBLIC	?DGRecvPetItemInfo@@YAXPAE@Z			; DGRecvPetItemInfo
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CF@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0P@GMPEKMII@Test?5Data?5Send@		; `string'
PUBLIC	??_C@_0DB@KDJHGNDI@?0?5?$FLD?9?$DOG?5Recv?5GetCharList?$FN?0?5Acco@ ; `string'
PUBLIC	?__LINE__Var@?0??DataServerGetCharListRequest@@YAXF@Z@4JA ; `DataServerGetCharListRequest'::`1'::__LINE__Var
PUBLIC	??_C@_0DN@MBPEHAPP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	??_C@_0DB@LJIPDNBN@?0?5?$FLG?9?$DOD?5Req?5GetCharList?$FN?0?5Accou@ ; `string'
PUBLIC	?__LINE__Var@?0??JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA ; `JGGetCharacterInfo'::`1'::__LINE__Var
PUBLIC	??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character@ ; `string'
PUBLIC	??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN@ ; `string'
PUBLIC	??_C@_0CG@BPCBIHIK@?$KB?Z?$KB?Y?5ZEN?5MODIFY?5?$KB?Y?$KB?Z?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CF@ ; `string'
PUBLIC	??_C@_0EE@HOADODHJ@?0?5?$FLD?9?$DOG?5Recv?5MapJoin?$FN?5CharSelec@ ; `string'
PUBLIC	??_C@_0DG@DAPPAGFG@?0?5?$FLG?9?$DOD?5Req?5GetWarehouseList?$FN?0?5@ ; `string'
PUBLIC	??_C@_0DH@CCJJLLEJ@?0?5?$FLG?9?$DOC?5Recv?5GetWarehouseList?$FN?0@ ; `string'
PUBLIC	??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5@ ; `string'
PUBLIC	??_C@_0BP@KBPACLIK@?$FLERROR?$FN?5Item?5doesn?8t?5exists?5?$CFd@ ; `string'
PUBLIC	??_C@_0GG@PDKAJKAJ@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	?__LINE__Var@?0??ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z@4JA ; `ItemSerialCreateRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0FF@NJPANPON@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Special?5Shop?5Item?3?$CFs?5?$FL@ ; `string'
PUBLIC	??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5us@ ; `string'
PUBLIC	??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4@ ; `string'
PUBLIC	??_C@_0GA@EHKFCGJE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item@ ; `string'
PUBLIC	??_C@_0EO@DCIKCPFD@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Failed?5@ ; `string'
PUBLIC	??_C@_0EP@FICGMJHI@?$FLPickupSystem?$FN?5Error?5?3?5Failed?5T@ ; `string'
PUBLIC	??_C@_0BO@CNHMPMBL@?$FLPickUp?5System?$FN?5?3?5?$CFs?5Obtained@ ; `string'
PUBLIC	??_C@_0GD@LMECKDPM@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5@ ; `string'
PUBLIC	??_C@_0CE@HMMPKDMJ@?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CF@ ; `string'
PUBLIC	?__LINE__Var@?0??DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z@4JA ; `DGMoveOtherServer'::`1'::__LINE__Var
PUBLIC	??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd@ ; `string'
PUBLIC	??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr@ ; `string'
PUBLIC	??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0BD@IBAEEAEE@?A?$KC?$LM?S?$MA?L?5?A?$LO?$LH?a?$LF?K?$LE?O?$LE?Y?4@ ; `string'
PUBLIC	??_C@_0CD@HNLEMMHH@?$LK?P?G?R?5?$LM?$KN?$LJ?v?$LH?N?5?A?$KC?$LM?S?G?X?A?V?$LN?C?$LB?b?5?$LJ?Y?$LG?x?$LE?O@ ; `string'
PUBLIC	??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5info@ ; `string'
PUBLIC	??_C@_0CP@HBHBBGIF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5@ ; `string'
PUBLIC	??_C@_0CP@HLCJJJIG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@41200000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__time64:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
EXTRN	?Convert@CItem@@QAEXHEEEEEE@Z:PROC		; CItem::Convert
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?SetPetItemInfo@CItem@@QAEXHH@Z:PROC		; CItem::SetPetItemInfo
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?ItemByteConvert10@@YAXPAEQAVCItem@@H@Z:PROC	; ItemByteConvert10
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?IsItem@@YAHH@Z:PROC				; IsItem
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z:PROC	; MagicByteConvert
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObjGetAccountId@@YAPADH@Z:PROC		; gObjGetAccountId
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
EXTRN	?gObjSetCharacter@@YAHPAEH@Z:PROC		; gObjSetCharacter
EXTRN	?LevelSmallConvert@@YAEH@Z:PROC			; LevelSmallConvert
EXTRN	?gObjInventoryInsertItem@@YAEHVCItem@@@Z:PROC	; gObjInventoryInsertItem
EXTRN	?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z:PROC ; gObjInventoryInsertItem
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjCloseSet@@YAXHH@Z:PROC			; gObjCloseSet
EXTRN	?gObjStatTextSave@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; gObjStatTextSave
EXTRN	?gObjItemTextSave@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; gObjItemTextSave
EXTRN	?gObjWarehouseTextSave@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; gObjWarehouseTextSave
EXTRN	?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z:PROC ; gObjWarehouseInsertItemPos
EXTRN	?gObjWarehouseItemSet@@YAXHHE@Z:PROC		; gObjWarehouseItemSet
EXTRN	?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z:PROC ; gObjChaosBoxInsertItemPos
EXTRN	?gObjChaosItemSet@@YAXHHE@Z:PROC		; gObjChaosItemSet
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?gObjGetStatPointState@@YAXHAAF0@Z:PROC		; gObjGetStatPointState
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; GCMagicListMultiSend
EXTRN	?GCInventoryItemOneSend@@YAXHH@Z:PROC		; GCInventoryItemOneSend
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?GCUserWarehouseSend@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; GCUserWarehouseSend
EXTRN	?GCSkillKeySend@@YAXHPAEEEEEE@Z:PROC		; GCSkillKeySend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?GCWarehouseStateSend@@YAXHE@Z:PROC		; GCWarehouseStateSend
EXTRN	?CGRequestQuestInfo@@YAXH@Z:PROC		; CGRequestQuestInfo
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	?DBGetResetInfo@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CResetSystem::DBGetResetInfo
EXTRN	?DBLoadReset@CResetSystem@@QAEXPAE@Z:PROC	; CResetSystem::DBLoadReset
EXTRN	?DBAnsUpdateReset@CResetSystem@@QAEXPAE@Z:PROC	; CResetSystem::DBAnsUpdateReset
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z:PROC ; MapClass::MonsterItemDrop
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?Send@DBSockMng@@QAEHHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?PickUpActive@CPickUpSystem@@QAEHHH@Z:PROC	; CPickUpSystem::PickUpActive
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?FriendListRequest@@YAXH@Z:PROC			; FriendListRequest
EXTRN	?DGGuildMemberInfoRequest@@YAXH@Z:PROC		; DGGuildMemberInfoRequest
EXTRN	?QuestInfoSave@CQuestInfo@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CQuestInfo::QuestInfoSave
EXTRN	?gObjWarehouseDeleteItem@@YAEHH@Z:PROC		; gObjWarehouseDeleteItem
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?LogAdd_MonsterItemDrop@@3P6AXPADZZA:DWORD	; LogAdd_MonsterItemDrop
EXTRN	?LogAddTD_TempLog@@3P6AXPADZZA:DWORD		; LogAddTD_TempLog
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_GlobalConfig@@3VCGlobalConfig@@A:BYTE	; g_GlobalConfig
EXTRN	?g_ResetSystem@@3VCResetSystem@@A:BYTE		; g_ResetSystem
EXTRN	?g_TerrainManager@@3VCTerrainManager@@A:BYTE	; g_TerrainManager
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?gServerReady@@3HA:DWORD			; gServerReady
EXTRN	?GameServerPort@@3HA:DWORD			; GameServerPort
EXTRN	?DataServerConnected@@3HA:DWORD			; DataServerConnected
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?bCanWarehouseLock@@3HA:DWORD			; bCanWarehouseLock
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?szServerName@@3PADA:BYTE			; szServerName
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?s_PickUp@@3VCPickUpSystem@@A:BYTE		; s_PickUp
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CP@HLCJJJIG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5@
CONST	SEGMENT
??_C@_0CP@HLCJJJIG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5@ DB '['
	DB	'%s][%s][PW][%d,%s]serial:[%d] Level:%d Exp:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HBHBBGIF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5@
CONST	SEGMENT
??_C@_0CP@HBHBBGIF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5@ DB '['
	DB	'%s][%s][PI][%d,%s]serial:[%d] Level:%d Exp:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5info@
CONST	SEGMENT
??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5info@ DB 'Request to re'
	DB	'ceive petitem infomation doesn''t match the user %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HNLEMMHH@?$LK?P?G?R?5?$LM?$KN?$LJ?v?$LH?N?5?A?$KC?$LM?S?G?X?A?V?$LN?C?$LB?b?5?$LJ?Y?$LG?x?$LE?O@
CONST	SEGMENT
??_C@_0CD@HNLEMMHH@?$LK?P?G?R?5?$LM?$KN?$LJ?v?$LH?N?5?A?$KC?$LM?S?G?X?A?V?$LN?C?$LB?b?5?$LJ?Y?$LG?x?$LE?O@ DB 0baH
	DB	0d0H, 0c7H, 0d2H, ' ', 0bcH, 0adH, 0b9H, 0f6H, 0b7H, 0ceH, ' ', 0c1H
	DB	0a2H, 0bcH, 0d3H, 0c7H, 0d8H, 0c1H, 0d6H, 0bdH, 0c3H, 0b1H, 0e2H
	DB	' ', 0b9H, 0d9H, 0b6H, 0f8H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IBAEEAEE@?A?$KC?$LM?S?$MA?L?5?A?$LO?$LH?a?$LF?K?$LE?O?$LE?Y?4@
CONST	SEGMENT
??_C@_0BD@IBAEEAEE@?A?$KC?$LM?S?$MA?L?5?A?$LO?$LH?a?$LF?K?$LE?O?$LE?Y?4@ DB 0c1H
	DB	0a2H, 0bcH, 0d3H, 0c0H, 0ccH, ' ', 0c1H, 0beH, 0b7H, 0e1H, 0b5H
	DB	0cbH, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'CharTrasfer] Success [%s][%s] (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr@
CONST	SEGMENT
??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr@ DB 0b9H
	DB	0aeH, 0c1H, 0a6H, ' ', 0b9H, 0dfH, 0bbH, 0fdH, 0bdH, 0c3H, ' c'
	DB	'hange@webzen.co.kr', 0b7H, 0ceH, ' ', 0b9H, 0aeH, 0c0H, 0c7H, 0c7H
	DB	0d8H, ' ', 0c1H, 0d6H, 0bdH, 0c3H, 0b1H, 0e2H, 0b9H, 0d9H, 0b6H
	DB	0f8H, 0b4H, 0cfH, 0b4H, 0d9H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd@
CONST	SEGMENT
??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd@ DB '['
	DB	'CharTrasfer] Fail [%s][%s] (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z@4JA DD 0f0cH ; `DGMoveOtherServer'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@HMMPKDMJ@?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CF@
CONST	SEGMENT
??_C@_0CE@HMMPKDMJ@?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CF@ DB '%'
	DB	'd', 09H, '%d', 09H, '%d', 09H, '%d', 09H, '%d', 09H, '%d', 09H
	DB	'%d', 09H, '%d', 09H, '%d', 09H, '%d', 09H, '%d', 09H, '%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@LMECKDPM@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5@
CONST	SEGMENT
??_C@_0GD@LMECKDPM@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5@ DB 'M'
	DB	'onster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d'
	DB	'] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CNHMPMBL@?$FLPickUp?5System?$FN?5?3?5?$CFs?5Obtained@
CONST	SEGMENT
??_C@_0BO@CNHMPMBL@?$FLPickUp?5System?$FN?5?3?5?$CFs?5Obtained@ DB '[Pick'
	DB	'Up System] : %s Obtained', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@FICGMJHI@?$FLPickupSystem?$FN?5Error?5?3?5Failed?5T@
CONST	SEGMENT
??_C@_0EP@FICGMJHI@?$FLPickupSystem?$FN?5Error?5?3?5Failed?5T@ DB '[Picku'
	DB	'pSystem] Error : Failed To Insert Item Type:%d, TypeIndex:%d '
	DB	'to [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@DCIKCPFD@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Failed?5@
CONST	SEGMENT
??_C@_0EO@DCIKCPFD@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Failed?5@ DB '[Mu_2A'
	DB	'nv_Event] Error : Failed To Gift Item Type:%d, TypeIndex:%d t'
	DB	'o [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@EHKFCGJE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item@
CONST	SEGMENT
??_C@_0GA@EHKFCGJE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item@ DB '['
	DB	'%s][%s] CBMix Item Create Item:%s [%d][%d] [%d][%d][%d][%d] E'
	DB	'x:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4@
CONST	SEGMENT
??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4@ DB 'error-L2: Chao'
	DB	'sBox not used.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5us@
CONST	SEGMENT
??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5us@ DB 'error-L2: Da'
	DB	'rkTrainerBox not used.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@NJPANPON@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Special?5Shop?5Item?3?$CFs?5?$FL@
CONST	SEGMENT
??_C@_0FF@NJPANPON@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Special?5Shop?5Item?3?$CFs?5?$FL@ DB '['
	DB	'%s][%s] Special Shop Item:%s [%d][%d] [%d][%d][%d][%d] Ex:[%d'
	DB	',%d,%d,%d,%d] Set:[%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@ DB 'error-L3 [%'
	DB	's][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z@4JA DD 0ba9H ; `ItemSerialCreateRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0GG@PDKAJKAJ@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0GG@PDKAJKAJ@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5@ DB 'Mon'
	DB	'ster Item Drop Request [%s] [%d][%d][%d] : [%s][%d][%d][%d][%'
	DB	'd] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KBPACLIK@?$FLERROR?$FN?5Item?5doesn?8t?5exists?5?$CFd@
CONST	SEGMENT
??_C@_0BP@KBPACLIK@?$FLERROR?$FN?5Item?5doesn?8t?5exists?5?$CFd@ DB '[ERR'
	DB	'OR] Item doesn''t exists %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5@
CONST	SEGMENT
??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5@ DB '['
	DB	'%s][%s] WareHouse Save Fail : Not Open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@CCJJLLEJ@?0?5?$FLG?9?$DOC?5Recv?5GetWarehouseList?$FN?0@
CONST	SEGMENT
??_C@_0DH@CCJJLLEJ@?0?5?$FLG?9?$DOC?5Recv?5GetWarehouseList?$FN?0@ DB ', '
	DB	'[G->C Recv GetWarehouseList], Account [%s], IP [%s] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DAPPAGFG@?0?5?$FLG?9?$DOD?5Req?5GetWarehouseList?$FN?0?5@
CONST	SEGMENT
??_C@_0DG@DAPPAGFG@?0?5?$FLG?9?$DOD?5Req?5GetWarehouseList?$FN?0?5@ DB ','
	DB	' [G->D Req GetWarehouseList], Account [%s], IP [%s] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@HOADODHJ@?0?5?$FLD?9?$DOG?5Recv?5MapJoin?$FN?5CharSelec@
CONST	SEGMENT
??_C@_0EE@HOADODHJ@?0?5?$FLD?9?$DOG?5Recv?5MapJoin?$FN?5CharSelec@ DB ', '
	DB	'[D->G Recv MapJoin] CharSelected, Account [%s], IP [%s], Name'
	DB	'[%s]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BPCBIHIK@?$KB?Z?$KB?Y?5ZEN?5MODIFY?5?$KB?Y?$KB?Z?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CF@
CONST	SEGMENT
??_C@_0CG@BPCBIHIK@?$KB?Z?$KB?Y?5ZEN?5MODIFY?5?$KB?Y?$KB?Z?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CF@ DB 0a1H
	DB	0daH, 0a1H, 0d9H, ' ZEN MODIFY ', 0a1H, 0d9H, 0a1H, 0daH, ' [%'
	DB	's][%s] %d -> 0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN@
CONST	SEGMENT
??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN@ DB '[Ant'
	DB	'i-HACK][JGGetCharacterInfo] Attempted Character-Copy by doubl'
	DB	'e logging [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character@
CONST	SEGMENT
??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character@ DB 'error-L1 : '
	DB	'Load Block Character infomation', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA DD 06c3H ; `JGGetCharacterInfo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DB@LJIPDNBN@?0?5?$FLG?9?$DOD?5Req?5GetCharList?$FN?0?5Accou@
CONST	SEGMENT
??_C@_0DB@LJIPDNBN@?0?5?$FLG?9?$DOD?5Req?5GetCharList?$FN?0?5Accou@ DB ','
	DB	' [G->D Req GetCharList], Account [%s], IP [%s] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@MBPEHAPP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0DN@MBPEHAPP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onl'
	DB	'ine\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DataServerGetCharListRequest@@YAXF@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DataServerGetCharListRequest@@YAXF@Z@4JA DD 060dH ; `DataServerGetCharListRequest'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DB@KDJHGNDI@?0?5?$FLD?9?$DOG?5Recv?5GetCharList?$FN?0?5Acco@
CONST	SEGMENT
??_C@_0DB@KDJHGNDI@?0?5?$FLD?9?$DOG?5Recv?5GetCharList?$FN?0?5Acco@ DB ','
	DB	' [D->G Recv GetCharList], Account [%s], IP [%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GMPEKMII@Test?5Data?5Send@
CONST	SEGMENT
??_C@_0P@GMPEKMII@Test?5Data?5Send@ DB 'Test Data Send', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CF@
CONST	SEGMENT
??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CF@ DB 'err'
	DB	'or-L2DataServer RECV : %d (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?DGRecvPetItemInfo@@YAXPAE@Z
_TEXT	SEGMENT
$T1 = -108						; size = 4
_n$2 = -40						; size = 4
_n$3 = -36						; size = 4
_ReCalc$4 = -32						; size = 4
_szAccountId$ = -28					; size = 11
_aIndex$ = -16						; size = 4
_pPetItemInfo$ = -12					; size = 4
_lpMsg$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
?DGRecvPetItemInfo@@YAXPAE@Z PROC			; DGRecvPetItemInfo, COMDAT

; 3980 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3981 : 	LPSDHP_RECV_PETITEM_INFO lpMsg = (LPSDHP_RECV_PETITEM_INFO)lpData; 

  00013	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 3982 : 	Recv_PetItem_Info*	pPetItemInfo = (Recv_PetItem_Info*)(lpData+sizeof(SDHP_RECV_PETITEM_INFO));

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]
  0001c	83 c0 14	 add	 eax, 20			; 00000014H
  0001f	89 45 f4	 mov	 DWORD PTR _pPetItemInfo$[ebp], eax

; 3983 : 
; 3984 : 	int		aIndex = lpMsg->Number;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00025	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00029	89 4d f0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 3985 : 	char	szAccountId[MAX_IDSTRING+1];
; 3986 : 
; 3987 : 	szAccountId[MAX_IDSTRING] = '\0';

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	6b c8 0a	 imul	 ecx, eax, 10
  00034	89 4d 94	 mov	 DWORD PTR $T1[ebp], ecx
  00037	83 7d 94 0b	 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  0003b	73 02		 jae	 SHORT $LN17@DGRecvPetI
  0003d	eb 05		 jmp	 SHORT $LN18@DGRecvPetI
$LN17@DGRecvPetI:
  0003f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN18@DGRecvPetI:
  00044	8b 55 94	 mov	 edx, DWORD PTR $T1[ebp]
  00047	c6 44 15 e4 00	 mov	 BYTE PTR _szAccountId$[ebp+edx], 0

; 3988 : 	memcpy(szAccountId, lpMsg->AccountID, MAX_IDSTRING);

  0004c	6a 0a		 push	 10			; 0000000aH
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00051	83 c0 04	 add	 eax, 4
  00054	50		 push	 eax
  00055	8d 4d e4	 lea	 ecx, DWORD PTR _szAccountId$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _memcpy
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3989 : 	if( gObjIsAccontConnect(aIndex, szAccountId) == FALSE )

  00061	8d 45 e4	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00064	50		 push	 eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0006e	83 c4 08	 add	 esp, 8
  00071	85 c0		 test	 eax, eax
  00073	75 25		 jne	 SHORT $LN8@DGRecvPetI

; 3990 : 	{
; 3991 : 		LogAddC(LOGC_RED, "Request to receive petitem infomation doesn't match the user %s",

  00075	8d 45 e4	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00078	50		 push	 eax
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5info@
  0007e	6a 02		 push	 2
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3992 : 				szAccountId);
; 3993 : 		CloseClient ( aIndex );

  00089	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00092	83 c4 04	 add	 esp, 4

; 3994 : 		return;

  00095	e9 10 02 00 00	 jmp	 $LN16@DGRecvPetI
$LN8@DGRecvPetI:

; 3995 : 	}
; 3996 : 
; 3997 : 	if( lpMsg->InvenType == 0 )

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0009d	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  000a1	85 c9		 test	 ecx, ecx
  000a3	0f 85 14 01 00
	00		 jne	 $LN9@DGRecvPetI

; 3998 : 	{	// 인벤토리
; 3999 : 		BOOL	ReCalc = FALSE;

  000a9	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _ReCalc$4[ebp], 0

; 4000 : 		for( int n=0; n<lpMsg->nCount; n++)

  000b0	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _n$3[ebp], 0
  000b7	eb 09		 jmp	 SHORT $LN4@DGRecvPetI
$LN2@DGRecvPetI:
  000b9	8b 45 dc	 mov	 eax, DWORD PTR _n$3[ebp]
  000bc	83 c0 01	 add	 eax, 1
  000bf	89 45 dc	 mov	 DWORD PTR _n$3[ebp], eax
$LN4@DGRecvPetI:
  000c2	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000c5	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  000c9	39 4d dc	 cmp	 DWORD PTR _n$3[ebp], ecx
  000cc	0f 8d d4 00 00
	00		 jge	 $LN3@DGRecvPetI

; 4001 : 		{
; 4002 : 			if( pPetItemInfo[n].nPos < MAX_EQUIPMENT )

  000d2	8b 45 dc	 mov	 eax, DWORD PTR _n$3[ebp]
  000d5	c1 e0 04	 shl	 eax, 4
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  000db	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000df	83 fa 0c	 cmp	 edx, 12			; 0000000cH
  000e2	7d 07		 jge	 SHORT $LN11@DGRecvPetI

; 4003 : 			{
; 4004 : 				ReCalc = TRUE;

  000e4	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _ReCalc$4[ebp], 1
$LN11@DGRecvPetI:

; 4005 : 			}
; 4006 : 
; 4007 : 			if( gObj[aIndex].pInventory[pPetItemInfo[n].nPos].IsItem() && 

  000eb	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f2	8b 4d dc	 mov	 ecx, DWORD PTR _n$3[ebp]
  000f5	c1 e1 04	 shl	 ecx, 4
  000f8	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  000fb	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  000ff	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00105	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010b	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00112	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00117	85 c0		 test	 eax, eax
  00119	0f 84 82 00 00
	00		 je	 $LN12@DGRecvPetI
  0011f	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00126	8b 4d dc	 mov	 ecx, DWORD PTR _n$3[ebp]
  00129	c1 e1 04	 shl	 ecx, 4
  0012c	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  0012f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00133	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00139	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013f	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00146	8b 4d dc	 mov	 ecx, DWORD PTR _n$3[ebp]
  00149	c1 e1 04	 shl	 ecx, 4
  0014c	8b 75 f4	 mov	 esi, DWORD PTR _pPetItemInfo$[ebp]
  0014f	8b 14 10	 mov	 edx, DWORD PTR [eax+edx]
  00152	3b 54 0e 04	 cmp	 edx, DWORD PTR [esi+ecx+4]
  00156	75 49		 jne	 SHORT $LN12@DGRecvPetI

; 4008 : 				gObj[aIndex].pInventory[pPetItemInfo[n].nPos].m_Number == pPetItemInfo[n].nSerial)
; 4009 : 			{	
; 4010 : 
; 4011 : #if TESTSERVER == 1
; 4012 : 				DebugOutput(aIndex, "[인벤] %s/%d Lv:%d Exp:%d", 
; 4013 : 							gObj[aIndex].pInventory[pPetItemInfo[n].nPos].GetName(),
; 4014 : 							pPetItemInfo[n].nPos, 
; 4015 : 							pPetItemInfo[n].Level, pPetItemInfo[n].Exp);
; 4016 : #endif
; 4017 : 
; 4018 : 				gObj[aIndex].pInventory[pPetItemInfo[n].nPos].SetPetItemInfo(pPetItemInfo[n].Level, pPetItemInfo[n].Exp);

  00158	8b 45 dc	 mov	 eax, DWORD PTR _n$3[ebp]
  0015b	c1 e0 04	 shl	 eax, 4
  0015e	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  00161	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00165	52		 push	 edx
  00166	8b 45 dc	 mov	 eax, DWORD PTR _n$3[ebp]
  00169	c1 e0 04	 shl	 eax, 4
  0016c	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  0016f	0f b6 54 01 08	 movzx	 edx, BYTE PTR [ecx+eax+8]
  00174	52		 push	 edx
  00175	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0017c	8b 4d dc	 mov	 ecx, DWORD PTR _n$3[ebp]
  0017f	c1 e1 04	 shl	 ecx, 4
  00182	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  00185	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00189	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  0018f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00195	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0019c	e8 00 00 00 00	 call	 ?SetPetItemInfo@CItem@@QAEXHH@Z ; CItem::SetPetItemInfo
$LN12@DGRecvPetI:

; 4019 : 			}
; 4020 : 		}

  001a1	e9 13 ff ff ff	 jmp	 $LN2@DGRecvPetI
$LN3@DGRecvPetI:

; 4021 : 
; 4022 : 		if( ReCalc )

  001a6	83 7d e0 00	 cmp	 DWORD PTR _ReCalc$4[ebp], 0
  001aa	74 0c		 je	 SHORT $LN13@DGRecvPetI

; 4023 : 		{
; 4024 : 			gObjCalCharacter(aIndex);

  001ac	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  001b5	83 c4 04	 add	 esp, 4
$LN13@DGRecvPetI:

; 4025 : 		}
; 4026 : 	}

  001b8	e9 ed 00 00 00	 jmp	 $LN16@DGRecvPetI
$LN9@DGRecvPetI:

; 4027 : 	else if( lpMsg->InvenType == 1 )

  001bd	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001c0	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  001c4	83 f9 01	 cmp	 ecx, 1
  001c7	0f 85 dd 00 00
	00		 jne	 $LN16@DGRecvPetI

; 4028 : 	{	// 창고
; 4029 : 		for( int n=0; n<lpMsg->nCount; n++)

  001cd	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _n$2[ebp], 0
  001d4	eb 09		 jmp	 SHORT $LN7@DGRecvPetI
$LN5@DGRecvPetI:
  001d6	8b 45 d8	 mov	 eax, DWORD PTR _n$2[ebp]
  001d9	83 c0 01	 add	 eax, 1
  001dc	89 45 d8	 mov	 DWORD PTR _n$2[ebp], eax
$LN7@DGRecvPetI:
  001df	8b 45 f8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001e2	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  001e6	39 4d d8	 cmp	 DWORD PTR _n$2[ebp], ecx
  001e9	0f 8d bb 00 00
	00		 jge	 $LN16@DGRecvPetI

; 4030 : 		{
; 4031 : 			if( gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].IsItem() && 

  001ef	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001f6	8b 4d d8	 mov	 ecx, DWORD PTR _n$2[ebp]
  001f9	c1 e1 04	 shl	 ecx, 4
  001fc	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  001ff	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00203	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00209	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0020f	03 8c 02 94 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3220]
  00216	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0021b	85 c0		 test	 eax, eax
  0021d	0f 84 82 00 00
	00		 je	 $LN15@DGRecvPetI
  00223	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0022a	8b 4d d8	 mov	 ecx, DWORD PTR _n$2[ebp]
  0022d	c1 e1 04	 shl	 ecx, 4
  00230	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  00233	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00237	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00243	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3220]
  0024a	8b 4d d8	 mov	 ecx, DWORD PTR _n$2[ebp]
  0024d	c1 e1 04	 shl	 ecx, 4
  00250	8b 75 f4	 mov	 esi, DWORD PTR _pPetItemInfo$[ebp]
  00253	8b 14 10	 mov	 edx, DWORD PTR [eax+edx]
  00256	3b 54 0e 04	 cmp	 edx, DWORD PTR [esi+ecx+4]
  0025a	75 49		 jne	 SHORT $LN15@DGRecvPetI

; 4032 : 				gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].m_Number == pPetItemInfo[n].nSerial)
; 4033 : 			{	
; 4034 : #if TESTSERVER == 1
; 4035 : 				DebugOutput(aIndex, "[창고] %s/%d Lv:%d Exp:%d", 
; 4036 : 							gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].GetName(),
; 4037 : 							pPetItemInfo[n].nPos, 
; 4038 : 							pPetItemInfo[n].Level, pPetItemInfo[n].Exp);				
; 4039 : #endif
; 4040 : 
; 4041 : 				gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].SetPetItemInfo(pPetItemInfo[n].Level, pPetItemInfo[n].Exp);

  0025c	8b 45 d8	 mov	 eax, DWORD PTR _n$2[ebp]
  0025f	c1 e0 04	 shl	 eax, 4
  00262	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  00265	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  00269	52		 push	 edx
  0026a	8b 45 d8	 mov	 eax, DWORD PTR _n$2[ebp]
  0026d	c1 e0 04	 shl	 eax, 4
  00270	8b 4d f4	 mov	 ecx, DWORD PTR _pPetItemInfo$[ebp]
  00273	0f b6 54 01 08	 movzx	 edx, BYTE PTR [ecx+eax+8]
  00278	52		 push	 edx
  00279	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00280	8b 4d d8	 mov	 ecx, DWORD PTR _n$2[ebp]
  00283	c1 e1 04	 shl	 ecx, 4
  00286	8b 55 f4	 mov	 edx, DWORD PTR _pPetItemInfo$[ebp]
  00289	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  0028d	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00293	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00299	03 8c 02 94 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3220]
  002a0	e8 00 00 00 00	 call	 ?SetPetItemInfo@CItem@@QAEXHH@Z ; CItem::SetPetItemInfo
$LN15@DGRecvPetI:

; 4042 : 			}
; 4043 : 		}

  002a5	e9 2c ff ff ff	 jmp	 $LN5@DGRecvPetI
$LN16@DGRecvPetI:

; 4044 : 	}	
; 4045 : }

  002aa	5f		 pop	 edi
  002ab	5e		 pop	 esi
  002ac	5b		 pop	 ebx
  002ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b0	33 cd		 xor	 ecx, ebp
  002b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b7	8b e5		 mov	 esp, ebp
  002b9	5d		 pop	 ebp
  002ba	c3		 ret	 0
?DGRecvPetItemInfo@@YAXPAE@Z ENDP			; DGRecvPetItemInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z
_TEXT	SEGMENT
_pResult$1 = -8						; size = 4
_lpObj$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z PROC ; DGMoveOtherServer, COMDAT

; 3852 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3853 : 	if( gObjIsConnectedGP(lpMsg->Number) == FALSE ) 

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax
  0001b	75 23		 jne	 SHORT $LN2@DGMoveOthe

; 3854 : 	{
; 3855 : 		LogAddC(LOGC_RED, "error-L3 [%s][%d]", __FILE__,__LINE__);

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z@4JA
  00022	83 c0 03	 add	 eax, 3
  00025	50		 push	 eax
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MBPEHAPP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
  00030	6a 02		 push	 2
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00038	83 c4 10	 add	 esp, 16			; 00000010H

; 3856 : 		return;

  0003b	e9 08 01 00 00	 jmp	 $LN1@DGMoveOthe
$LN2@DGMoveOthe:

; 3857 : 	}
; 3858 : 	
; 3859 : 	LPOBJECTSTRUCT lpObj = &gObj[lpMsg->Number];	

  00040	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00043	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  00047	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  0004d	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00053	89 55 fc	 mov	 DWORD PTR _lpObj$[ebp], edx

; 3860 : 	if( lpMsg->Result != 0 )

  00056	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00059	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0005d	85 c9		 test	 ecx, ecx
  0005f	74 6b		 je	 SHORT $LN3@DGMoveOthe

; 3861 : 	{	// 서버 이전 실패 했다
; 3862 : 		PMSG_DEFRESULT pResult;	
; 3863 : 		PHeadSetB((LPBYTE)&pResult, 0x99, sizeof(pResult));

  00061	6a 04		 push	 4
  00063	68 99 00 00 00	 push	 153			; 00000099H
  00068	8d 45 f8	 lea	 eax, DWORD PTR _pResult$1[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3864 : 		pResult.result	   = 0x01;

  00074	c6 45 fb 01	 mov	 BYTE PTR _pResult$1[ebp+3], 1

; 3865 : 		DataSend(lpMsg->Number, (LPBYTE)&pResult, pResult.h.size);

  00078	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$1[ebp+1]
  0007c	50		 push	 eax
  0007d	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$1[ebp]
  00080	51		 push	 ecx
  00081	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00084	0f bf 42 0e	 movsx	 eax, WORD PTR [edx+14]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3866 : 
; 3867 : 		LogAddTD("[CharTrasfer] Fail [%s][%s] (%d)", lpObj->AccountID, lpObj->Name, lpMsg->Result);

  00091	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00094	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00098	51		 push	 ecx
  00099	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009c	83 c2 73	 add	 edx, 115		; 00000073H
  0009f	52		 push	 edx
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a3	83 c0 68	 add	 eax, 104		; 00000068H
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd@
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b2	83 c4 10	 add	 esp, 16			; 00000010H

; 3868 : #ifdef GAMESERVER_DIVISION
; 3869 : 		lpObj->m_MoveOtherServer = FALSE;
; 3870 : #endif
; 3871 : 
; 3872 : 		GCServerMsgStringSend("문제 발생시 change@webzen.co.kr로 문의해 주시기바랍니다", lpObj->m_Index, 1);

  000b5	6a 01		 push	 1
  000b7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bc	51		 push	 ecx
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr@
  000c2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3873 : 		return;

  000ca	eb 7c		 jmp	 SHORT $LN1@DGMoveOthe
$LN3@DGMoveOthe:

; 3874 : 	}
; 3875 : 
; 3876 : 	LogAddTD("[CharTrasfer] Success [%s][%s] (%d)", lpObj->AccountID, lpObj->Name, lpMsg->Result);

  000cc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000cf	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  000d3	51		 push	 ecx
  000d4	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d7	83 c2 73	 add	 edx, 115		; 00000073H
  000da	52		 push	 edx
  000db	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000de	83 c0 68	 add	 eax, 104		; 00000068H
  000e1	50		 push	 eax
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ed	83 c4 10	 add	 esp, 16			; 00000010H

; 3877 : 
; 3878 : 	GCServerMsgStringSend("접속이 종료됩니다.", lpObj->m_Index, 1);	

  000f0	6a 01		 push	 1
  000f2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f7	51		 push	 ecx
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IBAEEAEE@?A?$KC?$LM?S?$MA?L?5?A?$LO?$LH?a?$LF?K?$LE?O?$LE?Y?4@
  000fd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3879 : 	GCServerMsgStringSend("분할 서버로 접속해주시기 바랍니다.", lpObj->m_Index, 1);	

  00105	6a 01		 push	 1
  00107	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010c	51		 push	 ecx
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HNLEMMHH@?$LK?P?G?R?5?$LM?$KN?$LJ?v?$LH?N?5?A?$KC?$LM?S?G?X?A?V?$LN?C?$LB?b?5?$LJ?Y?$LG?x?$LE?O@
  00112	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00117	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3880 : 
; 3881 : 	// 마지막으로 저장한번 하고
; 3882 : 	GJSetCharacterInfo(lpObj, lpObj->m_Index);

  0011a	6a 00		 push	 0
  0011c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	51		 push	 ecx
  00122	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00125	52		 push	 edx
  00126	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3883 : 
; 3884 : 	// 창고는 저장안되게 만들어 두고.
; 3885 : 	lpObj->LoadWareHouseInfo = FALSE;

  0012e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00131	c6 80 88 0e 00
	00 00		 mov	 BYTE PTR [eax+3720], 0

; 3886 : 
; 3887 : 	// 캐릭터를 서버 선택화면으로 보낸다
; 3888 : 	gObjCloseSet(lpObj->m_Index, CL_SERVERLIST);

  00138	6a 02		 push	 2
  0013a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013f	51		 push	 ecx
  00140	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  00145	83 c4 08	 add	 esp, 8
$LN1@DGMoveOthe:

; 3889 : #ifdef GAMESERVER_DIVISION
; 3890 : 	lpObj->m_MoveOtherServer = FALSE;
; 3891 : #endif
; 3892 : }

  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	5b		 pop	 ebx
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z ENDP ; DGMoveOtherServer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
_szName$ = -20						; size = 11
_aIndex$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z PROC ; DGOptionDataRecv, COMDAT

; 3818 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3819 : 	int aIndex = lpMsg->aIndex;

  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	89 4d f8	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 3820 : 	char szName[MAX_IDSTRING+1];
; 3821 : 
; 3822 : 	if( aIndex < 0 || aIndex >= MAX_OBJECT)

  0001c	83 7d f8 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00020	7c 09		 jl	 SHORT $LN3@DGOptionDa
  00022	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7400 ; 00001ce8H
  00029	7c 05		 jl	 SHORT $LN2@DGOptionDa
$LN3@DGOptionDa:

; 3823 : 		return;

  0002b	e9 a4 00 00 00	 jmp	 $LN5@DGOptionDa
$LN2@DGOptionDa:

; 3824 : 
; 3825 : 	memset(szName, 0, MAX_IDSTRING+1);

  00030	6a 0b		 push	 11			; 0000000bH
  00032	6a 00		 push	 0
  00034	8d 45 ec	 lea	 eax, DWORD PTR _szName$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _memset
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3826 : 	memcpy(szName, lpMsg->Name, MAX_IDSTRING);

  00040	6a 0a		 push	 10			; 0000000aH
  00042	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00045	83 c0 08	 add	 eax, 8
  00048	50		 push	 eax
  00049	8d 4d ec	 lea	 ecx, DWORD PTR _szName$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 _memcpy
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3827 : 
; 3828 : 	szName[MAX_IDSTRING] = '\0';

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	6b c8 0a	 imul	 ecx, eax, 10
  0005d	89 4d a8	 mov	 DWORD PTR $T1[ebp], ecx
  00060	83 7d a8 0b	 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00064	73 02		 jae	 SHORT $LN6@DGOptionDa
  00066	eb 05		 jmp	 SHORT $LN7@DGOptionDa
$LN6@DGOptionDa:
  00068	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN7@DGOptionDa:
  0006d	8b 55 a8	 mov	 edx, DWORD PTR $T1[ebp]
  00070	c6 44 15 ec 00	 mov	 BYTE PTR _szName$[ebp+edx], 0

; 3829 : 
; 3830 : 	if( strcmp(gObj[aIndex].Name, szName) != 0 )

  00075	8d 45 ec	 lea	 eax, DWORD PTR _szName$[ebp]
  00078	50		 push	 eax
  00079	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00080	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00086	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _strcmp
  00090	83 c4 08	 add	 esp, 8
  00093	85 c0		 test	 eax, eax
  00095	74 02		 je	 SHORT $LN4@DGOptionDa

; 3831 : 	{
; 3832 : 		return;

  00097	eb 3b		 jmp	 SHORT $LN5@DGOptionDa
$LN4@DGOptionDa:

; 3833 : 	}
; 3834 : 
; 3835 : #ifdef UPDATE_OPTIONKEY_LEVEL_20080116
; 3836 : 	GCSkillKeySend(aIndex, lpMsg->SkillKeyBuffer, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, lpMsg->ChatWindow, lpMsg->RkeyDefine, lpMsg->QWERLevel);
; 3837 : #else	// UPDATE_OPTIONKEY_LEVEL_20080116	
; 3838 : #ifdef VER_CHATWINDOW_OPTION	
; 3839 : #ifdef ADD_SEASON_3_NEW_UI_20071122 
; 3840 : 	GCSkillKeySend(aIndex, lpMsg->SkillKeyBuffer, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, lpMsg->ChatWindow, lpMsg->RkeyDefine);
; 3841 : #else
; 3842 : 	GCSkillKeySend(aIndex, lpMsg->SkillKeyBuffer, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, lpMsg->ChatWindow);

  00099	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0009c	0f b6 48 20	 movzx	 ecx, BYTE PTR [eax+32]
  000a0	51		 push	 ecx
  000a1	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000a4	0f b6 42 1f	 movzx	 eax, BYTE PTR [edx+31]
  000a8	50		 push	 eax
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000ac	0f b6 51 1e	 movzx	 edx, BYTE PTR [ecx+30]
  000b0	52		 push	 edx
  000b1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000b4	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  000b8	51		 push	 ecx
  000b9	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000bc	0f b6 42 1c	 movzx	 eax, BYTE PTR [edx+28]
  000c0	50		 push	 eax
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000c4	83 c1 12	 add	 ecx, 18			; 00000012H
  000c7	51		 push	 ecx
  000c8	8b 55 f8	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ?GCSkillKeySend@@YAXHPAEEEEEE@Z ; GCSkillKeySend
  000d1	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN5@DGOptionDa:

; 3843 : #endif
; 3844 : #else
; 3845 : 	GCSkillKeySend(aIndex, lpMsg->SkillKeyBuffer, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine);
; 3846 : #endif
; 3847 : #endif	// UPDATE_OPTIONKEY_LEVEL_20080116
; 3848 : }

  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	33 cd		 xor	 ecx, ebp
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z ENDP ; DGOptionDataRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z
_TEXT	SEGMENT
$T1 = -100						; size = 4
_lpObj$ = -32						; size = 4
_pResult$ = -28						; size = 8
_aIndex$ = -20						; size = 4
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z PROC ; GDGetWarehouseNoItem, COMDAT

; 2715 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2716 : 	char szId[MAX_IDSTRING+1];
; 2717 : 	int  aIndex=lpMsg->aIndex;

  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  0001a	89 4d ec	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2718 : 
; 2719 : 	PMSG_TALKRESULT		pResult;
; 2720 : 
; 2721 : 	szId[MAX_IDSTRING] = '\0';

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	6b c8 0a	 imul	 ecx, eax, 10
  00025	89 4d 9c	 mov	 DWORD PTR $T1[ebp], ecx
  00028	83 7d 9c 0b	 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  0002c	73 02		 jae	 SHORT $LN6@GDGetWareh
  0002e	eb 05		 jmp	 SHORT $LN7@GDGetWareh
$LN6@GDGetWareh:
  00030	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN7@GDGetWareh:
  00035	8b 55 9c	 mov	 edx, DWORD PTR $T1[ebp]
  00038	c6 44 15 f0 00	 mov	 BYTE PTR _szId$[ebp+edx], 0

; 2722 : 	memcpy(szId, lpMsg->AccountID, MAX_IDSTRING);

  0003d	6a 0a		 push	 10			; 0000000aH
  0003f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00042	83 c0 03	 add	 eax, 3
  00045	50		 push	 eax
  00046	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _memcpy
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2723 : 	if( gObjIsAccontConnect(aIndex, szId) == FALSE )

  00052	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00055	50		 push	 eax
  00056	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0005f	83 c4 08	 add	 esp, 8
  00062	85 c0		 test	 eax, eax
  00064	75 29		 jne	 SHORT $LN2@GDGetWareh

; 2724 : 	{
; 2725 : 		LogAddC(LOGC_RED, lMsg.Get(431), szId, aIndex);

  00066	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00069	50		 push	 eax
  0006a	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0006d	51		 push	 ecx
  0006e	68 af 01 00 00	 push	 431			; 000001afH
  00073	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0007e	50		 push	 eax
  0007f	6a 02		 push	 2
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 2726 : 		return;

  0008a	e9 c4 00 00 00	 jmp	 $LN5@GDGetWareh
$LN2@GDGetWareh:

; 2727 : 	}
; 2728 : 	LPOBJECTSTRUCT	lpObj;
; 2729 : 
; 2730 : 	lpObj = &gObj[aIndex];

  0008f	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00096	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009c	89 45 e0	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2731 : 	if( lpObj->m_IfState.type == I_WAREHOUSE )

  0009f	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a2	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000a8	c0 e9 04	 shr	 cl, 4
  000ab	80 e1 0f	 and	 cl, 15			; 0000000fH
  000ae	0f b6 d1	 movzx	 edx, cl
  000b1	83 fa 06	 cmp	 edx, 6
  000b4	0f 85 85 00 00
	00		 jne	 $LN3@GDGetWareh

; 2732 : 	{
; 2733 : 		if( lpObj->m_IfState.state == 0 )

  000ba	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bd	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000c3	c0 e9 02	 shr	 cl, 2
  000c6	80 e1 03	 and	 cl, 3
  000c9	0f b6 d1	 movzx	 edx, cl
  000cc	85 d2		 test	 edx, edx
  000ce	75 6f		 jne	 SHORT $LN3@GDGetWareh

; 2734 : 		{
; 2735 : 			lpObj->m_IfState.state	= 1;

  000d0	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d3	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000d9	80 e1 f3	 and	 cl, 243			; 000000f3H
  000dc	80 c9 04	 or	 cl, 4
  000df	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e2	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 2736 : 			lpObj->WarehouseSave	= TRUE;

  000e8	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000eb	c7 80 a8 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3240], 1

; 2737 : 
; 2738 : 			pResult.h.c        = PMHCE_BYTE;

  000f5	c6 45 e4 c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 2739 : 			pResult.h.headcode = 0x30;

  000f9	c6 45 e6 30	 mov	 BYTE PTR _pResult$[ebp+2], 48 ; 00000030H

; 2740 : 			pResult.h.size     = sizeof( pResult );

  000fd	c6 45 e5 08	 mov	 BYTE PTR _pResult$[ebp+1], 8

; 2741 : 			pResult.result     = 0x02;

  00101	c6 45 e7 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 2742 : 			DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  00105	0f b6 45 e5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00109	50		 push	 eax
  0010a	8d 4d e4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0010d	51		 push	 ecx
  0010e	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00111	8b 02		 mov	 eax, DWORD PTR [edx]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2743 : 			LogAddC(LOGC_RED, lMsg.Get(432), lpObj->Name);

  0011c	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011f	83 c0 73	 add	 eax, 115		; 00000073H
  00122	50		 push	 eax
  00123	68 b0 01 00 00	 push	 432			; 000001b0H
  00128	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00133	50		 push	 eax
  00134	6a 02		 push	 2
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GDGetWareh:

; 2744 : 			
; 2745 : #ifdef MODIFY_NEW_ACCOUNT_WAREHOUSE_ZEN_BUGFIX_20080812	// 젠 보유량도 보내주도록 수정
; 2746 : 			PMSG_MONEY	pMsg;
; 2747 : 			
; 2748 : 			PHeadSetB((LPBYTE)&pMsg, 0x81, sizeof( pMsg ));
; 2749 : 			pMsg.Result     = 0x01;
; 2750 : 			pMsg.iMoney		= lpObj->Money; 
; 2751 : 			pMsg.wMoney		= lpObj->WarehouseMoney;
; 2752 : 			DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 2753 : #endif // MODIFY_NEW_ACCOUNT_WAREHOUSE_ZEN_BUGFIX_20080812
; 2754 : 		}
; 2755 : 	}
; 2756 : 
; 2757 : 	lpObj->LoadWareHouseInfo = TRUE;

  0013f	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00142	c6 80 88 0e 00
	00 01		 mov	 BYTE PTR [eax+3720], 1

; 2758 : 
; 2759 : #ifdef WAREHOUSE_ITEMCOPY_BUG_FIX
; 2760 : 	lpObj->m_ReqWarehouseOpen = FALSE;

  00149	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014c	c6 80 24 0f 00
	00 00		 mov	 BYTE PTR [eax+3876], 0
$LN5@GDGetWareh:

; 2761 : #endif
; 2762 : }

  00153	5f		 pop	 edi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx
  00156	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00159	33 cd		 xor	 ecx, ebp
  0015b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ENDP ; GDGetWarehouseNoItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z
_TEXT	SEGMENT
$T1 = -296						; size = 4
_loWord$2 = -228					; size = 2
_hiWord$3 = -224					; size = 2
_n$4 = -220						; size = 4
_dbsize$ = -216						; size = 4
_item$ = -212						; size = 168
_OptionData$ = -41					; size = 1
__type$ = -40						; size = 4
_itype$ = -36						; size = 4
_lpObj$ = -32						; size = 4
_pResult$ = -28						; size = 8
_aIndex$ = -20						; size = 4
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z PROC ; DGGetWarehouseList, COMDAT

; 2297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2298 : 	char	szId[MAX_IDSTRING+1];
; 2299 : 	int		aIndex=0;

  00016	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _aIndex$[ebp], 0

; 2300 : 	PMSG_TALKRESULT		pResult;
; 2301 : 	
; 2302 : 	szId[MAX_IDSTRING] = '\0';

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	6b c8 0a	 imul	 ecx, eax, 10
  00025	89 8d d8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0002b	83 bd d8 fe ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00032	73 02		 jae	 SHORT $LN39@DGGetWareh
  00034	eb 05		 jmp	 SHORT $LN40@DGGetWareh
$LN39@DGGetWareh:
  00036	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN40@DGGetWareh:
  0003b	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00041	c6 44 15 f0 00	 mov	 BYTE PTR _szId$[ebp+edx], 0

; 2303 : 	memcpy(szId, lpMsg->AccountID, MAX_IDSTRING);

  00046	6a 0a		 push	 10			; 0000000aH
  00048	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004b	83 c0 04	 add	 eax, 4
  0004e	50		 push	 eax
  0004f	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 _memcpy
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2304 : 	aIndex = (int)lpMsg->aIndex;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0005e	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  00062	89 4d ec	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2305 : 
; 2306 : 	if( gObjIsAccontConnect(aIndex, szId) == FALSE )

  00065	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00068	50		 push	 eax
  00069	8b 4d ec	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00072	83 c4 08	 add	 esp, 8
  00075	85 c0		 test	 eax, eax
  00077	75 29		 jne	 SHORT $LN5@DGGetWareh

; 2307 : 	{
; 2308 : 		LogAddC(LOGC_RED, lMsg.Get(431), szId, aIndex);

  00079	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0007c	50		 push	 eax
  0007d	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  00080	51		 push	 ecx
  00081	68 af 01 00 00	 push	 431			; 000001afH
  00086	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00091	50		 push	 eax
  00092	6a 02		 push	 2
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0009a	83 c4 10	 add	 esp, 16			; 00000010H

; 2309 : 		return;

  0009d	e9 e4 06 00 00	 jmp	 $LN1@DGGetWareh
$LN5@DGGetWareh:

; 2310 : 	}
; 2311 : 	LPOBJECTSTRUCT	lpObj;
; 2312 : 
; 2313 : 	lpObj = &gObj[aIndex];

  000a2	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a9	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	89 45 e0	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2314 : 
; 2315 : 	int		itype, _type;
; 2316 : 	BYTE	OptionData;
; 2317 : 	CItem	item;

  000b2	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  000b8	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 2318 : 	
; 2319 : 	memset(gObj[aIndex].pWarehouseMap, 0xFF, MAX_WAREHOUSEITEMS);

  000bd	6a 78		 push	 120			; 00000078H
  000bf	68 ff 00 00 00	 push	 255			; 000000ffH
  000c4	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d1	8b 94 01 98 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3224]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 _memset
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2320 : 	gObj[aIndex].WarehouseMoney = lpMsg->Money;

  000e1	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ee	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000f1	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  000f4	89 94 01 a4 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3236], edx

; 2321 : 	gObj[aIndex].WarehousePW	= lpMsg->pw;

  000fb	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00102	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00108	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0010b	66 8b 92 c6 04
	00 00		 mov	 dx, WORD PTR [edx+1222]
  00112	66 89 94 01 9e
	0c 00 00	 mov	 WORD PTR [ecx+eax+3230], dx

; 2322 : 	
; 2323 : 	int dbsize = MAX_ITEMDBBYTE_V00;

  0011a	c7 85 28 ff ff
	ff 07 00 00 00	 mov	 DWORD PTR _dbsize$[ebp], 7

; 2324 : 	
; 2325 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 2326 : 	if( lpMsg->DbVersion >= 0x03 ) {
; 2327 : 		dbsize = MAX_ITEMDBBYTE;
; 2328 : 	}
; 2329 : 	else if (lpMsg->DbVersion >= 0x01) {
; 2330 : 		dbsize = MAX_ITEMDBBYTE_V02;
; 2331 : 	}
; 2332 : #else
; 2333 : #ifdef SETITEM_BUFFER_CLEAR
; 2334 : 	if( lpMsg->DbVersion != 0x00 ) dbsize = MAX_ITEMDBBYTE;

  00124	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00127	0f b6 88 c4 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1220]
  0012e	85 c9		 test	 ecx, ecx
  00130	74 0a		 je	 SHORT $LN6@DGGetWareh
  00132	c7 85 28 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR _dbsize$[ebp], 10 ; 0000000aH
$LN6@DGGetWareh:

; 2335 : #else
; 2336 : 	if( lpMsg->DbVersion == 0x01 ) dbsize = MAX_ITEMDBBYTE;
; 2337 : #endif
; 2338 : #endif
; 2339 : 
; 2340 : 	for( int n=0; n<MAX_WAREHOUSEITEMS; n++)

  0013c	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$4[ebp], 0
  00146	eb 0f		 jmp	 SHORT $LN4@DGGetWareh
$LN2@DGGetWareh:
  00148	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0014e	83 c0 01	 add	 eax, 1
  00151	89 85 24 ff ff
	ff		 mov	 DWORD PTR _n$4[ebp], eax
$LN4@DGGetWareh:
  00157	83 bd 24 ff ff
	ff 78		 cmp	 DWORD PTR _n$4[ebp], 120 ; 00000078H
  0015e	0f 8d 26 05 00
	00		 jge	 $LN3@DGGetWareh

; 2341 : 	{
; 2342 : 		itype = lpMsg->dbItems[n*dbsize];

  00164	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0016a	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00171	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00174	0f b6 54 01 14	 movzx	 edx, BYTE PTR [ecx+eax+20]
  00179	89 55 dc	 mov	 DWORD PTR _itype$[ebp], edx

; 2343 : 
; 2344 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 2345 : 		if( dbsize == MAX_ITEMDBBYTE ) {
; 2346 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2347 : //			itype |= (BYTE)lpMsg->dbInventory[n*ItemDbByte];
; 2348 : 			itype |= (lpMsg->dbItems[(n*dbsize)+9]&0xF0)<<5;
; 2349 : 			itype |= (lpMsg->dbItems[(n*dbsize)+7]&0x80)<<1;
; 2350 : 			_type = itype;
; 2351 : #endif
; 2352 : 		}
; 2353 : 		else if (dbsize == MAX_ITEMDBBYTE_V02)
; 2354 : #else
; 2355 : 		if( dbsize == 10 )

  0017c	83 bd 28 ff ff
	ff 0a		 cmp	 DWORD PTR _dbsize$[ebp], 10 ; 0000000aH
  00183	75 30		 jne	 SHORT $LN7@DGGetWareh

; 2356 : #endif
; 2357 : 		{
; 2358 : 			if( (lpMsg->dbItems[(n*dbsize)+7]>>7)&1 ) itype += 256;

  00185	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0018b	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00192	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00195	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  0019a	c1 fa 07	 sar	 edx, 7
  0019d	83 e2 01	 and	 edx, 1
  001a0	74 0b		 je	 SHORT $LN9@DGGetWareh
  001a2	8b 45 dc	 mov	 eax, DWORD PTR _itype$[ebp]
  001a5	05 00 01 00 00	 add	 eax, 256		; 00000100H
  001aa	89 45 dc	 mov	 DWORD PTR _itype$[ebp], eax
$LN9@DGGetWareh:

; 2359 : 
; 2360 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2361 : 			_type = ((itype/32)*MAX_ITEM_INDEX)+(itype%32);
; 2362 : #else
; 2363 : 			_type = itype;

  001ad	8b 45 dc	 mov	 eax, DWORD PTR _itype$[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR __type$[ebp], eax

; 2364 : #endif
; 2365 : 		}

  001b3	eb 24		 jmp	 SHORT $LN8@DGGetWareh
$LN7@DGGetWareh:

; 2366 : 		else
; 2367 : 		{
; 2368 : 			_type = ((itype/16)*MAX_ITEM_INDEX)+(itype%16);

  001b5	8b 45 dc	 mov	 eax, DWORD PTR _itype$[ebp]
  001b8	99		 cdq
  001b9	83 e2 0f	 and	 edx, 15			; 0000000fH
  001bc	03 c2		 add	 eax, edx
  001be	c1 f8 04	 sar	 eax, 4
  001c1	c1 e0 05	 shl	 eax, 5
  001c4	8b 4d dc	 mov	 ecx, DWORD PTR _itype$[ebp]
  001c7	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  001cd	79 05		 jns	 SHORT $LN41@DGGetWareh
  001cf	49		 dec	 ecx
  001d0	83 c9 f0	 or	 ecx, -16		; fffffff0H
  001d3	41		 inc	 ecx
$LN41@DGGetWareh:
  001d4	03 c1		 add	 eax, ecx
  001d6	89 45 d8	 mov	 DWORD PTR __type$[ebp], eax
$LN8@DGGetWareh:

; 2369 : 		}
; 2370 : 
; 2371 : 		gObj[aIndex].pWarehouse[n].Clear();

  001d9	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001e0	69 8d 24 ff ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$4[ebp], 168
  001ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f0	03 8c 02 94 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3220]
  001f7	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 2372 : 		
; 2373 : 		// 2003-01-08 : 잘못된 타입의 창고 아이템 검사 추가
; 2374 : 		// type == 0xef extype = 0x80 현재 의미없는 아이템 타입 
; 2375 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2376 : 		if( dbsize >= MAX_ITEMDBBYTE ) {
; 2377 : 			if( (lpMsg->dbItems[n*dbsize] == 0xFF)
; 2378 : 				&& (lpMsg->dbItems[(n*dbsize)+9]&0xF0) == 0xF0
; 2379 : 				&& (lpMsg->dbItems[(n*dbsize)+7]&0x80) == 0x80
; 2380 : 				) 
; 2381 : 			{
; 2382 : 				// 저장할 때 아이템이 없으면 모든 비트를 1로 set 하므로 이런 식별이 가능
; 2383 : 				itype = -1;
; 2384 : 			}
; 2385 : 		}
; 2386 : 		else if (dbsize >= MAX_ITEMDBBYTE_V02) {
; 2387 : 			if( (lpMsg->dbItems[n*dbsize] == 0xFF) && (lpMsg->dbItems[(n*dbsize)+7]&0x80) == 0x80) 
; 2388 : 			{
; 2389 : 				itype = -1;
; 2390 : 			}
; 2391 : 		}
; 2392 : 		else {
; 2393 : 			if(lpMsg->dbItems[n*dbsize] == 0xFF) 
; 2394 : 			{
; 2395 : 				itype = -1;
; 2396 : 			}
; 2397 : 		}
; 2398 : #else
; 2399 : #ifdef INVENTORY_EMPTYSLOT_CHECK_20050217
; 2400 : 		if( (lpMsg->dbItems[n*dbsize] == 0xFF) && (lpMsg->dbItems[(n*dbsize)+7]&0x80) == 0x80) {

  001fc	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  00202	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00209	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0020c	0f b6 54 01 14	 movzx	 edx, BYTE PTR [ecx+eax+20]
  00211	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00217	75 24		 jne	 SHORT $LN10@DGGetWareh
  00219	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0021f	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00226	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00229	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  0022e	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00234	74 07		 je	 SHORT $LN10@DGGetWareh

; 2401 : #else
; 2402 : 		if( (lpMsg->dbItems[n*dbsize] == 0xFF) ) {
; 2403 : #endif
; 2404 : 			itype = -1;

  00236	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN10@DGGetWareh:

; 2405 : 		}
; 2406 : #endif
; 2407 : 
; 2408 : 		if( !IsItem(_type) )

  0023d	8b 45 d8	 mov	 eax, DWORD PTR __type$[ebp]
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 ?IsItem@@YAHH@Z		; IsItem
  00246	83 c4 04	 add	 esp, 4
  00249	85 c0		 test	 eax, eax
  0024b	75 07		 jne	 SHORT $LN11@DGGetWareh

; 2409 : 		{
; 2410 : 			itype = -1;

  0024d	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN11@DGGetWareh:

; 2411 : 		}
; 2412 : 
; 2413 : 		if( _type == MAKE_ITEMNUM(14,17) || _type == MAKE_ITEMNUM(14,18) )

  00254	6a 11		 push	 17			; 00000011H
  00256	6a 0e		 push	 14			; 0000000eH
  00258	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0025d	83 c4 08	 add	 esp, 8
  00260	39 45 d8	 cmp	 DWORD PTR __type$[ebp], eax
  00263	74 11		 je	 SHORT $LN13@DGGetWareh
  00265	6a 12		 push	 18			; 00000012H
  00267	6a 0e		 push	 14			; 0000000eH
  00269	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0026e	83 c4 08	 add	 esp, 8
  00271	39 45 d8	 cmp	 DWORD PTR __type$[ebp], eax
  00274	75 20		 jne	 SHORT $LN14@DGGetWareh
$LN13@DGGetWareh:

; 2414 : 		{	// 악마의 열쇠, 눈의 경우에는 내구도가 0인건 다 무시한다			
; 2415 : 			if( lpMsg->dbItems[(n*dbsize)+2] == 0 )

  00276	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0027c	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00283	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00286	0f b6 54 01 16	 movzx	 edx, BYTE PTR [ecx+eax+22]
  0028b	85 d2		 test	 edx, edx
  0028d	75 07		 jne	 SHORT $LN14@DGGetWareh

; 2416 : 			{
; 2417 : 				_type = -1;

  0028f	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR __type$[ebp], -1
$LN14@DGGetWareh:

; 2418 : 			}
; 2419 : 		}
; 2420 : 
; 2421 : 		if( _type == MAKE_ITEMNUM(14,19) )

  00296	6a 13		 push	 19			; 00000013H
  00298	6a 0e		 push	 14			; 0000000eH
  0029a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0029f	83 c4 08	 add	 esp, 8
  002a2	39 45 d8	 cmp	 DWORD PTR __type$[ebp], eax
  002a5	75 24		 jne	 SHORT $LN16@DGGetWareh

; 2422 : 		{	// 악마의 초대권의 경우에는 내구도가 255인건 다 무시한다			
; 2423 : 			if( lpMsg->dbItems[(n*dbsize)+2] == 255 )

  002a7	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  002ad	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  002b4	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002b7	0f b6 54 01 16	 movzx	 edx, BYTE PTR [ecx+eax+22]
  002bc	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  002c2	75 07		 jne	 SHORT $LN16@DGGetWareh

; 2424 : 			{
; 2425 : 				itype = -1;

  002c4	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN16@DGGetWareh:

; 2426 : 			}
; 2427 : 		}
; 2428 : 		
; 2429 : #ifdef CHINA_BUG_RETOUCH		
; 2430 : 		if( _type == MAKE_ITEMNUM(13,20) )
; 2431 : 		{	// 마법사의 반지, 용/전사의 반지는 창고에 있으면 안된다
; 2432 : 			LogAddTD("(%s)(%s) Invalid Ring Item Found - Removed", lpObj->AccountID, lpObj->Name);
; 2433 : 			itype = -1;
; 2434 : 		}
; 2435 : #endif
; 2436 : 
; 2437 : #ifndef FOR_BLOODCASTLE_TEST
; 2438 : /*		if ( 
; 2439 : 			_type == MAKE_ITEMNUM(13, 16) ||	// 대천사의서
; 2440 : 			_type == MAKE_ITEMNUM(13, 17)		// 블러드본
; 2441 : //			_type == MAKE_ITEMNUM(13, 18)		// 투명망토
; 2442 : 			)	
; 2443 : 		{
; 2444 : 			if( lpMsg->dbItems[(n*dbsize)+2] != 128 )
; 2445 : 			{
; 2446 : 				itype = -1;
; 2447 : 			}
; 2448 : 		}
; 2449 : 
; 2450 : 		if (_type == MAKE_ITEMNUM(14, 21))
; 2451 : 		{
; 2452 : 			int _level = ((lpMsg->dbItems[(n*dbsize)+1]>>3)&0xF);
; 2453 : 			if (_level == 1) {	// 스톤임
; 2454 : 				if( lpMsg->dbItems[(n*dbsize)+2] != 128 )
; 2455 : 				{
; 2456 : 					itype = -1;
; 2457 : 				}
; 2458 : 			}
; 2459 : 		}
; 2460 : */
; 2461 : #endif
; 2462 : 
; 2463 : 
; 2464 : 		if( itype != -1 )

  002cb	83 7d dc ff	 cmp	 DWORD PTR _itype$[ebp], -1
  002cf	0f 84 b0 03 00
	00		 je	 $LN17@DGGetWareh

; 2465 : 		{	
; 2466 : 			item.m_Level = ((lpMsg->dbItems[(n*dbsize)+1]>>3)&0xF);

  002d5	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  002db	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  002e2	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002e5	0f b6 54 01 15	 movzx	 edx, BYTE PTR [ecx+eax+21]
  002ea	c1 fa 03	 sar	 edx, 3
  002ed	83 e2 0f	 and	 edx, 15			; 0000000fH
  002f0	66 89 95 34 ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], dx

; 2467 : 
; 2468 : #ifdef SETITEM_BUFFER_CLEAR
; 2469 : 			if( lpMsg->DbVersion < 2 )

  002f7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002fa	0f b6 88 c4 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1220]
  00301	83 f9 02	 cmp	 ecx, 2
  00304	7d 2a		 jge	 SHORT $LN18@DGGetWareh

; 2470 : 			{	// 인벤이 세트용으로 클리어 되어 있지 않으면 세트아이템 정보를 클리어 한다
; 2471 : 				lpMsg->dbItems[(n*dbsize)+8] = 0xFF;

  00306	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0030c	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00313	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00316	c6 44 01 1c ff	 mov	 BYTE PTR [ecx+eax+28], 255 ; 000000ffH

; 2472 : 				lpMsg->dbItems[(n*dbsize)+9] = 0xFF;

  0031b	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  00321	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00328	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0032b	c6 44 01 1d ff	 mov	 BYTE PTR [ecx+eax+29], 255 ; 000000ffH
$LN18@DGGetWareh:

; 2473 : 			}
; 2474 : #endif
; 2475 : 
; 2476 : 
; 2477 : #ifdef TEST_SETITEM_CLEAR			
; 2478 : 			if( !(lpObj->ClearInfoForSetItem&0x02) )
; 2479 : 			{	// 인벤이 세트용으로 클리어 되어 있지 않으면 세트아이템 정보를 클리어 한다
; 2480 : 				lpMsg->dbItems[(n*dbsize)+8] = 0xFF;
; 2481 : 				lpMsg->dbItems[(n*dbsize)+9] = 0xFF;
; 2482 : 			}
; 2483 : #endif
; 2484 : 
; 2485 : 			if( _type != MAKE_ITEMNUM(14,11) )	// 행운의 상자는 레벨 체크 안한다

  00330	6a 0b		 push	 11			; 0000000bH
  00332	6a 0e		 push	 14			; 0000000eH
  00334	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00339	83 c4 08	 add	 esp, 8
  0033c	39 45 d8	 cmp	 DWORD PTR __type$[ebp], eax
  0033f	74 15		 je	 SHORT $LN20@DGGetWareh

; 2486 : 				if( item.m_Level >  MAX_ITEMLEVEL ) item.m_Level = 0;

  00341	0f bf 85 34 ff
	ff ff		 movsx	 eax, WORD PTR _item$[ebp+8]
  00348	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0034b	7e 09		 jle	 SHORT $LN20@DGGetWareh
  0034d	33 c0		 xor	 eax, eax
  0034f	66 89 85 34 ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], ax
$LN20@DGGetWareh:

; 2487 : 			
; 2488 : 			OptionData = lpMsg->dbItems[(n*dbsize)+1];

  00356	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0035c	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00363	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00366	8a 54 01 15	 mov	 dl, BYTE PTR [ecx+eax+21]
  0036a	88 55 d7	 mov	 BYTE PTR _OptionData$[ebp], dl

; 2489 : 			item.m_Option1 = OptionData>>7;

  0036d	0f b6 45 d7	 movzx	 eax, BYTE PTR _OptionData$[ebp]
  00371	c1 f8 07	 sar	 eax, 7
  00374	88 45 a4	 mov	 BYTE PTR _item$[ebp+120], al

; 2490 : 			item.m_Option2 = (OptionData>>2)&0x1;

  00377	0f b6 45 d7	 movzx	 eax, BYTE PTR _OptionData$[ebp]
  0037b	c1 f8 02	 sar	 eax, 2
  0037e	83 e0 01	 and	 eax, 1
  00381	88 45 a5	 mov	 BYTE PTR _item$[ebp+121], al

; 2491 : 			item.m_Option3 = OptionData&0x3;

  00384	0f b6 45 d7	 movzx	 eax, BYTE PTR _OptionData$[ebp]
  00388	83 e0 03	 and	 eax, 3
  0038b	88 45 a6	 mov	 BYTE PTR _item$[ebp+122], al

; 2492 : 
; 2493 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 2494 : 			if( dbsize >= 10 )
; 2495 : #else
; 2496 : 			if( dbsize == 10 )

  0038e	83 bd 28 ff ff
	ff 0a		 cmp	 DWORD PTR _dbsize$[ebp], 10 ; 0000000aH
  00395	75 5b		 jne	 SHORT $LN24@DGGetWareh

; 2497 : #endif
; 2498 : 			{
; 2499 : 				if( _type == MAKE_ITEMNUM(13,3) )

  00397	6a 03		 push	 3
  00399	6a 0d		 push	 13			; 0000000dH
  0039b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003a0	83 c4 08	 add	 esp, 8
  003a3	39 45 d8	 cmp	 DWORD PTR __type$[ebp], eax
  003a6	75 26		 jne	 SHORT $LN22@DGGetWareh

; 2500 : 				{	// 디노란트는 옵션 3Bit를 모두다 사용한다
; 2501 : 					item.m_Option3 |= (lpMsg->dbItems[(n*dbsize)+7]&0x40)>>4;

  003a8	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  003ae	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  003b5	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  003b8	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  003bd	83 e2 40	 and	 edx, 64			; 00000040H
  003c0	c1 fa 04	 sar	 edx, 4
  003c3	0f b6 45 a6	 movzx	 eax, BYTE PTR _item$[ebp+122]
  003c7	0b c2		 or	 eax, edx
  003c9	88 45 a6	 mov	 BYTE PTR _item$[ebp+122], al

; 2502 : 				}

  003cc	eb 24		 jmp	 SHORT $LN24@DGGetWareh
$LN22@DGGetWareh:

; 2503 : 				else
; 2504 : 				{
; 2505 : 					if( (lpMsg->dbItems[(n*dbsize)+7]&0x40) == 0x40 )

  003ce	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  003d4	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  003db	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  003de	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  003e3	83 e2 40	 and	 edx, 64			; 00000040H
  003e6	74 0a		 je	 SHORT $LN24@DGGetWareh

; 2506 : 						item.m_Option3 += 4;

  003e8	0f b6 45 a6	 movzx	 eax, BYTE PTR _item$[ebp+122]
  003ec	83 c0 04	 add	 eax, 4
  003ef	88 45 a6	 mov	 BYTE PTR _item$[ebp+122], al
$LN24@DGGetWareh:

; 2507 : 				}
; 2508 : 			}
; 2509 : 
; 2510 : 			item.m_Durability = lpMsg->dbItems[(n*dbsize)+2];

  003f2	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  003f8	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  003ff	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00402	0f b6 54 01 16	 movzx	 edx, BYTE PTR [ecx+eax+22]
  00407	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0040b	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0

; 2511 : 
; 2512 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2513 : 	#ifdef MODIFY_JEWELOFHARMONY_380OPTION_DBVERSION_BUGFIX_20060727 // ITEM_DBSIZE_EXTEND_20050706 define 반드시 On
; 2514 : 			if ( dbsize >= MAX_ITEMDBBYTE)
; 2515 : 			{
; 2516 : 				item.m_JewelOfHarmonyOption = lpMsg->dbItems[(n*dbsize)+10];	// 10번째 버퍼 : 조화의보석 강화 옵션
; 2517 : 			}
; 2518 : 	#else
; 2519 : 			item.m_JewelOfHarmonyOption = lpMsg->dbItems[(n*dbsize)+10];	// 10번째 버퍼 : 조화의보석 강화 옵션
; 2520 : 	#endif // MODIFY_JEWELOFHARMONY_380OPTION_DBVERSION_BUGFIX_20060727
; 2521 : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2522 : 
; 2523 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 2524 : 	#ifdef MODIFY_JEWELOFHARMONY_380OPTION_DBVERSION_BUGFIX_20060727 // ITEM_DBSIZE_EXTEND_20050706 define 반드시 On
; 2525 : 			if ( dbsize >= MAX_ITEMDBBYTE)
; 2526 : 			{
; 2527 : 				item.m_ItemOptionEx = (lpMsg->dbItems[(n*dbsize)+9]&0x08)<<4;	// 9번째 버퍼. 상위 5번째 1 비트값을 m_ItemOptionEx의 상위 1비트로 설정
; 2528 : 				// 2006.8.2 추가
; 2529 : 				if ( item.m_ItemOptionEx != 0 )
; 2530 : 				{
; 2531 : 					// 380 아이템이 아닌 경우 옵션 삭제
; 2532 : 					item.m_Type = itype;	// DBVersion3이상이기 때문에 itype값을 그대로 설정
; 2533 : 					if ( g_kItemSystemFor380.Is380Item( &item ) == FALSE )
; 2534 : 					{
; 2535 : 						item.m_ItemOptionEx = 0;
; 2536 : 						LogAddTD("[380Item][%s][%s] Invalid 380 Item Option in Warehouse pos[%d]", lpObj->AccountID, lpObj->Name, n);
; 2537 : 					}
; 2538 : 				}
; 2539 : 			}
; 2540 : 	#else
; 2541 : 			item.m_ItemOptionEx = (lpMsg->dbItems[(n*dbsize)+9]&0x08)<<4;	// 9번째 버퍼. 상위 5번째 1 비트값을 m_ItemOptionEx의 상위 1비트로 설정
; 2542 : 	#endif // MODIFY_JEWELOFHARMONY_380OPTION_DBVERSION_BUGFIX_20060727
; 2543 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 2544 : 
; 2545 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2546 : 			BYTE SocketOption[MAX_SOCKET_SLOT];
; 2547 : 			BYTE SocketBonusOption = SOCKETSLOT_NONE;
; 2548 : 			int iSocketSlotIndex = 0;
; 2549 : 
; 2550 : 			memset( SocketOption, SOCKETSLOT_NONE, MAX_SOCKET_SLOT );
; 2551 : 
; 2552 : 			if( g_SocketOptionSystem.IsEnableSocketItem( itype ) == true )
; 2553 : 			{
; 2554 : 				SocketBonusOption = lpMsg->dbItems[(n*dbsize)+10];
; 2555 : 				for( iSocketSlotIndex = 0; iSocketSlotIndex < MAX_SOCKET_SLOT ; iSocketSlotIndex++ )
; 2556 : 				{
; 2557 : 					SocketOption[iSocketSlotIndex] = lpMsg->dbItems[(n*dbsize)+11+iSocketSlotIndex];
; 2558 : 				}
; 2559 : 			}
; 2560 : 			else
; 2561 : 			{
; 2562 : 				SocketBonusOption = 0;
; 2563 : 
; 2564 : 				for( iSocketSlotIndex = 0 ; iSocketSlotIndex < MAX_SOCKET_SLOT ; iSocketSlotIndex++ )
; 2565 : 				{
; 2566 : 					SocketOption[iSocketSlotIndex] = SOCKETSLOT_NONE;
; 2567 : 				}
; 2568 : 			}
; 2569 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2570 : 
; 2571 : 			if( lpMsg->DbVersion == 0x00 )

  00413	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00416	0f b6 88 c4 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1220]
  0041d	85 c9		 test	 ecx, ecx
  0041f	75 26		 jne	 SHORT $LN25@DGGetWareh

; 2572 : 	#ifdef ADD_380ITEM_NEWOPTION_20060711
; 2573 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, 0, 0, 0, 0);
; 2574 : 	#else
; 2575 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, 0, 0, 0);

  00421	6a 00		 push	 0
  00423	6a 00		 push	 0
  00425	6a 00		 push	 0
  00427	0f b6 45 a6	 movzx	 eax, BYTE PTR _item$[ebp+122]
  0042b	50		 push	 eax
  0042c	0f b6 4d a5	 movzx	 ecx, BYTE PTR _item$[ebp+121]
  00430	51		 push	 ecx
  00431	0f b6 55 a4	 movzx	 edx, BYTE PTR _item$[ebp+120]
  00435	52		 push	 edx
  00436	8b 45 dc	 mov	 eax, DWORD PTR _itype$[ebp]
  00439	50		 push	 eax
  0043a	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00440	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert
  00445	eb 4f		 jmp	 SHORT $LN26@DGGetWareh
$LN25@DGGetWareh:

; 2576 : 	#endif // ADD_380ITEM_NEWOPTION_20060711
; 2577 : 
; 2578 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2579 : 			else if (lpMsg->DbVersion <= 0x02) 
; 2580 : 			{
; 2581 : 			#ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2582 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, lpMsg->dbItems[(n*dbsize)+7]&0x3F, lpMsg->dbItems[(n*dbsize)+8], item.m_ItemOptionEx, NULL, SOCKETSLOT_NONE, 1);
; 2583 : 			#else
; 2584 : 				#ifdef ADD_380ITEM_NEWOPTION_20060711
; 2585 : 					item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, lpMsg->dbItems[(n*dbsize)+7]&0x3F, lpMsg->dbItems[(n*dbsize)+8], item.m_ItemOptionEx, 1);
; 2586 : 				#else
; 2587 : 					item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, lpMsg->dbItems[(n*dbsize)+7]&0x3F, lpMsg->dbItems[(n*dbsize)+8], 1);
; 2588 : 				#endif // ADD_380ITEM_NEWOPTION_20060711
; 2589 : 			#endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2590 : 			}
; 2591 : 			else 
; 2592 : 			{
; 2593 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2594 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, lpMsg->dbItems[(n*dbsize)+7]&0x3F, lpMsg->dbItems[(n*dbsize)+8], item.m_ItemOptionEx, SocketOption, SocketBonusOption, 3);
; 2595 : #else
; 2596 : 	#ifdef ADD_380ITEM_NEWOPTION_20060711
; 2597 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, lpMsg->dbItems[(n*dbsize)+7]&0x3F, lpMsg->dbItems[(n*dbsize)+8], item.m_ItemOptionEx, 3);
; 2598 : 	#else
; 2599 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, lpMsg->dbItems[(n*dbsize)+7]&0x3F, lpMsg->dbItems[(n*dbsize)+8], 3);
; 2600 : 	#endif	// ADD_380ITEM_NEWOPTION_20060711
; 2601 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2602 : 			}
; 2603 : #else
; 2604 : 			else 
; 2605 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, lpMsg->dbItems[(n*dbsize)+7]&0x3F, lpMsg->dbItems[(n*dbsize)+8], 1);

  00447	6a 01		 push	 1
  00449	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0044f	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00456	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00459	0f b6 54 01 1c	 movzx	 edx, BYTE PTR [ecx+eax+28]
  0045e	52		 push	 edx
  0045f	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  00465	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  0046c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0046f	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [ecx+eax+27]
  00474	83 e2 3f	 and	 edx, 63			; 0000003fH
  00477	52		 push	 edx
  00478	0f b6 45 a6	 movzx	 eax, BYTE PTR _item$[ebp+122]
  0047c	50		 push	 eax
  0047d	0f b6 4d a5	 movzx	 ecx, BYTE PTR _item$[ebp+121]
  00481	51		 push	 ecx
  00482	0f b6 55 a4	 movzx	 edx, BYTE PTR _item$[ebp+120]
  00486	52		 push	 edx
  00487	8b 45 dc	 mov	 eax, DWORD PTR _itype$[ebp]
  0048a	50		 push	 eax
  0048b	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00491	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert
$LN26@DGGetWareh:

; 2606 : #endif
; 2607 : 
; 2608 : 
; 2609 : #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 2610 : 			if( _type == ITEM_POTION + 7 )
; 2611 : 			{
; 2612 : 				// 공성물약 제외
; 2613 : 			}
; 2614 : 			else
; 2615 : #endif
; 2616 : 			if( _type >= ITEM_POTION && 

  00496	81 7d d8 c0 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 448 ; 000001c0H
  0049d	7c 55		 jl	 SHORT $LN27@DGGetWareh
  0049f	81 7d d8 c8 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 456 ; 000001c8H
  004a6	7f 4c		 jg	 SHORT $LN27@DGGetWareh

; 2617 : 				_type <= ITEM_POTION+8 
; 2618 : #ifdef ADD_SHIELD_POINT_01_20060403
; 2619 : 				|| ( _type >= ITEM_POTION+35 && _type <= ITEM_POTION+40 )
; 2620 : #endif
; 2621 : 				) 
; 2622 : 			{
; 2623 : 				if( item.m_Durability == 0 ) item.m_Durability = 1;

  004a8	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _item$[ebp+36]
  004b0	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  004b7	9f		 lahf
  004b8	f6 c4 44	 test	 ah, 68			; 00000044H
  004bb	7a 10		 jp	 SHORT $LN29@DGGetWareh
  004bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004c5	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0
$LN29@DGGetWareh:

; 2624 : 				if( item.m_Durability > g_GlobalConfig.m_iMaxPotionDurability  ) item.m_Durability = g_GlobalConfig.m_iMaxPotionDurability;

  004cd	f3 0f 2a 05 b8
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+184
  004d5	f3 0f 10 8d 50
	ff ff ff	 movss	 xmm1, DWORD PTR _item$[ebp+36]
  004dd	0f 2f c8	 comiss	 xmm1, xmm0
  004e0	76 10		 jbe	 SHORT $LN30@DGGetWareh
  004e2	f3 0f 2a 05 b8
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+184
  004ea	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0
$LN30@DGGetWareh:

; 2625 : 			}

  004f2	eb 43		 jmp	 SHORT $LN32@DGGetWareh
$LN27@DGGetWareh:

; 2626 : 
; 2627 : 			else if( _type != MAKE_ITEMNUM(13,10)
; 2628 : #ifdef ADD_NEW_MAP_KALIMA_20040518					// 쿤둔의 표식의 내구력은 초기값에 맞춰 초기화되면 않된다.
; 2629 : 				 && _type != MAKE_ITEMNUM(14,29)

  004f4	6a 0a		 push	 10			; 0000000aH
  004f6	6a 0d		 push	 13			; 0000000dH
  004f8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  004fd	83 c4 08	 add	 esp, 8
  00500	39 45 d8	 cmp	 DWORD PTR __type$[ebp], eax
  00503	74 32		 je	 SHORT $LN32@DGGetWareh
  00505	6a 1d		 push	 29			; 0000001dH
  00507	6a 0e		 push	 14			; 0000000eH
  00509	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0050e	83 c4 08	 add	 esp, 8
  00511	39 45 d8	 cmp	 DWORD PTR __type$[ebp], eax
  00514	74 21		 je	 SHORT $LN32@DGGetWareh

; 2630 : #endif
; 2631 : #ifdef MU_CASTLESIEGE_CS_MARKS_20041214				// 성주의 표식의 내구력은 초기값에 맞춰 초기화되면 않된다.
; 2632 : 				 && (_type != MAKE_ITEMNUM(14,21) && item.m_Level == 3)
; 2633 : #endif
; 2634 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029				// 행운의 동전의 내구력은 초기값에 맞춰 초기화되면 않된다.
; 2635 : 				 && _type != MAKE_ITEMNUM(14, 100)
; 2636 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029				 
; 2637 : 				)			
; 2638 : 			{
; 2639 : 				if( item.m_Durability > item.m_BaseDurability )

  00516	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _item$[ebp+36]
  0051e	0f 2f 85 58 ff
	ff ff		 comiss	 xmm0, DWORD PTR _item$[ebp+44]
  00525	76 10		 jbe	 SHORT $LN32@DGGetWareh

; 2640 : 				{
; 2641 : 					item.m_Durability = item.m_BaseDurability;

  00527	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _item$[ebp+44]
  0052f	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0
$LN32@DGGetWareh:

; 2642 : 				}
; 2643 : 			}
; 2644 : 
; 2645 : 			lpObj->pWarehouse[n].m_Option1 = item.m_Option1;

  00537	69 85 24 ff ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$4[ebp], 168
  00541	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00544	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  0054a	8a 4d a4	 mov	 cl, BYTE PTR _item$[ebp+120]
  0054d	88 4c 02 78	 mov	 BYTE PTR [edx+eax+120], cl

; 2646 : 			lpObj->pWarehouse[n].m_Option2 = item.m_Option2;

  00551	69 85 24 ff ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$4[ebp], 168
  0055b	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0055e	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  00564	8a 4d a5	 mov	 cl, BYTE PTR _item$[ebp+121]
  00567	88 4c 02 79	 mov	 BYTE PTR [edx+eax+121], cl

; 2647 : 			lpObj->pWarehouse[n].m_Option3 = item.m_Option3;

  0056b	69 85 24 ff ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$4[ebp], 168
  00575	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00578	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  0057e	8a 4d a6	 mov	 cl, BYTE PTR _item$[ebp+122]
  00581	88 4c 02 7a	 mov	 BYTE PTR [edx+eax+122], cl

; 2648 : 
; 2649 : 
; 2650 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2651 : 			lpObj->pWarehouse[n].m_JewelOfHarmonyOption = item.m_JewelOfHarmonyOption;
; 2652 : #endif //	ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2653 : 
; 2654 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 2655 : 			lpObj->pWarehouse[n].m_ItemOptionEx = item.m_ItemOptionEx;
; 2656 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 2657 : 			
; 2658 : 			WORD hiWord, loWord;
; 2659 : 
; 2660 : 			hiWord = MAKEWORD(lpMsg->dbItems[(n*dbsize)+4], lpMsg->dbItems[(n*dbsize)+3]);

  00585	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0058b	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  00592	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00595	0f b6 54 01 18	 movzx	 edx, BYTE PTR [ecx+eax+24]
  0059a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005a0	0f b6 c2	 movzx	 eax, dl
  005a3	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _n$4[ebp]
  005a9	0f af 8d 28 ff
	ff ff		 imul	 ecx, DWORD PTR _dbsize$[ebp]
  005b0	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  005b3	0f b6 4c 0a 17	 movzx	 ecx, BYTE PTR [edx+ecx+23]
  005b8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005be	0f b6 d1	 movzx	 edx, cl
  005c1	c1 e2 08	 shl	 edx, 8
  005c4	0b c2		 or	 eax, edx
  005c6	66 89 85 20 ff
	ff ff		 mov	 WORD PTR _hiWord$3[ebp], ax

; 2661 : 			loWord = MAKEWORD(lpMsg->dbItems[(n*dbsize)+6], lpMsg->dbItems[(n*dbsize)+5]);			

  005cd	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  005d3	0f af 85 28 ff
	ff ff		 imul	 eax, DWORD PTR _dbsize$[ebp]
  005da	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  005dd	0f b6 54 01 1a	 movzx	 edx, BYTE PTR [ecx+eax+26]
  005e2	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005e8	0f b6 c2	 movzx	 eax, dl
  005eb	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _n$4[ebp]
  005f1	0f af 8d 28 ff
	ff ff		 imul	 ecx, DWORD PTR _dbsize$[ebp]
  005f8	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  005fb	0f b6 4c 0a 19	 movzx	 ecx, BYTE PTR [edx+ecx+25]
  00600	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00606	0f b6 d1	 movzx	 edx, cl
  00609	c1 e2 08	 shl	 edx, 8
  0060c	0b c2		 or	 eax, edx
  0060e	66 89 85 1c ff
	ff ff		 mov	 WORD PTR _loWord$2[ebp], ax

; 2662 : 			item.m_Number		= MAKELONG(loWord, hiWord);

  00615	0f b7 85 1c ff
	ff ff		 movzx	 eax, WORD PTR _loWord$2[ebp]
  0061c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00621	0f b7 c8	 movzx	 ecx, ax
  00624	0f b7 95 20 ff
	ff ff		 movzx	 edx, WORD PTR _hiWord$3[ebp]
  0062b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00631	0f b7 c2	 movzx	 eax, dx
  00634	c1 e0 10	 shl	 eax, 16			; 00000010H
  00637	0b c8		 or	 ecx, eax
  00639	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _item$[ebp], ecx

; 2663 : 
; 2664 : 			gObjWarehouseInsertItemPos(lpObj->m_Index, item, n, -1);

  0063f	6a ff		 push	 -1
  00641	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  00647	50		 push	 eax
  00648	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0064e	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00653	8d b5 2c ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  00659	8b fc		 mov	 edi, esp
  0065b	f3 a5		 rep movsd
  0065d	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00660	8b 11		 mov	 edx, DWORD PTR [ecx]
  00662	52		 push	 edx
  00663	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z ; gObjWarehouseInsertItemPos
  00668	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H

; 2665 : 			gObjWarehouseItemSet(lpObj->m_Index, n, 0x01);

  0066e	6a 01		 push	 1
  00670	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  00676	50		 push	 eax
  00677	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0067a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0067c	52		 push	 edx
  0067d	e8 00 00 00 00	 call	 ?gObjWarehouseItemSet@@YAXHHE@Z ; gObjWarehouseItemSet
  00682	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@DGGetWareh:

; 2666 : 		}
; 2667 : 	}

  00685	e9 be fa ff ff	 jmp	 $LN2@DGGetWareh
$LN3@DGGetWareh:

; 2668 : 
; 2669 : #ifdef TEST_SETITEM_CLEAR	// 세트 아이템용 정보를 클리어 했다
; 2670 : 	lpObj->ClearInfoForSetItem |= 0x02;
; 2671 : #endif
; 2672 : 
; 2673 : 	pResult.h.c        = PMHCE_BYTE;

  0068a	c6 45 e4 c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 2674 : 	pResult.h.headcode = 0x30;

  0068e	c6 45 e6 30	 mov	 BYTE PTR _pResult$[ebp+2], 48 ; 00000030H

; 2675 : 	pResult.h.size     = sizeof( pResult );

  00692	c6 45 e5 08	 mov	 BYTE PTR _pResult$[ebp+1], 8

; 2676 : 	pResult.result     = 0x02;

  00696	c6 45 e7 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 2677 : 	DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  0069a	0f b6 45 e5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0069e	50		 push	 eax
  0069f	8d 4d e4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  006a2	51		 push	 ecx
  006a3	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006a6	8b 02		 mov	 eax, DWORD PTR [edx]
  006a8	50		 push	 eax
  006a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2678 : 
; 2679 : 	// 창고의 아이템을 보낸다.
; 2680 : 	GCUserWarehouseSend(&gObj[aIndex]);

  006b1	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006b8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006be	50		 push	 eax
  006bf	e8 00 00 00 00	 call	 ?GCUserWarehouseSend@@YAXPAVOBJECTSTRUCT@@@Z ; GCUserWarehouseSend
  006c4	83 c4 04	 add	 esp, 4

; 2681 : 	
; 2682 :     if( bCanWarehouseLock == TRUE )

  006c7	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  006ce	75 60		 jne	 SHORT $LN35@DGGetWareh

; 2683 : 	{
; 2684 : 		if( gObj[aIndex].WarehousePW > 0 )

  006d0	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006dd	0f bf 94 01 9e
	0c 00 00	 movsx	 edx, WORD PTR [ecx+eax+3230]
  006e5	85 d2		 test	 edx, edx
  006e7	7e 39		 jle	 SHORT $LN34@DGGetWareh

; 2685 : 			if( gObj[aIndex].WarehouseLock == 0  )

  006e9	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006f6	0f b6 94 01 a0
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3232]
  006fe	85 d2		 test	 edx, edx
  00700	75 10		 jne	 SHORT $LN36@DGGetWareh

; 2686 : 				GCWarehouseStateSend(aIndex, 12);

  00702	6a 0c		 push	 12			; 0000000cH
  00704	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00707	50		 push	 eax
  00708	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  0070d	83 c4 08	 add	 esp, 8
  00710	eb 0e		 jmp	 SHORT $LN37@DGGetWareh
$LN36@DGGetWareh:

; 2687 : 			else GCWarehouseStateSend(aIndex, 1);

  00712	6a 01		 push	 1
  00714	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00717	50		 push	 eax
  00718	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  0071d	83 c4 08	 add	 esp, 8
$LN37@DGGetWareh:
  00720	eb 0e		 jmp	 SHORT $LN35@DGGetWareh
$LN34@DGGetWareh:

; 2688 : 		else GCWarehouseStateSend(aIndex, 0);

  00722	6a 00		 push	 0
  00724	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00727	50		 push	 eax
  00728	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  0072d	83 c4 08	 add	 esp, 8
$LN35@DGGetWareh:

; 2689 : 	}
; 2690 : 
; 2691 : 	lpObj->LoadWareHouseInfo = TRUE;

  00730	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00733	c6 80 88 0e 00
	00 01		 mov	 BYTE PTR [eax+3720], 1

; 2692 : 
; 2693 : #ifdef WAREHOUSE_ITEMCOPY_BUG_FIX
; 2694 : 	lpObj->m_ReqWarehouseOpen = FALSE;

  0073a	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0073d	c6 80 24 0f 00
	00 00		 mov	 BYTE PTR [eax+3876], 0

; 2695 : #endif
; 2696 : 
; 2697 : #ifdef DARKLORD_WORK
; 2698 : 	gObjRequestPetItemInfo(lpObj->m_Index, 1);

  00744	6a 01		 push	 1
  00746	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00749	8b 08		 mov	 ecx, DWORD PTR [eax]
  0074b	51		 push	 ecx
  0074c	e8 00 00 00 00	 call	 ?gObjRequestPetItemInfo@@YAXHH@Z ; gObjRequestPetItemInfo
  00751	83 c4 08	 add	 esp, 8

; 2699 : #endif	
; 2700 : 
; 2701 : #ifdef AUTH_GAMESERVER_CHECKKEY
; 2702 : 	if( szAuthKey[2] != AUTH_CHECK_02 )
; 2703 : 		DestroyGIocp();
; 2704 : #endif
; 2705 : 
; 2706 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 2707 :     //창고 요청 정보 받고 클라로
; 2708 : 	LogAddTD_TempLog(", [G->C Recv GetWarehouseList], Account [%s], IP [%s] ", gObj[aIndex].AccountID, gObj[aIndex].Ip_addr);

  00754	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0075b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00761	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00765	52		 push	 edx
  00766	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0076d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00773	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00777	52		 push	 edx
  00778	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@CCJJLLEJ@?0?5?$FLG?9?$DOC?5Recv?5GetWarehouseList?$FN?0@
  0077d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  00783	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@DGGetWareh:

; 2709 : #endif
; 2710 : }

  00786	5f		 pop	 edi
  00787	5e		 pop	 esi
  00788	5b		 pop	 ebx
  00789	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0078c	33 cd		 xor	 ecx, ebp
  0078e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00793	8b e5		 mov	 esp, ebp
  00795	5d		 pop	 ebp
  00796	c3		 ret	 0
?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ENDP ; DGGetWarehouseList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z
_TEXT	SEGMENT
$T1 = -728						; size = 4
_i$2 = -596						; size = 4
_NewOption$3 = -592					; size = 8
_iItemCount$4 = -584					; size = 4
_iRetMapNumber$5 = -580					; size = 4
_btItemPos$6 = -573					; size = 1
_iItemIndex$7 = -572					; size = 4
_iItemType$8 = -568					; size = 4
_pCreateItem$9 = -564					; size = 168
_DropItem$10 = -396					; size = 4
_iItemPos$11 = -391					; size = 1
_iTypeIndex$12 = -390					; size = 1
_iType$13 = -389					; size = 1
_ExOption$14 = -388					; size = 8
_NewItem$15 = -380					; size = 168
_pMsg$16 = -212						; size = 9
_ExOption$17 = -200					; size = 8
_iTypeIndex$18 = -190					; size = 1
_iType$19 = -189					; size = 1
_NewItem$20 = -188					; size = 168
_lootindex$ = -20					; size = 4
_aIndex$ = -16						; size = 4
_mapnumber$ = -12					; size = 4
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z PROC ; ItemSerialCreateRecv, COMDAT

; 2985 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 02 00
	00		 sub	 esp, 728		; 000002d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2986 : 	LPOBJECTSTRUCT			lpObj;
; 2987 : 	
; 2988 : 	int mapnumber	= lpMsg->MapNumber;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00019	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0001d	89 4d f4	 mov	 DWORD PTR _mapnumber$[ebp], ecx

; 2989 : 	int	aIndex		= lpMsg->aIndex;

  00020	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00023	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00026	89 4d f0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2990 : 	int lootindex   = lpMsg->lootindex;

  00029	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002c	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  00030	89 4d ec	 mov	 DWORD PTR _lootindex$[ebp], ecx

; 2991 : 	
; 2992 : 	if( mapnumber != 255 )

  00033	81 7d f4 ff 00
	00 00		 cmp	 DWORD PTR _mapnumber$[ebp], 255 ; 000000ffH
  0003a	74 26		 je	 SHORT $LN6@ItemSerial

; 2993 : 	{
; 2994 : //#if defined ( EVENT_FRIENDSHIP_20040204 ) || defined ( EVENT_LOTTO )
; 2995 : #ifdef MODIFY_GAMBLING_COMPLEMENT_20090513
; 2996 : 		if( (mapnumber < 0) || ((mapnumber > g_TerrainManager.Size()-1) && (mapnumber < ITEMMAKE_INVENTORY_GAMBLINGITEM)))
; 2997 : #else // MODIFY_GAMBLING_COMPLEMENT_20090513
; 2998 : 		if( (mapnumber < 0) || ((mapnumber > g_TerrainManager.Size()-1) && (mapnumber < ITEMMAKE_INVENTORY_1CELL)))

  0003c	83 7d f4 00	 cmp	 DWORD PTR _mapnumber$[ebp], 0
  00040	7c 1b		 jl	 SHORT $LN7@ItemSerial
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00047	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  0004c	83 e8 01	 sub	 eax, 1
  0004f	39 45 f4	 cmp	 DWORD PTR _mapnumber$[ebp], eax
  00052	7e 0e		 jle	 SHORT $LN6@ItemSerial
  00054	81 7d f4 eb 00
	00 00		 cmp	 DWORD PTR _mapnumber$[ebp], 235 ; 000000ebH
  0005b	7d 05		 jge	 SHORT $LN6@ItemSerial
$LN7@ItemSerial:

; 2999 : #endif // MODIFY_GAMBLING_COMPLEMENT_20090513
; 3000 : 				
; 3001 : //#else // else EVENT_FRIENDSHIP_20040204 || EVENT_LOTTO
; 3002 : /*	#ifdef FOR_BLOODCASTLE
; 3003 : 			if( (mapnumber < 0) || ((mapnumber > MAX_MAP-1) && (mapnumber < BC_MAPNUMBER_CHAOSGEM1)))
; 3004 : 	
; 3005 : 	#else // else FOR_BLOODCASTLE
; 3006 : 			if( mapnumber < 0 || mapnumber > MAX_MAP-1)
; 3007 : 	
; 3008 : 	#endif
; 3009 : */
; 3010 : //#endif // EVENT_FRIENDSHIP_20040204 || EVENT_LOTTO
; 3011 : 		{
; 3012 : 			return;

  0005d	e9 19 0c 00 00	 jmp	 $LN1@ItemSerial
$LN6@ItemSerial:

; 3013 : 		}
; 3014 : 	}
; 3015 : 
; 3016 : 	if( lpMsg->SpecialShop == TRUE )	// 카오스 박스 였는지..

  00062	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00065	83 78 1c 01	 cmp	 DWORD PTR [eax+28], 1
  00069	0f 85 f2 01 00
	00		 jne	 $LN8@ItemSerial

; 3017 : 	{
; 3018 : 		if( gObjIsConnectedGP(aIndex) == FALSE ) 

  0006f	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00078	83 c4 04	 add	 esp, 4
  0007b	85 c0		 test	 eax, eax
  0007d	75 23		 jne	 SHORT $LN10@ItemSerial

; 3019 : 		{
; 3020 : 			LogAddC(LOGC_RED, "error-L3 [%s][%d]", __FILE__,__LINE__);

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z@4JA
  00084	83 c0 23	 add	 eax, 35			; 00000023H
  00087	50		 push	 eax
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MBPEHAPP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
  00092	6a 02		 push	 2
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0009a	83 c4 10	 add	 esp, 16			; 00000010H

; 3021 : 			return;

  0009d	e9 d9 0b 00 00	 jmp	 $LN1@ItemSerial
$LN10@ItemSerial:

; 3022 : 		}
; 3023 : 		lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  000a2	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a9	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 3024 : 
; 3025 : 		CItem NewItem;								

  000b2	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$20[ebp]
  000b8	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3026 : 
; 3027 : 		NewItem.m_Level      = lpMsg->Level;

  000bd	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000c0	66 0f b6 48 0e	 movzx	 cx, BYTE PTR [eax+14]
  000c5	66 89 8d 4c ff
	ff ff		 mov	 WORD PTR _NewItem$20[ebp+8], cx

; 3028 : 
; 3029 : 		NewItem.m_Durability = (float)ItemGetDurability(lpMsg->Type, lpMsg->Level, lpMsg->NewOption, lpMsg->SetOption);

  000cc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000cf	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  000d3	51		 push	 ecx
  000d4	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000d7	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  000db	50		 push	 eax
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000df	0f b6 51 0e	 movzx	 edx, BYTE PTR [ecx+14]
  000e3	52		 push	 edx
  000e4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000e7	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  000f1	83 c4 10	 add	 esp, 16			; 00000010H
  000f4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000f8	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _NewItem$20[ebp+36], xmm0

; 3030 : 
; 3031 : #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 3032 : 		// 축복의 물약, 영혼의 물약은 내구력이 데이터서버에서 넘어온 상태로 세팅되어야 한다.
; 3033 : 		if( lpMsg->Type == MAKE_ITEMNUM(14,7) )
; 3034 : 		{
; 3035 : 			NewItem.m_Durability = lpMsg->Dur;
; 3036 : 		}
; 3037 : #endif
; 3038 : 
; 3039 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 3040 : 		// 펜릴의 경우, 업그레이드 시 액설런트 옵션을 사용 하기 때문에 내구력 재조정 필요!
; 3041 : 		if( lpMsg->Type == MAKE_ITEMNUM(13,37))
; 3042 : 		{
; 3043 : 			NewItem.m_Durability = lpMsg->Dur;
; 3044 : 		}
; 3045 : #endif
; 3046 : 
; 3047 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3048 : 		// 주의 : 380 추가 옵션은 0, 380 추가옵션은 시리얼발급을 필요로하는 아이템이 아님.
; 3049 : 		NewItem.Convert(lpMsg->Type, lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0);	
; 3050 : #else
; 3051 : 		NewItem.Convert(lpMsg->Type, lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption);	

  00100	6a 01		 push	 1
  00102	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00105	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  00109	51		 push	 ecx
  0010a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0010d	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  00111	50		 push	 eax
  00112	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00115	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  00119	52		 push	 edx
  0011a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0011d	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  00121	51		 push	 ecx
  00122	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00125	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00129	50		 push	 eax
  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0012d	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  00131	52		 push	 edx
  00132	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$20[ebp]
  00138	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3052 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 3053 : 
; 3054 : 		NewItem.m_Number = lpMsg->m_Number;	

  0013d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00140	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00143	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _NewItem$20[ebp], ecx

; 3055 : 
; 3056 : #ifdef ITEM_INDEX_EXTEND_20050706
; 3057 : 		INT iType = lpMsg->Type/MAX_ITEM_INDEX;
; 3058 : 		INT iTypeIndex = lpMsg->Type%MAX_ITEM_INDEX;
; 3059 : #else
; 3060 : 		BYTE iType = lpMsg->Type >> ITEM_BITSHIFT;

  00149	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0014c	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00150	c1 f9 05	 sar	 ecx, 5
  00153	88 8d 43 ff ff
	ff		 mov	 BYTE PTR _iType$19[ebp], cl

; 3061 : 		BYTE iTypeIndex = lpMsg->Type & 0x1F;

  00159	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0015c	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00160	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00163	88 8d 42 ff ff
	ff		 mov	 BYTE PTR _iTypeIndex$18[ebp], cl

; 3062 : #endif
; 3063 : 
; 3064 : 		gObjInventoryInsertItem(lpObj,iType,iTypeIndex,lpMsg->Level,lpMsg->m_Number,lpMsg->Dur);

  00169	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0016c	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  00170	51		 push	 ecx
  00171	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00174	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00177	50		 push	 eax
  00178	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0017b	0f b6 51 0e	 movzx	 edx, BYTE PTR [ecx+14]
  0017f	52		 push	 edx
  00180	0f b6 85 42 ff
	ff ff		 movzx	 eax, BYTE PTR _iTypeIndex$18[ebp]
  00187	50		 push	 eax
  00188	0f b6 8d 43 ff
	ff ff		 movzx	 ecx, BYTE PTR _iType$19[ebp]
  0018f	51		 push	 ecx
  00190	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z ; gObjInventoryInsertItem
  00199	83 c4 18	 add	 esp, 24			; 00000018H

; 3065 : 
; 3066 : 		BYTE ExOption[8];		
; 3067 : 		ItemIsBufExOption(ExOption, &NewItem);

  0019c	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _NewItem$20[ebp]
  001a2	50		 push	 eax
  001a3	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _ExOption$17[ebp]
  001a9	51		 push	 ecx
  001aa	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  001af	83 c4 08	 add	 esp, 8

; 3068 : 
; 3069 : 		LogAddTD("[%s][%s] Special Shop Item:%s [%d][%d] [%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d] Set:[%d]",

  001b2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001b5	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  001b9	51		 push	 ecx
  001ba	ba 01 00 00 00	 mov	 edx, 1
  001bf	c1 e2 02	 shl	 edx, 2
  001c2	0f b6 84 15 38
	ff ff ff	 movzx	 eax, BYTE PTR _ExOption$17[ebp+edx]
  001ca	50		 push	 eax
  001cb	b9 01 00 00 00	 mov	 ecx, 1
  001d0	6b d1 03	 imul	 edx, ecx, 3
  001d3	0f b6 84 15 38
	ff ff ff	 movzx	 eax, BYTE PTR _ExOption$17[ebp+edx]
  001db	50		 push	 eax
  001dc	b9 01 00 00 00	 mov	 ecx, 1
  001e1	d1 e1		 shl	 ecx, 1
  001e3	0f b6 94 0d 38
	ff ff ff	 movzx	 edx, BYTE PTR _ExOption$17[ebp+ecx]
  001eb	52		 push	 edx
  001ec	b8 01 00 00 00	 mov	 eax, 1
  001f1	c1 e0 00	 shl	 eax, 0
  001f4	0f b6 8c 05 38
	ff ff ff	 movzx	 ecx, BYTE PTR _ExOption$17[ebp+eax]
  001fc	51		 push	 ecx
  001fd	ba 01 00 00 00	 mov	 edx, 1
  00202	6b c2 00	 imul	 eax, edx, 0
  00205	0f b6 8c 05 38
	ff ff ff	 movzx	 ecx, BYTE PTR _ExOption$17[ebp+eax]
  0020d	51		 push	 ecx
  0020e	0f b6 55 be	 movzx	 edx, BYTE PTR _NewItem$20[ebp+122]
  00212	52		 push	 edx
  00213	0f b6 45 bd	 movzx	 eax, BYTE PTR _NewItem$20[ebp+121]
  00217	50		 push	 eax
  00218	0f b6 4d bc	 movzx	 ecx, BYTE PTR _NewItem$20[ebp+120]
  0021c	51		 push	 ecx
  0021d	0f bf 95 4c ff
	ff ff		 movsx	 edx, WORD PTR _NewItem$20[ebp+8]
  00224	52		 push	 edx
  00225	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00228	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  0022c	51		 push	 ecx
  0022d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00230	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00233	50		 push	 eax
  00234	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$20[ebp]
  0023a	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0023f	50		 push	 eax
  00240	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00243	83 c1 73	 add	 ecx, 115		; 00000073H
  00246	51		 push	 ecx
  00247	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0024a	83 c2 68	 add	 edx, 104		; 00000068H
  0024d	52		 push	 edx
  0024e	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@NJPANPON@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Special?5Shop?5Item?3?$CFs?5?$FL@
  00253	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00259	83 c4 40	 add	 esp, 64			; 00000040H

; 3070 : 			lpObj->AccountID, lpObj->Name, NewItem.GetName(), lpMsg->m_Number, lpMsg->Dur, NewItem.m_Level, 
; 3071 : 			NewItem.m_Option1, NewItem.m_Option2, NewItem.m_Option3, ExOption[0], ExOption[1],
; 3072 : 			ExOption[2], ExOption[3], ExOption[4], lpMsg->SetOption);
; 3073 : 	}	

  0025c	e9 1a 0a 00 00	 jmp	 $LN31@ItemSerial
$LN8@ItemSerial:

; 3074 : #ifdef DARKLORD_WORK
; 3075 : 	else if( lpMsg->MapNumber == 255 || lpMsg->MapNumber == 254 )	// 카오스 박스 였는지..

  00261	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00264	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00268	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0026e	74 13		 je	 SHORT $LN13@ItemSerial
  00270	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00273	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00277	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  0027d	0f 85 03 03 00
	00		 jne	 $LN11@ItemSerial
$LN13@ItemSerial:

; 3076 : #else
; 3077 : 	else if( lpMsg->MapNumber == 255 )	// 카오스 박스 였는지..
; 3078 : #endif
; 3079 : 	{
; 3080 : 		PMSG_CHAOSMIXRESULT		pMsg;
; 3081 : 
; 3082 : 		if( gObjIsConnectedGP(aIndex) == FALSE ) 

  00283	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00286	50		 push	 eax
  00287	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0028c	83 c4 04	 add	 esp, 4
  0028f	85 c0		 test	 eax, eax
  00291	75 23		 jne	 SHORT $LN14@ItemSerial

; 3083 : 		{
; 3084 : 			LogAddC(LOGC_RED, "error-L3 [%s][%d]", __FILE__,__LINE__);

  00293	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z@4JA
  00298	83 c0 63	 add	 eax, 99			; 00000063H
  0029b	50		 push	 eax
  0029c	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MBPEHAPP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  002a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
  002a6	6a 02		 push	 2
  002a8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002ae	83 c4 10	 add	 esp, 16			; 00000010H

; 3085 : 			return;

  002b1	e9 c5 09 00 00	 jmp	 $LN1@ItemSerial
$LN14@ItemSerial:

; 3086 : 		}
; 3087 : 		lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  002b6	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002bd	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c3	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 3088 : 		
; 3089 : #ifdef DARKLORD_WORK
; 3090 : 		if( lpMsg->MapNumber == 254 )

  002c6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002c9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002cd	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  002d3	75 2c		 jne	 SHORT $LN15@ItemSerial

; 3091 : 		{
; 3092 : 			if( lpObj->m_IfState.type != I_DARK_TRAINER )

  002d5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d8	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  002de	c0 e9 04	 shr	 cl, 4
  002e1	80 e1 0f	 and	 cl, 15			; 0000000fH
  002e4	0f b6 d1	 movzx	 edx, cl
  002e7	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  002ea	74 13		 je	 SHORT $LN17@ItemSerial

; 3093 : 			{
; 3094 : 				LogAdd("error-L2: DarkTrainerBox not used.");

  002ec	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5us@
  002f1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002f7	83 c4 04	 add	 esp, 4

; 3095 : 				return;

  002fa	e9 7c 09 00 00	 jmp	 $LN1@ItemSerial
$LN17@ItemSerial:

; 3096 : 			}
; 3097 : 		}

  002ff	eb 2a		 jmp	 SHORT $LN18@ItemSerial
$LN15@ItemSerial:

; 3098 : 		else		
; 3099 : #endif
; 3100 : 		{
; 3101 : 			if( lpObj->m_IfState.type != I_CHAOSBOX )

  00301	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00304	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0030a	c0 e9 04	 shr	 cl, 4
  0030d	80 e1 0f	 and	 cl, 15			; 0000000fH
  00310	0f b6 d1	 movzx	 edx, cl
  00313	83 fa 07	 cmp	 edx, 7
  00316	74 13		 je	 SHORT $LN18@ItemSerial

; 3102 : 			{
; 3103 : 				LogAdd("error-L2: ChaosBox not used.");

  00318	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4@
  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00323	83 c4 04	 add	 esp, 4

; 3104 : 				return;

  00326	e9 50 09 00 00	 jmp	 $LN1@ItemSerial
$LN18@ItemSerial:

; 3105 : 			}
; 3106 : 		}
; 3107 : 		pMsg.h.c		= PMHC_BYTE;

  0032b	c6 85 2c ff ff
	ff c1		 mov	 BYTE PTR _pMsg$16[ebp], 193 ; 000000c1H

; 3108 : 		pMsg.h.headcode	= 0x86;

  00332	c6 85 2e ff ff
	ff 86		 mov	 BYTE PTR _pMsg$16[ebp+2], 134 ; 00000086H

; 3109 : 		pMsg.h.size		= sizeof( pMsg );

  00339	c6 85 2d ff ff
	ff 09		 mov	 BYTE PTR _pMsg$16[ebp+1], 9

; 3110 : 
; 3111 : #ifdef DARKLORD_WORK
; 3112 : 		if( lpMsg->MapNumber == 254 )

  00340	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00343	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00347	81 f9 fe 00 00
	00		 cmp	 ecx, 254		; 000000feH
  0034d	75 09		 jne	 SHORT $LN19@ItemSerial

; 3113 : 			pMsg.Result		= 100;	// 조련사 조합은 성공이 100이다

  0034f	c6 85 2f ff ff
	ff 64		 mov	 BYTE PTR _pMsg$16[ebp+3], 100 ; 00000064H
  00356	eb 07		 jmp	 SHORT $LN20@ItemSerial
$LN19@ItemSerial:

; 3114 : 		else
; 3115 : #endif
; 3116 : 		pMsg.Result		= 0x01;

  00358	c6 85 2f ff ff
	ff 01		 mov	 BYTE PTR _pMsg$16[ebp+3], 1
$LN20@ItemSerial:

; 3117 : 		
; 3118 : 		CItem NewItem;								

  0035f	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR _NewItem$15[ebp]
  00365	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3119 : 		
; 3120 : 		NewItem.m_Level      = lpMsg->Level;

  0036a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0036d	66 0f b6 48 0e	 movzx	 cx, BYTE PTR [eax+14]
  00372	66 89 8d 8c fe
	ff ff		 mov	 WORD PTR _NewItem$15[ebp+8], cx

; 3121 : 
; 3122 : 		NewItem.m_Durability = (float)ItemGetDurability(lpMsg->Type, lpMsg->Level, lpMsg->NewOption, lpMsg->SetOption);

  00379	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0037c	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  00380	51		 push	 ecx
  00381	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00384	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  00388	50		 push	 eax
  00389	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0038c	0f b6 51 0e	 movzx	 edx, BYTE PTR [ecx+14]
  00390	52		 push	 edx
  00391	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00394	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00398	51		 push	 ecx
  00399	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  0039e	83 c4 10	 add	 esp, 16			; 00000010H
  003a1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003a5	f3 0f 11 85 a8
	fe ff ff	 movss	 DWORD PTR _NewItem$15[ebp+36], xmm0

; 3123 : 
; 3124 : #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 3125 : 		// 축복의 물약, 영혼의 물약은 내구력이 데이터서버에서 넘어온 상태로 세팅되어야 한다.
; 3126 : 		if( lpMsg->Type == MAKE_ITEMNUM(14,7) )
; 3127 : 		{
; 3128 : 			NewItem.m_Durability = lpMsg->Dur;
; 3129 : 		}
; 3130 : #endif
; 3131 : 		
; 3132 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 3133 : 		// 펜릴의 경우, 업그레이드 시 액설런트 옵션을 사용 하기 때문에 내구력 재조정 필요!
; 3134 : 		if( lpMsg->Type == MAKE_ITEMNUM(13,37))
; 3135 : 		{
; 3136 : 			NewItem.m_Durability = lpMsg->Dur;
; 3137 : 		}
; 3138 : #endif
; 3139 : 		
; 3140 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3141 : 		// 주의 : 380 추가 옵션은 0, 380 추가옵션은 시리얼발급을 필요로하는 아이템이 아님.
; 3142 : 		NewItem.Convert(lpMsg->Type, lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0);	
; 3143 : #else
; 3144 : 		NewItem.Convert(lpMsg->Type, lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption);	

  003ad	6a 01		 push	 1
  003af	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003b2	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  003b6	51		 push	 ecx
  003b7	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  003ba	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  003be	50		 push	 eax
  003bf	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  003c2	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  003c6	52		 push	 edx
  003c7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003ca	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  003ce	51		 push	 ecx
  003cf	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  003d2	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  003d6	50		 push	 eax
  003d7	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  003da	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  003de	52		 push	 edx
  003df	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR _NewItem$15[ebp]
  003e5	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3145 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 3146 : 		
; 3147 : 		ItemByteConvert(pMsg.ItemInfo, NewItem);

  003ea	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  003f0	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  003f5	8d b5 84 fe ff
	ff		 lea	 esi, DWORD PTR _NewItem$15[ebp]
  003fb	8b fc		 mov	 edi, esp
  003fd	f3 a5		 rep movsd
  003ff	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pMsg$16[ebp+4]
  00405	50		 push	 eax
  00406	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  0040b	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 3148 : 		NewItem.m_Number = lpMsg->m_Number;

  00411	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00414	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00417	89 8d 84 fe ff
	ff		 mov	 DWORD PTR _NewItem$15[ebp], ecx

; 3149 : 		
; 3150 : #ifdef MODIFY_MIX_SYSTEM_20070518
; 3151 : 		g_MixSystem.ChaosBoxInit(lpObj);

  0041d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00420	50		 push	 eax
  00421	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00426	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 3152 : #endif
; 3153 : 
; 3154 : 		gObjChaosBoxInsertItemPos(aIndex, NewItem, 0, -1);

  0042b	6a ff		 push	 -1
  0042d	6a 00		 push	 0
  0042f	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00435	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0043a	8d b5 84 fe ff
	ff		 lea	 esi, DWORD PTR _NewItem$15[ebp]
  00440	8b fc		 mov	 edi, esp
  00442	f3 a5		 rep movsd
  00444	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00447	50		 push	 eax
  00448	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos
  0044d	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H

; 3155 : 		gObjChaosItemSet(aIndex, 0, 1);		

  00453	6a 01		 push	 1
  00455	6a 00		 push	 0
  00457	8b 45 f0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0045a	50		 push	 eax
  0045b	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet
  00460	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3156 : 
; 3157 : 		BYTE ExOption[8];		
; 3158 : 		ItemIsBufExOption(ExOption, &NewItem);

  00463	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR _NewItem$15[ebp]
  00469	50		 push	 eax
  0046a	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR _ExOption$14[ebp]
  00470	51		 push	 ecx
  00471	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  00476	83 c4 08	 add	 esp, 8

; 3159 : 		
; 3160 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3161 : 		LogAddTD("[%s][%s] CBMix Item Create Item:%s [%u][%d] [%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", 
; 3162 : #else
; 3163 : 		LogAddTD("[%s][%s] CBMix Item Create Item:%s [%d][%d] [%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", 

  00479	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0047c	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  00480	51		 push	 ecx
  00481	ba 01 00 00 00	 mov	 edx, 1
  00486	6b c2 06	 imul	 eax, edx, 6
  00489	0f b6 8c 05 7c
	fe ff ff	 movzx	 ecx, BYTE PTR _ExOption$14[ebp+eax]
  00491	51		 push	 ecx
  00492	ba 01 00 00 00	 mov	 edx, 1
  00497	6b c2 05	 imul	 eax, edx, 5
  0049a	0f b6 8c 05 7c
	fe ff ff	 movzx	 ecx, BYTE PTR _ExOption$14[ebp+eax]
  004a2	51		 push	 ecx
  004a3	ba 01 00 00 00	 mov	 edx, 1
  004a8	c1 e2 02	 shl	 edx, 2
  004ab	0f b6 84 15 7c
	fe ff ff	 movzx	 eax, BYTE PTR _ExOption$14[ebp+edx]
  004b3	50		 push	 eax
  004b4	b9 01 00 00 00	 mov	 ecx, 1
  004b9	6b d1 03	 imul	 edx, ecx, 3
  004bc	0f b6 84 15 7c
	fe ff ff	 movzx	 eax, BYTE PTR _ExOption$14[ebp+edx]
  004c4	50		 push	 eax
  004c5	b9 01 00 00 00	 mov	 ecx, 1
  004ca	d1 e1		 shl	 ecx, 1
  004cc	0f b6 94 0d 7c
	fe ff ff	 movzx	 edx, BYTE PTR _ExOption$14[ebp+ecx]
  004d4	52		 push	 edx
  004d5	b8 01 00 00 00	 mov	 eax, 1
  004da	c1 e0 00	 shl	 eax, 0
  004dd	0f b6 8c 05 7c
	fe ff ff	 movzx	 ecx, BYTE PTR _ExOption$14[ebp+eax]
  004e5	51		 push	 ecx
  004e6	ba 01 00 00 00	 mov	 edx, 1
  004eb	6b c2 00	 imul	 eax, edx, 0
  004ee	0f b6 8c 05 7c
	fe ff ff	 movzx	 ecx, BYTE PTR _ExOption$14[ebp+eax]
  004f6	51		 push	 ecx
  004f7	0f b6 95 fe fe
	ff ff		 movzx	 edx, BYTE PTR _NewItem$15[ebp+122]
  004fe	52		 push	 edx
  004ff	0f b6 85 fd fe
	ff ff		 movzx	 eax, BYTE PTR _NewItem$15[ebp+121]
  00506	50		 push	 eax
  00507	0f b6 8d fc fe
	ff ff		 movzx	 ecx, BYTE PTR _NewItem$15[ebp+120]
  0050e	51		 push	 ecx
  0050f	0f bf 95 8c fe
	ff ff		 movsx	 edx, WORD PTR _NewItem$15[ebp+8]
  00516	52		 push	 edx
  00517	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0051a	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  0051e	51		 push	 ecx
  0051f	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00522	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00525	50		 push	 eax
  00526	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR _NewItem$15[ebp]
  0052c	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00531	50		 push	 eax
  00532	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00535	83 c1 73	 add	 ecx, 115		; 00000073H
  00538	51		 push	 ecx
  00539	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0053c	83 c2 68	 add	 edx, 104		; 00000068H
  0053f	52		 push	 edx
  00540	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@EHKFCGJE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item@
  00545	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0054b	83 c4 48	 add	 esp, 72			; 00000048H

; 3164 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3165 : 				lpObj->AccountID, lpObj->Name,
; 3166 : 				NewItem.GetName(),
; 3167 : 			    lpMsg->m_Number, lpMsg->Dur, 				
; 3168 : 				NewItem.m_Level, NewItem.m_Option1, NewItem.m_Option2, NewItem.m_Option3,
; 3169 : 				ExOption[0],
; 3170 : 			    ExOption[1],
; 3171 : 			    ExOption[2],
; 3172 : 			    ExOption[3],
; 3173 : 			    ExOption[4],
; 3174 : 			    ExOption[5],
; 3175 : 			    ExOption[6],
; 3176 : 				lpMsg->SetOption
; 3177 : 			   );
; 3178 : 
; 3179 : 		DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0054e	0f b6 85 2d ff
	ff ff		 movzx	 eax, BYTE PTR _pMsg$16[ebp+1]
  00555	50		 push	 eax
  00556	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR _pMsg$16[ebp]
  0055c	51		 push	 ecx
  0055d	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00560	52		 push	 edx
  00561	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00566	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3180 : 		gObj[aIndex].ChaosLock = FALSE;

  00569	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00570	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00576	c7 84 01 bc 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3260], 0

; 3181 : 	}

  00581	e9 f5 06 00 00	 jmp	 $LN31@ItemSerial
$LN11@ItemSerial:

; 3182 : //#if defined ( EVENT_FRIENDSHIP_20040204 ) || defined ( EVENT_LOTTO )
; 3183 : 	else if (lpMsg->MapNumber == ITEMMAKE_INVENTORY_1CELL) {

  00586	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00589	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0058d	81 f9 eb 00 00
	00		 cmp	 ecx, 235		; 000000ebH
  00593	0f 85 f4 00 00
	00		 jne	 $LN21@ItemSerial

; 3184 : 		if(gObj[lpMsg->aIndex].Connected > 1) {			// 인증을 받은 상태까지는 인정

  00599	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0059c	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  005a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a9	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  005ae	0f 8e d4 00 00
	00		 jle	 $LN25@ItemSerial

; 3185 : #ifdef ITEM_INDEX_EXTEND_20050706
; 3186 : 			INT iType = lpMsg->Type/MAX_ITEM_INDEX;
; 3187 : 			INT iTypeIndex = lpMsg->Type%MAX_ITEM_INDEX;
; 3188 : #else
; 3189 : 			BYTE iType = lpMsg->Type >> ITEM_BITSHIFT;

  005b4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  005b7	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  005bb	c1 f9 05	 sar	 ecx, 5
  005be	88 8d 7b fe ff
	ff		 mov	 BYTE PTR _iType$13[ebp], cl

; 3190 : 			BYTE iTypeIndex = lpMsg->Type & 0x1F;

  005c4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  005c7	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  005cb	83 e1 1f	 and	 ecx, 31			; 0000001fH
  005ce	88 8d 7a fe ff
	ff		 mov	 BYTE PTR _iTypeIndex$12[ebp], cl

; 3191 : #endif
; 3192 : 			BYTE iItemPos = gObjInventoryInsertItem(&gObj[lpMsg->aIndex], iType, iTypeIndex, lpMsg->Level, lpMsg->m_Number, lpMsg->Dur);

  005d4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  005d7	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  005db	51		 push	 ecx
  005dc	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  005df	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  005e2	50		 push	 eax
  005e3	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  005e6	0f b6 51 0e	 movzx	 edx, BYTE PTR [ecx+14]
  005ea	52		 push	 edx
  005eb	0f b6 85 7a fe
	ff ff		 movzx	 eax, BYTE PTR _iTypeIndex$12[ebp]
  005f2	50		 push	 eax
  005f3	0f b6 8d 7b fe
	ff ff		 movzx	 ecx, BYTE PTR _iType$13[ebp]
  005fa	51		 push	 ecx
  005fb	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  005fe	69 42 14 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+20], 7072
  00605	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0060b	50		 push	 eax
  0060c	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z ; gObjInventoryInsertItem
  00611	83 c4 18	 add	 esp, 24			; 00000018H
  00614	88 85 79 fe ff
	ff		 mov	 BYTE PTR _iItemPos$11[ebp], al

; 3193 : 			if (0xFF == iItemPos) {

  0061a	0f b6 85 79 fe
	ff ff		 movzx	 eax, BYTE PTR _iItemPos$11[ebp]
  00621	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00626	75 49		 jne	 SHORT $LN24@ItemSerial

; 3194 : 				// 에러
; 3195 : 				LogAddTD("[Mu_2Anv_Event] Error : Failed To Gift Item Type:%d, TypeIndex:%d to [%s][%s]",

  00628	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0062b	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  00632	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00638	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0063c	50		 push	 eax
  0063d	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00640	69 51 14 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+20], 7072
  00647	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0064c	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00650	51		 push	 ecx
  00651	0f b6 95 7a fe
	ff ff		 movzx	 edx, BYTE PTR _iTypeIndex$12[ebp]
  00658	52		 push	 edx
  00659	0f b6 85 7b fe
	ff ff		 movzx	 eax, BYTE PTR _iType$13[ebp]
  00660	50		 push	 eax
  00661	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@DCIKCPFD@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Failed?5@
  00666	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0066c	83 c4 14	 add	 esp, 20			; 00000014H

; 3196 : 					iType,
; 3197 : 					iTypeIndex,
; 3198 : 					gObj[lpMsg->aIndex].AccountID,
; 3199 : 					gObj[lpMsg->aIndex].Name
; 3200 : 					);
; 3201 : 			}

  0066f	eb 17		 jmp	 SHORT $LN25@ItemSerial
$LN24@ItemSerial:

; 3202 : 			else {
; 3203 : 				GCInventoryItemOneSend (lpMsg->aIndex, iItemPos);

  00671	0f b6 85 79 fe
	ff ff		 movzx	 eax, BYTE PTR _iItemPos$11[ebp]
  00678	50		 push	 eax
  00679	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0067c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0067f	52		 push	 edx
  00680	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  00685	83 c4 08	 add	 esp, 8
$LN25@ItemSerial:

; 3204 : 			}
; 3205 : 		}
; 3206 : 	}

  00688	e9 ee 05 00 00	 jmp	 $LN31@ItemSerial
$LN21@ItemSerial:

; 3207 : //#endif // EVENT_FRIENDSHIP_20040204 || EVENT_LOTTO	
; 3208 : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 3209 : 	else if( lpMsg->MapNumber == ITEMMAKE_INVENTORY_CASHITEM )
; 3210 : 	{
; 3211 : 		if( gObj[lpMsg->aIndex].Connected > 1 )
; 3212 : 		{
; 3213 : 			CItem pCreateItem;
; 3214 : 			int iItemType	= lpMsg->Type / MAX_ITEM_INDEX;
; 3215 : 			int iItemIndex	= lpMsg->Type % MAX_ITEM_INDEX;
; 3216 : 
; 3217 : 			pCreateItem.m_Level = lpMsg->Level;
; 3218 : 			pCreateItem.m_Durability = lpMsg->Dur;
; 3219 : 			
; 3220 : 			pCreateItem.Convert( MAKE_ITEMNUM( iItemType, iItemIndex ), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption );
; 3221 : 			//pCreateItem.m_Level = lpMsg->Level;
; 3222 : 			//pCreateItem.m_Durability = lpMsg->Dur;
; 3223 : 			BYTE btItemPos = gObjInventoryInsertItem( lpMsg->aIndex, pCreateItem );
; 3224 : 			if (0xFF == btItemPos) {
; 3225 : 				// 에러
; 3226 : 				LogAddTD("[CashShop] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",
; 3227 : 					iItemType,
; 3228 : 					iItemIndex,
; 3229 : 					gObj[lpMsg->aIndex].AccountID,
; 3230 : 					gObj[lpMsg->aIndex].Name
; 3231 : 					);
; 3232 : 			}
; 3233 : 			else {
; 3234 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);
; 3235 : 			}
; 3236 : 		}
; 3237 : 	}
; 3238 : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 3239 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029	// 행운의 동전을 교환된 아이템을 인벤에 추가
; 3240 : 	else if( lpMsg->MapNumber == ITEMMAKE_INVENTORY_COINITEM )
; 3241 : 	{
; 3242 : 		if( gObj[lpMsg->aIndex].Connected > 1 )
; 3243 : 		{
; 3244 : 			CItem pCreateItem;
; 3245 : 			int iItemType	= lpMsg->Type / MAX_ITEM_INDEX;
; 3246 : 			int iItemIndex	= lpMsg->Type % MAX_ITEM_INDEX;
; 3247 : 
; 3248 : 			pCreateItem.m_Level = lpMsg->Level;
; 3249 : 			pCreateItem.m_Durability = lpMsg->Dur;
; 3250 : 
; 3251 : 			pCreateItem.Convert( MAKE_ITEMNUM( iItemType, iItemIndex ), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption );
; 3252 : 			pCreateItem.m_Level = lpMsg->Level;
; 3253 : 			//pCreateItem.m_Durability = lpMsg->Dur;
; 3254 : 			//pCreateItem.m_Number = lpMsg->m_Number;
; 3255 : 			BYTE btItemPos = gObjInventoryInsertItem( lpMsg->aIndex, pCreateItem );
; 3256 : 			if (0xFF == btItemPos) {
; 3257 : 				// 에러
; 3258 : 				LogAddTD("[LuckyCoin Trade] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",
; 3259 : 					iItemType,
; 3260 : 					iItemIndex,
; 3261 : 					gObj[lpMsg->aIndex].AccountID,
; 3262 : 					gObj[lpMsg->aIndex].Name
; 3263 : 					);
; 3264 : 				GCANSTradeCoin(lpMsg->aIndex, 2);
; 3265 : 			}
; 3266 : 			else {
; 3267 : 				// 아이템 전송
; 3268 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);
; 3269 : 				GCANSTradeCoin(lpMsg->aIndex, 1);
; 3270 : 			}
; 3271 : 			
; 3272 : 			gObj[aIndex].ChaosLock = FALSE;
; 3273 : 		}
; 3274 : 	}
; 3275 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029
; 3276 : #ifdef ADD_GAMBLING_20090120		// 겜블링을 해서 획득한 아이템을 인벤에 추가
; 3277 : 	else if( lpMsg->MapNumber == ITEMMAKE_INVENTORY_GAMBLINGITEM )
; 3278 : 	{
; 3279 : 		if( gObj[lpMsg->aIndex].Connected > 1 )
; 3280 : 		{
; 3281 : 			CItem pCreateItem;
; 3282 : 			int iItemType	= lpMsg->Type / MAX_ITEM_INDEX;
; 3283 : 			int iItemIndex	= lpMsg->Type % MAX_ITEM_INDEX;
; 3284 : 			
; 3285 : 			pCreateItem.m_Level = lpMsg->Level;
; 3286 : 			pCreateItem.m_Durability = lpMsg->Dur;
; 3287 : 
; 3288 : #ifdef MODIFY_GAMBLING_BUGFIX_1_20090323
; 3289 : 			pCreateItem.m_Number = lpMsg->m_Number;
; 3290 : #endif // MODIFY_GAMBLING_BUGFIX_1_20090323
; 3291 : 			
; 3292 : 			pCreateItem.Convert( MAKE_ITEMNUM( iItemType, iItemIndex ), lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption );
; 3293 : 			pCreateItem.m_Level = lpMsg->Level;
; 3294 : 
; 3295 : 			// 인벤에 2*4의 공간이 있는지 체크한다.
; 3296 : 			BOOL bIsBlank = gObjGamblingInventoryCheck( lpMsg->aIndex, 2, 4 );
; 3297 : 			if ( bIsBlank == TRUE ) {
; 3298 : 				// 아이템을 인벤에 넣어준다.
; 3299 : 				BYTE btItemPos = gObjInventoryInsertItem( lpMsg->aIndex, pCreateItem );
; 3300 : 
; 3301 : 				if( btItemPos == 0xFF )
; 3302 : 				{
; 3303 : 					// 에러
; 3304 : 					LogAddTD("[Gambling Trade] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",
; 3305 : 						iItemType,
; 3306 : 						iItemIndex,
; 3307 : 						gObj[lpMsg->aIndex].AccountID,
; 3308 : 						gObj[lpMsg->aIndex].Name
; 3309 : 					);
; 3310 : 
; 3311 : #ifdef MODIFY_GAMBLING_COMPLEMENT_20090513
; 3312 : 					// 클라이언트로 일단 패킷을 리턴해준다.
; 3313 : 					PMSG_BUYRESULT	pResult;			
; 3314 : 					PHeadSetB((LPBYTE)&pResult, 0x32, sizeof( pResult ));
; 3315 : 					pResult.Result = 0xFF;
; 3316 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3317 : #endif // MODIFY_GAMBLING_COMPLEMENT_20090513
; 3318 : 
; 3319 : #ifdef MODIFY_GAMBLING_BUGFIX_1_20090323
; 3320 : 					return;
; 3321 : #endif // MODIFY_GAMBLING_BUGFIX_1_20090323
; 3322 : 				}
; 3323 : 				
; 3324 : 				int iBuyTaxMoney = (INT)((INT64)g_iGamblingValue * (INT64)g_CastleSiegeSync.GetTaxRateStore(gObj[lpMsg->aIndex].m_Index) / (INT64)100);
; 3325 : 				g_CastleSiegeSync.AddTributeMoney(iBuyTaxMoney);	// 상점에서 물건을 판 세금을 저장
; 3326 : 
; 3327 : 				gObj[lpMsg->aIndex].Money -= (g_iGamblingValue + iBuyTaxMoney);
; 3328 : 								
; 3329 : 				if( gObj[lpMsg->aIndex].Money < 0 )
; 3330 : 					gObj[lpMsg->aIndex].Money = 0;
; 3331 : 				
; 3332 : 				GCMoneySend(gObj[lpMsg->aIndex].m_Index, gObj[lpMsg->aIndex].Money);
; 3333 : 				
; 3334 : 				// 아이템 전송
; 3335 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);
; 3336 : 				
; 3337 : 				// 겜블링 아이템을 받은 유저를 로그로 남긴다.
; 3338 : 				BYTE ExOption[6];
; 3339 : 				ItemIsBufExOption(ExOption, &pCreateItem);
; 3340 : 
; 3341 : 				// 겜블링 아이템일 경우 축하 메시지와 폭죽을 터트려준다.
; 3342 : 				if( lpMsg->Type ==  MAKE_ITEMNUM(3, 11)
; 3343 : 					|| lpMsg->Type ==  MAKE_ITEMNUM(5, 33)
; 3344 : 					|| lpMsg->Type ==  MAKE_ITEMNUM(4, 24)
; 3345 : 					|| lpMsg->Type ==  MAKE_ITEMNUM(2, 18)
; 3346 : 					|| lpMsg->Type ==  MAKE_ITEMNUM(5, 34)
; 3347 : 					)
; 3348 : 				{					
; 3349 : 					char szBuffer[512] = "";
; 3350 : 					sprintf( szBuffer, lMsg.Get(1262), gObj[lpMsg->aIndex].Name, pCreateItem.GetName() );
; 3351 : 					
; 3352 : 					PMSG_NOTICE	pNotice;
; 3353 : 					TNotice::MakeNoticeMsg( &pNotice, 0, szBuffer );
; 3354 : 					TNotice::SendNoticeToAllUser( &pNotice );
; 3355 : 
; 3356 : 					PMSG_SERVERCMD	ServerCmd;
; 3357 : 					PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			
; 3358 : 					ServerCmd.CmdType = 0;
; 3359 : 					ServerCmd.X = gObj[lpMsg->aIndex].X;
; 3360 : 					ServerCmd.Y = gObj[lpMsg->aIndex].Y;
; 3361 : 					MsgSendV2( &gObj[lpMsg->aIndex], (LPBYTE)&ServerCmd, sizeof(ServerCmd) );
; 3362 : 					DataSend( lpMsg->aIndex, (LPBYTE)&ServerCmd, sizeof(ServerCmd));				
; 3363 : 
; 3364 : 					LogAddTD("[Gambling Unique] User:%s(%s) Item:[%s,%d,%d,%d,%d]serial:[%u][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d] 380:[%d] HO:[%d,%d] Socket[%d,%d,%d,%d,%d]", 
; 3365 : 						gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name,
; 3366 : 						pCreateItem.GetName(),
; 3367 : 						pCreateItem.m_Level,
; 3368 : 						pCreateItem.m_Option1,
; 3369 : 						pCreateItem.m_Option2,
; 3370 : 						pCreateItem.m_Option3,
; 3371 : 						pCreateItem.m_Number,
; 3372 : 						(int)pCreateItem.m_Durability,
; 3373 : 						ExOption[0],
; 3374 : 						ExOption[1],
; 3375 : 						ExOption[2],
; 3376 : 						ExOption[3],
; 3377 : 						ExOption[4],
; 3378 : 						ExOption[5],
; 3379 : 						ExOption[6],
; 3380 : 						pCreateItem.m_SetOption,
; 3381 : 						pCreateItem.m_ItemOptionEx >> 7,
; 3382 : 						g_kJewelOfHarmonySystem.GetItemStrengthenOption( &pCreateItem ),
; 3383 : 						g_kJewelOfHarmonySystem.GetItemOptionLevel( &pCreateItem ),
; 3384 : 						pCreateItem.m_SocketOption[0],
; 3385 : 						pCreateItem.m_SocketOption[1],
; 3386 : 						pCreateItem.m_SocketOption[2],
; 3387 : 						pCreateItem.m_SocketOption[3],
; 3388 : 						pCreateItem.m_SocketOption[4]
; 3389 : 					);
; 3390 : 				}
; 3391 : 				else
; 3392 : 				{
; 3393 : 					LogAddTD("[Gambling Normal] User:%s(%s) Item:[%s,%d,%d,%d,%d]serial:[%u][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d] 380:[%d] HO:[%d,%d] Socket[%d,%d,%d,%d,%d]", 
; 3394 : 						gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name,
; 3395 : 						pCreateItem.GetName(),
; 3396 : 						pCreateItem.m_Level,
; 3397 : 						pCreateItem.m_Option1,
; 3398 : 						pCreateItem.m_Option2,
; 3399 : 						pCreateItem.m_Option3,
; 3400 : 						pCreateItem.m_Number,
; 3401 : 						(int)pCreateItem.m_Durability,
; 3402 : 						ExOption[0],
; 3403 : 						ExOption[1],
; 3404 : 						ExOption[2],
; 3405 : 						ExOption[3],
; 3406 : 						ExOption[4],
; 3407 : 						ExOption[5],
; 3408 : 						ExOption[6],
; 3409 : 						pCreateItem.m_SetOption,
; 3410 : 						pCreateItem.m_ItemOptionEx >> 7,
; 3411 : 						g_kJewelOfHarmonySystem.GetItemStrengthenOption( &pCreateItem ),
; 3412 : 						g_kJewelOfHarmonySystem.GetItemOptionLevel( &pCreateItem ),
; 3413 : 						pCreateItem.m_SocketOption[0],
; 3414 : 						pCreateItem.m_SocketOption[1],
; 3415 : 						pCreateItem.m_SocketOption[2],
; 3416 : 						pCreateItem.m_SocketOption[3],
; 3417 : 						pCreateItem.m_SocketOption[4]
; 3418 : 					);
; 3419 : 				}
; 3420 : 			}
; 3421 : 			else {
; 3422 : 				// 겜블 아이템 구매 실패
; 3423 : 				GCServerMsgStringSend( lMsg.Get(1260), lpMsg->aIndex, 1);
; 3424 : 				
; 3425 : 				LogAddTD("[Gambling Fail] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",
; 3426 : 					iItemType,
; 3427 : 					iItemIndex,
; 3428 : 					gObj[lpMsg->aIndex].AccountID,
; 3429 : 					gObj[lpMsg->aIndex].Name
; 3430 : 					);
; 3431 : 			}
; 3432 : 
; 3433 : 			// 클라이언트로 일단 패킷을 리턴해준다.
; 3434 : 			PMSG_BUYRESULT	pResult;			
; 3435 : 			PHeadSetB((LPBYTE)&pResult, 0x32, sizeof( pResult ));
; 3436 : 			pResult.Result = 0xFF;
; 3437 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3438 : 			
; 3439 : 			gObj[aIndex].ChaosLock = FALSE;
; 3440 : 		}
; 3441 : 	}
; 3442 : #endif	// ADD_GAMBLING_20090120
; 3443 : 	else 
; 3444 : 	{
; 3445 : 
; 3446 : 		//#ifdef PICKUP_SYSTEM
; 3447 : 		//	s_PickUp.PickUpActive(lpObj->m_Index, 0);
; 3448 : 		//#endif
; 3449 : 		//PICKUP
; 3450 : #ifdef PICKUP_SYSTEM
; 3451 : 		BOOL DropItem;
; 3452 : 		if (s_PickUp.PickUpActive(lpMsg->lootindex, lpMsg->Type))

  0068d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00690	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00694	51		 push	 ecx
  00695	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00698	0f bf 42 18	 movsx	 eax, WORD PTR [edx+24]
  0069c	50		 push	 eax
  0069d	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_PickUp@@3VCPickUpSystem@@A ; s_PickUp
  006a2	e8 00 00 00 00	 call	 ?PickUpActive@CPickUpSystem@@QAEHHH@Z ; CPickUpSystem::PickUpActive
  006a7	85 c0		 test	 eax, eax
  006a9	0f 84 a2 01 00
	00		 je	 $LN26@ItemSerial

; 3453 : 		{
; 3454 : 
; 3455 : 			if (gObj[lpMsg->lootindex].Connected > PLAYER_CONNECTED)

  006af	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006b2	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  006b6	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  006bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006c1	83 7c 10 04 01	 cmp	 DWORD PTR [eax+edx+4], 1
  006c6	0f 8e 83 01 00
	00		 jle	 $LN30@ItemSerial

; 3456 : 			{
; 3457 : 				CItem pCreateItem;

  006cc	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$9[ebp]
  006d2	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3458 : 				int iItemType = ITEM_GET_TYPE(lpMsg->Type);

  006d7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006da	0f bf 40 0c	 movsx	 eax, WORD PTR [eax+12]
  006de	99		 cdq
  006df	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  006e5	03 c2		 add	 eax, edx
  006e7	c1 f8 09	 sar	 eax, 9
  006ea	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _iItemType$8[ebp], eax

; 3459 : 				int iItemIndex = ITEM_GET_INDEX(lpMsg->Type);

  006f0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006f3	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  006f7	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  006fd	79 08		 jns	 SHORT $LN46@ItemSerial
  006ff	49		 dec	 ecx
  00700	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  00706	41		 inc	 ecx
$LN46@ItemSerial:
  00707	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _iItemIndex$7[ebp], ecx

; 3460 : 
; 3461 : 				pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2,

  0070d	6a 00		 push	 0
  0070f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00712	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  00716	51		 push	 ecx
  00717	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0071a	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  0071e	50		 push	 eax
  0071f	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00722	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  00726	52		 push	 edx
  00727	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0072a	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  0072e	51		 push	 ecx
  0072f	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00732	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00736	50		 push	 eax
  00737	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _iItemType$8[ebp]
  0073d	c1 e1 09	 shl	 ecx, 9
  00740	03 8d c4 fd ff
	ff		 add	 ecx, DWORD PTR _iItemIndex$7[ebp]
  00746	51		 push	 ecx
  00747	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$9[ebp]
  0074d	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3462 : 					lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0);
; 3463 : 				pCreateItem.m_Level = lpMsg->Level;

  00752	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00755	66 0f b6 48 0e	 movzx	 cx, BYTE PTR [eax+14]
  0075a	66 89 8d d4 fd
	ff ff		 mov	 WORD PTR _pCreateItem$9[ebp+8], cx

; 3464 : 				pCreateItem.m_Durability = lpMsg->Dur;

  00761	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00764	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  00768	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0076c	f3 0f 11 85 f0
	fd ff ff	 movss	 DWORD PTR _pCreateItem$9[ebp+36], xmm0

; 3465 : 
; 3466 : 				BYTE btItemPos = gObjInventoryInsertItem(lpMsg->lootindex, pCreateItem);

  00774	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0077a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0077f	8d b5 cc fd ff
	ff		 lea	 esi, DWORD PTR _pCreateItem$9[ebp]
  00785	8b fc		 mov	 edi, esp
  00787	f3 a5		 rep movsd
  00789	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0078c	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  00790	51		 push	 ecx
  00791	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  00796	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  0079c	88 85 c3 fd ff
	ff		 mov	 BYTE PTR _btItemPos$6[ebp], al

; 3467 : 
; 3468 : 				if (btItemPos == (BYTE)-1)

  007a2	0f b6 85 c3 fd
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$6[ebp]
  007a9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  007ae	75 57		 jne	 SHORT $LN29@ItemSerial

; 3469 : 				{
; 3470 : 					DropItem = false;

  007b0	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _DropItem$10[ebp], 0

; 3471 : 					LogAddTD("[PickupSystem] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",

  007ba	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007bd	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  007c1	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  007c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007cc	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  007d0	51		 push	 ecx
  007d1	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  007d4	0f bf 42 18	 movsx	 eax, WORD PTR [edx+24]
  007d8	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  007de	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007e4	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  007e8	50		 push	 eax
  007e9	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _iItemIndex$7[ebp]
  007ef	51		 push	 ecx
  007f0	8b 95 c8 fd ff
	ff		 mov	 edx, DWORD PTR _iItemType$8[ebp]
  007f6	52		 push	 edx
  007f7	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@FICGMJHI@?$FLPickupSystem?$FN?5Error?5?3?5Failed?5T@
  007fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00802	83 c4 14	 add	 esp, 20			; 00000014H

; 3472 : 						iItemType, iItemIndex, gObj[lpMsg->lootindex].AccountID, gObj[lpMsg->lootindex].Name);
; 3473 : 				}

  00805	eb 48		 jmp	 SHORT $LN30@ItemSerial
$LN29@ItemSerial:

; 3474 : 				else
; 3475 : 				{
; 3476 : 					DropItem = true;

  00807	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _DropItem$10[ebp], 1

; 3477 : 					GCInventoryItemOneSend(lpMsg->lootindex, btItemPos);

  00811	0f b6 85 c3 fd
	ff ff		 movzx	 eax, BYTE PTR _btItemPos$6[ebp]
  00818	50		 push	 eax
  00819	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0081c	0f bf 51 18	 movsx	 edx, WORD PTR [ecx+24]
  00820	52		 push	 edx
  00821	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  00826	83 c4 08	 add	 esp, 8

; 3478 : 					MsgOutput(lpMsg->lootindex, "[PickUp System] : %s Obtained", ItemAttribute[lpMsg->Type].Name);

  00829	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0082c	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00830	6b d1 6c	 imul	 edx, ecx, 108
  00833	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00839	52		 push	 edx
  0083a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@CNHMPMBL@?$FLPickUp?5System?$FN?5?3?5?$CFs?5Obtained@
  0083f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00842	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  00846	51		 push	 ecx
  00847	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0084c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@ItemSerial:

; 3479 : 				}
; 3480 : 			}
; 3481 : 
; 3482 : 		}

  0084f	eb 0a		 jmp	 SHORT $LN27@ItemSerial
$LN26@ItemSerial:

; 3483 : 		else
; 3484 : 		{
; 3485 : 
; 3486 : 			DropItem = false;

  00851	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _DropItem$10[ebp], 0
$LN27@ItemSerial:

; 3487 : 		}
; 3488 : 		if (!DropItem)

  0085b	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _DropItem$10[ebp], 0
  00862	0f 85 13 04 00
	00		 jne	 $LN31@ItemSerial

; 3489 : 		{
; 3490 : #endif
; 3491 : #ifdef FOR_BLOODCASTLE
; 3492 : 		INT iRetMapNumber = lpMsg->MapNumber;

  00868	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0086b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0086f	89 8d bc fd ff
	ff		 mov	 DWORD PTR _iRetMapNumber$5[ebp], ecx

; 3493 : 
; 3494 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 맵 체크 변경
; 3495 : 		if ((lpMsg->MapNumber >= BC_MAPNUMBER_CHAOSGEM1) && (lpMsg->MapNumber <= BC_MAPNUMBER_CHAOSGEM8)) 
; 3496 : 		{
; 3497 : 			mapnumber = g_BloodCastle.GetMapNumByBC_CHAOSGEM( iRetMapNumber );
; 3498 : 		}
; 3499 : #else		
; 3500 : #ifdef BLOODCASTLE_EXTEND_20040314
; 3501 : 		if ((lpMsg->MapNumber >= BC_MAPNUMBER_CHAOSGEM1) && (lpMsg->MapNumber <= BC_MAPNUMBER_CHAOSGEM7)) {

  00875	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00878	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0087c	81 f9 ee 00 00
	00		 cmp	 ecx, 238		; 000000eeH
  00882	7c 1a		 jl	 SHORT $LN32@ItemSerial
  00884	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00887	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0088b	81 f9 f4 00 00
	00		 cmp	 ecx, 244		; 000000f4H
  00891	7f 0b		 jg	 SHORT $LN32@ItemSerial

; 3502 : #else
; 3503 : 		if ((lpMsg->MapNumber >= BC_MAPNUMBER_CHAOSGEM1) && (lpMsg->MapNumber <= BC_MAPNUMBER_CHAOSGEM6)) {
; 3504 : #endif
; 3505 : 			mapnumber -= BC_MAPNUMBER_BASE_CHAOSGEM;

  00893	8b 45 f4	 mov	 eax, DWORD PTR _mapnumber$[ebp]
  00896	2d e3 00 00 00	 sub	 eax, 227		; 000000e3H
  0089b	89 45 f4	 mov	 DWORD PTR _mapnumber$[ebp], eax
$LN32@ItemSerial:

; 3506 : 		}
; 3507 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 3508 : 
; 3509 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 맵 체크 변경		
; 3510 : 		if ((lpMsg->MapNumber >= BC_MAPNUMBER_ULTIMATEWEAPON1) && (lpMsg->MapNumber <= BC_MAPNUMBER_ULTIMATEWEAPON8)) 
; 3511 : 		{
; 3512 : 			mapnumber = g_BloodCastle.GetMapNumByBC_ULTIMATEWEAPON( iRetMapNumber );
; 3513 : 		}
; 3514 : #else
; 3515 : #ifdef BLOODCASTLE_EXTEND_20040314
; 3516 : 		if ((lpMsg->MapNumber >= BC_MAPNUMBER_ULTIMATEWEAPON1) && (lpMsg->MapNumber <= BC_MAPNUMBER_ULTIMATEWEAPON7)) {

  0089e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008a1	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  008a5	81 f9 f7 00 00
	00		 cmp	 ecx, 247		; 000000f7H
  008ab	7c 1a		 jl	 SHORT $LN33@ItemSerial
  008ad	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008b0	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  008b4	81 f9 fd 00 00
	00		 cmp	 ecx, 253		; 000000fdH
  008ba	7f 0b		 jg	 SHORT $LN33@ItemSerial

; 3517 : #else
; 3518 : 		if ((lpMsg->MapNumber >= BC_MAPNUMBER_ULTIMATEWEAPON1) && (lpMsg->MapNumber <= BC_MAPNUMBER_ULTIMATEWEAPON6)) {
; 3519 : #endif
; 3520 : 			mapnumber -= BC_MAPNUMBER_BASE_ULTIMATEWEAPON;

  008bc	8b 45 f4	 mov	 eax, DWORD PTR _mapnumber$[ebp]
  008bf	2d ec 00 00 00	 sub	 eax, 236		; 000000ecH
  008c4	89 45 f4	 mov	 DWORD PTR _mapnumber$[ebp], eax
$LN33@ItemSerial:

; 3521 : 		}
; 3522 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		
; 3523 : 
; 3524 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 3525 : 		// 소켓아이템은 엑설런트옵션과 세트옵션을 삭제한다.
; 3526 : 
; 3527 : 		BYTE btSocketSlotCount = 0;
; 3528 : 		BYTE btSocketOption[MAX_SOCKET_SLOT];
; 3529 : 		BYTE btBonusSocketOption = 0;
; 3530 : 
; 3531 : 		if( g_SocketOptionSystem.IsEnableSocketItem( lpMsg->Type ) == true )
; 3532 : 		{	
; 3533 : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_05_20080715
; 3534 : 			btSocketSlotCount = g_SocketOptionSystem.GetMakeSocketSlotCount( lpMsg->Type );
; 3535 : #else
; 3536 : 			btSocketSlotCount = g_SocketOptionSystem.GetMakeSocketSlotCount();
; 3537 : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_05_20080715
; 3538 : 			
; 3539 : #ifdef ADD_SOCKET_OPTION_LOG_02_20080821
; 3540 : 			LogAddTD( "[SocketItem] Drop Socket Item ( Socket Slot : %d ) - %s, [%d,%d,%d,%d], Serial : %u, ItemCode : %d, Level : %d, MapNumber : %d(%d/%d)",
; 3541 : 				 btSocketSlotCount, ItemAttribute[lpMsg->Type].Name, lpMsg->Level, lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->m_Number, lpMsg->Type, lpMsg->Level, lpMsg->MapNumber, lpMsg->x, lpMsg->y );
; 3542 : #else
; 3543 : 	#ifdef ADD_SOCKET_OPTION_LOG_20080715
; 3544 : 			LogAddTD( "[SocketItem] Drop Socket Item ( Socket Slot : %d ) - ItemCode : %d, Level : %d, MapNumber : %d(%d/%d)",
; 3545 : 				 btSocketSlotCount, lpMsg->Type, lpMsg->Level, lpMsg->MapNumber, lpMsg->x, lpMsg->y );
; 3546 : 	#endif // ADD_SOCKET_OPTION_LOG_20080715
; 3547 : #endif // ADD_SOCKET_OPTION_LOG_02_20080821
; 3548 : 
; 3549 : 			btBonusSocketOption = SOCKETSLOT_NONE;
; 3550 : 
; 3551 : 			for( int i = 0 ; i < MAX_SOCKET_SLOT ; i++ )
; 3552 : 			{
; 3553 : 				if( i < btSocketSlotCount )
; 3554 : 				{
; 3555 : 					btSocketOption[i] = SOCKETSLOT_EMPTY;
; 3556 : 				}
; 3557 : 				else
; 3558 : 				{
; 3559 : 					btSocketOption[i] = SOCKETSLOT_NONE;
; 3560 : 				}
; 3561 : 			}
; 3562 : 		}
; 3563 : 		else
; 3564 : 		{
; 3565 : 			btBonusSocketOption = 0;
; 3566 : 
; 3567 : 			for( int i = 0 ; i < MAX_SOCKET_SLOT ; i++ )
; 3568 : 			{
; 3569 : 				btSocketOption[i] = SOCKETSLOT_NONE;
; 3570 : 			}
; 3571 : 		}
; 3572 : 
; 3573 : 		INT iItemCount = MapC[mapnumber].MonsterItemDrop(
; 3574 : 							lpMsg->Type, 
; 3575 : 							lpMsg->Level, 
; 3576 : 							lpMsg->Dur, 
; 3577 : 							lpMsg->x, 
; 3578 : 							lpMsg->y, 
; 3579 : 							lpMsg->Op1, 
; 3580 : 							lpMsg->Op2, 
; 3581 : 							lpMsg->Op3, 
; 3582 : 							lpMsg->NewOption,
; 3583 : 							lpMsg->SetOption,
; 3584 : 							lootindex, 
; 3585 : 							lpMsg->m_Number,
; 3586 : 							0,
; 3587 : 							btSocketOption,
; 3588 :   							btBonusSocketOption );
; 3589 : 
; 3590 : #else
; 3591 : 
; 3592 : 		INT iItemCount = MapC[mapnumber].MonsterItemDrop(

  008c7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008ca	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  008cd	51		 push	 ecx
  008ce	8b 55 ec	 mov	 edx, DWORD PTR _lootindex$[ebp]
  008d1	52		 push	 edx
  008d2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008d5	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  008d9	51		 push	 ecx
  008da	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  008dd	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  008e1	50		 push	 eax
  008e2	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  008e5	0f b6 51 12	 movzx	 edx, BYTE PTR [ecx+18]
  008e9	52		 push	 edx
  008ea	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008ed	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  008f1	51		 push	 ecx
  008f2	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  008f5	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  008f9	50		 push	 eax
  008fa	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  008fd	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00901	52		 push	 edx
  00902	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00905	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00909	51		 push	 ecx
  0090a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0090d	0f b6 42 0f	 movzx	 eax, BYTE PTR [edx+15]
  00911	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00915	51		 push	 ecx
  00916	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0091b	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0091e	0f b6 51 0e	 movzx	 edx, BYTE PTR [ecx+14]
  00922	52		 push	 edx
  00923	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00926	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  0092a	51		 push	 ecx
  0092b	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  00932	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00938	e8 00 00 00 00	 call	 ?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z ; MapClass::MonsterItemDrop
  0093d	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _iItemCount$4[ebp], eax

; 3593 : 							lpMsg->Type, 
; 3594 : 							lpMsg->Level, 
; 3595 : 							lpMsg->Dur, 
; 3596 : 							lpMsg->x, 
; 3597 : 							lpMsg->y, 
; 3598 : 							lpMsg->Op1, 
; 3599 : 							lpMsg->Op2, 
; 3600 : 							lpMsg->Op3, 
; 3601 : 							lpMsg->NewOption,
; 3602 : 							lpMsg->SetOption,
; 3603 : 							lootindex, 
; 3604 : 							lpMsg->m_Number);
; 3605 : 
; 3606 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 3607 : 
; 3608 : 		if (iItemCount != -1) 

  00943	83 bd b8 fd ff
	ff ff		 cmp	 DWORD PTR _iItemCount$4[ebp], -1
  0094a	0f 84 f1 00 00
	00		 je	 $LN36@ItemSerial

; 3609 : 		{
; 3610 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		// 맵 체크 변경 
; 3611 : 			if ((iRetMapNumber >= BC_MAPNUMBER_CHAOSGEM1) && (iRetMapNumber <= BC_MAPNUMBER_CHAOSGEM8)) {
; 3612 : #else
; 3613 : #ifdef BLOODCASTLE_EXTEND_20040314
; 3614 : 			if ((iRetMapNumber >= BC_MAPNUMBER_CHAOSGEM1) && (iRetMapNumber <= BC_MAPNUMBER_CHAOSGEM7)) {

  00950	81 bd bc fd ff
	ff ee 00 00 00	 cmp	 DWORD PTR _iRetMapNumber$5[ebp], 238 ; 000000eeH
  0095a	7c 5e		 jl	 SHORT $LN35@ItemSerial
  0095c	81 bd bc fd ff
	ff f4 00 00 00	 cmp	 DWORD PTR _iRetMapNumber$5[ebp], 244 ; 000000f4H
  00966	7f 52		 jg	 SHORT $LN35@ItemSerial

; 3615 : #else
; 3616 : 			if ((iRetMapNumber >= BC_MAPNUMBER_CHAOSGEM1) && (iRetMapNumber <= BC_MAPNUMBER_CHAOSGEM6)) {
; 3617 : #endif
; 3618 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 3619 : 				// 만약 아이템이 대천사 보상 혼석이라면
; 3620 : 				MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + BC_REWARD_CHAOSEGEM_LOOT_TIME;

  00968	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0096e	05 e0 93 04 00	 add	 eax, 300000		; 000493e0H
  00973	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  0097a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00980	69 95 b8 fd ff
	ff 48 04 00 00	 imul	 edx, DWORD PTR _iItemCount$4[ebp], 1096
  0098a	89 84 11 d4 00
	00 00		 mov	 DWORD PTR [ecx+edx+212], eax

; 3621 : 				MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + BC_ANGEL_WEAPON_LOOT_TIME * 2;

  00991	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00997	05 20 4e 00 00	 add	 eax, 20000		; 00004e20H
  0099c	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  009a3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  009a9	69 95 b8 fd ff
	ff 48 04 00 00	 imul	 edx, DWORD PTR _iItemCount$4[ebp], 1096
  009b3	89 84 11 dc 00
	00 00		 mov	 DWORD PTR [ecx+edx+220], eax
$LN35@ItemSerial:

; 3622 : 			}
; 3623 : 
; 3624 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		// 맵 체크 변경
; 3625 : 			if ((iRetMapNumber >= BC_MAPNUMBER_ULTIMATEWEAPON1) && (iRetMapNumber <= BC_MAPNUMBER_ULTIMATEWEAPON8)) 
; 3626 : 			{				
; 3627 : 				// 만약 아이템이 대천사 절대아이템 이라면
; 3628 : 				MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + BC_REWARD_CHAOSEGEM_LOOT_TIME * 3;
; 3629 : 				MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + BC_ANGEL_WEAPON_LOOT_TIME;
; 3630 : 
; 3631 : 				int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( mapnumber );
; 3632 : 				g_BloodCastle.m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL = lpMsg->m_Number;
; 3633 : 			}
; 3634 : #else
; 3635 : #ifdef BLOODCASTLE_EXTEND_20040314
; 3636 : 			if ((iRetMapNumber >= BC_MAPNUMBER_ULTIMATEWEAPON1) && (iRetMapNumber <= BC_MAPNUMBER_ULTIMATEWEAPON7)) {

  009ba	81 bd bc fd ff
	ff f7 00 00 00	 cmp	 DWORD PTR _iRetMapNumber$5[ebp], 247 ; 000000f7H
  009c4	7c 7b		 jl	 SHORT $LN36@ItemSerial
  009c6	81 bd bc fd ff
	ff fd 00 00 00	 cmp	 DWORD PTR _iRetMapNumber$5[ebp], 253 ; 000000fdH
  009d0	7f 6f		 jg	 SHORT $LN36@ItemSerial

; 3637 : #else
; 3638 : 			if ((iRetMapNumber >= BC_MAPNUMBER_ULTIMATEWEAPON1) && (iRetMapNumber <= BC_MAPNUMBER_ULTIMATEWEAPON6)) {
; 3639 : #endif
; 3640 : 				// 만약 아이템이 대천사 절대아이템 이라면
; 3641 : 				MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + BC_REWARD_CHAOSEGEM_LOOT_TIME * 3;

  009d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  009d8	05 a0 bb 0d 00	 add	 eax, 900000		; 000dbba0H
  009dd	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  009e4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  009ea	69 95 b8 fd ff
	ff 48 04 00 00	 imul	 edx, DWORD PTR _iItemCount$4[ebp], 1096
  009f4	89 84 11 d4 00
	00 00		 mov	 DWORD PTR [ecx+edx+212], eax

; 3642 : 				MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + BC_ANGEL_WEAPON_LOOT_TIME;

  009fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00a01	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  00a06	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  00a0d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00a13	69 95 b8 fd ff
	ff 48 04 00 00	 imul	 edx, DWORD PTR _iItemCount$4[ebp], 1096
  00a1d	89 84 11 dc 00
	00 00		 mov	 DWORD PTR [ecx+edx+220], eax

; 3643 : 				g_BloodCastle.m_BridgeData[iRetMapNumber - BC_MAPNUMBER_ULTIMATEWEAPON1].m_nBC_QUESTITEM_SERIAL = lpMsg->m_Number;

  00a24	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _iRetMapNumber$5[ebp]
  00a2a	2d f7 00 00 00	 sub	 eax, 247		; 000000f7H
  00a2f	69 c8 04 02 00
	00		 imul	 ecx, eax, 516
  00a35	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00a38	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00a3b	89 81 90 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+400], eax
$LN36@ItemSerial:

; 3644 : 			}
; 3645 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 3646 : 		}
; 3647 : 
; 3648 : #else
; 3649 : 		MapC[mapnumber].MonsterItemDrop(
; 3650 : 			lpMsg->Type, 
; 3651 : 			lpMsg->Level, 
; 3652 : 			lpMsg->Dur, 
; 3653 : 			lpMsg->x, 
; 3654 : 			lpMsg->y, 
; 3655 : 			lpMsg->Op1, 
; 3656 : 			lpMsg->Op2, 
; 3657 : 			lpMsg->Op3, 
; 3658 : 			lpMsg->NewOption,
; 3659 : 			lpMsg->SetOption,
; 3660 : 			lootindex, 
; 3661 : 			lpMsg->m_Number);
; 3662 : #endif
; 3663 : 
; 3664 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	// 성물 일경우 없어지는 시간과 루팅 시간 설정
; 3665 : 			if(CHECK_ILLUSION_TEMPLE(mapnumber))
; 3666 : 			{
; 3667 : 				// 성물 루팅 시간
; 3668 : 				if(lpMsg->Type == MAKE_ITEMNUM(14, 64))
; 3669 : 				{
; 3670 : 					MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + ILLUSION_TEMPLE_RELICS_LOOT_TIME * 3 * 1000;
; 3671 : 					MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + ILLUSION_TEMPLE_RELICS_LOOT_TIME * 1000;
; 3672 : 				}
; 3673 : 				
; 3674 : 				// 혼석 루팅 시간
; 3675 : 				if(lpMsg->Type == MAKE_ITEMNUM(12, 15))
; 3676 : 				{
; 3677 : 					MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + ILLUSION_TEMPLE_CHAOSGEM_LOOT_TIME;
; 3678 : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_2_20070724	//보상 혼석 루팅시간 10초
; 3679 : 					MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + 10*1000;
; 3680 : #else
; 3681 : 					MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + ILLUSION_TEMPLE_CHAOSGEM_LOOT_TIME * 2;
; 3682 : #endif
; 3683 : 				}
; 3684 : 			}
; 3685 : #endif
; 3686 : 
; 3687 : 		BYTE NewOption[8];
; 3688 : 		for( int i=0; i<8; i++) NewOption[i]=0;

  00a41	c7 85 ac fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$2[ebp], 0
  00a4b	eb 0f		 jmp	 SHORT $LN4@ItemSerial
$LN2@ItemSerial:
  00a4d	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  00a53	83 c0 01	 add	 eax, 1
  00a56	89 85 ac fd ff
	ff		 mov	 DWORD PTR _i$2[ebp], eax
$LN4@ItemSerial:
  00a5c	83 bd ac fd ff
	ff 08		 cmp	 DWORD PTR _i$2[ebp], 8
  00a63	7d 2c		 jge	 SHORT $LN3@ItemSerial
  00a65	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  00a6b	89 85 28 fd ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00a71	83 bd 28 fd ff
	ff 08		 cmp	 DWORD PTR $T1[ebp], 8
  00a78	73 02		 jae	 SHORT $LN44@ItemSerial
  00a7a	eb 05		 jmp	 SHORT $LN45@ItemSerial
$LN44@ItemSerial:
  00a7c	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN45@ItemSerial:
  00a81	8b 8d 28 fd ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00a87	c6 84 0d b0 fd
	ff ff 00	 mov	 BYTE PTR _NewOption$3[ebp+ecx], 0
  00a8f	eb bc		 jmp	 SHORT $LN2@ItemSerial
$LN3@ItemSerial:

; 3689 : 
; 3690 : 		if( lpMsg->NewOption&0x20) NewOption[0] = 1;

  00a91	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00a94	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00a98	83 e1 20	 and	 ecx, 32			; 00000020H
  00a9b	74 10		 je	 SHORT $LN37@ItemSerial
  00a9d	b8 01 00 00 00	 mov	 eax, 1
  00aa2	6b c8 00	 imul	 ecx, eax, 0
  00aa5	c6 84 0d b0 fd
	ff ff 01	 mov	 BYTE PTR _NewOption$3[ebp+ecx], 1
$LN37@ItemSerial:

; 3691 : 		if( lpMsg->NewOption&0x10) NewOption[1] = 1;

  00aad	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00ab0	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00ab4	83 e1 10	 and	 ecx, 16			; 00000010H
  00ab7	74 10		 je	 SHORT $LN38@ItemSerial
  00ab9	b8 01 00 00 00	 mov	 eax, 1
  00abe	c1 e0 00	 shl	 eax, 0
  00ac1	c6 84 05 b0 fd
	ff ff 01	 mov	 BYTE PTR _NewOption$3[ebp+eax], 1
$LN38@ItemSerial:

; 3692 : 		if( lpMsg->NewOption&0x08) NewOption[2] = 1;

  00ac9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00acc	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00ad0	83 e1 08	 and	 ecx, 8
  00ad3	74 0f		 je	 SHORT $LN39@ItemSerial
  00ad5	b8 01 00 00 00	 mov	 eax, 1
  00ada	d1 e0		 shl	 eax, 1
  00adc	c6 84 05 b0 fd
	ff ff 01	 mov	 BYTE PTR _NewOption$3[ebp+eax], 1
$LN39@ItemSerial:

; 3693 : 		if( lpMsg->NewOption&0x04) NewOption[3] = 1;

  00ae4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00ae7	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00aeb	83 e1 04	 and	 ecx, 4
  00aee	74 10		 je	 SHORT $LN40@ItemSerial
  00af0	b8 01 00 00 00	 mov	 eax, 1
  00af5	6b c8 03	 imul	 ecx, eax, 3
  00af8	c6 84 0d b0 fd
	ff ff 01	 mov	 BYTE PTR _NewOption$3[ebp+ecx], 1
$LN40@ItemSerial:

; 3694 : 		if( lpMsg->NewOption&0x02) NewOption[4] = 1;

  00b00	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00b03	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00b07	83 e1 02	 and	 ecx, 2
  00b0a	74 10		 je	 SHORT $LN41@ItemSerial
  00b0c	b8 01 00 00 00	 mov	 eax, 1
  00b11	c1 e0 02	 shl	 eax, 2
  00b14	c6 84 05 b0 fd
	ff ff 01	 mov	 BYTE PTR _NewOption$3[ebp+eax], 1
$LN41@ItemSerial:

; 3695 : 		if( lpMsg->NewOption&0x01) NewOption[5] = 1;		

  00b1c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00b1f	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00b23	83 e1 01	 and	 ecx, 1
  00b26	74 10		 je	 SHORT $LN42@ItemSerial
  00b28	b8 01 00 00 00	 mov	 eax, 1
  00b2d	6b c8 05	 imul	 ecx, eax, 5
  00b30	c6 84 0d b0 fd
	ff ff 01	 mov	 BYTE PTR _NewOption$3[ebp+ecx], 1
$LN42@ItemSerial:

; 3696 : 
; 3697 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3698 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%u [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", 
; 3699 : #else
; 3700 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", 

  00b38	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00b3b	0f b6 48 1a	 movzx	 ecx, BYTE PTR [eax+26]
  00b3f	51		 push	 ecx
  00b40	ba 01 00 00 00	 mov	 edx, 1
  00b45	6b c2 06	 imul	 eax, edx, 6
  00b48	0f b6 8c 05 b0
	fd ff ff	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00b50	51		 push	 ecx
  00b51	ba 01 00 00 00	 mov	 edx, 1
  00b56	6b c2 05	 imul	 eax, edx, 5
  00b59	0f b6 8c 05 b0
	fd ff ff	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00b61	51		 push	 ecx
  00b62	ba 01 00 00 00	 mov	 edx, 1
  00b67	c1 e2 02	 shl	 edx, 2
  00b6a	0f b6 84 15 b0
	fd ff ff	 movzx	 eax, BYTE PTR _NewOption$3[ebp+edx]
  00b72	50		 push	 eax
  00b73	b9 01 00 00 00	 mov	 ecx, 1
  00b78	6b d1 03	 imul	 edx, ecx, 3
  00b7b	0f b6 84 15 b0
	fd ff ff	 movzx	 eax, BYTE PTR _NewOption$3[ebp+edx]
  00b83	50		 push	 eax
  00b84	b9 01 00 00 00	 mov	 ecx, 1
  00b89	d1 e1		 shl	 ecx, 1
  00b8b	0f b6 94 0d b0
	fd ff ff	 movzx	 edx, BYTE PTR _NewOption$3[ebp+ecx]
  00b93	52		 push	 edx
  00b94	b8 01 00 00 00	 mov	 eax, 1
  00b99	c1 e0 00	 shl	 eax, 0
  00b9c	0f b6 8c 05 b0
	fd ff ff	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00ba4	51		 push	 ecx
  00ba5	ba 01 00 00 00	 mov	 edx, 1
  00baa	6b c2 00	 imul	 eax, edx, 0
  00bad	0f b6 8c 05 b0
	fd ff ff	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00bb5	51		 push	 ecx
  00bb6	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00bb9	0f b6 42 12	 movzx	 eax, BYTE PTR [edx+18]
  00bbd	50		 push	 eax
  00bbe	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00bc1	0f b6 51 11	 movzx	 edx, BYTE PTR [ecx+17]
  00bc5	52		 push	 edx
  00bc6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00bc9	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00bcd	51		 push	 ecx
  00bce	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00bd1	0f b6 42 0e	 movzx	 eax, BYTE PTR [edx+14]
  00bd5	50		 push	 eax
  00bd6	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00bd9	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  00bdd	6b c2 6c	 imul	 eax, edx, 108
  00be0	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00be5	50		 push	 eax
  00be6	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00be9	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00bec	52		 push	 edx
  00bed	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00bf0	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00bf4	51		 push	 ecx
  00bf5	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00bf8	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00bfc	50		 push	 eax
  00bfd	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  00c00	51		 push	 ecx
  00c01	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@LMECKDPM@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5@
  00c06	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00c0c	83 c4 48	 add	 esp, 72			; 00000048H

; 3701 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3702 : 				mapnumber, lpMsg->x, lpMsg->y,
; 3703 : 			    lpMsg->m_Number, 				
; 3704 : 				ItemAttribute[lpMsg->Type].Name, 				
; 3705 : 				lpMsg->Level, 
; 3706 : 				lpMsg->Op1, 
; 3707 : 				lpMsg->Op2, 
; 3708 : 				lpMsg->Op3,
; 3709 : 				NewOption[0],
; 3710 : 				NewOption[1],
; 3711 : 				NewOption[2],
; 3712 : 				NewOption[3],
; 3713 : 				NewOption[4],
; 3714 : 				NewOption[5],
; 3715 : 				NewOption[6],
; 3716 : 				lpMsg->SetOption
; 3717 : 			   );
; 3718 : 
; 3719 : #ifdef MONSTER_ITEMDROP_LOG_20040309
; 3720 : 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3721 : 		LogAdd_MonsterItemDrop("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%u",
; 3722 : 	#else
; 3723 : 		LogAdd_MonsterItemDrop("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d",

  00c0f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00c12	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00c15	51		 push	 ecx
  00c16	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00c19	0f b6 42 1a	 movzx	 eax, BYTE PTR [edx+26]
  00c1d	50		 push	 eax
  00c1e	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00c21	0f b6 51 13	 movzx	 edx, BYTE PTR [ecx+19]
  00c25	83 e2 3f	 and	 edx, 63			; 0000003fH
  00c28	52		 push	 edx
  00c29	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00c2c	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  00c30	51		 push	 ecx
  00c31	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00c34	0f b6 42 11	 movzx	 eax, BYTE PTR [edx+17]
  00c38	50		 push	 eax
  00c39	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00c3c	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00c40	52		 push	 edx
  00c41	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00c44	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  00c48	51		 push	 ecx
  00c49	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00c4c	0f b6 42 0e	 movzx	 eax, BYTE PTR [edx+14]
  00c50	50		 push	 eax
  00c51	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00c54	0f bf 51 0c	 movsx	 edx, WORD PTR [ecx+12]
  00c58	52		 push	 edx
  00c59	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00c5c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00c60	51		 push	 ecx
  00c61	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00c64	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00c68	50		 push	 eax
  00c69	8b 4d f4	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  00c6c	51		 push	 ecx
  00c6d	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HMMPKDMJ@?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CFd?7?$CF@
  00c72	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd_MonsterItemDrop@@3P6AXPADZZA ; LogAdd_MonsterItemDrop
  00c78	83 c4 34	 add	 esp, 52			; 00000034H
$LN31@ItemSerial:
$LN1@ItemSerial:

; 3724 : 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3725 : 				mapnumber, lpMsg->x, lpMsg->y,
; 3726 : 				lpMsg->Type, 
; 3727 : 				lpMsg->Level, 
; 3728 : 				lpMsg->Dur, 
; 3729 : 				lpMsg->Op1, 
; 3730 : 				lpMsg->Op2, 
; 3731 : 				lpMsg->Op3,
; 3732 : 				lpMsg->NewOption & 0x3F,
; 3733 : 				lpMsg->SetOption,
; 3734 : 			    lpMsg->m_Number 				
; 3735 : 			);
; 3736 : #endif
; 3737 : 		
; 3738 : 	}
; 3739 : 	#ifdef PICKUP_SYSTEM
; 3740 : 	}
; 3741 : #endif
; 3742 : }

  00c7b	5f		 pop	 edi
  00c7c	5e		 pop	 esi
  00c7d	5b		 pop	 ebx
  00c7e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c81	33 cd		 xor	 ecx, ebp
  00c83	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c88	8b e5		 mov	 esp, ebp
  00c8a	5d		 pop	 ebp
  00c8b	c3		 ret	 0
?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z ENDP ; ItemSerialCreateRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?TestDSSend@@YAXXZ
_TEXT	SEGMENT
_size$ = -2012						; size = 4
_pMsg$ = -2008						; size = 2004
__$ArrayPad$ = -4					; size = 4
?TestDSSend@@YAXXZ PROC					; TestDSSend, COMDAT

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 08 00
	00		 sub	 esp, 2268		; 000008dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 457  : 	PMSG_TEST	pMsg;
; 458  : 	int			size;
; 459  : 	
; 460  : 	size = sizeof( PMSG_TEST );

  00016	c7 85 24 f8 ff
	ff d4 07 00 00	 mov	 DWORD PTR _size$[ebp], 2004 ; 000007d4H

; 461  : 	pMsg.h.c			= 0xC2;

  00020	c6 85 28 f8 ff
	ff c2		 mov	 BYTE PTR _pMsg$[ebp], 194 ; 000000c2H

; 462  : 	pMsg.h.headcode		= 0xFF;

  00027	c6 85 2b f8 ff
	ff ff		 mov	 BYTE PTR _pMsg$[ebp+3], 255 ; 000000ffH

; 463  : 	pMsg.h.sizeH			= HIBYTE(size);

  0002e	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00034	c1 e8 08	 shr	 eax, 8
  00037	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003c	88 85 29 f8 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], al

; 464  : 	pMsg.h.sizeL			= LOBYTE(size);

  00042	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00048	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004d	88 85 2a f8 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+2], al

; 465  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);	

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00058	50		 push	 eax
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0005e	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00064	51		 push	 ecx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00080	83 c4 08	 add	 esp, 8

; 466  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  00083	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00089	50		 push	 eax
  0008a	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00090	51		 push	 ecx
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00096	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  000a0	83 c0 01	 add	 eax, 1
  000a3	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 467  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  000ad	50		 push	 eax
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000b3	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  000b9	51		 push	 ecx
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c3	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  000c9	50		 push	 eax
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d5	83 c4 08	 add	 esp, 8

; 468  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  000d8	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  000de	50		 push	 eax
  000df	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000e5	51		 push	 ecx
  000e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000eb	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  000f5	83 c0 01	 add	 eax, 1
  000f8	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 469  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00102	50		 push	 eax
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00108	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0010e	51		 push	 ecx
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
  00118	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0011e	50		 push	 eax
  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0012a	83 c4 08	 add	 esp, 8

; 470  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  0012d	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00133	50		 push	 eax
  00134	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0013a	51		 push	 ecx
  0013b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00140	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0014a	83 c0 01	 add	 eax, 1
  0014d	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 471  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  00152	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00157	50		 push	 eax
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0015d	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00163	51		 push	 ecx
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016d	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00173	50		 push	 eax
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0017f	83 c4 08	 add	 esp, 8

; 472  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  00182	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00188	50		 push	 eax
  00189	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0018f	51		 push	 ecx
  00190	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00195	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  0019a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0019f	83 c0 01	 add	 eax, 1
  001a2	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 473  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  001a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  001ac	50		 push	 eax
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  001b2	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  001b8	51		 push	 ecx
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c2	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  001c8	50		 push	 eax
  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001d4	83 c4 08	 add	 esp, 8

; 474  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  001d7	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  001dd	50		 push	 eax
  001de	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001e4	51		 push	 ecx
  001e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  001ea	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  001ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  001f4	83 c0 01	 add	 eax, 1
  001f7	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 475  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  001fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00201	50		 push	 eax
  00202	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00207	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0020d	51		 push	 ecx
  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00214	83 c4 0c	 add	 esp, 12			; 0000000cH
  00217	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0021d	50		 push	 eax
  0021e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00229	83 c4 08	 add	 esp, 8

; 476  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  0022c	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00232	50		 push	 eax
  00233	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00239	51		 push	 ecx
  0023a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0023f	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00244	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00249	83 c0 01	 add	 eax, 1
  0024c	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 477  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  00251	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00256	50		 push	 eax
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0025c	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00262	51		 push	 ecx
  00263	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00269	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026c	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00272	50		 push	 eax
  00273	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00278	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0027e	83 c4 08	 add	 esp, 8

; 478  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  00281	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00287	50		 push	 eax
  00288	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0028e	51		 push	 ecx
  0028f	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00294	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00299	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0029e	83 c0 01	 add	 eax, 1
  002a1	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 479  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  002a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  002ab	50		 push	 eax
  002ac	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  002b1	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  002b7	51		 push	 ecx
  002b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  002be	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c1	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  002c7	50		 push	 eax
  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002d3	83 c4 08	 add	 esp, 8

; 480  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  002d6	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  002dc	50		 push	 eax
  002dd	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  002e3	51		 push	 ecx
  002e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002e9	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  002ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  002f3	83 c0 01	 add	 eax, 1
  002f6	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 481  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  002fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00300	50		 push	 eax
  00301	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00306	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0030c	51		 push	 ecx
  0030d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00313	83 c4 0c	 add	 esp, 12			; 0000000cH
  00316	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0031c	50		 push	 eax
  0031d	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00322	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00328	83 c4 08	 add	 esp, 8

; 482  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  0032b	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00331	50		 push	 eax
  00332	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00338	51		 push	 ecx
  00339	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0033e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00343	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00348	83 c0 01	 add	 eax, 1
  0034b	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 483  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  00350	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00355	50		 push	 eax
  00356	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0035b	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00361	51		 push	 ecx
  00362	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00368	83 c4 0c	 add	 esp, 12			; 0000000cH
  0036b	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00371	50		 push	 eax
  00372	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00377	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0037d	83 c4 08	 add	 esp, 8

; 484  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  00380	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00386	50		 push	 eax
  00387	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0038d	51		 push	 ecx
  0038e	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00393	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00398	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0039d	83 c0 01	 add	 eax, 1
  003a0	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 485  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  003a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  003aa	50		 push	 eax
  003ab	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  003b0	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  003b6	51		 push	 ecx
  003b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  003bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c0	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  003c6	50		 push	 eax
  003c7	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  003cc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003d2	83 c4 08	 add	 esp, 8

; 486  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  003d5	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  003db	50		 push	 eax
  003dc	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  003e2	51		 push	 ecx
  003e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  003e8	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  003ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  003f2	83 c0 01	 add	 eax, 1
  003f5	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 487  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  003fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  003ff	50		 push	 eax
  00400	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00405	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0040b	51		 push	 ecx
  0040c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00412	83 c4 0c	 add	 esp, 12			; 0000000cH
  00415	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0041b	50		 push	 eax
  0041c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00421	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00427	83 c4 08	 add	 esp, 8

; 488  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  0042a	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00430	50		 push	 eax
  00431	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00437	51		 push	 ecx
  00438	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0043d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00442	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00447	83 c0 01	 add	 eax, 1
  0044a	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 489  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  0044f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00454	50		 push	 eax
  00455	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0045a	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00460	51		 push	 ecx
  00461	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00467	83 c4 0c	 add	 esp, 12			; 0000000cH
  0046a	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00470	50		 push	 eax
  00471	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00476	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0047c	83 c4 08	 add	 esp, 8

; 490  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  0047f	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00485	50		 push	 eax
  00486	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0048c	51		 push	 ecx
  0048d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00492	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00497	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0049c	83 c0 01	 add	 eax, 1
  0049f	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 491  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  004a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  004a9	50		 push	 eax
  004aa	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  004af	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  004b5	51		 push	 ecx
  004b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  004bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  004bf	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  004c5	50		 push	 eax
  004c6	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  004cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004d1	83 c4 08	 add	 esp, 8

; 492  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  004d4	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  004da	50		 push	 eax
  004db	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  004e1	51		 push	 ecx
  004e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  004e7	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  004ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  004f1	83 c0 01	 add	 eax, 1
  004f4	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 493  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  004f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  004fe	50		 push	 eax
  004ff	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00504	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0050a	51		 push	 ecx
  0050b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00511	83 c4 0c	 add	 esp, 12			; 0000000cH
  00514	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0051a	50		 push	 eax
  0051b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00520	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00526	83 c4 08	 add	 esp, 8

; 494  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  00529	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  0052f	50		 push	 eax
  00530	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00536	51		 push	 ecx
  00537	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0053c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00541	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00546	83 c0 01	 add	 eax, 1
  00549	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 495  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  0054e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00553	50		 push	 eax
  00554	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00559	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0055f	51		 push	 ecx
  00560	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00566	83 c4 0c	 add	 esp, 12			; 0000000cH
  00569	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0056f	50		 push	 eax
  00570	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00575	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0057b	83 c4 08	 add	 esp, 8

; 496  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  0057e	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00584	50		 push	 eax
  00585	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0058b	51		 push	 ecx
  0058c	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00591	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00596	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0059b	83 c0 01	 add	 eax, 1
  0059e	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 497  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  005a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  005a8	50		 push	 eax
  005a9	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  005ae	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  005b4	51		 push	 ecx
  005b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  005bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  005be	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  005c4	50		 push	 eax
  005c5	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  005ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  005d0	83 c4 08	 add	 esp, 8

; 498  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  005d3	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  005d9	50		 push	 eax
  005da	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  005e0	51		 push	 ecx
  005e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  005e6	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  005eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  005f0	83 c0 01	 add	 eax, 1
  005f3	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 499  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  005f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  005fd	50		 push	 eax
  005fe	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00603	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00609	51		 push	 ecx
  0060a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00610	83 c4 0c	 add	 esp, 12			; 0000000cH
  00613	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00619	50		 push	 eax
  0061a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0061f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00625	83 c4 08	 add	 esp, 8

; 500  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  00628	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  0062e	50		 push	 eax
  0062f	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00635	51		 push	 ecx
  00636	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0063b	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00640	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00645	83 c0 01	 add	 eax, 1
  00648	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 501  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  0064d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00652	50		 push	 eax
  00653	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00658	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0065e	51		 push	 ecx
  0065f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00665	83 c4 0c	 add	 esp, 12			; 0000000cH
  00668	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0066e	50		 push	 eax
  0066f	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00674	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0067a	83 c4 08	 add	 esp, 8

; 502  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  0067d	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00683	50		 push	 eax
  00684	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0068a	51		 push	 ecx
  0068b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00690	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00695	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0069a	83 c0 01	 add	 eax, 1
  0069d	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 503  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  006a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  006a7	50		 push	 eax
  006a8	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  006ad	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  006b3	51		 push	 ecx
  006b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  006ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  006bd	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  006c3	50		 push	 eax
  006c4	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  006c9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  006cf	83 c4 08	 add	 esp, 8

; 504  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  006d2	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  006d8	50		 push	 eax
  006d9	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  006df	51		 push	 ecx
  006e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  006e5	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  006ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  006ef	83 c0 01	 add	 eax, 1
  006f2	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 505  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  006f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  006fc	50		 push	 eax
  006fd	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00702	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00708	51		 push	 ecx
  00709	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0070f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00712	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00718	50		 push	 eax
  00719	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0071e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00724	83 c4 08	 add	 esp, 8

; 506  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  00727	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  0072d	50		 push	 eax
  0072e	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00734	51		 push	 ecx
  00735	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0073a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  0073f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00744	83 c0 01	 add	 eax, 1
  00747	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 507  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  0074c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00751	50		 push	 eax
  00752	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  00757	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0075d	51		 push	 ecx
  0075e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00764	83 c4 0c	 add	 esp, 12			; 0000000cH
  00767	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0076d	50		 push	 eax
  0076e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00773	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00779	83 c4 08	 add	 esp, 8

; 508  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  0077c	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00782	50		 push	 eax
  00783	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00789	51		 push	 ecx
  0078a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0078f	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00794	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00799	83 c0 01	 add	 eax, 1
  0079c	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 509  : 	wsprintf(pMsg.testbuf,"%d", iCount);LogAdd("%s",pMsg.testbuf);

  007a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  007a6	50		 push	 eax
  007a7	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  007ac	8d 8d 2c f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  007b2	51		 push	 ecx
  007b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  007b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  007bc	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  007c2	50		 push	 eax
  007c3	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  007c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  007ce	83 c4 08	 add	 esp, 8

; 510  : 	cDBSMng.Send((char*)&pMsg, size); iCount++;

  007d1	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  007d7	50		 push	 eax
  007d8	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  007de	51		 push	 ecx
  007df	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  007e4	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  007e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  007ee	83 c0 01	 add	 eax, 1
  007f1	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount

; 511  : 	/*
; 512  : 	cDBSMng.Send((char*)&pMsg, size);
; 513  : 	cDBSMng.Send((char*)&pMsg, size);
; 514  : 	cDBSMng.Send((char*)&pMsg, size);
; 515  : 	cDBSMng.Send((char*)&pMsg, size);
; 516  : 	cDBSMng.Send((char*)&pMsg, size);
; 517  : 	cDBSMng.Send((char*)&pMsg, size);
; 518  : 	*/
; 519  : 	//cDBSMng.Send((char*)&pMsg, size);
; 520  : 	//cDBSMng.Send((char*)&pMsg, size);
; 521  : 	//cDBSMng.Send((char*)&pMsg, size);
; 522  : 
; 523  : 	LogAdd("Test Data Send");

  007f6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GMPEKMII@Test?5Data?5Send@
  007fb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00801	83 c4 04	 add	 esp, 4

; 524  : }

  00804	5f		 pop	 edi
  00805	5e		 pop	 esi
  00806	5b		 pop	 ebx
  00807	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0080a	33 cd		 xor	 ecx, ebp
  0080c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00811	8b e5		 mov	 esp, ebp
  00813	5d		 pop	 ebp
  00814	c3		 ret	 0
?TestDSSend@@YAXXZ ENDP					; TestDSSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z PROC	; DataServerLoginResult, COMDAT

; 553  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 554  : 	if( lpMsg->Result == FALSE )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00010	85 c9		 test	 ecx, ecx
  00012	75 1b		 jne	 SHORT $LN2@DataServer

; 555  : 	{
; 556  : 		MsgBox(lMsg.Get(466));

  00014	68 d2 01 00 00	 push	 466			; 000001d2H
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0002a	83 c4 04	 add	 esp, 4

; 557  : 	}

  0002d	eb 2c		 jmp	 SHORT $LN1@DataServer
$LN2@DataServer:

; 558  : 	else
; 559  : 	{
; 560  : 		//gItemNumberCount = lpMsg->ItemCount;
; 561  : 		//LogAdd("아이템 번호 설정 : %d", gItemNumberCount);
; 562  : 		DataServerConnected = 1;

  0002f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DataServerConnected@@3HA, 1 ; DataServerConnected

; 563  : 		gServerReady++;

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gServerReady@@3HA ; gServerReady
  0003e	83 c0 01	 add	 eax, 1
  00041	a3 00 00 00 00	 mov	 DWORD PTR ?gServerReady@@3HA, eax ; gServerReady

; 564  : 		SendMessage(ghWnd, WM_ASS_CREATEGAMESERVER, 0, 0);

  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	68 05 04 00 00	 push	 1029			; 00000405H
  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN1@DataServer:

; 565  : 	}
; 566  : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z ENDP	; DataServerLoginResult
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z
_TEXT	SEGMENT
$T1 = -444						; size = 4
$T2 = -440						; size = 4
_pNotice$ = -372					; size = 272
_MaxAddPoint$ = -100					; size = 2
_AddPoint$ = -96					; size = 2
_lpObj$ = -92						; size = 4
_i$3 = -88						; size = 4
_aIndex$ = -84						; size = 4
_szName$ = -80						; size = 11
_szAccountId$ = -68					; size = 11
_pjMsg$ = -56						; size = 52
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z PROC ; JGGetCharacterInfo, COMDAT

; 1731 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 01 00
	00		 sub	 esp, 444		; 000001bcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1732 : 	PMSG_CHARMAPJOINRESULT	pjMsg;
; 1733 : 		
; 1734 : 	char szAccountId[MAX_IDSTRING+1];
; 1735 : 	char szName[MAX_IDSTRING+1];
; 1736 : 
; 1737 : 	int	 aIndex = lpMsg->Number;	

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00019	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0001d	89 4d ac	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 1738 : 	
; 1739 : 	szAccountId[MAX_IDSTRING] = '\0';

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	6b c8 0a	 imul	 ecx, eax, 10
  00028	89 8d 48 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  0002e	83 bd 48 fe ff
	ff 0b		 cmp	 DWORD PTR $T2[ebp], 11	; 0000000bH
  00035	73 02		 jae	 SHORT $LN17@JGGetChara
  00037	eb 05		 jmp	 SHORT $LN18@JGGetChara
$LN17@JGGetChara:
  00039	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN18@JGGetChara:
  0003e	8b 95 48 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  00044	c6 44 15 bc 00	 mov	 BYTE PTR _szAccountId$[ebp+edx], 0

; 1740 : 	memcpy(szAccountId, lpMsg->AccountID, MAX_IDSTRING);

  00049	6a 0a		 push	 10			; 0000000aH
  0004b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004e	83 c0 08	 add	 eax, 8
  00051	50		 push	 eax
  00052	8d 4d bc	 lea	 ecx, DWORD PTR _szAccountId$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _memcpy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1741 : 	if( gObjIsAccontConnect(aIndex, szAccountId) == FALSE )

  0005e	8d 45 bc	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00061	50		 push	 eax
  00062	8b 4d ac	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0006b	83 c4 08	 add	 esp, 8
  0006e	85 c0		 test	 eax, eax
  00070	75 31		 jne	 SHORT $LN5@JGGetChara

; 1742 : 	{
; 1743 : 		LogAddC(LOGC_RED, lMsg.Get(426), szAccountId);

  00072	8d 45 bc	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00075	50		 push	 eax
  00076	68 aa 01 00 00	 push	 426			; 000001aaH
  0007b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00086	50		 push	 eax
  00087	6a 02		 push	 2
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1744 : 		CloseClient ( aIndex );

  00092	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0009b	83 c4 04	 add	 esp, 4

; 1745 : 		return;

  0009e	e9 29 05 00 00	 jmp	 $LN1@JGGetChara
$LN5@JGGetChara:

; 1746 : 	}
; 1747 : 	szName[MAX_IDSTRING] = '\0';

  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	6b c8 0a	 imul	 ecx, eax, 10
  000ab	89 8d 44 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  000b1	83 bd 44 fe ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  000b8	73 02		 jae	 SHORT $LN19@JGGetChara
  000ba	eb 05		 jmp	 SHORT $LN20@JGGetChara
$LN19@JGGetChara:
  000bc	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN20@JGGetChara:
  000c1	8b 95 44 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  000c7	c6 44 15 b0 00	 mov	 BYTE PTR _szName$[ebp+edx], 0

; 1748 : 	memcpy(szName, lpMsg->Name, MAX_IDSTRING);

  000cc	6a 0a		 push	 10			; 0000000aH
  000ce	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000d1	83 c0 12	 add	 eax, 18			; 00000012H
  000d4	50		 push	 eax
  000d5	8d 4d b0	 lea	 ecx, DWORD PTR _szName$[ebp]
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 _memcpy
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1749 : 	if( lpMsg->result == 0x00 )

  000e1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000e4	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000e8	85 c9		 test	 ecx, ecx
  000ea	75 43		 jne	 SHORT $LN6@JGGetChara

; 1750 : 	{
; 1751 : 		LogAddC(LOGC_RED, lMsg.Get(427), szName, gObj[aIndex].AccountID);

  000ec	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f9	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000fd	52		 push	 edx
  000fe	8d 45 b0	 lea	 eax, DWORD PTR _szName$[ebp]
  00101	50		 push	 eax
  00102	68 ab 01 00 00	 push	 427			; 000001abH
  00107	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00112	50		 push	 eax
  00113	6a 02		 push	 2
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0011b	83 c4 10	 add	 esp, 16			; 00000010H

; 1752 : 		CloseClient ( aIndex );

  0011e	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00127	83 c4 04	 add	 esp, 4

; 1753 : 		return;

  0012a	e9 9d 04 00 00	 jmp	 $LN1@JGGetChara
$LN6@JGGetChara:

; 1754 : 	}
; 1755 : 
; 1756 : 	if( lpMsg->CtlCode & 0x01 )

  0012f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00132	0f b6 88 3c 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1340]
  00139	83 e1 01	 and	 ecx, 1
  0013c	74 37		 je	 SHORT $LN7@JGGetChara

; 1757 : 	{	// 캐릭터 블럭일때는 강제로 접속을 종료 시킨다
; 1758 : 		LogAddC(LOGC_RED, "error-L1 : Load Block Character infomation", szName, gObj[aIndex].AccountID);

  0013e	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00145	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014b	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0014f	52		 push	 edx
  00150	8d 45 b0	 lea	 eax, DWORD PTR _szName$[ebp]
  00153	50		 push	 eax
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character@
  00159	6a 02		 push	 2
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00161	83 c4 10	 add	 esp, 16			; 00000010H

; 1759 : 		CloseClient ( aIndex );

  00164	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0016d	83 c4 04	 add	 esp, 4

; 1760 : 		return;

  00170	e9 57 04 00 00	 jmp	 $LN1@JGGetChara
$LN7@JGGetChara:

; 1761 : 	}
; 1762 : 
; 1763 : // 본서버만 적용 된다
; 1764 : #if TESTSERVER == 0
; 1765 : #ifdef MODIFY_CHARACTER_DELETE_IN_MAP_20051121
; 1766 : 	// 동일한 이름의 캐릭터가 이미 존재하면 접속 할수 없다.
; 1767 : 	for( int i=ALLOC_USEROBJECTSTART ; i<MAX_OBJECT; i++)

  00175	c7 45 a8 00 19
	00 00		 mov	 DWORD PTR _i$3[ebp], 6400 ; 00001900H
  0017c	eb 09		 jmp	 SHORT $LN4@JGGetChara
$LN2@JGGetChara:
  0017e	8b 45 a8	 mov	 eax, DWORD PTR _i$3[ebp]
  00181	83 c0 01	 add	 eax, 1
  00184	89 45 a8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@JGGetChara:
  00187	81 7d a8 e8 1c
	00 00		 cmp	 DWORD PTR _i$3[ebp], 7400 ; 00001ce8H
  0018e	0f 8d b1 00 00
	00		 jge	 $LN3@JGGetChara

; 1768 : 	{
; 1769 : 		if( (gObj[i].Connected == CSS_GAMEPLAYING) && (gObj[i].Type == OBJTYPE_CHARACTER))

  00194	69 45 a8 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$3[ebp], 7072
  0019b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a1	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  001a6	0f 85 94 00 00
	00		 jne	 $LN9@JGGetChara
  001ac	69 45 a8 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$3[ebp], 7072
  001b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b9	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  001be	83 fa 01	 cmp	 edx, 1
  001c1	75 7d		 jne	 SHORT $LN9@JGGetChara

; 1770 : 		{
; 1771 : 			if( strncmp(szName, gObj[i].Name, MAX_IDSTRING) == 0 || strncmp(szAccountId, gObj[i].AccountID, MAX_IDSTRING) == 0 )

  001c3	6a 0a		 push	 10			; 0000000aH
  001c5	69 45 a8 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$3[ebp], 7072
  001cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d2	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001d6	52		 push	 edx
  001d7	8d 45 b0	 lea	 eax, DWORD PTR _szName$[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _strncmp
  001e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e3	85 c0		 test	 eax, eax
  001e5	74 24		 je	 SHORT $LN10@JGGetChara
  001e7	6a 0a		 push	 10			; 0000000aH
  001e9	69 45 a8 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$3[ebp], 7072
  001f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f6	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001fa	52		 push	 edx
  001fb	8d 45 bc	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 _strncmp
  00204	83 c4 0c	 add	 esp, 12			; 0000000cH
  00207	85 c0		 test	 eax, eax
  00209	75 35		 jne	 SHORT $LN9@JGGetChara
$LN10@JGGetChara:

; 1772 : 			{
; 1773 : 				LogAddTD("[Anti-HACK][JGGetCharacterInfo] Attempted Character-Copy by double logging [%s][%s]", 

  0020b	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00212	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00218	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0021c	52		 push	 edx
  0021d	8d 45 b0	 lea	 eax, DWORD PTR _szName$[ebp]
  00220	50		 push	 eax
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN@
  00226	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1774 : 					szName, gObj[aIndex].AccountID);
; 1775 : 				
; 1776 : 				CloseClient ( aIndex );

  0022f	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00238	83 c4 04	 add	 esp, 4

; 1777 : 				return;

  0023b	e9 8c 03 00 00	 jmp	 $LN1@JGGetChara
$LN9@JGGetChara:

; 1778 : 			}
; 1779 : 		}
; 1780 : 	}

  00240	e9 39 ff ff ff	 jmp	 $LN2@JGGetChara
$LN3@JGGetChara:

; 1781 : 
; 1782 : #endif // MODIFY_CHARACTER_DELETE_IN_MAP_20051121
; 1783 : #endif // TESTSERVER
; 1784 : 	
; 1785 : 	// 세팅한다.
; 1786 : 	if( gObjSetCharacter((LPBYTE)lpMsg, aIndex) == FALSE) 

  00245	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00248	50		 push	 eax
  00249	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0024c	51		 push	 ecx
  0024d	e8 00 00 00 00	 call	 ?gObjSetCharacter@@YAHPAEH@Z ; gObjSetCharacter
  00252	83 c4 08	 add	 esp, 8
  00255	85 c0		 test	 eax, eax
  00257	75 31		 jne	 SHORT $LN11@JGGetChara

; 1787 : 	{
; 1788 : 		LogAddC(LOGC_RED, lMsg.Get(428), szName);

  00259	8d 45 b0	 lea	 eax, DWORD PTR _szName$[ebp]
  0025c	50		 push	 eax
  0025d	68 ac 01 00 00	 push	 428			; 000001acH
  00262	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00267	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0026d	50		 push	 eax
  0026e	6a 02		 push	 2
  00270	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00276	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1789 : 		CloseClient ( aIndex );

  00279	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00282	83 c4 04	 add	 esp, 4

; 1790 : 		return;

  00285	e9 42 03 00 00	 jmp	 $LN1@JGGetChara
$LN11@JGGetChara:

; 1791 : 	}
; 1792 : 	
; 1793 : #ifdef ADD_SHIELD_POINT_01_20060403
; 1794 : 	gObj[aIndex].iShield = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield);
; 1795 : #endif
; 1796 : 
; 1797 : 	
; 1798 : #ifdef AUTH_GAMESERVER_CHECKKEY
; 1799 : 	if( szAuthKey[0] != AUTH_CHECK_00 )
; 1800 : 		DestroyGIocp();
; 1801 : #endif
; 1802 : 
; 1803 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  0028a	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00291	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00297	89 45 a4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 1804 : 	if( gObj[aIndex].m_Index != aIndex )

  0029a	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a7	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  002aa	3b 55 ac	 cmp	 edx, DWORD PTR _aIndex$[ebp]
  002ad	74 3b		 je	 SHORT $LN12@JGGetChara

; 1805 : 	{
; 1806 : 		LogAddC(LOGC_RED, lMsg.Get(429), __FILE__, __LINE__);

  002af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z@4JA
  002b4	83 c0 4b	 add	 eax, 75			; 0000004bH
  002b7	50		 push	 eax
  002b8	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MBPEHAPP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  002bd	68 ad 01 00 00	 push	 429			; 000001adH
  002c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002cd	50		 push	 eax
  002ce	6a 02		 push	 2
  002d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002d6	83 c4 10	 add	 esp, 16			; 00000010H

; 1807 : 		CloseClient ( aIndex );

  002d9	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002dc	50		 push	 eax
  002dd	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002e2	83 c4 04	 add	 esp, 4

; 1808 : 		return;

  002e5	e9 e2 02 00 00	 jmp	 $LN1@JGGetChara
$LN12@JGGetChara:

; 1809 : 	}
; 1810 : 
; 1811 : #ifdef MODIFY_ZEN_MAX_20040414
; 1812 : 	// Zen이 0보다 작으면 0으로 세팅해준다.
; 1813 : 	if( lpObj->Money < 0 )

  002ea	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ed	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  002f4	7d 3c		 jge	 SHORT $LN13@JGGetChara

; 1814 : 	{
; 1815 : 		LogAddC(LOGC_RED, "★☆ ZEN MODIFY ☆★ [%s][%s] %d -> 0", 

  002f6	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f9	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  002ff	51		 push	 ecx
  00300	69 55 ac a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00307	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0030c	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00310	51		 push	 ecx
  00311	8d 55 b0	 lea	 edx, DWORD PTR _szName$[ebp]
  00314	52		 push	 edx
  00315	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BPCBIHIK@?$KB?Z?$KB?Y?5ZEN?5MODIFY?5?$KB?Y?$KB?Z?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CF@
  0031a	6a 02		 push	 2
  0031c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00322	83 c4 14	 add	 esp, 20			; 00000014H

; 1816 : 			szName, gObj[aIndex].AccountID, lpObj->Money);
; 1817 : 		lpObj->Money = 0;

  00325	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00328	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0
$LN13@JGGetChara:

; 1818 : 	}
; 1819 : #endif
; 1820 : 
; 1821 : #ifdef MAP_SERVER_WORK_20041030		// 맵서버로 이동여부 체크 -> 최초 로그인 하여 케릭터 정보를 받을 때 이 맵이 아니라면 다른 맵서버로 이동시켜 준다.
; 1822 : 	if (lpObj->m_bMapSvrMoveReq == false) {
; 1823 : 		// 최초 로그인인 경우에만 여기서 처리한다. -> 다른 맵서버에서 온 경우는 gObjSetCharacter() 에서 처리
; 1824 : 		if( !MapNumberCheck(lpObj->MapNumber) ) 
; 1825 : 		{
; 1826 : 			LogAdd("error-L3 : %s %d", __FILE__, __LINE__);
; 1827 : 			CloseClient ( aIndex );
; 1828 : 			return;
; 1829 : 		}
; 1830 : 
; 1831 : 		SHORT sSvrCode	= g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, lpObj->MapNumber, lpObj->m_sPrevMapSvrCode);
; 1832 : 		if (sSvrCode != gGameServerCode) {
; 1833 : 			if (sSvrCode == -1) {
; 1834 : 				// 치명적인 에러 -> 거의 없슴
; 1835 : 				LogAddC(LOGC_RED, "[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)",
; 1836 : 					lpObj->AccountID,
; 1837 : 					lpObj->Name,
; 1838 : 					lpObj->m_Index
; 1839 : 					);
; 1840 : 				CloseClient ( aIndex );
; 1841 : 				return;
; 1842 : 			}
; 1843 : 
; 1844 : 			// 인증서버에 맵서버 이동 요청을 한다.
; 1845 : 			GJReqMapSvrMove (lpObj->m_Index, sSvrCode, lpObj->MapNumber, lpObj->X, lpObj->Y);
; 1846 : 			LogAddTD("[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)",
; 1847 : 				sSvrCode,
; 1848 : 				lpObj->AccountID,
; 1849 : 				lpObj->Name,
; 1850 : 				lpObj->m_Index
; 1851 : 				);
; 1852 : 			return;
; 1853 : 		}
; 1854 : 	}
; 1855 : 	
; 1856 : 	lpObj->m_bMapSvrMoveReq	= false;
; 1857 : #endif
; 1858 : 
; 1859 : 	pjMsg.h.c			= PMHCE_BYTE;

  00332	c6 45 c8 c3	 mov	 BYTE PTR _pjMsg$[ebp], 195 ; 000000c3H

; 1860 : 	pjMsg.h.headcode	= 0xF3;

  00336	c6 45 ca f3	 mov	 BYTE PTR _pjMsg$[ebp+2], 243 ; 000000f3H

; 1861 : 	pjMsg.h.size		= sizeof(pjMsg);

  0033a	c6 45 c9 34	 mov	 BYTE PTR _pjMsg$[ebp+1], 52 ; 00000034H

; 1862 : 	pjMsg.subcode		= 0x03;

  0033e	c6 45 cb 03	 mov	 BYTE PTR _pjMsg$[ebp+3], 3

; 1863 : 	pjMsg.MapX			= (BYTE)lpObj->X;

  00342	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00345	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  0034b	88 4d cc	 mov	 BYTE PTR _pjMsg$[ebp+4], cl

; 1864 : 	pjMsg.MapY			= (BYTE)lpObj->Y;

  0034e	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00351	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00357	88 4d cd	 mov	 BYTE PTR _pjMsg$[ebp+5], cl

; 1865 : 	pjMsg.MapNumber		= lpObj->MapNumber;

  0035a	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035d	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  00363	88 4d ce	 mov	 BYTE PTR _pjMsg$[ebp+6], cl

; 1866 : 	pjMsg.Dir			= lpObj->Dir;

  00366	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00369	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  0036f	88 4d cf	 mov	 BYTE PTR _pjMsg$[ebp+7], cl

; 1867 : #ifdef	MASTER_LEVEL_UP_SYSTEM_20070912	// 경험치 전송 -> EXP 타입 변경	
; 1868 : 	// *마스터레벨 정보를 받기 전이라 의미는 없음. 나중을 위해서 일단 작업.
; 1869 : 	INT64 i64Exp = lpObj->Experience;
; 1870 : 	if( g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 1871 : 	{
; 1872 : 		i64Exp = lpObj->m_i64MasterLevelExp;
; 1873 : 	}
; 1874 : 
; 1875 : 	// 마스터레벨 유저를 위해 타입 변경						
; 1876 : 	pjMsg.btExp1			= HIBYTE(HIWORD(HILONG( i64Exp )));
; 1877 : 	pjMsg.btExp2			= LOBYTE(HIWORD(HILONG( i64Exp )));
; 1878 : 	pjMsg.btExp3			= HIBYTE(LOWORD(HILONG( i64Exp )));
; 1879 : 	pjMsg.btExp4			= LOBYTE(LOWORD(HILONG( i64Exp )));
; 1880 : 	pjMsg.btExp5			= HIBYTE(HIWORD(LOLONG( i64Exp )));
; 1881 : 	pjMsg.btExp6			= LOBYTE(HIWORD(LOLONG( i64Exp )));
; 1882 : 	pjMsg.btExp7			= HIBYTE(LOWORD(LOLONG( i64Exp )));
; 1883 : 	pjMsg.btExp8			= LOBYTE(LOWORD(LOLONG( i64Exp )));	
; 1884 : 
; 1885 : 	INT64 i64NextExp = lpObj->NextExp;
; 1886 : 	if( g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 1887 : 	{
; 1888 : 		i64NextExp = lpObj->m_i64NextMasterLevelExp;
; 1889 : 	}	
; 1890 : 	pjMsg.btNextExp1		= HIBYTE(HIWORD(HILONG( i64NextExp )));
; 1891 : 	pjMsg.btNextExp2		= LOBYTE(HIWORD(HILONG( i64NextExp )));
; 1892 : 	pjMsg.btNextExp3		= HIBYTE(LOWORD(HILONG( i64NextExp )));
; 1893 : 	pjMsg.btNextExp4		= LOBYTE(LOWORD(HILONG( i64NextExp )));
; 1894 : 	pjMsg.btNextExp5		= HIBYTE(HIWORD(LOLONG( i64NextExp )));
; 1895 : 	pjMsg.btNextExp6		= LOBYTE(HIWORD(LOLONG( i64NextExp )));
; 1896 : 	pjMsg.btNextExp7		= HIBYTE(LOWORD(LOLONG( i64NextExp )));
; 1897 : 	pjMsg.btNextExp8		= LOBYTE(LOWORD(LOLONG( i64NextExp )));	
; 1898 : #else
; 1899 : 	pjMsg.Exp			= lpObj->Experience;

  00372	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00375	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  0037b	89 4d d0	 mov	 DWORD PTR _pjMsg$[ebp+8], ecx

; 1900 : 	pjMsg.NextExp		= lpObj->NextExp;

  0037e	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00381	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00387	89 4d d4	 mov	 DWORD PTR _pjMsg$[ebp+12], ecx

; 1901 : #endif	
; 1902 : 	pjMsg.LevelUpPoint	= lpObj->LevelUpPoint;

  0038a	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0038d	66 8b 88 a4 00
	00 00		 mov	 cx, WORD PTR [eax+164]
  00394	66 89 4d d8	 mov	 WORD PTR _pjMsg$[ebp+16], cx

; 1903 : 	pjMsg.Str			= lpObj->Strength;

  00398	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039b	66 8b 88 b4 00
	00 00		 mov	 cx, WORD PTR [eax+180]
  003a2	66 89 4d da	 mov	 WORD PTR _pjMsg$[ebp+18], cx

; 1904 : 	pjMsg.Dex			= lpObj->Dexterity;

  003a6	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a9	66 8b 88 b6 00
	00 00		 mov	 cx, WORD PTR [eax+182]
  003b0	66 89 4d dc	 mov	 WORD PTR _pjMsg$[ebp+20], cx

; 1905 : 	pjMsg.Vit			= lpObj->Vitality;	

  003b4	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b7	66 8b 88 b8 00
	00 00		 mov	 cx, WORD PTR [eax+184]
  003be	66 89 4d de	 mov	 WORD PTR _pjMsg$[ebp+22], cx

; 1906 : 	pjMsg.Energy		= lpObj->Energy;

  003c2	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c5	66 8b 88 ba 00
	00 00		 mov	 cx, WORD PTR [eax+186]
  003cc	66 89 4d e0	 mov	 WORD PTR _pjMsg$[ebp+24], cx

; 1907 : 	pjMsg.Money			= lpObj->Money;

  003d0	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d3	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  003d9	89 4d f0	 mov	 DWORD PTR _pjMsg$[ebp+40], ecx

; 1908 : 	pjMsg.PkLevel		= lpObj->m_PK_Level;

  003dc	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003df	8a 88 fd 00 00
	00		 mov	 cl, BYTE PTR [eax+253]
  003e5	88 4d f4	 mov	 BYTE PTR _pjMsg$[ebp+44], cl

; 1909 : 	pjMsg.Life			= (WORD)(lpObj->Life);

  003e8	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003eb	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  003f3	66 89 4d e2	 mov	 WORD PTR _pjMsg$[ebp+26], cx

; 1910 : 	pjMsg.MaxLife		= (WORD)((lpObj->MaxLife+lpObj->AddLife));

  003f7	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003fa	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  00402	8b 4d a4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00405	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  0040d	f3 0f 2c d0	 cvttss2si edx, xmm0
  00411	66 89 55 e4	 mov	 WORD PTR _pjMsg$[ebp+28], dx

; 1911 : 	pjMsg.Mana			= (WORD)(lpObj->Mana);

  00415	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00418	f3 0f 2c 88 d0
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+208]
  00420	66 89 4d e6	 mov	 WORD PTR _pjMsg$[ebp+30], cx

; 1912 : 	pjMsg.MaxMana		= (WORD)((lpObj->MaxMana+lpObj->AddMana));

  00424	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00427	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  0042f	8b 4d a4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00432	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  0043a	f3 0f 2c d0	 cvttss2si edx, xmm0
  0043e	66 89 55 e8	 mov	 WORD PTR _pjMsg$[ebp+32], dx

; 1913 : #ifdef ADD_SHIELD_POINT_01_20060403
; 1914 : 	pjMsg.wShield		= (WORD)(lpObj->iShield);
; 1915 : 	pjMsg.wMaxShield	= (WORD)(lpObj->iMaxShield + lpObj->iAddShield);
; 1916 : #endif
; 1917 : 	pjMsg.CtlCode		= lpMsg->CtlCode;

  00442	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00445	8a 88 3c 05 00
	00		 mov	 cl, BYTE PTR [eax+1340]
  0044b	88 4d f5	 mov	 BYTE PTR _pjMsg$[ebp+45], cl

; 1918 : 
; 1919 : #ifdef NEW_FORSKYLAND2
; 1920 : 	pjMsg.BP			= lpObj->BP;

  0044e	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00451	66 8b 88 e8 00
	00 00		 mov	 cx, WORD PTR [eax+232]
  00458	66 89 4d ea	 mov	 WORD PTR _pjMsg$[ebp+34], cx

; 1921 : 	pjMsg.MaxBP			= lpObj->MaxBP+lpObj->AddBP;

  0045c	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0045f	8b 88 ec 00 00
	00		 mov	 ecx, DWORD PTR [eax+236]
  00465	8b 55 a4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00468	03 8a f0 00 00
	00		 add	 ecx, DWORD PTR [edx+240]
  0046e	66 89 4d ec	 mov	 WORD PTR _pjMsg$[ebp+36], cx

; 1922 : #endif
; 1923 : 
; 1924 : #ifdef DARKLORD_WORK
; 1925 : 	pjMsg.Leadership = lpObj->Leadership;

  00472	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00475	66 8b 88 d8 00
	00 00		 mov	 cx, WORD PTR [eax+216]
  0047c	66 89 4d fa	 mov	 WORD PTR _pjMsg$[ebp+50], cx

; 1926 : #endif
; 1927 : 
; 1928 : 	short AddPoint		= 0;

  00480	33 c0		 xor	 eax, eax
  00482	66 89 45 a0	 mov	 WORD PTR _AddPoint$[ebp], ax

; 1929 : 	short MaxAddPoint	= 0;

  00486	33 c0		 xor	 eax, eax
  00488	66 89 45 9c	 mov	 WORD PTR _MaxAddPoint$[ebp], ax

; 1930 : 
; 1931 : #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 1932 : 	short MinusPoint	= 0;
; 1933 : 	short MaxMinusPoint = 0;
; 1934 : 	gObjGetStatPointState(lpObj->m_Index, AddPoint, MaxAddPoint, MinusPoint, MaxMinusPoint);
; 1935 : #else
; 1936 : 	gObjGetStatPointState(lpObj->m_Index, AddPoint, MaxAddPoint);

  0048c	8d 45 9c	 lea	 eax, DWORD PTR _MaxAddPoint$[ebp]
  0048f	50		 push	 eax
  00490	8d 4d a0	 lea	 ecx, DWORD PTR _AddPoint$[ebp]
  00493	51		 push	 ecx
  00494	8b 55 a4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00497	8b 02		 mov	 eax, DWORD PTR [edx]
  00499	50		 push	 eax
  0049a	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF0@Z ; gObjGetStatPointState
  0049f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1937 : #endif
; 1938 : 
; 1939 : 	pjMsg.AddPoint		= AddPoint;

  004a2	66 8b 45 a0	 mov	 ax, WORD PTR _AddPoint$[ebp]
  004a6	66 89 45 f6	 mov	 WORD PTR _pjMsg$[ebp+46], ax

; 1940 : 	pjMsg.MaxAddPoint	= MaxAddPoint;

  004aa	66 8b 45 9c	 mov	 ax, WORD PTR _MaxAddPoint$[ebp]
  004ae	66 89 45 f8	 mov	 WORD PTR _pjMsg$[ebp+48], ax

; 1941 : 
; 1942 : #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 1943 : 	pjMsg.wMinusPoint	= MinusPoint;
; 1944 : 	pjMsg.wMaxMinusPoint= MaxMinusPoint;
; 1945 : 
; 1946 : 	LogAddTD("[FRUIT System] [%s][%s] (MinusPoint:%d/PlusPoint:%d) (MaxMinus:%d/MaxPlus:%d)", 
; 1947 : 		lpObj->AccountID, lpObj->Name, MinusPoint, AddPoint, MaxMinusPoint, MaxAddPoint);
; 1948 : #endif
; 1949 : 
; 1950 : #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 1951 : 	if( AddPoint<0 || AddPoint>MaxAddPoint  || MinusPoint<0 || MinusPoint>MaxMinusPoint )
; 1952 : 	{
; 1953 : 		LogAddTD("[FRUIT System] Character Stat Error [%s][%s] (MinusPoint:%d/PlusPoint:%d) (MaxMinus:%d/MaxPlus:%d)", 
; 1954 : 			lpObj->AccountID, lpObj->Name, MinusPoint, AddPoint, MaxMinusPoint, MaxAddPoint);
; 1955 : 	}
; 1956 : #else
; 1957 : 	if( AddPoint < 0 || AddPoint > MaxAddPoint)

  004b2	0f bf 45 a0	 movsx	 eax, WORD PTR _AddPoint$[ebp]
  004b6	85 c0		 test	 eax, eax
  004b8	7c 0c		 jl	 SHORT $LN15@JGGetChara
  004ba	0f bf 45 a0	 movsx	 eax, WORD PTR _AddPoint$[ebp]
  004be	0f bf 4d 9c	 movsx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  004c2	3b c1		 cmp	 eax, ecx
  004c4	7e 32		 jle	 SHORT $LN14@JGGetChara
$LN15@JGGetChara:

; 1958 : 	{
; 1959 : 		LogAddTD(lMsg.Get(500), lpObj->AccountID, lpObj->Name, AddPoint, MaxAddPoint);

  004c6	0f bf 45 9c	 movsx	 eax, WORD PTR _MaxAddPoint$[ebp]
  004ca	50		 push	 eax
  004cb	0f bf 4d a0	 movsx	 ecx, WORD PTR _AddPoint$[ebp]
  004cf	51		 push	 ecx
  004d0	8b 55 a4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004d3	83 c2 73	 add	 edx, 115		; 00000073H
  004d6	52		 push	 edx
  004d7	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004da	83 c0 68	 add	 eax, 104		; 00000068H
  004dd	50		 push	 eax
  004de	68 f4 01 00 00	 push	 500			; 000001f4H
  004e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  004ee	50		 push	 eax
  004ef	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004f5	83 c4 14	 add	 esp, 20			; 00000014H
$LN14@JGGetChara:

; 1960 : 	}
; 1961 : #endif
; 1962 : 
; 1963 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 1964 : 	g_QuestInfo.QuestInfoSave(lpObj);
; 1965 : #endif // EXTEND_LOG_SYSTEM_20060202
; 1966 : 
; 1967 : 	DataSend(aIndex, (LPBYTE)&pjMsg, pjMsg.h.size);		// 여기까지 하면 사람의 모습만 보인다.

  004f8	0f b6 45 c9	 movzx	 eax, BYTE PTR _pjMsg$[ebp+1]
  004fc	50		 push	 eax
  004fd	8d 4d c8	 lea	 ecx, DWORD PTR _pjMsg$[ebp]
  00500	51		 push	 ecx
  00501	8b 55 ac	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00504	52		 push	 edx
  00505	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0050a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1968 : 	GCItemListSend(aIndex);								// 여기까지 하면 사람이 장비한 것이 보인다.

  0050d	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00510	50		 push	 eax
  00511	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  00516	83 c4 04	 add	 esp, 4

; 1969 : 	GCMagicListMultiSend( lpObj );						// 여기까지 하면 사람의 마법리스트를 한방에 보낸다.

  00519	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0051c	50		 push	 eax
  0051d	e8 00 00 00 00	 call	 ?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z ; GCMagicListMultiSend
  00522	83 c4 04	 add	 esp, 4

; 1970 : 
; 1971 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912					// DS에 마스터레벨 정보 요청
; 1972 : 	g_MasterLevelSystem.GDReqMasterLevelInfo( lpObj );
; 1973 : #endif
; 1974 : 
; 1975 : #ifdef ADD_SKILL_WITH_COMBO
; 1976 : 	CGRequestQuestInfo(aIndex);

  00525	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00528	50		 push	 eax
  00529	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo
  0052e	83 c4 04	 add	 esp, 4

; 1977 : #endif
; 1978 : 
; 1979 : #ifdef MODIFY_QUEST_MONSTER_KILL_COUNT_BUGFIX_20070704	// DS에 퀘스트 몬스터 킬카운트 정보 요청
; 1980 : 	// 정보 셋팅이 완료되면 몬스터 킬카운트 정보를 요청한다.
; 1981 : 	g_QuestUtil.GDReqQuestMonsterKillInfo( lpObj );
; 1982 : #endif
; 1983 : 
; 1984 : #ifdef _NEW_EXDB_
; 1985 : 	//##EXDB##
; 1986 : 	DGGuildMemberInfoRequest(aIndex);					// 해당 케릭에 대한 길드정보를 길드서버에 요청??

  00531	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00534	50		 push	 eax
  00535	e8 00 00 00 00	 call	 ?DGGuildMemberInfoRequest@@YAXH@Z ; DGGuildMemberInfoRequest
  0053a	83 c4 04	 add	 esp, 4

; 1987 : 	//##EXDB##
; 1988 : #endif
; 1989 : 	
; 1990 : // gObjSetCharacter에서 호출하던 것을 맵서버 적용에 따라 뒤쪽으로 이동시킴.
; 1991 : #ifdef MODIFY_ORDER_REQUEST_FRIENDLIST_20050205
; 1992 : 	#ifdef __FRIEND_WORK__
; 1993 : 		FriendListRequest(aIndex);

  0053d	8b 45 ac	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00540	50		 push	 eax
  00541	e8 00 00 00 00	 call	 ?FriendListRequest@@YAXH@Z ; FriendListRequest
  00546	83 c4 04	 add	 esp, 4

; 1994 : 	#endif
; 1995 : #endif
; 1996 : 
; 1997 : #ifdef FOR_JAPAN	
; 1998 : 	// 타마짱 이벤트가 진행중이면
; 1999 : 	if( gTamaJJangEvent )
; 2000 : 	{
; 2001 : 		if( gAppearTamaJJang && lpObj->MapNumber == 0 )
; 2002 : 		{	// 타마짱이 나와 있고, 로렌시아에 있으면
; 2003 : 			GCMapEventStateSend(0, gAppearTamaJJang, 2);	
; 2004 : 		}
; 2005 : 	}
; 2006 : #endif
; 2007 : 
; 2008 : #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	// 게임에 입장했을 때 변신 보여주기
; 2009 : 	gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 2010 : #endif
; 2011 : 	
; 2012 : #ifdef ADD_HACKING_TOOL_BLOCK_20090311
; 2013 : 	// 신규 접속자에게 서버에서 설정된 블록된 해킹툴의 사용여부를 확인한다.
; 2014 : 	g_HackToolBlock.HacktoolStatisticsNewConnect( lpObj );
; 2015 : #endif // ADD_HACKING_TOOL_BLOCK_20090311
; 2016 : 
; 2017 : #ifdef ADD_MAPMOVE_PROTOCOL_20090327
; 2018 : 	lpObj->m_dwMapMoveKeyValue = g_KeyGenerater.GenerateSeedValue();
; 2019 : 	GCSendMapMoveChecksum( lpObj );
; 2020 : #endif // ADD_MAPMOVE_PROTOCOL_20090327
; 2021 : 
; 2022 : 	g_ResetSystem.DBGetResetInfo(lpObj);

  00549	8b 45 a4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0054c	50		 push	 eax
  0054d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ResetSystem@@3VCResetSystem@@A ; g_ResetSystem
  00552	e8 00 00 00 00	 call	 ?DBGetResetInfo@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::DBGetResetInfo

; 2023 : 
; 2024 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 2025 : 	// 캐릭터 선택 후 맵
; 2026 : 	LogAddTD_TempLog(", [D->G Recv MapJoin] CharSelected, Account [%s], IP [%s], Name[%s]", 

  00557	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0055e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00564	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00568	52		 push	 edx
  00569	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00570	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00576	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0057a	52		 push	 edx
  0057b	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00582	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00588	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0058c	52		 push	 edx
  0058d	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@HOADODHJ@?0?5?$FLD?9?$DOG?5Recv?5MapJoin?$FN?5CharSelec@
  00592	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  00598	83 c4 10	 add	 esp, 16			; 00000010H

; 2027 : 		gObj[aIndex].AccountID, gObj[aIndex].Ip_addr, gObj[aIndex].Name);
; 2028 : #endif
; 2029 : 
; 2030 : 	PMSG_NOTICE pNotice;
; 2031 : 
; 2032 : 	TNotice::MakeNoticeMsg((TNotice*)&pNotice, 0x00,  g_GlobalConfig.m_szConnectMessage);

  0059b	68 fc 00 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+252
  005a0	6a 00		 push	 0
  005a2	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  005a8	50		 push	 eax
  005a9	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  005ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2033 : 	DataSend(aIndex, (unsigned char*)&pNotice , pNotice.h.size );

  005b1	0f b6 85 8d fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  005b8	50		 push	 eax
  005b9	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  005bf	51		 push	 ecx
  005c0	8b 55 ac	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005c3	52		 push	 edx
  005c4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@JGGetChara:

; 2034 : }

  005cc	5f		 pop	 edi
  005cd	5e		 pop	 esi
  005ce	5b		 pop	 ebx
  005cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005d2	33 cd		 xor	 ecx, ebp
  005d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d9	8b e5		 mov	 esp, ebp
  005db	5d		 pop	 ebp
  005dc	c3		 ret	 0
?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z ENDP ; JGGetCharacterInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z
_TEXT	SEGMENT
$T1 = -96						; size = 4
_aIndex$ = -28						; size = 4
_szAccountId$ = -24					; size = 11
_pResult$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z PROC	; JGCharDelRequest, COMDAT

; 1702 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1703 : 	PMSG_RESULT pResult;
; 1704 : 
; 1705 : 	char szAccountId[MAX_IDSTRING+1];
; 1706 : 	int	 aIndex = lpMsg->Number;	

  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  0001a	89 4d e4	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 1707 : 	
; 1708 : 	szAccountId[MAX_IDSTRING] = '\0';

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	6b c8 0a	 imul	 ecx, eax, 10
  00025	89 4d a0	 mov	 DWORD PTR $T1[ebp], ecx
  00028	83 7d a0 0b	 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  0002c	73 02		 jae	 SHORT $LN4@JGCharDelR
  0002e	eb 05		 jmp	 SHORT $LN5@JGCharDelR
$LN4@JGCharDelR:
  00030	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN5@JGCharDelR:
  00035	8b 55 a0	 mov	 edx, DWORD PTR $T1[ebp]
  00038	c6 44 15 e8 00	 mov	 BYTE PTR _szAccountId$[ebp+edx], 0

; 1709 : 	
; 1710 : 	memcpy(szAccountId, lpMsg->AccountID, MAX_IDSTRING);

  0003d	6a 0a		 push	 10			; 0000000aH
  0003f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00042	83 c0 06	 add	 eax, 6
  00045	50		 push	 eax
  00046	8d 4d e8	 lea	 ecx, DWORD PTR _szAccountId$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _memcpy
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1711 : 	if( gObjIsAccontConnect(aIndex, szAccountId) == FALSE )

  00052	8d 45 e8	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00055	50		 push	 eax
  00056	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0005f	83 c4 08	 add	 esp, 8
  00062	85 c0		 test	 eax, eax
  00064	75 2e		 jne	 SHORT $LN2@JGCharDelR

; 1712 : 	{
; 1713 : 		LogAddC(LOGC_RED, lMsg.Get(425), szAccountId);

  00066	8d 45 e8	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00069	50		 push	 eax
  0006a	68 a9 01 00 00	 push	 425			; 000001a9H
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0007a	50		 push	 eax
  0007b	6a 02		 push	 2
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1714 : 		CloseClient ( aIndex );

  00086	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0008f	83 c4 04	 add	 esp, 4

; 1715 : 		return;

  00092	eb 32		 jmp	 SHORT $LN3@JGCharDelR
$LN2@JGCharDelR:

; 1716 : 	}
; 1717 : 
; 1718 : 	pResult.h.c        = PMHC_BYTE;

  00094	c6 45 f4 c1	 mov	 BYTE PTR _pResult$[ebp], 193 ; 000000c1H

; 1719 : 	pResult.h.size     = sizeof( pResult );

  00098	c6 45 f5 05	 mov	 BYTE PTR _pResult$[ebp+1], 5

; 1720 : 	pResult.h.headcode = 0xF3;

  0009c	c6 45 f6 f3	 mov	 BYTE PTR _pResult$[ebp+2], 243 ; 000000f3H

; 1721 : 	pResult.subcode    = 0x02;

  000a0	c6 45 f7 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 1722 : 	pResult.result	   = lpMsg->Result;

  000a4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a7	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  000aa	88 4d f8	 mov	 BYTE PTR _pResult$[ebp+4], cl

; 1723 : 
; 1724 : 	DataSend(lpMsg->Number, (LPBYTE)&pResult, pResult.h.size);

  000ad	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000b1	50		 push	 eax
  000b2	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000b5	51		 push	 ecx
  000b6	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000b9	0f bf 42 04	 movsx	 eax, WORD PTR [edx+4]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@JGCharDelR:

; 1725 : }

  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cc	33 cd		 xor	 ecx, ebp
  000ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z ENDP	; JGCharDelRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z
_TEXT	SEGMENT
$T1 = -132						; size = 4
_aIndex$ = -64						; size = 4
_szAccountId$ = -60					; size = 11
_pResult$ = -48						; size = 42
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z PROC ; JGCharacterCreateRequest, COMDAT

; 1610 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1611 : 	PMSG_CHARCREATERESULT	pResult;
; 1612 : 	
; 1613 : 	char szAccountId[MAX_IDSTRING+1];
; 1614 : 	
; 1615 : 	int	 aIndex = lpMsg->Number;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00019	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  0001d	89 4d c0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 1616 : 	
; 1617 : 	szAccountId[MAX_IDSTRING] = '\0';

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	6b c8 0a	 imul	 ecx, eax, 10
  00028	89 8d 7c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0002e	83 bd 7c ff ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00035	73 02		 jae	 SHORT $LN5@JGCharacte
  00037	eb 05		 jmp	 SHORT $LN6@JGCharacte
$LN5@JGCharacte:
  00039	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN6@JGCharacte:
  0003e	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00044	c6 44 15 c4 00	 mov	 BYTE PTR _szAccountId$[ebp+edx], 0

; 1618 : 	
; 1619 : 	memcpy(szAccountId, lpMsg->AccountId, MAX_IDSTRING);

  00049	6a 0a		 push	 10			; 0000000aH
  0004b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004e	83 c0 06	 add	 eax, 6
  00051	50		 push	 eax
  00052	8d 4d c4	 lea	 ecx, DWORD PTR _szAccountId$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _memcpy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1620 : 	if( gObjIsAccontConnect(aIndex, szAccountId) == FALSE )

  0005e	8d 45 c4	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00061	50		 push	 eax
  00062	8b 4d c0	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0006b	83 c4 08	 add	 esp, 8
  0006e	85 c0		 test	 eax, eax
  00070	75 2e		 jne	 SHORT $LN2@JGCharacte

; 1621 : 	{
; 1622 : 		LogAddC(LOGC_RED, lMsg.Get(424),szAccountId);

  00072	8d 45 c4	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00075	50		 push	 eax
  00076	68 a8 01 00 00	 push	 424			; 000001a8H
  0007b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00086	50		 push	 eax
  00087	6a 02		 push	 2
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1623 : 		CloseClient ( aIndex );

  00092	8b 45 c0	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0009b	83 c4 04	 add	 esp, 4

; 1624 : 		return;

  0009e	eb 75		 jmp	 SHORT $LN4@JGCharacte
$LN2@JGCharacte:

; 1625 : 	}
; 1626 : 
; 1627 : 	pResult.h.c        = PMHC_BYTE;

  000a0	c6 45 d0 c1	 mov	 BYTE PTR _pResult$[ebp], 193 ; 000000c1H

; 1628 : 	pResult.h.size     = sizeof( pResult );

  000a4	c6 45 d1 2a	 mov	 BYTE PTR _pResult$[ebp+1], 42 ; 0000002aH

; 1629 : 	pResult.h.headcode = 0xF3;

  000a8	c6 45 d2 f3	 mov	 BYTE PTR _pResult$[ebp+2], 243 ; 000000f3H

; 1630 : 	pResult.subcode    = 0x01;

  000ac	c6 45 d3 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 1631 : 	pResult.Result     = lpMsg->Result;

  000b0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000b3	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  000b6	88 4d d4	 mov	 BYTE PTR _pResult$[ebp+4], cl

; 1632 : 	pResult.pos        = lpMsg->Pos;

  000b9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000bc	8a 48 1a	 mov	 cl, BYTE PTR [eax+26]
  000bf	88 4d df	 mov	 BYTE PTR _pResult$[ebp+15], cl

; 1633 : 
; 1634 : #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 1635 : 	if( lpMsg->ClassSkin == 0 || lpMsg->ClassSkin == 16 || lpMsg->ClassSkin == 32 )
; 1636 : 	{
; 1637 : 		lpMsg->ClassSkin++;
; 1638 : 	}
; 1639 : 
; 1640 : 	pResult.Class = ((lpMsg->ClassSkin>>4)<<5)&0xE0; 
; 1641 : 	int changeup = (lpMsg->ClassSkin)&CHANGEUP_MASK;
; 1642 : 	pResult.Class |= (changeup<<4)&0x10;
; 1643 : 	
; 1644 : #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 캐릭생성결과를 받았다.	
; 1645 : 	pResult.Class |= ( changeup << 4 )&0x20;
; 1646 : #endif
; 1647 : 
; 1648 : 	//pResult.Class = lpMsg->ClassSkin;
; 1649 : #else
; 1650 : 	#ifdef ADD_CLASSINFO_ON_CHARCTER_CREATION_20041224
; 1651 : //		if( lpMsg->ClassSkin == 0 || lpMsg->ClassSkin == 16 || lpMsg->ClassSkin == 32 )
; 1652 : //		{
; 1653 : //			lpMsg->ClassSkin++;
; 1654 : //		}
; 1655 : 		
; 1656 : 		pResult.Class = ((lpMsg->ClassSkin>>4)<<5)&0xE0; 
; 1657 : 		int changeup = (lpMsg->ClassSkin)&CHANGEUP_MASK;
; 1658 : 		pResult.Class |= (changeup<<4)&0x10;	
; 1659 : 		
; 1660 : #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 캐릭생성결과를 받았다.
; 1661 : 		pResult.Class |= ( changeup << 4 )&0x20;
; 1662 : #endif
; 1663 : 
; 1664 : 	#endif
; 1665 : #endif
; 1666 : 	
; 1667 : 
; 1668 : 
; 1669 : 
; 1670 : #ifdef DARKLORD_WORK
; 1671 : 	pResult.Level        = lpMsg->Level;

  000c2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000c5	66 8b 48 34	 mov	 cx, WORD PTR [eax+52]
  000c9	66 89 4d e0	 mov	 WORD PTR _pResult$[ebp+16], cx

; 1672 : #endif
; 1673 : 	memcpy(pResult.Name, lpMsg->Name, MAX_IDSTRING);

  000cd	6a 0a		 push	 10			; 0000000aH
  000cf	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000d2	83 c0 10	 add	 eax, 16			; 00000010H
  000d5	50		 push	 eax
  000d6	8d 4d d5	 lea	 ecx, DWORD PTR _pResult$[ebp+5]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 _memcpy
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1674 : 	
; 1675 : 	if( pResult.Result == 0x01 ) // 성공이면 장비 착용

  000e2	0f b6 45 d4	 movzx	 eax, BYTE PTR _pResult$[ebp+4]
  000e6	83 f8 01	 cmp	 eax, 1
  000e9	75 15		 jne	 SHORT $LN3@JGCharacte

; 1676 : 	{
; 1677 : 		memcpy(pResult.Equipment, lpMsg->Equipment, 24);

  000eb	6a 18		 push	 24			; 00000018H
  000ed	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000f0	83 c0 1c	 add	 eax, 28			; 0000001cH
  000f3	50		 push	 eax
  000f4	8d 4d e2	 lea	 ecx, DWORD PTR _pResult$[ebp+18]
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 _memcpy
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@JGCharacte:

; 1678 : 	}
; 1679 : 
; 1680 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00100	0f b6 45 d1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00104	50		 push	 eax
  00105	8d 4d d0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00108	51		 push	 ecx
  00109	8b 55 c0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0010c	52		 push	 edx
  0010d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@JGCharacte:

; 1681 : }

  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	5b		 pop	 ebx
  00118	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011b	33 cd		 xor	 ecx, ebp
  0011d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z ENDP ; JGCharacterCreateRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?JGPGetCharList@@YAXPAE@Z
_TEXT	SEGMENT
$T1 = -428						; size = 4
_levelindex$2 = -360					; size = 4
_levelindex$3 = -356					; size = 4
_changeup$4 = -352					; size = 4
_n$5 = -348						; size = 4
_TempInventory$ = -344					; size = 12
_pCList$ = -332						; size = 28
_pCLCount$ = -304					; size = 7
_index$ = -293						; size = 1
_aIndex$ = -292						; size = 4
_lsOfs$ = -288						; size = 4
_lOfs$ = -284						; size = 4
_sendbuf$ = -280					; size = 256
_szId$ = -24						; size = 11
_lpCL$ = -12						; size = 4
_lpCount$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
?JGPGetCharList@@YAXPAE@Z PROC				; JGPGetCharList, COMDAT

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 575  : 	LPSDHP_CHARLISTCOUNT	lpCount = (LPSDHP_CHARLISTCOUNT)lpRecv;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00019	89 45 f8	 mov	 DWORD PTR _lpCount$[ebp], eax

; 576  : 	LPSDHP_CHARLIST			lpCL;
; 577  : 	
; 578  : 	char szId[MAX_IDSTRING+1];
; 579  : 	BYTE sendbuf[256];
; 580  : 	int  lOfs=0;

  0001c	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 581  : 	int  lsOfs=sizeof(SDHP_CHARLISTCOUNT);

  00026	c7 85 e0 fe ff
	ff 1c 00 00 00	 mov	 DWORD PTR _lsOfs$[ebp], 28 ; 0000001cH

; 582  : 	int  aIndex = lpCount->Number;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00033	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00037	89 8d dc fe ff
	ff		 mov	 DWORD PTR _aIndex$[ebp], ecx

; 583  : 	BYTE index;
; 584  : 	
; 585  : 	PMSG_CHARLISTCOUNT	pCLCount;
; 586  : 	PMSG_CHARLIST		pCList;
; 587  : 
; 588  : #ifdef ITEM_INDEX_EXTEND_20050706
; 589  : 	WORD TempInventory[12];
; 590  : #else
; 591  : 	BYTE TempInventory[12];
; 592  : #endif
; 593  : 
; 594  : 	pCLCount.h.c        = PMHC_BYTE;

  0003d	c6 85 d0 fe ff
	ff c1		 mov	 BYTE PTR _pCLCount$[ebp], 193 ; 000000c1H

; 595  : 	pCLCount.h.headcode = 0xF3;

  00044	c6 85 d2 fe ff
	ff f3		 mov	 BYTE PTR _pCLCount$[ebp+2], 243 ; 000000f3H

; 596  : 	pCLCount.subcode    = 0x00;

  0004b	c6 85 d3 fe ff
	ff 00		 mov	 BYTE PTR _pCLCount$[ebp+3], 0

; 597  : 	pCLCount.Count      = lpCount->Count;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00055	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  00058	88 8d d6 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+6], cl

; 598  : 
; 599  : 	szId[MAX_IDSTRING] = '\0';

  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	6b c8 0a	 imul	 ecx, eax, 10
  00066	89 8d 54 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0006c	83 bd 54 fe ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00073	73 02		 jae	 SHORT $LN70@JGPGetChar
  00075	eb 05		 jmp	 SHORT $LN71@JGPGetChar
$LN70@JGPGetChar:
  00077	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN71@JGPGetChar:
  0007c	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00082	c6 44 15 e8 00	 mov	 BYTE PTR _szId$[ebp+edx], 0

; 600  : 	memcpy(szId, lpCount->AccountId, MAX_IDSTRING);

  00087	6a 0a		 push	 10			; 0000000aH
  00089	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  0008c	83 c0 0d	 add	 eax, 13			; 0000000dH
  0008f	50		 push	 eax
  00090	8d 4d e8	 lea	 ecx, DWORD PTR _szId$[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _memcpy
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 601  : 	if( gObjIsAccontConnect(aIndex, szId) == FALSE )

  0009c	8d 45 e8	 lea	 eax, DWORD PTR _szId$[ebp]
  0009f	50		 push	 eax
  000a0	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  000ac	83 c4 08	 add	 esp, 8
  000af	85 c0		 test	 eax, eax
  000b1	75 49		 jne	 SHORT $LN5@JGPGetChar

; 602  : 	{
; 603  : 		LogAddC(LOGC_RED, lMsg.Get(421),gObj[aIndex].AccountID, szId);

  000b3	8d 45 e8	 lea	 eax, DWORD PTR _szId$[ebp]
  000b6	50		 push	 eax
  000b7	69 8d dc fe ff
	ff a0 1b 00 00	 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  000cb	50		 push	 eax
  000cc	68 a5 01 00 00	 push	 421			; 000001a5H
  000d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000dc	50		 push	 eax
  000dd	6a 02		 push	 2
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000e5	83 c4 10	 add	 esp, 16			; 00000010H

; 604  : 		CloseClient ( aIndex );

  000e8	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _aIndex$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000f4	83 c4 04	 add	 esp, 4

; 605  : 		return;

  000f7	e9 6c 12 00 00	 jmp	 $LN69@JGPGetChar
$LN5@JGPGetChar:

; 606  : 	}
; 607  : 
; 608  : 	gObj[aIndex].Magumsa = lpCount->Magumsa;

  000fc	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010c	8b 55 f8	 mov	 edx, DWORD PTR _lpCount$[ebp]
  0010f	8a 52 0c	 mov	 dl, BYTE PTR [edx+12]
  00112	88 54 01 30	 mov	 BYTE PTR [ecx+eax+48], dl

; 609  : 
; 610  : #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 611  : 	gObj[aIndex].Magumsa = 1;
; 612  : #endif
; 613  : 
; 614  : #ifdef FOR_NEW_TESTSERVER
; 615  : //	if( gTestServer )
; 616  : 	{
; 617  : 		gObj[aIndex].Magumsa = 2;
; 618  : 	}
; 619  : #endif
; 620  : 
; 621  : 	#ifdef DARKLORD_WORK	
; 622  : 		pCLCount.MaxClass = gObj[aIndex].Magumsa+2;

  00116	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00126	0f b6 54 01 30	 movzx	 edx, BYTE PTR [ecx+eax+48]
  0012b	83 c2 02	 add	 edx, 2
  0012e	88 95 d4 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+4], dl

; 623  : 	#endif
; 624  : 
; 625  : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 626  : 		pCLCount.MaxClass += 1;
; 627  : #endif		
; 628  : 
; 629  : #ifdef CHARACTER_MOVE_20040810
; 630  : 	pCLCount.MoveCnt = lpCount->MoveCnt;

  00134	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00137	8a 48 18	 mov	 cl, BYTE PTR [eax+24]
  0013a	88 8d d5 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+5], cl

; 631  : #endif
; 632  : 
; 633  : 	memset( sendbuf, 0, sizeof(sendbuf));

  00140	68 00 01 00 00	 push	 256			; 00000100H
  00145	6a 00		 push	 0
  00147	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _memset
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH

; 634  : 	lOfs += sizeof(pCLCount);

  00156	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0015c	83 c0 07	 add	 eax, 7
  0015f	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 635  : 
; 636  : 	if( pCLCount.Count > 0 )

  00165	0f b6 85 d6 fe
	ff ff		 movzx	 eax, BYTE PTR _pCLCount$[ebp+6]
  0016c	85 c0		 test	 eax, eax
  0016e	0f 8e 7b 11 00
	00		 jle	 $LN6@JGPGetChar

; 637  : 	{
; 638  : 		for( int n=0; n<pCLCount.Count; n++)

  00174	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$5[ebp], 0
  0017e	eb 0f		 jmp	 SHORT $LN4@JGPGetChar
$LN2@JGPGetChar:
  00180	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _n$5[ebp]
  00186	83 c0 01	 add	 eax, 1
  00189	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _n$5[ebp], eax
$LN4@JGPGetChar:
  0018f	0f b6 85 d6 fe
	ff ff		 movzx	 eax, BYTE PTR _pCLCount$[ebp+6]
  00196	39 85 a4 fe ff
	ff		 cmp	 DWORD PTR _n$5[ebp], eax
  0019c	0f 8d 4d 11 00
	00		 jge	 $LN6@JGPGetChar

; 639  : 		{
; 640  : #ifdef ITEM_INDEX_EXTEND_20050706
; 641  : 			memset(&pCList, 0, sizeof(pCList));
; 642  : #endif
; 643  : 
; 644  : 			lpCL = (LPSDHP_CHARLIST)(lpRecv+lsOfs);

  001a2	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  001a5	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _lsOfs$[ebp]
  001ab	89 45 f4	 mov	 DWORD PTR _lpCL$[ebp], eax

; 645  : 			pCList.Index = lpCL->Index;

  001ae	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  001b1	8a 08		 mov	 cl, BYTE PTR [eax]
  001b3	88 8d b4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp], cl

; 646  : 			pCList.Level = lpCL->Level;

  001b9	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  001bc	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  001c0	66 89 8d c0 fe
	ff ff		 mov	 WORD PTR _pCList$[ebp+12], cx

; 647  : 			pCList.CtlCode = lpCL->CtlCode;

  001c7	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  001ca	8a 48 0f	 mov	 cl, BYTE PTR [eax+15]
  001cd	88 8d c2 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+14], cl

; 648  : 			
; 649  : #ifdef ADD_CHARACTERLIST_GUILD_STATUS_01_20050126
; 650  : 			pCList.btGuildStatus = lpCL->btGuildStatus;
; 651  : #endif
; 652  : 			if( gObj[aIndex].m_cAccountItemBlock )

  001d3	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e3	0f b6 94 01 ac
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+428]
  001eb	85 d2		 test	 edx, edx
  001ed	74 10		 je	 SHORT $LN7@JGPGetChar

; 653  : 			{	// 계정 캐릭터 블럭 표시
; 654  : 				pCList.CtlCode |= 0x10;

  001ef	0f b6 85 c2 fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$[ebp+14]
  001f6	83 c8 10	 or	 eax, 16			; 00000010H
  001f9	88 85 c2 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+14], al
$LN7@JGPGetChar:

; 655  : 			}
; 656  : 
; 657  : 			memcpy(pCList.Name, lpCL->Name, MAX_IDSTRING);

  001ff	6a 0a		 push	 10			; 0000000aH
  00201	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  00204	83 c0 01	 add	 eax, 1
  00207	50		 push	 eax
  00208	8d 8d b5 fe ff
	ff		 lea	 ecx, DWORD PTR _pCList$[ebp+1]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 _memcpy
  00214	83 c4 0c	 add	 esp, 12			; 0000000cH

; 658  : 			
; 659  : 			pCList.CharSet[0] = ((lpCL->Class>>4)<<5)&0xE0; 

  00217	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  0021a	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0021e	c1 f9 04	 sar	 ecx, 4
  00221	c1 e1 05	 shl	 ecx, 5
  00224	81 e1 e0 00 00
	00		 and	 ecx, 224		; 000000e0H
  0022a	ba 01 00 00 00	 mov	 edx, 1
  0022f	6b c2 00	 imul	 eax, edx, 0
  00232	88 8c 05 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+eax+15], cl

; 660  : #ifdef NEW_SKILL_FORSKYLAND	
; 661  : 			//(lpMsg->Class>>1)&0x01;
; 662  : 			int changeup = (lpCL->Class)&CHANGEUP_MASK;

  00239	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  0023c	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00240	83 e1 07	 and	 ecx, 7
  00243	89 8d a0 fe ff
	ff		 mov	 DWORD PTR _changeup$4[ebp], ecx

; 663  : 			pCList.CharSet[0] |= (changeup<<4)&0x10;			

  00249	b8 01 00 00 00	 mov	 eax, 1
  0024e	6b c8 00	 imul	 ecx, eax, 0
  00251	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _changeup$4[ebp]
  00257	c1 e2 04	 shl	 edx, 4
  0025a	83 e2 10	 and	 edx, 16			; 00000010H
  0025d	0f b6 84 0d c3
	fe ff ff	 movzx	 eax, BYTE PTR _pCList$[ebp+ecx+15]
  00265	0b c2		 or	 eax, edx
  00267	b9 01 00 00 00	 mov	 ecx, 1
  0026c	6b d1 00	 imul	 edx, ecx, 0
  0026f	88 84 15 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+edx+15], al

; 664  : #else
; 665  : 			pCList.CharSet[0] |= ((lpCL->Class&0x0F)<<4)&0x10;		// skin
; 666  : #endif
; 667  : 
; 668  : #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 클라이언트에 3차전직 정보를 보낸다.			
; 669  : 			pCList.CharSet[0] |= ( ( changeup >> 1 )<< 3)&0x08;
; 670  : #endif
; 671  : 			
; 672  : 			pCList.CharSet[9] = 0x00;

  00276	b8 01 00 00 00	 mov	 eax, 1
  0027b	6b c8 09	 imul	 ecx, eax, 9
  0027e	c6 84 0d c3 fe
	ff ff 00	 mov	 BYTE PTR _pCList$[ebp+ecx+15], 0

; 673  : 			
; 674  : 			
; 675  : 			//---------------------------------------------------------------------------------
; 676  : 			//
; 677  : 			//  [] DB Version - 0x00
; 678  : 			//
; 679  : 			//	   Check Date - 20051117
; 680  : 			// 	
; 681  : 			//---------------------------------------------------------------------------------
; 682  : 			if( lpCL->DbVersion == 0x00 )

  00286	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  00289	0f b6 48 40	 movzx	 ecx, BYTE PTR [eax+64]
  0028d	85 c9		 test	 ecx, ecx
  0028f	0f 85 9a 05 00
	00		 jne	 $LN8@JGPGetChar

; 683  : 			{
; 684  : //				if( lpCL->dbInventory[4] == 0xFF )
; 685  : //					index = 0xF0;
; 686  : //				else index = (lpCL->dbInventory[4]&0x0F)<<4;
; 687  : 
; 688  : #ifdef ITEM_INDEX_EXTEND_20050706
; 689  : 				// 오른손 무기
; 690  : 				if (lpCL->dbInventory[0] != 0xFF) 
; 691  : 				{
; 692  : 					WORD wItemCode = (lpCL->dbInventory[0]/32)*MAX_ITEM_INDEX+(lpCL->dbInventory[0]%32);
; 693  : 					pCList.CharSet[1] = (BYTE) wItemCode;
; 694  : 					pCList.CharSet[12] |= (BYTE) ((wItemCode&0x0F00) >> 4);
; 695  : 				}
; 696  : 				else 
; 697  : 				{
; 698  : 					pCList.CharSet[1] = 0xFF;
; 699  : 					pCList.CharSet[12] |= 0xF0;
; 700  : 				}
; 701  : 				// 왼손 무기
; 702  : 				if (lpCL->dbInventory[2] != 0xFF) 
; 703  : 				{
; 704  : 					WORD wItemCode = (lpCL->dbInventory[2]/16)*MAX_ITEM_INDEX+(lpCL->dbInventory[2]%16);
; 705  : 					pCList.CharSet[2] = (BYTE) wItemCode;
; 706  : 					pCList.CharSet[13] |= (BYTE) ((wItemCode&0x0F00) >> 4);
; 707  : 				}
; 708  : 				else 
; 709  : 				{
; 710  : 					pCList.CharSet[2] = 0xFF;
; 711  : 					pCList.CharSet[13] |= 0xF0;
; 712  : 				}
; 713  : #else
; 714  : 				pCList.CharSet[1] = (lpCL->dbInventory[0]/16)*MAX_ITEM_INDEX+(lpCL->dbInventory[0]%16);

  00295	b8 01 00 00 00	 mov	 eax, 1
  0029a	6b c8 00	 imul	 ecx, eax, 0
  0029d	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  002a0	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  002a5	99		 cdq
  002a6	83 e2 0f	 and	 edx, 15			; 0000000fH
  002a9	03 c2		 add	 eax, edx
  002ab	c1 f8 04	 sar	 eax, 4
  002ae	c1 e0 05	 shl	 eax, 5
  002b1	b9 01 00 00 00	 mov	 ecx, 1
  002b6	6b d1 00	 imul	 edx, ecx, 0
  002b9	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  002bc	0f b6 54 11 10	 movzx	 edx, BYTE PTR [ecx+edx+16]
  002c1	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  002c7	79 05		 jns	 SHORT $LN72@JGPGetChar
  002c9	4a		 dec	 edx
  002ca	83 ca f0	 or	 edx, -16		; fffffff0H
  002cd	42		 inc	 edx
$LN72@JGPGetChar:
  002ce	03 c2		 add	 eax, edx
  002d0	b9 01 00 00 00	 mov	 ecx, 1
  002d5	c1 e1 00	 shl	 ecx, 0
  002d8	88 84 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], al

; 715  : 				pCList.CharSet[2] = (lpCL->dbInventory[2]/16)*MAX_ITEM_INDEX+(lpCL->dbInventory[2]%16);

  002df	b8 01 00 00 00	 mov	 eax, 1
  002e4	d1 e0		 shl	 eax, 1
  002e6	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  002e9	0f b6 44 01 10	 movzx	 eax, BYTE PTR [ecx+eax+16]
  002ee	99		 cdq
  002ef	83 e2 0f	 and	 edx, 15			; 0000000fH
  002f2	03 c2		 add	 eax, edx
  002f4	c1 f8 04	 sar	 eax, 4
  002f7	c1 e0 05	 shl	 eax, 5
  002fa	ba 01 00 00 00	 mov	 edx, 1
  002ff	d1 e2		 shl	 edx, 1
  00301	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00304	0f b6 54 11 10	 movzx	 edx, BYTE PTR [ecx+edx+16]
  00309	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  0030f	79 05		 jns	 SHORT $LN73@JGPGetChar
  00311	4a		 dec	 edx
  00312	83 ca f0	 or	 edx, -16		; fffffff0H
  00315	42		 inc	 edx
$LN73@JGPGetChar:
  00316	03 c2		 add	 eax, edx
  00318	b9 01 00 00 00	 mov	 ecx, 1
  0031d	d1 e1		 shl	 ecx, 1
  0031f	88 84 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], al

; 716  : #endif
; 717  : 
; 718  : 				if( lpCL->dbInventory[4] == 0xFF )

  00326	b8 01 00 00 00	 mov	 eax, 1
  0032b	c1 e0 02	 shl	 eax, 2
  0032e	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00331	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  00336	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0033c	75 09		 jne	 SHORT $LN10@JGPGetChar

; 719  : 					index = 0xF0;

  0033e	c6 85 db fe ff
	ff f0		 mov	 BYTE PTR _index$[ebp], 240 ; 000000f0H
  00345	eb 1c		 jmp	 SHORT $LN11@JGPGetChar
$LN10@JGPGetChar:

; 720  : 				else index = (lpCL->dbInventory[4]&0x0F)<<4;

  00347	b8 01 00 00 00	 mov	 eax, 1
  0034c	c1 e0 02	 shl	 eax, 2
  0034f	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00352	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  00357	83 e2 0f	 and	 edx, 15			; 0000000fH
  0035a	c1 e2 04	 shl	 edx, 4
  0035d	88 95 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], dl
$LN11@JGPGetChar:

; 721  : 				if( lpCL->dbInventory[6] == 0xFF )

  00363	b8 01 00 00 00	 mov	 eax, 1
  00368	6b c8 06	 imul	 ecx, eax, 6
  0036b	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0036e	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00373	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00378	75 12		 jne	 SHORT $LN12@JGPGetChar

; 722  : 					index |= 0x0F;

  0037a	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  00381	83 c8 0f	 or	 eax, 15			; 0000000fH
  00384	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
  0038a	eb 22		 jmp	 SHORT $LN13@JGPGetChar
$LN12@JGPGetChar:

; 723  : 				else index |=(lpCL->dbInventory[6]&0x0F);

  0038c	b8 01 00 00 00	 mov	 eax, 1
  00391	6b c8 06	 imul	 ecx, eax, 6
  00394	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00397	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  0039c	83 e0 0f	 and	 eax, 15			; 0000000fH
  0039f	0f b6 8d db fe
	ff ff		 movzx	 ecx, BYTE PTR _index$[ebp]
  003a6	0b c8		 or	 ecx, eax
  003a8	88 8d db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], cl
$LN13@JGPGetChar:

; 724  : 				pCList.CharSet[3] = index;

  003ae	b8 01 00 00 00	 mov	 eax, 1
  003b3	6b c8 03	 imul	 ecx, eax, 3
  003b6	8a 95 db fe ff
	ff		 mov	 dl, BYTE PTR _index$[ebp]
  003bc	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl

; 725  : 				
; 726  : 				if( lpCL->dbInventory[8] == 0xFF )

  003c3	b8 01 00 00 00	 mov	 eax, 1
  003c8	c1 e0 03	 shl	 eax, 3
  003cb	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  003ce	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  003d3	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  003d9	75 09		 jne	 SHORT $LN14@JGPGetChar

; 727  : 					index = 0xF0;					

  003db	c6 85 db fe ff
	ff f0		 mov	 BYTE PTR _index$[ebp], 240 ; 000000f0H
  003e2	eb 1c		 jmp	 SHORT $LN15@JGPGetChar
$LN14@JGPGetChar:

; 728  : 				else index = (lpCL->dbInventory[8]&0x0F)<<4;

  003e4	b8 01 00 00 00	 mov	 eax, 1
  003e9	c1 e0 03	 shl	 eax, 3
  003ec	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  003ef	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  003f4	83 e2 0f	 and	 edx, 15			; 0000000fH
  003f7	c1 e2 04	 shl	 edx, 4
  003fa	88 95 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], dl
$LN15@JGPGetChar:

; 729  : 				if( lpCL->dbInventory[10] == 0xFF )

  00400	b8 01 00 00 00	 mov	 eax, 1
  00405	6b c8 0a	 imul	 ecx, eax, 10
  00408	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0040b	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00410	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00415	75 12		 jne	 SHORT $LN16@JGPGetChar

; 730  : 					index |= 0x0F;

  00417	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  0041e	83 c8 0f	 or	 eax, 15			; 0000000fH
  00421	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
  00427	eb 22		 jmp	 SHORT $LN17@JGPGetChar
$LN16@JGPGetChar:

; 731  : 				else index |=(lpCL->dbInventory[10]&0x0F);

  00429	b8 01 00 00 00	 mov	 eax, 1
  0042e	6b c8 0a	 imul	 ecx, eax, 10
  00431	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00434	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00439	83 e0 0f	 and	 eax, 15			; 0000000fH
  0043c	0f b6 8d db fe
	ff ff		 movzx	 ecx, BYTE PTR _index$[ebp]
  00443	0b c8		 or	 ecx, eax
  00445	88 8d db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], cl
$LN17@JGPGetChar:

; 732  : 				pCList.CharSet[4] = index;

  0044b	b8 01 00 00 00	 mov	 eax, 1
  00450	c1 e0 02	 shl	 eax, 2
  00453	8a 8d db fe ff
	ff		 mov	 cl, BYTE PTR _index$[ebp]
  00459	88 8c 05 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+eax+15], cl

; 733  : 				
; 734  : 				if( lpCL->dbInventory[12] == 0xFF )

  00460	b8 01 00 00 00	 mov	 eax, 1
  00465	6b c8 0c	 imul	 ecx, eax, 12
  00468	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0046b	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00470	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00475	75 09		 jne	 SHORT $LN18@JGPGetChar

; 735  : 					index = 0xF0;					

  00477	c6 85 db fe ff
	ff f0		 mov	 BYTE PTR _index$[ebp], 240 ; 000000f0H
  0047e	eb 1c		 jmp	 SHORT $LN19@JGPGetChar
$LN18@JGPGetChar:

; 736  : 				else index = (lpCL->dbInventory[12]&0x0F)<<4;

  00480	b8 01 00 00 00	 mov	 eax, 1
  00485	6b c8 0c	 imul	 ecx, eax, 12
  00488	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0048b	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00490	83 e0 0f	 and	 eax, 15			; 0000000fH
  00493	c1 e0 04	 shl	 eax, 4
  00496	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
$LN19@JGPGetChar:

; 737  : 
; 738  : 				// 날개와 헬퍼는 2비트씩
; 739  : 				if( lpCL->dbInventory[14] == 0xFF )

  0049c	b8 01 00 00 00	 mov	 eax, 1
  004a1	6b c8 0e	 imul	 ecx, eax, 14
  004a4	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  004a7	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  004ac	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  004b1	75 12		 jne	 SHORT $LN20@JGPGetChar

; 740  : 					index |= 0x0C;

  004b3	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  004ba	83 c8 0c	 or	 eax, 12			; 0000000cH
  004bd	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
  004c3	eb 25		 jmp	 SHORT $LN21@JGPGetChar
$LN20@JGPGetChar:

; 741  : 				else index |=(lpCL->dbInventory[14]&0x03)<<2;

  004c5	b8 01 00 00 00	 mov	 eax, 1
  004ca	6b c8 0e	 imul	 ecx, eax, 14
  004cd	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  004d0	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  004d5	83 e0 03	 and	 eax, 3
  004d8	c1 e0 02	 shl	 eax, 2
  004db	0f b6 8d db fe
	ff ff		 movzx	 ecx, BYTE PTR _index$[ebp]
  004e2	0b c8		 or	 ecx, eax
  004e4	88 8d db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], cl
$LN21@JGPGetChar:

; 742  : 				if( lpCL->dbInventory[16] == 0xFF  )

  004ea	b8 01 00 00 00	 mov	 eax, 1
  004ef	c1 e0 04	 shl	 eax, 4
  004f2	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  004f5	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  004fa	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00500	75 12		 jne	 SHORT $LN22@JGPGetChar

; 743  : 					index |= 0x03;

  00502	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  00509	83 c8 03	 or	 eax, 3
  0050c	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
  00512	eb 22		 jmp	 SHORT $LN23@JGPGetChar
$LN22@JGPGetChar:

; 744  : 				else index |=(lpCL->dbInventory[16]&0x03);

  00514	b8 01 00 00 00	 mov	 eax, 1
  00519	c1 e0 04	 shl	 eax, 4
  0051c	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  0051f	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  00524	83 e2 03	 and	 edx, 3
  00527	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  0052e	0b c2		 or	 eax, edx
  00530	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
$LN23@JGPGetChar:

; 745  : 				pCList.CharSet[5] = index;

  00536	b8 01 00 00 00	 mov	 eax, 1
  0053b	6b c8 05	 imul	 ecx, eax, 5
  0053e	8a 95 db fe ff
	ff		 mov	 dl, BYTE PTR _index$[ebp]
  00544	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl

; 746  : 
; 747  : 				if( lpCL->dbInventory[4] == 0xFF ) pCList.CharSet[9]  = 0x80;

  0054b	b8 01 00 00 00	 mov	 eax, 1
  00550	c1 e0 02	 shl	 eax, 2
  00553	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00556	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  0055b	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00561	75 10		 jne	 SHORT $LN24@JGPGetChar
  00563	b8 01 00 00 00	 mov	 eax, 1
  00568	6b c8 09	 imul	 ecx, eax, 9
  0056b	c6 84 0d c3 fe
	ff ff 80	 mov	 BYTE PTR _pCList$[ebp+ecx+15], 128 ; 00000080H
$LN24@JGPGetChar:

; 748  : 				if( lpCL->dbInventory[6] == 0xFF ) pCList.CharSet[9] |= 0x40;

  00573	b8 01 00 00 00	 mov	 eax, 1
  00578	6b c8 06	 imul	 ecx, eax, 6
  0057b	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0057e	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00583	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00588	75 22		 jne	 SHORT $LN25@JGPGetChar
  0058a	b8 01 00 00 00	 mov	 eax, 1
  0058f	6b c8 09	 imul	 ecx, eax, 9
  00592	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  0059a	83 ca 40	 or	 edx, 64			; 00000040H
  0059d	b8 01 00 00 00	 mov	 eax, 1
  005a2	6b c8 09	 imul	 ecx, eax, 9
  005a5	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN25@JGPGetChar:

; 749  : 				if( lpCL->dbInventory[8] == 0xFF ) pCList.CharSet[9] |= 0x20;

  005ac	b8 01 00 00 00	 mov	 eax, 1
  005b1	c1 e0 03	 shl	 eax, 3
  005b4	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  005b7	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  005bc	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  005c2	75 22		 jne	 SHORT $LN26@JGPGetChar
  005c4	b8 01 00 00 00	 mov	 eax, 1
  005c9	6b c8 09	 imul	 ecx, eax, 9
  005cc	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  005d4	83 ca 20	 or	 edx, 32			; 00000020H
  005d7	b8 01 00 00 00	 mov	 eax, 1
  005dc	6b c8 09	 imul	 ecx, eax, 9
  005df	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN26@JGPGetChar:

; 750  : 				if( lpCL->dbInventory[10] == 0xFF ) pCList.CharSet[9] |= 0x10;

  005e6	b8 01 00 00 00	 mov	 eax, 1
  005eb	6b c8 0a	 imul	 ecx, eax, 10
  005ee	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  005f1	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  005f6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  005fb	75 22		 jne	 SHORT $LN27@JGPGetChar
  005fd	b8 01 00 00 00	 mov	 eax, 1
  00602	6b c8 09	 imul	 ecx, eax, 9
  00605	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  0060d	83 ca 10	 or	 edx, 16			; 00000010H
  00610	b8 01 00 00 00	 mov	 eax, 1
  00615	6b c8 09	 imul	 ecx, eax, 9
  00618	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN27@JGPGetChar:

; 751  : 				if( lpCL->dbInventory[12] == 0xFF ) pCList.CharSet[9] |= 0x08;

  0061f	b8 01 00 00 00	 mov	 eax, 1
  00624	6b c8 0c	 imul	 ecx, eax, 12
  00627	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0062a	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  0062f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00634	75 22		 jne	 SHORT $LN28@JGPGetChar
  00636	b8 01 00 00 00	 mov	 eax, 1
  0063b	6b c8 09	 imul	 ecx, eax, 9
  0063e	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  00646	83 ca 08	 or	 edx, 8
  00649	b8 01 00 00 00	 mov	 eax, 1
  0064e	6b c8 09	 imul	 ecx, eax, 9
  00651	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN28@JGPGetChar:

; 752  : 				//if( lpCL->dbInventory[9] == 0xFF ) pCList.CharSet[9] |= 0x80;
; 753  : 
; 754  : 				int levelindex;
; 755  : 				
; 756  : 				levelindex  = ((int)LevelSmallConvert((lpCL->dbInventory[1]>>3)&0xF));

  00658	b8 01 00 00 00	 mov	 eax, 1
  0065d	c1 e0 00	 shl	 eax, 0
  00660	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00663	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  00668	c1 fa 03	 sar	 edx, 3
  0066b	83 e2 0f	 and	 edx, 15			; 0000000fH
  0066e	52		 push	 edx
  0066f	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00674	83 c4 04	 add	 esp, 4
  00677	0f b6 c0	 movzx	 eax, al
  0067a	89 85 9c fe ff
	ff		 mov	 DWORD PTR _levelindex$3[ebp], eax

; 757  : 				levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[3]>>3)&0xF))<<3);

  00680	b8 01 00 00 00	 mov	 eax, 1
  00685	6b c8 03	 imul	 ecx, eax, 3
  00688	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0068b	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00690	c1 f8 03	 sar	 eax, 3
  00693	83 e0 0f	 and	 eax, 15			; 0000000fH
  00696	50		 push	 eax
  00697	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  0069c	83 c4 04	 add	 esp, 4
  0069f	0f b6 c8	 movzx	 ecx, al
  006a2	c1 e1 03	 shl	 ecx, 3
  006a5	0b 8d 9c fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$3[ebp]
  006ab	89 8d 9c fe ff
	ff		 mov	 DWORD PTR _levelindex$3[ebp], ecx

; 758  : 				levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[5]>>3)&0xF))<<6);

  006b1	b8 01 00 00 00	 mov	 eax, 1
  006b6	6b c8 05	 imul	 ecx, eax, 5
  006b9	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  006bc	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  006c1	c1 f8 03	 sar	 eax, 3
  006c4	83 e0 0f	 and	 eax, 15			; 0000000fH
  006c7	50		 push	 eax
  006c8	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  006cd	83 c4 04	 add	 esp, 4
  006d0	0f b6 c8	 movzx	 ecx, al
  006d3	c1 e1 06	 shl	 ecx, 6
  006d6	0b 8d 9c fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$3[ebp]
  006dc	89 8d 9c fe ff
	ff		 mov	 DWORD PTR _levelindex$3[ebp], ecx

; 759  : 				levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[7]>>3)&0xF))<<9);

  006e2	b8 01 00 00 00	 mov	 eax, 1
  006e7	6b c8 07	 imul	 ecx, eax, 7
  006ea	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  006ed	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  006f2	c1 f8 03	 sar	 eax, 3
  006f5	83 e0 0f	 and	 eax, 15			; 0000000fH
  006f8	50		 push	 eax
  006f9	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  006fe	83 c4 04	 add	 esp, 4
  00701	0f b6 c8	 movzx	 ecx, al
  00704	c1 e1 09	 shl	 ecx, 9
  00707	0b 8d 9c fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$3[ebp]
  0070d	89 8d 9c fe ff
	ff		 mov	 DWORD PTR _levelindex$3[ebp], ecx

; 760  : 				levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[9]>>3)&0xF))<<12);

  00713	b8 01 00 00 00	 mov	 eax, 1
  00718	6b c8 09	 imul	 ecx, eax, 9
  0071b	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0071e	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00723	c1 f8 03	 sar	 eax, 3
  00726	83 e0 0f	 and	 eax, 15			; 0000000fH
  00729	50		 push	 eax
  0072a	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  0072f	83 c4 04	 add	 esp, 4
  00732	0f b6 c8	 movzx	 ecx, al
  00735	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00738	0b 8d 9c fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$3[ebp]
  0073e	89 8d 9c fe ff
	ff		 mov	 DWORD PTR _levelindex$3[ebp], ecx

; 761  : 				levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[11]>>3)&0xF))<<15);

  00744	b8 01 00 00 00	 mov	 eax, 1
  00749	6b c8 0b	 imul	 ecx, eax, 11
  0074c	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0074f	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00754	c1 f8 03	 sar	 eax, 3
  00757	83 e0 0f	 and	 eax, 15			; 0000000fH
  0075a	50		 push	 eax
  0075b	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00760	83 c4 04	 add	 esp, 4
  00763	0f b6 c8	 movzx	 ecx, al
  00766	c1 e1 0f	 shl	 ecx, 15			; 0000000fH
  00769	0b 8d 9c fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$3[ebp]
  0076f	89 8d 9c fe ff
	ff		 mov	 DWORD PTR _levelindex$3[ebp], ecx

; 762  : 				levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[13]>>3)&0xF))<<18);

  00775	b8 01 00 00 00	 mov	 eax, 1
  0077a	6b c8 0d	 imul	 ecx, eax, 13
  0077d	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00780	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00785	c1 f8 03	 sar	 eax, 3
  00788	83 e0 0f	 and	 eax, 15			; 0000000fH
  0078b	50		 push	 eax
  0078c	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00791	83 c4 04	 add	 esp, 4
  00794	0f b6 c8	 movzx	 ecx, al
  00797	c1 e1 12	 shl	 ecx, 18			; 00000012H
  0079a	0b 8d 9c fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$3[ebp]
  007a0	89 8d 9c fe ff
	ff		 mov	 DWORD PTR _levelindex$3[ebp], ecx

; 763  : 				
; 764  : 				pCList.CharSet[6] = (BYTE)((levelindex>>16)&255);

  007a6	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _levelindex$3[ebp]
  007ac	c1 f8 10	 sar	 eax, 16			; 00000010H
  007af	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007b4	b9 01 00 00 00	 mov	 ecx, 1
  007b9	6b d1 06	 imul	 edx, ecx, 6
  007bc	88 84 15 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+edx+15], al

; 765  : 				pCList.CharSet[7] = (BYTE)((levelindex>> 8)&255);

  007c3	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _levelindex$3[ebp]
  007c9	c1 f8 08	 sar	 eax, 8
  007cc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007d1	b9 01 00 00 00	 mov	 ecx, 1
  007d6	6b d1 07	 imul	 edx, ecx, 7
  007d9	88 84 15 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+edx+15], al

; 766  : 				pCList.CharSet[8] = (BYTE)((levelindex    )&255);

  007e0	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _levelindex$3[ebp]
  007e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007eb	b9 01 00 00 00	 mov	 ecx, 1
  007f0	c1 e1 03	 shl	 ecx, 3
  007f3	88 84 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], al

; 767  : 				//pCList.CharSet[9] = 0;
; 768  : 				pCList.CharSet[10]= 0;

  007fa	b8 01 00 00 00	 mov	 eax, 1
  007ff	6b c8 0a	 imul	 ecx, eax, 10
  00802	c6 84 0d c3 fe
	ff ff 00	 mov	 BYTE PTR _pCList$[ebp+ecx+15], 0

; 769  : #ifdef DARKLORD_WORK
; 770  : 				pCList.CharSet[11]= 0;

  0080a	b8 01 00 00 00	 mov	 eax, 1
  0080f	6b c8 0b	 imul	 ecx, eax, 11
  00812	c6 84 0d c3 fe
	ff ff 00	 mov	 BYTE PTR _pCList$[ebp+ecx+15], 0

; 771  : #endif
; 772  : 
; 773  : #ifdef DARKLORD_WORK	
; 774  : #ifndef ITEM_INDEX_EXTEND_20050706
; 775  : 				pCList.CharSet[12]= 0;

  0081a	b8 01 00 00 00	 mov	 eax, 1
  0081f	6b c8 0c	 imul	 ecx, eax, 12
  00822	c6 84 0d c3 fe
	ff ff 00	 mov	 BYTE PTR _pCList$[ebp+ecx+15], 0

; 776  : #endif
; 777  : #endif
; 778  : 
; 779  : #ifdef ITEM_INDEX_EXTEND_20050706
; 780  : 				// 아이템 유무에 따라서 케릭터 뷰에 추가된 비트들을 셋한다.
; 781  : 
; 782  : 				// 오른손 무기
; 783  : //				if( lpCL->dbInventory[0] == 0xFF )	pCList.CharSet[12] |= 0xF0;
; 784  : 				// 왼손 무기
; 785  : //				if( lpCL->dbInventory[2] == 0xFF )	pCList.CharSet[13] |= 0xF0;
; 786  : 				// 헬멧
; 787  : 				if( lpCL->dbInventory[4] == 0xFF )	pCList.CharSet[13] |= 0x0F;
; 788  : 				// 갑옷
; 789  : 				if( lpCL->dbInventory[8] == 0xFF )	pCList.CharSet[14] |= 0xF0;
; 790  : 				// 바지
; 791  : 				if( lpCL->dbInventory[10] == 0xFF )	pCList.CharSet[14] |= 0x0F;
; 792  : 				// 장갑
; 793  : 				if( lpCL->dbInventory[12] == 0xFF )	pCList.CharSet[15] |= 0xF0;
; 794  : 				// 부츠
; 795  : 				if( lpCL->dbInventory[14] == 0xFF )	pCList.CharSet[15] |= 0x0F;
; 796  : 
; 797  : 				// 예비 바이트 셋
; 798  : 				pCList.CharSet[16] = 0;
; 799  : 				pCList.CharSet[17] = 0;
; 800  : #endif
; 801  : 			}

  0082a	e9 7e 0a 00 00	 jmp	 $LN9@JGPGetChar
$LN8@JGPGetChar:

; 802  : 
; 803  : 			//---------------------------------------------------------------------------------
; 804  : 			//
; 805  : 			//  [] DB Version - 0x01, 0x02
; 806  : 			//
; 807  : 			//	   Check Date - 20051117
; 808  : 			// 	
; 809  : 			//---------------------------------------------------------------------------------
; 810  : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 811  : 			else if (lpCL->DbVersion <= 0x02)
; 812  : #else
; 813  : 			else
; 814  : #endif
; 815  : 			{
; 816  : #ifdef ITEM_INDEX_EXTEND_20050706
; 817  : 				// 오른손 무기
; 818  : 				if (lpCL->dbInventory[0] != 0xFF)
; 819  : 					TempInventory[0] = (lpCL->dbInventory[0]/32)*MAX_ITEM_INDEX+(lpCL->dbInventory[0]%32);
; 820  : 				else
; 821  : 					TempInventory[0] = 0xFFFF;
; 822  : 				// 왼손 무기
; 823  : 				if (lpCL->dbInventory[3] != 0xFF)
; 824  : 					TempInventory[1] = (lpCL->dbInventory[3]/32)*MAX_ITEM_INDEX+(lpCL->dbInventory[3]%32);
; 825  : 				else
; 826  : 					TempInventory[1] = 0xFFFF;
; 827  : #else
; 828  : 				TempInventory[0] = lpCL->dbInventory[0];

  0082f	b8 01 00 00 00	 mov	 eax, 1
  00834	6b c8 00	 imul	 ecx, eax, 0
  00837	ba 01 00 00 00	 mov	 edx, 1
  0083c	6b c2 00	 imul	 eax, edx, 0
  0083f	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00842	8a 4c 0a 10	 mov	 cl, BYTE PTR [edx+ecx+16]
  00846	88 8c 05 a8 fe
	ff ff		 mov	 BYTE PTR _TempInventory$[ebp+eax], cl

; 829  : 				TempInventory[1] = lpCL->dbInventory[3];

  0084d	b8 01 00 00 00	 mov	 eax, 1
  00852	6b c8 03	 imul	 ecx, eax, 3
  00855	ba 01 00 00 00	 mov	 edx, 1
  0085a	c1 e2 00	 shl	 edx, 0
  0085d	8b 45 f4	 mov	 eax, DWORD PTR _lpCL$[ebp]
  00860	8a 4c 08 10	 mov	 cl, BYTE PTR [eax+ecx+16]
  00864	88 8c 15 a8 fe
	ff ff		 mov	 BYTE PTR _TempInventory$[ebp+edx], cl

; 830  : #endif
; 831  : 
; 832  : 				if( lpCL->dbInventory[6] == 255 && ((lpCL->dbInventory[8]&0x80)==0x80) )

  0086b	b8 01 00 00 00	 mov	 eax, 1
  00870	6b c8 06	 imul	 ecx, eax, 6
  00873	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00876	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  0087b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00880	75 29		 jne	 SHORT $LN29@JGPGetChar
  00882	b8 01 00 00 00	 mov	 eax, 1
  00887	c1 e0 03	 shl	 eax, 3
  0088a	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  0088d	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  00892	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00898	74 11		 je	 SHORT $LN29@JGPGetChar

; 833  : 					TempInventory[2] = 0xFFFF;

  0089a	b8 01 00 00 00	 mov	 eax, 1
  0089f	d1 e0		 shl	 eax, 1
  008a1	c6 84 05 a8 fe
	ff ff ff	 mov	 BYTE PTR _TempInventory$[ebp+eax], 255 ; 000000ffH
  008a9	eb 42		 jmp	 SHORT $LN30@JGPGetChar
$LN29@JGPGetChar:

; 834  : 				else TempInventory[2] = MAKE_ITEMNUM_32(lpCL->dbInventory[6], lpCL->dbInventory[8]);

  008ab	b8 01 00 00 00	 mov	 eax, 1
  008b0	6b c8 06	 imul	 ecx, eax, 6
  008b3	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  008b6	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  008bb	b9 01 00 00 00	 mov	 ecx, 1
  008c0	c1 e1 03	 shl	 ecx, 3
  008c3	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  008c6	0f b6 4c 0a 10	 movzx	 ecx, BYTE PTR [edx+ecx+16]
  008cb	c1 f9 07	 sar	 ecx, 7
  008ce	c1 e1 08	 shl	 ecx, 8
  008d1	03 c1		 add	 eax, ecx
  008d3	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  008d8	79 05		 jns	 SHORT $LN74@JGPGetChar
  008da	48		 dec	 eax
  008db	83 c8 e0	 or	 eax, -32		; ffffffe0H
  008de	40		 inc	 eax
$LN74@JGPGetChar:
  008df	ba 01 00 00 00	 mov	 edx, 1
  008e4	d1 e2		 shl	 edx, 1
  008e6	88 84 15 a8 fe
	ff ff		 mov	 BYTE PTR _TempInventory$[ebp+edx], al
$LN30@JGPGetChar:

; 835  : 				
; 836  : 				if( lpCL->dbInventory[9] == 255 && ((lpCL->dbInventory[11]&0x80)==0x80) )

  008ed	b8 01 00 00 00	 mov	 eax, 1
  008f2	6b c8 09	 imul	 ecx, eax, 9
  008f5	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  008f8	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  008fd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00902	75 29		 jne	 SHORT $LN31@JGPGetChar
  00904	b8 01 00 00 00	 mov	 eax, 1
  00909	6b c8 0b	 imul	 ecx, eax, 11
  0090c	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0090f	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00914	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00919	74 12		 je	 SHORT $LN31@JGPGetChar

; 837  : 					TempInventory[3] = 0xFFFF;

  0091b	b8 01 00 00 00	 mov	 eax, 1
  00920	6b c8 03	 imul	 ecx, eax, 3
  00923	c6 84 0d a8 fe
	ff ff ff	 mov	 BYTE PTR _TempInventory$[ebp+ecx], 255 ; 000000ffH
  0092b	eb 43		 jmp	 SHORT $LN32@JGPGetChar
$LN31@JGPGetChar:

; 838  : 				else TempInventory[3] = MAKE_ITEMNUM_32(lpCL->dbInventory[9], lpCL->dbInventory[11]);

  0092d	b8 01 00 00 00	 mov	 eax, 1
  00932	6b c8 09	 imul	 ecx, eax, 9
  00935	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00938	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  0093d	b9 01 00 00 00	 mov	 ecx, 1
  00942	6b d1 0b	 imul	 edx, ecx, 11
  00945	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00948	0f b6 54 11 10	 movzx	 edx, BYTE PTR [ecx+edx+16]
  0094d	c1 fa 07	 sar	 edx, 7
  00950	c1 e2 08	 shl	 edx, 8
  00953	03 c2		 add	 eax, edx
  00955	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0095a	79 05		 jns	 SHORT $LN75@JGPGetChar
  0095c	48		 dec	 eax
  0095d	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00960	40		 inc	 eax
$LN75@JGPGetChar:
  00961	b9 01 00 00 00	 mov	 ecx, 1
  00966	6b d1 03	 imul	 edx, ecx, 3
  00969	88 84 15 a8 fe
	ff ff		 mov	 BYTE PTR _TempInventory$[ebp+edx], al
$LN32@JGPGetChar:

; 839  : 				
; 840  : 				if( lpCL->dbInventory[12] == 255 && ((lpCL->dbInventory[14]&0x80)==0x80) )

  00970	b8 01 00 00 00	 mov	 eax, 1
  00975	6b c8 0c	 imul	 ecx, eax, 12
  00978	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  0097b	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00980	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00985	75 29		 jne	 SHORT $LN33@JGPGetChar
  00987	b8 01 00 00 00	 mov	 eax, 1
  0098c	6b c8 0e	 imul	 ecx, eax, 14
  0098f	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00992	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00997	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0099c	74 12		 je	 SHORT $LN33@JGPGetChar

; 841  : 					TempInventory[4] = 31;

  0099e	b8 01 00 00 00	 mov	 eax, 1
  009a3	c1 e0 02	 shl	 eax, 2
  009a6	c6 84 05 a8 fe
	ff ff 1f	 mov	 BYTE PTR _TempInventory$[ebp+eax], 31 ; 0000001fH
  009ae	eb 43		 jmp	 SHORT $LN34@JGPGetChar
$LN33@JGPGetChar:

; 842  : 				else TempInventory[4] = MAKE_ITEMNUM_32(lpCL->dbInventory[12], lpCL->dbInventory[14]);

  009b0	b8 01 00 00 00	 mov	 eax, 1
  009b5	6b c8 0c	 imul	 ecx, eax, 12
  009b8	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  009bb	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  009c0	b9 01 00 00 00	 mov	 ecx, 1
  009c5	6b d1 0e	 imul	 edx, ecx, 14
  009c8	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  009cb	0f b6 54 11 10	 movzx	 edx, BYTE PTR [ecx+edx+16]
  009d0	c1 fa 07	 sar	 edx, 7
  009d3	c1 e2 08	 shl	 edx, 8
  009d6	03 c2		 add	 eax, edx
  009d8	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  009dd	79 05		 jns	 SHORT $LN76@JGPGetChar
  009df	48		 dec	 eax
  009e0	83 c8 e0	 or	 eax, -32		; ffffffe0H
  009e3	40		 inc	 eax
$LN76@JGPGetChar:
  009e4	b9 01 00 00 00	 mov	 ecx, 1
  009e9	c1 e1 02	 shl	 ecx, 2
  009ec	88 84 0d a8 fe
	ff ff		 mov	 BYTE PTR _TempInventory$[ebp+ecx], al
$LN34@JGPGetChar:

; 843  : 				
; 844  : 				if( lpCL->dbInventory[15] == 255 && ((lpCL->dbInventory[17]&0x80)==0x80) )

  009f3	b8 01 00 00 00	 mov	 eax, 1
  009f8	6b c8 0f	 imul	 ecx, eax, 15
  009fb	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  009fe	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00a03	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00a08	75 29		 jne	 SHORT $LN35@JGPGetChar
  00a0a	b8 01 00 00 00	 mov	 eax, 1
  00a0f	6b c8 11	 imul	 ecx, eax, 17
  00a12	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00a15	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00a1a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00a1f	74 12		 je	 SHORT $LN35@JGPGetChar

; 845  : 					TempInventory[5] = 31;

  00a21	b8 01 00 00 00	 mov	 eax, 1
  00a26	6b c8 05	 imul	 ecx, eax, 5
  00a29	c6 84 0d a8 fe
	ff ff 1f	 mov	 BYTE PTR _TempInventory$[ebp+ecx], 31 ; 0000001fH
  00a31	eb 43		 jmp	 SHORT $LN36@JGPGetChar
$LN35@JGPGetChar:

; 846  : 				else TempInventory[5] = MAKE_ITEMNUM_32(lpCL->dbInventory[15], lpCL->dbInventory[17]);

  00a33	b8 01 00 00 00	 mov	 eax, 1
  00a38	6b c8 0f	 imul	 ecx, eax, 15
  00a3b	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00a3e	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00a43	b9 01 00 00 00	 mov	 ecx, 1
  00a48	6b d1 11	 imul	 edx, ecx, 17
  00a4b	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00a4e	0f b6 54 11 10	 movzx	 edx, BYTE PTR [ecx+edx+16]
  00a53	c1 fa 07	 sar	 edx, 7
  00a56	c1 e2 08	 shl	 edx, 8
  00a59	03 c2		 add	 eax, edx
  00a5b	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00a60	79 05		 jns	 SHORT $LN77@JGPGetChar
  00a62	48		 dec	 eax
  00a63	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00a66	40		 inc	 eax
$LN77@JGPGetChar:
  00a67	b9 01 00 00 00	 mov	 ecx, 1
  00a6c	6b d1 05	 imul	 edx, ecx, 5
  00a6f	88 84 15 a8 fe
	ff ff		 mov	 BYTE PTR _TempInventory$[ebp+edx], al
$LN36@JGPGetChar:

; 847  : 
; 848  : 				if( lpCL->dbInventory[18] == 255 && ((lpCL->dbInventory[20]&0x80)==0x80) )

  00a76	b8 01 00 00 00	 mov	 eax, 1
  00a7b	6b c8 12	 imul	 ecx, eax, 18
  00a7e	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00a81	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00a86	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00a8b	75 29		 jne	 SHORT $LN37@JGPGetChar
  00a8d	b8 01 00 00 00	 mov	 eax, 1
  00a92	6b c8 14	 imul	 ecx, eax, 20
  00a95	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00a98	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00a9d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00aa2	74 12		 je	 SHORT $LN37@JGPGetChar

; 849  : 					TempInventory[6] = 31;

  00aa4	b8 01 00 00 00	 mov	 eax, 1
  00aa9	6b c8 06	 imul	 ecx, eax, 6
  00aac	c6 84 0d a8 fe
	ff ff 1f	 mov	 BYTE PTR _TempInventory$[ebp+ecx], 31 ; 0000001fH
  00ab4	eb 43		 jmp	 SHORT $LN38@JGPGetChar
$LN37@JGPGetChar:

; 850  : 				else TempInventory[6] = MAKE_ITEMNUM_32(lpCL->dbInventory[18], lpCL->dbInventory[20]);

  00ab6	b8 01 00 00 00	 mov	 eax, 1
  00abb	6b c8 12	 imul	 ecx, eax, 18
  00abe	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00ac1	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00ac6	b9 01 00 00 00	 mov	 ecx, 1
  00acb	6b d1 14	 imul	 edx, ecx, 20
  00ace	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00ad1	0f b6 54 11 10	 movzx	 edx, BYTE PTR [ecx+edx+16]
  00ad6	c1 fa 07	 sar	 edx, 7
  00ad9	c1 e2 08	 shl	 edx, 8
  00adc	03 c2		 add	 eax, edx
  00ade	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00ae3	79 05		 jns	 SHORT $LN78@JGPGetChar
  00ae5	48		 dec	 eax
  00ae6	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00ae9	40		 inc	 eax
$LN78@JGPGetChar:
  00aea	b9 01 00 00 00	 mov	 ecx, 1
  00aef	6b d1 06	 imul	 edx, ecx, 6
  00af2	88 84 15 a8 fe
	ff ff		 mov	 BYTE PTR _TempInventory$[ebp+edx], al
$LN38@JGPGetChar:

; 851  : 
; 852  : 				if( lpCL->dbInventory[21] == 255 && ((lpCL->dbInventory[23]&0x80)==0x80) )

  00af9	b8 01 00 00 00	 mov	 eax, 1
  00afe	6b c8 15	 imul	 ecx, eax, 21
  00b01	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00b04	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00b09	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00b0e	75 29		 jne	 SHORT $LN39@JGPGetChar
  00b10	b8 01 00 00 00	 mov	 eax, 1
  00b15	6b c8 17	 imul	 ecx, eax, 23
  00b18	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00b1b	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00b20	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00b25	74 12		 je	 SHORT $LN39@JGPGetChar

; 853  : 					TempInventory[7] = 31;

  00b27	b8 01 00 00 00	 mov	 eax, 1
  00b2c	6b c8 07	 imul	 ecx, eax, 7
  00b2f	c6 84 0d a8 fe
	ff ff 1f	 mov	 BYTE PTR _TempInventory$[ebp+ecx], 31 ; 0000001fH
  00b37	eb 43		 jmp	 SHORT $LN40@JGPGetChar
$LN39@JGPGetChar:

; 854  : 				else TempInventory[7] = MAKE_ITEMNUM_32(lpCL->dbInventory[21], lpCL->dbInventory[23]);

  00b39	b8 01 00 00 00	 mov	 eax, 1
  00b3e	6b c8 15	 imul	 ecx, eax, 21
  00b41	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00b44	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00b49	b9 01 00 00 00	 mov	 ecx, 1
  00b4e	6b d1 17	 imul	 edx, ecx, 23
  00b51	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00b54	0f b6 54 11 10	 movzx	 edx, BYTE PTR [ecx+edx+16]
  00b59	c1 fa 07	 sar	 edx, 7
  00b5c	c1 e2 08	 shl	 edx, 8
  00b5f	03 c2		 add	 eax, edx
  00b61	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00b66	79 05		 jns	 SHORT $LN79@JGPGetChar
  00b68	48		 dec	 eax
  00b69	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00b6c	40		 inc	 eax
$LN79@JGPGetChar:
  00b6d	b9 01 00 00 00	 mov	 ecx, 1
  00b72	6b d1 07	 imul	 edx, ecx, 7
  00b75	88 84 15 a8 fe
	ff ff		 mov	 BYTE PTR _TempInventory$[ebp+edx], al
$LN40@JGPGetChar:

; 855  : 
; 856  : 				if( lpCL->dbInventory[24] == 255 && ((lpCL->dbInventory[26]&0x80)==0x80) )

  00b7c	b8 01 00 00 00	 mov	 eax, 1
  00b81	6b c8 18	 imul	 ecx, eax, 24
  00b84	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00b87	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00b8c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00b91	75 29		 jne	 SHORT $LN41@JGPGetChar
  00b93	b8 01 00 00 00	 mov	 eax, 1
  00b98	6b c8 1a	 imul	 ecx, eax, 26
  00b9b	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00b9e	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00ba3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00ba8	74 12		 je	 SHORT $LN41@JGPGetChar

; 857  : 					TempInventory[8] = 31;

  00baa	b8 01 00 00 00	 mov	 eax, 1
  00baf	c1 e0 03	 shl	 eax, 3
  00bb2	c6 84 05 a8 fe
	ff ff 1f	 mov	 BYTE PTR _TempInventory$[ebp+eax], 31 ; 0000001fH
  00bba	eb 43		 jmp	 SHORT $LN42@JGPGetChar
$LN41@JGPGetChar:

; 858  : 				else TempInventory[8] = MAKE_ITEMNUM_32(lpCL->dbInventory[24], lpCL->dbInventory[26]);

  00bbc	b8 01 00 00 00	 mov	 eax, 1
  00bc1	6b c8 18	 imul	 ecx, eax, 24
  00bc4	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00bc7	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00bcc	b9 01 00 00 00	 mov	 ecx, 1
  00bd1	6b d1 1a	 imul	 edx, ecx, 26
  00bd4	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00bd7	0f b6 54 11 10	 movzx	 edx, BYTE PTR [ecx+edx+16]
  00bdc	c1 fa 07	 sar	 edx, 7
  00bdf	c1 e2 08	 shl	 edx, 8
  00be2	03 c2		 add	 eax, edx
  00be4	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00be9	79 05		 jns	 SHORT $LN80@JGPGetChar
  00beb	48		 dec	 eax
  00bec	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00bef	40		 inc	 eax
$LN80@JGPGetChar:
  00bf0	b9 01 00 00 00	 mov	 ecx, 1
  00bf5	c1 e1 03	 shl	 ecx, 3
  00bf8	88 84 0d a8 fe
	ff ff		 mov	 BYTE PTR _TempInventory$[ebp+ecx], al
$LN42@JGPGetChar:

; 859  : 												
; 860  : #ifdef ITEM_INDEX_EXTEND_20050706
; 861  : 				// 오른손 무기
; 862  : 				if (TempInventory[0] != 0xFFFF) {
; 863  : 					pCList.CharSet[1] = (BYTE) TempInventory[0];
; 864  : 					pCList.CharSet[12] |= (BYTE) ((TempInventory[0]&0x0F00) >> 4);
; 865  : 				}
; 866  : 				else {
; 867  : 					pCList.CharSet[1] = 0xFF;
; 868  : 					pCList.CharSet[12] |= 0xF0;
; 869  : 				}
; 870  : 				// 왼손 무기
; 871  : 				if (TempInventory[1] != 0xFFFF) {
; 872  : 					pCList.CharSet[2] = (BYTE) TempInventory[1];
; 873  : 					pCList.CharSet[13] |= (BYTE) ((TempInventory[1]&0x0F00) >> 4);
; 874  : 				}
; 875  : 				else {
; 876  : 					pCList.CharSet[2] = 0xFF;
; 877  : 					pCList.CharSet[13] |= 0xF0;
; 878  : 				}
; 879  : #else
; 880  : 				pCList.CharSet[1] = (BYTE) TempInventory[0];

  00bff	b8 01 00 00 00	 mov	 eax, 1
  00c04	6b c8 00	 imul	 ecx, eax, 0
  00c07	ba 01 00 00 00	 mov	 edx, 1
  00c0c	c1 e2 00	 shl	 edx, 0
  00c0f	8a 84 0d a8 fe
	ff ff		 mov	 al, BYTE PTR _TempInventory$[ebp+ecx]
  00c16	88 84 15 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+edx+15], al

; 881  : 				pCList.CharSet[2] = (BYTE) TempInventory[1];

  00c1d	b8 01 00 00 00	 mov	 eax, 1
  00c22	c1 e0 00	 shl	 eax, 0
  00c25	b9 01 00 00 00	 mov	 ecx, 1
  00c2a	d1 e1		 shl	 ecx, 1
  00c2c	8a 94 05 a8 fe
	ff ff		 mov	 dl, BYTE PTR _TempInventory$[ebp+eax]
  00c33	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl

; 882  : #endif
; 883  : 				
; 884  : 				pCList.CharSet[3] = ((TempInventory[2]%16)<<4)+(TempInventory[3]%16);

  00c3a	b8 01 00 00 00	 mov	 eax, 1
  00c3f	d1 e0		 shl	 eax, 1
  00c41	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  00c49	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  00c4f	79 05		 jns	 SHORT $LN81@JGPGetChar
  00c51	49		 dec	 ecx
  00c52	83 c9 f0	 or	 ecx, -16		; fffffff0H
  00c55	41		 inc	 ecx
$LN81@JGPGetChar:
  00c56	c1 e1 04	 shl	 ecx, 4
  00c59	ba 01 00 00 00	 mov	 edx, 1
  00c5e	6b c2 03	 imul	 eax, edx, 3
  00c61	0f b6 94 05 a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+eax]
  00c69	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00c6f	79 05		 jns	 SHORT $LN82@JGPGetChar
  00c71	4a		 dec	 edx
  00c72	83 ca f0	 or	 edx, -16		; fffffff0H
  00c75	42		 inc	 edx
$LN82@JGPGetChar:
  00c76	03 ca		 add	 ecx, edx
  00c78	b8 01 00 00 00	 mov	 eax, 1
  00c7d	6b d0 03	 imul	 edx, eax, 3
  00c80	88 8c 15 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+edx+15], cl

; 885  : 				pCList.CharSet[4] = ((TempInventory[4]%16)<<4)+(TempInventory[5]%16);

  00c87	b8 01 00 00 00	 mov	 eax, 1
  00c8c	c1 e0 02	 shl	 eax, 2
  00c8f	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  00c97	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  00c9d	79 05		 jns	 SHORT $LN83@JGPGetChar
  00c9f	49		 dec	 ecx
  00ca0	83 c9 f0	 or	 ecx, -16		; fffffff0H
  00ca3	41		 inc	 ecx
$LN83@JGPGetChar:
  00ca4	c1 e1 04	 shl	 ecx, 4
  00ca7	ba 01 00 00 00	 mov	 edx, 1
  00cac	6b c2 05	 imul	 eax, edx, 5
  00caf	0f b6 94 05 a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+eax]
  00cb7	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00cbd	79 05		 jns	 SHORT $LN84@JGPGetChar
  00cbf	4a		 dec	 edx
  00cc0	83 ca f0	 or	 edx, -16		; fffffff0H
  00cc3	42		 inc	 edx
$LN84@JGPGetChar:
  00cc4	03 ca		 add	 ecx, edx
  00cc6	b8 01 00 00 00	 mov	 eax, 1
  00ccb	c1 e0 02	 shl	 eax, 2
  00cce	88 8c 05 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+eax+15], cl

; 886  : 				index             = (TempInventory[6]%16)<<4;

  00cd5	b8 01 00 00 00	 mov	 eax, 1
  00cda	6b c8 06	 imul	 ecx, eax, 6
  00cdd	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  00ce5	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00ceb	79 05		 jns	 SHORT $LN85@JGPGetChar
  00ced	4a		 dec	 edx
  00cee	83 ca f0	 or	 edx, -16		; fffffff0H
  00cf1	42		 inc	 edx
$LN85@JGPGetChar:
  00cf2	c1 e2 04	 shl	 edx, 4
  00cf5	88 95 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], dl

; 887  : 				
; 888  : 				// 날개와 헬퍼는 2비트씩
; 889  : 				if( TempInventory[7] == 31 )

  00cfb	b8 01 00 00 00	 mov	 eax, 1
  00d00	6b c8 07	 imul	 ecx, eax, 7
  00d03	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  00d0b	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  00d0e	75 12		 jne	 SHORT $LN43@JGPGetChar

; 890  : 					index |= 0x0C;

  00d10	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  00d17	83 c8 0c	 or	 eax, 12			; 0000000cH
  00d1a	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
  00d20	eb 25		 jmp	 SHORT $LN44@JGPGetChar
$LN43@JGPGetChar:

; 891  : 				else index |=(TempInventory[7]&0x03)<<2;

  00d22	b8 01 00 00 00	 mov	 eax, 1
  00d27	6b c8 07	 imul	 ecx, eax, 7
  00d2a	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  00d32	83 e2 03	 and	 edx, 3
  00d35	c1 e2 02	 shl	 edx, 2
  00d38	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  00d3f	0b c2		 or	 eax, edx
  00d41	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
$LN44@JGPGetChar:

; 892  : 				
; 893  : #ifdef DARKLORD_WORK
; 894  : 				if( !(TempInventory[8]&0x04) )

  00d47	b8 01 00 00 00	 mov	 eax, 1
  00d4c	c1 e0 03	 shl	 eax, 3
  00d4f	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  00d57	83 e1 04	 and	 ecx, 4
  00d5a	75 4b		 jne	 SHORT $LN45@JGPGetChar

; 895  : 				{	// 다크호스가 아니면
; 896  : 					if( TempInventory[8] == 31  )

  00d5c	b8 01 00 00 00	 mov	 eax, 1
  00d61	c1 e0 03	 shl	 eax, 3
  00d64	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  00d6c	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  00d6f	75 12		 jne	 SHORT $LN47@JGPGetChar

; 897  : 					index |= 0x03;

  00d71	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  00d78	83 c8 03	 or	 eax, 3
  00d7b	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
  00d81	eb 22		 jmp	 SHORT $LN48@JGPGetChar
$LN47@JGPGetChar:

; 898  : 					else index |=(TempInventory[8]&0x03);

  00d83	b8 01 00 00 00	 mov	 eax, 1
  00d88	c1 e0 03	 shl	 eax, 3
  00d8b	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  00d93	83 e1 03	 and	 ecx, 3
  00d96	0f b6 95 db fe
	ff ff		 movzx	 edx, BYTE PTR _index$[ebp]
  00d9d	0b d1		 or	 edx, ecx
  00d9f	88 95 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], dl
$LN48@JGPGetChar:

; 899  : 				}

  00da5	eb 10		 jmp	 SHORT $LN46@JGPGetChar
$LN45@JGPGetChar:

; 900  : 				else
; 901  : 				{					
; 902  : 					index |=  0x03;		// 다크호스를 장착하면 수호천사가 안보이게 하기 위해										

  00da7	0f b6 85 db fe
	ff ff		 movzx	 eax, BYTE PTR _index$[ebp]
  00dae	83 c8 03	 or	 eax, 3
  00db1	88 85 db fe ff
	ff		 mov	 BYTE PTR _index$[ebp], al
$LN46@JGPGetChar:

; 903  : 				}
; 904  : #else
; 905  : 				if( TempInventory[8] == 31  )
; 906  : 					index |= 0x03;
; 907  : 				else index |=(TempInventory[8]&0x03);
; 908  : #endif
; 909  : 				
; 910  : 				pCList.CharSet[5] = index;

  00db7	b8 01 00 00 00	 mov	 eax, 1
  00dbc	6b c8 05	 imul	 ecx, eax, 5
  00dbf	8a 95 db fe ff
	ff		 mov	 dl, BYTE PTR _index$[ebp]
  00dc5	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl

; 911  : 				
; 912  : 				int levelindex=0;

  00dcc	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _levelindex$2[ebp], 0

; 913  : 								
; 914  : #ifdef ITEM_INDEX_EXTEND_20050706
; 915  : 				if( TempInventory[0] != 0xFFFF )
; 916  : 					levelindex  = ((int)LevelSmallConvert((lpCL->dbInventory[1]>>3)&0xF));
; 917  : 				if( TempInventory[1] != 0xFFFF )
; 918  : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[4]>>3)&0xF))<<3);
; 919  : #else
; 920  : 				if( TempInventory[0] != 0xFF )

  00dd6	b8 01 00 00 00	 mov	 eax, 1
  00ddb	6b c8 00	 imul	 ecx, eax, 0
  00dde	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  00de6	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00dec	74 28		 je	 SHORT $LN49@JGPGetChar

; 921  : 					levelindex  = ((int)LevelSmallConvert((lpCL->dbInventory[1]>>3)&0xF));

  00dee	b8 01 00 00 00	 mov	 eax, 1
  00df3	c1 e0 00	 shl	 eax, 0
  00df6	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00df9	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  00dfe	c1 fa 03	 sar	 edx, 3
  00e01	83 e2 0f	 and	 edx, 15			; 0000000fH
  00e04	52		 push	 edx
  00e05	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00e0a	83 c4 04	 add	 esp, 4
  00e0d	0f b6 c0	 movzx	 eax, al
  00e10	89 85 98 fe ff
	ff		 mov	 DWORD PTR _levelindex$2[ebp], eax
$LN49@JGPGetChar:

; 922  : 				if( TempInventory[1] != 0xFF )

  00e16	b8 01 00 00 00	 mov	 eax, 1
  00e1b	c1 e0 00	 shl	 eax, 0
  00e1e	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  00e26	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00e2c	74 31		 je	 SHORT $LN50@JGPGetChar

; 923  : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[4]>>3)&0xF))<<3);

  00e2e	b8 01 00 00 00	 mov	 eax, 1
  00e33	c1 e0 02	 shl	 eax, 2
  00e36	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00e39	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  00e3e	c1 fa 03	 sar	 edx, 3
  00e41	83 e2 0f	 and	 edx, 15			; 0000000fH
  00e44	52		 push	 edx
  00e45	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00e4a	83 c4 04	 add	 esp, 4
  00e4d	0f b6 c0	 movzx	 eax, al
  00e50	c1 e0 03	 shl	 eax, 3
  00e53	0b 85 98 fe ff
	ff		 or	 eax, DWORD PTR _levelindex$2[ebp]
  00e59	89 85 98 fe ff
	ff		 mov	 DWORD PTR _levelindex$2[ebp], eax
$LN50@JGPGetChar:

; 924  : #endif
; 925  : 				if( TempInventory[2] < 31 )

  00e5f	b8 01 00 00 00	 mov	 eax, 1
  00e64	d1 e0		 shl	 eax, 1
  00e66	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  00e6e	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  00e71	7d 31		 jge	 SHORT $LN51@JGPGetChar

; 926  : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[7]>>3)&0xF))<<6);

  00e73	b8 01 00 00 00	 mov	 eax, 1
  00e78	6b c8 07	 imul	 ecx, eax, 7
  00e7b	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00e7e	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00e83	c1 f8 03	 sar	 eax, 3
  00e86	83 e0 0f	 and	 eax, 15			; 0000000fH
  00e89	50		 push	 eax
  00e8a	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00e8f	83 c4 04	 add	 esp, 4
  00e92	0f b6 c8	 movzx	 ecx, al
  00e95	c1 e1 06	 shl	 ecx, 6
  00e98	0b 8d 98 fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$2[ebp]
  00e9e	89 8d 98 fe ff
	ff		 mov	 DWORD PTR _levelindex$2[ebp], ecx
$LN51@JGPGetChar:

; 927  : 				if( TempInventory[3] < 31 )

  00ea4	b8 01 00 00 00	 mov	 eax, 1
  00ea9	6b c8 03	 imul	 ecx, eax, 3
  00eac	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  00eb4	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  00eb7	7d 31		 jge	 SHORT $LN52@JGPGetChar

; 928  : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[10]>>3)&0xF))<<9);

  00eb9	b8 01 00 00 00	 mov	 eax, 1
  00ebe	6b c8 0a	 imul	 ecx, eax, 10
  00ec1	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00ec4	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00ec9	c1 f8 03	 sar	 eax, 3
  00ecc	83 e0 0f	 and	 eax, 15			; 0000000fH
  00ecf	50		 push	 eax
  00ed0	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00ed5	83 c4 04	 add	 esp, 4
  00ed8	0f b6 c8	 movzx	 ecx, al
  00edb	c1 e1 09	 shl	 ecx, 9
  00ede	0b 8d 98 fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$2[ebp]
  00ee4	89 8d 98 fe ff
	ff		 mov	 DWORD PTR _levelindex$2[ebp], ecx
$LN52@JGPGetChar:

; 929  : 				if( TempInventory[4] < 31 )

  00eea	b8 01 00 00 00	 mov	 eax, 1
  00eef	c1 e0 02	 shl	 eax, 2
  00ef2	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  00efa	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  00efd	7d 31		 jge	 SHORT $LN53@JGPGetChar

; 930  : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[13]>>3)&0xF))<<12);

  00eff	b8 01 00 00 00	 mov	 eax, 1
  00f04	6b c8 0d	 imul	 ecx, eax, 13
  00f07	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00f0a	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00f0f	c1 f8 03	 sar	 eax, 3
  00f12	83 e0 0f	 and	 eax, 15			; 0000000fH
  00f15	50		 push	 eax
  00f16	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00f1b	83 c4 04	 add	 esp, 4
  00f1e	0f b6 c8	 movzx	 ecx, al
  00f21	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00f24	0b 8d 98 fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$2[ebp]
  00f2a	89 8d 98 fe ff
	ff		 mov	 DWORD PTR _levelindex$2[ebp], ecx
$LN53@JGPGetChar:

; 931  : 				if( TempInventory[5] < 31 )

  00f30	b8 01 00 00 00	 mov	 eax, 1
  00f35	6b c8 05	 imul	 ecx, eax, 5
  00f38	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  00f40	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  00f43	7d 31		 jge	 SHORT $LN54@JGPGetChar

; 932  : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[16]>>3)&0xF))<<15);

  00f45	b8 01 00 00 00	 mov	 eax, 1
  00f4a	c1 e0 04	 shl	 eax, 4
  00f4d	8b 4d f4	 mov	 ecx, DWORD PTR _lpCL$[ebp]
  00f50	0f b6 54 01 10	 movzx	 edx, BYTE PTR [ecx+eax+16]
  00f55	c1 fa 03	 sar	 edx, 3
  00f58	83 e2 0f	 and	 edx, 15			; 0000000fH
  00f5b	52		 push	 edx
  00f5c	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00f61	83 c4 04	 add	 esp, 4
  00f64	0f b6 c0	 movzx	 eax, al
  00f67	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00f6a	0b 85 98 fe ff
	ff		 or	 eax, DWORD PTR _levelindex$2[ebp]
  00f70	89 85 98 fe ff
	ff		 mov	 DWORD PTR _levelindex$2[ebp], eax
$LN54@JGPGetChar:

; 933  : 				if( TempInventory[6] < 31 )

  00f76	b8 01 00 00 00	 mov	 eax, 1
  00f7b	6b c8 06	 imul	 ecx, eax, 6
  00f7e	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  00f86	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  00f89	7d 31		 jge	 SHORT $LN55@JGPGetChar

; 934  : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[19]>>3)&0xF))<<18);

  00f8b	b8 01 00 00 00	 mov	 eax, 1
  00f90	6b c8 13	 imul	 ecx, eax, 19
  00f93	8b 55 f4	 mov	 edx, DWORD PTR _lpCL$[ebp]
  00f96	0f b6 44 0a 10	 movzx	 eax, BYTE PTR [edx+ecx+16]
  00f9b	c1 f8 03	 sar	 eax, 3
  00f9e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00fa1	50		 push	 eax
  00fa2	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00fa7	83 c4 04	 add	 esp, 4
  00faa	0f b6 c8	 movzx	 ecx, al
  00fad	c1 e1 12	 shl	 ecx, 18			; 00000012H
  00fb0	0b 8d 98 fe ff
	ff		 or	 ecx, DWORD PTR _levelindex$2[ebp]
  00fb6	89 8d 98 fe ff
	ff		 mov	 DWORD PTR _levelindex$2[ebp], ecx
$LN55@JGPGetChar:

; 935  : 				
; 936  : 				//levelindex = 0;
; 937  : 				
; 938  : 				pCList.CharSet[6] = (BYTE)((levelindex>>16)&255);

  00fbc	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _levelindex$2[ebp]
  00fc2	c1 f8 10	 sar	 eax, 16			; 00000010H
  00fc5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00fca	b9 01 00 00 00	 mov	 ecx, 1
  00fcf	6b d1 06	 imul	 edx, ecx, 6
  00fd2	88 84 15 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+edx+15], al

; 939  : 				pCList.CharSet[7] = (BYTE)((levelindex>> 8)&255);

  00fd9	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _levelindex$2[ebp]
  00fdf	c1 f8 08	 sar	 eax, 8
  00fe2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00fe7	b9 01 00 00 00	 mov	 ecx, 1
  00fec	6b d1 07	 imul	 edx, ecx, 7
  00fef	88 84 15 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+edx+15], al

; 940  : 				pCList.CharSet[8] = (BYTE)((levelindex    )&255);

  00ff6	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _levelindex$2[ebp]
  00ffc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01001	b9 01 00 00 00	 mov	 ecx, 1
  01006	c1 e1 03	 shl	 ecx, 3
  01009	88 84 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], al

; 941  : 
; 942  : 
; 943  : 				if( TempInventory[2] > 15 ) pCList.CharSet[9]  = 0x80;

  01010	b8 01 00 00 00	 mov	 eax, 1
  01015	d1 e0		 shl	 eax, 1
  01017	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  0101f	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  01022	7e 10		 jle	 SHORT $LN56@JGPGetChar
  01024	b8 01 00 00 00	 mov	 eax, 1
  01029	6b c8 09	 imul	 ecx, eax, 9
  0102c	c6 84 0d c3 fe
	ff ff 80	 mov	 BYTE PTR _pCList$[ebp+ecx+15], 128 ; 00000080H
$LN56@JGPGetChar:

; 944  : 				if( TempInventory[3] > 15 ) pCList.CharSet[9] |= 0x40;

  01034	b8 01 00 00 00	 mov	 eax, 1
  01039	6b c8 03	 imul	 ecx, eax, 3
  0103c	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  01044	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  01047	7e 22		 jle	 SHORT $LN57@JGPGetChar
  01049	b8 01 00 00 00	 mov	 eax, 1
  0104e	6b c8 09	 imul	 ecx, eax, 9
  01051	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  01059	83 ca 40	 or	 edx, 64			; 00000040H
  0105c	b8 01 00 00 00	 mov	 eax, 1
  01061	6b c8 09	 imul	 ecx, eax, 9
  01064	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN57@JGPGetChar:

; 945  : 				if( TempInventory[4] > 15 ) pCList.CharSet[9] |= 0x20;

  0106b	b8 01 00 00 00	 mov	 eax, 1
  01070	c1 e0 02	 shl	 eax, 2
  01073	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  0107b	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  0107e	7e 22		 jle	 SHORT $LN58@JGPGetChar
  01080	b8 01 00 00 00	 mov	 eax, 1
  01085	6b c8 09	 imul	 ecx, eax, 9
  01088	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  01090	83 ca 20	 or	 edx, 32			; 00000020H
  01093	b8 01 00 00 00	 mov	 eax, 1
  01098	6b c8 09	 imul	 ecx, eax, 9
  0109b	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN58@JGPGetChar:

; 946  : 				if( TempInventory[5] > 15 ) pCList.CharSet[9] |= 0x10;

  010a2	b8 01 00 00 00	 mov	 eax, 1
  010a7	6b c8 05	 imul	 ecx, eax, 5
  010aa	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  010b2	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  010b5	7e 22		 jle	 SHORT $LN59@JGPGetChar
  010b7	b8 01 00 00 00	 mov	 eax, 1
  010bc	6b c8 09	 imul	 ecx, eax, 9
  010bf	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  010c7	83 ca 10	 or	 edx, 16			; 00000010H
  010ca	b8 01 00 00 00	 mov	 eax, 1
  010cf	6b c8 09	 imul	 ecx, eax, 9
  010d2	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN59@JGPGetChar:

; 947  : 				if( TempInventory[6] > 15 ) pCList.CharSet[9] |= 0x08;

  010d9	b8 01 00 00 00	 mov	 eax, 1
  010de	6b c8 06	 imul	 ecx, eax, 6
  010e1	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  010e9	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  010ec	7e 22		 jle	 SHORT $LN60@JGPGetChar
  010ee	b8 01 00 00 00	 mov	 eax, 1
  010f3	6b c8 09	 imul	 ecx, eax, 9
  010f6	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  010fe	83 ca 08	 or	 edx, 8
  01101	b8 01 00 00 00	 mov	 eax, 1
  01106	6b c8 09	 imul	 ecx, eax, 9
  01109	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN60@JGPGetChar:

; 948  : 
; 949  : #ifdef NEW_FORSKYLAND2
; 950  : 				// 날개....
; 951  : 	#ifdef DARKLORD_WORK
; 952  : 				if( (TempInventory[7] >= 3 && TempInventory[7] <= 6) || 

  01110	b8 01 00 00 00	 mov	 eax, 1
  01115	6b c8 07	 imul	 ecx, eax, 7
  01118	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  01120	83 fa 03	 cmp	 edx, 3
  01123	7c 15		 jl	 SHORT $LN63@JGPGetChar
  01125	b8 01 00 00 00	 mov	 eax, 1
  0112a	6b c8 07	 imul	 ecx, eax, 7
  0112d	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  01135	83 fa 06	 cmp	 edx, 6
  01138	7e 19		 jle	 SHORT $LN62@JGPGetChar
$LN63@JGPGetChar:
  0113a	b8 01 00 00 00	 mov	 eax, 1
  0113f	6b c8 07	 imul	 ecx, eax, 7
  01142	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  0114a	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  0114d	0f 85 92 00 00
	00		 jne	 $LN61@JGPGetChar
$LN62@JGPGetChar:

; 953  : 					TempInventory[7] == 30 )
; 954  : 	#else
; 955  : 				if( TempInventory[7] >= 3 && TempInventory[7] <= 6)
; 956  : 	#endif	// #ifdef DARKLORD_WORK
; 957  : 				{
; 958  : 					pCList.CharSet[5] |= 0x0C;

  01153	b8 01 00 00 00	 mov	 eax, 1
  01158	6b c8 05	 imul	 ecx, eax, 5
  0115b	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  01163	83 ca 0c	 or	 edx, 12			; 0000000cH
  01166	b8 01 00 00 00	 mov	 eax, 1
  0116b	6b c8 05	 imul	 ecx, eax, 5
  0116e	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl

; 959  : 
; 960  : 	#ifdef DARKLORD_WORK
; 961  : 					if( TempInventory[7] == 30 )

  01175	b8 01 00 00 00	 mov	 eax, 1
  0117a	6b c8 07	 imul	 ecx, eax, 7
  0117d	0f b6 94 0d a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+ecx]
  01185	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  01188	75 24		 jne	 SHORT $LN64@JGPGetChar

; 962  : 						pCList.CharSet[9] |= 0x05;		// 망토 설정(0x07까지 마스킹이 되므로 앞으로 두개 더 쓸수 있음)

  0118a	b8 01 00 00 00	 mov	 eax, 1
  0118f	6b c8 09	 imul	 ecx, eax, 9
  01192	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  0119a	83 ca 05	 or	 edx, 5
  0119d	b8 01 00 00 00	 mov	 eax, 1
  011a2	6b c8 09	 imul	 ecx, eax, 9
  011a5	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
  011ac	eb 37		 jmp	 SHORT $LN61@JGPGetChar
$LN64@JGPGetChar:

; 963  : 					else
; 964  : 	#endif	// #ifdef DARKLORD_WORK
; 965  : 						pCList.CharSet[9] |= ((TempInventory[7]-2)&0x7);

  011ae	b8 01 00 00 00	 mov	 eax, 1
  011b3	6b c8 09	 imul	 ecx, eax, 9
  011b6	ba 01 00 00 00	 mov	 edx, 1
  011bb	6b c2 07	 imul	 eax, edx, 7
  011be	0f b6 94 05 a8
	fe ff ff	 movzx	 edx, BYTE PTR _TempInventory$[ebp+eax]
  011c6	83 ea 02	 sub	 edx, 2
  011c9	83 e2 07	 and	 edx, 7
  011cc	0f b6 84 0d c3
	fe ff ff	 movzx	 eax, BYTE PTR _pCList$[ebp+ecx+15]
  011d4	0b c2		 or	 eax, edx
  011d6	b9 01 00 00 00	 mov	 ecx, 1
  011db	6b d1 09	 imul	 edx, ecx, 9
  011de	88 84 15 c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+edx+15], al
$LN61@JGPGetChar:

; 966  : 				}
; 967  : 	#ifdef ADD_THIRD_WING_20070525	// 캐릭터 정보 보낼 때 3차날개 추가
; 968  : 		#ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 차원의 날개 캐릭터 정보 추가
; 969  : 				if( ( TempInventory[7] >= 36 && TempInventory[7] <= 40 )
; 970  : 					|| TempInventory[7] == 43)	
; 971  : 		#else
; 972  : 				if( TempInventory[7] >= 36 && TempInventory[7] <= 40 )
; 973  : 		#endif
; 974  : 				{
; 975  : 					pCList.CharSet[5] |= 0x0C;
; 976  : 					pCList.CharSet[16] |= ( (( TempInventory[7] - 35 )&0x7 ) << 2 );
; 977  : 		#ifdef MODIFY_SUMMONER_THIRD_WING_BUFGIX_20090109	// 차원의 날개는 0x06으로 보냄
; 978  : 					if(TempInventory[7] == 43)
; 979  : 					{
; 980  : 						pCList.CharSet[16] |= ( (( 0x06 )&0x7 ) << 2 );
; 981  : 					}
; 982  : 		#endif	// MODIFY_SUMMONER_THIRD_WING_BUFGIX_20090109					
; 983  : 				}
; 984  : 	#endif	// ADD_THIRD_WING_20070525
; 985  : #else
; 986  : 	#ifdef NEW_SKILL_FORSKYLAND
; 987  : 				// 페가시아용...
; 988  : 				if( TempInventory[8] & 0x03 && TempInventory[8] != 31 )
; 989  : 				{
; 990  : 					pCList.CharSet[9] |= (BYTE)0x04;
; 991  : 				}
; 992  : 	#endif
; 993  : #endif	
; 994  : 
; 995  : 				pCList.CharSet[10] = 0;

  011e5	b8 01 00 00 00	 mov	 eax, 1
  011ea	6b c8 0a	 imul	 ecx, eax, 10
  011ed	c6 84 0d c3 fe
	ff ff 00	 mov	 BYTE PTR _pCList$[ebp+ecx+15], 0

; 996  : 
; 997  : #ifdef NEW_FORSKYLAND2
; 998  : 				// 페가시아용...
; 999  : 				if( TempInventory[8] & 0x03 && TempInventory[8] != 31 )

  011f5	b8 01 00 00 00	 mov	 eax, 1
  011fa	c1 e0 03	 shl	 eax, 3
  011fd	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  01205	83 e1 03	 and	 ecx, 3
  01208	74 37		 je	 SHORT $LN66@JGPGetChar
  0120a	b8 01 00 00 00	 mov	 eax, 1
  0120f	c1 e0 03	 shl	 eax, 3
  01212	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  0121a	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  0121d	74 22		 je	 SHORT $LN66@JGPGetChar

; 1000 : 				{
; 1001 : 					pCList.CharSet[10] |= (BYTE)0x01;

  0121f	b8 01 00 00 00	 mov	 eax, 1
  01224	6b c8 0a	 imul	 ecx, eax, 10
  01227	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  0122f	83 ca 01	 or	 edx, 1
  01232	b8 01 00 00 00	 mov	 eax, 1
  01237	6b c8 0a	 imul	 ecx, eax, 10
  0123a	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN66@JGPGetChar:

; 1002 : 				}
; 1003 : #endif
; 1004 : 
; 1005 : #ifdef DARKLORD_WORK
; 1006 : 				pCList.CharSet[11]  = 0;

  01241	b8 01 00 00 00	 mov	 eax, 1
  01246	6b c8 0b	 imul	 ecx, eax, 11
  01249	c6 84 0d c3 fe
	ff ff 00	 mov	 BYTE PTR _pCList$[ebp+ecx+15], 0

; 1007 : #endif
; 1008 : 
; 1009 : #ifdef DARKLORD_WORK
; 1010 : #ifndef ITEM_INDEX_EXTEND_20050706
; 1011 : 				pCList.CharSet[12]= 0;

  01251	b8 01 00 00 00	 mov	 eax, 1
  01256	6b c8 0c	 imul	 ecx, eax, 12
  01259	c6 84 0d c3 fe
	ff ff 00	 mov	 BYTE PTR _pCList$[ebp+ecx+15], 0

; 1012 : #endif				
; 1013 : 				if( TempInventory[8] & 0x04 && TempInventory[8] != 31 )

  01261	b8 01 00 00 00	 mov	 eax, 1
  01266	c1 e0 03	 shl	 eax, 3
  01269	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  01271	83 e1 04	 and	 ecx, 4
  01274	74 37		 je	 SHORT $LN9@JGPGetChar
  01276	b8 01 00 00 00	 mov	 eax, 1
  0127b	c1 e0 03	 shl	 eax, 3
  0127e	0f b6 8c 05 a8
	fe ff ff	 movzx	 ecx, BYTE PTR _TempInventory$[ebp+eax]
  01286	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  01289	74 22		 je	 SHORT $LN9@JGPGetChar

; 1014 : 				{	// 다크호스
; 1015 : 					pCList.CharSet[12] |= (BYTE)0x01;

  0128b	b8 01 00 00 00	 mov	 eax, 1
  01290	6b c8 0c	 imul	 ecx, eax, 12
  01293	0f b6 94 0d c3
	fe ff ff	 movzx	 edx, BYTE PTR _pCList$[ebp+ecx+15]
  0129b	83 ca 01	 or	 edx, 1
  0129e	b8 01 00 00 00	 mov	 eax, 1
  012a3	6b c8 0c	 imul	 ecx, eax, 12
  012a6	88 94 0d c3 fe
	ff ff		 mov	 BYTE PTR _pCList$[ebp+ecx+15], dl
$LN9@JGPGetChar:

; 1016 : 				}
; 1017 : #endif
; 1018 : 				/*if( lpObj->pInventory[EQUIPMENT_HELM  ].IsExtItem()) lpObj->CharSet[10] = 0x80;
; 1019 : 				if( lpObj->pInventory[EQUIPMENT_ARMOR ].IsExtItem()) lpObj->CharSet[10] = 0x40;
; 1020 : 				if( lpObj->pInventory[EQUIPMENT_PANTS ].IsExtItem()) lpObj->CharSet[10] = 0x20;
; 1021 : 				if( lpObj->pInventory[EQUIPMENT_GLOVES].IsExtItem()) lpObj->CharSet[10] = 0x10;
; 1022 : 				if( lpObj->pInventory[EQUIPMENT_BOOTS ].IsExtItem()) lpObj->CharSet[10] = 0x08;*/
; 1023 : 
; 1024 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1025 : 				// 아이템 유무에 따라서 케릭터 뷰에 추가된 비트들을 셋한다.
; 1026 : 
; 1027 : 				// 오른손 무기
; 1028 : //				if( TempInventory[0] == 0xFFFF )	pCList.CharSet[12] |= 0xF0;
; 1029 : 				// 왼손 무기
; 1030 : //				if( TempInventory[1] == 0xFFFF )	pCList.CharSet[13] |= 0xF0;
; 1031 : 				// 헬멧
; 1032 : 				if( TempInventory[2] >= 31 )	pCList.CharSet[13] |= 0x0F;
; 1033 : 				// 갑옷
; 1034 : 				if( TempInventory[3] >= 31 )	pCList.CharSet[14] |= 0xF0;
; 1035 : 				// 바지
; 1036 : 				if( TempInventory[4] >= 31 )	pCList.CharSet[14] |= 0x0F;
; 1037 : 				// 장갑
; 1038 : 				if( TempInventory[5] >= 31 )	pCList.CharSet[15] |= 0xF0;
; 1039 : 				// 부츠
; 1040 : 				if( TempInventory[6] >= 31 )	pCList.CharSet[15] |= 0x0F;
; 1041 : 
; 1042 : 				// 예비 바이트 셋
; 1043 : 				pCList.CharSet[16] = 0;
; 1044 : 				pCList.CharSet[17] = 0;
; 1045 : #endif
; 1046 : 
; 1047 : 			}
; 1048 : 
; 1049 : 			//---------------------------------------------------------------------------------
; 1050 : 			//
; 1051 : 			//  [] DB Version - 0x03
; 1052 : 			//
; 1053 : 			//	   Check Date - 20051117
; 1054 : 			// 	
; 1055 : 			//---------------------------------------------------------------------------------
; 1056 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 1057 : 			// !!!. 중요> MAX_PREVIEWCHARSET (클라이언트) 확장 시 한번 더 수정 필요
; 1058 : 			else 
; 1059 : 			{
; 1060 : 				// lpCL->DbVersion > 0x02
; 1061 : 				// 인벤토리 4바이트 마다 아이템 있음
; 1062 : 				// TempInventory -> 아이템 인덱스 생성
; 1063 : 
; 1064 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1065 : 				// 오른손 무기
; 1066 : 				if( lpCL->dbInventory[0] == 255 && ((lpCL->dbInventory[2]&0x80)==0x80) && ((lpCL->dbInventory[3]&0xF0)==0xF0))
; 1067 : 					TempInventory[0] = 0xFFFF;
; 1068 : 				else TempInventory[0] = (lpCL->dbInventory[0]+((lpCL->dbInventory[2]&0x80)<<1)+((lpCL->dbInventory[3]&0xF0)<<5));
; 1069 : 				// 완손 무기
; 1070 : 				if( lpCL->dbInventory[4] == 255 && ((lpCL->dbInventory[6]&0x80)==0x80) && ((lpCL->dbInventory[7]&0xF0)==0xF0))
; 1071 : 					TempInventory[1] = 0xFFFF;
; 1072 : 				else TempInventory[1] = (lpCL->dbInventory[4]+((lpCL->dbInventory[6]&0x80)<<1)+((lpCL->dbInventory[7]&0xF0)<<5));
; 1073 : #else
; 1074 : 				// 오른손 무기
; 1075 : 				TempInventory[0] = lpCL->dbInventory[0];	
; 1076 : 				// 완손 무기
; 1077 : 				TempInventory[1] = lpCL->dbInventory[4];	
; 1078 : #endif
; 1079 : 
; 1080 : 				// 헬멧
; 1081 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1082 : 				if( lpCL->dbInventory[8] == 255 && ((lpCL->dbInventory[10]&0x80)==0x80) && ((lpCL->dbInventory[11]&0xF0)==0xF0))
; 1083 : 					TempInventory[2] = ITEM_INDEX_NOT_EXIST;
; 1084 : 				else TempInventory[2] = MAKE_ITEMNUM_512(lpCL->dbInventory[8], lpCL->dbInventory[10], lpCL->dbInventory[11]);
; 1085 : #else
; 1086 : 				if( lpCL->dbInventory[8] == 255 && ((lpCL->dbInventory[10]&0x80)==0x80))
; 1087 : 					TempInventory[2] = 0xFF;
; 1088 : 				else TempInventory[2] = MAKE_ITEMNUM_32(lpCL->dbInventory[8], lpCL->dbInventory[10]);
; 1089 : #endif
; 1090 : 				
; 1091 : 				// 갑옷
; 1092 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1093 : 				if( lpCL->dbInventory[12] == 255 && ((lpCL->dbInventory[14]&0x80)==0x80) && ((lpCL->dbInventory[15]&0xF0)==0xF0))
; 1094 : 					TempInventory[3] = ITEM_INDEX_NOT_EXIST;
; 1095 : 				else TempInventory[3] = MAKE_ITEMNUM_512(lpCL->dbInventory[12], lpCL->dbInventory[14], lpCL->dbInventory[15]);
; 1096 : #else
; 1097 : 				if( lpCL->dbInventory[12] == 255 && ((lpCL->dbInventory[14]&0x80)==0x80))
; 1098 : 					TempInventory[3] = 0xFF;
; 1099 : 				else TempInventory[3] = MAKE_ITEMNUM_32(lpCL->dbInventory[12], lpCL->dbInventory[14]);
; 1100 : #endif
; 1101 : 				
; 1102 : 				// 바지
; 1103 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1104 : 				if( lpCL->dbInventory[16] == 255 && ((lpCL->dbInventory[18]&0x80)==0x80) && ((lpCL->dbInventory[19]&0xF0)==0xF0)) 
; 1105 : 				{
; 1106 : 					TempInventory[4] = ITEM_INDEX_NOT_EXIST;
; 1107 : 				}
; 1108 : 				else TempInventory[4] = MAKE_ITEMNUM_512(lpCL->dbInventory[16], lpCL->dbInventory[18], lpCL->dbInventory[19]);
; 1109 : #else
; 1110 : 				if( lpCL->dbInventory[16] == 255 && ((lpCL->dbInventory[18]&0x80)==0x80))
; 1111 : 					TempInventory[4] = 31;
; 1112 : 				else TempInventory[4] = MAKE_ITEMNUM_32(lpCL->dbInventory[16], lpCL->dbInventory[18]);
; 1113 : #endif
; 1114 : 				
; 1115 : 				// 장갑
; 1116 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1117 : 				if( lpCL->dbInventory[20] == 255 && ((lpCL->dbInventory[22]&0x80)==0x80) && ((lpCL->dbInventory[23]&0xF0)==0xF0)) {
; 1118 : 					TempInventory[5] = ITEM_INDEX_NOT_EXIST;
; 1119 : 				}
; 1120 : 				else TempInventory[5] = MAKE_ITEMNUM_512(lpCL->dbInventory[20], lpCL->dbInventory[22], lpCL->dbInventory[23]);
; 1121 : #else
; 1122 : 				if( lpCL->dbInventory[20] == 255 && ((lpCL->dbInventory[22]&0x80)==0x80))
; 1123 : 					TempInventory[5] = 31;
; 1124 : 				else TempInventory[5] = MAKE_ITEMNUM_32(lpCL->dbInventory[20], lpCL->dbInventory[22]);
; 1125 : #endif
; 1126 : 
; 1127 : 				// 부츠
; 1128 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1129 : 				if( lpCL->dbInventory[24] == 255 && ((lpCL->dbInventory[26]&0x80)==0x80) && ((lpCL->dbInventory[27]&0xF0)==0xF0)) 
; 1130 : 				{
; 1131 : 					TempInventory[6] = ITEM_INDEX_NOT_EXIST;
; 1132 : 				}
; 1133 : 				else TempInventory[6] = MAKE_ITEMNUM_512(lpCL->dbInventory[24], lpCL->dbInventory[26], lpCL->dbInventory[27]);
; 1134 : #else
; 1135 : 				if( lpCL->dbInventory[24] == 255 && ((lpCL->dbInventory[26]&0x80)==0x80))
; 1136 : 					TempInventory[6] = 31;
; 1137 : 				else TempInventory[6] = MAKE_ITEMNUM_32(lpCL->dbInventory[24], lpCL->dbInventory[26]);
; 1138 : #endif
; 1139 : 
; 1140 : 				// 날개
; 1141 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1142 : 				if( lpCL->dbInventory[28] == 255 && ((lpCL->dbInventory[30]&0x80)==0x80) && ((lpCL->dbInventory[31]&0xF0)==0xF0)) 
; 1143 : 				{
; 1144 : 					TempInventory[7] = ITEM_INDEX_NOT_EXIST;
; 1145 : 				}
; 1146 : 				else TempInventory[7] = MAKE_ITEMNUM_512(lpCL->dbInventory[28], lpCL->dbInventory[30], lpCL->dbInventory[31]);
; 1147 : #else
; 1148 : 				if( lpCL->dbInventory[28] == 255 && ((lpCL->dbInventory[30]&0x80)==0x80))
; 1149 : 					TempInventory[7] = 31;
; 1150 : 				else TempInventory[7] = MAKE_ITEMNUM_32(lpCL->dbInventory[28], lpCL->dbInventory[30]);
; 1151 : #endif
; 1152 : 
; 1153 : 				// 헬퍼 (수호/사탄)
; 1154 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1155 : 				if( lpCL->dbInventory[32] == 255 && ((lpCL->dbInventory[34]&0x80)==0x80) && ((lpCL->dbInventory[35]&0xF0)==0xF0)) 
; 1156 : 				{
; 1157 : 					TempInventory[8] = ITEM_INDEX_NOT_EXIST;
; 1158 : 				}
; 1159 : 				else TempInventory[8] = MAKE_ITEMNUM_512(lpCL->dbInventory[32], lpCL->dbInventory[34], lpCL->dbInventory[35]);
; 1160 : #else
; 1161 : 				if( lpCL->dbInventory[32] == 255 && ((lpCL->dbInventory[34]&0x80)==0x80))
; 1162 : 					TempInventory[8] = 31;
; 1163 : 				else TempInventory[8] = MAKE_ITEMNUM_32(lpCL->dbInventory[32], lpCL->dbInventory[34]);
; 1164 : #endif
; 1165 : 
; 1166 : 				// *> . 목걸이, 반지 (우/좌) 등은 않보이므로 필요없음
; 1167 : 												
; 1168 : #ifdef ITEM_INDEX_EXTEND_20050706	// 기존의 기본 인덱스 + 확장 인덱스 세팅 부분 (아래 확장 인덱스 세팅 제거)
; 1169 : 				// !!! . 인덱스작업 
; 1170 : 				// 이 방식을 적용하면 없는 아이템들의 모든 비트는 알아서 전부 1로 셋된다.
; 1171 : 
; 1172 : 				// !!! . 중요> 무기류는 코드가 4096을 넘을 수 없다는 가정하에 최상위 1비트를 계산하지 않는다.
; 1173 : 
; 1174 : 				// 오른손 무기
; 1175 : 				// 상위 4비트 (4096,2048,1024,512) 저장
; 1176 : 				pCList.CharSet[12] |= (BYTE)((TempInventory[0]&0x0F00)>>4);
; 1177 : 				// 하위 4비트 저장
; 1178 : 				pCList.CharSet[1] = TempInventory[0]%256;
; 1179 : 
; 1180 : 				// 왼손 무기
; 1181 : 				// 상위 4비트 (4096,2048,1024,512) 저장
; 1182 : 				pCList.CharSet[13] |= (BYTE)((TempInventory[1]&0x0F00)>>4);
; 1183 : 				// 하위 4비트 저장
; 1184 : 				pCList.CharSet[2] = TempInventory[1]%256;
; 1185 : 
; 1186 : 				// 헬멧
; 1187 : 				// 상위 4비트 (256,128,64,32) 저장
; 1188 : 				pCList.CharSet[13] |= (BYTE)((TempInventory[2]&0x01E0)>>5);
; 1189 : 				// 상위 5번째 비트 (32) 저장
; 1190 : 				pCList.CharSet[9] |= (BYTE)((TempInventory[2]&0x0010)<<3);
; 1191 : 				// 하위 4비트 저장
; 1192 : 				pCList.CharSet[3] |= (BYTE)((TempInventory[2]&0x000F)<<4);
; 1193 : 
; 1194 : 				// 갑옷
; 1195 : 				// 상위 4비트 (256,128,64,32) 저장
; 1196 : 				pCList.CharSet[14] |= (BYTE)((TempInventory[3]&0x01E0)>>1);
; 1197 : 				// 상위 5번째 비트 (32) 저장
; 1198 : 				pCList.CharSet[9] |= (BYTE)((TempInventory[3]&0x0010)<<2);
; 1199 : 				// 하위 4비트 저장
; 1200 : 				pCList.CharSet[3] |= (BYTE)((TempInventory[3]&0x000F));
; 1201 : 
; 1202 : 				// 바지
; 1203 : 				// 상위 4비트 (256,128,64,32) 저장
; 1204 : 				pCList.CharSet[14] |= (BYTE)((TempInventory[4]&0x01E0)>>5);
; 1205 : 				// 상위 5번째 비트 (32) 저장
; 1206 : 				pCList.CharSet[9] |= (BYTE)((TempInventory[4]&0x0010)<<1);
; 1207 : 				// 하위 4비트 저장
; 1208 : 				pCList.CharSet[4] |= (BYTE)((TempInventory[4]&0x000F)<<4);
; 1209 : 
; 1210 : 				// 장갑
; 1211 : 				// 상위 4비트 (256,128,64,32) 저장
; 1212 : 				pCList.CharSet[15] |= (BYTE)((TempInventory[5]&0x01E0)>>1);
; 1213 : 				// 상위 5번째 비트 (32) 저장
; 1214 : 				pCList.CharSet[9] |= (BYTE)((TempInventory[5]&0x0010));
; 1215 : 				// 하위 4비트 저장
; 1216 : 				pCList.CharSet[4] |= (BYTE)((TempInventory[5]&0x000F));
; 1217 : 
; 1218 : 				// 신발
; 1219 : 				// 상위 4비트 (256,128,64,32) 저장
; 1220 : 				pCList.CharSet[15] |= (BYTE)((TempInventory[6]&0x01E0)>>5);
; 1221 : 				// 상위 5번째 비트 (32) 저장
; 1222 : 				pCList.CharSet[9] |= (BYTE)((TempInventory[6]&0x0010)>>1);
; 1223 : 				// 하위 4비트 저장
; 1224 : 				pCList.CharSet[5] |= (BYTE)((TempInventory[6]&0x000F)<<4);
; 1225 : 
; 1226 : 				index = 0;	// 여기서는 사용 않함
; 1227 : #else
; 1228 : 				// 무기 인덱스는 그냥 1바이트씩 저장 (기존에 무기번호는 256 을 넘을 수 없었음)
; 1229 : 				pCList.CharSet[1] = (BYTE) TempInventory[0];
; 1230 : 				pCList.CharSet[2] = (BYTE) TempInventory[1];
; 1231 : 				
; 1232 : 				// 장구류 (헬멧, 갑옷, 바지, 장갑, 부츠) 는 Item Type 은 약속되어 있으므로 Item Index 만 저장 4바이트 씩 저장
; 1233 : 				pCList.CharSet[3] = ((TempInventory[2]%16)<<4)+(TempInventory[3]%16);
; 1234 : 				pCList.CharSet[4] = ((TempInventory[4]%16)<<4)+(TempInventory[5]%16);
; 1235 : 				index             = (TempInventory[6]%16)<<4;
; 1236 : #endif
; 1237 : 				
; 1238 : 				// 날개와 헬퍼는 2비트씩 -> 부츠를 저장했던 하위 4비트에 2비트씩 사용
; 1239 : 
; 1240 : 				// 날개
; 1241 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1242 : 				if( TempInventory[7] == ITEM_INDEX_NOT_EXIST )
; 1243 : #else
; 1244 : 				if( TempInventory[7] == 31 )
; 1245 : #endif
; 1246 : 					index |= 0x0C;
; 1247 : 				else index |=(TempInventory[7]&0x03)<<2;
; 1248 : 				
; 1249 : #ifdef DARKLORD_WORK
; 1250 : 				// 헬퍼
; 1251 : 				if( !(TempInventory[8]&0x04) )
; 1252 : 				{	// 다크호스가 아니면
; 1253 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1254 : 					if( TempInventory[8] == ITEM_INDEX_NOT_EXIST  )
; 1255 : #else
; 1256 : 					if( TempInventory[8] == 31  )
; 1257 : #endif
; 1258 : 					{
; 1259 : 						index |= 0x03;
; 1260 : 					}	
; 1261 : 					else
; 1262 : 					{
; 1263 : 						if( TempInventory[8] != 67 )//20080930 크리스마스 이벤트 루돌푸 펫(grooving)
; 1264 : 						{
; 1265 : 							index |=(TempInventory[8]&0x03);
; 1266 : 						}
; 1267 : 					}
; 1268 : 				}
; 1269 : 				else
; 1270 : 				{					
; 1271 : 					index |=  0x03;		// 다크호스를 장착하면 수호천사가 안보이게 하기 위해										
; 1272 : 				}
; 1273 : #else
; 1274 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1275 : 				if( TempInventory[8] == ITEM_INDEX_NOT_EXIST  )
; 1276 : #else
; 1277 : 				if( TempInventory[8] == 31  )
; 1278 : #endif					
; 1279 : 					index |= 0x03;
; 1280 : 				else index |=(TempInventory[8]&0x03);
; 1281 : #endif // DARKLORD_WORK
; 1282 : 				
; 1283 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1284 : 				pCList.CharSet[5] |= index;
; 1285 : #else
; 1286 : 				pCList.CharSet[5] = index;
; 1287 : #endif
; 1288 : 				
; 1289 : 				int levelindex=0;
; 1290 : 								
; 1291 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1292 : 				if( TempInventory[0] != 0xFFFF )
; 1293 : 					levelindex  = ((int)LevelSmallConvert((lpCL->dbInventory[1]>>3)&0xF));
; 1294 : 				if( TempInventory[1] != 0xFFFF )
; 1295 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[5]>>3)&0xF))<<3);
; 1296 : 				if( TempInventory[2] < ITEM_INDEX_NOT_EXIST )
; 1297 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[9]>>3)&0xF))<<6);
; 1298 : 				if( TempInventory[3] < ITEM_INDEX_NOT_EXIST )
; 1299 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[13]>>3)&0xF))<<9);
; 1300 : 				if( TempInventory[4] < ITEM_INDEX_NOT_EXIST )
; 1301 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[17]>>3)&0xF))<<12);
; 1302 : 				if( TempInventory[5] < ITEM_INDEX_NOT_EXIST )
; 1303 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[21]>>3)&0xF))<<15);
; 1304 : 				if( TempInventory[6] < ITEM_INDEX_NOT_EXIST )
; 1305 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[25]>>3)&0xF))<<18);
; 1306 : #else
; 1307 : 				if( TempInventory[0] != 0xFF )
; 1308 : 					levelindex  = ((int)LevelSmallConvert((lpCL->dbInventory[1]>>3)&0xF));
; 1309 : 				if( TempInventory[1] != 0xFF )
; 1310 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[5]>>3)&0xF))<<3);
; 1311 : 				if( TempInventory[2] < 31 )
; 1312 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[9]>>3)&0xF))<<6);
; 1313 : 				if( TempInventory[3] < 31 )
; 1314 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[13]>>3)&0xF))<<9);
; 1315 : 				if( TempInventory[4] < 31 )
; 1316 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[17]>>3)&0xF))<<12);
; 1317 : 				if( TempInventory[5] < 31 )
; 1318 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[21]>>3)&0xF))<<15);
; 1319 : 				if( TempInventory[6] < 31 )
; 1320 : 					levelindex |= ((int)LevelSmallConvert(((lpCL->dbInventory[25]>>3)&0xF))<<18);
; 1321 : #endif
; 1322 : 				
; 1323 : 				//levelindex = 0;
; 1324 : 				
; 1325 : 				pCList.CharSet[6] = (BYTE)((levelindex>>16)&255);
; 1326 : 				pCList.CharSet[7] = (BYTE)((levelindex>> 8)&255);
; 1327 : 				pCList.CharSet[8] = (BYTE)((levelindex    )&255);
; 1328 : 
; 1329 : 
; 1330 : #ifndef ITEM_INDEX_EXTEND_20050706		// 아이템 확장비트를 배분하는 부분 제거
; 1331 : 				if( TempInventory[2] > 15 ) pCList.CharSet[9]  = 0x80;
; 1332 : 				if( TempInventory[3] > 15 ) pCList.CharSet[9] |= 0x40;
; 1333 : 				if( TempInventory[4] > 15 ) pCList.CharSet[9] |= 0x20;
; 1334 : 				if( TempInventory[5] > 15 ) pCList.CharSet[9] |= 0x10;
; 1335 : 				if( TempInventory[6] > 15 ) pCList.CharSet[9] |= 0x08;
; 1336 : #endif
; 1337 : 
; 1338 : #ifdef NEW_FORSKYLAND2
; 1339 : 				// 날개....
; 1340 : 	#ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// CharList에 신규캐릭터 재앙의 날개 추가
; 1341 : 	if( (TempInventory[7] >= 3 && TempInventory[7] <= 6) || 
; 1342 : 					TempInventory[7] == 30 
; 1343 : 					|| TempInventory[7] == 41 || TempInventory[7] == 42 
; 1344 : 					)
; 1345 : 	#else	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 1346 : 	#ifdef DARKLORD_WORK
; 1347 : 				if( (TempInventory[7] >= 3 && TempInventory[7] <= 6) || 
; 1348 : 					TempInventory[7] == 30 )
; 1349 : 	#else
; 1350 : 				if( TempInventory[7] >= 3 && TempInventory[7] <= 6)
; 1351 : 	#endif	// #ifdef DARKLORD_WORK
; 1352 : 	#endif // ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 1353 : 				{
; 1354 : 					pCList.CharSet[5] |= 0x0C;
; 1355 : 
; 1356 : 	#ifdef DARKLORD_WORK
; 1357 : 					if( TempInventory[7] == 30 )
; 1358 : 						pCList.CharSet[9] |= 0x05;		// 망토 설정(0x07까지 마스킹이 되므로 앞으로 두개 더 쓸수 있음)
; 1359 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// CharList에 신규캐릭터 재앙의 날개 추가
; 1360 : 					else if( TempInventory[7] == 41 )
; 1361 : 						pCList.CharSet[9] |= 0x06;
; 1362 : 					else if( TempInventory[7] == 42 )
; 1363 : 						pCList.CharSet[9] |= 0x07;
; 1364 : #endif
; 1365 : 					else
; 1366 : 	#endif	// #ifdef DARKLORD_WORK
; 1367 : 						pCList.CharSet[9] |= ((TempInventory[7]-2)&0x7);
; 1368 : 				}
; 1369 : #else
; 1370 : 	#ifdef NEW_SKILL_FORSKYLAND
; 1371 : 				// 페가시아용...
; 1372 : 				if( TempInventory[8] & 0x03 && TempInventory[8] != 31 )
; 1373 : 				{
; 1374 : 					pCList.CharSet[9] |= (BYTE)0x04;
; 1375 : 				}
; 1376 : 	#endif
; 1377 : #endif	
; 1378 : 
; 1379 : 				pCList.CharSet[10] = 0;
; 1380 : 
; 1381 : #ifdef NEW_FORSKYLAND2
; 1382 : 				// 페가시아용...
; 1383 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1384 : 				if( TempInventory[8] & 0x03 && TempInventory[8] != ITEM_INDEX_NOT_EXIST  )
; 1385 : #else
; 1386 : 				if( TempInventory[8] & 0x03 && TempInventory[8] != 31 )
; 1387 : #endif
; 1388 : 				{
; 1389 : 					pCList.CharSet[10] |= (BYTE)0x01;
; 1390 : 				}
; 1391 : #endif
; 1392 : 
; 1393 : 				pCList.CharSet[11]  = 0;
; 1394 : 
; 1395 : #ifdef DARKLORD_WORK	
; 1396 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1397 : 				if( TempInventory[8] & 0x04 && TempInventory[8] != ITEM_INDEX_NOT_EXIST )
; 1398 : #else
; 1399 : 				if( TempInventory[8] & 0x04 && TempInventory[8] != 31 )
; 1400 : #endif
; 1401 : 				{	// 다크호스
; 1402 : 					pCList.CharSet[12] |= (BYTE)0x01;
; 1403 : 				}
; 1404 : #endif
; 1405 : 
; 1406 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1407 : 				// 예비 바이트 셋
; 1408 : 				pCList.CharSet[16] = 0;
; 1409 : 				pCList.CharSet[17] = 0;
; 1410 : #endif
; 1411 : 
; 1412 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 1413 : 				// HELPER가 펜릴인 경우 - 펜릴 번호 : (13, 37)
; 1414 : 				if( TempInventory[8] == 37 && TempInventory[8] != ITEM_INDEX_NOT_EXIST )
; 1415 : 				{	
; 1416 : 					pCList.CharSet[10] &= ~ (BYTE)0x01;	// 디노란트 아님 
; 1417 : 					pCList.CharSet[12] &= ~ (BYTE)0x01;	// 다크호스 아님
; 1418 : 					pCList.CharSet[12] |=	(BYTE)0x04; // 펜릴
; 1419 : 
; 1420 : 					// 액설런트 옵션 검사
; 1421 : 					
; 1422 : 					// ( DB -> GS ) 캐릭리스트 4BYTE 정보 
; 1423 : 					//  [0] 아이템 인덱스 
; 1424 : 					//	[1] 아이템 레벨, 옵션
; 1425 : 					//	[2] 아이템 인덱스 9번째 BIT, 액설런트&옵션 
; 1426 : 					//	[3] 아이템 인덱스 10~13번째 BIT
; 1427 : 
; 1428 : 					// ( GS -> CL ) 예비 바이트 
; 1429 : 					// CharSet[16], CharSet[17] 중
; 1430 : 					// CharSet[16]을 사용한다.
; 1431 : 
; 1432 : 					BYTE btExcellentOption = lpCL->dbInventory[34] & 0x3F;
; 1433 : 					
; 1434 : 					if( (btExcellentOption & PLUS_FENRIR_INCREASE_LAST_DAMAGE) == PLUS_FENRIR_INCREASE_LAST_DAMAGE )
; 1435 : 					{
; 1436 : 						pCList.CharSet[16] |= (BYTE)0x01;	// 펜릴 - 최종 데미지 증가
; 1437 : 					}
; 1438 : 					
; 1439 : 					if( (btExcellentOption & PLUS_FENRIR_DECREASE_LAST_DAMAGE) == PLUS_FENRIR_DECREASE_LAST_DAMAGE )
; 1440 : 					{
; 1441 : 						pCList.CharSet[16] |= (BYTE)0x02;	// 펜릴 - 최종 데미지 증가
; 1442 : 					}
; 1443 : 
; 1444 : #ifdef ADD_ILLUSION_FENRIR_20070703	// 환영 펜릴 옵션에 따른 스킬 추가(CharSet[17]중 2번째 Bit)
; 1445 : 					if( (btExcellentOption & PLUS_ILLUSION_FENRIR_OPTION) == PLUS_ILLUSION_FENRIR_OPTION )
; 1446 : 					{
; 1447 : 						pCList.CharSet[17] |= (BYTE)0x01;	// 펜릴 - 최종 데미지 증가
; 1448 : 					}
; 1449 : #endif
; 1450 : 				}
; 1451 : #endif // ADD_ITEM_FENRIR_01_20051110
; 1452 : 				
; 1453 : #ifdef ADD_THIRD_WING_20070525	// 캐릭터 정보 보낼 때 3차날개 추가	( DB 0x03 )
; 1454 : 	#ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 차원의 날개 캐릭터 정보 추가
; 1455 : 				if( ( TempInventory[7] >= 36 && TempInventory[7] <= 40 )
; 1456 : 					|| TempInventory[7] == 43)	
; 1457 : 	#else
; 1458 : 				if( TempInventory[7] >= 36 && TempInventory[7] <= 40 )
; 1459 : 	#endif
; 1460 : 				{
; 1461 : 					pCList.CharSet[5] |= 0x0C;
; 1462 : 					pCList.CharSet[16] |= ( (( TempInventory[7] - 35 )&0x7 ) << 2 );
; 1463 : 		#ifdef MODIFY_SUMMONER_THIRD_WING_BUFGIX_20090109	// 차원의 날개는 0x06으로 보냄
; 1464 : 					if(TempInventory[7] == 43)
; 1465 : 					{
; 1466 : 						pCList.CharSet[16] |= ( (( 0x06 )&0x7 ) << 2 );
; 1467 : 					}
; 1468 : 		#endif	// MODIFY_SUMMONER_THIRD_WING_BUFGIX_20090109
; 1469 : 				}
; 1470 : #endif	// ADD_THIRD_WING_20070525
; 1471 : 
; 1472 : #ifdef ADD_SAFEGUARD_ITEM_20080702
; 1473 : 				// 일본 데몬,추호천사 추가
; 1474 : 				// pCList.CharSet[16] : 1110 0000 앞에 3자리 사용함.
; 1475 : 				if( !(TempInventory[8]&0x04) && TempInventory[8] != ITEM_INDEX_NOT_EXIST )
; 1476 : 				{
; 1477 : 					BYTE btItemIndex = 0;
; 1478 : 					switch(TempInventory[8])
; 1479 : 					{
; 1480 : 					case 64://데몬
; 1481 : 						{
; 1482 : 							btItemIndex = (BYTE)(0x01 << 5);
; 1483 : 							break;
; 1484 : 						}
; 1485 : 					case 65://수호정령
; 1486 : 						{
; 1487 : 							btItemIndex = (BYTE)(0x02 << 5);
; 1488 : 							break;
; 1489 : 						}
; 1490 : 					case 67://20080930 크리스마스 이벤트 루돌푸 펫(grooving)
; 1491 : 						{
; 1492 : 							btItemIndex = (BYTE)(0x04 << 5);
; 1493 : 							break;
; 1494 : 						}
; 1495 : #ifdef ADD_UNICORN_PET_20090915		// 유니콘 펫
; 1496 : 					case 106:
; 1497 : 						{
; 1498 : 							btItemIndex = (BYTE)(0x05 << 5);
; 1499 : 							break;
; 1500 : 						}
; 1501 : #endif // ADD_UNICORN_PET_20090915
; 1502 : #ifdef ADD_PREMIUMITEM_PANDA
; 1503 : 					case 80://팬더펫
; 1504 : 						{
; 1505 : 							btItemIndex = (BYTE)(0x07 << 5);
; 1506 : 							break;
; 1507 : 						}
; 1508 : #endif // ADD_PREMIUMITEM_PANDA
; 1509 : 					}
; 1510 : 					
; 1511 : 					pCList.CharSet[16] |= btItemIndex;
; 1512 : 				}
; 1513 : #endif	//ADD_SAFEGUARD_ITEM_20080702
; 1514 : 			}
; 1515 : #endif	// ITEM_DBSIZE_EXTEND_20050706
; 1516 : 		
; 1517 : 			memcpy(sendbuf+lOfs, (char*)&pCList, sizeof(PMSG_CHARLIST));

  012ad	6a 1c		 push	 28			; 0000001cH
  012af	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _pCList$[ebp]
  012b5	50		 push	 eax
  012b6	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  012bc	8d 94 0d e8 fe
	ff ff		 lea	 edx, DWORD PTR _sendbuf$[ebp+ecx]
  012c3	52		 push	 edx
  012c4	e8 00 00 00 00	 call	 _memcpy
  012c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1518 : 			lsOfs += sizeof(SDHP_CHARLIST);

  012cc	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$[ebp]
  012d2	83 c0 42	 add	 eax, 66			; 00000042H
  012d5	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _lsOfs$[ebp], eax

; 1519 : 			lOfs  += sizeof(PMSG_CHARLIST);

  012db	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  012e1	83 c0 1c	 add	 eax, 28			; 0000001cH
  012e4	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 1520 : 		}

  012ea	e9 91 ee ff ff	 jmp	 $LN2@JGPGetChar
$LN6@JGPGetChar:

; 1521 : 	}
; 1522 : 	pCLCount.h.size = lOfs;

  012ef	8a 85 e4 fe ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  012f5	88 85 d1 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+1], al

; 1523 : 	memcpy(sendbuf, (char*)&pCLCount, sizeof(PMSG_CHARLISTCOUNT));

  012fb	6a 07		 push	 7
  012fd	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _pCLCount$[ebp]
  01303	50		 push	 eax
  01304	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  0130a	51		 push	 ecx
  0130b	e8 00 00 00 00	 call	 _memcpy
  01310	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1524 : 	DataSend(aIndex, sendbuf, lOfs);

  01313	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  01319	50		 push	 eax
  0131a	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  01320	51		 push	 ecx
  01321	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _aIndex$[ebp]
  01327	52		 push	 edx
  01328	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0132d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1525 : 
; 1526 : 	//캐릭터 리스트 받기(클라에서 캐릭터 선택 화면)
; 1527 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 1528 : 	LogAddTD_TempLog(", [D->G Recv GetCharList], Account [%s], IP [%s]", gObj[aIndex].AccountID, gObj[aIndex].Ip_addr);

  01330	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0133a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01340	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  01344	52		 push	 edx
  01345	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0134f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01355	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  01359	52		 push	 edx
  0135a	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@KDJHGNDI@?0?5?$FLD?9?$DOG?5Recv?5GetCharList?$FN?0?5Acco@
  0135f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  01365	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN69@JGPGetChar:

; 1529 : #endif
; 1530 : 	
; 1531 : 	if( gCreateCharacter == 0 )
; 1532 : 	{
; 1533 : 		//if( lpCount->Count == 0 ) 
; 1534 : 		//{
; 1535 : 		//	GCServerMsgStringSend("이벤트 서버엔 등록된 사용자만 접속 가능합니다.", aIndex, 0);
; 1536 : 		//	gObjCloseSet(aIndex, CL_SERVERLIST);
; 1537 : 		//}	
; 1538 : 	}
; 1539 : 	return;
; 1540 : 
; 1541 : }

  01368	5f		 pop	 edi
  01369	5e		 pop	 esi
  0136a	5b		 pop	 ebx
  0136b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0136e	33 cd		 xor	 ecx, ebp
  01370	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01375	8b e5		 mov	 esp, ebp
  01377	5d		 pop	 ebp
  01378	c3		 ret	 0
?JGPGetCharList@@YAXPAE@Z ENDP				; JGPGetCharList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?GCItemListSend@@YAXH@Z
_TEXT	SEGMENT
_n$1 = -1064						; size = 4
_itemcount$ = -1060					; size = 4
_lpObj$ = -1056						; size = 4
_sendBuf$ = -1052					; size = 1024
_pMsgILSize$ = -28					; size = 4
_sOfs$ = -24						; size = 4
_pMsgIL$ = -20						; size = 6
_pMsgILC$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCItemListSend@@YAXH@Z PROC				; GCItemListSend, COMDAT

; 2037 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 04 00
	00		 sub	 esp, 1256		; 000004e8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2038 : 	PMSG_INVENTORYLISTCOUNT	pMsgILC;
; 2039 : 	PMSG_INVENTORYLIST		pMsgIL;
; 2040 : 	int						sOfs       = sizeof(pMsgILC);

  00016	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR _sOfs$[ebp], 6

; 2041 : 	int						pMsgILSize = sizeof(pMsgIL);

  0001d	c7 45 e4 06 00
	00 00		 mov	 DWORD PTR _pMsgILSize$[ebp], 6

; 2042 : 	
; 2043 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2044 : 	BYTE					sendBuf[2048];
; 2045 : #else
; 2046 : 	BYTE					sendBuf[1024];
; 2047 : #endif
; 2048 : 	
; 2049 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00024	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00031	89 85 e0 fb ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], eax

; 2050 : 
; 2051 : 	int itemcount=0;

  00037	c7 85 dc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _itemcount$[ebp], 0

; 2052 : 	
; 2053 : #ifdef PERSONAL_SHOP_20040113
; 2054 : 	for( int n=0; n<MAX_INVENTORY_EXTEND; n++)

  00041	c7 85 d8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1[ebp], 0
  0004b	eb 0f		 jmp	 SHORT $LN4@GCItemList
$LN2@GCItemList:
  0004d	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@GCItemList:
  0005c	83 bd d8 fb ff
	ff 6c		 cmp	 DWORD PTR _n$1[ebp], 108 ; 0000006cH
  00063	0f 8d bc 00 00
	00		 jge	 $LN3@GCItemList

; 2055 : #else
; 2056 : 	for( int n=0; n<MAX_INVENTORY; n++)
; 2057 : #endif
; 2058 : 	{
; 2059 : 		if( lpObj->pInventory[n].IsItem() == TRUE )

  00069	69 8d d8 fb ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00073	8b 85 e0 fb ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00079	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0007f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00084	83 f8 01	 cmp	 eax, 1
  00087	0f 85 93 00 00
	00		 jne	 $LN5@GCItemList

; 2060 : 		{
; 2061 : #ifdef ITEMDELETE_MODIFY_20040604	// 존재하지 않는 아이템이라면 리스트를 보내주지 않는다.
; 2062 : 			if (lpObj->pInventory[n].m_bItemExist == false)

  0008d	69 85 d8 fb ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 168
  00097	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009d	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000a3	0f b6 44 02 6c	 movzx	 eax, BYTE PTR [edx+eax+108]
  000a8	85 c0		 test	 eax, eax
  000aa	75 02		 jne	 SHORT $LN6@GCItemList

; 2063 : 				continue;

  000ac	eb 9f		 jmp	 SHORT $LN2@GCItemList
$LN6@GCItemList:

; 2064 : #endif
; 2065 : 			pMsgIL.Pos = n;

  000ae	8a 85 d8 fb ff
	ff		 mov	 al, BYTE PTR _n$1[ebp]
  000b4	88 45 ec	 mov	 BYTE PTR _pMsgIL$[ebp], al

; 2066 : 			ItemByteConvert( pMsgIL.ItemInfo, lpObj->pInventory[n] );

  000b7	69 85 d8 fb ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 168
  000c1	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c7	8b b1 5c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3164]
  000cd	03 f0		 add	 esi, eax
  000cf	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  000d5	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000da	8b fc		 mov	 edi, esp
  000dc	f3 a5		 rep movsd
  000de	8d 55 ed	 lea	 edx, DWORD PTR _pMsgIL$[ebp+1]
  000e1	52		 push	 edx
  000e2	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  000e7	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 2067 : 			memcpy(sendBuf+sOfs, (char*)&pMsgIL, pMsgILSize);

  000ed	8b 45 e4	 mov	 eax, DWORD PTR _pMsgILSize$[ebp]
  000f0	50		 push	 eax
  000f1	8d 4d ec	 lea	 ecx, DWORD PTR _pMsgIL$[ebp]
  000f4	51		 push	 ecx
  000f5	8b 55 e8	 mov	 edx, DWORD PTR _sOfs$[ebp]
  000f8	8d 84 15 e4 fb
	ff ff		 lea	 eax, DWORD PTR _sendBuf$[ebp+edx]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _memcpy
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2068 : 			itemcount++;

  00108	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _itemcount$[ebp]
  0010e	83 c0 01	 add	 eax, 1
  00111	89 85 dc fb ff
	ff		 mov	 DWORD PTR _itemcount$[ebp], eax

; 2069 : 			sOfs += pMsgILSize;

  00117	8b 45 e8	 mov	 eax, DWORD PTR _sOfs$[ebp]
  0011a	03 45 e4	 add	 eax, DWORD PTR _pMsgILSize$[ebp]
  0011d	89 45 e8	 mov	 DWORD PTR _sOfs$[ebp], eax
$LN5@GCItemList:

; 2070 : 		}
; 2071 : 	}

  00120	e9 28 ff ff ff	 jmp	 $LN2@GCItemList
$LN3@GCItemList:

; 2072 : 	
; 2073 : 	pMsgILC.h.c        = 0xC4;

  00125	c6 45 f4 c4	 mov	 BYTE PTR _pMsgILC$[ebp], 196 ; 000000c4H

; 2074 : 	pMsgILC.h.headcode = 0xF3;

  00129	c6 45 f7 f3	 mov	 BYTE PTR _pMsgILC$[ebp+3], 243 ; 000000f3H

; 2075 : 	pMsgILC.subcode    = 0x10;

  0012d	c6 45 f8 10	 mov	 BYTE PTR _pMsgILC$[ebp+4], 16 ; 00000010H

; 2076 : 	pMsgILC.h.sizeH    = HIBYTE( sOfs );

  00131	8b 45 e8	 mov	 eax, DWORD PTR _sOfs$[ebp]
  00134	c1 e8 08	 shr	 eax, 8
  00137	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0013c	88 45 f5	 mov	 BYTE PTR _pMsgILC$[ebp+1], al

; 2077 : 	pMsgILC.h.sizeL    = LOBYTE( sOfs );

  0013f	8b 45 e8	 mov	 eax, DWORD PTR _sOfs$[ebp]
  00142	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00147	88 45 f6	 mov	 BYTE PTR _pMsgILC$[ebp+2], al

; 2078 : 	pMsgILC.Count      = itemcount;

  0014a	8a 85 dc fb ff
	ff		 mov	 al, BYTE PTR _itemcount$[ebp]
  00150	88 45 f9	 mov	 BYTE PTR _pMsgILC$[ebp+5], al

; 2079 : 	memcpy( sendBuf, (char*)&pMsgILC, sizeof(pMsgILC));

  00153	6a 06		 push	 6
  00155	8d 45 f4	 lea	 eax, DWORD PTR _pMsgILC$[ebp]
  00158	50		 push	 eax
  00159	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  0015f	51		 push	 ecx
  00160	e8 00 00 00 00	 call	 _memcpy
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2080 : 	
; 2081 : 	DataSend(aIndex, (LPBYTE)sendBuf, sOfs);

  00168	8b 45 e8	 mov	 eax, DWORD PTR _sOfs$[ebp]
  0016b	50		 push	 eax
  0016c	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  00172	51		 push	 ecx
  00173	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0017c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2082 : 	//LogAddL("암호화 패킷 데이터 전송 : [%x][%x]", pMsgILC.h.headcode, pMsgILC.subcode);
; 2083 : 
; 2084 : 
; 2085 : 	
; 2086 : }

  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx
  00182	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00185	33 cd		 xor	 ecx, ebp
  00187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
?GCItemListSend@@YAXH@Z ENDP				; GCItemListSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?gObjSavePetItemInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$1 = -2092						; size = 5
_n$2 = -2084						; size = 4
_n$3 = -2080						; size = 4
_petIteminfo$ = -2076					; size = 12
_founditemcount$ = -2064				; size = 4
_lofs$ = -2060						; size = 4
_pbuffer$ = -2056					; size = 2048
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_inventype$ = 12					; size = 4
?gObjSavePetItemInfo@@YAXHH@Z PROC			; gObjSavePetItemInfo, COMDAT

; 4048 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 09 00
	00		 sub	 esp, 2412		; 0000096cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 4049 : 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00016	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 4050 : 	char	pbuffer[2048];
; 4051 : 	int		lofs = sizeof(SDHP_SAVE_PETITEM_INFO);	

  00026	c7 85 f4 f7 ff
	ff 05 00 00 00	 mov	 DWORD PTR _lofs$[ebp], 5

; 4052 : 
; 4053 : 	BOOL	founditemcount = 0;

  00030	c7 85 f0 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _founditemcount$[ebp], 0

; 4054 : 	Save_PetItem_Info	petIteminfo;
; 4055 : 
; 4056 : 	if( inventype == 0 )

  0003a	83 7d 0c 00	 cmp	 DWORD PTR _inventype$[ebp], 0
  0003e	0f 85 b2 01 00
	00		 jne	 $LN8@gObjSavePe

; 4057 : 	{	// 인벤토리
; 4058 : 	#ifdef PERSONAL_SHOP_20040113		
; 4059 : 		for( int n=0; n<MAX_INVENTORY_EXTEND; n++)

  00044	c7 85 e0 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$3[ebp], 0
  0004e	eb 0f		 jmp	 SHORT $LN4@gObjSavePe
$LN2@gObjSavePe:
  00050	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _n$3[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 85 e0 f7 ff
	ff		 mov	 DWORD PTR _n$3[ebp], eax
$LN4@gObjSavePe:
  0005f	83 bd e0 f7 ff
	ff 6c		 cmp	 DWORD PTR _n$3[ebp], 108 ; 0000006cH
  00066	0f 8d 85 01 00
	00		 jge	 $LN3@gObjSavePe

; 4060 : 	#else
; 4061 : 		for( int n=0; n<MAX_INVENTORY; n++)
; 4062 : 	#endif
; 4063 : 		{
; 4064 : 			if( lpObj->pInventory[n].IsItem() )

  0006c	69 8d e0 f7 ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$3[ebp], 168
  00076	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00079	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0007f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00084	85 c0		 test	 eax, eax
  00086	0f 84 60 01 00
	00		 je	 $LN10@gObjSavePe

; 4065 : 			{
; 4066 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,4) || 

  0008c	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00099	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0009f	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000a4	6a 04		 push	 4
  000a6	6a 0d		 push	 13			; 0000000dH
  000a8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ad	83 c4 08	 add	 esp, 8
  000b0	3b f0		 cmp	 esi, eax
  000b2	74 2c		 je	 SHORT $LN12@gObjSavePe
  000b4	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  000be	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c1	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000c7	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000cc	6a 05		 push	 5
  000ce	6a 0d		 push	 13			; 0000000dH
  000d0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d5	83 c4 08	 add	 esp, 8
  000d8	3b f0		 cmp	 esi, eax
  000da	0f 85 0c 01 00
	00		 jne	 $LN10@gObjSavePe
$LN12@gObjSavePe:

; 4067 : 					lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,5) )
; 4068 : 				{	// 다크스피릿또는 다크호스는 펫 정보를 요청한다
; 4069 : 					if( lpObj->pInventory[n].m_IsLoadPetItemInfo )

  000e0	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ed	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000f3	83 bc 02 9c 00
	00 00 00	 cmp	 DWORD PTR [edx+eax+156], 0
  000fb	0f 84 eb 00 00
	00		 je	 $LN10@gObjSavePe

; 4070 : 					{
; 4071 : 						founditemcount++;					

  00101	8b 85 f0 f7 ff
	ff		 mov	 eax, DWORD PTR _founditemcount$[ebp]
  00107	83 c0 01	 add	 eax, 1
  0010a	89 85 f0 f7 ff
	ff		 mov	 DWORD PTR _founditemcount$[ebp], eax

; 4072 : 						petIteminfo.nSerial = lpObj->pInventory[n].m_Number;

  00110	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0011d	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00123	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00126	89 85 e4 f7 ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp], eax

; 4073 : 						petIteminfo.Level = lpObj->pInventory[n].m_PetItem_Level;					

  0012c	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  00136	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00139	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0013f	8a 84 02 a0 00
	00 00		 mov	 al, BYTE PTR [edx+eax+160]
  00146	88 85 e8 f7 ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp+4], al

; 4074 : 						petIteminfo.Exp = lpObj->pInventory[n].m_PetItem_Exp;

  0014c	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  00156	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00159	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0015f	8b 84 02 a4 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+164]
  00166	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp+8], eax

; 4075 : 
; 4076 : 						// PI : 펫아이템 인벤 PW : 펫아이템 창고
; 4077 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 4078 : 						LogAddTD("[%s][%s][PI][%d,%s]serial:[%u] Level:%d Exp:%d", 
; 4079 : #else
; 4080 : 						LogAddTD("[%s][%s][PI][%d,%s]serial:[%d] Level:%d Exp:%d", 

  0016c	8b 85 ec f7 ff
	ff		 mov	 eax, DWORD PTR _petIteminfo$[ebp+8]
  00172	50		 push	 eax
  00173	0f b6 8d e8 f7
	ff ff		 movzx	 ecx, BYTE PTR _petIteminfo$[ebp+4]
  0017a	51		 push	 ecx
  0017b	8b 95 e4 f7 ff
	ff		 mov	 edx, DWORD PTR _petIteminfo$[ebp]
  00181	52		 push	 edx
  00182	69 8d e0 f7 ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$3[ebp], 168
  0018c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018f	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00195	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0019a	50		 push	 eax
  0019b	8b 8d e0 f7 ff
	ff		 mov	 ecx, DWORD PTR _n$3[ebp]
  001a1	51		 push	 ecx
  001a2	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001a5	83 c2 73	 add	 edx, 115		; 00000073H
  001a8	52		 push	 edx
  001a9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ac	83 c0 68	 add	 eax, 104		; 00000068H
  001af	50		 push	 eax
  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@HBHBBGIF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5@
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001bb	83 c4 20	 add	 esp, 32			; 00000020H

; 4081 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 4082 : 								 lpObj->AccountID, lpObj->Name, 
; 4083 : 								 n, lpObj->pInventory[n].GetName(),
; 4084 : 								 petIteminfo.nSerial,
; 4085 : 								 petIteminfo.Level,
; 4086 : 								 petIteminfo.Exp);
; 4087 : 
; 4088 : 						memcpy(pbuffer+lofs, &petIteminfo, sizeof(Save_PetItem_Info));

  001be	6a 0c		 push	 12			; 0000000cH
  001c0	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _petIteminfo$[ebp]
  001c6	50		 push	 eax
  001c7	8b 8d f4 f7 ff
	ff		 mov	 ecx, DWORD PTR _lofs$[ebp]
  001cd	8d 94 0d f8 f7
	ff ff		 lea	 edx, DWORD PTR _pbuffer$[ebp+ecx]
  001d4	52		 push	 edx
  001d5	e8 00 00 00 00	 call	 _memcpy
  001da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4089 : 						lofs+=sizeof(Save_PetItem_Info);

  001dd	8b 85 f4 f7 ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  001e3	83 c0 0c	 add	 eax, 12			; 0000000cH
  001e6	89 85 f4 f7 ff
	ff		 mov	 DWORD PTR _lofs$[ebp], eax
$LN10@gObjSavePe:

; 4090 : 					}					
; 4091 : 				}
; 4092 : 			}
; 4093 : 		}

  001ec	e9 5f fe ff ff	 jmp	 $LN2@gObjSavePe
$LN3@gObjSavePe:

; 4094 : 	}

  001f1	e9 b7 01 00 00	 jmp	 $LN9@gObjSavePe
$LN8@gObjSavePe:

; 4095 : 	else if( inventype == 1 )

  001f6	83 7d 0c 01	 cmp	 DWORD PTR _inventype$[ebp], 1
  001fa	0f 85 ad 01 00
	00		 jne	 $LN9@gObjSavePe

; 4096 : 	{
; 4097 : 		for( int n=0; n<MAX_WAREHOUSEITEMS; n++)

  00200	c7 85 dc f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$2[ebp], 0
  0020a	eb 0f		 jmp	 SHORT $LN7@gObjSavePe
$LN5@gObjSavePe:
  0020c	8b 85 dc f7 ff
	ff		 mov	 eax, DWORD PTR _n$2[ebp]
  00212	83 c0 01	 add	 eax, 1
  00215	89 85 dc f7 ff
	ff		 mov	 DWORD PTR _n$2[ebp], eax
$LN7@gObjSavePe:
  0021b	83 bd dc f7 ff
	ff 78		 cmp	 DWORD PTR _n$2[ebp], 120 ; 00000078H
  00222	0f 8d 85 01 00
	00		 jge	 $LN9@gObjSavePe

; 4098 : 		{
; 4099 : 			if( lpObj->pWarehouse[n].IsItem() )

  00228	69 8d dc f7 ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$2[ebp], 168
  00232	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00235	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  0023b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00240	85 c0		 test	 eax, eax
  00242	0f 84 60 01 00
	00		 je	 $LN15@gObjSavePe

; 4100 : 			{
; 4101 : 				if( lpObj->pWarehouse[n].m_Type == MAKE_ITEMNUM(13,4) || 

  00248	69 85 dc f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  00252	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00255	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  0025b	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00260	6a 04		 push	 4
  00262	6a 0d		 push	 13			; 0000000dH
  00264	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00269	83 c4 08	 add	 esp, 8
  0026c	3b f0		 cmp	 esi, eax
  0026e	74 2c		 je	 SHORT $LN17@gObjSavePe
  00270	69 85 dc f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  0027a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0027d	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  00283	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00288	6a 05		 push	 5
  0028a	6a 0d		 push	 13			; 0000000dH
  0028c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00291	83 c4 08	 add	 esp, 8
  00294	3b f0		 cmp	 esi, eax
  00296	0f 85 0c 01 00
	00		 jne	 $LN15@gObjSavePe
$LN17@gObjSavePe:

; 4102 : 					lpObj->pWarehouse[n].m_Type == MAKE_ITEMNUM(13,5) )
; 4103 : 				{	// 다크스피릿또는 다크호스는 펫 정보를 요청한다
; 4104 : 					if( lpObj->pWarehouse[n].m_IsLoadPetItemInfo )

  0029c	69 85 dc f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  002a6	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002a9	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  002af	83 bc 02 9c 00
	00 00 00	 cmp	 DWORD PTR [edx+eax+156], 0
  002b7	0f 84 eb 00 00
	00		 je	 $LN15@gObjSavePe

; 4105 : 					{
; 4106 : 						founditemcount++;					

  002bd	8b 85 f0 f7 ff
	ff		 mov	 eax, DWORD PTR _founditemcount$[ebp]
  002c3	83 c0 01	 add	 eax, 1
  002c6	89 85 f0 f7 ff
	ff		 mov	 DWORD PTR _founditemcount$[ebp], eax

; 4107 : 						petIteminfo.nSerial = lpObj->pWarehouse[n].m_Number;

  002cc	69 85 dc f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  002d6	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002d9	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  002df	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  002e2	89 85 e4 f7 ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp], eax

; 4108 : 						petIteminfo.Level = lpObj->pWarehouse[n].m_PetItem_Level;

  002e8	69 85 dc f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  002f2	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002f5	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  002fb	8a 84 02 a0 00
	00 00		 mov	 al, BYTE PTR [edx+eax+160]
  00302	88 85 e8 f7 ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp+4], al

; 4109 : 						petIteminfo.Exp = lpObj->pWarehouse[n].m_PetItem_Exp;					

  00308	69 85 dc f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  00312	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00315	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  0031b	8b 84 02 a4 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+164]
  00322	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp+8], eax

; 4110 : 
; 4111 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 4112 : 						LogAddTD("[%s][%s][PW][%d,%s]serial:[%u] Level:%d Exp:%d", 
; 4113 : #else
; 4114 : 						LogAddTD("[%s][%s][PW][%d,%s]serial:[%d] Level:%d Exp:%d", 

  00328	8b 85 ec f7 ff
	ff		 mov	 eax, DWORD PTR _petIteminfo$[ebp+8]
  0032e	50		 push	 eax
  0032f	0f b6 8d e8 f7
	ff ff		 movzx	 ecx, BYTE PTR _petIteminfo$[ebp+4]
  00336	51		 push	 ecx
  00337	8b 95 e4 f7 ff
	ff		 mov	 edx, DWORD PTR _petIteminfo$[ebp]
  0033d	52		 push	 edx
  0033e	69 8d dc f7 ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$2[ebp], 168
  00348	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034b	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  00351	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00356	50		 push	 eax
  00357	8b 8d dc f7 ff
	ff		 mov	 ecx, DWORD PTR _n$2[ebp]
  0035d	51		 push	 ecx
  0035e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00361	83 c2 73	 add	 edx, 115		; 00000073H
  00364	52		 push	 edx
  00365	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00368	83 c0 68	 add	 eax, 104		; 00000068H
  0036b	50		 push	 eax
  0036c	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@HLCJJJIG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5@
  00371	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00377	83 c4 20	 add	 esp, 32			; 00000020H

; 4115 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 4116 : 								 lpObj->AccountID, lpObj->Name, 
; 4117 : 								 n, lpObj->pWarehouse[n].GetName(),
; 4118 : 								 petIteminfo.nSerial,
; 4119 : 								 petIteminfo.Level,
; 4120 : 								 petIteminfo.Exp);
; 4121 : 
; 4122 : 						memcpy(pbuffer+lofs, &petIteminfo, sizeof(Save_PetItem_Info));

  0037a	6a 0c		 push	 12			; 0000000cH
  0037c	8d 85 e4 f7 ff
	ff		 lea	 eax, DWORD PTR _petIteminfo$[ebp]
  00382	50		 push	 eax
  00383	8b 8d f4 f7 ff
	ff		 mov	 ecx, DWORD PTR _lofs$[ebp]
  00389	8d 94 0d f8 f7
	ff ff		 lea	 edx, DWORD PTR _pbuffer$[ebp+ecx]
  00390	52		 push	 edx
  00391	e8 00 00 00 00	 call	 _memcpy
  00396	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4123 : 						lofs+=sizeof(Save_PetItem_Info);

  00399	8b 85 f4 f7 ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  0039f	83 c0 0c	 add	 eax, 12			; 0000000cH
  003a2	89 85 f4 f7 ff
	ff		 mov	 DWORD PTR _lofs$[ebp], eax
$LN15@gObjSavePe:

; 4124 : 					}					
; 4125 : 				}
; 4126 : 			}
; 4127 : 		}

  003a8	e9 5f fe ff ff	 jmp	 $LN5@gObjSavePe
$LN9@gObjSavePe:

; 4128 : 	}
; 4129 : 
; 4130 : 	if( founditemcount )

  003ad	83 bd f0 f7 ff
	ff 00		 cmp	 DWORD PTR _founditemcount$[ebp], 0
  003b4	74 5d		 je	 SHORT $LN1@gObjSavePe

; 4131 : 	{
; 4132 : 		SDHP_SAVE_PETITEM_INFO pMsg;
; 4133 : 		pMsg.h.set((LPBYTE)&pMsg, 0x57,  sizeof(SDHP_SAVE_PETITEM_INFO)+lofs);

  003b6	8b 85 f4 f7 ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  003bc	83 c0 05	 add	 eax, 5
  003bf	50		 push	 eax
  003c0	6a 57		 push	 87			; 00000057H
  003c2	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  003c8	51		 push	 ecx
  003c9	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  003cf	e8 00 00 00 00	 call	 ?set@PWMSG_HEAD@@QAEXPAEEH@Z ; PWMSG_HEAD::set

; 4134 : 		
; 4135 : 		pMsg.nCount = founditemcount;		

  003d4	8a 85 f0 f7 ff
	ff		 mov	 al, BYTE PTR _founditemcount$[ebp]
  003da	88 85 d8 f7 ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+4], al

; 4136 : 
; 4137 : 		memcpy(pbuffer, &pMsg, sizeof(SDHP_SAVE_PETITEM_INFO));

  003e0	6a 05		 push	 5
  003e2	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  003e8	50		 push	 eax
  003e9	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _pbuffer$[ebp]
  003ef	51		 push	 ecx
  003f0	e8 00 00 00 00	 call	 _memcpy
  003f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4138 : 		cDBSMng.Send(pbuffer, sizeof(SDHP_SAVE_PETITEM_INFO)+lofs);

  003f8	8b 85 f4 f7 ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  003fe	83 c0 05	 add	 eax, 5
  00401	50		 push	 eax
  00402	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _pbuffer$[ebp]
  00408	51		 push	 ecx
  00409	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0040e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@gObjSavePe:

; 4139 : 	}
; 4140 : }

  00413	5f		 pop	 edi
  00414	5e		 pop	 esi
  00415	5b		 pop	 ebx
  00416	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00419	33 cd		 xor	 ecx, ebp
  0041b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00420	8b e5		 mov	 esp, ebp
  00422	5d		 pop	 ebp
  00423	c3		 ret	 0
?gObjSavePetItemInfo@@YAXHH@Z ENDP			; gObjSavePetItemInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?gObjRequestPetItemInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$1 = -2100						; size = 20
_n$2 = -2080						; size = 4
_n$3 = -2076						; size = 4
_petIteminfo$ = -2072					; size = 8
_founditemcount$ = -2064				; size = 4
_lofs$ = -2060						; size = 4
_pbuffer$ = -2056					; size = 2048
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_inventype$ = 12					; size = 4
?gObjRequestPetItemInfo@@YAXHH@Z PROC			; gObjRequestPetItemInfo, COMDAT

; 3896 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 74 09 00
	00		 sub	 esp, 2420		; 00000974H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3897 : 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00016	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 3898 : 	char	pbuffer[2048];
; 3899 : 	int		lofs = sizeof(SDHP_REQUEST_PETITEM_INFO);

  00026	c7 85 f4 f7 ff
	ff 14 00 00 00	 mov	 DWORD PTR _lofs$[ebp], 20 ; 00000014H

; 3900 : 	
; 3901 : 
; 3902 : 	//SDHP_REQUEST_PETITEM_INFO	pMsg;
; 3903 : 
; 3904 : 	//pMsg.h.set(&pMsg, 0x56, )
; 3905 : 
; 3906 : 	BOOL	founditemcount = 0;

  00030	c7 85 f0 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _founditemcount$[ebp], 0

; 3907 : 	Request_PetItem_Info	petIteminfo;
; 3908 : 
; 3909 : 	if( inventype == 0 )

  0003a	83 7d 0c 00	 cmp	 DWORD PTR _inventype$[ebp], 0
  0003e	0f 85 52 01 00
	00		 jne	 $LN8@gObjReques

; 3910 : 	{	// 인벤토리
; 3911 : 	#ifdef PERSONAL_SHOP_20040113		
; 3912 : 		for( int n=0; n<MAX_INVENTORY_EXTEND; n++)

  00044	c7 85 e4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$3[ebp], 0
  0004e	eb 0f		 jmp	 SHORT $LN4@gObjReques
$LN2@gObjReques:
  00050	8b 85 e4 f7 ff
	ff		 mov	 eax, DWORD PTR _n$3[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 85 e4 f7 ff
	ff		 mov	 DWORD PTR _n$3[ebp], eax
$LN4@gObjReques:
  0005f	83 bd e4 f7 ff
	ff 6c		 cmp	 DWORD PTR _n$3[ebp], 108 ; 0000006cH
  00066	0f 8d 25 01 00
	00		 jge	 $LN3@gObjReques

; 3913 : 	#else
; 3914 : 		for( int n=0; n<MAX_INVENTORY; n++)
; 3915 : 	#endif
; 3916 : 		{
; 3917 : 			if( lpObj->pInventory[n].IsItem() )

  0006c	69 8d e4 f7 ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$3[ebp], 168
  00076	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00079	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0007f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00084	85 c0		 test	 eax, eax
  00086	0f 84 00 01 00
	00		 je	 $LN10@gObjReques

; 3918 : 			{
; 3919 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,4) || 

  0008c	69 85 e4 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00099	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0009f	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000a4	6a 04		 push	 4
  000a6	6a 0d		 push	 13			; 0000000dH
  000a8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ad	83 c4 08	 add	 esp, 8
  000b0	3b f0		 cmp	 esi, eax
  000b2	74 2c		 je	 SHORT $LN12@gObjReques
  000b4	69 85 e4 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  000be	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c1	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000c7	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000cc	6a 05		 push	 5
  000ce	6a 0d		 push	 13			; 0000000dH
  000d0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d5	83 c4 08	 add	 esp, 8
  000d8	3b f0		 cmp	 esi, eax
  000da	0f 85 ac 00 00
	00		 jne	 $LN10@gObjReques
$LN12@gObjReques:

; 3920 : 					lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,5) )
; 3921 : 				{	// 다크스피릿또는 다크호스는 펫 정보를 요청한다
; 3922 : #ifdef DELETE_DARKLORD_PET_SERIAL_ZERO_20050617
; 3923 : 					if (lpObj->pInventory[n].m_Number == 0) {

  000e0	69 85 e4 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  000ea	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ed	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000f3	83 3c 02 00	 cmp	 DWORD PTR [edx+eax], 0
  000f7	75 2e		 jne	 SHORT $LN13@gObjReques

; 3924 : 						gObjInventoryDeleteItem(aIndex, n);

  000f9	8b 85 e4 f7 ff
	ff		 mov	 eax, DWORD PTR _n$3[ebp]
  000ff	50		 push	 eax
  00100	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00103	51		 push	 ecx
  00104	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00109	83 c4 08	 add	 esp, 8

; 3925 : 						GCInventoryItemDeleteSend(aIndex, n, 1);

  0010c	6a 01		 push	 1
  0010e	0f b6 85 e4 f7
	ff ff		 movzx	 eax, BYTE PTR _n$3[ebp]
  00115	50		 push	 eax
  00116	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00119	51		 push	 ecx
  0011a	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3926 : 						continue;

  00122	e9 29 ff ff ff	 jmp	 $LN2@gObjReques
$LN13@gObjReques:

; 3927 : 					}
; 3928 : #endif
; 3929 : 					founditemcount++;

  00127	8b 85 f0 f7 ff
	ff		 mov	 eax, DWORD PTR _founditemcount$[ebp]
  0012d	83 c0 01	 add	 eax, 1
  00130	89 85 f0 f7 ff
	ff		 mov	 DWORD PTR _founditemcount$[ebp], eax

; 3930 : 					petIteminfo.nPos = n;

  00136	8a 85 e4 f7 ff
	ff		 mov	 al, BYTE PTR _n$3[ebp]
  0013c	88 85 e8 f7 ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp], al

; 3931 : 					petIteminfo.nSerial = lpObj->pInventory[n].m_Number;

  00142	69 85 e4 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 168
  0014c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0014f	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00155	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00158	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp+4], eax

; 3932 : 					memcpy(pbuffer+lofs, &petIteminfo, sizeof(Request_PetItem_Info));

  0015e	6a 08		 push	 8
  00160	8d 85 e8 f7 ff
	ff		 lea	 eax, DWORD PTR _petIteminfo$[ebp]
  00166	50		 push	 eax
  00167	8b 8d f4 f7 ff
	ff		 mov	 ecx, DWORD PTR _lofs$[ebp]
  0016d	8d 94 0d f8 f7
	ff ff		 lea	 edx, DWORD PTR _pbuffer$[ebp+ecx]
  00174	52		 push	 edx
  00175	e8 00 00 00 00	 call	 _memcpy
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3933 : 					lofs+=sizeof(Request_PetItem_Info);

  0017d	8b 85 f4 f7 ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  00183	83 c0 08	 add	 eax, 8
  00186	89 85 f4 f7 ff
	ff		 mov	 DWORD PTR _lofs$[ebp], eax
$LN10@gObjReques:

; 3934 : 				}
; 3935 : 			}
; 3936 : 		}

  0018c	e9 bf fe ff ff	 jmp	 $LN2@gObjReques
$LN3@gObjReques:

; 3937 : 	}

  00191	e9 41 01 00 00	 jmp	 $LN9@gObjReques
$LN8@gObjReques:

; 3938 : 	else if( inventype == 1 )

  00196	83 7d 0c 01	 cmp	 DWORD PTR _inventype$[ebp], 1
  0019a	0f 85 37 01 00
	00		 jne	 $LN9@gObjReques

; 3939 : 	{
; 3940 : 		for( int n=0; n<MAX_WAREHOUSEITEMS; n++)

  001a0	c7 85 e0 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$2[ebp], 0
  001aa	eb 0f		 jmp	 SHORT $LN7@gObjReques
$LN5@gObjReques:
  001ac	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _n$2[ebp]
  001b2	83 c0 01	 add	 eax, 1
  001b5	89 85 e0 f7 ff
	ff		 mov	 DWORD PTR _n$2[ebp], eax
$LN7@gObjReques:
  001bb	83 bd e0 f7 ff
	ff 78		 cmp	 DWORD PTR _n$2[ebp], 120 ; 00000078H
  001c2	0f 8d 0f 01 00
	00		 jge	 $LN9@gObjReques

; 3941 : 		{
; 3942 : 			if( lpObj->pWarehouse[n].IsItem() )

  001c8	69 8d e0 f7 ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$2[ebp], 168
  001d2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d5	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  001db	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001e0	85 c0		 test	 eax, eax
  001e2	0f 84 ea 00 00
	00		 je	 $LN15@gObjReques

; 3943 : 			{
; 3944 : 				if( lpObj->pWarehouse[n].m_Type == MAKE_ITEMNUM(13,4) || 

  001e8	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  001f2	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f5	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  001fb	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00200	6a 04		 push	 4
  00202	6a 0d		 push	 13			; 0000000dH
  00204	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00209	83 c4 08	 add	 esp, 8
  0020c	3b f0		 cmp	 esi, eax
  0020e	74 2c		 je	 SHORT $LN17@gObjReques
  00210	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  0021a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0021d	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  00223	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00228	6a 05		 push	 5
  0022a	6a 0d		 push	 13			; 0000000dH
  0022c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00231	83 c4 08	 add	 esp, 8
  00234	3b f0		 cmp	 esi, eax
  00236	0f 85 96 00 00
	00		 jne	 $LN15@gObjReques
$LN17@gObjReques:

; 3945 : 					lpObj->pWarehouse[n].m_Type == MAKE_ITEMNUM(13,5) )
; 3946 : 				{	// 다크스피릿또는 다크호스는 펫 정보를 요청한다
; 3947 : #ifdef DELETE_DARKLORD_PET_SERIAL_ZERO_20050617
; 3948 : 					if (lpObj->pWarehouse[n].m_Number == 0) {

  0023c	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  00246	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00249	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  0024f	83 3c 02 00	 cmp	 DWORD PTR [edx+eax], 0
  00253	75 18		 jne	 SHORT $LN18@gObjReques

; 3949 : 						gObjWarehouseDeleteItem(aIndex, n);

  00255	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _n$2[ebp]
  0025b	50		 push	 eax
  0025c	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0025f	51		 push	 ecx
  00260	e8 00 00 00 00	 call	 ?gObjWarehouseDeleteItem@@YAEHH@Z ; gObjWarehouseDeleteItem
  00265	83 c4 08	 add	 esp, 8

; 3950 : 						continue;

  00268	e9 3f ff ff ff	 jmp	 $LN5@gObjReques
$LN18@gObjReques:

; 3951 : 					}
; 3952 : #endif
; 3953 : 					founditemcount++;

  0026d	8b 85 f0 f7 ff
	ff		 mov	 eax, DWORD PTR _founditemcount$[ebp]
  00273	83 c0 01	 add	 eax, 1
  00276	89 85 f0 f7 ff
	ff		 mov	 DWORD PTR _founditemcount$[ebp], eax

; 3954 : 					petIteminfo.nPos = n;

  0027c	8a 85 e0 f7 ff
	ff		 mov	 al, BYTE PTR _n$2[ebp]
  00282	88 85 e8 f7 ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp], al

; 3955 : 					petIteminfo.nSerial = lpObj->pWarehouse[n].m_Number;

  00288	69 85 e0 f7 ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 168
  00292	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00295	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  0029b	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0029e	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp+4], eax

; 3956 : 					memcpy(pbuffer+lofs, &petIteminfo, sizeof(Request_PetItem_Info));

  002a4	6a 08		 push	 8
  002a6	8d 85 e8 f7 ff
	ff		 lea	 eax, DWORD PTR _petIteminfo$[ebp]
  002ac	50		 push	 eax
  002ad	8b 8d f4 f7 ff
	ff		 mov	 ecx, DWORD PTR _lofs$[ebp]
  002b3	8d 94 0d f8 f7
	ff ff		 lea	 edx, DWORD PTR _pbuffer$[ebp+ecx]
  002ba	52		 push	 edx
  002bb	e8 00 00 00 00	 call	 _memcpy
  002c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3957 : 					lofs+=sizeof(Request_PetItem_Info);

  002c3	8b 85 f4 f7 ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  002c9	83 c0 08	 add	 eax, 8
  002cc	89 85 f4 f7 ff
	ff		 mov	 DWORD PTR _lofs$[ebp], eax
$LN15@gObjReques:

; 3958 : 				}
; 3959 : 			}
; 3960 : 		}

  002d2	e9 d5 fe ff ff	 jmp	 $LN5@gObjReques
$LN9@gObjReques:

; 3961 : 	}
; 3962 : 
; 3963 : 	if( founditemcount )

  002d7	83 bd f0 f7 ff
	ff 00		 cmp	 DWORD PTR _founditemcount$[ebp], 0
  002de	0f 84 89 00 00
	00		 je	 $LN1@gObjReques

; 3964 : 	{
; 3965 : 		SDHP_REQUEST_PETITEM_INFO pMsg;
; 3966 : 		pMsg.h.set((LPBYTE)&pMsg, 0x56,  sizeof(SDHP_REQUEST_PETITEM_INFO)+lofs);

  002e4	8b 85 f4 f7 ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  002ea	83 c0 14	 add	 eax, 20			; 00000014H
  002ed	50		 push	 eax
  002ee	6a 56		 push	 86			; 00000056H
  002f0	8d 8d cc f7 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  002f6	51		 push	 ecx
  002f7	8d 8d cc f7 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  002fd	e8 00 00 00 00	 call	 ?set@PWMSG_HEAD@@QAEXPAEEH@Z ; PWMSG_HEAD::set

; 3967 : 
; 3968 : 		memcpy(pMsg.AccountID, lpObj->AccountID, MAX_IDSTRING);

  00302	6a 0a		 push	 10			; 0000000aH
  00304	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00307	83 c0 68	 add	 eax, 104		; 00000068H
  0030a	50		 push	 eax
  0030b	8d 8d d0 f7 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$1[ebp+4]
  00311	51		 push	 ecx
  00312	e8 00 00 00 00	 call	 _memcpy
  00317	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3969 : 		pMsg.Number = aIndex;

  0031a	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  0031e	66 89 85 dc f7
	ff ff		 mov	 WORD PTR _pMsg$1[ebp+16], ax

; 3970 : 		pMsg.InvenType = inventype;

  00325	8a 45 0c	 mov	 al, BYTE PTR _inventype$[ebp]
  00328	88 85 de f7 ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+18], al

; 3971 : 		pMsg.nCount = founditemcount;

  0032e	8a 85 f0 f7 ff
	ff		 mov	 al, BYTE PTR _founditemcount$[ebp]
  00334	88 85 df f7 ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+19], al

; 3972 : 		
; 3973 : 
; 3974 : 		memcpy(pbuffer, &pMsg, sizeof(SDHP_REQUEST_PETITEM_INFO));

  0033a	6a 14		 push	 20			; 00000014H
  0033c	8d 85 cc f7 ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00342	50		 push	 eax
  00343	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _pbuffer$[ebp]
  00349	51		 push	 ecx
  0034a	e8 00 00 00 00	 call	 _memcpy
  0034f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3975 : 		cDBSMng.Send(pbuffer, sizeof(SDHP_REQUEST_PETITEM_INFO)+lofs);

  00352	8b 85 f4 f7 ff
	ff		 mov	 eax, DWORD PTR _lofs$[ebp]
  00358	83 c0 14	 add	 eax, 20			; 00000014H
  0035b	50		 push	 eax
  0035c	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _pbuffer$[ebp]
  00362	51		 push	 ecx
  00363	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00368	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@gObjReques:

; 3976 : 	}
; 3977 : }

  0036d	5f		 pop	 edi
  0036e	5e		 pop	 esi
  0036f	5b		 pop	 ebx
  00370	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00373	33 cd		 xor	 ecx, ebp
  00375	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037a	8b e5		 mov	 esp, ebp
  0037c	5d		 pop	 ebp
  0037d	c3		 ret	 0
?gObjRequestPetItemInfo@@YAXHH@Z ENDP			; gObjRequestPetItemInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?DGOptionDataSend@@YAXHPADPAEEEEEE@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_szName$ = 12						; size = 4
_KeyBuffer$ = 16					; size = 4
_GO$ = 20						; size = 1
_Qk$ = 24						; size = 1
_Wk$ = 28						; size = 1
_Ek$ = 32						; size = 1
_ChatWnd$ = 36						; size = 1
?DGOptionDataSend@@YAXHPADPAEEEEEE@Z PROC		; DGOptionDataSend, COMDAT

; 3783 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3784 : 	SDHP_SKILLKEYDATA	pMsg;
; 3785 : 
; 3786 : 	pMsg.h.c			= PMHC_BYTE;

  00013	c6 45 e0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 3787 : 	pMsg.h.headcode		= 0x60;

  00017	c6 45 e2 60	 mov	 BYTE PTR _pMsg$[ebp+2], 96 ; 00000060H

; 3788 : 	pMsg.h.size			= sizeof( pMsg );

  0001b	c6 45 e1 1c	 mov	 BYTE PTR _pMsg$[ebp+1], 28 ; 0000001cH

; 3789 : 
; 3790 : 	memcpy(pMsg.Name, szName, MAX_IDSTRING);

  0001f	6a 0a		 push	 10			; 0000000aH
  00021	8b 45 0c	 mov	 eax, DWORD PTR _szName$[ebp]
  00024	50		 push	 eax
  00025	8d 4d e3	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _memcpy
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3791 : #ifdef UPDATE_SKILLKEY_EXPAND_20080804
; 3792 : 	memcpy(pMsg.SkillKeyBuffer, KeyBuffer, 20);
; 3793 : #else	// UPDATE_SKILLKEY_EXPAND_20080804
; 3794 : 	memcpy(pMsg.SkillKeyBuffer, KeyBuffer, 10);

  00031	6a 0a		 push	 10			; 0000000aH
  00033	8b 45 10	 mov	 eax, DWORD PTR _KeyBuffer$[ebp]
  00036	50		 push	 eax
  00037	8d 4d ed	 lea	 ecx, DWORD PTR _pMsg$[ebp+13]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _memcpy
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3795 : #endif	// UPDATE_SKILLKEY_EXPAND_20080804
; 3796 : 	pMsg.GameOption = GO;

  00043	8a 45 14	 mov	 al, BYTE PTR _GO$[ebp]
  00046	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+23], al

; 3797 : 	pMsg.QkeyDefine = Qk;

  00049	8a 45 18	 mov	 al, BYTE PTR _Qk$[ebp]
  0004c	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+24], al

; 3798 : 	pMsg.WkeyDefine = Wk;

  0004f	8a 45 1c	 mov	 al, BYTE PTR _Wk$[ebp]
  00052	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+25], al

; 3799 : 	pMsg.EkeyDefine = Ek;

  00055	8a 45 20	 mov	 al, BYTE PTR _Ek$[ebp]
  00058	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+26], al

; 3800 : 
; 3801 : #ifdef VER_CHATWINDOW_OPTION
; 3802 : 	pMsg.ChatWindow = ChatWnd;

  0005b	8a 45 24	 mov	 al, BYTE PTR _ChatWnd$[ebp]
  0005e	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+27], al

; 3803 : #endif
; 3804 : 
; 3805 : #ifdef ADD_SEASON_3_NEW_UI_20071122 
; 3806 : 	pMsg.RkeyDefine = Rk;
; 3807 : #endif
; 3808 : 
; 3809 : #ifdef UPDATE_OPTIONKEY_LEVEL_20080116
; 3810 : 	pMsg.QWERLevel	= QWERLevel;
; 3811 : #endif
; 3812 : 
; 3813 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00061	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00065	50		 push	 eax
  00066	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00069	51		 push	 ecx
  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0006f	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 3814 : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007a	33 cd		 xor	 ecx, ebp
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?DGOptionDataSend@@YAXHPADPAEEEEEE@Z ENDP		; DGOptionDataSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?GDSetWarehouseMoney@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDSetWarehouseMoney@@YAXH@Z PROC			; GDSetWarehouseMoney, COMDAT

; 2836 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2837 : #if (DATANOSAVE == 1)
; 2838 : 	return;
; 2839 : #endif
; 2840 : 
; 2841 : 	SDHP_WAREHOUSEMONEY_SAVE	pMsg;
; 2842 : 	
; 2843 : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, MAX_IDSTRING);

  00013	6a 0a		 push	 10			; 0000000aH
  00015	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00022	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00026	52		 push	 edx
  00027	8d 45 eb	 lea	 eax, DWORD PTR _pMsg$[ebp+3]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _memcpy
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2844 : 	pMsg.aIndex		= aIndex;

  00033	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  00037	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 2845 : 	pMsg.h.c		= PMHC_BYTE;

  0003b	c6 45 e8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 2846 : 	pMsg.h.headcode = 0x12;

  0003f	c6 45 ea 12	 mov	 BYTE PTR _pMsg$[ebp+2], 18 ; 00000012H

; 2847 : 	pMsg.h.size     = sizeof( pMsg );

  00043	c6 45 e9 14	 mov	 BYTE PTR _pMsg$[ebp+1], 20 ; 00000014H

; 2848 : 	pMsg.Money      = gObj[aIndex].WarehouseMoney;

  00047	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00054	8b 94 01 a4 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3236]
  0005b	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+16], edx

; 2849 : 	
; 2850 : 	cDBSMng.Send((char*)&pMsg, sizeof( pMsg ));

  0005e	6a 14		 push	 20			; 00000014H
  00060	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00063	50		 push	 eax
  00064	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00069	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2851 : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	33 cd		 xor	 ecx, ebp
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?GDSetWarehouseMoney@@YAXH@Z ENDP			; GDSetWarehouseMoney
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?GDSetWarehouseList@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -1228						; size = 1224
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDSetWarehouseList@@YAXH@Z PROC			; GDSetWarehouseList, COMDAT

; 2766 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 05 00
	00		 sub	 esp, 1420		; 0000058cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2767 : 	if( !gObj[aIndex].LoadWareHouseInfo )

  00016	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	0f b6 94 01 88
	0e 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3720]
  0002b	85 d2		 test	 edx, edx
  0002d	75 37		 jne	 SHORT $LN2@GDSetWareh

; 2768 : 	{
; 2769 : 		LogAddTD("[%s][%s] WareHouse Save Fail : Not Open", 

  0002f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003c	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00040	52		 push	 edx
  00041	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00052	52		 push	 edx
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5@
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2770 : 			     gObj[aIndex].AccountID, gObj[aIndex].Name);
; 2771 : 		return;

  00061	e9 dd 00 00 00	 jmp	 $LN1@GDSetWareh
$LN2@GDSetWareh:

; 2772 : 	}
; 2773 : 
; 2774 : 	SDHP_GETWAREHOUSEDB_SAVE	pMsg;
; 2775 : 
; 2776 : #if (DATANOSAVE == 1)
; 2777 : 	return;
; 2778 : #endif
; 2779 : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, MAX_IDSTRING);

  00066	6a 0a		 push	 10			; 0000000aH
  00068	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00075	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00079	52		 push	 edx
  0007a	8d 85 38 fb ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _memcpy
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2780 : 	pMsg.aIndex		= aIndex;

  00089	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  0008d	66 89 85 42 fb
	ff ff		 mov	 WORD PTR _pMsg$[ebp+14], ax

; 2781 : 	pMsg.h.c		= PMHC_WORD;

  00094	c6 85 34 fb ff
	ff c2		 mov	 BYTE PTR _pMsg$[ebp], 194 ; 000000c2H

; 2782 : 	pMsg.h.headcode = 0x09;

  0009b	c6 85 37 fb ff
	ff 09		 mov	 BYTE PTR _pMsg$[ebp+3], 9

; 2783 : 	pMsg.h.sizeH    = HIBYTE( sizeof( pMsg ) );

  000a2	c6 85 35 fb ff
	ff 04		 mov	 BYTE PTR _pMsg$[ebp+1], 4

; 2784 : 	pMsg.h.sizeL    = LOBYTE( sizeof( pMsg ) );

  000a9	c6 85 36 fb ff
	ff c8		 mov	 BYTE PTR _pMsg$[ebp+2], 200 ; 000000c8H

; 2785 : 	pMsg.Money      = gObj[aIndex].WarehouseMoney;

  000b0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bd	8b 94 01 a4 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3236]
  000c4	89 95 44 fb ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+16], edx

; 2786 : 	pMsg.pw			= gObj[aIndex].WarehousePW;

  000ca	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d7	66 8b 94 01 9e
	0c 00 00	 mov	 dx, WORD PTR [ecx+eax+3230]
  000df	66 89 55 fa	 mov	 WORD PTR _pMsg$[ebp+1222], dx

; 2787 : 
; 2788 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 2789 : 	ItemByteConvert16(pMsg.dbItems, gObj[aIndex].pWarehouse, MAX_WAREHOUSEITEMS);
; 2790 : #else
; 2791 : 	ItemByteConvert10(pMsg.dbItems, gObj[aIndex].pWarehouse, MAX_WAREHOUSEITEMS);

  000e3	6a 78		 push	 120			; 00000078H
  000e5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f2	8b 94 01 94 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3220]
  000f9	52		 push	 edx
  000fa	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+20]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?ItemByteConvert10@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert10
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2792 : #endif
; 2793 : 	
; 2794 : 	cDBSMng.Send((char*)&pMsg, sizeof( pMsg ));

  00109	68 c8 04 00 00	 push	 1224			; 000004c8H
  0010e	8d 85 34 fb ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00114	50		 push	 eax
  00115	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0011a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2795 : 
; 2796 : #ifdef DARKLORD_WORK	// 펫 아이템 정보도 저장한다
; 2797 : 	gObjSavePetItemInfo(aIndex, 1);

  0011f	6a 01		 push	 1
  00121	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ?gObjSavePetItemInfo@@YAXHH@Z ; gObjSavePetItemInfo
  0012a	83 c4 08	 add	 esp, 8

; 2798 : #endif
; 2799 : 
; 2800 : 	gObjWarehouseTextSave(&gObj[aIndex]);

  0012d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00134	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?gObjWarehouseTextSave@@YAXPAVOBJECTSTRUCT@@@Z ; gObjWarehouseTextSave
  00140	83 c4 04	 add	 esp, 4
$LN1@GDSetWareh:

; 2801 : }

  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx
  00146	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00149	33 cd		 xor	 ecx, ebp
  0014b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
?GDSetWarehouseList@@YAXH@Z ENDP			; GDSetWarehouseList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?GDGetWarehouseList@@YAXHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_AccountID$ = 12					; size = 4
?GDGetWarehouseList@@YAXHPAD@Z PROC			; GDGetWarehouseList, COMDAT

; 2274 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2275 : 
; 2276 : 	if( strlen(AccountID) < 1 ) return;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _AccountID$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _strlen
  0001c	83 c4 04	 add	 esp, 4
  0001f	83 f8 01	 cmp	 eax, 1
  00022	73 02		 jae	 SHORT $LN2@GDGetWareh
  00024	eb 5d		 jmp	 SHORT $LN1@GDGetWareh
$LN2@GDGetWareh:

; 2277 : 
; 2278 : 	SDHP_GETWAREHOUSEDB		pMsg;
; 2279 : 	
; 2280 : 	pMsg.h.c		= PMHC_BYTE;

  00026	c6 45 ec c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 2281 : 	pMsg.h.headcode	= 0x08;

  0002a	c6 45 ee 08	 mov	 BYTE PTR _pMsg$[ebp+2], 8

; 2282 : 	pMsg.h.size		= sizeof( pMsg );

  0002e	c6 45 ed 10	 mov	 BYTE PTR _pMsg$[ebp+1], 16 ; 00000010H

; 2283 : 	pMsg.aIndex		= (short)aIndex;

  00032	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  00036	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 2284 : 
; 2285 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 2286 : 	//창고 요청
; 2287 : 	LogAddTD_TempLog(", [G->D Req GetWarehouseList], Account [%s], IP [%s] ", AccountID, gObj[aIndex].Ip_addr);

  0003a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00047	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0004b	52		 push	 edx
  0004c	8b 45 0c	 mov	 eax, DWORD PTR _AccountID$[ebp]
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@DAPPAGFG@?0?5?$FLG?9?$DOD?5Req?5GetWarehouseList?$FN?0?5@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2288 : #endif
; 2289 : 
; 2290 : 	memcpy(pMsg.AccountID, AccountID, MAX_IDSTRING);

  0005e	6a 0a		 push	 10			; 0000000aH
  00060	8b 45 0c	 mov	 eax, DWORD PTR _AccountID$[ebp]
  00063	50		 push	 eax
  00064	8d 4d ef	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _memcpy
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2291 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00070	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00074	50		 push	 eax
  00075	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00078	51		 push	 ecx
  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0007e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GDGetWareh:

; 2292 : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?GDGetWarehouseList@@YAXHPAD@Z ENDP			; GDGetWarehouseList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z
_TEXT	SEGMENT
_pMsg$ = -80						; size = 76
__$ArrayPad$ = -4					; size = 4
_ActID$ = 8						; size = 4
_Name$ = 12						; size = 4
_level$ = 16						; size = 1
_mapnumber$ = 20					; size = 1
_x$ = 24						; size = 1
_y$ = 28						; size = 1
_Item$ = 32						; size = 4
_op1$ = 36						; size = 1
_op2$ = 40						; size = 1
_op3$ = 44						; size = 1
_serial$ = 48						; size = 4
?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z PROC		; ItemMovePathSave, COMDAT

; 3747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3748 : 	SDHP_ITEMMOVESAVE	pMsg;
; 3749 : 
; 3750 : 	pMsg.h.c = PMHC_BYTE;

  00016	c6 45 b0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 3751 : 	pMsg.h.headcode	= 0x53;

  0001a	c6 45 b2 53	 mov	 BYTE PTR _pMsg$[ebp+2], 83 ; 00000053H

; 3752 : 	pMsg.h.size = sizeof( pMsg );

  0001e	c6 45 b1 4c	 mov	 BYTE PTR _pMsg$[ebp+1], 76 ; 0000004cH

; 3753 : 	
; 3754 : 	pMsg.ItemLevel  = level;

  00022	8a 45 10	 mov	 al, BYTE PTR _level$[ebp]
  00025	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+71], al

; 3755 : 	pMsg.Serial		= serial;

  00028	8b 45 30	 mov	 eax, DWORD PTR _serial$[ebp]
  0002b	89 45 b4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 3756 : 	pMsg.ItemOp1 = op1;

  0002e	8a 45 24	 mov	 al, BYTE PTR _op1$[ebp]
  00031	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+72], al

; 3757 : 	pMsg.ItemOp2 = op2;

  00034	8a 45 28	 mov	 al, BYTE PTR _op2$[ebp]
  00037	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+73], al

; 3758 : 	pMsg.ItemOp3 = op3;

  0003a	8a 45 2c	 mov	 al, BYTE PTR _op3$[ebp]
  0003d	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+74], al

; 3759 : 	pMsg.X		 = x;

  00040	8a 45 18	 mov	 al, BYTE PTR _x$[ebp]
  00043	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+69], al

; 3760 : 	pMsg.Y		 = y;

  00046	8a 45 1c	 mov	 al, BYTE PTR _y$[ebp]
  00049	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+70], al

; 3761 : 	memcpy(pMsg.Account, ActID, MAX_IDSTRING);

  0004c	6a 0a		 push	 10			; 0000000aH
  0004e	8b 45 08	 mov	 eax, DWORD PTR _ActID$[ebp]
  00051	50		 push	 eax
  00052	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp+28]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 _memcpy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3762 : 	strcpy(pMsg.ItemName, Item);

  0005e	8b 45 20	 mov	 eax, DWORD PTR _Item$[ebp]
  00061	50		 push	 eax
  00062	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp+48]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 _strcpy
  0006b	83 c4 08	 add	 esp, 8

; 3763 : 	memcpy(pMsg.Name, Name, MAX_IDSTRING);

  0006e	6a 0a		 push	 10			; 0000000aH
  00070	8b 45 0c	 mov	 eax, DWORD PTR _Name$[ebp]
  00073	50		 push	 eax
  00074	8d 4d d6	 lea	 ecx, DWORD PTR _pMsg$[ebp+38]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _memcpy
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3764 : 	strcpy(pMsg.ServerName, szServerName);

  00080	68 00 00 00 00	 push	 OFFSET ?szServerName@@3PADA ; szServerName
  00085	8d 45 b8	 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _strcpy
  0008e	83 c4 08	 add	 esp, 8

; 3765 : 
; 3766 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00091	0f b6 45 b1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00095	50		 push	 eax
  00096	8d 4d b0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00099	51		 push	 ecx
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0009f	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 3767 : }

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000aa	33 cd		 xor	 ecx, ebp
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z ENDP		; ItemMovePathSave
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_type$ = 24						; size = 4
_level$ = 28						; size = 1
_dur$ = 32						; size = 1
_Op1$ = 36						; size = 1
_Op2$ = 40						; size = 1
_Op3$ = 44						; size = 1
_LootIndex$ = 48					; size = 4
_NewOption$ = 52					; size = 1
_SetOption$ = 56					; size = 1
?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z PROC	; PetItemSerialCreateSend, COMDAT

; 2948 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2949 : 	SDHP_ITEMCREATE	pMsg;
; 2950 : 
; 2951 : 	pMsg.h.c		= PMHC_BYTE;

  00013	c6 45 e0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 2952 : 	pMsg.h.headcode	= 0x55;

  00017	c6 45 e2 55	 mov	 BYTE PTR _pMsg$[ebp+2], 85 ; 00000055H

; 2953 : 	pMsg.h.size		= sizeof( pMsg );

  0001b	c6 45 e1 1c	 mov	 BYTE PTR _pMsg$[ebp+1], 28 ; 0000001cH

; 2954 : 	pMsg.MapNumber	= MapNumber;

  0001f	8a 45 0c	 mov	 al, BYTE PTR _MapNumber$[ebp]
  00022	88 45 e5	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 2955 : 	pMsg.x			= x;

  00025	8a 45 10	 mov	 al, BYTE PTR _x$[ebp]
  00028	88 45 e3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2956 : 	pMsg.y			= y;

  0002b	8a 45 14	 mov	 al, BYTE PTR _y$[ebp]
  0002e	88 45 e4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2957 : 	pMsg.Type		= (short)type;

  00031	66 8b 45 18	 mov	 ax, WORD PTR _type$[ebp]
  00035	66 89 45 e6	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 2958 : 	pMsg.Level		= level;

  00039	8a 45 1c	 mov	 al, BYTE PTR _level$[ebp]
  0003c	88 45 e8	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 2959 : 	
; 2960 : 	// 2003/02/28 내구력 수치를 얻어 기본 세팅함
; 2961 : 	// pMsg.Dur		= dur;
; 2962 : 
; 2963 : 	if( dur == 0 )

  0003f	0f b6 45 20	 movzx	 eax, BYTE PTR _dur$[ebp]
  00043	85 c0		 test	 eax, eax
  00045	75 1e		 jne	 SHORT $LN2@PetItemSer

; 2964 : 	{
; 2965 : 		dur = ItemGetDurability(type, level, NewOption, SetOption);

  00047	0f b6 45 38	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  0004b	50		 push	 eax
  0004c	0f b6 4d 34	 movzx	 ecx, BYTE PTR _NewOption$[ebp]
  00050	51		 push	 ecx
  00051	0f b6 55 1c	 movzx	 edx, BYTE PTR _level$[ebp]
  00055	52		 push	 edx
  00056	8b 45 18	 mov	 eax, DWORD PTR _type$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	88 45 20	 mov	 BYTE PTR _dur$[ebp], al
$LN2@PetItemSer:

; 2966 : 	}
; 2967 : 
; 2968 : 	pMsg.Dur		= dur;

  00065	8a 45 20	 mov	 al, BYTE PTR _dur$[ebp]
  00068	88 45 e9	 mov	 BYTE PTR _pMsg$[ebp+9], al

; 2969 : 
; 2970 : 	pMsg.Op1		= Op1;

  0006b	8a 45 24	 mov	 al, BYTE PTR _Op1$[ebp]
  0006e	88 45 ea	 mov	 BYTE PTR _pMsg$[ebp+10], al

; 2971 : 	pMsg.Op2		= Op2;

  00071	8a 45 28	 mov	 al, BYTE PTR _Op2$[ebp]
  00074	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 2972 : 	pMsg.Op3		= Op3;

  00077	8a 45 2c	 mov	 al, BYTE PTR _Op3$[ebp]
  0007a	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 2973 : 	pMsg.NewOption	= NewOption;

  0007d	8a 45 34	 mov	 al, BYTE PTR _NewOption$[ebp]
  00080	88 45 ed	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 2974 : 	pMsg.aIndex		= aIndex;

  00083	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00086	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 2975 : 	pMsg.lootindex	= LootIndex;

  00089	66 8b 45 30	 mov	 ax, WORD PTR _LootIndex$[ebp]
  0008d	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 2976 : 
; 2977 : 	pMsg.SetOption = SetOption;

  00091	8a 45 38	 mov	 al, BYTE PTR _SetOption$[ebp]
  00094	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+22], al

; 2978 : 
; 2979 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00097	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0009b	50		 push	 eax
  0009c	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0009f	51		 push	 ecx
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000a5	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2980 : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ENDP	; PetItemSerialCreateSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z
_TEXT	SEGMENT
tv84 = -120						; size = 4
tv85 = -116						; size = 4
$T1 = -112						; size = 4
_i$2 = -44						; size = 4
_NewOption$3 = -40					; size = 8
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_type$ = 24						; size = 4
_level$ = 28						; size = 1
_dur$ = 32						; size = 1
_Op1$ = 36						; size = 1
_Op2$ = 40						; size = 1
_Op3$ = 44						; size = 1
_LootIndex$ = 48					; size = 4
_NewOption$ = 52					; size = 1
_SetOption$ = 56					; size = 1
_SpecialShop$ = 60					; size = 4
?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z PROC		; ItemSerialCreateSend, COMDAT

; 2869 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2870 : 	if(ItemAttribute[type].HaveItemInfo == FALSE)

  00013	6b 45 18 6c	 imul	 eax, DWORD PTR _type$[ebp], 108
  00017	0f b6 88 20 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+32]
  0001e	85 c9		 test	 ecx, ecx
  00020	75 17		 jne	 SHORT $LN5@ItemSerial

; 2871 : 	{
; 2872 : 		LogAddTD("[ERROR] Item doesn't exists %d", type);

  00022	8b 45 18	 mov	 eax, DWORD PTR _type$[ebp]
  00025	50		 push	 eax
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@KBPACLIK@?$FLERROR?$FN?5Item?5doesn?8t?5exists?5?$CFd@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00031	83 c4 08	 add	 esp, 8

; 2873 : 		return;

  00034	e9 5e 02 00 00	 jmp	 $LN14@ItemSerial
$LN5@ItemSerial:

; 2874 : 	}
; 2875 : 
; 2876 : 	SDHP_ITEMCREATE	pMsg;
; 2877 : 
; 2878 : 	pMsg.h.c		= PMHC_BYTE;

  00039	c6 45 e0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 2879 : 	pMsg.h.headcode	= 0x52;

  0003d	c6 45 e2 52	 mov	 BYTE PTR _pMsg$[ebp+2], 82 ; 00000052H

; 2880 : 	pMsg.h.size		= sizeof( pMsg );

  00041	c6 45 e1 1c	 mov	 BYTE PTR _pMsg$[ebp+1], 28 ; 0000001cH

; 2881 : 	pMsg.MapNumber	= MapNumber;

  00045	8a 45 0c	 mov	 al, BYTE PTR _MapNumber$[ebp]
  00048	88 45 e5	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 2882 : 	pMsg.x			= x;

  0004b	8a 45 10	 mov	 al, BYTE PTR _x$[ebp]
  0004e	88 45 e3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2883 : 	pMsg.y			= y;

  00051	8a 45 14	 mov	 al, BYTE PTR _y$[ebp]
  00054	88 45 e4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2884 : 	pMsg.Type		= (short)type;

  00057	66 8b 45 18	 mov	 ax, WORD PTR _type$[ebp]
  0005b	66 89 45 e6	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 2885 : 	pMsg.Level		= level;

  0005f	8a 45 1c	 mov	 al, BYTE PTR _level$[ebp]
  00062	88 45 e8	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 2886 : 	
; 2887 : 	// 2003/02/28 내구력 수치를 얻어 기본 세팅함
; 2888 : 	// pMsg.Dur		= dur;
; 2889 : 
; 2890 : 	if( dur == 0 )

  00065	0f b6 45 20	 movzx	 eax, BYTE PTR _dur$[ebp]
  00069	85 c0		 test	 eax, eax
  0006b	75 1e		 jne	 SHORT $LN6@ItemSerial

; 2891 : 	{
; 2892 : 		dur = ItemGetDurability(type, level, NewOption, SetOption);

  0006d	0f b6 45 38	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  00071	50		 push	 eax
  00072	0f b6 4d 34	 movzx	 ecx, BYTE PTR _NewOption$[ebp]
  00076	51		 push	 ecx
  00077	0f b6 55 1c	 movzx	 edx, BYTE PTR _level$[ebp]
  0007b	52		 push	 edx
  0007c	8b 45 18	 mov	 eax, DWORD PTR _type$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00085	83 c4 10	 add	 esp, 16			; 00000010H
  00088	88 45 20	 mov	 BYTE PTR _dur$[ebp], al
$LN6@ItemSerial:

; 2893 : 	}
; 2894 : 
; 2895 : 	pMsg.Dur		= dur;

  0008b	8a 45 20	 mov	 al, BYTE PTR _dur$[ebp]
  0008e	88 45 e9	 mov	 BYTE PTR _pMsg$[ebp+9], al

; 2896 : 
; 2897 : 	pMsg.Op1		= Op1;

  00091	8a 45 24	 mov	 al, BYTE PTR _Op1$[ebp]
  00094	88 45 ea	 mov	 BYTE PTR _pMsg$[ebp+10], al

; 2898 : 	pMsg.Op2		= Op2;

  00097	8a 45 28	 mov	 al, BYTE PTR _Op2$[ebp]
  0009a	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 2899 : 	pMsg.Op3		= Op3;

  0009d	8a 45 2c	 mov	 al, BYTE PTR _Op3$[ebp]
  000a0	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 2900 : 	pMsg.NewOption	= NewOption;

  000a3	8a 45 34	 mov	 al, BYTE PTR _NewOption$[ebp]
  000a6	88 45 ed	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 2901 : 	pMsg.aIndex		= aIndex;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000ac	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 2902 : 	pMsg.lootindex	= LootIndex;

  000af	66 8b 45 30	 mov	 ax, WORD PTR _LootIndex$[ebp]
  000b3	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 2903 : 
; 2904 : 	pMsg.SetOption = SetOption;

  000b7	8a 45 38	 mov	 al, BYTE PTR _SetOption$[ebp]
  000ba	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+22], al

; 2905 : 
; 2906 : 	pMsg.SpecialShop = SpecialShop;

  000bd	8b 45 3c	 mov	 eax, DWORD PTR _SpecialShop$[ebp]
  000c0	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 2907 : 
; 2908 : #ifdef MONSTER_ITEMDROP_LOG_ADD_NAME_20041202		// 몬스터가 아이템을 드롭한다는 로그를 남김
; 2909 : 	if (CHECK_LIMIT(aIndex, MAX_OBJECT) && gObj[aIndex].Type != OBJTYPE_CHARACTER) 

  000c3	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  000c7	7d 09		 jge	 SHORT $LN17@ItemSerial
  000c9	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  000d0	eb 1f		 jmp	 SHORT $LN18@ItemSerial
$LN17@ItemSerial:
  000d2	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  000d9	7e 09		 jle	 SHORT $LN15@ItemSerial
  000db	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
  000e2	eb 07		 jmp	 SHORT $LN16@ItemSerial
$LN15@ItemSerial:
  000e4	c7 45 88 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
$LN16@ItemSerial:
  000eb	8b 45 88	 mov	 eax, DWORD PTR tv84[ebp]
  000ee	89 45 8c	 mov	 DWORD PTR tv85[ebp], eax
$LN18@ItemSerial:
  000f1	83 7d 8c 00	 cmp	 DWORD PTR tv85[ebp], 0
  000f5	0f 84 89 01 00
	00		 je	 $LN7@ItemSerial
  000fb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00102	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00108	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0010d	83 fa 01	 cmp	 edx, 1
  00110	0f 84 6e 01 00
	00		 je	 $LN7@ItemSerial

; 2910 : 	{
; 2911 : 		// 사람이 아닌 -> 몬스터라면 로그를 남긴다.
; 2912 : 		BYTE NewOption[8];
; 2913 : 		for( int i=0; i<8; i++) NewOption[i]=0;

  00116	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0011d	eb 09		 jmp	 SHORT $LN4@ItemSerial
$LN2@ItemSerial:
  0011f	8b 45 d4	 mov	 eax, DWORD PTR _i$2[ebp]
  00122	83 c0 01	 add	 eax, 1
  00125	89 45 d4	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@ItemSerial:
  00128	83 7d d4 08	 cmp	 DWORD PTR _i$2[ebp], 8
  0012c	7d 1d		 jge	 SHORT $LN3@ItemSerial
  0012e	8b 45 d4	 mov	 eax, DWORD PTR _i$2[ebp]
  00131	89 45 90	 mov	 DWORD PTR $T1[ebp], eax
  00134	83 7d 90 08	 cmp	 DWORD PTR $T1[ebp], 8
  00138	73 02		 jae	 SHORT $LN19@ItemSerial
  0013a	eb 05		 jmp	 SHORT $LN20@ItemSerial
$LN19@ItemSerial:
  0013c	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN20@ItemSerial:
  00141	8b 4d 90	 mov	 ecx, DWORD PTR $T1[ebp]
  00144	c6 44 0d d8 00	 mov	 BYTE PTR _NewOption$3[ebp+ecx], 0
  00149	eb d4		 jmp	 SHORT $LN2@ItemSerial
$LN3@ItemSerial:

; 2914 : 
; 2915 : 		if( pMsg.NewOption&0x20) NewOption[0] = 1;

  0014b	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  0014f	83 e0 20	 and	 eax, 32			; 00000020H
  00152	74 0d		 je	 SHORT $LN8@ItemSerial
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	6b c8 00	 imul	 ecx, eax, 0
  0015c	c6 44 0d d8 01	 mov	 BYTE PTR _NewOption$3[ebp+ecx], 1
$LN8@ItemSerial:

; 2916 : 		if( pMsg.NewOption&0x10) NewOption[1] = 1;

  00161	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  00165	83 e0 10	 and	 eax, 16			; 00000010H
  00168	74 0d		 je	 SHORT $LN9@ItemSerial
  0016a	b8 01 00 00 00	 mov	 eax, 1
  0016f	c1 e0 00	 shl	 eax, 0
  00172	c6 44 05 d8 01	 mov	 BYTE PTR _NewOption$3[ebp+eax], 1
$LN9@ItemSerial:

; 2917 : 		if( pMsg.NewOption&0x08) NewOption[2] = 1;

  00177	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  0017b	83 e0 08	 and	 eax, 8
  0017e	74 0c		 je	 SHORT $LN10@ItemSerial
  00180	b8 01 00 00 00	 mov	 eax, 1
  00185	d1 e0		 shl	 eax, 1
  00187	c6 44 05 d8 01	 mov	 BYTE PTR _NewOption$3[ebp+eax], 1
$LN10@ItemSerial:

; 2918 : 		if( pMsg.NewOption&0x04) NewOption[3] = 1;

  0018c	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  00190	83 e0 04	 and	 eax, 4
  00193	74 0d		 je	 SHORT $LN11@ItemSerial
  00195	b8 01 00 00 00	 mov	 eax, 1
  0019a	6b c8 03	 imul	 ecx, eax, 3
  0019d	c6 44 0d d8 01	 mov	 BYTE PTR _NewOption$3[ebp+ecx], 1
$LN11@ItemSerial:

; 2919 : 		if( pMsg.NewOption&0x02) NewOption[4] = 1;

  001a2	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  001a6	83 e0 02	 and	 eax, 2
  001a9	74 0d		 je	 SHORT $LN12@ItemSerial
  001ab	b8 01 00 00 00	 mov	 eax, 1
  001b0	c1 e0 02	 shl	 eax, 2
  001b3	c6 44 05 d8 01	 mov	 BYTE PTR _NewOption$3[ebp+eax], 1
$LN12@ItemSerial:

; 2920 : 		if( pMsg.NewOption&0x01) NewOption[5] = 1;

  001b8	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+13]
  001bc	83 e0 01	 and	 eax, 1
  001bf	74 0d		 je	 SHORT $LN13@ItemSerial
  001c1	b8 01 00 00 00	 mov	 eax, 1
  001c6	6b c8 05	 imul	 ecx, eax, 5
  001c9	c6 44 0d d8 01	 mov	 BYTE PTR _NewOption$3[ebp+ecx], 1
$LN13@ItemSerial:

; 2921 : 
; 2922 : 		LogAddTD("Monster Item Drop Request [%s] [%d][%d][%d] : [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", 

  001ce	0f b6 45 f6	 movzx	 eax, BYTE PTR _pMsg$[ebp+22]
  001d2	50		 push	 eax
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	6b d1 06	 imul	 edx, ecx, 6
  001db	0f b6 44 15 d8	 movzx	 eax, BYTE PTR _NewOption$3[ebp+edx]
  001e0	50		 push	 eax
  001e1	b9 01 00 00 00	 mov	 ecx, 1
  001e6	6b d1 05	 imul	 edx, ecx, 5
  001e9	0f b6 44 15 d8	 movzx	 eax, BYTE PTR _NewOption$3[ebp+edx]
  001ee	50		 push	 eax
  001ef	b9 01 00 00 00	 mov	 ecx, 1
  001f4	c1 e1 02	 shl	 ecx, 2
  001f7	0f b6 54 0d d8	 movzx	 edx, BYTE PTR _NewOption$3[ebp+ecx]
  001fc	52		 push	 edx
  001fd	b8 01 00 00 00	 mov	 eax, 1
  00202	6b c8 03	 imul	 ecx, eax, 3
  00205	0f b6 54 0d d8	 movzx	 edx, BYTE PTR _NewOption$3[ebp+ecx]
  0020a	52		 push	 edx
  0020b	b8 01 00 00 00	 mov	 eax, 1
  00210	d1 e0		 shl	 eax, 1
  00212	0f b6 4c 05 d8	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00217	51		 push	 ecx
  00218	ba 01 00 00 00	 mov	 edx, 1
  0021d	c1 e2 00	 shl	 edx, 0
  00220	0f b6 44 15 d8	 movzx	 eax, BYTE PTR _NewOption$3[ebp+edx]
  00225	50		 push	 eax
  00226	b9 01 00 00 00	 mov	 ecx, 1
  0022b	6b d1 00	 imul	 edx, ecx, 0
  0022e	0f b6 44 15 d8	 movzx	 eax, BYTE PTR _NewOption$3[ebp+edx]
  00233	50		 push	 eax
  00234	0f b6 4d ec	 movzx	 ecx, BYTE PTR _pMsg$[ebp+12]
  00238	51		 push	 ecx
  00239	0f b6 55 eb	 movzx	 edx, BYTE PTR _pMsg$[ebp+11]
  0023d	52		 push	 edx
  0023e	0f b6 45 ea	 movzx	 eax, BYTE PTR _pMsg$[ebp+10]
  00242	50		 push	 eax
  00243	0f b6 4d e8	 movzx	 ecx, BYTE PTR _pMsg$[ebp+8]
  00247	51		 push	 ecx
  00248	0f bf 55 e6	 movsx	 edx, WORD PTR _pMsg$[ebp+6]
  0024c	6b c2 6c	 imul	 eax, edx, 108
  0024f	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00254	50		 push	 eax
  00255	0f b6 4d e4	 movzx	 ecx, BYTE PTR _pMsg$[ebp+4]
  00259	51		 push	 ecx
  0025a	0f b6 55 e3	 movzx	 edx, BYTE PTR _pMsg$[ebp+3]
  0025e	52		 push	 edx
  0025f	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00263	50		 push	 eax
  00264	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0026b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00271	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00275	50		 push	 eax
  00276	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@PDKAJKAJ@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5@
  0027b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00281	83 c4 48	 add	 esp, 72			; 00000048H
$LN7@ItemSerial:

; 2923 : 				gObj[aIndex].Name,
; 2924 : 				MapNumber, pMsg.x, pMsg.y,
; 2925 : 				ItemAttribute[pMsg.Type].Name, 				
; 2926 : 				pMsg.Level, 
; 2927 : 				pMsg.Op1, 
; 2928 : 				pMsg.Op2, 
; 2929 : 				pMsg.Op3,
; 2930 : 				NewOption[0],
; 2931 : 				NewOption[1],
; 2932 : 				NewOption[2],
; 2933 : 				NewOption[3],
; 2934 : 				NewOption[4],
; 2935 : 				NewOption[5],
; 2936 : 				NewOption[6],
; 2937 : 				pMsg.SetOption
; 2938 : 			   );
; 2939 : 	}
; 2940 : #endif
; 2941 : 
; 2942 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00284	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00288	50		 push	 eax
  00289	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0028c	51		 push	 ecx
  0028d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00292	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN14@ItemSerial:

; 2943 : }

  00297	5f		 pop	 edi
  00298	5e		 pop	 esi
  00299	5b		 pop	 ebx
  0029a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029d	33 cd		 xor	 ecx, ebp
  0029f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a4	8b e5		 mov	 esp, ebp
  002a6	5d		 pop	 ebp
  002a7	c3		 ret	 0
?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ENDP		; ItemSerialCreateSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?JGCharacterCreateFailSend@@YAXHPAD@Z
_TEXT	SEGMENT
_pResult$ = -48						; size = 42
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_id$ = 12						; size = 4
?JGCharacterCreateFailSend@@YAXHPAD@Z PROC		; JGCharacterCreateFailSend, COMDAT

; 1684 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1685 : 	PMSG_CHARCREATERESULT	pResult;
; 1686 : 	
; 1687 : 	pResult.h.c        = PMHC_BYTE;

  00013	c6 45 d0 c1	 mov	 BYTE PTR _pResult$[ebp], 193 ; 000000c1H

; 1688 : 	pResult.h.size     = sizeof( pResult );

  00017	c6 45 d1 2a	 mov	 BYTE PTR _pResult$[ebp+1], 42 ; 0000002aH

; 1689 : 	pResult.h.headcode = 0xF3;

  0001b	c6 45 d2 f3	 mov	 BYTE PTR _pResult$[ebp+2], 243 ; 000000f3H

; 1690 : 	pResult.subcode    = 0x01;

  0001f	c6 45 d3 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 1691 : 	pResult.Result     = 0x00;

  00023	c6 45 d4 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 1692 : 	pResult.pos        = 0x00;

  00027	c6 45 df 00	 mov	 BYTE PTR _pResult$[ebp+15], 0

; 1693 : 	memcpy(pResult.Name, id, MAX_IDSTRING);

  0002b	6a 0a		 push	 10			; 0000000aH
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  00030	50		 push	 eax
  00031	8d 4d d5	 lea	 ecx, DWORD PTR _pResult$[ebp+5]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _memcpy
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 : 
; 1695 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0003d	0f b6 45 d1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00041	50		 push	 eax
  00042	8d 4d d0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00045	51		 push	 ecx
  00046	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1696 : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	33 cd		 xor	 ecx, ebp
  0005a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?JGCharacterCreateFailSend@@YAXHPAD@Z ENDP		; JGCharacterCreateFailSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?GDUserItemSave@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -1100						; size = 1094
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GDUserItemSave@@YAXPAVOBJECTSTRUCT@@@Z PROC		; GDUserItemSave, COMDAT

; 2806 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 05 00
	00		 sub	 esp, 1292		; 0000050cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2807 : #if (DATANOSAVE == 1)
; 2808 : 	return;
; 2809 : #endif
; 2810 : 
; 2811 : 	SDHP_DBCHAR_ITEMSAVE	pMsg;
; 2812 : 
; 2813 : 	pMsg.h.c		= PMHC_WORD;

  00016	c6 85 b4 fb ff
	ff c2		 mov	 BYTE PTR _pMsg$[ebp], 194 ; 000000c2H

; 2814 : 	pMsg.h.headcode = 0x11;

  0001d	c6 85 b7 fb ff
	ff 11		 mov	 BYTE PTR _pMsg$[ebp+3], 17 ; 00000011H

; 2815 : 	pMsg.h.sizeH    = HIBYTE( sizeof( pMsg ) );

  00024	c6 85 b5 fb ff
	ff 04		 mov	 BYTE PTR _pMsg$[ebp+1], 4

; 2816 : 	pMsg.h.sizeL    = LOBYTE( sizeof( pMsg ) );

  0002b	c6 85 b6 fb ff
	ff 46		 mov	 BYTE PTR _pMsg$[ebp+2], 70 ; 00000046H

; 2817 : 	//ItemByteConvert7(pMsg.dbInventory, lpObj->pInventory, MAX_INVENTORY);
; 2818 : 	memcpy(pMsg.Name, lpObj->Name, MAX_IDSTRING);

  00032	6a 0a		 push	 10			; 0000000aH
  00034	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00037	83 c0 73	 add	 eax, 115		; 00000073H
  0003a	50		 push	 eax
  0003b	8d 8d b8 fb ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 _memcpy
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2819 : 	
; 2820 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 2821 : 	ItemByteConvert16(pMsg.dbInventory, lpObj->pInventory, MAX_INVENTORY_EXTEND);
; 2822 : #else
; 2823 : #ifdef PERSONAL_SHOP_20040113
; 2824 : 	ItemByteConvert10(pMsg.dbInventory, lpObj->pInventory, MAX_INVENTORY_EXTEND);

  0004a	6a 6c		 push	 108			; 0000006cH
  0004c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004f	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00055	51		 push	 ecx
  00056	8d 95 c2 fb ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp+14]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ?ItemByteConvert10@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert10
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2825 : #else
; 2826 : 	ItemByteConvert10(pMsg.dbInventory, lpObj->pInventory, MAX_INVENTORY);
; 2827 : #endif	// #define PERSONAL_SHOP_20040113
; 2828 : #endif	// #define ITEM_DBSIZE_EXTEND_20050706
; 2829 : 
; 2830 : 	//wsDataCli.DataSend((char*)&pMsg, sizeof( pMsg ));
; 2831 : 	cDBSMng.Send((char*)&pMsg, sizeof( pMsg ));

  00065	68 46 04 00 00	 push	 1094			; 00000446H
  0006a	8d 85 b4 fb ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00070	50		 push	 eax
  00071	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00076	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2832 : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00081	33 cd		 xor	 ecx, ebp
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?GDUserItemSave@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; GDUserItemSave
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
tv375 = -1616						; size = 4
_pCSave$ = -1420					; size = 1416
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_bMapServerMove$ = 16					; size = 4
?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z PROC	; GJSetCharacterInfo, COMDAT

; 2098 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 06 00
	00		 sub	 esp, 1616		; 00000650H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2099 : 	if(lpObj->m_bShell == true)

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	0f b6 88 7d 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6781]
  00020	83 f9 01	 cmp	 ecx, 1
  00023	75 05		 jne	 SHORT $LN2@GJSetChara

; 2100 : 		return;

  00025	e9 c5 03 00 00	 jmp	 $LN1@GJSetChara
$LN2@GJSetChara:

; 2101 : #ifdef MAP_SERVER_WORK_20041030				// 맵서버 이동 전에 한번 저장했으므로 두번 저장하지 않는다.
; 2102 : 	if (lpObj->m_bMapSvrMoveQuit == true) {
; 2103 : 		LogAddC(LOGC_RED, "[MapServerMng] GJSetCharacterInfo() - Inventory Already Saved [%s][%s] (%d)",
; 2104 : 			lpObj->AccountID,
; 2105 : 			lpObj->Name,
; 2106 : 			lpObj->m_Index
; 2107 : 			);
; 2108 : 		return;
; 2109 : 	}
; 2110 : 
; 2111 : #ifdef MODIFY_MAPSERVERMOVE_FLAG_BUGFIX_20060817
; 2112 : 	// 맵 서버 이동인 경우 m_bMapSvrMoveQuit 값을 TRUE로 미리 설정한다. DB에 창고/인벤 정보가 저장되기 전에 설정.
; 2113 : 	if ( bMapServerMove == TRUE )
; 2114 : 	{
; 2115 : 		lpObj->m_bMapSvrMoveQuit = true;
; 2116 : 		LogAddC(LOGC_LIGHTRED, "[MapServerMng][%s][%s] GJSetCharacterInfo() - MapServerMove Character Save Start (%d)",
; 2117 : 			lpObj->AccountID,
; 2118 : 			lpObj->Name,
; 2119 : 			lpObj->m_Index
; 2120 : 			);
; 2121 : 	}
; 2122 : #endif // MODIFY_MAPSERVERMOVE_FLAG_BUGFIX_20060817
; 2123 : 	
; 2124 : #endif // MAP_SERVER_WORK_20041030
; 2125 : 	
; 2126 : 	if( lpObj->m_IfState.use > 0 && lpObj->m_IfState.type == I_WAREHOUSE && lpObj->m_IfState.state == 1 ) 

  0002a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002d	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00033	80 e1 03	 and	 cl, 3
  00036	0f b6 d1	 movzx	 edx, cl
  00039	85 d2		 test	 edx, edx
  0003b	7e 3a		 jle	 SHORT $LN3@GJSetChara
  0003d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00040	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00046	c0 e9 04	 shr	 cl, 4
  00049	80 e1 0f	 and	 cl, 15			; 0000000fH
  0004c	0f b6 d1	 movzx	 edx, cl
  0004f	83 fa 06	 cmp	 edx, 6
  00052	75 23		 jne	 SHORT $LN3@GJSetChara
  00054	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00057	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0005d	c0 e9 02	 shr	 cl, 2
  00060	80 e1 03	 and	 cl, 3
  00063	0f b6 d1	 movzx	 edx, cl
  00066	83 fa 01	 cmp	 edx, 1
  00069	75 0c		 jne	 SHORT $LN3@GJSetChara

; 2127 : 	{	// 창고가 열려 있을때는 창고도 저장한다
; 2128 : 		GDSetWarehouseList(aIndex);	

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?GDSetWarehouseList@@YAXH@Z ; GDSetWarehouseList
  00074	83 c4 04	 add	 esp, 4
$LN3@GJSetChara:

; 2129 : 	}
; 2130 : 
; 2131 : #ifdef AUTH_GAMESERVER_CHECKKEY
; 2132 : 	if( szAuthKey[1] != AUTH_CHECK_01 )
; 2133 : 		DestroyGIocp();
; 2134 : #endif
; 2135 : 
; 2136 : 	SDHP_DBCHAR_INFOSAVE	pCSave;
; 2137 : 	
; 2138 : #if (DATANOSAVE == 1)
; 2139 : 	return;
; 2140 : #endif
; 2141 : 
; 2142 : 	pCSave.h.c			= PMHC_WORD;

  00077	c6 85 74 fa ff
	ff c2		 mov	 BYTE PTR _pCSave$[ebp], 194 ; 000000c2H

; 2143 : 	pCSave.h.headcode	= 0x07;

  0007e	c6 85 77 fa ff
	ff 07		 mov	 BYTE PTR _pCSave$[ebp+3], 7

; 2144 : 	pCSave.h.sizeH      = HIBYTE(sizeof( pCSave ));

  00085	c6 85 75 fa ff
	ff 05		 mov	 BYTE PTR _pCSave$[ebp+1], 5

; 2145 : 	pCSave.h.sizeL      = LOBYTE(sizeof( pCSave ));

  0008c	c6 85 76 fa ff
	ff 88		 mov	 BYTE PTR _pCSave$[ebp+2], 136 ; 00000088H

; 2146 : 	
; 2147 : 	pCSave.AccountID[MAX_IDSTRING] = '\0';

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	6b c8 0a	 imul	 ecx, eax, 10
  0009b	c6 84 0d 78 fa
	ff ff 00	 mov	 BYTE PTR _pCSave$[ebp+ecx+4], 0

; 2148 : 	memcpy(pCSave.AccountID, lpObj->AccountID, MAX_IDSTRING);

  000a3	6a 0a		 push	 10			; 0000000aH
  000a5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a8	83 c0 68	 add	 eax, 104		; 00000068H
  000ab	50		 push	 eax
  000ac	8d 8d 78 fa ff
	ff		 lea	 ecx, DWORD PTR _pCSave$[ebp+4]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 _memcpy
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2149 : 
; 2150 : 	pCSave.Name[MAX_IDSTRING] = '\0';

  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	6b c8 0a	 imul	 ecx, eax, 10
  000c3	c6 84 0d 83 fa
	ff ff 00	 mov	 BYTE PTR _pCSave$[ebp+ecx+15], 0

; 2151 : 	memcpy(pCSave.Name,	lpObj->Name, MAX_IDSTRING);

  000cb	6a 0a		 push	 10			; 0000000aH
  000cd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d0	83 c0 73	 add	 eax, 115		; 00000073H
  000d3	50		 push	 eax
  000d4	8d 8d 83 fa ff
	ff		 lea	 ecx, DWORD PTR _pCSave$[ebp+15]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _memcpy
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2152 : 
; 2153 : 	pCSave.Class		= (BYTE)lpObj->DbClass;

  000e3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e6	8a 88 9e 00 00
	00		 mov	 cl, BYTE PTR [eax+158]
  000ec	88 8d 90 fa ff
	ff		 mov	 BYTE PTR _pCSave$[ebp+28], cl

; 2154 : 	pCSave.Level		= lpObj->Level;

  000f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f5	66 8b 88 a0 00
	00 00		 mov	 cx, WORD PTR [eax+160]
  000fc	66 89 8d 8e fa
	ff ff		 mov	 WORD PTR _pCSave$[ebp+26], cx

; 2155 : 	pCSave.LevelUpPoint = lpObj->LevelUpPoint;

  00103	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00106	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0010c	89 8d 94 fa ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+32], ecx

; 2156 : 	pCSave.Exp			= lpObj->Experience;

  00112	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00115	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  0011b	89 8d 98 fa ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+36], ecx

; 2157 : 	pCSave.NextExp		= lpObj->NextExp;

  00121	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00124	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  0012a	89 8d 9c fa ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+40], ecx

; 2158 : 	pCSave.Money		= lpObj->Money;

  00130	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00133	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00139	89 8d a0 fa ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+44], ecx

; 2159 : 	pCSave.Str			= lpObj->Strength;

  0013f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00142	66 8b 88 b4 00
	00 00		 mov	 cx, WORD PTR [eax+180]
  00149	66 89 8d a4 fa
	ff ff		 mov	 WORD PTR _pCSave$[ebp+48], cx

; 2160 : 	pCSave.Dex			= lpObj->Dexterity;

  00150	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00153	66 8b 88 b6 00
	00 00		 mov	 cx, WORD PTR [eax+182]
  0015a	66 89 8d a6 fa
	ff ff		 mov	 WORD PTR _pCSave$[ebp+50], cx

; 2161 : 	pCSave.Vit			= lpObj->Vitality;

  00161	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00164	66 8b 88 b8 00
	00 00		 mov	 cx, WORD PTR [eax+184]
  0016b	66 89 8d a8 fa
	ff ff		 mov	 WORD PTR _pCSave$[ebp+52], cx

; 2162 : 	pCSave.Energy		= lpObj->Energy;

  00172	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00175	66 8b 88 ba 00
	00 00		 mov	 cx, WORD PTR [eax+186]
  0017c	66 89 8d aa fa
	ff ff		 mov	 WORD PTR _pCSave$[ebp+54], cx

; 2163 : 	pCSave.Life			= (WORD)(lpObj->Life*10.0f);

  00183	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00186	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  0018e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  00196	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0019a	66 89 8d ac fa
	ff ff		 mov	 WORD PTR _pCSave$[ebp+56], cx

; 2164 : 	pCSave.MaxLife		= (WORD)(lpObj->MaxLife*10.0f);

  001a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a4	f3 0f 10 80 c0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+192]
  001ac	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  001b4	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001b8	66 89 8d ae fa
	ff ff		 mov	 WORD PTR _pCSave$[ebp+58], cx

; 2165 : 	pCSave.Mana			= (WORD)(lpObj->Mana*10.0f);

  001bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c2	f3 0f 10 80 d0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+208]
  001ca	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  001d2	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001d6	66 89 8d b0 fa
	ff ff		 mov	 WORD PTR _pCSave$[ebp+60], cx

; 2166 : 	pCSave.MaxMana		= (WORD)(lpObj->MaxMana*10.0f);

  001dd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e0	f3 0f 10 80 d4
	00 00 00	 movss	 xmm0, DWORD PTR [eax+212]
  001e8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  001f0	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001f4	66 89 8d b2 fa
	ff ff		 mov	 WORD PTR _pCSave$[ebp+62], cx

; 2167 : 
; 2168 : 	if((lpObj->Authority&AUTHORITY_DISABLE) == AUTHORITY_DISABLE)

  001fb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fe	8b 88 a4 01 00
	00		 mov	 ecx, DWORD PTR [eax+420]
  00204	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  0020a	74 06		 je	 SHORT $LN4@GJSetChara

; 2169 : 		pCSave.CtlCode = 1;

  0020c	c6 45 f4 01	 mov	 BYTE PTR _pCSave$[ebp+1408], 1
  00210	eb 3a		 jmp	 SHORT $LN10@GJSetChara
$LN4@GJSetChara:

; 2170 : 	else if((lpObj->Authority&AUTHORITY_ADMIN) == AUTHORITY_ADMIN)

  00212	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00215	8b 88 a4 01 00
	00		 mov	 ecx, DWORD PTR [eax+420]
  0021b	83 e1 02	 and	 ecx, 2
  0021e	74 06		 je	 SHORT $LN6@GJSetChara

; 2171 : 		pCSave.CtlCode = 32;

  00220	c6 45 f4 20	 mov	 BYTE PTR _pCSave$[ebp+1408], 32 ; 00000020H
  00224	eb 26		 jmp	 SHORT $LN10@GJSetChara
$LN6@GJSetChara:

; 2172 : 	else if((lpObj->Authority&AUTHORITY_EVENT_GM) == AUTHORITY_EVENT_GM)

  00226	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00229	8b 88 a4 01 00
	00		 mov	 ecx, DWORD PTR [eax+420]
  0022f	83 e1 20	 and	 ecx, 32			; 00000020H
  00232	74 06		 je	 SHORT $LN8@GJSetChara

; 2173 : 		pCSave.CtlCode = 8;

  00234	c6 45 f4 08	 mov	 BYTE PTR _pCSave$[ebp+1408], 8
  00238	eb 12		 jmp	 SHORT $LN10@GJSetChara
$LN8@GJSetChara:

; 2174 : 	else if((lpObj->Authority&AUTHORITY_USER) == AUTHORITY_USER)

  0023a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023d	8b 88 a4 01 00
	00		 mov	 ecx, DWORD PTR [eax+420]
  00243	83 e1 01	 and	 ecx, 1
  00246	74 04		 je	 SHORT $LN10@GJSetChara

; 2175 : 		pCSave.CtlCode = 0;

  00248	c6 45 f4 00	 mov	 BYTE PTR _pCSave$[ebp+1408], 0
$LN10@GJSetChara:

; 2176 : 
; 2177 : 	//ItemByteConvert7(pCSave.dbInventory, lpObj->pInventory, MAX_INVENTORY);
; 2178 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 2179 : 	ItemByteConvert16(pCSave.dbInventory, lpObj->pInventory, MAX_INVENTORY_EXTEND);
; 2180 : #else
; 2181 : #ifdef PERSONAL_SHOP_20040113
; 2182 : 	ItemByteConvert10(pCSave.dbInventory, lpObj->pInventory, MAX_INVENTORY_EXTEND);

  0024c	6a 6c		 push	 108			; 0000006cH
  0024e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00251	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00257	51		 push	 ecx
  00258	8d 95 b4 fa ff
	ff		 lea	 edx, DWORD PTR _pCSave$[ebp+64]
  0025e	52		 push	 edx
  0025f	e8 00 00 00 00	 call	 ?ItemByteConvert10@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert10
  00264	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2183 : #else
; 2184 : 	ItemByteConvert10(pCSave.dbInventory, lpObj->pInventory, MAX_INVENTORY);
; 2185 : #endif	// #define PERSONAL_SHOP_20040113
; 2186 : #endif	// #define ITEM_DBSIZE_EXTEND_20050706
; 2187 : 
; 2188 : 	MagicByteConvert(pCSave.dbMagicList, lpObj->Magic, MAX_MAGIC);

  00267	6a 3c		 push	 60			; 0000003cH
  00269	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026c	8b 88 10 03 00
	00		 mov	 ecx, DWORD PTR [eax+784]
  00272	51		 push	 ecx
  00273	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pCSave$[ebp+1144]
  00279	52		 push	 edx
  0027a	e8 00 00 00 00	 call	 ?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z ; MagicByteConvert
  0027f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2189 : 
; 2190 : 	pCSave.MapNumber	= lpObj->MapNumber;

  00282	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00285	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  0028b	88 4d a0	 mov	 BYTE PTR _pCSave$[ebp+1324], cl

; 2191 : 	pCSave.MapX			= (BYTE)lpObj->X;

  0028e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00291	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00297	88 4d a1	 mov	 BYTE PTR _pCSave$[ebp+1325], cl

; 2192 : 	pCSave.MapY			= (BYTE)lpObj->Y;

  0029a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029d	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  002a3	88 4d a2	 mov	 BYTE PTR _pCSave$[ebp+1326], cl

; 2193 : 
; 2194 : 	pCSave.Dir			= lpObj->Dir;

  002a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a9	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  002af	88 4d a3	 mov	 BYTE PTR _pCSave$[ebp+1327], cl

; 2195 : 
; 2196 : #ifdef TEST_SETITEM_CLEAR
; 2197 : 	pCSave.Dir			|= (lpObj->ClearInfoForSetItem<<4);
; 2198 : #endif
; 2199 : 	pCSave.PkCount		= lpObj->m_PK_Count;

  002b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b5	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  002bc	89 4d a4	 mov	 DWORD PTR _pCSave$[ebp+1328], ecx

; 2200 : 	pCSave.PkLevel		= lpObj->m_PK_Level;

  002bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c2	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  002c9	89 4d a8	 mov	 DWORD PTR _pCSave$[ebp+1332], ecx

; 2201 : 	pCSave.PkTime		= lpObj->m_PK_Time;

  002cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cf	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  002d5	89 4d ac	 mov	 DWORD PTR _pCSave$[ebp+1336], ecx

; 2202 : 
; 2203 : #ifdef DARKLORD_WORK	
; 2204 : 	pCSave.Leadership	 = lpObj->Leadership;			// 통솔

  002d8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002db	66 8b 88 d8 00
	00 00		 mov	 cx, WORD PTR [eax+216]
  002e2	66 89 4d e4	 mov	 WORD PTR _pCSave$[ebp+1392], cx

; 2205 : 	pCSave.ChatLitmitTime = lpObj->ChatLitmitTime;		// 채팅 제한 시간

  002e6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e9	66 8b 88 dc 00
	00 00		 mov	 cx, WORD PTR [eax+220]
  002f0	66 89 4d e6	 mov	 WORD PTR _pCSave$[ebp+1394], cx

; 2206 : #endif
; 2207 : 	
; 2208 : #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 2209 : 	pCSave.iFruitPoint	= lpObj->iFruitPoint;			// 추가된 열매 포인트.
; 2210 : #endif
; 2211 : 
; 2212 : 
; 2213 : #ifdef ITEMSAVE_MODIFY_FORSTATICS
; 2214 : 
; 2215 : #ifdef FOR_KOREA
; 2216 : 
; 2217 : 	#ifndef REMOVE_CONNECTED_CHARACTER_NAME_INFO_20051004
; 2218 : 		if( (GetTickCount()-lpObj->SaveTimeForStatics) > (1000*60*60) )	
; 2219 : 		{
; 2220 : 			lpObj->SaveTimeForStatics = GetTickCount()+(1000*60*60);
; 2221 : 			pCSave.CharInfoSave = 1;
; 2222 : 		}
; 2223 : 		else
; 2224 : 	#endif
; 2225 : 			pCSave.CharInfoSave = 0;

  002f4	c6 45 e2 00	 mov	 BYTE PTR _pCSave$[ebp+1390], 0

; 2226 : #else
; 2227 : 		pCSave.CharInfoSave = 0;
; 2228 : #endif
; 2229 : 
; 2230 : 
; 2231 : #endif
; 2232 : 
; 2233 : #ifdef NEW_SKILL_FORSKYLAND
; 2234 : 	memcpy(pCSave.dbQuest, lpObj->m_Quest, MAX_DBQUEST);

  002f8	6a 32		 push	 50			; 00000032H
  002fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002fd	05 90 0e 00 00	 add	 eax, 3728		; 00000e90H
  00302	50		 push	 eax
  00303	8d 4d b0	 lea	 ecx, DWORD PTR _pCSave$[ebp+1340]
  00306	51		 push	 ecx
  00307	e8 00 00 00 00	 call	 _memcpy
  0030c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2235 : #endif
; 2236 : 
; 2237 : 	pCSave.AccountType = lpObj->m_AccountType;

  0030f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00312	8a 88 5d 1a 00
	00		 mov	 cl, BYTE PTR [eax+6749]
  00318	88 4d e8	 mov	 BYTE PTR _pCSave$[ebp+1396], cl

; 2238 : 	pCSave.DecreaseTime = time(NULL)-lpObj->m_JoinTime;

  0031b	6a 00		 push	 0
  0031d	e8 00 00 00 00	 call	 _time
  00322	83 c4 04	 add	 esp, 4
  00325	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00328	2b 81 68 1a 00
	00		 sub	 eax, DWORD PTR [ecx+6760]
  0032e	1b 91 6c 1a 00
	00		 sbb	 edx, DWORD PTR [ecx+6764]
  00334	89 45 ec	 mov	 DWORD PTR _pCSave$[ebp+1400], eax
  00337	89 55 f0	 mov	 DWORD PTR _pCSave$[ebp+1404], edx

; 2239 : 
; 2240 : 	if(pCSave.DecreaseTime > lpObj->m_EndTime)

  0033a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033d	89 85 b0 f9 ff
	ff		 mov	 DWORD PTR tv375[ebp], eax
  00343	8b 8d b0 f9 ff
	ff		 mov	 ecx, DWORD PTR tv375[ebp]
  00349	8b 55 f0	 mov	 edx, DWORD PTR _pCSave$[ebp+1404]
  0034c	3b 91 64 1a 00
	00		 cmp	 edx, DWORD PTR [ecx+6756]
  00352	7c 28		 jl	 SHORT $LN11@GJSetChara
  00354	7f 11		 jg	 SHORT $LN14@GJSetChara
  00356	8b 85 b0 f9 ff
	ff		 mov	 eax, DWORD PTR tv375[ebp]
  0035c	8b 4d ec	 mov	 ecx, DWORD PTR _pCSave$[ebp+1400]
  0035f	3b 88 60 1a 00
	00		 cmp	 ecx, DWORD PTR [eax+6752]
  00365	76 15		 jbe	 SHORT $LN11@GJSetChara
$LN14@GJSetChara:

; 2241 : 		pCSave.DecreaseTime = lpObj->m_EndTime;

  00367	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0036a	8b 88 60 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6752]
  00370	89 4d ec	 mov	 DWORD PTR _pCSave$[ebp+1400], ecx
  00373	8b 90 64 1a 00
	00		 mov	 edx, DWORD PTR [eax+6756]
  00379	89 55 f0	 mov	 DWORD PTR _pCSave$[ebp+1404], edx
$LN11@GJSetChara:

; 2242 : 
; 2243 : 	if( cDBSMng.Send((char*)&pCSave, sizeof(pCSave)) == FALSE )

  0037c	68 88 05 00 00	 push	 1416			; 00000588H
  00381	8d 85 74 fa ff
	ff		 lea	 eax, DWORD PTR _pCSave$[ebp]
  00387	50		 push	 eax
  00388	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0038d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00392	85 c0		 test	 eax, eax
  00394	75 25		 jne	 SHORT $LN12@GJSetChara

; 2244 : 	{
; 2245 : 		LogAddC(LOGC_RED, lMsg.Get(430), lpObj->Name);

  00396	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00399	83 c0 73	 add	 eax, 115		; 00000073H
  0039c	50		 push	 eax
  0039d	68 ae 01 00 00	 push	 430			; 000001aeH
  003a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003ad	50		 push	 eax
  003ae	6a 02		 push	 2
  003b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  003b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2246 : 		return;

  003b9	eb 34		 jmp	 SHORT $LN1@GJSetChara
$LN12@GJSetChara:

; 2247 : 	}
; 2248 : 	gObjItemTextSave(lpObj);

  003bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003be	50		 push	 eax
  003bf	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAVOBJECTSTRUCT@@@Z ; gObjItemTextSave
  003c4	83 c4 04	 add	 esp, 4

; 2249 : 
; 2250 : 	gObjStatTextSave(lpObj);

  003c7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ca	50		 push	 eax
  003cb	e8 00 00 00 00	 call	 ?gObjStatTextSave@@YAXPAVOBJECTSTRUCT@@@Z ; gObjStatTextSave
  003d0	83 c4 04	 add	 esp, 4

; 2251 : 
; 2252 : #ifdef DARKLORD_WORK	// 펫 아이템 정보도 저장한다
; 2253 : 	gObjSavePetItemInfo(aIndex, 0);

  003d3	6a 00		 push	 0
  003d5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003d8	50		 push	 eax
  003d9	e8 00 00 00 00	 call	 ?gObjSavePetItemInfo@@YAXHH@Z ; gObjSavePetItemInfo
  003de	83 c4 08	 add	 esp, 8

; 2254 : #endif
; 2255 : 	
; 2256 : #ifdef NEW_SKILL_FORSKYLAND
; 2257 : 	#ifndef EXTEND_LOG_SYSTEM_20060202
; 2258 : 		g_QuestInfo.QuestInfoSave(lpObj);

  003e1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e4	50		 push	 eax
  003e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  003ea	e8 00 00 00 00	 call	 ?QuestInfoSave@CQuestInfo@@QAEXPAVOBJECTSTRUCT@@@Z ; CQuestInfo::QuestInfoSave
$LN1@GJSetChara:

; 2259 : 	#endif // EXTEND_LOG_SYSTEM_20060202
; 2260 : #endif
; 2261 : 
; 2262 : #ifdef MODIFY_QUEST_SYSTEM_20070525	// 퀘스트 정보를 저장한다.
; 2263 : 	g_QuestUtil.GDReqQuestMonKillInfoSave( lpObj );
; 2264 : #endif
; 2265 : 
; 2266 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912		// 마스터레벨 정보 저장
; 2267 : 	g_MasterLevelSystem.GDReqMasterLevelInfoSave( lpObj );
; 2268 : #endif
; 2269 : }

  003ef	5f		 pop	 edi
  003f0	5e		 pop	 esi
  003f1	5b		 pop	 ebx
  003f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f5	33 cd		 xor	 ecx, ebp
  003f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003fc	8b e5		 mov	 esp, ebp
  003fe	5d		 pop	 ebp
  003ff	c3		 ret	 0
?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z ENDP	; GJSetCharacterInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?GDGameServerInfoSave@@YAXXZ
_TEXT	SEGMENT
?GDGameServerInfoSave@@YAXXZ PROC			; GDGameServerInfoSave, COMDAT

; 2856 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2857 : 	/*SDHP_GAMESERVERINFO	pMsg;
; 2858 : 	pMsg.h.c		= PMHC_BYTE;
; 2859 : 	pMsg.h.headcode	= 0x20;
; 2860 : 	pMsg.h.size		= sizeof( pMsg );
; 2861 : 	pMsg.ItemCount	= gItemNumberCount;
; 2862 : 	wsDataCli.DataSend((char*)&pMsg, pMsg.h.size);
; 2863 : 	LogAdd("아이템 번호 저장 : %d", gItemNumberCount);
; 2864 : 	*/
; 2865 : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GDGameServerInfoSave@@YAXXZ ENDP			; GDGameServerInfoSave
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?DataServerGetCharListRequest@@YAXF@Z
_TEXT	SEGMENT
_AccountId$ = -36					; size = 4
_TempId$ = -32						; size = 11
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?DataServerGetCharListRequest@@YAXF@Z PROC		; DataServerGetCharListRequest, COMDAT

; 1549 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 1550 : 	SDHP_GETCHARLIST	pMsg;
; 1551 : 	char TempId[MAX_IDSTRING+1];
; 1552 : 	char *AccountId;
; 1553 : 	
; 1554 : 	memset(TempId, 0, MAX_IDSTRING+1);

  00013	6a 0b		 push	 11			; 0000000bH
  00015	6a 00		 push	 0
  00017	8d 45 e0	 lea	 eax, DWORD PTR _TempId$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _memset
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1555 : 	
; 1556 : 	AccountId = gObjGetAccountId(aIndex);

  00023	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?gObjGetAccountId@@YAPADH@Z ; gObjGetAccountId
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 dc	 mov	 DWORD PTR _AccountId$[ebp], eax

; 1557 : 	if( AccountId == NULL )

  00033	83 7d dc 00	 cmp	 DWORD PTR _AccountId$[ebp], 0
  00037	75 3a		 jne	 SHORT $LN2@DataServer

; 1558 : 	{
; 1559 : 		LogAdd( lMsg.Get(422), __FILE__, __LINE__);

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??DataServerGetCharListRequest@@YAXF@Z@4JA
  0003e	83 c0 0a	 add	 eax, 10			; 0000000aH
  00041	50		 push	 eax
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MBPEHAPP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00047	68 a6 01 00 00	 push	 422			; 000001a6H
  0004c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1560 : 		CloseClient ( aIndex );

  00061	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0006b	83 c4 04	 add	 esp, 4

; 1561 : 		return;

  0006e	e9 b8 00 00 00	 jmp	 $LN1@DataServer
$LN2@DataServer:

; 1562 : 	}
; 1563 : 	if( strlen(AccountId) < 1 ) 

  00073	8b 45 dc	 mov	 eax, DWORD PTR _AccountId$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _strlen
  0007c	83 c4 04	 add	 esp, 4
  0007f	83 f8 01	 cmp	 eax, 1
  00082	73 37		 jae	 SHORT $LN3@DataServer

; 1564 : 	{
; 1565 : 		LogAdd(lMsg.Get(423), __FILE__, __LINE__);

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??DataServerGetCharListRequest@@YAXF@Z@4JA
  00089	83 c0 10	 add	 eax, 16			; 00000010H
  0008c	50		 push	 eax
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@MBPEHAPP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00092	68 a7 01 00 00	 push	 423			; 000001a7H
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000a2	50		 push	 eax
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1566 : 		CloseClient ( aIndex );

  000ac	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000b6	83 c4 04	 add	 esp, 4

; 1567 : 		return;

  000b9	eb 70		 jmp	 SHORT $LN1@DataServer
$LN3@DataServer:

; 1568 : 	}
; 1569 : 	
; 1570 : #ifdef UPDATE_RESEND_GETCHARlIST_DISABLE_20090605
; 1571 : 	if( gObj[aIndex].m_bRequestPaket == TRUE )
; 1572 : 	{
; 1573 : 		LogAdd("ReSend CharacterList (%s)", AccountId);
; 1574 : 		gObj[aIndex].m_nRequestPacketCnt++;
; 1575 : 		if(gObj[aIndex].m_nRequestPacketCnt > 3)
; 1576 : 		{
; 1577 : 			// 인증서버에 아이피를 등록
; 1578 : 			//GJRequestBlockIp(gObj[aIndex].Ip_addr);
; 1579 : 			
; 1580 : 			// 사용자 종료
; 1581 : 			LogAdd("ReSend CharacterList CloseUser (%s)", AccountId);
; 1582 : 			CloseClient ( aIndex );
; 1583 : 			return;
; 1584 : 		}
; 1585 : 	}
; 1586 : 	
; 1587 : 	gObj[aIndex].m_bRequestPaket = TRUE;
; 1588 : #endif	// UPDATE_RESEND_GETCHARlIST_DISABLE_20090605
; 1589 : 
; 1590 : 	strcpy(TempId, AccountId);

  000bb	8b 45 dc	 mov	 eax, DWORD PTR _AccountId$[ebp]
  000be	50		 push	 eax
  000bf	8d 4d e0	 lea	 ecx, DWORD PTR _TempId$[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 _strcpy
  000c8	83 c4 08	 add	 esp, 8

; 1591 : 
; 1592 : 	pMsg.h.c        = PMHC_BYTE;

  000cb	c6 45 ec c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 1593 : 	pMsg.h.size     = sizeof( pMsg );

  000cf	c6 45 ed 10	 mov	 BYTE PTR _pMsg$[ebp+1], 16 ; 00000010H

; 1594 : 	pMsg.h.headcode = 0x01;

  000d3	c6 45 ee 01	 mov	 BYTE PTR _pMsg$[ebp+2], 1

; 1595 : 	pMsg.Number     = aIndex;

  000d7	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]
  000db	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 1596 : 	memcpy(pMsg.Id, TempId, MAX_IDSTRING);

  000df	6a 0a		 push	 10			; 0000000aH
  000e1	8d 45 e0	 lea	 eax, DWORD PTR _TempId$[ebp]
  000e4	50		 push	 eax
  000e5	8d 4d ef	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 _memcpy
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1597 : 
; 1598 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 1599 : 	//창고 정보 요청
; 1600 : 	LogAddTD_TempLog(", [G->D Req GetCharList], Account [%s], IP [%s] ", AccountId, gObj[aIndex].Ip_addr);

  000f1	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  000f5	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  000fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00101	8d 44 0a 18	 lea	 eax, DWORD PTR [edx+ecx+24]
  00105	50		 push	 eax
  00106	8b 4d dc	 mov	 ecx, DWORD PTR _AccountId$[ebp]
  00109	51		 push	 ecx
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@LJIPDNBN@?0?5?$FLG?9?$DOD?5Req?5GetCharList?$FN?0?5Accou@
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1601 : #endif
; 1602 : 
; 1603 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00118	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0011c	50		 push	 eax
  0011d	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00120	51		 push	 ecx
  00121	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00126	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@DataServer:

; 1604 : }

  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00131	33 cd		 xor	 ecx, ebp
  00133	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c3		 ret	 0
?DataServerGetCharListRequest@@YAXF@Z ENDP		; DataServerGetCharListRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?DataServerLogin@@YAXH@Z
_TEXT	SEGMENT
_pInfo$ = -64						; size = 58
__$ArrayPad$ = -4					; size = 4
_server$ = 8						; size = 4
?DataServerLogin@@YAXH@Z PROC				; DataServerLogin, COMDAT

; 533  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 534  : 	SDHP_SERVERINFO	   pInfo;
; 535  : 
; 536  : 	pInfo.h.c		 = PMHC_BYTE;

  00016	c6 45 c0 c1	 mov	 BYTE PTR _pInfo$[ebp], 193 ; 000000c1H

; 537  : 	pInfo.h.size	 = sizeof(pInfo);

  0001a	c6 45 c1 3a	 mov	 BYTE PTR _pInfo$[ebp+1], 58 ; 0000003aH

; 538  : 	pInfo.h.headcode = 0x00;

  0001e	c6 45 c2 00	 mov	 BYTE PTR _pInfo$[ebp+2], 0

; 539  : 	pInfo.Port		 = GameServerPort;

  00022	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?GameServerPort@@3HA
  00028	66 89 45 c4	 mov	 WORD PTR _pInfo$[ebp+4], ax

; 540  : 	pInfo.Type		 = ST_GAMESERVER;

  0002c	c6 45 c3 01	 mov	 BYTE PTR _pInfo$[ebp+3], 1

; 541  : 
; 542  : 	pInfo.ServerCode = gGameServerCode;

  00030	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00036	66 89 45 f8	 mov	 WORD PTR _pInfo$[ebp+56], ax

; 543  : 
; 544  : 	strcpy( pInfo.ServerName, szServerName);

  0003a	68 00 00 00 00	 push	 OFFSET ?szServerName@@3PADA ; szServerName
  0003f	8d 45 c6	 lea	 eax, DWORD PTR _pInfo$[ebp+6]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _strcpy
  00048	83 c4 08	 add	 esp, 8

; 545  : 
; 546  : 	cDBSMng.Send(server, (char*)&pInfo, pInfo.h.size);

  0004b	0f b6 45 c1	 movzx	 eax, BYTE PTR _pInfo$[ebp+1]
  0004f	50		 push	 eax
  00050	8d 4d c0	 lea	 ecx, DWORD PTR _pInfo$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _server$[ebp]
  00057	52		 push	 edx
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0005d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHHPADH@Z ; DBSockMng::Send

; 547  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?DataServerLogin@@YAXH@Z ENDP				; DataServerLogin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?DataServerProtocolCore@@YAXEPAEH@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
_pMsg$1 = -4						; size = 4
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?DataServerProtocolCore@@YAXEPAEH@Z PROC		; DataServerProtocolCore, COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 194  : 	switch( protoNum )

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  0000d	89 45 b8	 mov	 DWORD PTR tv65[ebp], eax
  00010	81 7d b8 ff 00
	00 00		 cmp	 DWORD PTR tv65[ebp], 255 ; 000000ffH
  00017	7f 2b		 jg	 SHORT $LN18@DataServer
  00019	81 7d b8 ff 00
	00 00		 cmp	 DWORD PTR tv65[ebp], 255 ; 000000ffH
  00020	0f 84 de 00 00
	00		 je	 $LN16@DataServer
  00026	81 7d b8 a9 00
	00 00		 cmp	 DWORD PTR tv65[ebp], 169 ; 000000a9H
  0002d	0f 87 f5 00 00
	00		 ja	 $LN1@DataServer
  00033	8b 4d b8	 mov	 ecx, DWORD PTR tv65[ebp]
  00036	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN19@DataServer[ecx]
  0003d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN20@DataServer[edx*4]
$LN18@DataServer:
  00044	e9 df 00 00 00	 jmp	 $LN1@DataServer
$LN4@DataServer:

; 195  : 	{
; 196  : 	case 0x00 :
; 197  : 		DataServerLoginResult((LPSDHP_RESULT)aRecv);

  00049	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z ; DataServerLoginResult
  00052	83 c4 04	 add	 esp, 4

; 198  : 		break;

  00055	e9 ce 00 00 00	 jmp	 $LN1@DataServer
$LN5@DataServer:

; 199  : 	case 0x01 : // 캐릭터 리스트 요청 결과
; 200  : 		JGPGetCharList(aRecv);

  0005a	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?JGPGetCharList@@YAXPAE@Z ; JGPGetCharList
  00063	83 c4 04	 add	 esp, 4

; 201  : 		break;

  00066	e9 bd 00 00 00	 jmp	 $LN1@DataServer
$LN6@DataServer:

; 202  : 	//#BUGFIX_20040203_01
; 203  : 	//case 0x02 부분을 EDSProtocol.cpp 로 이전
; 204  : 	//#BUGFIX_20040203_01
; 205  : 	case 0x04 :	// 캐릭터 만들기 요청 결과
; 206  : 		JGCharacterCreateRequest((LPSDHP_CREATECHARRESULT)aRecv);

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z ; JGCharacterCreateRequest
  00074	83 c4 04	 add	 esp, 4

; 207  : 		break;

  00077	e9 ac 00 00 00	 jmp	 $LN1@DataServer
$LN7@DataServer:

; 208  : 	case 0x05 : // 캐릭터 삭제 결과
; 209  : 		JGCharDelRequest((LPSDHP_CHARDELETERESULT)aRecv);

  0007c	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z ; JGCharDelRequest
  00085	83 c4 04	 add	 esp, 4

; 210  : 		break;

  00088	e9 9b 00 00 00	 jmp	 $LN1@DataServer
$LN8@DataServer:

; 211  : 	case 0x06 :	// 캐릭터 정보를 달라고 한 요청 결과
; 212  : 		JGGetCharacterInfo((LPSDHP_DBCHAR_INFORESULT)aRecv);

  0008d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z ; JGGetCharacterInfo
  00096	83 c4 04	 add	 esp, 4

; 213  : 		break;

  00099	e9 8a 00 00 00	 jmp	 $LN1@DataServer
$LN9@DataServer:

; 214  : 	case 0x08 :	// 창고 아이템 리스트를 얻는다.
; 215  : 		DGGetWarehouseList((LPSDHP_GETWAREHOUSEDB_SAVE)aRecv);

  0009e	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ; DGGetWarehouseList
  000a7	83 c4 04	 add	 esp, 4

; 216  : 		break;

  000aa	eb 7c		 jmp	 SHORT $LN1@DataServer
$LN10@DataServer:

; 217  : 	case 0x10 :	
; 218  : 		GDGetWarehouseNoItem((LPSDHP_GETWAREHOUSEDB_RESULT)aRecv);

  000ac	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ; GDGetWarehouseNoItem
  000b5	83 c4 04	 add	 esp, 4

; 219  : 		break;

  000b8	eb 6e		 jmp	 SHORT $LN1@DataServer
$LN11@DataServer:

; 220  : 		
; 221  : #ifdef MODIFY_QUEST_SYSTEM_20070525	// DG [0x13] 퀘스트 - 몬스터 킬카운트 정보를 받았다.
; 222  : 	case 0x14:	
; 223  : 		g_QuestUtil.DGGetQuestMonKillInfo( aRecv );
; 224  : 		break;
; 225  : #endif		
; 226  : 
; 227  : #ifdef UPDATE_CHANGE_CHARACTERNAME_20080410
; 228  : 	case 0x16:
; 229  : 		DGChangeNameResult((LPSDHP_CHANGE_NAME_RESULT) aRecv);
; 230  : 		break;
; 231  : #endif
; 232  : 
; 233  : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912		// DG 정보 요청 결과
; 234  : 	case 0x30:	// 마스터레벨 정보 요청 결과
; 235  : 		g_MasterLevelSystem.DGAnsMasterLevelInfo( aRecv );
; 236  : 		break;
; 237  : #endif
; 238  : 
; 239  : 	case 0x52 :
; 240  : 		ItemSerialCreateRecv((LPSDHP_ITEMCREATERECV)aRecv);

  000ba	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z ; ItemSerialCreateRecv
  000c3	83 c4 04	 add	 esp, 4

; 241  : 		break;

  000c6	eb 60		 jmp	 SHORT $LN1@DataServer
$LN12@DataServer:

; 242  : 
; 243  : 
; 244  : #ifdef DARKLORD_WORK	
; 245  : 	case 0x56 :
; 246  : 		DGRecvPetItemInfo((LPBYTE) aRecv);		

  000c8	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?DGRecvPetItemInfo@@YAXPAE@Z ; DGRecvPetItemInfo
  000d1	83 c4 04	 add	 esp, 4

; 247  : 		break;

  000d4	eb 52		 jmp	 SHORT $LN1@DataServer
$LN13@DataServer:

; 248  : #endif
; 249  : 
; 250  : #ifdef GS_DS_LIVECHECK_20041008			// [0x58] GS -> DS 로 보내온 LIVE 신호를 받아서 응답신호를 보낸다.
; 251  : 	case 0x58 :
; 252  : 		GS_DGAnsLiveCheck((LPSDHP_ANS_GSLIVECHECK) aRecv);		
; 253  : 		break;
; 254  : #endif
; 255  : 		
; 256  : 	case 0x60 :	// 스킬키를 전송 받는다.
; 257  : 		DGOptionDataRecv((LPSDHP_SKILLKEYDATA_SEND)aRecv);

  000d6	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z ; DGOptionDataRecv
  000df	83 c4 04	 add	 esp, 4

; 258  : 		break;

  000e2	eb 44		 jmp	 SHORT $LN1@DataServer
$LN14@DataServer:

; 259  : 
; 260  : #ifdef CHINA_HACKUSER_KICK_SYSTEM
; 261  : 	case 0x70 :	// 핵유저 블럭에 대한 결과를 받는다
; 262  : 		DGBlockHackUserResult((LPSDHP_HACKUSERBLOCK_RESULT)aRecv);
; 263  : 		break;
; 264  : #endif
; 265  : 		
; 266  : #ifdef MU_CASTLESIEGE_DS_PROTOCOL_20041105
; 267  : 	case 0x80 :	// 공성전 관련 데이터 처리
; 268  : 		{
; 269  : 			LPPMSG_DEFAULT2 lpDef1 = (LPPMSG_DEFAULT2)aRecv;
; 270  : 			switch(lpDef1->subcode) {
; 271  : 			case 0x00 :		// [0x80][0x00] 성에 대한 전체적인 정보 요청 응답
; 272  : 				GS_DGAnsCastleTotalInfo		(aRecv);
; 273  : 				break;
; 274  : 			case 0X01 :		// [0x80][0x01] 수성측 길드의 길마이름 요청 응답 -> 경비병 NPC 성 상태 출력
; 275  : 				GS_DGAnsOwnerGuildMaster	(aRecv);
; 276  : 				break;
; 277  : 			case 0x03 :		// [0x80][0x03] 수성측 NPC 구입 요청 응답
; 278  : 				GS_DGAnsCastleNpcBuy		(aRecv);
; 279  : 				break;
; 280  : 			case 0x04 :		// [0x80][0x04] 수성측 NPC 수리 요청 응답
; 281  : 				GS_DGAnsCastleNpcRepair		(aRecv);
; 282  : 				break;
; 283  : 			case 0x05 :		// [0x80][0x05] 수성측 NPC 업그레이드 요청 응답
; 284  : 				GS_DGAnsCastleNpcUpgrade	(aRecv);
; 285  : 				break;
; 286  : 			case 0x06 :		// [0x80][0x06] 성주측 세금정보 요청 응답 (소유 젠도 함께 보내야함)
; 287  : 				GS_DGAnsTaxInfo				(aRecv);
; 288  : 				break;
; 289  : 			case 0x07 :		// [0x80][0x07] 성주측 세율 변경 요청 응답
; 290  : 				GS_DGAnsTaxRateChange		(aRecv);
; 291  : 				break;
; 292  : 			case 0x08 :		// [0x80][0x08] 성주측 소유 젠 변경 요청 응답
; 293  : 				GS_DGAnsCastleMoneyChange	(aRecv);
; 294  : 				break;
; 295  : 			case 0x09 :		// [0x80][0x09] 성주측 공성 시작/종료 시간 변경 요청 응답
; 296  : 				GS_DGAnsSiegeDateChange		(aRecv);
; 297  : 				break;
; 298  : 			case 0x0A :		// [0x80][0x0A] 공성측 특정 길드등록 정보 요청 응답
; 299  : 				GS_DGAnsGuildMarkRegInfo	(aRecv);
; 300  : 				break;
; 301  : 			case 0x0B :		// [0x80][0x0B] 현재 공성 종료여부 변경 요청 응답
; 302  : 				GS_DGAnsSiegeEndedChange	(aRecv);
; 303  : 				break;
; 304  : 			case 0x0C :		// [0x80][0x0C] 현재 성 소유상태 변경 요청 응답
; 305  : 				GS_DGAnsCastleOwnerChange	(aRecv);
; 306  : 				break;
; 307  : 			case 0x0D :		// [0x80][0x0D] 공성측 길드의 공성전 등록 요청
; 308  : 				GS_DGAnsRegAttackGuild		(aRecv);
; 309  : 				break;
; 310  : 			case 0x0E :		// [0x80][0x0E] 공성에 대한 주기가 끝났으므로 현재 성에 대한 정보를 리셋 요청 응답
; 311  : 				GS_DGAnsRestartCastleState	(aRecv);
; 312  : 				break;
; 313  : 			case 0x0F :		// [0x80][0x0F] 특정 맵서버군에 메시지를 멀티 캐스팅 요청 응답
; 314  : 				GS_DGAnsMapSvrMsgMultiCast	(aRecv);
; 315  : 				break;
; 316  : 			case 0x10 :		// [0x80][0x10] 특정 길드의 문장 등록을 요청 응답
; 317  : 				GS_DGAnsRegGuildMark		(aRecv);
; 318  : 				break;
; 319  : 			case 0x11 :		// [0x80][0x11] 공성측 특정 길드 마크 개수 초기화 요청 응답
; 320  : 				GS_DGAnsGuildMarkReset		(aRecv);
; 321  : 				break;
; 322  : 			case 0x12 :		// [0x80][0x12] 공성측 특정 길드 공성 포기여부 수정 요청 응답
; 323  : 				GS_DGAnsGuildSetGiveUp		(aRecv);
; 324  : 				break;
; 325  : 			case 0x16 :		// [0x80][0x16] 수성측 NPC 제거 요청 응답
; 326  : 				GS_DGAnsNpcRemove			(aRecv);
; 327  : 				break;
; 328  : 			case 0x17 :		// [0x80][0x17] 현재의 공성상태 동기화 요청 응답
; 329  : 				GS_DGAnsCastleStateSync		(aRecv);
; 330  : 				break;
; 331  : 			case 0x18 :		// [0x80][0x18] 맵서버군의 성 공납금 추가 요청
; 332  : 				GS_DGAnsCastleTributeMoney	(aRecv);
; 333  : 				break;
; 334  : 			case 0x19 :		// [0x80][0x19] 맵서버군의 성 세율, 돈 초기화 요청 응답
; 335  : 				GS_DGAnsResetCastleTaxInfo	(aRecv);
; 336  : 				break;
; 337  : 			case 0x1A :		// [0x80][0x1A] 공성 참여길드 리스트 초기화 요청 응답
; 338  : 				GS_DGAnsResetSiegeGuildInfo	(aRecv);
; 339  : 				break;
; 340  : 			case 0x1B :		// [0x80][0x1B] 공성 참여신청 길드 리스트 초기화 요청 응답
; 341  : 				GS_DGAnsResetRegSiegeInfo	(aRecv);
; 342  : 				break;
; 343  : 			}
; 344  : 		}
; 345  : 		break;
; 346  : 	case 0x81 :				// [0x81] 공성전 최초 모든 초기화 데이터 요청 응답
; 347  : 		GS_DGAnsCastleInitData				(aRecv);
; 348  : 		break;
; 349  : 	case 0x82 :				// [0x82] 수성측 NPC 정보 요청 응답
; 350  : 		GS_DGAnsCastleNpcInfo				(aRecv);
; 351  : 		break;
; 352  : 	case 0x83 :				// [0x83] 공성측 길드등록 정보 요청 응답 (길드 개수 N개 제한)
; 353  : 		GS_DGAnsAllGuildMarkRegInfo			(aRecv);
; 354  : 		break;
; 355  : 	case 0x84 :				// [0x84] 수성측 NPC 리스트 즉시 생성 요청 응답
; 356  : 		GS_DGAnsFirstCreateNPC				(aRecv);
; 357  : 		break;
; 358  : 	case 0x85 :				// [0x85] 공성측 길드선정 후보자료 요청 응답
; 359  : 		GS_DGAnsCalcREgGuildList			(aRecv);
; 360  : 		break;
; 361  : 	case 0x86 :				// [0x86] 공/수 길드의 연합정보를 요청 응답
; 362  : 		GS_DGAnsCsGulidUnionInfo			(aRecv);
; 363  : 		break;
; 364  : 	case 0x87 :				// [0x87] 공/수 길드의 최종정보를 저장 요청 응답
; 365  : 		GS_DGAnsCsSaveTotalGuildInfo		(aRecv);
; 366  : 		break;
; 367  : 	case 0x88 :				// [0x88] 공/수 길드의 최종정보를 불러오기 요청 응답
; 368  : 		GS_DGAnsCsLoadTotalGuildInfo		(aRecv);
; 369  : 		break;
; 370  : 	case 0x89 :				// [0x89] 수성측 NPC 리스트 정보갱신 요청 응답
; 371  : 		GS_DGAnsCastleNpcUpdate				(aRecv);
; 372  : 		break;
; 373  : #endif
; 374  : 		
; 375  : #ifdef MU_CRYWOLF_DS_PROTOCOL_20050505
; 376  : 	case 0xB0 :				// [0xB0] 크라이울프 동기화 요청 응답
; 377  : 		DGAnsCrywolfSync					(aRecv);
; 378  : 		break;
; 379  : 	case 0xB1 :				// [0xB1] 크라이울프 동기화 요청 응답
; 380  : 		DGAnsCrywolfInfoLoad					(aRecv);
; 381  : 		break;
; 382  : 	case 0xB2 :				// [0xB2] 크라이울프 동기화 요청 응답
; 383  : 		DGAnsCrywolfInfoSave					(aRecv);
; 384  : 		break;
; 385  : #endif
; 386  : 
; 387  : #ifdef GAMESERVER_DIVISION
; 388  : 	case 0xCF:	// 서버이전에 대한 결과를 받는다
; 389  : 		DGMoveOtherServer((LPSDHP_CHARACTER_TRANSFER_RESULT) aRecv);		
; 390  : 		break;
; 391  : #endif
; 392  : 
; 393  : #ifdef ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 394  : 	case 0xD0:
; 395  : 		{
; 396  : 			LPPMSG_DEFAULT2 lpMsg = (LPPMSG_DEFAULT2)aRecv;
; 397  : 			switch( lpMsg->subcode )
; 398  : 			{
; 399  : 			case 0x02:				// 기간제 아이템 정보 확인
; 400  : 				g_CashItemPeriodSystem.DGAnsPeriodItemInquiry( (LPPMSG_ANS_PERIODITEM_INQUIRY)aRecv );
; 401  : 				break;
; 402  : 			case 0x04:				// 기간제 아이템 추가 결과
; 403  : 				g_CashItemPeriodSystem.DGAnsPeriodItemInsert( (LPPMSG_ANS_PERIODITEM_INSERT)aRecv );
; 404  : 				break;
; 405  : 			case 0x06:				// 기간제 아이템 리스트
; 406  : 				g_CashItemPeriodSystem.DGAnsPeriodItemList( (LPPMSG_ANS_PERIODITEM_LIST)aRecv );
; 407  : 				break;
; 408  : 			case 0x08:				// 기간제 아이템 업데이트
; 409  : 				g_CashItemPeriodSystem.DGAnsPeriodItemUpdate( (LPPMSG_ANS_PERIODITEM_UPDATE)aRecv );
; 410  : 				break;
; 411  : 			}
; 412  : 		}
; 413  : 		break;
; 414  : #endif // ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 415  : 
; 416  : #ifdef ADD_CHARCARD_SUMMONER_20080313
; 417  : 	case 0xA1:
; 418  : 		{
; 419  : 			JGGetAccountInfo((LPSDHP_ANS_ACCOUNTINFO)aRecv);
; 420  : 		} break;
; 421  : 	case 0xA2:
; 422  : 		{
; 423  : 			JGSetAccountInfo((LPSDHP_ANS_SETACCOUNTINFO)aRecv);
; 424  : 		} break;
; 425  : #endif // ADD_CHARCARD_SUMMONER_20080313
; 426  : 
; 427  : 	case 0xA8:
; 428  : 		g_ResetSystem.DBLoadReset(aRecv);

  000e4	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000e7	50		 push	 eax
  000e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ResetSystem@@3VCResetSystem@@A ; g_ResetSystem
  000ed	e8 00 00 00 00	 call	 ?DBLoadReset@CResetSystem@@QAEXPAE@Z ; CResetSystem::DBLoadReset

; 429  : 		break;

  000f2	eb 34		 jmp	 SHORT $LN1@DataServer
$LN15@DataServer:

; 430  : 
; 431  : 	case 0xA9:
; 432  : 		g_ResetSystem.DBAnsUpdateReset(aRecv);

  000f4	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000f7	50		 push	 eax
  000f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ResetSystem@@3VCResetSystem@@A ; g_ResetSystem
  000fd	e8 00 00 00 00	 call	 ?DBAnsUpdateReset@CResetSystem@@QAEXPAE@Z ; CResetSystem::DBAnsUpdateReset

; 433  : 		break;

  00102	eb 24		 jmp	 SHORT $LN1@DataServer
$LN16@DataServer:

; 434  : 
; 435  : 	/*case 0xAA:
; 436  : 		g_VIPSystem.UpdateVip((LPPMSG_ANS_VIP)aRecv);
; 437  : 		break;*/
; 438  : 
; 439  : 	case 0xFF :
; 440  : 		{
; 441  : 		LPPMSG_TEST	pMsg = (LPPMSG_TEST)aRecv;

  00104	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00107	89 45 fc	 mov	 DWORD PTR _pMsg$1[ebp], eax

; 442  : 		LogAddC(LOGC_RED,"error-L2DataServer RECV : %d (%d)", aLen, pMsg->count);

  0010a	8b 45 fc	 mov	 eax, DWORD PTR _pMsg$1[ebp]
  0010d	8b 88 d0 07 00
	00		 mov	 ecx, DWORD PTR [eax+2000]
  00113	51		 push	 ecx
  00114	8b 55 10	 mov	 edx, DWORD PTR _aLen$[ebp]
  00117	52		 push	 edx
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CF@
  0011d	6a 02		 push	 2
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00125	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@DataServer:

; 443  : 		//TestDSSend();
; 444  : 		}
; 445  : 		break;
; 446  : 
; 447  : 	}	
; 448  : }

  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
  0012f	90		 npad	 1
$LN20@DataServer:
  00130	00 00 00 00	 DD	 $LN4@DataServer
  00134	00 00 00 00	 DD	 $LN5@DataServer
  00138	00 00 00 00	 DD	 $LN6@DataServer
  0013c	00 00 00 00	 DD	 $LN7@DataServer
  00140	00 00 00 00	 DD	 $LN8@DataServer
  00144	00 00 00 00	 DD	 $LN9@DataServer
  00148	00 00 00 00	 DD	 $LN10@DataServer
  0014c	00 00 00 00	 DD	 $LN11@DataServer
  00150	00 00 00 00	 DD	 $LN12@DataServer
  00154	00 00 00 00	 DD	 $LN13@DataServer
  00158	00 00 00 00	 DD	 $LN14@DataServer
  0015c	00 00 00 00	 DD	 $LN15@DataServer
  00160	00 00 00 00	 DD	 $LN1@DataServer
$LN19@DataServer:
  00164	00		 DB	 0
  00165	01		 DB	 1
  00166	0c		 DB	 12			; 0000000cH
  00167	0c		 DB	 12			; 0000000cH
  00168	02		 DB	 2
  00169	03		 DB	 3
  0016a	04		 DB	 4
  0016b	0c		 DB	 12			; 0000000cH
  0016c	05		 DB	 5
  0016d	0c		 DB	 12			; 0000000cH
  0016e	0c		 DB	 12			; 0000000cH
  0016f	0c		 DB	 12			; 0000000cH
  00170	0c		 DB	 12			; 0000000cH
  00171	0c		 DB	 12			; 0000000cH
  00172	0c		 DB	 12			; 0000000cH
  00173	0c		 DB	 12			; 0000000cH
  00174	06		 DB	 6
  00175	0c		 DB	 12			; 0000000cH
  00176	0c		 DB	 12			; 0000000cH
  00177	0c		 DB	 12			; 0000000cH
  00178	0c		 DB	 12			; 0000000cH
  00179	0c		 DB	 12			; 0000000cH
  0017a	0c		 DB	 12			; 0000000cH
  0017b	0c		 DB	 12			; 0000000cH
  0017c	0c		 DB	 12			; 0000000cH
  0017d	0c		 DB	 12			; 0000000cH
  0017e	0c		 DB	 12			; 0000000cH
  0017f	0c		 DB	 12			; 0000000cH
  00180	0c		 DB	 12			; 0000000cH
  00181	0c		 DB	 12			; 0000000cH
  00182	0c		 DB	 12			; 0000000cH
  00183	0c		 DB	 12			; 0000000cH
  00184	0c		 DB	 12			; 0000000cH
  00185	0c		 DB	 12			; 0000000cH
  00186	0c		 DB	 12			; 0000000cH
  00187	0c		 DB	 12			; 0000000cH
  00188	0c		 DB	 12			; 0000000cH
  00189	0c		 DB	 12			; 0000000cH
  0018a	0c		 DB	 12			; 0000000cH
  0018b	0c		 DB	 12			; 0000000cH
  0018c	0c		 DB	 12			; 0000000cH
  0018d	0c		 DB	 12			; 0000000cH
  0018e	0c		 DB	 12			; 0000000cH
  0018f	0c		 DB	 12			; 0000000cH
  00190	0c		 DB	 12			; 0000000cH
  00191	0c		 DB	 12			; 0000000cH
  00192	0c		 DB	 12			; 0000000cH
  00193	0c		 DB	 12			; 0000000cH
  00194	0c		 DB	 12			; 0000000cH
  00195	0c		 DB	 12			; 0000000cH
  00196	0c		 DB	 12			; 0000000cH
  00197	0c		 DB	 12			; 0000000cH
  00198	0c		 DB	 12			; 0000000cH
  00199	0c		 DB	 12			; 0000000cH
  0019a	0c		 DB	 12			; 0000000cH
  0019b	0c		 DB	 12			; 0000000cH
  0019c	0c		 DB	 12			; 0000000cH
  0019d	0c		 DB	 12			; 0000000cH
  0019e	0c		 DB	 12			; 0000000cH
  0019f	0c		 DB	 12			; 0000000cH
  001a0	0c		 DB	 12			; 0000000cH
  001a1	0c		 DB	 12			; 0000000cH
  001a2	0c		 DB	 12			; 0000000cH
  001a3	0c		 DB	 12			; 0000000cH
  001a4	0c		 DB	 12			; 0000000cH
  001a5	0c		 DB	 12			; 0000000cH
  001a6	0c		 DB	 12			; 0000000cH
  001a7	0c		 DB	 12			; 0000000cH
  001a8	0c		 DB	 12			; 0000000cH
  001a9	0c		 DB	 12			; 0000000cH
  001aa	0c		 DB	 12			; 0000000cH
  001ab	0c		 DB	 12			; 0000000cH
  001ac	0c		 DB	 12			; 0000000cH
  001ad	0c		 DB	 12			; 0000000cH
  001ae	0c		 DB	 12			; 0000000cH
  001af	0c		 DB	 12			; 0000000cH
  001b0	0c		 DB	 12			; 0000000cH
  001b1	0c		 DB	 12			; 0000000cH
  001b2	0c		 DB	 12			; 0000000cH
  001b3	0c		 DB	 12			; 0000000cH
  001b4	0c		 DB	 12			; 0000000cH
  001b5	0c		 DB	 12			; 0000000cH
  001b6	07		 DB	 7
  001b7	0c		 DB	 12			; 0000000cH
  001b8	0c		 DB	 12			; 0000000cH
  001b9	0c		 DB	 12			; 0000000cH
  001ba	08		 DB	 8
  001bb	0c		 DB	 12			; 0000000cH
  001bc	0c		 DB	 12			; 0000000cH
  001bd	0c		 DB	 12			; 0000000cH
  001be	0c		 DB	 12			; 0000000cH
  001bf	0c		 DB	 12			; 0000000cH
  001c0	0c		 DB	 12			; 0000000cH
  001c1	0c		 DB	 12			; 0000000cH
  001c2	0c		 DB	 12			; 0000000cH
  001c3	0c		 DB	 12			; 0000000cH
  001c4	09		 DB	 9
  001c5	0c		 DB	 12			; 0000000cH
  001c6	0c		 DB	 12			; 0000000cH
  001c7	0c		 DB	 12			; 0000000cH
  001c8	0c		 DB	 12			; 0000000cH
  001c9	0c		 DB	 12			; 0000000cH
  001ca	0c		 DB	 12			; 0000000cH
  001cb	0c		 DB	 12			; 0000000cH
  001cc	0c		 DB	 12			; 0000000cH
  001cd	0c		 DB	 12			; 0000000cH
  001ce	0c		 DB	 12			; 0000000cH
  001cf	0c		 DB	 12			; 0000000cH
  001d0	0c		 DB	 12			; 0000000cH
  001d1	0c		 DB	 12			; 0000000cH
  001d2	0c		 DB	 12			; 0000000cH
  001d3	0c		 DB	 12			; 0000000cH
  001d4	0c		 DB	 12			; 0000000cH
  001d5	0c		 DB	 12			; 0000000cH
  001d6	0c		 DB	 12			; 0000000cH
  001d7	0c		 DB	 12			; 0000000cH
  001d8	0c		 DB	 12			; 0000000cH
  001d9	0c		 DB	 12			; 0000000cH
  001da	0c		 DB	 12			; 0000000cH
  001db	0c		 DB	 12			; 0000000cH
  001dc	0c		 DB	 12			; 0000000cH
  001dd	0c		 DB	 12			; 0000000cH
  001de	0c		 DB	 12			; 0000000cH
  001df	0c		 DB	 12			; 0000000cH
  001e0	0c		 DB	 12			; 0000000cH
  001e1	0c		 DB	 12			; 0000000cH
  001e2	0c		 DB	 12			; 0000000cH
  001e3	0c		 DB	 12			; 0000000cH
  001e4	0c		 DB	 12			; 0000000cH
  001e5	0c		 DB	 12			; 0000000cH
  001e6	0c		 DB	 12			; 0000000cH
  001e7	0c		 DB	 12			; 0000000cH
  001e8	0c		 DB	 12			; 0000000cH
  001e9	0c		 DB	 12			; 0000000cH
  001ea	0c		 DB	 12			; 0000000cH
  001eb	0c		 DB	 12			; 0000000cH
  001ec	0c		 DB	 12			; 0000000cH
  001ed	0c		 DB	 12			; 0000000cH
  001ee	0c		 DB	 12			; 0000000cH
  001ef	0c		 DB	 12			; 0000000cH
  001f0	0c		 DB	 12			; 0000000cH
  001f1	0c		 DB	 12			; 0000000cH
  001f2	0c		 DB	 12			; 0000000cH
  001f3	0c		 DB	 12			; 0000000cH
  001f4	0c		 DB	 12			; 0000000cH
  001f5	0c		 DB	 12			; 0000000cH
  001f6	0c		 DB	 12			; 0000000cH
  001f7	0c		 DB	 12			; 0000000cH
  001f8	0c		 DB	 12			; 0000000cH
  001f9	0c		 DB	 12			; 0000000cH
  001fa	0c		 DB	 12			; 0000000cH
  001fb	0c		 DB	 12			; 0000000cH
  001fc	0c		 DB	 12			; 0000000cH
  001fd	0c		 DB	 12			; 0000000cH
  001fe	0c		 DB	 12			; 0000000cH
  001ff	0c		 DB	 12			; 0000000cH
  00200	0c		 DB	 12			; 0000000cH
  00201	0c		 DB	 12			; 0000000cH
  00202	0c		 DB	 12			; 0000000cH
  00203	0c		 DB	 12			; 0000000cH
  00204	0c		 DB	 12			; 0000000cH
  00205	0c		 DB	 12			; 0000000cH
  00206	0c		 DB	 12			; 0000000cH
  00207	0c		 DB	 12			; 0000000cH
  00208	0c		 DB	 12			; 0000000cH
  00209	0c		 DB	 12			; 0000000cH
  0020a	0c		 DB	 12			; 0000000cH
  0020b	0c		 DB	 12			; 0000000cH
  0020c	0a		 DB	 10			; 0000000aH
  0020d	0b		 DB	 11			; 0000000bH
?DataServerProtocolCore@@YAXEPAEH@Z ENDP		; DataServerProtocolCore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TerrainManager.h
;	COMDAT ?Size@CTerrainManager@@QAE?BHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Size@CTerrainManager@@QAE?BHXZ PROC			; CTerrainManager::Size, COMDAT
; _this$ = ecx

; 22   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 		return m_iSize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 24   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Size@CTerrainManager@@QAE?BHXZ ENDP			; CTerrainManager::Size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\ProDef.h
;	COMDAT ?set@PWMSG_HEAD@@QAEXPAEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?set@PWMSG_HEAD@@QAEXPAEEH@Z PROC			; PWMSG_HEAD::set, COMDAT
; _this$ = ecx

; 56   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 57   : 		lpBuf[0] = PMHC_WORD;

  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	6b c8 00	 imul	 ecx, eax, 0
  00014	8b 55 08	 mov	 edx, DWORD PTR _lpBuf$[ebp]
  00017	c6 04 0a c2	 mov	 BYTE PTR [edx+ecx], 194	; 000000c2H

; 58   : 		lpBuf[1] = HIBYTE(size);

  0001b	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  0001e	c1 e8 08	 shr	 eax, 8
  00021	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00026	b9 01 00 00 00	 mov	 ecx, 1
  0002b	c1 e1 00	 shl	 ecx, 0
  0002e	8b 55 08	 mov	 edx, DWORD PTR _lpBuf$[ebp]
  00031	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 59   : 		lpBuf[2] = LOBYTE(size);

  00034	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00037	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003c	b9 01 00 00 00	 mov	 ecx, 1
  00041	d1 e1		 shl	 ecx, 1
  00043	8b 55 08	 mov	 edx, DWORD PTR _lpBuf$[ebp]
  00046	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 60   : 		lpBuf[3] = head;

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	6b c8 03	 imul	 ecx, eax, 3
  00051	8b 55 08	 mov	 edx, DWORD PTR _lpBuf$[ebp]
  00054	8a 45 0c	 mov	 al, BYTE PTR _head$[ebp]
  00057	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 61   : 	}

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 0c 00	 ret	 12			; 0000000cH
?set@PWMSG_HEAD@@QAEXPAEEH@Z ENDP			; PWMSG_HEAD::set
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 535  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 536  :             return _time64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __time64
  00012	83 c4 04	 add	 esp, 4

; 537  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DSProtocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
