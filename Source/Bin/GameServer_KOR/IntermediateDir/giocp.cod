; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?SOCKET_FLAG@@3W4<unnamed-type-SOCKET_FLAG>@@A	; SOCKET_FLAG
PUBLIC	?criti@@3U_RTL_CRITICAL_SECTION@@A		; criti
PUBLIC	?g_dwThreadCount@@3KA				; g_dwThreadCount
PUBLIC	?g_ThreadHandles@@3PAPAXA			; g_ThreadHandles
PUBLIC	?g_Listen@@3IA					; g_Listen
PUBLIC	?g_ServerPort@@3HA				; g_ServerPort
PUBLIC	?g_CompletionPort@@3PAXA			; g_CompletionPort
PUBLIC	?g_IocpThreadHandle@@3PAXA			; g_IocpThreadHandle
PUBLIC	?ExSendBuf@@3PAEA				; ExSendBuf
_BSS	SEGMENT
?SOCKET_FLAG@@3W4<unnamed-type-SOCKET_FLAG>@@A DD 01H DUP (?) ; SOCKET_FLAG
?criti@@3U_RTL_CRITICAL_SECTION@@A DB 018H DUP (?)	; criti
?g_dwThreadCount@@3KA DD 01H DUP (?)			; g_dwThreadCount
?g_ThreadHandles@@3PAPAXA DD 010H DUP (?)		; g_ThreadHandles
?g_ServerPort@@3HA DD 01H DUP (?)			; g_ServerPort
?g_CompletionPort@@3PAXA DD 01H DUP (?)			; g_CompletionPort
?g_IocpThreadHandle@@3PAXA DD 01H DUP (?)		; g_IocpThreadHandle
?ExSendBuf@@3PAEA DD 01H DUP (?)			; ExSendBuf
_BSS	ENDS
_DATA	SEGMENT
?g_Listen@@3IA DD 0ffffffffH				; g_Listen
_DATA	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?GiocpInit@@YAXXZ				; GiocpInit
PUBLIC	?GiocpDelete@@YAXXZ				; GiocpDelete
PUBLIC	?CreateGIocp@@YAHH@Z				; CreateGIocp
PUBLIC	?UpdateCompletionPort@@YAHIHH@Z			; UpdateCompletionPort
PUBLIC	?CloseClient@@YAXH@Z				; CloseClient
PUBLIC	?CloseClientEx@@YAXH@Z				; CloseClientEx
PUBLIC	?DataSend@@YAHHPAEK@Z				; DataSend
PUBLIC	?ResponErrorCloseClient@@YAXH@Z			; ResponErrorCloseClient
PUBLIC	?DestroyGIocp@@YAXXZ				; DestroyGIocp
PUBLIC	??0CStreamPacketEngine_Server@@QAE@XZ		; CStreamPacketEngine_Server::CStreamPacketEngine_Server
PUBLIC	??1CStreamPacketEngine_Server@@UAE@XZ		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
PUBLIC	?Clear@CStreamPacketEngine_Server@@QAEXXZ	; CStreamPacketEngine_Server::Clear
PUBLIC	?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z	; CStreamPacketEngine_Server::XorData
PUBLIC	?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z	; CStreamPacketEngine_Server::AddData
PUBLIC	?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
PUBLIC	??_GCStreamPacketEngine_Server@@UAEPAXI@Z	; CStreamPacketEngine_Server::`scalar deleting destructor'
PUBLIC	?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z	; RecvDataParse
PUBLIC	?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z	; CloseClient
PUBLIC	?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z	; IoSendSecond
PUBLIC	?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z	; IoMoreSend
PUBLIC	?IocpServerWorker@@YGKPAX@Z			; IocpServerWorker
PUBLIC	?ServerWorkerThread@@YGKPAX@Z			; ServerWorkerThread
PUBLIC	?IsHackTool@@YAHEHHE@Z				; IsHackTool
PUBLIC	?CreateListenSocket@@YAHXZ			; CreateListenSocket
PUBLIC	??_7CStreamPacketEngine_Server@@6B@		; CStreamPacketEngine_Server::`vftable'
PUBLIC	??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Err@ ; `string'
PUBLIC	??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buff@ ; `string'
PUBLIC	?__LINE__Var@?0??IsHackTool@@YAHEHHE@Z@4JA	; `IsHackTool'::`1'::__LINE__Var
PUBLIC	??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	??_C@_0GB@DNFPOLMM@?0?5?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Seco@ ; `string'
PUBLIC	??_C@_0FI@JLMDBNFF@?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Second@ ; `string'
PUBLIC	??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5erro@ ; `string'
PUBLIC	??_C@_09HNKOADHB@Error?9L10@			; `string'
PUBLIC	??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CF@ ; `string'
PUBLIC	??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	??_C@_0CM@FGEFAMMO@?5?$CK?$CK?$CK?$CK?5Worker?5Thread?5Max?5Count?5F@ ; `string'
PUBLIC	??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5w@ ; `string'
PUBLIC	??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CF@ ; `string'
PUBLIC	??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91@ ; `string'
PUBLIC	??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComple@ ; `string'
PUBLIC	??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5fail@ ; `string'
PUBLIC	??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5wit@ ; `string'
PUBLIC	??_C@_0CM@COJCIKFD@?0?5?$FLConnect?$FN?0?5Account?5?$FL?$CFs?$FN?0?5IP?5?$FL@ ; `string'
PUBLIC	??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompleti@ ; `string'
PUBLIC	??_C@_0DA@NINFHBLD@Connection?5Closed?0?5bSuccess?5?$DN?$DN?5@ ; `string'
PUBLIC	??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?5@ ; `string'
PUBLIC	??_C@_0BE@NKDBKMD@lpIoContext?5is?5NULL@	; `string'
PUBLIC	??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5@ ; `string'
PUBLIC	??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA ; `RecvDataParse'::`1'::__LINE__Var
PUBLIC	??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd@	; `string'
PUBLIC	??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5@ ; `string'
PUBLIC	??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5@ ; `string'
PUBLIC	??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN@ ; `string'
PUBLIC	??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_0BA@OIIBACED@Message?5copy?5?$CFd@	; `string'
PUBLIC	?__LINE__Var@?0??DataSend@@YAHHPAEK@Z@4JA	; `DataSend'::`1'::__LINE__Var
PUBLIC	??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5@ ; `string'
PUBLIC	??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd@ ; `string'
PUBLIC	??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd@ ; `string'
PUBLIC	??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5err@ ; `string'
PUBLIC	?__LINE__Var@?0??IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z@4JA ; `IoSendSecond'::`1'::__LINE__Var
PUBLIC	??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CF@ ; `string'
PUBLIC	?__LINE__Var@?0??IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z@4JA ; `IoMoreSend'::`1'::__LINE__Var
PUBLIC	??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5er@ ; `string'
PUBLIC	??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5@ ; `string'
PUBLIC	??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_@ ; `string'
PUBLIC	??_R4CStreamPacketEngine_Server@@6B@		; CStreamPacketEngine_Server::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCStreamPacketEngine_Server@@@8		; CStreamPacketEngine_Server `RTTI Type Descriptor'
PUBLIC	??_R3CStreamPacketEngine_Server@@8		; CStreamPacketEngine_Server::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CStreamPacketEngine_Server@@8		; CStreamPacketEngine_Server::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CStreamPacketEngine_Server@@8	; CStreamPacketEngine_Server::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__CreateIoCompletionPort@16:PROC
EXTRN	__imp__GetQueuedCompletionStatus@20:PROC
EXTRN	__imp__PostQueuedCompletionStatus@16:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	_srand:PROC
EXTRN	__time64:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__htonl@4:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__inet_ntoa@4:PROC
EXTRN	__imp__listen@8:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSAAccept@20:PROC
EXTRN	__imp__WSARecv@28:PROC
EXTRN	__imp__WSASend@28:PROC
EXTRN	__imp__WSASocketA@24:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?Process@PacketStatistics@@QAE?AW4PROCESS_RETURN@1@XZ:PROC ; PacketStatistics::Process
EXTRN	?AddPacketInfo@PacketStatistics@@QAEX_NI@Z:PROC	; PacketStatistics::AddPacketInfo
EXTRN	?GetStatistics@PacketStatistics@@QAEXAAH0AAI@Z:PROC ; PacketStatistics::GetStatistics
EXTRN	?gObjAdd@@YAFIPADH@Z:PROC			; gObjAdd
EXTRN	?gObjAddSearch@@YAFIPAD@Z:PROC			; gObjAddSearch
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?ProtocolCore@@YAXEPAEHHHH@Z:PROC		; ProtocolCore
EXTRN	?SCPJoinResultSend@@YAXHE@Z:PROC		; SCPJoinResultSend
EXTRN	?Updateoffafk@COFFSystem@@QAE_NHE@Z:PROC	; COFFSystem::Updateoffafk
EXTRN	?Updateofftrade@COFFtrade@@QAE_NHE@Z:PROC	; COFFtrade::Updateofftrade
EXTRN	?Encrypt@CSimpleModulus@@QAEHPAX0H@Z:PROC	; CSimpleModulus::Encrypt
EXTRN	?Decrypt@CSimpleModulus@@QAEHPAX0H@Z:PROC	; CSimpleModulus::Decrypt
EXTRN	??_ECStreamPacketEngine_Server@@UAEPAXI@Z:PROC	; CStreamPacketEngine_Server::`vector deleting destructor'
EXTRN	?Update@cOffExp@@QAE_NHE@Z:PROC			; cOffExp::Update
EXTRN	?GetSendSerial@NSerialCheck@@QAEEXZ:PROC	; NSerialCheck::GetSendSerial
EXTRN	?ChkBlockIp@@YA_NPAUIP_BLOCK@@@Z:PROC		; ChkBlockIp
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	__except_handler4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddL@@3P6AXPADZZA:DWORD			; LogAddL
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?LogAddTD_TempLog@@3P6AXPADZZA:DWORD		; LogAddTD_TempLog
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?OFFSystem@@3VCOFFSystem@@A:BYTE		; OFFSystem
EXTRN	?OFFtrade@@3VCOFFtrade@@A:BYTE			; OFFtrade
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?OffExp@@3VcOffExp@@A:BYTE			; OffExp
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
EXTRN	?g_SimpleModulusCS@@3VCSimpleModulus@@A:BYTE	; g_SimpleModulusCS
EXTRN	?g_SimpleModulusSC@@3VCSimpleModulus@@A:BYTE	; g_SimpleModulusSC
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CStreamPacketEngine_Server@@8 DD FLAT:??_R0?AVCStreamPacketEngine_Server@@@8 ; CStreamPacketEngine_Server::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_R2CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R2CStreamPacketEngine_Server@@8 DD FLAT:??_R1A@?0A@EA@CStreamPacketEngine_Server@@8 ; CStreamPacketEngine_Server::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CStreamPacketEngine_Server@@8
rdata$r	SEGMENT
??_R3CStreamPacketEngine_Server@@8 DD 00H		; CStreamPacketEngine_Server::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCStreamPacketEngine_Server@@@8
data$r	SEGMENT
??_R0?AVCStreamPacketEngine_Server@@@8 DD FLAT:??_7type_info@@6B@ ; CStreamPacketEngine_Server `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCStreamPacketEngine_Server@@', 00H
data$r	ENDS
;	COMDAT ??_R4CStreamPacketEngine_Server@@6B@
rdata$r	SEGMENT
??_R4CStreamPacketEngine_Server@@6B@ DD 00H		; CStreamPacketEngine_Server::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCStreamPacketEngine_Server@@@8
	DD	FLAT:??_R3CStreamPacketEngine_Server@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_@
CONST	SEGMENT
??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_@ DB 'error-L1 : C'
	DB	'loseClient INVALID_SOCKET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5@
CONST	SEGMENT
??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5@ DB 'error-L1 : '
	DB	'CloseClient connect error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5er@
CONST	SEGMENT
??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5er@ DB 'error-L1 : '
	DB	'CloseClient index error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd@
CONST	SEGMENT
??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd@ DB 'CreateIoCompletio'
	DB	'nPort: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z@4JA DD 0484H ; `IoMoreSend'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CF@
CONST	SEGMENT
??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CF@ DB 'W'
	DB	'SASend(%d) failed with error %d %s ', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z@4JA DD 044dH ; `IoSendSecond'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5err@
CONST	SEGMENT
??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5err@ DB '('
	DB	'%d)WSASend(%d) failed with error [%x][%x] %d %s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd@
CONST	SEGMENT
??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd@ DB '('
	DB	'%d)error-L2 MAX BUFFER OVER %d %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd@
CONST	SEGMENT
??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd@ DB '('
	DB	'%d)error-L2 MAX BUFFER OVER %d %d %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd@ DB 'Er'
	DB	'ror : Max msg(%d) %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5@
CONST	SEGMENT
??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5@ DB 'e'
	DB	'rror-L2 : Index(%d) %x %x %x ', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DataSend@@YAHHPAEK@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??DataSend@@YAHHPAEK@Z@4JA DD 0381H	; `DataSend'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@OIIBACED@Message?5copy?5?$CFd@
CONST	SEGMENT
??_C@_0BA@OIIBACED@Message?5copy?5?$CFd@ DB 'Message copy %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd@ DB 'error-'
	DB	'L1 : recvbuflen 1 %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN@
CONST	SEGMENT
??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN@ DB 0beH, 0cfH
	DB	0c8H, 0a3H, 0c6H, 0d0H, 0c5H, 0b6H, ' : [0x%x]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5@
CONST	SEGMENT
??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5@ DB 'error-L1 : C'
	DB	'StreamPacketEngine ExtractPacket Error : ip = %s account:%s n'
	DB	'ame:%s HEAD:%x (%s,%d) State:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5@
CONST	SEGMENT
??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5@ DB 'error-L1 : C'
	DB	'StreamPacketEngine Adding Error : ip = %s account:%s name:%s '
	DB	'HEAD:%x (%s,%d) State:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd@
CONST	SEGMENT
??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd@ DB 'error-L1 : size %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJ@
CONST	SEGMENT
??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJ@ DB 'e'
	DB	'rror-L1 : Header error (%s %d)lOfs:%d, size:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA DD 0218H ; `RecvDataParse'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd@ DB 'WSARe'
	DB	'cv() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5@
CONST	SEGMENT
??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5@ DB 'error-L1 :'
	DB	' Socket Header error %d, %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NKDBKMD@lpIoContext?5is?5NULL@
CONST	SEGMENT
??_C@_0BE@NKDBKMD@lpIoContext?5is?5NULL@ DB 'lpIoContext is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?5@
CONST	SEGMENT
??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?5@ DB 'Connec'
	DB	'tion Closed, dwIoSize == 0 (Index:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NINFHBLD@Connection?5Closed?0?5bSuccess?5?$DN?$DN?5@
CONST	SEGMENT
??_C@_0DA@NINFHBLD@Connection?5Closed?0?5bSuccess?5?$DN?$DN?5@ DB 'Connec'
	DB	'tion Closed, bSuccess == FALSE (Index:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompleti@
CONST	SEGMENT
??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompleti@ DB 'Error Thread '
	DB	': GetQueueCompletionStatus( %d )', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@COJCIKFD@?0?5?$FLConnect?$FN?0?5Account?5?$FL?$CFs?$FN?0?5IP?5?$FL@
CONST	SEGMENT
??_C@_0CM@COJCIKFD@?0?5?$FLConnect?$FN?0?5Account?5?$FL?$CFs?$FN?0?5IP?5?$FL@ DB ','
	DB	' [Connect], Account [%s], IP [%s], Success', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5wit@
CONST	SEGMENT
??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5wit@ DB 'error'
	DB	'-L1 : WSARecv() failed with error %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5fail@
CONST	SEGMENT
??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5fail@ DB 'e'
	DB	'rror-L1 : %d %d gObjAdd() failed with error %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComple@
CONST	SEGMENT
??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComple@ DB 'error'
	DB	'-L1 : %d %d CreateIoCompletionPort failed with error %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91@
CONST	SEGMENT
??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91@ DB 'error-L2 : C'
	DB	'lientIndex = -1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CF@
CONST	SEGMENT
??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CF@ DB 'WSAA'
	DB	'ccept() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5w@
CONST	SEGMENT
??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5w@ DB 'CreateIoComplet'
	DB	'ionPort failed with error: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FGEFAMMO@?5?$CK?$CK?$CK?$CK?5Worker?5Thread?5Max?5Count?5F@
CONST	SEGMENT
??_C@_0CM@FGEFAMMO@?5?$CK?$CK?$CK?$CK?5Worker?5Thread?5Max?5Count?5F@ DB ' '
	DB	'**** Worker Thread Max Count Fix 16ea ****', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd@
CONST	SEGMENT
??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd@ DB 'listen'
	DB	'() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CF@
CONST	SEGMENT
??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CF@ DB 'WSAS'
	DB	'ocket() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HNKOADHB@Error?9L10@
CONST	SEGMENT
??_C@_09HNKOADHB@Error?9L10@ DB 'Error-L10', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5erro@
CONST	SEGMENT
??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5erro@ DB 'CreateTh'
	DB	'read() failed with error %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@JLMDBNFF@?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Second@
CONST	SEGMENT
??_C@_0FI@JLMDBNFF@?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Second@ DB '[HACKT'
	DB	'OOL] : Packets Per Second = %dip = %s account:%s name:%s HEAD'
	DB	':%x (%s,%d) State:%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@DNFPOLMM@?0?5?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Seco@
CONST	SEGMENT
??_C@_0GB@DNFPOLMM@?0?5?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Seco@ DB ', [H'
	DB	'ACKTOOL] : Packets Per Second = %d,account [%s], ip [%s], nam'
	DB	'e:%s, HEAD:%x (%s,%d), State:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onli'
	DB	'ne\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??IsHackTool@@YAHEHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??IsHackTool@@YAHEHHE@Z@4JA DD 050H	; `IsHackTool'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buff@
CONST	SEGMENT
??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buff@ DB 'CStreamPacketEng'
	DB	'ine Adding Buffer Size Error %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Err@
CONST	SEGMENT
??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Err@ DB 'CStreamPacketEn'
	DB	'gine XorData Error %d,%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7CStreamPacketEngine_Server@@6B@
CONST	SEGMENT
??_7CStreamPacketEngine_Server@@6B@ DD FLAT:??_R4CStreamPacketEngine_Server@@6B@ ; CStreamPacketEngine_Server::`vftable'
	DD	FLAT:??_ECStreamPacketEngine_Server@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?IocpServerWorker@@YGKPAX@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffff10H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN32@IocpServer
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$2
__ehfuncinfo$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?CreateListenSocket@@YAHXZ
_TEXT	SEGMENT
_nRet$ = -24						; size = 4
_InternetAddr$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
?CreateListenSocket@@YAHXZ PROC				; CreateListenSocket, COMDAT

; 174  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 175  : 	SOCKADDR_IN InternetAddr;
; 176  : 	int			nRet;
; 177  : 
; 178  : 	g_Listen = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);

  00013	6a 01		 push	 1
  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	6a 00		 push	 0
  0001b	6a 01		 push	 1
  0001d	6a 02		 push	 2
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24
  00025	a3 00 00 00 00	 mov	 DWORD PTR ?g_Listen@@3IA, eax ; g_Listen

; 179  : 	if (g_Listen == INVALID_SOCKET)

  0002a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?g_Listen@@3IA, -1 ; g_Listen
  00031	75 1c		 jne	 SHORT $LN2@CreateList

; 180  : 	{
; 181  : 		LogAdd("WSASocket() failed with error %d", WSAGetLastError());

  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MJLDDOOB@WSASocket?$CI?$CJ?5failed?5with?5error?5?$CF@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00045	83 c4 08	 add	 esp, 8

; 182  : 		return FALSE;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 a6 00 00 00	 jmp	 $LN1@CreateList
$LN2@CreateList:

; 183  : 	} 
; 184  : 	
; 185  : 	InternetAddr.sin_family			= AF_INET;

  0004f	b8 02 00 00 00	 mov	 eax, 2
  00054	66 89 45 ec	 mov	 WORD PTR _InternetAddr$[ebp], ax

; 186  : 	InternetAddr.sin_addr.s_addr	= htonl(INADDR_ANY);

  00058	6a 00		 push	 0
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4
  00060	89 45 f0	 mov	 DWORD PTR _InternetAddr$[ebp+4], eax

; 187  : 	InternetAddr.sin_port			= htons(g_ServerPort);

  00063	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?g_ServerPort@@3HA
  0006a	50		 push	 eax
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  00071	66 89 45 ee	 mov	 WORD PTR _InternetAddr$[ebp+2], ax

; 188  : 	
; 189  : 	nRet = bind(g_Listen, (PSOCKADDR) &InternetAddr, sizeof(InternetAddr));

  00075	6a 10		 push	 16			; 00000010H
  00077	8d 45 ec	 lea	 eax, DWORD PTR _InternetAddr$[ebp]
  0007a	50		 push	 eax
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_Listen@@3IA ; g_Listen
  00081	51		 push	 ecx
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12
  00088	89 45 e8	 mov	 DWORD PTR _nRet$[ebp], eax

; 190  : 	if( nRet == SOCKET_ERROR )

  0008b	83 7d e8 ff	 cmp	 DWORD PTR _nRet$[ebp], -1
  0008f	75 2f		 jne	 SHORT $LN3@CreateList

; 191  : 	{
; 192  : 		MsgBox(lMsg.Get(567));

  00091	68 37 02 00 00	 push	 567			; 00000237H
  00096	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000a7	83 c4 04	 add	 esp, 4

; 193  : 		SendMessage(ghWnd, WM_CLOSE, 0,0);

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	6a 10		 push	 16			; 00000010H
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 194  : 		return FALSE;

  000bc	33 c0		 xor	 eax, eax
  000be	eb 35		 jmp	 SHORT $LN1@CreateList
$LN3@CreateList:

; 195  : 	}
; 196  : 
; 197  : 	nRet = listen(g_Listen, 5);

  000c0	6a 05		 push	 5
  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_Listen@@3IA ; g_Listen
  000c7	50		 push	 eax
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__listen@8
  000ce	89 45 e8	 mov	 DWORD PTR _nRet$[ebp], eax

; 198  : 
; 199  : 	if (nRet == SOCKET_ERROR)

  000d1	83 7d e8 ff	 cmp	 DWORD PTR _nRet$[ebp], -1
  000d5	75 19		 jne	 SHORT $LN4@CreateList

; 200  : 	{
; 201  : 		LogAdd("listen() failed with error %d", WSAGetLastError());

  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000dd	50		 push	 eax
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KHMIJPLC@listen?$CI?$CJ?5failed?5with?5error?5?$CFd@
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000e9	83 c4 08	 add	 esp, 8

; 202  : 		return FALSE;

  000ec	33 c0		 xor	 eax, eax
  000ee	eb 05		 jmp	 SHORT $LN1@CreateList
$LN4@CreateList:

; 203  : 	} 
; 204  : 	return TRUE;

  000f0	b8 01 00 00 00	 mov	 eax, 1
$LN1@CreateList:

; 205  : }

  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	33 cd		 xor	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
?CreateListenSocket@@YAHXZ ENDP				; CreateListenSocket
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?IsHackTool@@YAHEHHE@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
tv175 = -77						; size = 1
_iOutPacketTotalSize$1 = -12				; size = 4
_iOutEncryptPacketCount$2 = -8				; size = 4
_iOutPacketCount$3 = -4					; size = 4
_headcode$ = 8						; size = 1
_size$ = 12						; size = 4
_uIndex$ = 16						; size = 4
_xcode$ = 20						; size = 1
?IsHackTool@@YAHEHHE@Z PROC				; IsHackTool, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 81   : 	if(CHECK_LIMIT( uIndex, MAX_OBJECT ))

  00009	83 7d 10 00	 cmp	 DWORD PTR _uIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN10@IsHackTool
  0000f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN11@IsHackTool
$LN10@IsHackTool:
  00018	81 7d 10 e7 1c
	00 00		 cmp	 DWORD PTR _uIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN8@IsHackTool
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN9@IsHackTool
$LN8@IsHackTool:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@IsHackTool:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN11@IsHackTool:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	0f 84 85 01 00
	00		 je	 $LN2@IsHackTool

; 82   : 	{
; 83   : 		int				iOutPacketCount;
; 84   : 		int				iOutEncryptPacketCount;
; 85   : 		unsigned int	iOutPacketTotalSize;
; 86   : 		
; 87   : 		gObj[uIndex].m_kRecvPacketStatistics.GetStatistics(iOutPacketCount, iOutEncryptPacketCount, iOutPacketTotalSize);

  00041	8d 45 f4	 lea	 eax, DWORD PTR _iOutPacketTotalSize$1[ebp]
  00044	50		 push	 eax
  00045	8d 4d f8	 lea	 ecx, DWORD PTR _iOutEncryptPacketCount$2[ebp]
  00048	51		 push	 ecx
  00049	8d 55 fc	 lea	 edx, DWORD PTR _iOutPacketCount$3[ebp]
  0004c	52		 push	 edx
  0004d	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005a	8d 8c 01 44 1a
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+6724]
  00061	e8 00 00 00 00	 call	 ?GetStatistics@PacketStatistics@@QAEXAAH0AAI@Z ; PacketStatistics::GetStatistics

; 88   : 		
; 89   : 		if(gObj[uIndex].m_kRecvPacketStatistics.Process() == PacketStatistics::PS_RESET) // 시간되면 통계치가 리셋된다.

  00066	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00073	8d 8c 01 44 1a
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+6724]
  0007a	e8 00 00 00 00	 call	 ?Process@PacketStatistics@@QAE?AW4PROCESS_RETURN@1@XZ ; PacketStatistics::Process

; 90   : 		{
; 91   : 			// 초당 데이터가 잡힌다.
; 92   : //				char temp[1000];
; 93   : //				wsprintf(temp, "PacketCount = %d, iOutEncryptPacketCount = %d, PacketTotalSize = %d\n", iOutPacketCount, iOutEncryptPacketCount, iOutPacketTotalSize);
; 94   : //				OutputDebugString(temp);
; 95   : 		}
; 96   : 		
; 97   : 		if(iOutPacketCount > PACKET_NUMBER_PER_SECOND)

  0007f	81 7d fc c8 00
	00 00		 cmp	 DWORD PTR _iOutPacketCount$3[ebp], 200 ; 000000c8H
  00086	0f 8e dd 00 00
	00		 jle	 $LN4@IsHackTool

; 98   : 		{
; 99   : 
; 100  : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 101  : 			LogAddTD_TempLog(", [HACKTOOL] : Packets Per Second = %d,"

  0008c	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00099	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  0009d	52		 push	 edx
  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??IsHackTool@@YAHEHHE@Z@4JA
  000a3	83 c0 1c	 add	 eax, 28			; 0000001cH
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000ac	0f b6 4d 08	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  000b0	51		 push	 ecx
  000b1	69 55 10 a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bd	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  000c1	51		 push	 ecx
  000c2	69 55 10 a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  000c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ce	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  000d2	51		 push	 ecx
  000d3	69 55 10 a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000df	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  000e3	51		 push	 ecx
  000e4	8b 55 fc	 mov	 edx, DWORD PTR _iOutPacketCount$3[ebp]
  000e7	52		 push	 edx
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@DNFPOLMM@?0?5?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Seco@
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  000f3	83 c4 24	 add	 esp, 36			; 00000024H

; 102  : 				"account [%s], ip [%s], name:%s, HEAD:%x (%s,%d), State:%d", 
; 103  : 				iOutPacketCount,
; 104  : 				gObj[uIndex].AccountID, 
; 105  : 				gObj[uIndex].Ip_addr,
; 106  : 				gObj[uIndex].Name, 
; 107  : 				headcode, 
; 108  : 				__FILE__, __LINE__, 
; 109  : 				gObj[uIndex].Connected);
; 110  : #endif
; 111  : 			LogAddC(LOGC_RED,"[HACKTOOL] : Packets Per Second = %d"

  000f6	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00103	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00107	52		 push	 edx
  00108	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??IsHackTool@@YAHEHHE@Z@4JA
  0010d	83 c0 26	 add	 eax, 38			; 00000026H
  00110	50		 push	 eax
  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00116	0f b6 4d 08	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  0011a	51		 push	 ecx
  0011b	69 55 10 a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00122	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00127	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0012b	51		 push	 ecx
  0012c	69 55 10 a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00133	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00138	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  0013c	51		 push	 ecx
  0013d	69 55 10 a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00144	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00149	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  0014d	51		 push	 ecx
  0014e	8b 55 fc	 mov	 edx, DWORD PTR _iOutPacketCount$3[ebp]
  00151	52		 push	 edx
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@JLMDBNFF@?$FLHACKTOOL?$FN?5?3?5Packets?5Per?5Second@
  00157	6a 02		 push	 2
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0015f	83 c4 28	 add	 esp, 40			; 00000028H

; 112  : 				"ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 113  : 				iOutPacketCount,
; 114  : 				gObj[uIndex].Ip_addr,
; 115  : 				gObj[uIndex].AccountID, 
; 116  : 				gObj[uIndex].Name, 
; 117  : 				headcode, 
; 118  : 				__FILE__, __LINE__, 
; 119  : 				gObj[uIndex].Connected);
; 120  : 			return TRUE;

  00162	b8 01 00 00 00	 mov	 eax, 1
  00167	eb 5f		 jmp	 SHORT $LN1@IsHackTool
$LN4@IsHackTool:

; 121  : 		}
; 122  : 		
; 123  : 		// 0xC3: 친구 삭제, 0xC8: 메모 삭제
; 124  : 		if (headcode == 0xC3 || headcode == 0xC8)

  00169	0f b6 45 08	 movzx	 eax, BYTE PTR _headcode$[ebp]
  0016d	3d c3 00 00 00	 cmp	 eax, 195		; 000000c3H
  00172	74 0b		 je	 SHORT $LN6@IsHackTool
  00174	0f b6 45 08	 movzx	 eax, BYTE PTR _headcode$[ebp]
  00178	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  0017d	75 04		 jne	 SHORT $LN5@IsHackTool
$LN6@IsHackTool:

; 125  : 		{
; 126  : 			return FALSE;

  0017f	33 c0		 xor	 eax, eax
  00181	eb 45		 jmp	 SHORT $LN1@IsHackTool
$LN5@IsHackTool:

; 127  : 		}
; 128  : 		
; 129  : 		gObj[uIndex].m_kRecvPacketStatistics.AddPacketInfo(((xcode == 0xC3) || (xcode == 0xC4))? true : false, size);

  00183	0f b6 45 14	 movzx	 eax, BYTE PTR _xcode$[ebp]
  00187	3d c3 00 00 00	 cmp	 eax, 195		; 000000c3H
  0018c	74 12		 je	 SHORT $LN12@IsHackTool
  0018e	0f b6 4d 14	 movzx	 ecx, BYTE PTR _xcode$[ebp]
  00192	81 f9 c4 00 00
	00		 cmp	 ecx, 196		; 000000c4H
  00198	74 06		 je	 SHORT $LN12@IsHackTool
  0019a	c6 45 b3 00	 mov	 BYTE PTR tv175[ebp], 0
  0019e	eb 04		 jmp	 SHORT $LN13@IsHackTool
$LN12@IsHackTool:
  001a0	c6 45 b3 01	 mov	 BYTE PTR tv175[ebp], 1
$LN13@IsHackTool:
  001a4	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  001a7	52		 push	 edx
  001a8	0f b6 45 b3	 movzx	 eax, BYTE PTR tv175[ebp]
  001ac	50		 push	 eax
  001ad	69 4d 10 a0 1b
	00 00		 imul	 ecx, DWORD PTR _uIndex$[ebp], 7072
  001b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ba	8d 8c 0a 44 1a
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+6724]
  001c1	e8 00 00 00 00	 call	 ?AddPacketInfo@PacketStatistics@@QAEX_NI@Z ; PacketStatistics::AddPacketInfo
$LN2@IsHackTool:

; 130  : 	}
; 131  : 	
; 132  : 	return FALSE;

  001c6	33 c0		 xor	 eax, eax
$LN1@IsHackTool:

; 133  : }

  001c8	5f		 pop	 edi
  001c9	5e		 pop	 esi
  001ca	5b		 pop	 ebx
  001cb	8b e5		 mov	 esp, ebp
  001cd	5d		 pop	 ebp
  001ce	c3		 ret	 0
?IsHackTool@@YAHEHHE@Z ENDP				; IsHackTool
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?ServerWorkerThread@@YGKPAX@Z
_TEXT	SEGMENT
_errorcode$1 = -48					; size = 4
_lpIOContext$ = -44					; size = 4
_lpOverlapped$ = -40					; size = 4
_lpPerSocketContext$ = -36				; size = 4
_ClientIndex$ = -32					; size = 4
_nRet$ = -28						; size = 4
_bSuccess$ = -24					; size = 4
_dwSendNumBytes$ = -20					; size = 4
_Flags$ = -16						; size = 4
_RecvBytes$ = -12					; size = 4
_dwIoSize$ = -8						; size = 4
_CompletionPort$ = -4					; size = 4
_CompletionPortID$ = 8					; size = 4
?ServerWorkerThread@@YGKPAX@Z PROC			; ServerWorkerThread, COMDAT

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 384  : 	HANDLE	CompletionPort = (HANDLE) CompletionPortID;

  00009	8b 45 08	 mov	 eax, DWORD PTR _CompletionPortID$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _CompletionPort$[ebp], eax

; 385  : 	DWORD	dwIoSize;
; 386  : 	DWORD	RecvBytes;
; 387  : 	DWORD	Flags;
; 388  : 	DWORD	dwSendNumBytes = 0;

  0000f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwSendNumBytes$[ebp], 0

; 389  : 	BOOL	bSuccess = FALSE; 

  00016	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bSuccess$[ebp], 0

; 390  : 	int		nRet;
; 391  : 	int     ClientIndex;
; 392  : 
; 393  : 	srand(time(NULL));

  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 _time
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _srand
  0002d	83 c4 04	 add	 esp, 4

; 394  : 
; 395  : 	LPPER_SOCKET_CONTEXT	lpPerSocketContext = NULL;

  00030	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _lpPerSocketContext$[ebp], 0

; 396  : 	LPOVERLAPPED			lpOverlapped = NULL; 

  00037	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _lpOverlapped$[ebp], 0

; 397  : 	LPPER_IO_CONTEXT		lpIOContext = NULL;

  0003e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _lpIOContext$[ebp], 0
$LN2@ServerWork:

; 398  : 	
; 399  : 
; 400  : 	while(TRUE)

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 6b 03 00
	00		 je	 $LN3@ServerWork

; 401  : 	{
; 402  : 		bSuccess = GetQueuedCompletionStatus(

  00052	6a ff		 push	 -1
  00054	8d 45 d8	 lea	 eax, DWORD PTR _lpOverlapped$[ebp]
  00057	50		 push	 eax
  00058	8d 4d e0	 lea	 ecx, DWORD PTR _ClientIndex$[ebp]
  0005b	51		 push	 ecx
  0005c	8d 55 f8	 lea	 edx, DWORD PTR _dwIoSize$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 fc	 mov	 eax, DWORD PTR _CompletionPort$[ebp]
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetQueuedCompletionStatus@20
  0006a	89 45 e8	 mov	 DWORD PTR _bSuccess$[ebp], eax

; 403  : 			CompletionPort,
; 404  : 			&dwIoSize,
; 405  : 			(LPDWORD)&ClientIndex,
; 406  : 			&lpOverlapped,
; 407  : 			INFINITE
; 408  : 		);
; 409  : 
; 410  : 		if( !bSuccess )

  0006d	83 7d e8 00	 cmp	 DWORD PTR _bSuccess$[ebp], 0
  00071	75 3f		 jne	 SHORT $LN4@ServerWork

; 411  : 		{
; 412  : 			if( lpOverlapped != NULL ) 

  00073	83 7d d8 00	 cmp	 DWORD PTR _lpOverlapped$[ebp], 0
  00077	74 39		 je	 SHORT $LN4@ServerWork

; 413  : 			{
; 414  : 				DWORD errorcode = GetLastError();

  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0007f	89 45 d0	 mov	 DWORD PTR _errorcode$1[ebp], eax

; 415  : 
; 416  : 				if( ERROR_NETNAME_DELETED != errorcode && 
; 417  : 					ERROR_CONNECTION_ABORTED != errorcode && 
; 418  : 					ERROR_OPERATION_ABORTED != errorcode &&

  00082	83 7d d0 40	 cmp	 DWORD PTR _errorcode$1[ebp], 64 ; 00000040H
  00086	74 2a		 je	 SHORT $LN4@ServerWork
  00088	81 7d d0 d4 04
	00 00		 cmp	 DWORD PTR _errorcode$1[ebp], 1236 ; 000004d4H
  0008f	74 21		 je	 SHORT $LN4@ServerWork
  00091	81 7d d0 e3 03
	00 00		 cmp	 DWORD PTR _errorcode$1[ebp], 995 ; 000003e3H
  00098	74 18		 je	 SHORT $LN4@ServerWork
  0009a	83 7d d0 79	 cmp	 DWORD PTR _errorcode$1[ebp], 121 ; 00000079H
  0009e	74 12		 je	 SHORT $LN4@ServerWork

; 419  : 					ERROR_SEM_TIMEOUT != errorcode)
; 420  : 				{
; 421  : 					//EnterCriticalSection(&criti);
; 422  : 					LogAdd( "Error Thread : GetQueueCompletionStatus( %d )", errorcode );

  000a0	8b 45 d0	 mov	 eax, DWORD PTR _errorcode$1[ebp]
  000a3	50		 push	 eax
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KIOKACIH@Error?5Thread?5?3?5GetQueueCompleti@
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000af	83 c4 08	 add	 esp, 8
$LN4@ServerWork:

; 423  : 					//LeaveCriticalSection(&criti);
; 424  : 				}
; 425  : 
; 426  : 				//if(ClientIndex >= ALLOC_USEROBJECTSTART && ClientIndex < MAX_OBJECT)
; 427  : 				//	CloseClient(ClientIndex);
; 428  : 
; 429  : 				//continue;
; 430  : 			}
; 431  : 		}
; 432  : 
; 433  : 		EnterCriticalSection(&criti);

  000b2	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 434  : 		lpPerSocketContext = gObj[ClientIndex].PerSocketContext;

  000bd	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ca	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  000ce	89 55 dc	 mov	 DWORD PTR _lpPerSocketContext$[ebp], edx

; 435  : 
; 436  : 		if(!bSuccess)

  000d1	83 7d e8 00	 cmp	 DWORD PTR _bSuccess$[ebp], 0
  000d5	75 33		 jne	 SHORT $LN7@ServerWork

; 437  : 		{
; 438  : 			LogAdd( "Connection Closed, bSuccess == FALSE (Index:%d)", lpPerSocketContext->nIndex);

  000d7	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  000da	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000dd	51		 push	 ecx
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@NINFHBLD@Connection?5Closed?0?5bSuccess?5?$DN?$DN?5@
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000e9	83 c4 08	 add	 esp, 8

; 439  : 			CloseClient(lpPerSocketContext, FALSE);

  000ec	6a 00		 push	 0
  000ee	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  000f7	83 c4 08	 add	 esp, 8

; 440  : 			LeaveCriticalSection(&criti);

  000fa	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 441  : 			continue;

  00105	e9 3b ff ff ff	 jmp	 $LN2@ServerWork
$LN7@ServerWork:

; 442  : 		}
; 443  : 		
; 444  : 		lpPerSocketContext->dwIOCount--;

  0010a	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  0010d	8b 88 68 00 02
	00		 mov	 ecx, DWORD PTR [eax+131176]
  00113	83 e9 01	 sub	 ecx, 1
  00116	8b 55 dc	 mov	 edx, DWORD PTR _lpPerSocketContext$[ebp]
  00119	89 8a 68 00 02
	00		 mov	 DWORD PTR [edx+131176], ecx

; 445  : 		if( dwIoSize == 0 )

  0011f	83 7d f8 00	 cmp	 DWORD PTR _dwIoSize$[ebp], 0
  00123	75 33		 jne	 SHORT $LN8@ServerWork

; 446  : 		{
; 447  : 			LogAdd( "Connection Closed, dwIoSize == 0 (Index:%d)", lpPerSocketContext->nIndex);

  00125	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	51		 push	 ecx
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PHCJMMBN@Connection?5Closed?0?5dwIoSize?5?$DN?$DN?5@
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00137	83 c4 08	 add	 esp, 8

; 448  : 			CloseClient(lpPerSocketContext, FALSE);

  0013a	6a 00		 push	 0
  0013c	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  00145	83 c4 08	 add	 esp, 8

; 449  : 			LeaveCriticalSection(&criti);

  00148	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 450  : 			continue;

  00153	e9 ed fe ff ff	 jmp	 $LN2@ServerWork
$LN8@ServerWork:

; 451  : 		}
; 452  : 
; 453  : 		lpIOContext = (LPPER_IO_CONTEXT)lpOverlapped;

  00158	8b 45 d8	 mov	 eax, DWORD PTR _lpOverlapped$[ebp]
  0015b	89 45 d4	 mov	 DWORD PTR _lpIOContext$[ebp], eax

; 454  : 
; 455  : 		if( lpIOContext == NULL )

  0015e	83 7d d4 00	 cmp	 DWORD PTR _lpIOContext$[ebp], 0
  00162	75 13		 jne	 SHORT $LN9@ServerWork

; 456  : 		{
; 457  : 			LogAdd("lpIoContext is NULL");

  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NKDBKMD@lpIoContext?5is?5NULL@
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0016f	83 c4 04	 add	 esp, 4

; 458  : 			continue;

  00172	e9 ce fe ff ff	 jmp	 $LN2@ServerWork
$LN9@ServerWork:

; 459  : 		}
; 460  : 
; 461  : 		if( lpIOContext->IOOperation == SEND_IO )

  00177	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  0017a	83 b8 28 00 01
	00 01		 cmp	 DWORD PTR [eax+65576], 1
  00181	75 61		 jne	 SHORT $LN10@ServerWork

; 462  : 		{
; 463  : 			lpIOContext->nSentBytes += dwIoSize;

  00183	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00186	8b 88 24 00 01
	00		 mov	 ecx, DWORD PTR [eax+65572]
  0018c	03 4d f8	 add	 ecx, DWORD PTR _dwIoSize$[ebp]
  0018f	8b 55 d4	 mov	 edx, DWORD PTR _lpIOContext$[ebp]
  00192	89 8a 24 00 01
	00		 mov	 DWORD PTR [edx+65572], ecx

; 464  : 
; 465  : 			if( lpIOContext->nSentBytes >= lpIOContext->nTotalBytes )

  00198	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  0019b	8b 4d d4	 mov	 ecx, DWORD PTR _lpIOContext$[ebp]
  0019e	8b 90 24 00 01
	00		 mov	 edx, DWORD PTR [eax+65572]
  001a4	3b 91 20 00 01
	00		 cmp	 edx, DWORD PTR [ecx+65568]
  001aa	7c 27		 jl	 SHORT $LN12@ServerWork

; 466  : 			{
; 467  : 				lpIOContext->nWaitIO = 0;

  001ac	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  001af	c7 80 2c 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65580], 0

; 468  : 				if( lpIOContext->nSecondOfs > 0 )

  001b9	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  001bc	83 b8 1c 00 01
	00 00		 cmp	 DWORD PTR [eax+65564], 0
  001c3	7e 0c		 jle	 SHORT $LN14@ServerWork

; 469  : 				{
; 470  : 					IoSendSecond(lpPerSocketContext);

  001c5	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ; IoSendSecond
  001ce	83 c4 04	 add	 esp, 4
$LN14@ServerWork:

; 471  : 				}
; 472  : 			}

  001d1	eb 0c		 jmp	 SHORT $LN13@ServerWork
$LN12@ServerWork:

; 473  : 			else
; 474  : 			{
; 475  : 				IoMoreSend(lpPerSocketContext);

  001d3	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 ?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ; IoMoreSend
  001dc	83 c4 04	 add	 esp, 4
$LN13@ServerWork:

; 476  : 			}
; 477  : 		}

  001df	e9 c9 01 00 00	 jmp	 $LN11@ServerWork
$LN10@ServerWork:

; 478  : 		else if( lpIOContext->IOOperation == RECV_IO )

  001e4	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  001e7	83 b8 28 00 01
	00 00		 cmp	 DWORD PTR [eax+65576], 0
  001ee	0f 85 b9 01 00
	00		 jne	 $LN11@ServerWork

; 479  : 		{
; 480  : 			RecvBytes = 0;

  001f4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _RecvBytes$[ebp], 0

; 481  : 
; 482  : 			lpIOContext->nSentBytes += dwIoSize;

  001fb	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  001fe	8b 88 24 00 01
	00		 mov	 ecx, DWORD PTR [eax+65572]
  00204	03 4d f8	 add	 ecx, DWORD PTR _dwIoSize$[ebp]
  00207	8b 55 d4	 mov	 edx, DWORD PTR _lpIOContext$[ebp]
  0020a	89 8a 24 00 01
	00		 mov	 DWORD PTR [edx+65572], ecx

; 483  : 			
; 484  : 			if( RecvDataParse(lpIOContext, lpPerSocketContext->nIndex) == FALSE )

  00210	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00213	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00216	51		 push	 ecx
  00217	8b 55 d4	 mov	 edx, DWORD PTR _lpIOContext$[ebp]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 ?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z ; RecvDataParse
  00220	83 c4 08	 add	 esp, 8
  00223	85 c0		 test	 eax, eax
  00225	75 3f		 jne	 SHORT $LN16@ServerWork

; 485  : 			{
; 486  : 				LogAdd("error-L1 : Socket Header error %d, %d", WSAGetLastError(), lpPerSocketContext->nIndex);

  00227	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  0022a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0022d	51		 push	 ecx
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00234	50		 push	 eax
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@MJPNHJDJ@error?9L1?5?3?5Socket?5Header?5error?5@
  0023a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00240	83 c4 0c	 add	 esp, 12			; 0000000cH

; 487  : 				CloseClient( lpPerSocketContext, FALSE);

  00243	6a 00		 push	 0
  00245	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  0024e	83 c4 08	 add	 esp, 8

; 488  : 				LeaveCriticalSection(&criti);

  00251	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 489  : 				continue;

  0025c	e9 e4 fd ff ff	 jmp	 $LN2@ServerWork

; 490  : 			}

  00261	e9 47 01 00 00	 jmp	 $LN11@ServerWork
$LN16@ServerWork:

; 491  : 			else
; 492  : 			{
; 493  : 				lpIOContext->nWaitIO = 0;

  00266	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00269	c7 80 2c 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65580], 0

; 494  : 				Flags = 0;

  00273	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Flags$[ebp], 0

; 495  : 				ZeroMemory(&(lpIOContext->Overlapped), sizeof(OVERLAPPED));

  0027a	6a 14		 push	 20			; 00000014H
  0027c	6a 00		 push	 0
  0027e	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 _memset
  00287	83 c4 0c	 add	 esp, 12			; 0000000cH

; 496  : 				
; 497  : 				lpIOContext->wsabuf.len		= MAX_BUFF_SIZE-lpIOContext->nSentBytes;

  0028a	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  0028d	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  00292	2b 88 24 00 01
	00		 sub	 ecx, DWORD PTR [eax+65572]
  00298	8b 55 d4	 mov	 edx, DWORD PTR _lpIOContext$[ebp]
  0029b	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 498  : 				lpIOContext->wsabuf.buf		= lpIOContext->Buffer+lpIOContext->nSentBytes;

  0029e	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  002a1	8b 88 24 00 01
	00		 mov	 ecx, DWORD PTR [eax+65572]
  002a7	8b 55 d4	 mov	 edx, DWORD PTR _lpIOContext$[ebp]
  002aa	8d 44 0a 1c	 lea	 eax, DWORD PTR [edx+ecx+28]
  002ae	8b 4d d4	 mov	 ecx, DWORD PTR _lpIOContext$[ebp]
  002b1	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 499  : 				lpIOContext->IOOperation	= RECV_IO;

  002b4	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  002b7	c7 80 28 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65576], 0

; 500  : 				
; 501  : 				nRet = WSARecv(lpPerSocketContext->m_socket, &(lpIOContext->wsabuf), 1, &RecvBytes, &Flags,

  002c1	6a 00		 push	 0
  002c3	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  002c6	50		 push	 eax
  002c7	8d 4d f0	 lea	 ecx, DWORD PTR _Flags$[ebp]
  002ca	51		 push	 ecx
  002cb	8d 55 f4	 lea	 edx, DWORD PTR _RecvBytes$[ebp]
  002ce	52		 push	 edx
  002cf	6a 01		 push	 1
  002d1	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  002d4	83 c0 14	 add	 eax, 20			; 00000014H
  002d7	50		 push	 eax
  002d8	8b 4d dc	 mov	 ecx, DWORD PTR _lpPerSocketContext$[ebp]
  002db	8b 11		 mov	 edx, DWORD PTR [ecx]
  002dd	52		 push	 edx
  002de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28
  002e4	89 45 e4	 mov	 DWORD PTR _nRet$[ebp], eax

; 502  : 					&(lpIOContext->Overlapped), NULL);
; 503  : 				if( nRet == SOCKET_ERROR && (WSAGetLastError() != ERROR_IO_PENDING) )

  002e7	83 7d e4 ff	 cmp	 DWORD PTR _nRet$[ebp], -1
  002eb	0f 85 9a 00 00
	00		 jne	 $LN18@ServerWork
  002f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  002f7	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  002fc	0f 84 89 00 00
	00		 je	 $LN18@ServerWork

; 504  : 				{
; 505  : 					//if ((OfflineShop[i].IsOffTrade == 1) && (ExUser[i].OffAttack != 1) && (Exafk[i].OffAfk != 1))
; 506  : 				if(gObj[lpPerSocketContext->nIndex].OffExp == FALSE && gObj[lpPerSocketContext->nIndex].OffAfk == FALSE && gObj[lpPerSocketContext->nIndex].Offtrade == FALSE)

  00302	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00305	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0030c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00312	0f b6 84 0a 8c
	1a 00 00	 movzx	 eax, BYTE PTR [edx+ecx+6796]
  0031a	85 c0		 test	 eax, eax
  0031c	75 5b		 jne	 SHORT $LN20@ServerWork
  0031e	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00321	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00328	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0032e	0f b6 84 0a 85
	1a 00 00	 movzx	 eax, BYTE PTR [edx+ecx+6789]
  00336	85 c0		 test	 eax, eax
  00338	75 3f		 jne	 SHORT $LN20@ServerWork
  0033a	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  0033d	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00344	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0034a	0f b6 84 0a 86
	1a 00 00	 movzx	 eax, BYTE PTR [edx+ecx+6790]
  00352	85 c0		 test	 eax, eax
  00354	75 23		 jne	 SHORT $LN20@ServerWork

; 507  : 				{
; 508  : 					LogAdd("WSARecv() failed with error %d", WSAGetLastError());

  00356	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0035c	50		 push	 eax
  0035d	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CPHIIPEF@WSARecv?$CI?$CJ?5failed?5with?5error?5?$CFd@
  00362	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00368	83 c4 08	 add	 esp, 8

; 509  : 					//lpIOContext->nWaitIO = 2;
; 510  : 					CloseClient(lpPerSocketContext,FALSE);

  0036b	6a 00		 push	 0
  0036d	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  00376	83 c4 08	 add	 esp, 8
$LN20@ServerWork:

; 511  : 				}
; 512  : 
; 513  : 					//LogAdd("WSARecv() failed with error %d", WSAGetLastError());
; 514  : 					//lpIOContext->nWaitIO = 2;
; 515  : 					//CloseClient( lpPerSocketContext, FALSE);
; 516  : 					LeaveCriticalSection(&criti);

  00379	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0037e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 517  : 					continue;

  00384	e9 bc fc ff ff	 jmp	 $LN2@ServerWork

; 518  : 				}

  00389	eb 22		 jmp	 SHORT $LN11@ServerWork
$LN18@ServerWork:

; 519  : 				else
; 520  : 				{	
; 521  : 					lpPerSocketContext->dwIOCount++;

  0038b	8b 45 dc	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  0038e	8b 88 68 00 02
	00		 mov	 ecx, DWORD PTR [eax+131176]
  00394	83 c1 01	 add	 ecx, 1
  00397	8b 55 dc	 mov	 edx, DWORD PTR _lpPerSocketContext$[ebp]
  0039a	89 8a 68 00 02
	00		 mov	 DWORD PTR [edx+131176], ecx

; 522  : 					lpIOContext->nWaitIO = 1;

  003a0	8b 45 d4	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  003a3	c7 80 2c 00 01
	00 01 00 00 00	 mov	 DWORD PTR [eax+65580], 1
$LN11@ServerWork:

; 523  : 				}
; 524  : 			}
; 525  : 		}
; 526  : 		LeaveCriticalSection(&criti);

  003ad	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  003b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 527  : 	}

  003b8	e9 88 fc ff ff	 jmp	 $LN2@ServerWork
$LN3@ServerWork:

; 528  : 	return TRUE;

  003bd	b8 01 00 00 00	 mov	 eax, 1

; 529  : }

  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	5b		 pop	 ebx
  003c5	8b e5		 mov	 esp, ebp
  003c7	5d		 pop	 ebp
  003c8	c2 04 00	 ret	 4
?ServerWorkerThread@@YGKPAX@Z ENDP			; ServerWorkerThread
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?IocpServerWorker@@YGKPAX@Z
_TEXT	SEGMENT
_i$2 = -160						; size = 4
_pIpBlock$3 = -156					; size = 32
_ThreadHandle$4 = -124					; size = 4
_dwCPU$5 = -120						; size = 4
_Flags$ = -116						; size = 4
_RecvBytes$ = -112					; size = 4
_lpPerSocketContext$ = -108				; size = 4
_cAddrlen$ = -104					; size = 4
_cInAddr$ = -100					; size = 4
_cAddr$ = -96						; size = 16
_ClientIndex$ = -80					; size = 4
_nRet$ = -76						; size = 4
_Accept$ = -72						; size = 4
_ThreadID$ = -68					; size = 4
_SystemInfo$ = -64					; size = 36
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_p$ = 8							; size = 4
?IocpServerWorker@@YGKPAX@Z PROC			; IocpServerWorker, COMDAT

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?IocpServerWorker@@YGKPAX@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 c4 30 ff ff
	ff		 add	 esp, -208		; ffffff30H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 210  : 	SYSTEM_INFO SystemInfo;
; 211  : 	DWORD		ThreadID;
; 212  : 	SOCKET		Accept;
; 213  : 	int			nRet;
; 214  : 	int			ClientIndex;
; 215  : 	SOCKADDR_IN cAddr;
; 216  : 	IN_ADDR		cInAddr;
; 217  : 	int			cAddrlen = sizeof( cAddr );

  00036	c7 45 98 10 00
	00 00		 mov	 DWORD PTR _cAddrlen$[ebp], 16 ; 00000010H

; 218  : 
; 219  : 	LPPER_SOCKET_CONTEXT lpPerSocketContext = NULL; 

  0003d	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _lpPerSocketContext$[ebp], 0

; 220  : 
; 221  : 	DWORD RecvBytes;
; 222  : 	DWORD Flags=0;

  00044	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _Flags$[ebp], 0

; 223  : 		
; 224  : 	InitializeCriticalSection(&criti);

  0004b	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 225  : 
; 226  : 	GetSystemInfo(&SystemInfo);

  00056	8d 45 c0	 lea	 eax, DWORD PTR _SystemInfo$[ebp]
  00059	50		 push	 eax
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 227  : 	g_dwThreadCount = SystemInfo.dwNumberOfProcessors * 2;

  00060	8b 45 d4	 mov	 eax, DWORD PTR _SystemInfo$[ebp+20]
  00063	d1 e0		 shl	 eax, 1
  00065	a3 00 00 00 00	 mov	 DWORD PTR ?g_dwThreadCount@@3KA, eax ; g_dwThreadCount

; 228  : 
; 229  : 	if ( 2 * SystemInfo.dwNumberOfProcessors > MAX_WORKER_THREAD )

  0006a	8b 45 d4	 mov	 eax, DWORD PTR _SystemInfo$[ebp+20]
  0006d	d1 e0		 shl	 eax, 1
  0006f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00072	76 18		 jbe	 SHORT $LN10@IocpServer

; 230  : 	{
; 231  : 		g_dwThreadCount = MAX_WORKER_THREAD;

  00074	c7 05 00 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?g_dwThreadCount@@3KA, 16 ; g_dwThreadCount, 00000010H

; 232  : 		LogAdd(" **** Worker Thread Max Count Fix 16ea ****");

  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@FGEFAMMO@?5?$CK?$CK?$CK?$CK?5Worker?5Thread?5Max?5Count?5F@
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00089	83 c4 04	 add	 esp, 4
$LN10@IocpServer:

; 233  : 	}
; 234  : 	
; 235  :     __try  

  0008c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 236  :     { 
; 237  : 		g_CompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

  00093	6a 00		 push	 0
  00095	6a 00		 push	 0
  00097	6a 00		 push	 0
  00099	6a ff		 push	 -1
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16
  000a1	a3 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, eax ; g_CompletionPort

; 238  : 		if ( g_CompletionPort == NULL)

  000a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
  000ad	75 1a		 jne	 SHORT $LN12@IocpServer

; 239  : 		{
; 240  : 			LogAdd("CreateIoCompletionPort failed with error: %d", GetLastError());

  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000b5	50		 push	 eax
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@DNNAFBKA@CreateIoCompletionPort?5failed?5w@
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c1	83 c4 08	 add	 esp, 8

; 241  : 			__leave;

  000c4	e9 54 06 00 00	 jmp	 $LN11@IocpServer
$LN12@IocpServer:

; 242  : 		}
; 243  : 		
; 244  : 		for(DWORD dwCPU = 0; dwCPU < g_dwThreadCount; dwCPU++)

  000c9	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _dwCPU$5[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@IocpServer
$LN2@IocpServer:
  000d2	8b 45 88	 mov	 eax, DWORD PTR _dwCPU$5[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 88	 mov	 DWORD PTR _dwCPU$5[ebp], eax
$LN4@IocpServer:
  000db	8b 45 88	 mov	 eax, DWORD PTR _dwCPU$5[ebp]
  000de	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  000e4	73 58		 jae	 SHORT $LN3@IocpServer

; 245  : 		{
; 246  : 			HANDLE ThreadHandle;
; 247  : 			// Create a server worker thread and pass the completion port to the thread.
; 248  : 			
; 249  : 			ThreadHandle = CreateThread(NULL, 0, ServerWorkerThread, g_CompletionPort, 0, &ThreadID);

  000e6	8d 45 bc	 lea	 eax, DWORD PTR _ThreadID$[ebp]
  000e9	50		 push	 eax
  000ea	6a 00		 push	 0
  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  000f2	51		 push	 ecx
  000f3	68 00 00 00 00	 push	 OFFSET ?ServerWorkerThread@@YGKPAX@Z ; ServerWorkerThread
  000f8	6a 00		 push	 0
  000fa	6a 00		 push	 0
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00102	89 45 84	 mov	 DWORD PTR _ThreadHandle$4[ebp], eax

; 250  : 			if ( ThreadHandle == NULL)

  00105	83 7d 84 00	 cmp	 DWORD PTR _ThreadHandle$4[ebp], 0
  00109	75 1a		 jne	 SHORT $LN13@IocpServer

; 251  : 			{
; 252  : 				LogAdd("CreateThread() failed with error %d", GetLastError());

  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00111	50		 push	 eax
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5erro@
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0011d	83 c4 08	 add	 esp, 8

; 253  : 				__leave;

  00120	e9 f8 05 00 00	 jmp	 $LN11@IocpServer
$LN13@IocpServer:

; 254  : 			}
; 255  : 			g_ThreadHandles[dwCPU] = ThreadHandle;

  00125	8b 45 88	 mov	 eax, DWORD PTR _dwCPU$5[ebp]
  00128	8b 4d 84	 mov	 ecx, DWORD PTR _ThreadHandle$4[ebp]
  0012b	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?g_ThreadHandles@@3PAPAXA[eax*4], ecx

; 256  : 			CloseHandle(ThreadHandle);

  00132	8b 45 84	 mov	 eax, DWORD PTR _ThreadHandle$4[ebp]
  00135	50		 push	 eax
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 257  : 		}

  0013c	eb 94		 jmp	 SHORT $LN2@IocpServer
$LN3@IocpServer:

; 258  : 
; 259  : 		if (!CreateListenSocket() )

  0013e	e8 00 00 00 00	 call	 ?CreateListenSocket@@YAHXZ ; CreateListenSocket
  00143	85 c0		 test	 eax, eax
  00145	75 05		 jne	 SHORT $LN5@IocpServer

; 260  : 			__leave;

  00147	e9 d1 05 00 00	 jmp	 $LN11@IocpServer
$LN5@IocpServer:

; 261  : 
; 262  : 		while(TRUE)		

  0014c	b8 01 00 00 00	 mov	 eax, 1
  00151	85 c0		 test	 eax, eax
  00153	0f 84 c4 05 00
	00		 je	 $LN11@IocpServer

; 263  : 		{
; 264  : 			Accept = WSAAccept(g_Listen, (LPSOCKADDR)&cAddr, &cAddrlen, NULL, 0);

  00159	6a 00		 push	 0
  0015b	6a 00		 push	 0
  0015d	8d 45 98	 lea	 eax, DWORD PTR _cAddrlen$[ebp]
  00160	50		 push	 eax
  00161	8d 4d a0	 lea	 ecx, DWORD PTR _cAddr$[ebp]
  00164	51		 push	 ecx
  00165	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?g_Listen@@3IA ; g_Listen
  0016b	52		 push	 edx
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAAccept@20
  00172	89 45 b8	 mov	 DWORD PTR _Accept$[ebp], eax

; 265  : 			if (Accept==SOCKET_ERROR)

  00175	83 7d b8 ff	 cmp	 DWORD PTR _Accept$[ebp], -1
  00179	75 2d		 jne	 SHORT $LN15@IocpServer

; 266  : 			{
; 267  : 				EnterCriticalSection(&criti);

  0017b	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 268  : 				LogAdd("WSAAccept() failed with error %d", WSAGetLastError());

  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0018c	50		 push	 eax
  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@CBCMIDPM@WSAAccept?$CI?$CJ?5failed?5with?5error?5?$CF@
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00198	83 c4 08	 add	 esp, 8

; 269  : 				LeaveCriticalSection(&criti);

  0019b	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 270  : 				continue;

  001a6	eb a4		 jmp	 SHORT $LN5@IocpServer
$LN15@IocpServer:

; 271  : 			}
; 272  : 			EnterCriticalSection(&criti);

  001a8	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 273  : 
; 274  : 			memcpy( &cInAddr, &cAddr.sin_addr.s_addr, 4 );

  001b3	6a 04		 push	 4
  001b5	8d 45 a4	 lea	 eax, DWORD PTR _cAddr$[ebp+4]
  001b8	50		 push	 eax
  001b9	8d 4d 9c	 lea	 ecx, DWORD PTR _cInAddr$[ebp]
  001bc	51		 push	 ecx
  001bd	e8 00 00 00 00	 call	 _memcpy
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : 
; 276  : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 277  : 			
; 278  : 			IP_BLOCK pIpBlock;
; 279  : 			pIpBlock.dwBlockTime = GetTickCount();

  001c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001cb	89 45 80	 mov	 DWORD PTR _pIpBlock$3[ebp+28], eax

; 280  : 			memcpy(pIpBlock.Ip_addr, inet_ntoa(cInAddr), 15);

  001ce	6a 0f		 push	 15			; 0000000fH
  001d0	8b 45 9c	 mov	 eax, DWORD PTR _cInAddr$[ebp]
  001d3	50		 push	 eax
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  001da	50		 push	 eax
  001db	8d 8d 6f ff ff
	ff		 lea	 ecx, DWORD PTR _pIpBlock$3[ebp+11]
  001e1	51		 push	 ecx
  001e2	e8 00 00 00 00	 call	 _memcpy
  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 			
; 282  : 			if( ChkBlockIp(&pIpBlock) == true )

  001ea	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _pIpBlock$3[ebp]
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ?ChkBlockIp@@YA_NPAUIP_BLOCK@@@Z ; ChkBlockIp
  001f6	83 c4 04	 add	 esp, 4
  001f9	0f b6 c8	 movzx	 ecx, al
  001fc	83 f9 01	 cmp	 ecx, 1
  001ff	75 1a		 jne	 SHORT $LN16@IocpServer

; 283  : 			{
; 284  : 				//LogAddTD_TempLog(", [TempLog - BlockIP], IP [%s], Fail", gObj[ClientIndex].Ip_addr);
; 285  : 				closesocket(Accept);

  00201	8b 45 b8	 mov	 eax, DWORD PTR _Accept$[ebp]
  00204	50		 push	 eax
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 286  : 				LeaveCriticalSection(&criti);

  0020b	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 287  : 				continue;

  00216	e9 31 ff ff ff	 jmp	 $LN5@IocpServer
$LN16@IocpServer:

; 288  : 			}
; 289  : 			
; 290  : #endif	//MODIFY_CONNNECT_HACK_ATTACK_20090409
; 291  : 
; 292  : 			ClientIndex = gObjAddSearch(Accept, inet_ntoa(cInAddr));

  0021b	8b 45 9c	 mov	 eax, DWORD PTR _cInAddr$[ebp]
  0021e	50		 push	 eax
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  00225	50		 push	 eax
  00226	8b 4d b8	 mov	 ecx, DWORD PTR _Accept$[ebp]
  00229	51		 push	 ecx
  0022a	e8 00 00 00 00	 call	 ?gObjAddSearch@@YAFIPAD@Z ; gObjAddSearch
  0022f	83 c4 08	 add	 esp, 8
  00232	0f bf d0	 movsx	 edx, ax
  00235	89 55 b0	 mov	 DWORD PTR _ClientIndex$[ebp], edx

; 293  : 			if( ClientIndex == -1 ) 

  00238	83 7d b0 ff	 cmp	 DWORD PTR _ClientIndex$[ebp], -1
  0023c	75 28		 jne	 SHORT $LN17@IocpServer

; 294  : 			{
; 295  : 				LogAddL("error-L2 : ClientIndex = -1");

  0023e	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PFLJNKN@error?9L2?5?3?5ClientIndex?5?$DN?5?91@
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  00249	83 c4 04	 add	 esp, 4

; 296  : 				closesocket(Accept);

  0024c	8b 45 b8	 mov	 eax, DWORD PTR _Accept$[ebp]
  0024f	50		 push	 eax
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 297  : 				LeaveCriticalSection(&criti);

  00256	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 298  : 				continue;

  00261	e9 e6 fe ff ff	 jmp	 $LN5@IocpServer
$LN17@IocpServer:

; 299  : 			}
; 300  : 			if( UpdateCompletionPort(Accept, ClientIndex, TRUE) == FALSE )

  00266	6a 01		 push	 1
  00268	8b 45 b0	 mov	 eax, DWORD PTR _ClientIndex$[ebp]
  0026b	50		 push	 eax
  0026c	8b 4d b8	 mov	 ecx, DWORD PTR _Accept$[ebp]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 ?UpdateCompletionPort@@YAHIHH@Z ; UpdateCompletionPort
  00275	83 c4 0c	 add	 esp, 12			; 0000000cH
  00278	85 c0		 test	 eax, eax
  0027a	75 37		 jne	 SHORT $LN18@IocpServer

; 301  : 			{ 
; 302  : 				LogAddL("error-L1 : %d %d CreateIoCompletionPort failed with error %d", Accept, ClientIndex, GetLastError());

  0027c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00282	50		 push	 eax
  00283	8b 45 b0	 mov	 eax, DWORD PTR _ClientIndex$[ebp]
  00286	50		 push	 eax
  00287	8b 4d b8	 mov	 ecx, DWORD PTR _Accept$[ebp]
  0028a	51		 push	 ecx
  0028b	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@KCGEKGOM@error?9L1?5?3?5?$CFd?5?$CFd?5CreateIoComple@
  00290	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  00296	83 c4 10	 add	 esp, 16			; 00000010H

; 303  : 				closesocket(Accept);

  00299	8b 45 b8	 mov	 eax, DWORD PTR _Accept$[ebp]
  0029c	50		 push	 eax
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 304  : 				LeaveCriticalSection(&criti);

  002a3	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  002a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 305  : 				continue;

  002ae	e9 99 fe ff ff	 jmp	 $LN5@IocpServer
$LN18@IocpServer:

; 306  : 			}
; 307  : 			if( gObjAdd(Accept, inet_ntoa(cInAddr), ClientIndex) == -1 )

  002b3	8b 45 b0	 mov	 eax, DWORD PTR _ClientIndex$[ebp]
  002b6	50		 push	 eax
  002b7	8b 4d 9c	 mov	 ecx, DWORD PTR _cInAddr$[ebp]
  002ba	51		 push	 ecx
  002bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_ntoa@4
  002c1	50		 push	 eax
  002c2	8b 55 b8	 mov	 edx, DWORD PTR _Accept$[ebp]
  002c5	52		 push	 edx
  002c6	e8 00 00 00 00	 call	 ?gObjAdd@@YAFIPADH@Z	; gObjAdd
  002cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ce	98		 cwde
  002cf	83 f8 ff	 cmp	 eax, -1
  002d2	75 37		 jne	 SHORT $LN19@IocpServer

; 308  : 			{
; 309  : 				LogAddL("error-L1 : %d %d gObjAdd() failed with error %d", Accept, ClientIndex, GetLastError());

  002d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002da	50		 push	 eax
  002db	8b 45 b0	 mov	 eax, DWORD PTR _ClientIndex$[ebp]
  002de	50		 push	 eax
  002df	8b 4d b8	 mov	 ecx, DWORD PTR _Accept$[ebp]
  002e2	51		 push	 ecx
  002e3	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@CNIBOKAF@error?9L1?5?3?5?$CFd?5?$CFd?5gObjAdd?$CI?$CJ?5fail@
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  002ee	83 c4 10	 add	 esp, 16			; 00000010H

; 310  : 				LeaveCriticalSection(&criti);

  002f1	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 311  : 				closesocket(Accept);

  002fc	8b 45 b8	 mov	 eax, DWORD PTR _Accept$[ebp]
  002ff	50		 push	 eax
  00300	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 312  : 				continue;

  00306	e9 41 fe ff ff	 jmp	 $LN5@IocpServer
$LN19@IocpServer:

; 313  : 			}
; 314  : 			
; 315  : 			memset(&gObj[ClientIndex].PerSocketContext->IOContext[0].Overlapped, 0, sizeof(OVERLAPPED));

  0030b	6a 14		 push	 20			; 00000014H
  0030d	6a 00		 push	 0
  0030f	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00316	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0031c	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00320	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00325	6b c8 00	 imul	 ecx, eax, 0
  00328	8d 54 0a 08	 lea	 edx, DWORD PTR [edx+ecx+8]
  0032c	52		 push	 edx
  0032d	e8 00 00 00 00	 call	 _memset
  00332	83 c4 0c	 add	 esp, 12			; 0000000cH

; 316  : 			memset(&gObj[ClientIndex].PerSocketContext->IOContext[1].Overlapped, 0, sizeof(OVERLAPPED));

  00335	6a 14		 push	 20			; 00000014H
  00337	6a 00		 push	 0
  00339	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00340	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00346	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  0034a	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  0034f	c1 e0 00	 shl	 eax, 0
  00352	8d 4c 02 08	 lea	 ecx, DWORD PTR [edx+eax+8]
  00356	51		 push	 ecx
  00357	e8 00 00 00 00	 call	 _memset
  0035c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 317  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf.buf = gObj[ClientIndex].PerSocketContext->IOContext[0].Buffer;

  0035f	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00366	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0036c	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00370	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00375	6b c8 00	 imul	 ecx, eax, 0
  00378	8d 54 0a 24	 lea	 edx, DWORD PTR [edx+ecx+36]
  0037c	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00383	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00389	8b 44 01 10	 mov	 eax, DWORD PTR [ecx+eax+16]
  0038d	b9 30 00 01 00	 mov	 ecx, 65584		; 00010030H
  00392	6b c9 00	 imul	 ecx, ecx, 0
  00395	89 54 08 20	 mov	 DWORD PTR [eax+ecx+32], edx

; 318  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf.len = MAX_BUFF_SIZE;

  00399	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  003a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a6	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  003aa	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  003af	6b c8 00	 imul	 ecx, eax, 0
  003b2	c7 44 0a 1c 00
	40 00 00	 mov	 DWORD PTR [edx+ecx+28], 16384 ; 00004000H

; 319  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nTotalBytes = 0;

  003ba	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  003c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003c7	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  003cb	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  003d0	6b c8 00	 imul	 ecx, eax, 0
  003d3	c7 84 0a 28 00
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+65576], 0

; 320  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nSentBytes = 0;

  003de	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  003e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003eb	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  003ef	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  003f4	6b c8 00	 imul	 ecx, eax, 0
  003f7	c7 84 0a 2c 00
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+65580], 0

; 321  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO    = 0;

  00402	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00409	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0040f	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00413	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00418	6b c8 00	 imul	 ecx, eax, 0
  0041b	c7 84 0a 34 00
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+65588], 0

; 322  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].nSecondOfs = 0;

  00426	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  0042d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00433	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00437	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  0043c	6b c8 00	 imul	 ecx, eax, 0
  0043f	c7 84 0a 24 00
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+65572], 0

; 323  : 			gObj[ClientIndex].PerSocketContext->IOContext[0].IOOperation = RECV_IO;

  0044a	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00451	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00457	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  0045b	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00460	6b c8 00	 imul	 ecx, eax, 0
  00463	c7 84 0a 30 00
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+65584], 0

; 324  : 			
; 325  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].wsabuf.buf = gObj[ClientIndex].PerSocketContext->IOContext[0].Buffer;

  0046e	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00475	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0047b	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  0047f	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00484	6b c8 00	 imul	 ecx, eax, 0
  00487	8d 54 0a 24	 lea	 edx, DWORD PTR [edx+ecx+36]
  0048b	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00492	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00498	8b 44 01 10	 mov	 eax, DWORD PTR [ecx+eax+16]
  0049c	b9 30 00 01 00	 mov	 ecx, 65584		; 00010030H
  004a1	c1 e1 00	 shl	 ecx, 0
  004a4	89 54 08 20	 mov	 DWORD PTR [eax+ecx+32], edx

; 326  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].wsabuf.len = MAX_BUFF_SIZE;

  004a8	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  004af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004b5	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  004b9	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  004be	c1 e0 00	 shl	 eax, 0
  004c1	c7 44 02 1c 00
	40 00 00	 mov	 DWORD PTR [edx+eax+28], 16384 ; 00004000H

; 327  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nTotalBytes= 0;

  004c9	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  004d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004d6	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  004da	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  004df	c1 e0 00	 shl	 eax, 0
  004e2	c7 84 02 28 00
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+eax+65576], 0

; 328  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nSentBytes = 0;

  004ed	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  004f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004fa	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  004fe	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00503	c1 e0 00	 shl	 eax, 0
  00506	c7 84 02 2c 00
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+eax+65580], 0

; 329  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nWaitIO    = 0;

  00511	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00518	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0051e	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00522	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00527	c1 e0 00	 shl	 eax, 0
  0052a	c7 84 02 34 00
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+eax+65588], 0

; 330  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].nSecondOfs = 0;

  00535	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  0053c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00542	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00546	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  0054b	c1 e0 00	 shl	 eax, 0
  0054e	c7 84 02 24 00
	01 00 00 00 00
	00		 mov	 DWORD PTR [edx+eax+65572], 0

; 331  : 			gObj[ClientIndex].PerSocketContext->IOContext[1].IOOperation = SEND_IO;

  00559	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00560	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00566	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  0056a	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  0056f	c1 e0 00	 shl	 eax, 0
  00572	c7 84 02 30 00
	01 00 01 00 00
	00		 mov	 DWORD PTR [edx+eax+65584], 1

; 332  : 			gObj[ClientIndex].PerSocketContext->m_socket = Accept;

  0057d	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00584	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0058a	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  0058e	8b 45 b8	 mov	 eax, DWORD PTR _Accept$[ebp]
  00591	89 02		 mov	 DWORD PTR [edx], eax

; 333  : 			gObj[ClientIndex].PerSocketContext->nIndex   = ClientIndex;

  00593	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  0059a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a0	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  005a4	8b 45 b0	 mov	 eax, DWORD PTR _ClientIndex$[ebp]
  005a7	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 334  : 
; 335  : 			nRet = WSARecv(Accept, &(gObj[ClientIndex].PerSocketContext->IOContext[0].wsabuf), 1, &RecvBytes, &Flags,

  005aa	6a 00		 push	 0
  005ac	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  005b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005b9	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  005bd	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  005c2	6b c8 00	 imul	 ecx, eax, 0
  005c5	8d 54 0a 08	 lea	 edx, DWORD PTR [edx+ecx+8]
  005c9	52		 push	 edx
  005ca	8d 45 8c	 lea	 eax, DWORD PTR _Flags$[ebp]
  005cd	50		 push	 eax
  005ce	8d 4d 90	 lea	 ecx, DWORD PTR _RecvBytes$[ebp]
  005d1	51		 push	 ecx
  005d2	6a 01		 push	 1
  005d4	69 55 b0 a0 1b
	00 00		 imul	 edx, DWORD PTR _ClientIndex$[ebp], 7072
  005db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005e0	8b 4c 10 10	 mov	 ecx, DWORD PTR [eax+edx+16]
  005e4	ba 30 00 01 00	 mov	 edx, 65584		; 00010030H
  005e9	6b c2 00	 imul	 eax, edx, 0
  005ec	8d 4c 01 1c	 lea	 ecx, DWORD PTR [ecx+eax+28]
  005f0	51		 push	 ecx
  005f1	8b 55 b8	 mov	 edx, DWORD PTR _Accept$[ebp]
  005f4	52		 push	 edx
  005f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28
  005fb	89 45 b4	 mov	 DWORD PTR _nRet$[ebp], eax

; 336  : 				&(gObj[ClientIndex].PerSocketContext->IOContext[0].Overlapped), NULL);
; 337  : 			
; 338  : 			if( nRet == SOCKET_ERROR && WSAGetLastError() != ERROR_IO_PENDING )

  005fe	83 7d b4 ff	 cmp	 DWORD PTR _nRet$[ebp], -1
  00602	75 74		 jne	 SHORT $LN20@IocpServer
  00604	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0060a	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  0060f	74 67		 je	 SHORT $LN20@IocpServer

; 339  : 			{
; 340  : 				LogAddL("error-L1 : WSARecv() failed with error %d", WSAGetLastError());

  00611	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00617	50		 push	 eax
  00618	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FNPFENCA@error?9L1?5?3?5WSARecv?$CI?$CJ?5failed?5wit@
  0061d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  00623	83 c4 08	 add	 esp, 8

; 341  : 				gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO = 4;

  00626	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  0062d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00633	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00637	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  0063c	6b c8 00	 imul	 ecx, eax, 0
  0063f	c7 84 0a 34 00
	01 00 04 00 00
	00		 mov	 DWORD PTR [edx+ecx+65588], 4

; 342  : 				CloseClient(gObj[ClientIndex].PerSocketContext, FALSE);

  0064a	6a 00		 push	 0
  0064c	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00653	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00659	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  0065d	52		 push	 edx
  0065e	e8 00 00 00 00	 call	 ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ; CloseClient
  00663	83 c4 08	 add	 esp, 8

; 343  : 				LeaveCriticalSection(&criti);

  00666	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0066b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 344  : 				continue;

  00671	e9 d6 fa ff ff	 jmp	 $LN5@IocpServer

; 345  : 			}

  00676	eb 55		 jmp	 SHORT $LN21@IocpServer
$LN20@IocpServer:

; 346  : 			else
; 347  : 			{
; 348  : 				gObj[ClientIndex].PerSocketContext->IOContext[0].nWaitIO = 1;

  00678	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  0067f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00685	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00689	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  0068e	6b c8 00	 imul	 ecx, eax, 0
  00691	c7 84 0a 34 00
	01 00 01 00 00
	00		 mov	 DWORD PTR [edx+ecx+65588], 1

; 349  : 				gObj[ClientIndex].PerSocketContext->dwIOCount++;

  0069c	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  006a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006a9	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  006ad	8b 82 68 00 02
	00		 mov	 eax, DWORD PTR [edx+131176]
  006b3	83 c0 01	 add	 eax, 1
  006b6	69 4d b0 a0 1b
	00 00		 imul	 ecx, DWORD PTR _ClientIndex$[ebp], 7072
  006bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006c3	8b 4c 0a 10	 mov	 ecx, DWORD PTR [edx+ecx+16]
  006c7	89 81 68 00 02
	00		 mov	 DWORD PTR [ecx+131176], eax
$LN21@IocpServer:

; 350  : 			}
; 351  : 			LeaveCriticalSection(&criti);

  006cd	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  006d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 352  : 			SCPJoinResultSend( ClientIndex, 0x01);

  006d8	6a 01		 push	 1
  006da	8b 45 b0	 mov	 eax, DWORD PTR _ClientIndex$[ebp]
  006dd	50		 push	 eax
  006de	e8 00 00 00 00	 call	 ?SCPJoinResultSend@@YAXHE@Z ; SCPJoinResultSend
  006e3	83 c4 08	 add	 esp, 8

; 353  : 
; 354  : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 355  : 			LogAddTD_TempLog(", [Connect], Account [%s], IP [%s], Success",gObj[ClientIndex].Name, gObj[ClientIndex].Ip_addr);

  006e6	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  006ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006f3	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  006f7	52		 push	 edx
  006f8	69 45 b0 a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  006ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00705	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00709	52		 push	 edx
  0070a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@COJCIKFD@?0?5?$FLConnect?$FN?0?5Account?5?$FL?$CFs?$FN?0?5IP?5?$FL@
  0070f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  00715	83 c4 0c	 add	 esp, 12			; 0000000cH

; 356  : #endif
; 357  : 
; 358  : 		}	// while

  00718	e9 2f fa ff ff	 jmp	 $LN5@IocpServer
$LN11@IocpServer:

; 359  : 	}	// __try

  0071d	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00724	e8 05 00 00 00	 call	 $LN29@IocpServer
  00729	e9 85 00 00 00	 jmp	 $LN30@IocpServer
$LN27@IocpServer:
$LN32@IocpServer:
$LN29@IocpServer:

; 360  : 	__finally  
; 361  : 	{
; 362  : 		if( g_CompletionPort )

  0072e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
  00735	74 3d		 je	 SHORT $LN22@IocpServer

; 363  : 		{
; 364  : 			for (DWORD i = 0; i < g_dwThreadCount; i++) 

  00737	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$2[ebp], 0
  00741	eb 0f		 jmp	 SHORT $LN9@IocpServer
$LN7@IocpServer:
  00743	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  00749	83 c0 01	 add	 eax, 1
  0074c	89 85 60 ff ff
	ff		 mov	 DWORD PTR _i$2[ebp], eax
$LN9@IocpServer:
  00752	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  00758	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  0075e	73 14		 jae	 SHORT $LN22@IocpServer

; 365  : 					PostQueuedCompletionStatus(g_CompletionPort, 0, 0, NULL); 

  00760	6a 00		 push	 0
  00762	6a 00		 push	 0
  00764	6a 00		 push	 0
  00766	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  0076b	50		 push	 eax
  0076c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQueuedCompletionStatus@16
  00772	eb cf		 jmp	 SHORT $LN7@IocpServer
$LN22@IocpServer:

; 366  : 		}
; 367  : 		if( g_CompletionPort )

  00774	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
  0077b	74 16		 je	 SHORT $LN23@IocpServer

; 368  : 		{
; 369  : 			CloseHandle(g_CompletionPort);

  0077d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00782	50		 push	 eax
  00783	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 370  : 			g_CompletionPort = NULL;

  00789	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
$LN23@IocpServer:

; 371  : 		}
; 372  : 		if (g_Listen != INVALID_SOCKET)  

  00793	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?g_Listen@@3IA, -1 ; g_Listen
  0079a	74 16		 je	 SHORT $LN28@IocpServer

; 373  : 		{ 
; 374  :             closesocket(g_Listen);  

  0079c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_Listen@@3IA ; g_Listen
  007a1	50		 push	 eax
  007a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 375  :             g_Listen = INVALID_SOCKET; 

  007a8	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_Listen@@3IA, -1 ; g_Listen
$LN28@IocpServer:
$LN31@IocpServer:
  007b2	c3		 ret	 0
$LN30@IocpServer:

; 376  : 		} 
; 377  : 	}
; 378  : 	return TRUE;

  007b3	b8 01 00 00 00	 mov	 eax, 1

; 379  : }

  007b8	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  007bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  007c2	59		 pop	 ecx
  007c3	5f		 pop	 edi
  007c4	5e		 pop	 esi
  007c5	5b		 pop	 ebx
  007c6	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007c9	33 cd		 xor	 ecx, ebp
  007cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007d0	8b e5		 mov	 esp, ebp
  007d2	5d		 pop	 ebp
  007d3	c2 04 00	 ret	 4
?IocpServerWorker@@YGKPAX@Z ENDP			; IocpServerWorker
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z
_TEXT	SEGMENT
_lpIoCtxt$ = -12					; size = 4
_aIndex$ = -8						; size = 4
_SendBytes$ = -4					; size = 4
_lpPerSocketContext$ = 8				; size = 4
?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z PROC		; IoMoreSend, COMDAT

; 1156 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1157 : 	EnterCriticalSection(&criti);

  00009	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1158 : 	DWORD SendBytes;
; 1159 : 	int aIndex = lpPerSocketContext->nIndex;

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	89 4d f8	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 1160 : 
; 1161 : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];

  0001d	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00022	c1 e0 00	 shl	 eax, 0
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _lpPerSocketContext$[ebp]
  00028	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0002c	89 55 f4	 mov	 DWORD PTR _lpIoCtxt$[ebp], edx

; 1162 : 	
; 1163 : 	//LogAdd("Send IO More");
; 1164 : 
; 1165 : 	if( (lpIoCtxt->nTotalBytes-lpIoCtxt->nSentBytes) < 0 ) 

  0002f	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00032	8b 4d f4	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  00035	8b 90 20 00 01
	00		 mov	 edx, DWORD PTR [eax+65568]
  0003b	2b 91 24 00 01
	00		 sub	 edx, DWORD PTR [ecx+65572]
  00041	79 12		 jns	 SHORT $LN2@IoMoreSend

; 1166 : 	{
; 1167 : 		LeaveCriticalSection(&criti);

  00043	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1168 : 		return FALSE;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 f9 00 00 00	 jmp	 $LN1@IoMoreSend
$LN2@IoMoreSend:

; 1169 : 	}
; 1170 : 	
; 1171 : 	//LogAddC(LOGC_RED, "%d 남은 만큼 다시 보냄", lpIoCtxt->nTotalBytes-lpIoCtxt->nSentBytes);
; 1172 : 	// 보낸 다음부터 
; 1173 : 	lpIoCtxt->wsabuf.buf	= (char*)lpIoCtxt->Buffer+lpIoCtxt->nSentBytes;

  00055	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00058	8b 88 24 00 01
	00		 mov	 ecx, DWORD PTR [eax+65572]
  0005e	8b 55 f4	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  00061	8d 44 0a 1c	 lea	 eax, DWORD PTR [edx+ecx+28]
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  00068	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1174 : 	lpIoCtxt->wsabuf.len	= lpIoCtxt->nTotalBytes-lpIoCtxt->nSentBytes;

  0006b	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  00071	8b 90 20 00 01
	00		 mov	 edx, DWORD PTR [eax+65568]
  00077	2b 91 24 00 01
	00		 sub	 edx, DWORD PTR [ecx+65572]
  0007d	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00080	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1175 : 	lpIoCtxt->IOOperation	= SEND_IO;

  00083	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00086	c7 80 28 00 01
	00 01 00 00 00	 mov	 DWORD PTR [eax+65576], 1

; 1176 : 
; 1177 : 	if (WSASend(gObj[aIndex].m_socket, &(lpIoCtxt->wsabuf), 1, &SendBytes, 0,
; 1178 : 		&(lpIoCtxt->Overlapped), NULL) == SOCKET_ERROR)

  00090	6a 00		 push	 0
  00092	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00095	50		 push	 eax
  00096	6a 00		 push	 0
  00098	8d 4d fc	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  0009b	51		 push	 ecx
  0009c	6a 01		 push	 1
  0009e	8b 55 f4	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  000a1	83 c2 14	 add	 edx, 20			; 00000014H
  000a4	52		 push	 edx
  000a5	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b2	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  000b6	52		 push	 edx
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  000bd	83 f8 ff	 cmp	 eax, -1
  000c0	75 5a		 jne	 SHORT $LN3@IoMoreSend

; 1179 : 	{
; 1180 : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000c8	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000cd	74 4b		 je	 SHORT $LN5@IoMoreSend

; 1181 : 		{
; 1182 : 			LogAdd("WSASend(%d) failed with error %d %s ", __LINE__, WSAGetLastError(), gObj[aIndex].Ip_addr);

  000cf	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000dc	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  000e0	52		 push	 edx
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000e7	50		 push	 eax
  000e8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z@4JA
  000ed	83 c0 1a	 add	 eax, 26			; 0000001aH
  000f0	50		 push	 eax
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CF@
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fc	83 c4 10	 add	 esp, 16			; 00000010H

; 1183 : 			CloseClient( aIndex );

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00108	83 c4 04	 add	 esp, 4

; 1184 : 			LeaveCriticalSection(&criti);

  0010b	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1185 : 			return FALSE;

  00116	33 c0		 xor	 eax, eax
  00118	eb 34		 jmp	 SHORT $LN1@IoMoreSend
$LN5@IoMoreSend:

; 1186 : 		}
; 1187 : 	}

  0011a	eb 15		 jmp	 SHORT $LN4@IoMoreSend
$LN3@IoMoreSend:

; 1188 : 	else 
; 1189 : 	{
; 1190 : 		lpPerSocketContext->dwIOCount++;

  0011c	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  0011f	8b 88 68 00 02
	00		 mov	 ecx, DWORD PTR [eax+131176]
  00125	83 c1 01	 add	 ecx, 1
  00128	8b 55 08	 mov	 edx, DWORD PTR _lpPerSocketContext$[ebp]
  0012b	89 8a 68 00 02
	00		 mov	 DWORD PTR [edx+131176], ecx
$LN4@IoMoreSend:

; 1191 : 	}
; 1192 : 	lpIoCtxt->nWaitIO = 1;

  00131	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00134	c7 80 2c 00 01
	00 01 00 00 00	 mov	 DWORD PTR [eax+65580], 1

; 1193 : 	LeaveCriticalSection(&criti);

  0013e	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1194 : 	return TRUE;

  00149	b8 01 00 00 00	 mov	 eax, 1
$LN1@IoMoreSend:

; 1195 : }

  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	5b		 pop	 ebx
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
?IoMoreSend@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ENDP		; IoMoreSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z
_TEXT	SEGMENT
_lpIoCtxt$ = -12					; size = 4
_aIndex$ = -8						; size = 4
_SendBytes$ = -4					; size = 4
_lpPerSocketContext$ = 8				; size = 4
?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z PROC	; IoSendSecond, COMDAT

; 1101 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1102 : 	EnterCriticalSection(&criti);

  00009	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1103 : 	DWORD SendBytes;
; 1104 : 	int aIndex = lpPerSocketContext->nIndex;

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00017	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001a	89 4d f8	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 1105 : 	
; 1106 : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];

  0001d	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00022	c1 e0 00	 shl	 eax, 0
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _lpPerSocketContext$[ebp]
  00028	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0002c	89 55 f4	 mov	 DWORD PTR _lpIoCtxt$[ebp], edx

; 1107 : 
; 1108 : 	if( lpIoCtxt->nWaitIO > 0 )	

  0002f	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00032	83 b8 2c 00 01
	00 00		 cmp	 DWORD PTR [eax+65580], 0
  00039	7e 12		 jle	 SHORT $LN2@IoSendSeco

; 1109 : 	{
; 1110 : 		LeaveCriticalSection(&criti);

  0003b	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1111 : 		return FALSE;

  00046	33 c0		 xor	 eax, eax
  00048	e9 62 01 00 00	 jmp	 $LN1@IoSendSeco
$LN2@IoSendSeco:

; 1112 : 	}
; 1113 : 	
; 1114 : 	lpIoCtxt->nTotalBytes = 0;

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00050	c7 80 20 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65568], 0

; 1115 : 	if( lpIoCtxt->nSecondOfs > 0 )

  0005a	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  0005d	83 b8 1c 00 01
	00 00		 cmp	 DWORD PTR [eax+65564], 0
  00064	7e 44		 jle	 SHORT $LN3@IoSendSeco

; 1116 : 	{
; 1117 : 		memcpy(lpIoCtxt->Buffer, lpIoCtxt->BufferSecond, lpIoCtxt->nSecondOfs);

  00066	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00069	8b 88 1c 00 01
	00		 mov	 ecx, DWORD PTR [eax+65564]
  0006f	51		 push	 ecx
  00070	8b 55 f4	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  00073	81 c2 1c 80 00
	00		 add	 edx, 32796		; 0000801cH
  00079	52		 push	 edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  0007d	83 c0 1c	 add	 eax, 28			; 0000001cH
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _memcpy
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1118 : 		lpIoCtxt->nTotalBytes = lpIoCtxt->nSecondOfs;

  00089	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  0008f	8b 91 1c 00 01
	00		 mov	 edx, DWORD PTR [ecx+65564]
  00095	89 90 20 00 01
	00		 mov	 DWORD PTR [eax+65568], edx

; 1119 : 		//LogAdd("세컨드 프론트로 복사.. %d", lpIoCtxt->nTotalBytes);
; 1120 : 		lpIoCtxt->nSecondOfs = 0;

  0009b	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  0009e	c7 80 1c 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65564], 0

; 1121 : 	}

  000a8	eb 12		 jmp	 SHORT $LN4@IoSendSeco
$LN3@IoSendSeco:

; 1122 : 	else 
; 1123 : 	{
; 1124 : 		LeaveCriticalSection(&criti);

  000aa	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1125 : 		return FALSE;

  000b5	33 c0		 xor	 eax, eax
  000b7	e9 f3 00 00 00	 jmp	 $LN1@IoSendSeco
$LN4@IoSendSeco:

; 1126 : 	}
; 1127 : 	// 쓰기작업이 완료되었다면..
; 1128 : 
; 1129 : 	lpIoCtxt->wsabuf.buf	= (char*)lpIoCtxt->Buffer;

  000bc	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  000bf	83 c0 1c	 add	 eax, 28			; 0000001cH
  000c2	8b 4d f4	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  000c5	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1130 : 	lpIoCtxt->wsabuf.len	= lpIoCtxt->nTotalBytes;

  000c8	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  000cb	8b 4d f4	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  000ce	8b 91 20 00 01
	00		 mov	 edx, DWORD PTR [ecx+65568]
  000d4	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1131 : 	lpIoCtxt->nSentBytes	= 0;

  000d7	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  000da	c7 80 24 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65572], 0

; 1132 : 	lpIoCtxt->IOOperation	= SEND_IO;

  000e4	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  000e7	c7 80 28 00 01
	00 01 00 00 00	 mov	 DWORD PTR [eax+65576], 1

; 1133 : 
; 1134 : 	if (WSASend(gObj[aIndex].m_socket, &(lpIoCtxt->wsabuf), 1, &SendBytes, 0,
; 1135 : 		&(lpIoCtxt->Overlapped), NULL) == SOCKET_ERROR)

  000f1	6a 00		 push	 0
  000f3	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  000f6	50		 push	 eax
  000f7	6a 00		 push	 0
  000f9	8d 4d fc	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  000fc	51		 push	 ecx
  000fd	6a 01		 push	 1
  000ff	8b 55 f4	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  00102	83 c2 14	 add	 edx, 20			; 00000014H
  00105	52		 push	 edx
  00106	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00113	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  00117	52		 push	 edx
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  0011e	83 f8 ff	 cmp	 eax, -1
  00121	75 5a		 jne	 SHORT $LN5@IoSendSeco

; 1136 : 	{
; 1137 : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00129	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  0012e	74 4b		 je	 SHORT $LN7@IoSendSeco

; 1138 : 		{
; 1139 : 			LogAdd("WSASend(%d) failed with error %d %s ", __LINE__, WSAGetLastError(), gObj[aIndex].Ip_addr);

  00130	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013d	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00141	52		 push	 edx
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00148	50		 push	 eax
  00149	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z@4JA
  0014e	83 c0 26	 add	 eax, 38			; 00000026H
  00151	50		 push	 eax
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NNJJAKBF@WSASend?$CI?$CFd?$CJ?5failed?5with?5error?5?$CF@
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0015d	83 c4 10	 add	 esp, 16			; 00000010H

; 1140 : 			//lpIoCtxt->nWaitIO = 3;
; 1141 : 			CloseClient( aIndex );

  00160	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00169	83 c4 04	 add	 esp, 4

; 1142 : 			LeaveCriticalSection(&criti);

  0016c	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1143 : 			return FALSE;

  00177	33 c0		 xor	 eax, eax
  00179	eb 34		 jmp	 SHORT $LN1@IoSendSeco
$LN7@IoSendSeco:

; 1144 : 		}
; 1145 : 	}

  0017b	eb 15		 jmp	 SHORT $LN6@IoSendSeco
$LN5@IoSendSeco:

; 1146 : 	else 
; 1147 : 	{
; 1148 : 		lpPerSocketContext->dwIOCount++;

  0017d	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00180	8b 88 68 00 02
	00		 mov	 ecx, DWORD PTR [eax+131176]
  00186	83 c1 01	 add	 ecx, 1
  00189	8b 55 08	 mov	 edx, DWORD PTR _lpPerSocketContext$[ebp]
  0018c	89 8a 68 00 02
	00		 mov	 DWORD PTR [edx+131176], ecx
$LN6@IoSendSeco:

; 1149 : 	}
; 1150 : 	lpIoCtxt->nWaitIO = 1;

  00192	8b 45 f4	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00195	c7 80 2c 00 01
	00 01 00 00 00	 mov	 DWORD PTR [eax+65580], 1

; 1151 : 	LeaveCriticalSection(&criti);

  0019f	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1152 : 	return TRUE;

  001aa	b8 01 00 00 00	 mov	 eax, 1
$LN1@IoSendSeco:

; 1153 : }

  001af	5f		 pop	 edi
  001b0	5e		 pop	 esi
  001b1	5b		 pop	 ebx
  001b2	8b e5		 mov	 esp, ebp
  001b4	5d		 pop	 ebp
  001b5	c3		 ret	 0
?IoSendSecond@@YAHPAU_PER_SOCKET_CONTEXT@@@Z ENDP	; IoSendSecond
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z
_TEXT	SEGMENT
_index$ = -4						; size = 4
_lpPerSocketContext$ = 8				; size = 4
_bGraceful$ = 12					; size = 4
?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z PROC	; CloseClient, COMDAT

; 1214 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1215 : 	int index=-1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _index$[ebp], -1

; 1216 : 
; 1217 : 	/*if( lpPerSocketContext->dwIOCount > 0 ) 
; 1218 : 	{
; 1219 : 		if( lpPerSocketContext->dwIOCount > 1 )	// 작업 들어가 있는 상태
; 1220 : 		{
; 1221 : 			if( lpPerSocketContext->IOContext[1].nWaitIO > 0 )	// 쓰기 작업중이면..
; 1222 : 			{
; 1223 : 				LogAdd("#1 Count Zero %d ior:%d iow:%d", lpPerSocketContext->dwIOCount,lpPerSocketContext->IOContext[0].nWaitIO, lpPerSocketContext->IOContext[1].nWaitIO);
; 1224 : 				return;
; 1225 : 			}
; 1226 : 		}
; 1227 : 		else 
; 1228 : 		{	// 작업이 들어가 있지만.. 쓰기 완료를 기다리는 중 이다.
; 1229 : 			if( lpPerSocketContext->IOContext[1].nWaitIO > 0 )	// 
; 1230 : 			{
; 1231 : 				LogAdd("#2 Count Zero %d ior:%d iow:%d", lpPerSocketContext->dwIOCount,lpPerSocketContext->IOContext[0].nWaitIO, lpPerSocketContext->IOContext[1].nWaitIO);
; 1232 : 			}			
; 1233 : 		}
; 1234 : 	}
; 1235 : 	*/
; 1236 : 	index = lpPerSocketContext->nIndex;

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00013	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00016	89 4d fc	 mov	 DWORD PTR _index$[ebp], ecx

; 1237 : 
; 1238 : #ifdef PACKET_KUZIMO
; 1239 : 	WriteLog("PacketLog.txt", "%08u	S	%-12s	UserIndex(%05d)	CloseClient(Socket)\n", GetTickCount(), gObj[index].Name, index);
; 1240 : #endif
; 1241 : 
; 1242 : 	if( index >= ALLOC_USEROBJECTSTART && index < MAX_OBJECT ) 

  00019	81 7d fc 00 19
	00 00		 cmp	 DWORD PTR _index$[ebp], 6400 ; 00001900H
  00020	0f 8c bc 00 00
	00		 jl	 $LN1@CloseClien
  00026	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _index$[ebp], 7400 ; 00001ce8H
  0002d	0f 8d af 00 00
	00		 jge	 $LN1@CloseClien

; 1243 : 	{		
; 1244 : 		//DevGamesX 01/05/2018 - OffExp
; 1245 : 		if( OffExp.Update(index, 0) )

  00033	6a 00		 push	 0
  00035	8b 45 fc	 mov	 eax, DWORD PTR _index$[ebp]
  00038	50		 push	 eax
  00039	b9 00 00 00 00	 mov	 ecx, OFFSET ?OffExp@@3VcOffExp@@A ; OffExp
  0003e	e8 00 00 00 00	 call	 ?Update@cOffExp@@QAE_NHE@Z ; cOffExp::Update
  00043	0f b6 c8	 movzx	 ecx, al
  00046	85 c9		 test	 ecx, ecx
  00048	74 05		 je	 SHORT $LN3@CloseClien

; 1246 : 		{
; 1247 : 			return;

  0004a	e9 93 00 00 00	 jmp	 $LN1@CloseClien
$LN3@CloseClien:

; 1248 : 		}
; 1249 : 
; 1250 : 		if( OFFSystem.Updateoffafk(index, 0) )

  0004f	6a 00		 push	 0
  00051	8b 45 fc	 mov	 eax, DWORD PTR _index$[ebp]
  00054	50		 push	 eax
  00055	b9 00 00 00 00	 mov	 ecx, OFFSET ?OFFSystem@@3VCOFFSystem@@A ; OFFSystem
  0005a	e8 00 00 00 00	 call	 ?Updateoffafk@COFFSystem@@QAE_NHE@Z ; COFFSystem::Updateoffafk
  0005f	0f b6 c8	 movzx	 ecx, al
  00062	85 c9		 test	 ecx, ecx
  00064	74 02		 je	 SHORT $LN4@CloseClien

; 1251 : 		{
; 1252 : 			return;

  00066	eb 7a		 jmp	 SHORT $LN1@CloseClien
$LN4@CloseClien:

; 1253 : 		}
; 1254 : 
; 1255 : 		if( OFFtrade.Updateofftrade(index, 0) )

  00068	6a 00		 push	 0
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _index$[ebp]
  0006d	50		 push	 eax
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?OFFtrade@@3VCOFFtrade@@A ; OFFtrade
  00073	e8 00 00 00 00	 call	 ?Updateofftrade@COFFtrade@@QAE_NHE@Z ; COFFtrade::Updateofftrade
  00078	0f b6 c8	 movzx	 ecx, al
  0007b	85 c9		 test	 ecx, ecx
  0007d	74 02		 je	 SHORT $LN5@CloseClien

; 1256 : 	{
; 1257 : 		return;

  0007f	eb 61		 jmp	 SHORT $LN1@CloseClien
$LN5@CloseClien:

; 1258 : 	}
; 1259 : 
; 1260 : 		if( INVALID_SOCKET != gObj[index].m_socket )

  00081	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008e	83 7c 01 14 ff	 cmp	 DWORD PTR [ecx+eax+20], -1
  00093	74 41		 je	 SHORT $LN6@CloseClien

; 1261 : 		{
; 1262 : #ifdef NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 1263 : 			gObj[index].NPggCSAuth.Close();
; 1264 : #endif
; 1265 : 			if( closesocket(gObj[index].m_socket) == SOCKET_ERROR )

  00095	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a2	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  000a6	52		 push	 edx
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  000ad	83 f8 ff	 cmp	 eax, -1
  000b0	75 0f		 jne	 SHORT $LN7@CloseClien

; 1266 : 			{
; 1267 : 				if(WSAGetLastError() != 10038)

  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000b8	3d 36 27 00 00	 cmp	 eax, 10038		; 00002736H
  000bd	74 02		 je	 SHORT $LN7@CloseClien

; 1268 : 				{	
; 1269 : 					return;

  000bf	eb 21		 jmp	 SHORT $LN1@CloseClien
$LN7@CloseClien:

; 1270 : 				}
; 1271 : 			}
; 1272 : 
; 1273 : 			gObj[index].m_socket = INVALID_SOCKET;

  000c1	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ce	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+20], -1
$LN6@CloseClien:

; 1274 : 		}
; 1275 : 		gObjDel(index);

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _index$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  000df	83 c4 04	 add	 esp, 4
$LN1@CloseClien:

; 1276 : 	}
; 1277 : 	return;     
; 1278 : }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?CloseClient@@YAXPAU_PER_SOCKET_CONTEXT@@H@Z ENDP	; CloseClient
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
_TEXT	SEGMENT
$T2 = -6836						; size = 4
$T3 = -6832						; size = 4
$T4 = -6828						; size = 4
$T5 = -6824						; size = 4
$T6 = -6820						; size = 4
$T7 = -6816						; size = 4
$T8 = -6812						; size = 4
$T9 = -6808						; size = 4
$T10 = -6804						; size = 4
$T11 = -6800						; size = 4
$T12 = -6796						; size = 4
$T13 = -6792						; size = 4
$T14 = -6788						; size = 4
$T15 = -6784						; size = 4
$T16 = -6780						; size = 4
$T17 = -6776						; size = 4
$T18 = -6772						; size = 4
$T19 = -6768						; size = 4
$T20 = -6764						; size = 4
$T21 = -6760						; size = 4
$T22 = -6756						; size = 4
_spe$23 = -6240						; size = 2056
_spe$24 = -4184						; size = 2056
_wSize$25 = -2128					; size = 2
_bSerial$26 = -2121					; size = 1
_lphead$27 = -2120					; size = 4
_iSize$28 = -2116					; size = 4
_spe$29 = -2112						; size = 2056
_bSerial$30 = -53					; size = 1
_lphead$31 = -52					; size = 4
_iSize$32 = -48						; size = 4
_lphead$33 = -44					; size = 4
_lphead$34 = -40					; size = 4
_byDec$ = -36						; size = 4
_xcode$ = -30						; size = 1
_headcode$ = -29					; size = 1
_size$ = -28						; size = 4
_lOfs$ = -24						; size = 4
_recvbuf$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpIOContext$ = 8					; size = 4
_uIndex$ = 12						; size = 4
?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z PROC		; RecvDataParse, COMDAT

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 a8 1a 00 00	 mov	 eax, 6824		; 00001aa8H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 537  : 	if( lpIOContext->nSentBytes < 3 ) return TRUE;

  00032	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00035	83 b8 24 00 01
	00 03		 cmp	 DWORD PTR [eax+65572], 3
  0003c	7d 0a		 jge	 SHORT $LN4@RecvDataPa
  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	e9 af 0a 00 00	 jmp	 $LN1@RecvDataPa
$LN4@RecvDataPa:

; 538  : 	
; 539  : 	LPBYTE	recvbuf;
; 540  : 	int		lOfs=0;

  00048	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _lOfs$[ebp], 0

; 541  : 	int		size=0;

  0004f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _size$[ebp], 0

; 542  : 	BYTE	headcode;
; 543  : 	BYTE	xcode=0;

  00056	c6 45 e2 00	 mov	 BYTE PTR _xcode$[ebp], 0

; 544  : 	BYTE	*byDec = new BYTE[MAX_BUFF_SIZE*2];

  0005a	68 00 80 00 00	 push	 32768			; 00008000H
  0005f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00064	83 c4 04	 add	 esp, 4
  00067	89 85 9c e5 ff
	ff		 mov	 DWORD PTR $T22[ebp], eax
  0006d	8b 85 9c e5 ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  00073	89 45 dc	 mov	 DWORD PTR _byDec$[ebp], eax

; 545  : 
; 546  : 	recvbuf = (LPBYTE)lpIOContext->Buffer;

  00076	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00079	83 c0 1c	 add	 eax, 28			; 0000001cH
  0007c	89 45 ec	 mov	 DWORD PTR _recvbuf$[ebp], eax
$LN2@RecvDataPa:

; 547  : 
; 548  : 	while(1)

  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	85 c0		 test	 eax, eax
  00086	0f 84 4e 0a 00
	00		 je	 $LN3@RecvDataPa

; 549  : 	{
; 550  : 		if( recvbuf[lOfs] == 0xC1 || recvbuf[lOfs] == 0xC3 ) 

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _recvbuf$[ebp]
  0008f	03 45 e8	 add	 eax, DWORD PTR _lOfs$[ebp]
  00092	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00095	81 f9 c1 00 00
	00		 cmp	 ecx, 193		; 000000c1H
  0009b	74 11		 je	 SHORT $LN7@RecvDataPa
  0009d	8b 45 ec	 mov	 eax, DWORD PTR _recvbuf$[ebp]
  000a0	03 45 e8	 add	 eax, DWORD PTR _lOfs$[ebp]
  000a3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000a6	81 f9 c3 00 00
	00		 cmp	 ecx, 195		; 000000c3H
  000ac	75 2c		 jne	 SHORT $LN5@RecvDataPa
$LN7@RecvDataPa:

; 551  : 		{
; 552  : 			LPPBMSG_HEAD lphead = (LPPBMSG_HEAD)(recvbuf+lOfs);

  000ae	8b 45 ec	 mov	 eax, DWORD PTR _recvbuf$[ebp]
  000b1	03 45 e8	 add	 eax, DWORD PTR _lOfs$[ebp]
  000b4	89 45 d8	 mov	 DWORD PTR _lphead$34[ebp], eax

; 553  : 			size				= lphead->size;

  000b7	8b 45 d8	 mov	 eax, DWORD PTR _lphead$34[ebp]
  000ba	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000be	89 4d e4	 mov	 DWORD PTR _size$[ebp], ecx

; 554  : 			headcode			= lphead->headcode;

  000c1	8b 45 d8	 mov	 eax, DWORD PTR _lphead$34[ebp]
  000c4	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  000c7	88 4d e3	 mov	 BYTE PTR _headcode$[ebp], cl

; 555  : 			xcode				= recvbuf[lOfs];

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _recvbuf$[ebp]
  000cd	03 45 e8	 add	 eax, DWORD PTR _lOfs$[ebp]
  000d0	8a 08		 mov	 cl, BYTE PTR [eax]
  000d2	88 4d e2	 mov	 BYTE PTR _xcode$[ebp], cl

; 556  : 		}

  000d5	e9 b1 00 00 00	 jmp	 $LN6@RecvDataPa
$LN5@RecvDataPa:

; 557  : 		else if( recvbuf[lOfs] == 0xC2 || recvbuf[lOfs] == 0xC4 ) //

  000da	8b 45 ec	 mov	 eax, DWORD PTR _recvbuf$[ebp]
  000dd	03 45 e8	 add	 eax, DWORD PTR _lOfs$[ebp]
  000e0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000e3	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  000e9	74 11		 je	 SHORT $LN10@RecvDataPa
  000eb	8b 45 ec	 mov	 eax, DWORD PTR _recvbuf$[ebp]
  000ee	03 45 e8	 add	 eax, DWORD PTR _lOfs$[ebp]
  000f1	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000f4	81 f9 c4 00 00
	00		 cmp	 ecx, 196		; 000000c4H
  000fa	75 39		 jne	 SHORT $LN8@RecvDataPa
$LN10@RecvDataPa:

; 558  : 		{
; 559  : 			LPPWMSG_HEAD lphead	= (LPPWMSG_HEAD)(recvbuf+lOfs);

  000fc	8b 45 ec	 mov	 eax, DWORD PTR _recvbuf$[ebp]
  000ff	03 45 e8	 add	 eax, DWORD PTR _lOfs$[ebp]
  00102	89 45 d4	 mov	 DWORD PTR _lphead$33[ebp], eax

; 560  : 			size				= ((WORD)(lphead->sizeH)<<8);

  00105	8b 45 d4	 mov	 eax, DWORD PTR _lphead$33[ebp]
  00108	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0010c	c1 e1 08	 shl	 ecx, 8
  0010f	89 4d e4	 mov	 DWORD PTR _size$[ebp], ecx

; 561  : 			size			   |= (WORD)(lphead->sizeL);

  00112	8b 45 d4	 mov	 eax, DWORD PTR _lphead$33[ebp]
  00115	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00119	0b 4d e4	 or	 ecx, DWORD PTR _size$[ebp]
  0011c	89 4d e4	 mov	 DWORD PTR _size$[ebp], ecx

; 562  : 			headcode			= lphead->headcode;

  0011f	8b 45 d4	 mov	 eax, DWORD PTR _lphead$33[ebp]
  00122	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00125	88 4d e3	 mov	 BYTE PTR _headcode$[ebp], cl

; 563  : 			xcode				= recvbuf[lOfs];

  00128	8b 45 ec	 mov	 eax, DWORD PTR _recvbuf$[ebp]
  0012b	03 45 e8	 add	 eax, DWORD PTR _lOfs$[ebp]
  0012e	8a 08		 mov	 cl, BYTE PTR [eax]
  00130	88 4d e2	 mov	 BYTE PTR _xcode$[ebp], cl

; 564  : 		}

  00133	eb 56		 jmp	 SHORT $LN6@RecvDataPa
$LN8@RecvDataPa:

; 565  : 		else  // 헤더가 맞지 않다면..
; 566  : 		{
; 567  : 			LogAdd("error-L1 : Header error (%s %d)lOfs:%d, size:%d", __FILE__, __LINE__, lOfs, lpIOContext->nSentBytes);

  00135	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00138	8b 88 24 00 01
	00		 mov	 ecx, DWORD PTR [eax+65572]
  0013e	51		 push	 ecx
  0013f	8b 55 e8	 mov	 edx, DWORD PTR _lOfs$[ebp]
  00142	52		 push	 edx
  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA
  00148	83 c0 1f	 add	 eax, 31			; 0000001fH
  0014b	50		 push	 eax
  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@PEHCNCMI@error?9L1?5?3?5Header?5error?5?$CI?$CFs?5?$CFd?$CJ@
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0015c	83 c4 14	 add	 esp, 20			; 00000014H

; 568  : 			lpIOContext->nSentBytes = 0;

  0015f	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00162	c7 80 24 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65572], 0

; 569  : 			delete[] byDec;

  0016c	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  0016f	89 85 98 e5 ff
	ff		 mov	 DWORD PTR $T21[ebp], eax
  00175	8b 8d 98 e5 ff
	ff		 mov	 ecx, DWORD PTR $T21[ebp]
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00181	83 c4 04	 add	 esp, 4

; 570  : 			return FALSE;

  00184	33 c0		 xor	 eax, eax
  00186	e9 6c 09 00 00	 jmp	 $LN1@RecvDataPa
$LN6@RecvDataPa:

; 571  : 		}
; 572  : /*
; 573  : #ifdef HACKTOOL_KUZIMO
; 574  : 		if(CHECK_LIMIT( uIndex, MAX_OBJECT ))
; 575  : 		{
; 576  : 			int				iOutPacketCount;
; 577  : 			int				iOutEncryptPacketCount;
; 578  : 			unsigned int	iOutPacketTotalSize;
; 579  : 
; 580  : 			gObj[uIndex].m_kRecvPacketStatistics.GetStatistics(iOutPacketCount, iOutEncryptPacketCount, iOutPacketTotalSize);
; 581  : 
; 582  : 			if(gObj[uIndex].m_kRecvPacketStatistics.Process() == PacketStatistics::PS_RESET) // 시간되면 통계치가 리셋된다.
; 583  : 			{
; 584  : 				// 초당 데이터가 잡힌다.
; 585  : //				char temp[1000];
; 586  : //				wsprintf(temp, "PacketCount = %d, iOutEncryptPacketCount = %d, PacketTotalSize = %d\n", iOutPacketCount, iOutEncryptPacketCount, iOutPacketTotalSize);
; 587  : //				OutputDebugString(temp);
; 588  : 			}
; 589  : 
; 590  : 			if(iOutPacketCount > PACKET_NUMBER_PER_SECOND)
; 591  : 			{
; 592  : 				LogAddC(LOGC_RED,"[HACKTOOL] : Packets Per Second = %d"
; 593  : 								 "ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 594  : 						iOutPacketCount,
; 595  : 						gObj[uIndex].Ip_addr,
; 596  : 						gObj[uIndex].AccountID, 
; 597  : 						gObj[uIndex].Name, 
; 598  : 						headcode, 
; 599  : 						__FILE__, __LINE__, 
; 600  : 						gObj[uIndex].Connected);
; 601  : 				return FALSE;
; 602  : 
; 603  : 			}
; 604  : 
; 605  : 			gObj[uIndex].m_kRecvPacketStatistics.AddPacketInfo(((xcode == 0xC3) || (xcode == 0xC4))? true : false, size);
; 606  : 		}
; 607  : #endif
; 608  : */
; 609  : 		if( size <= 0 )

  0018b	83 7d e4 00	 cmp	 DWORD PTR _size$[ebp], 0
  0018f	7f 31		 jg	 SHORT $LN11@RecvDataPa

; 610  : 		{
; 611  : 			LogAdd("error-L1 : size %d", size);

  00191	8b 45 e4	 mov	 eax, DWORD PTR _size$[ebp]
  00194	50		 push	 eax
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OEJCIIJN@error?9L1?5?3?5size?5?$CFd@
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001a0	83 c4 08	 add	 esp, 8

; 612  : 			delete[] byDec;

  001a3	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  001a6	89 85 94 e5 ff
	ff		 mov	 DWORD PTR $T20[ebp], eax
  001ac	8b 8d 94 e5 ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp]
  001b2	51		 push	 ecx
  001b3	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001b8	83 c4 04	 add	 esp, 4

; 613  : 			return FALSE;

  001bb	33 c0		 xor	 eax, eax
  001bd	e9 35 09 00 00	 jmp	 $LN1@RecvDataPa
$LN11@RecvDataPa:

; 614  : 		}
; 615  : 		if( size <= lpIOContext->nSentBytes )	// 데이터가 크기만큼 존재하면..

  001c2	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  001c5	8b 4d e4	 mov	 ecx, DWORD PTR _size$[ebp]
  001c8	3b 88 24 00 01
	00		 cmp	 ecx, DWORD PTR [eax+65572]
  001ce	0f 8f 85 08 00
	00		 jg	 $LN12@RecvDataPa

; 616  : 		{
; 617  : 			if( xcode == 0xC3 )

  001d4	0f b6 45 e2	 movzx	 eax, BYTE PTR _xcode$[ebp]
  001d8	3d c3 00 00 00	 cmp	 eax, 195		; 000000c3H
  001dd	0f 85 d7 02 00
	00		 jne	 $LN14@RecvDataPa

; 618  : 			{
; 619  : 				int iSize = g_SimpleModulusCS.Decrypt( byDec+2, (recvbuf+lOfs+2), size-2);

  001e3	8b 45 e4	 mov	 eax, DWORD PTR _size$[ebp]
  001e6	83 e8 02	 sub	 eax, 2
  001e9	50		 push	 eax
  001ea	8b 4d e8	 mov	 ecx, DWORD PTR _lOfs$[ebp]
  001ed	8b 55 ec	 mov	 edx, DWORD PTR _recvbuf$[ebp]
  001f0	8d 44 0a 02	 lea	 eax, DWORD PTR [edx+ecx+2]
  001f4	50		 push	 eax
  001f5	8b 4d dc	 mov	 ecx, DWORD PTR _byDec$[ebp]
  001f8	83 c1 02	 add	 ecx, 2
  001fb	51		 push	 ecx
  001fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusCS@@3VCSimpleModulus@@A ; g_SimpleModulusCS
  00201	e8 00 00 00 00	 call	 ?Decrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Decrypt
  00206	89 45 d0	 mov	 DWORD PTR _iSize$32[ebp], eax

; 620  : 				if ( iSize < 0)					// 깨지거나 조작된 패킷	

  00209	83 7d d0 00	 cmp	 DWORD PTR _iSize$32[ebp], 0
  0020d	7d 05		 jge	 SHORT $LN16@RecvDataPa

; 621  : 				{
; 622  : 				}

  0020f	e9 a1 02 00 00	 jmp	 $LN17@RecvDataPa
$LN16@RecvDataPa:

; 623  : 				else 
; 624  : 				{
; 625  : 					LPPBMSG_HEAD lphead;				
; 626  : 					/*
; 627  : 					if( gLanguage == 3 )
; 628  : 					{	// 중국의 경우 패킷 암호화 한번 더 있음										
; 629  : 					*/
; 630  : 						lphead = (LPPBMSG_HEAD)(byDec+1);

  00214	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00217	83 c0 01	 add	 eax, 1
  0021a	89 45 cc	 mov	 DWORD PTR _lphead$31[ebp], eax

; 631  : 						headcode		= lphead->headcode;

  0021d	8b 45 cc	 mov	 eax, DWORD PTR _lphead$31[ebp]
  00220	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00223	88 4d e3	 mov	 BYTE PTR _headcode$[ebp], cl

; 632  : 
; 633  : 						BYTE bSerial = byDec[2];

  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	d1 e0		 shl	 eax, 1
  0022d	8b 4d dc	 mov	 ecx, DWORD PTR _byDec$[ebp]
  00230	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00233	88 55 cb	 mov	 BYTE PTR _bSerial$30[ebp], dl

; 634  : 
; 635  : 						byDec[1] = 0XC1;

  00236	b8 01 00 00 00	 mov	 eax, 1
  0023b	c1 e0 00	 shl	 eax, 0
  0023e	8b 4d dc	 mov	 ecx, DWORD PTR _byDec$[ebp]
  00241	c6 04 01 c1	 mov	 BYTE PTR [ecx+eax], 193	; 000000c1H

; 636  : 						byDec[2] = (BYTE)iSize+2;

  00245	0f b6 45 d0	 movzx	 eax, BYTE PTR _iSize$32[ebp]
  00249	83 c0 02	 add	 eax, 2
  0024c	b9 01 00 00 00	 mov	 ecx, 1
  00251	d1 e1		 shl	 ecx, 1
  00253	8b 55 dc	 mov	 edx, DWORD PTR _byDec$[ebp]
  00256	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 637  : 
; 638  : 						CStreamPacketEngine_Server spe;

  00259	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _spe$29[ebp]
  0025f	e8 00 00 00 00	 call	 ??0CStreamPacketEngine_Server@@QAE@XZ ; CStreamPacketEngine_Server::CStreamPacketEngine_Server
  00264	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 639  : 						spe.Clear();

  0026b	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _spe$29[ebp]
  00271	e8 00 00 00 00	 call	 ?Clear@CStreamPacketEngine_Server@@QAEXXZ ; CStreamPacketEngine_Server::Clear

; 640  : 
; 641  : 						if( !spe.AddData(byDec+1, iSize+2) )

  00276	8b 45 d0	 mov	 eax, DWORD PTR _iSize$32[ebp]
  00279	83 c0 02	 add	 eax, 2
  0027c	50		 push	 eax
  0027d	8b 4d dc	 mov	 ecx, DWORD PTR _byDec$[ebp]
  00280	83 c1 01	 add	 ecx, 1
  00283	51		 push	 ecx
  00284	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _spe$29[ebp]
  0028a	e8 00 00 00 00	 call	 ?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z ; CStreamPacketEngine_Server::AddData
  0028f	85 c0		 test	 eax, eax
  00291	0f 85 a7 00 00
	00		 jne	 $LN18@RecvDataPa

; 642  : 						{
; 643  : 							LogAddC(LOGC_RED,"error-L1 : CStreamPacketEngine Adding Error : "

  00297	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  0029e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a4	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  002a8	52		 push	 edx
  002a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA
  002ae	83 c0 71	 add	 eax, 113		; 00000071H
  002b1	50		 push	 eax
  002b2	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  002b7	0f b6 4d e3	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  002bb	51		 push	 ecx
  002bc	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  002c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c8	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  002cc	51		 push	 ecx
  002cd	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  002d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d9	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  002dd	51		 push	 ecx
  002de	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  002e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ea	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  002ee	51		 push	 ecx
  002ef	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5@
  002f4	6a 02		 push	 2
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002fc	83 c4 24	 add	 esp, 36			; 00000024H

; 644  : 										     "ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 645  : 								    gObj[uIndex].Ip_addr,
; 646  : 									gObj[uIndex].AccountID, 
; 647  : 									gObj[uIndex].Name, 
; 648  : 									headcode, 
; 649  : 									__FILE__, __LINE__, 
; 650  : 									gObj[uIndex].Connected);
; 651  : 							delete[] byDec;

  002ff	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00302	89 85 90 e5 ff
	ff		 mov	 DWORD PTR $T19[ebp], eax
  00308	8b 8d 90 e5 ff
	ff		 mov	 ecx, DWORD PTR $T19[ebp]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00314	83 c4 04	 add	 esp, 4

; 652  : 							return FALSE;

  00317	c7 85 8c e5 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp], 0
  00321	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00328	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _spe$29[ebp]
  0032e	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  00333	8b 85 8c e5 ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  00339	e9 b9 07 00 00	 jmp	 $LN1@RecvDataPa
$LN18@RecvDataPa:

; 653  : 						}
; 654  : 
; 655  : 						if( spe.ExtractPacket(byDec) )

  0033e	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00341	50		 push	 eax
  00342	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _spe$29[ebp]
  00348	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  0034d	85 c0		 test	 eax, eax
  0034f	0f 84 a7 00 00
	00		 je	 $LN19@RecvDataPa

; 656  : 						{
; 657  : 							LogAddC(LOGC_RED,"error-L1 : CStreamPacketEngine ExtractPacket Error : "

  00355	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  0035c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00362	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00366	52		 push	 edx
  00367	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA
  0036c	83 c0 7f	 add	 eax, 127		; 0000007fH
  0036f	50		 push	 eax
  00370	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00375	0f b6 4d e3	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  00379	51		 push	 ecx
  0037a	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00381	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00386	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0038a	51		 push	 ecx
  0038b	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00392	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00397	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  0039b	51		 push	 ecx
  0039c	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  003a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a8	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  003ac	51		 push	 ecx
  003ad	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5@
  003b2	6a 02		 push	 2
  003b4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  003ba	83 c4 24	 add	 esp, 36			; 00000024H

; 658  :                                              "ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 659  : 									gObj[uIndex].Ip_addr,
; 660  : 									gObj[uIndex].AccountID, 
; 661  : 									gObj[uIndex].Name, 
; 662  : 									headcode, 
; 663  : 									__FILE__, __LINE__, 
; 664  : 									gObj[uIndex].Connected);
; 665  : 							delete[] byDec;

  003bd	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  003c0	89 85 88 e5 ff
	ff		 mov	 DWORD PTR $T17[ebp], eax
  003c6	8b 8d 88 e5 ff
	ff		 mov	 ecx, DWORD PTR $T17[ebp]
  003cc	51		 push	 ecx
  003cd	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  003d2	83 c4 04	 add	 esp, 4

; 666  : 							return FALSE;

  003d5	c7 85 84 e5 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp], 0
  003df	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003e6	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _spe$29[ebp]
  003ec	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  003f1	8b 85 84 e5 ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  003f7	e9 fb 06 00 00	 jmp	 $LN1@RecvDataPa
$LN19@RecvDataPa:

; 667  : 						}
; 668  : #ifdef TESTSERVER
; 669  : 		if( xcode == 0xC3 )

  003fc	0f b6 45 e2	 movzx	 eax, BYTE PTR _xcode$[ebp]
  00400	3d c3 00 00 00	 cmp	 eax, 195		; 000000c3H
  00405	75 1e		 jne	 SHORT $LN20@RecvDataPa

; 670  : 		{
; 671  : 			if( headcode == 0xC5)

  00407	0f b6 45 e3	 movzx	 eax, BYTE PTR _headcode$[ebp]
  0040b	3d c5 00 00 00	 cmp	 eax, 197		; 000000c5H
  00410	75 13		 jne	 SHORT $LN20@RecvDataPa

; 672  : 			{
; 673  : 				LogAdd("암호패킷 : [0x%x]", headcode);

  00412	0f b6 45 e3	 movzx	 eax, BYTE PTR _headcode$[ebp]
  00416	50		 push	 eax
  00417	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN@
  0041c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00422	83 c4 08	 add	 esp, 8
$LN20@RecvDataPa:

; 674  : 			}
; 675  : 		}
; 676  : #endif
; 677  : 
; 678  : #ifdef HACKTOOL_KUZIMO
; 679  : 		if (IsHackTool(headcode, size, uIndex, xcode) == TRUE)

  00425	0f b6 45 e2	 movzx	 eax, BYTE PTR _xcode$[ebp]
  00429	50		 push	 eax
  0042a	8b 4d 0c	 mov	 ecx, DWORD PTR _uIndex$[ebp]
  0042d	51		 push	 ecx
  0042e	8b 55 e4	 mov	 edx, DWORD PTR _size$[ebp]
  00431	52		 push	 edx
  00432	0f b6 45 e3	 movzx	 eax, BYTE PTR _headcode$[ebp]
  00436	50		 push	 eax
  00437	e8 00 00 00 00	 call	 ?IsHackTool@@YAHEHHE@Z	; IsHackTool
  0043c	83 c4 10	 add	 esp, 16			; 00000010H
  0043f	83 f8 01	 cmp	 eax, 1
  00442	75 3f		 jne	 SHORT $LN22@RecvDataPa

; 680  : 		{
; 681  : 			delete[] byDec;

  00444	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00447	89 85 80 e5 ff
	ff		 mov	 DWORD PTR $T15[ebp], eax
  0044d	8b 8d 80 e5 ff
	ff		 mov	 ecx, DWORD PTR $T15[ebp]
  00453	51		 push	 ecx
  00454	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00459	83 c4 04	 add	 esp, 4

; 682  : 			return FALSE;

  0045c	c7 85 7c e5 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp], 0
  00466	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0046d	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _spe$29[ebp]
  00473	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  00478	8b 85 7c e5 ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
  0047e	e9 74 06 00 00	 jmp	 $LN1@RecvDataPa
$LN22@RecvDataPa:

; 683  : 		}
; 684  : #endif // HACKTOOL_KUZIMO
; 685  : 
; 686  : 						// Serial Check
; 687  : 						ProtocolCore(headcode, byDec, iSize, uIndex, 1, bSerial);

  00483	0f b6 45 cb	 movzx	 eax, BYTE PTR _bSerial$30[ebp]
  00487	50		 push	 eax
  00488	6a 01		 push	 1
  0048a	8b 4d 0c	 mov	 ecx, DWORD PTR _uIndex$[ebp]
  0048d	51		 push	 ecx
  0048e	8b 55 d0	 mov	 edx, DWORD PTR _iSize$32[ebp]
  00491	52		 push	 edx
  00492	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00495	50		 push	 eax
  00496	0f b6 4d e3	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  0049a	51		 push	 ecx
  0049b	e8 00 00 00 00	 call	 ?ProtocolCore@@YAXEPAEHHHH@Z ; ProtocolCore
  004a0	83 c4 18	 add	 esp, 24			; 00000018H

; 688  : 					/*
; 689  : 					}
; 690  : 					else
; 691  : 					{
; 692  : 						lphead = (LPPBMSG_HEAD)(byDec);
; 693  : 						headcode		= lphead->headcode;
; 694  : 
; 695  : 						// Serial Check
; 696  : 						//ProtocolCore(headcode, byDec+1, iSize, uIndex, 1, byDec[0]);
; 697  : 						ProtocolCore(headcode, byDec, iSize, uIndex, 1, byDec[0]);
; 698  : 					}
; 699  : 					*/
; 700  : 				}

  004a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004aa	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _spe$29[ebp]
  004b0	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
$LN17@RecvDataPa:

; 701  : 			}

  004b5	e9 6e 05 00 00	 jmp	 $LN15@RecvDataPa
$LN14@RecvDataPa:

; 702  : 			else if( xcode == 0xC4 )

  004ba	0f b6 45 e2	 movzx	 eax, BYTE PTR _xcode$[ebp]
  004be	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  004c3	0f 85 27 03 00
	00		 jne	 $LN23@RecvDataPa

; 703  : 			{
; 704  : 				int iSize = g_SimpleModulusCS.Decrypt( byDec+3, (recvbuf+lOfs+3), size-3);

  004c9	8b 45 e4	 mov	 eax, DWORD PTR _size$[ebp]
  004cc	83 e8 03	 sub	 eax, 3
  004cf	50		 push	 eax
  004d0	8b 4d e8	 mov	 ecx, DWORD PTR _lOfs$[ebp]
  004d3	8b 55 ec	 mov	 edx, DWORD PTR _recvbuf$[ebp]
  004d6	8d 44 0a 03	 lea	 eax, DWORD PTR [edx+ecx+3]
  004da	50		 push	 eax
  004db	8b 4d dc	 mov	 ecx, DWORD PTR _byDec$[ebp]
  004de	83 c1 03	 add	 ecx, 3
  004e1	51		 push	 ecx
  004e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusCS@@3VCSimpleModulus@@A ; g_SimpleModulusCS
  004e7	e8 00 00 00 00	 call	 ?Decrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Decrypt
  004ec	89 85 bc f7 ff
	ff		 mov	 DWORD PTR _iSize$28[ebp], eax

; 705  : 				if ( iSize < 0)

  004f2	83 bd bc f7 ff
	ff 00		 cmp	 DWORD PTR _iSize$28[ebp], 0
  004f9	7d 05		 jge	 SHORT $LN25@RecvDataPa

; 706  : 				{
; 707  : 				}

  004fb	e9 eb 02 00 00	 jmp	 $LN26@RecvDataPa
$LN25@RecvDataPa:

; 708  : 				else 
; 709  : 				{
; 710  : 					LPPBMSG_HEAD lphead;			
; 711  : 					
; 712  : 					/*
; 713  : 					if( gLanguage == 3 )
; 714  : 					{	// 중국의 경우 패킷 암호화 한번 더 있음							
; 715  : 					*/
; 716  : 						lphead = (LPPBMSG_HEAD)(byDec+1);

  00500	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00503	83 c0 01	 add	 eax, 1
  00506	89 85 b8 f7 ff
	ff		 mov	 DWORD PTR _lphead$27[ebp], eax

; 717  : 
; 718  : 						BYTE bSerial = byDec[3];

  0050c	b8 01 00 00 00	 mov	 eax, 1
  00511	6b c8 03	 imul	 ecx, eax, 3
  00514	8b 55 dc	 mov	 edx, DWORD PTR _byDec$[ebp]
  00517	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  0051a	88 85 b7 f7 ff
	ff		 mov	 BYTE PTR _bSerial$26[ebp], al

; 719  : 						/*
; 720  : 						
; 721  : 
; 722  : 						byDec[1] = 0XC1;
; 723  : 						byDec[2] = (BYTE)iSize+2;
; 724  : 
; 725  : 						 */
; 726  : 						/*byDec[0] = 0XC2;
; 727  : 						WORD wSize = ( WORD)iSize+3;
; 728  : 						byDec[1] = LOBYTE( wSize);
; 729  : 						byDec[2] = HIBYTE( wSize);
; 730  : 						*/
; 731  : 						byDec[1] = 0XC2;

  00520	b8 01 00 00 00	 mov	 eax, 1
  00525	c1 e0 00	 shl	 eax, 0
  00528	8b 4d dc	 mov	 ecx, DWORD PTR _byDec$[ebp]
  0052b	c6 04 01 c2	 mov	 BYTE PTR [ecx+eax], 194	; 000000c2H

; 732  : 						WORD wSize = ( WORD)iSize+3;

  0052f	0f b7 85 bc f7
	ff ff		 movzx	 eax, WORD PTR _iSize$28[ebp]
  00536	83 c0 03	 add	 eax, 3
  00539	66 89 85 b0 f7
	ff ff		 mov	 WORD PTR _wSize$25[ebp], ax

; 733  : 						byDec[2] = HIBYTE( wSize);

  00540	0f b7 85 b0 f7
	ff ff		 movzx	 eax, WORD PTR _wSize$25[ebp]
  00547	c1 e8 08	 shr	 eax, 8
  0054a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0054f	b9 01 00 00 00	 mov	 ecx, 1
  00554	d1 e1		 shl	 ecx, 1
  00556	8b 55 dc	 mov	 edx, DWORD PTR _byDec$[ebp]
  00559	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 734  : 						byDec[3] = LOBYTE( wSize);

  0055c	0f b7 85 b0 f7
	ff ff		 movzx	 eax, WORD PTR _wSize$25[ebp]
  00563	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00568	b9 01 00 00 00	 mov	 ecx, 1
  0056d	6b d1 03	 imul	 edx, ecx, 3
  00570	8b 4d dc	 mov	 ecx, DWORD PTR _byDec$[ebp]
  00573	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 735  : 
; 736  : 						
; 737  : 						CStreamPacketEngine_Server spe;

  00576	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR _spe$24[ebp]
  0057c	e8 00 00 00 00	 call	 ??0CStreamPacketEngine_Server@@QAE@XZ ; CStreamPacketEngine_Server::CStreamPacketEngine_Server
  00581	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 738  : 						spe.Clear();

  00588	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR _spe$24[ebp]
  0058e	e8 00 00 00 00	 call	 ?Clear@CStreamPacketEngine_Server@@QAEXXZ ; CStreamPacketEngine_Server::Clear

; 739  : 
; 740  : 						if( !spe.AddData(byDec+1, iSize+3) )

  00593	8b 85 bc f7 ff
	ff		 mov	 eax, DWORD PTR _iSize$28[ebp]
  00599	83 c0 03	 add	 eax, 3
  0059c	50		 push	 eax
  0059d	8b 4d dc	 mov	 ecx, DWORD PTR _byDec$[ebp]
  005a0	83 c1 01	 add	 ecx, 1
  005a3	51		 push	 ecx
  005a4	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR _spe$24[ebp]
  005aa	e8 00 00 00 00	 call	 ?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z ; CStreamPacketEngine_Server::AddData
  005af	85 c0		 test	 eax, eax
  005b1	0f 85 a9 00 00
	00		 jne	 $LN27@RecvDataPa

; 741  : 						{
; 742  : 							LogAddC(LOGC_RED,"error-L1 : CStreamPacketEngine Adding Error : "

  005b7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  005be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c4	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  005c8	52		 push	 edx
  005c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA
  005ce	05 d4 00 00 00	 add	 eax, 212		; 000000d4H
  005d3	50		 push	 eax
  005d4	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  005d9	0f b6 4d e3	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  005dd	51		 push	 ecx
  005de	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  005e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ea	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  005ee	51		 push	 ecx
  005ef	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  005f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005fb	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  005ff	51		 push	 ecx
  00600	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00607	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0060c	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  00610	51		 push	 ecx
  00611	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5@
  00616	6a 02		 push	 2
  00618	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0061e	83 c4 24	 add	 esp, 36			; 00000024H

; 743  : 											 "ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 744  : 									gObj[uIndex].Ip_addr,
; 745  : 									gObj[uIndex].AccountID, 
; 746  : 									gObj[uIndex].Name, 
; 747  : 									headcode, 
; 748  : 									__FILE__, __LINE__, 
; 749  : 									gObj[uIndex].Connected);
; 750  : 							delete[] byDec;

  00621	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00624	89 85 78 e5 ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
  0062a	8b 8d 78 e5 ff
	ff		 mov	 ecx, DWORD PTR $T13[ebp]
  00630	51		 push	 ecx
  00631	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00636	83 c4 04	 add	 esp, 4

; 751  : 							return FALSE;

  00639	c7 85 74 e5 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp], 0
  00643	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0064a	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR _spe$24[ebp]
  00650	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  00655	8b 85 74 e5 ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  0065b	e9 97 04 00 00	 jmp	 $LN1@RecvDataPa
$LN27@RecvDataPa:

; 752  : 						}
; 753  : 
; 754  : 						if( spe.ExtractPacket(byDec) )

  00660	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00663	50		 push	 eax
  00664	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR _spe$24[ebp]
  0066a	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  0066f	85 c0		 test	 eax, eax
  00671	0f 84 a9 00 00
	00		 je	 $LN28@RecvDataPa

; 755  : 						{
; 756  : 							LogAddC(LOGC_RED,"error-L1 : CStreamPacketEngine ExtractPacket Error : "

  00677	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  0067e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00684	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00688	52		 push	 edx
  00689	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA
  0068e	05 e2 00 00 00	 add	 eax, 226		; 000000e2H
  00693	50		 push	 eax
  00694	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00699	0f b6 4d e3	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  0069d	51		 push	 ecx
  0069e	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  006a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006aa	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  006ae	51		 push	 ecx
  006af	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  006b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006bb	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  006bf	51		 push	 ecx
  006c0	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  006c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006cc	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  006d0	51		 push	 ecx
  006d1	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5@
  006d6	6a 02		 push	 2
  006d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  006de	83 c4 24	 add	 esp, 36			; 00000024H

; 757  : 											 "ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 758  : 									gObj[uIndex].Ip_addr,
; 759  : 									gObj[uIndex].AccountID, 
; 760  : 									gObj[uIndex].Name, 
; 761  : 									headcode, 
; 762  : 									__FILE__, __LINE__, 
; 763  : 									gObj[uIndex].Connected);
; 764  : 							delete[] byDec;

  006e1	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  006e4	89 85 70 e5 ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
  006ea	8b 8d 70 e5 ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  006f0	51		 push	 ecx
  006f1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  006f6	83 c4 04	 add	 esp, 4

; 765  : 							return FALSE;

  006f9	c7 85 6c e5 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp], 0
  00703	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0070a	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR _spe$24[ebp]
  00710	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  00715	8b 85 6c e5 ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  0071b	e9 d7 03 00 00	 jmp	 $LN1@RecvDataPa
$LN28@RecvDataPa:

; 766  : 						}
; 767  : 
; 768  : 						headcode		= lphead->headcode;

  00720	8b 85 b8 f7 ff
	ff		 mov	 eax, DWORD PTR _lphead$27[ebp]
  00726	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00729	88 4d e3	 mov	 BYTE PTR _headcode$[ebp], cl

; 769  : 
; 770  : #ifdef TESTSERVER
; 771  : 		if( xcode == 0xC4 )

  0072c	0f b6 45 e2	 movzx	 eax, BYTE PTR _xcode$[ebp]
  00730	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  00735	75 1e		 jne	 SHORT $LN29@RecvDataPa

; 772  : 		{
; 773  : 			if( headcode == 0xC5)

  00737	0f b6 45 e3	 movzx	 eax, BYTE PTR _headcode$[ebp]
  0073b	3d c5 00 00 00	 cmp	 eax, 197		; 000000c5H
  00740	75 13		 jne	 SHORT $LN29@RecvDataPa

; 774  : 			{
; 775  : 				LogAdd("암호패킷 : [0x%x]", headcode);

  00742	0f b6 45 e3	 movzx	 eax, BYTE PTR _headcode$[ebp]
  00746	50		 push	 eax
  00747	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GEFELIJM@?$LO?O?H?$KD?F?P?E?$LG?5?3?5?$FL0x?$CFx?$FN@
  0074c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00752	83 c4 08	 add	 esp, 8
$LN29@RecvDataPa:

; 776  : 			}
; 777  : 		}
; 778  : #endif
; 779  : 
; 780  : #ifdef HACKTOOL_KUZIMO
; 781  : 		if (IsHackTool(headcode, size, uIndex, xcode) == TRUE)

  00755	0f b6 45 e2	 movzx	 eax, BYTE PTR _xcode$[ebp]
  00759	50		 push	 eax
  0075a	8b 4d 0c	 mov	 ecx, DWORD PTR _uIndex$[ebp]
  0075d	51		 push	 ecx
  0075e	8b 55 e4	 mov	 edx, DWORD PTR _size$[ebp]
  00761	52		 push	 edx
  00762	0f b6 45 e3	 movzx	 eax, BYTE PTR _headcode$[ebp]
  00766	50		 push	 eax
  00767	e8 00 00 00 00	 call	 ?IsHackTool@@YAHEHHE@Z	; IsHackTool
  0076c	83 c4 10	 add	 esp, 16			; 00000010H
  0076f	83 f8 01	 cmp	 eax, 1
  00772	75 3f		 jne	 SHORT $LN31@RecvDataPa

; 782  : 		{
; 783  : 			delete[] byDec;

  00774	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00777	89 85 68 e5 ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  0077d	8b 8d 68 e5 ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  00783	51		 push	 ecx
  00784	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00789	83 c4 04	 add	 esp, 4

; 784  : 			return FALSE;

  0078c	c7 85 64 e5 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp], 0
  00796	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0079d	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR _spe$24[ebp]
  007a3	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  007a8	8b 85 64 e5 ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  007ae	e9 44 03 00 00	 jmp	 $LN1@RecvDataPa
$LN31@RecvDataPa:

; 785  : 		}
; 786  : #endif // HACKTOOL_KUZIMO
; 787  : 
; 788  : 						// Serial Check
; 789  : 						ProtocolCore(headcode, byDec, iSize, uIndex, 1, bSerial);						

  007b3	0f b6 85 b7 f7
	ff ff		 movzx	 eax, BYTE PTR _bSerial$26[ebp]
  007ba	50		 push	 eax
  007bb	6a 01		 push	 1
  007bd	8b 4d 0c	 mov	 ecx, DWORD PTR _uIndex$[ebp]
  007c0	51		 push	 ecx
  007c1	8b 95 bc f7 ff
	ff		 mov	 edx, DWORD PTR _iSize$28[ebp]
  007c7	52		 push	 edx
  007c8	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  007cb	50		 push	 eax
  007cc	0f b6 4d e3	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  007d0	51		 push	 ecx
  007d1	e8 00 00 00 00	 call	 ?ProtocolCore@@YAXEPAEHHHH@Z ; ProtocolCore
  007d6	83 c4 18	 add	 esp, 24			; 00000018H

; 790  : 					/*
; 791  : 					}
; 792  : 					else
; 793  : 					{
; 794  : 						lphead = (LPPBMSG_HEAD)(byDec);
; 795  : 						headcode		= lphead->headcode;
; 796  : 
; 797  : 						// Serial Check
; 798  : 						//ProtocolCore(headcode, byDec+1, iSize, uIndex, 1, byDec[0]);
; 799  : 						ProtocolCore(headcode, byDec, iSize, uIndex, 1, byDec[0]);
; 800  : 					}
; 801  : 					*/
; 802  : 				}

  007d9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  007e0	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR _spe$24[ebp]
  007e6	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
$LN26@RecvDataPa:

; 803  : 			}

  007eb	e9 38 02 00 00	 jmp	 $LN15@RecvDataPa
$LN23@RecvDataPa:

; 804  : 			else 
; 805  : 			{	
; 806  : 				/*
; 807  : 				if( gLanguage == 3 )
; 808  : 				{	// 중국의 경우 패킷 암호화 한번 더 있음				
; 809  : 				*/
; 810  : 				if(headcode != 0x5E)

  007f0	0f b6 45 e3	 movzx	 eax, BYTE PTR _headcode$[ebp]
  007f4	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  007f7	0f 84 b9 01 00
	00		 je	 $LN32@RecvDataPa

; 811  : 				{
; 812  : 					CStreamPacketEngine_Server spe;

  007fd	8d 8d a0 e7 ff
	ff		 lea	 ecx, DWORD PTR _spe$23[ebp]
  00803	e8 00 00 00 00	 call	 ??0CStreamPacketEngine_Server@@QAE@XZ ; CStreamPacketEngine_Server::CStreamPacketEngine_Server
  00808	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 813  : 					spe.Clear();

  0080f	8d 8d a0 e7 ff
	ff		 lea	 ecx, DWORD PTR _spe$23[ebp]
  00815	e8 00 00 00 00	 call	 ?Clear@CStreamPacketEngine_Server@@QAEXXZ ; CStreamPacketEngine_Server::Clear

; 814  : 					if( !spe.AddData(recvbuf+lOfs, size) )

  0081a	0f b7 45 e4	 movzx	 eax, WORD PTR _size$[ebp]
  0081e	50		 push	 eax
  0081f	8b 4d ec	 mov	 ecx, DWORD PTR _recvbuf$[ebp]
  00822	03 4d e8	 add	 ecx, DWORD PTR _lOfs$[ebp]
  00825	51		 push	 ecx
  00826	8d 8d a0 e7 ff
	ff		 lea	 ecx, DWORD PTR _spe$23[ebp]
  0082c	e8 00 00 00 00	 call	 ?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z ; CStreamPacketEngine_Server::AddData
  00831	85 c0		 test	 eax, eax
  00833	0f 85 a9 00 00
	00		 jne	 $LN34@RecvDataPa

; 815  : 					{
; 816  : 						LogAddC(LOGC_RED,"error-L1 : CStreamPacketEngine Adding Error : "

  00839	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  00840	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00846	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  0084a	52		 push	 edx
  0084b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA
  00850	05 1e 01 00 00	 add	 eax, 286		; 0000011eH
  00855	50		 push	 eax
  00856	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0085b	0f b6 4d e3	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  0085f	51		 push	 ecx
  00860	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00867	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0086c	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00870	51		 push	 ecx
  00871	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00878	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0087d	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00881	51		 push	 ecx
  00882	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00889	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0088e	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  00892	51		 push	 ecx
  00893	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@CEPNFMLO@error?9L1?5?3?5CStreamPacketEngine?5@
  00898	6a 02		 push	 2
  0089a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  008a0	83 c4 24	 add	 esp, 36			; 00000024H

; 817  : 										 "ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 818  : 								gObj[uIndex].Ip_addr,
; 819  : 								gObj[uIndex].AccountID, 
; 820  : 								gObj[uIndex].Name, 
; 821  : 								headcode, 
; 822  : 								__FILE__, __LINE__, 
; 823  : 								gObj[uIndex].Connected);
; 824  : 						delete[] byDec;

  008a3	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  008a6	89 85 60 e5 ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  008ac	8b 8d 60 e5 ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  008b2	51		 push	 ecx
  008b3	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  008b8	83 c4 04	 add	 esp, 4

; 825  : 						return FALSE;

  008bb	c7 85 5c e5 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], 0
  008c5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  008cc	8d 8d a0 e7 ff
	ff		 lea	 ecx, DWORD PTR _spe$23[ebp]
  008d2	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  008d7	8b 85 5c e5 ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  008dd	e9 15 02 00 00	 jmp	 $LN1@RecvDataPa
$LN34@RecvDataPa:

; 826  : 					}
; 827  : 
; 828  : 					if( spe.ExtractPacket(byDec) )

  008e2	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  008e5	50		 push	 eax
  008e6	8d 8d a0 e7 ff
	ff		 lea	 ecx, DWORD PTR _spe$23[ebp]
  008ec	e8 00 00 00 00	 call	 ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ; CStreamPacketEngine_Server::ExtractPacket
  008f1	85 c0		 test	 eax, eax
  008f3	0f 84 a9 00 00
	00		 je	 $LN35@RecvDataPa

; 829  : 					{
; 830  : 						LogAddC(LOGC_RED,"error-L1 : CStreamPacketEngine ExtractPacket Error : "

  008f9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _uIndex$[ebp], 7072
  00900	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00906	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  0090a	52		 push	 edx
  0090b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA
  00910	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00915	50		 push	 eax
  00916	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0091b	0f b6 4d e3	 movzx	 ecx, BYTE PTR _headcode$[ebp]
  0091f	51		 push	 ecx
  00920	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00927	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0092c	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00930	51		 push	 ecx
  00931	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00938	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0093d	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00941	51		 push	 ecx
  00942	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _uIndex$[ebp], 7072
  00949	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0094e	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  00952	51		 push	 ecx
  00953	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@IFEOENIG@error?9L1?5?3?5CStreamPacketEngine?5@
  00958	6a 02		 push	 2
  0095a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00960	83 c4 24	 add	 esp, 36			; 00000024H

; 831  :                                          "ip = %s account:%s name:%s HEAD:%x (%s,%d) State:%d", 
; 832  : 								gObj[uIndex].Ip_addr,
; 833  : 								gObj[uIndex].AccountID, 
; 834  : 								gObj[uIndex].Name, 
; 835  : 								headcode, 
; 836  : 								__FILE__, __LINE__, 
; 837  : 								gObj[uIndex].Connected);
; 838  : 						delete[] byDec;

  00963	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00966	89 85 58 e5 ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  0096c	8b 8d 58 e5 ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00972	51		 push	 ecx
  00973	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00978	83 c4 04	 add	 esp, 4

; 839  : 						return FALSE;

  0097b	c7 85 54 e5 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00985	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0098c	8d 8d a0 e7 ff
	ff		 lea	 ecx, DWORD PTR _spe$23[ebp]
  00992	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  00997	8b 85 54 e5 ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  0099d	e9 55 01 00 00	 jmp	 $LN1@RecvDataPa
$LN35@RecvDataPa:

; 840  : 					}
; 841  : 				}

  009a2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  009a9	8d 8d a0 e7 ff
	ff		 lea	 ecx, DWORD PTR _spe$23[ebp]
  009af	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  009b4	eb 17		 jmp	 SHORT $LN33@RecvDataPa
$LN32@RecvDataPa:

; 842  : 				else
; 843  : 				{
; 844  : 					memcpy(byDec,recvbuf+lOfs,size);

  009b6	8b 45 e4	 mov	 eax, DWORD PTR _size$[ebp]
  009b9	50		 push	 eax
  009ba	8b 4d ec	 mov	 ecx, DWORD PTR _recvbuf$[ebp]
  009bd	03 4d e8	 add	 ecx, DWORD PTR _lOfs$[ebp]
  009c0	51		 push	 ecx
  009c1	8b 55 dc	 mov	 edx, DWORD PTR _byDec$[ebp]
  009c4	52		 push	 edx
  009c5	e8 00 00 00 00	 call	 _memcpy
  009ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@RecvDataPa:

; 845  : 				}
; 846  : 					//spe.AddData(recvbuf+lOfs, size);
; 847  : 					//spe.ExtractPacket(byDec);
; 848  : 
; 849  : #ifdef HACKTOOL_KUZIMO
; 850  : 					if (IsHackTool(headcode, size, uIndex, xcode) == TRUE)

  009cd	0f b6 45 e2	 movzx	 eax, BYTE PTR _xcode$[ebp]
  009d1	50		 push	 eax
  009d2	8b 4d 0c	 mov	 ecx, DWORD PTR _uIndex$[ebp]
  009d5	51		 push	 ecx
  009d6	8b 55 e4	 mov	 edx, DWORD PTR _size$[ebp]
  009d9	52		 push	 edx
  009da	0f b6 45 e3	 movzx	 eax, BYTE PTR _headcode$[ebp]
  009de	50		 push	 eax
  009df	e8 00 00 00 00	 call	 ?IsHackTool@@YAHEHHE@Z	; IsHackTool
  009e4	83 c4 10	 add	 esp, 16			; 00000010H
  009e7	83 f8 01	 cmp	 eax, 1
  009ea	75 1f		 jne	 SHORT $LN36@RecvDataPa

; 851  : 					{
; 852  : 						delete[] byDec;

  009ec	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  009ef	89 85 50 e5 ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  009f5	8b 8d 50 e5 ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  009fb	51		 push	 ecx
  009fc	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00a01	83 c4 04	 add	 esp, 4

; 853  : 						return FALSE;

  00a04	33 c0		 xor	 eax, eax
  00a06	e9 ec 00 00 00	 jmp	 $LN1@RecvDataPa
$LN36@RecvDataPa:

; 854  : 					}
; 855  : #endif // HACKTOOL_KUZIMO
; 856  : 					ProtocolCore(headcode, byDec, size, uIndex);

  00a0b	6a ff		 push	 -1
  00a0d	6a 00		 push	 0
  00a0f	8b 45 0c	 mov	 eax, DWORD PTR _uIndex$[ebp]
  00a12	50		 push	 eax
  00a13	8b 4d e4	 mov	 ecx, DWORD PTR _size$[ebp]
  00a16	51		 push	 ecx
  00a17	8b 55 dc	 mov	 edx, DWORD PTR _byDec$[ebp]
  00a1a	52		 push	 edx
  00a1b	0f b6 45 e3	 movzx	 eax, BYTE PTR _headcode$[ebp]
  00a1f	50		 push	 eax
  00a20	e8 00 00 00 00	 call	 ?ProtocolCore@@YAXEPAEHHHH@Z ; ProtocolCore
  00a25	83 c4 18	 add	 esp, 24			; 00000018H
$LN15@RecvDataPa:

; 857  : 				/*
; 858  : 				}
; 859  : 				else
; 860  : 				{
; 861  : 					ProtocolCore(headcode, (recvbuf+lOfs), size, uIndex);
; 862  : 				}
; 863  : 				*/
; 864  : 			}
; 865  : 			lOfs += size;

  00a28	8b 45 e8	 mov	 eax, DWORD PTR _lOfs$[ebp]
  00a2b	03 45 e4	 add	 eax, DWORD PTR _size$[ebp]
  00a2e	89 45 e8	 mov	 DWORD PTR _lOfs$[ebp], eax

; 866  : 			lpIOContext->nSentBytes -= size;			

  00a31	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00a34	8b 88 24 00 01
	00		 mov	 ecx, DWORD PTR [eax+65572]
  00a3a	2b 4d e4	 sub	 ecx, DWORD PTR _size$[ebp]
  00a3d	8b 55 08	 mov	 edx, DWORD PTR _lpIOContext$[ebp]
  00a40	89 8a 24 00 01
	00		 mov	 DWORD PTR [edx+65572], ecx

; 867  : 			if( lpIOContext->nSentBytes <= 0 ) break;

  00a46	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00a49	83 b8 24 00 01
	00 00		 cmp	 DWORD PTR [eax+65572], 0
  00a50	7f 05		 jg	 SHORT $LN37@RecvDataPa
  00a52	e9 83 00 00 00	 jmp	 $LN3@RecvDataPa
$LN37@RecvDataPa:

; 868  : 		}			

  00a57	eb 7c		 jmp	 SHORT $LN13@RecvDataPa
$LN12@RecvDataPa:

; 869  : 		else 
; 870  : 		{	// recv 데이터가 아직 완성되지 않았다면..
; 871  : 			if( lOfs > 0 )  // 하나이상 데이터를 보낸 후라면..

  00a59	83 7d e8 00	 cmp	 DWORD PTR _lOfs$[ebp], 0
  00a5d	7e 74		 jle	 SHORT $LN38@RecvDataPa

; 872  : 			{
; 873  : 				if( lpIOContext->nSentBytes < 1 ) 

  00a5f	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00a62	83 b8 24 00 01
	00 01		 cmp	 DWORD PTR [eax+65572], 1
  00a69	7d 22		 jge	 SHORT $LN39@RecvDataPa

; 874  : 				{
; 875  : 					LogAdd("error-L1 : recvbuflen 1 %s %d", __FILE__, __LINE__);

  00a6b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z@4JA
  00a70	05 53 01 00 00	 add	 eax, 339		; 00000153H
  00a75	50		 push	 eax
  00a76	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00a7b	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OCHJCCMB@error?9L1?5?3?5recvbuflen?51?5?$CFs?5?$CFd@
  00a80	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00a86	83 c4 0c	 add	 esp, 12			; 0000000cH

; 876  : 					break;

  00a89	eb 4f		 jmp	 SHORT $LN3@RecvDataPa

; 877  : 				}

  00a8b	eb 46		 jmp	 SHORT $LN38@RecvDataPa
$LN39@RecvDataPa:

; 878  : 				else 
; 879  : 				{
; 880  : 					if( lpIOContext->nSentBytes < MAX_BUFF_SIZE )

  00a8d	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00a90	81 b8 24 00 01
	00 00 40 00 00	 cmp	 DWORD PTR [eax+65572], 16384 ; 00004000H
  00a9a	7d 35		 jge	 SHORT $LN41@RecvDataPa

; 881  : 					{
; 882  : 						memcpy(recvbuf, (recvbuf+lOfs), lpIOContext->nSentBytes); // 남은만큼 복사한다.

  00a9c	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00a9f	8b 88 24 00 01
	00		 mov	 ecx, DWORD PTR [eax+65572]
  00aa5	51		 push	 ecx
  00aa6	8b 55 ec	 mov	 edx, DWORD PTR _recvbuf$[ebp]
  00aa9	03 55 e8	 add	 edx, DWORD PTR _lOfs$[ebp]
  00aac	52		 push	 edx
  00aad	8b 45 ec	 mov	 eax, DWORD PTR _recvbuf$[ebp]
  00ab0	50		 push	 eax
  00ab1	e8 00 00 00 00	 call	 _memcpy
  00ab6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 883  : 						LogAdd("Message copy %d",lpIOContext->nSentBytes);

  00ab9	8b 45 08	 mov	 eax, DWORD PTR _lpIOContext$[ebp]
  00abc	8b 88 24 00 01
	00		 mov	 ecx, DWORD PTR [eax+65572]
  00ac2	51		 push	 ecx
  00ac3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OIIBACED@Message?5copy?5?$CFd@
  00ac8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00ace	83 c4 08	 add	 esp, 8
$LN41@RecvDataPa:

; 884  : 					}
; 885  : 					break;

  00ad1	eb 07		 jmp	 SHORT $LN3@RecvDataPa
$LN38@RecvDataPa:

; 886  : 				}
; 887  : 			}
; 888  : 			break;

  00ad3	eb 05		 jmp	 SHORT $LN3@RecvDataPa
$LN13@RecvDataPa:

; 889  : 		}
; 890  : 	}

  00ad5	e9 a5 f5 ff ff	 jmp	 $LN2@RecvDataPa
$LN3@RecvDataPa:

; 891  : 	delete[] byDec;

  00ada	8b 45 dc	 mov	 eax, DWORD PTR _byDec$[ebp]
  00add	89 85 4c e5 ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00ae3	8b 8d 4c e5 ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00ae9	51		 push	 ecx
  00aea	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00aef	83 c4 04	 add	 esp, 4

; 892  : 	return TRUE;

  00af2	b8 01 00 00 00	 mov	 eax, 1
$LN1@RecvDataPa:

; 893  : }

  00af7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00afa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00b01	59		 pop	 ecx
  00b02	5f		 pop	 edi
  00b03	5e		 pop	 esi
  00b04	5b		 pop	 ebx
  00b05	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b08	33 cd		 xor	 ecx, ebp
  00b0a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b0f	8b e5		 mov	 esp, ebp
  00b11	5d		 pop	 ebp
  00b12	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$0:
  00000	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _spe$29[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$1:
  0000b	8d 8d a8 ef ff
	ff		 lea	 ecx, DWORD PTR _spe$24[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
__unwindfunclet$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z$2:
  00016	8d 8d a0 e7 ff
	ff		 lea	 ecx, DWORD PTR _spe$23[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a 48 e5 ff
	ff		 mov	 ecx, DWORD PTR [edx-6840]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003f	33 c8		 xor	 ecx, eax
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z
  0004b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RecvDataParse@@YAHPAU_PER_IO_CONTEXT@@H@Z ENDP		; RecvDataParse
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCStreamPacketEngine_Server@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCStreamPacketEngine_Server@@UAEPAXI@Z PROC		; CStreamPacketEngine_Server::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CStreamPacketEngine_Server@@UAE@XZ ; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 08 08 00 00	 push	 2056			; 00000808H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GCStreamPacketEngine_Server@@UAEPAXI@Z ENDP		; CStreamPacketEngine_Server::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\spe.h
;	COMDAT ?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z
_TEXT	SEGMENT
tv195 = -2416						; size = 4
tv68 = -2416						; size = 4
_byTemp$ = -2092					; size = 2048
_byXorFilter$ = -44					; size = 32
_wSize$ = -12						; size = 2
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pTar$ = 8						; size = 4
?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z PROC ; CStreamPacketEngine_Server::ExtractPacket, COMDAT
; _this$ = ecx

; 74   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 09 00
	00		 sub	 esp, 2416		; 00000970H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 		WORD wSize;
; 76   : 		switch ( m_byBuffer[0])

  00019	b8 01 00 00 00	 mov	 eax, 1
  0001e	6b c8 00	 imul	 ecx, eax, 0
  00021	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8a 44 0a 06	 mov	 al, BYTE PTR [edx+ecx+6]
  00028	88 85 90 f6 ff
	ff		 mov	 BYTE PTR tv68[ebp], al
  0002e	80 bd 90 f6 ff
	ff c1		 cmp	 BYTE PTR tv68[ebp], 193	; 000000c1H
  00035	74 0b		 je	 SHORT $LN4@ExtractPac
  00037	80 bd 90 f6 ff
	ff c2		 cmp	 BYTE PTR tv68[ebp], 194	; 000000c2H
  0003e	74 19		 je	 SHORT $LN5@ExtractPac
  00040	eb 41		 jmp	 SHORT $LN6@ExtractPac
$LN4@ExtractPac:

; 77   : 		{
; 78   : 		case 0xC1:
; 79   : 			wSize = ( WORD)m_byBuffer[1];

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	c1 e0 00	 shl	 eax, 0
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	66 0f b6 54 01
	06		 movzx	 dx, BYTE PTR [ecx+eax+6]
  00053	66 89 55 f4	 mov	 WORD PTR _wSize$[ebp], dx

; 80   : 			break;

  00057	eb 34		 jmp	 SHORT $LN2@ExtractPac
$LN5@ExtractPac:

; 81   : 		case 0xC2:
; 82   : 			wSize = ( ( WORD)m_byBuffer[1] << 8) + m_byBuffer[2];

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	c1 e0 00	 shl	 eax, 0
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	0f b6 54 01 06	 movzx	 edx, BYTE PTR [ecx+eax+6]
  00069	c1 e2 08	 shl	 edx, 8
  0006c	b8 01 00 00 00	 mov	 eax, 1
  00071	d1 e0		 shl	 eax, 1
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	0f b6 44 01 06	 movzx	 eax, BYTE PTR [ecx+eax+6]
  0007b	03 d0		 add	 edx, eax
  0007d	66 89 55 f4	 mov	 WORD PTR _wSize$[ebp], dx

; 83   : 			break;

  00081	eb 0a		 jmp	 SHORT $LN2@ExtractPac
$LN6@ExtractPac:

; 84   : 		default:
; 85   : 			return ( 1);	// invalid packet

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	e9 51 01 00 00	 jmp	 $LN1@ExtractPac
$LN2@ExtractPac:

; 86   : 		}
; 87   : 		if ( m_wSize < wSize)

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00090	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00094	0f b7 55 f4	 movzx	 edx, WORD PTR _wSize$[ebp]
  00098	3b ca		 cmp	 ecx, edx
  0009a	7d 0a		 jge	 SHORT $LN7@ExtractPac

; 88   : 		{
; 89   : 			return ( 2);	// not complete packet

  0009c	b8 02 00 00 00	 mov	 eax, 2
  000a1	e9 38 01 00 00	 jmp	 $LN1@ExtractPac
$LN7@ExtractPac:

; 90   : 		}
; 91   : 
; 92   : 		// extract
; 93   : 		BYTE byXorFilter[SIZE_SPE_XORFILTER] =
; 94   : 		{
; 95   : 			0xE7, 0x6D, 0x3A, 0x89, 0xBC, 0xB2, 0x9F, 0x73,

  000a6	c6 45 d4 e7	 mov	 BYTE PTR _byXorFilter$[ebp], 231 ; 000000e7H
  000aa	c6 45 d5 6d	 mov	 BYTE PTR _byXorFilter$[ebp+1], 109 ; 0000006dH
  000ae	c6 45 d6 3a	 mov	 BYTE PTR _byXorFilter$[ebp+2], 58 ; 0000003aH
  000b2	c6 45 d7 89	 mov	 BYTE PTR _byXorFilter$[ebp+3], 137 ; 00000089H
  000b6	c6 45 d8 bc	 mov	 BYTE PTR _byXorFilter$[ebp+4], 188 ; 000000bcH
  000ba	c6 45 d9 b2	 mov	 BYTE PTR _byXorFilter$[ebp+5], 178 ; 000000b2H
  000be	c6 45 da 9f	 mov	 BYTE PTR _byXorFilter$[ebp+6], 159 ; 0000009fH
  000c2	c6 45 db 73	 mov	 BYTE PTR _byXorFilter$[ebp+7], 115 ; 00000073H

; 96   : 			0x23, 0xA8, 0xFE, 0xB6, 0x49, 0x5D, 0x39, 0x5D,

  000c6	c6 45 dc 23	 mov	 BYTE PTR _byXorFilter$[ebp+8], 35 ; 00000023H
  000ca	c6 45 dd a8	 mov	 BYTE PTR _byXorFilter$[ebp+9], 168 ; 000000a8H
  000ce	c6 45 de fe	 mov	 BYTE PTR _byXorFilter$[ebp+10], 254 ; 000000feH
  000d2	c6 45 df b6	 mov	 BYTE PTR _byXorFilter$[ebp+11], 182 ; 000000b6H
  000d6	c6 45 e0 49	 mov	 BYTE PTR _byXorFilter$[ebp+12], 73 ; 00000049H
  000da	c6 45 e1 5d	 mov	 BYTE PTR _byXorFilter$[ebp+13], 93 ; 0000005dH
  000de	c6 45 e2 39	 mov	 BYTE PTR _byXorFilter$[ebp+14], 57 ; 00000039H
  000e2	c6 45 e3 5d	 mov	 BYTE PTR _byXorFilter$[ebp+15], 93 ; 0000005dH

; 97   : 			0x8A, 0xCB, 0x63, 0x8D, 0xEA, 0x7D, 0x2B, 0x5F,

  000e6	c6 45 e4 8a	 mov	 BYTE PTR _byXorFilter$[ebp+16], 138 ; 0000008aH
  000ea	c6 45 e5 cb	 mov	 BYTE PTR _byXorFilter$[ebp+17], 203 ; 000000cbH
  000ee	c6 45 e6 63	 mov	 BYTE PTR _byXorFilter$[ebp+18], 99 ; 00000063H
  000f2	c6 45 e7 8d	 mov	 BYTE PTR _byXorFilter$[ebp+19], 141 ; 0000008dH
  000f6	c6 45 e8 ea	 mov	 BYTE PTR _byXorFilter$[ebp+20], 234 ; 000000eaH
  000fa	c6 45 e9 7d	 mov	 BYTE PTR _byXorFilter$[ebp+21], 125 ; 0000007dH
  000fe	c6 45 ea 2b	 mov	 BYTE PTR _byXorFilter$[ebp+22], 43 ; 0000002bH
  00102	c6 45 eb 5f	 mov	 BYTE PTR _byXorFilter$[ebp+23], 95 ; 0000005fH

; 98   : 			0xC3, 0xB1, 0xE9, 0x83, 0x29, 0x51, 0xE8, 0x56

  00106	c6 45 ec c3	 mov	 BYTE PTR _byXorFilter$[ebp+24], 195 ; 000000c3H
  0010a	c6 45 ed b1	 mov	 BYTE PTR _byXorFilter$[ebp+25], 177 ; 000000b1H
  0010e	c6 45 ee e9	 mov	 BYTE PTR _byXorFilter$[ebp+26], 233 ; 000000e9H
  00112	c6 45 ef 83	 mov	 BYTE PTR _byXorFilter$[ebp+27], 131 ; 00000083H
  00116	c6 45 f0 29	 mov	 BYTE PTR _byXorFilter$[ebp+28], 41 ; 00000029H
  0011a	c6 45 f1 51	 mov	 BYTE PTR _byXorFilter$[ebp+29], 81 ; 00000051H
  0011e	c6 45 f2 e8	 mov	 BYTE PTR _byXorFilter$[ebp+30], 232 ; 000000e8H
  00122	c6 45 f3 56	 mov	 BYTE PTR _byXorFilter$[ebp+31], 86 ; 00000056H

; 99   : 		};
; 100  : 		XorData( ( int)wSize - 1, ( int)( ( m_byBuffer[0] == 0xC1) ? 3 : 4) - 1, -1);

  00126	b8 01 00 00 00	 mov	 eax, 1
  0012b	6b c8 00	 imul	 ecx, eax, 0
  0012e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00131	0f b6 44 0a 06	 movzx	 eax, BYTE PTR [edx+ecx+6]
  00136	3d c1 00 00 00	 cmp	 eax, 193		; 000000c1H
  0013b	75 0c		 jne	 SHORT $LN9@ExtractPac
  0013d	c7 85 90 f6 ff
	ff 03 00 00 00	 mov	 DWORD PTR tv195[ebp], 3
  00147	eb 0a		 jmp	 SHORT $LN10@ExtractPac
$LN9@ExtractPac:
  00149	c7 85 90 f6 ff
	ff 04 00 00 00	 mov	 DWORD PTR tv195[ebp], 4
$LN10@ExtractPac:
  00153	6a ff		 push	 -1
  00155	8b 8d 90 f6 ff
	ff		 mov	 ecx, DWORD PTR tv195[ebp]
  0015b	83 e9 01	 sub	 ecx, 1
  0015e	51		 push	 ecx
  0015f	0f b7 55 f4	 movzx	 edx, WORD PTR _wSize$[ebp]
  00163	83 ea 01	 sub	 edx, 1
  00166	52		 push	 edx
  00167	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	e8 00 00 00 00	 call	 ?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z ; CStreamPacketEngine_Server::XorData

; 101  : 		memcpy( pTar, m_byBuffer, wSize);

  0016f	0f b7 45 f4	 movzx	 eax, WORD PTR _wSize$[ebp]
  00173	50		 push	 eax
  00174	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00177	83 c1 06	 add	 ecx, 6
  0017a	51		 push	 ecx
  0017b	8b 55 08	 mov	 edx, DWORD PTR _pTar$[ebp]
  0017e	52		 push	 edx
  0017f	e8 00 00 00 00	 call	 _memcpy
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH

; 102  : 		// pull
; 103  : 		BYTE byTemp[MAX_SPE_BUFFERSIZE];
; 104  : 		m_wSize -= wSize;

  00187	0f b7 45 f4	 movzx	 eax, WORD PTR _wSize$[ebp]
  0018b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018e	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  00192	2b d0		 sub	 edx, eax
  00194	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00197	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 105  : 		memcpy( byTemp, &m_byBuffer[wSize], m_wSize);

  0019b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019e	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  001a2	51		 push	 ecx
  001a3	0f b7 55 f4	 movzx	 edx, WORD PTR _wSize$[ebp]
  001a7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001aa	8d 4c 10 06	 lea	 ecx, DWORD PTR [eax+edx+6]
  001ae	51		 push	 ecx
  001af	8d 95 d4 f7 ff
	ff		 lea	 edx, DWORD PTR _byTemp$[ebp]
  001b5	52		 push	 edx
  001b6	e8 00 00 00 00	 call	 _memcpy
  001bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 106  : 		memcpy( m_byBuffer, byTemp, m_wSize);

  001be	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001c1	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  001c5	51		 push	 ecx
  001c6	8d 95 d4 f7 ff
	ff		 lea	 edx, DWORD PTR _byTemp$[ebp]
  001cc	52		 push	 edx
  001cd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001d0	83 c0 06	 add	 eax, 6
  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 _memcpy
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 107  : 		return ( 0);	// success

  001dc	33 c0		 xor	 eax, eax
$LN1@ExtractPac:

; 108  : 	}

  001de	5f		 pop	 edi
  001df	5e		 pop	 esi
  001e0	5b		 pop	 ebx
  001e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e4	33 cd		 xor	 ecx, ebp
  001e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c2 04 00	 ret	 4
?ExtractPacket@CStreamPacketEngine_Server@@QAEHPAX@Z ENDP ; CStreamPacketEngine_Server::ExtractPacket
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\spe.h
;	COMDAT ?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z
_TEXT	SEGMENT
_isize$1 = -8						; size = 4
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
_wSize$ = 12						; size = 2
?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z PROC	; CStreamPacketEngine_Server::AddData, COMDAT
; _this$ = ecx

; 60   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 61   : 		//assert( m_wSize + wSize <= MAX_SPE_BUFFERSIZE);
; 62   : 		if( ((m_wSize + wSize) >= MAX_SPE_BUFFERSIZE) || wSize == 0 )

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00013	0f b7 55 0c	 movzx	 edx, WORD PTR _wSize$[ebp]
  00017	03 ca		 add	 ecx, edx
  00019	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  0001f	7d 08		 jge	 SHORT $LN3@AddData
  00021	0f b7 45 0c	 movzx	 eax, WORD PTR _wSize$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	75 29		 jne	 SHORT $LN2@AddData
$LN3@AddData:

; 63   : 		{
; 64   : 			LogAddC(LOGC_RED,"CStreamPacketEngine Adding Buffer Size Error %d", m_wSize + wSize); 

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00030	0f b7 55 0c	 movzx	 edx, WORD PTR _wSize$[ebp]
  00034	03 ca		 add	 ecx, edx
  00036	51		 push	 ecx
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IBFCCNK@CStreamPacketEngine?5Adding?5Buff@
  0003c	6a 02		 push	 2
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 65   : 
; 66   : 			int isize = MAX_SPE_BUFFERSIZE;

  00047	c7 45 f8 00 08
	00 00		 mov	 DWORD PTR _isize$1[ebp], 2048 ; 00000800H

; 67   : 			return FALSE;

  0004e	33 c0		 xor	 eax, eax
  00050	eb 39		 jmp	 SHORT $LN1@AddData
$LN2@AddData:

; 68   : 		}
; 69   : 		memcpy( &m_byBuffer[m_wSize], pSrc, wSize);

  00052	0f b7 45 0c	 movzx	 eax, WORD PTR _wSize$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8d 54 01 06	 lea	 edx, DWORD PTR [ecx+eax+6]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 _memcpy
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 70   : 		m_wSize += wSize;

  00072	0f b7 45 0c	 movzx	 eax, WORD PTR _wSize$[ebp]
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  0007d	03 d0		 add	 edx, eax
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00082	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 71   : 		return TRUE;

  00086	b8 01 00 00 00	 mov	 eax, 1
$LN1@AddData:

; 72   : 	}

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
?AddData@CStreamPacketEngine_Server@@QAEHPAXG@Z ENDP	; CStreamPacketEngine_Server::AddData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\spe.h
;	COMDAT ?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z
_TEXT	SEGMENT
_i$1 = -44						; size = 4
_byXorFilter$ = -40					; size = 32
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iStart$ = 8						; size = 4
_iEnd$ = 12						; size = 4
_iDir$ = 16						; size = 4
?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z PROC	; CStreamPacketEngine_Server::XorData, COMDAT
; _this$ = ecx

; 39   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 		if( iStart < iEnd )

  00016	8b 45 08	 mov	 eax, DWORD PTR _iStart$[ebp]
  00019	3b 45 0c	 cmp	 eax, DWORD PTR _iEnd$[ebp]
  0001c	7d 1d		 jge	 SHORT $LN5@XorData

; 41   : 		{
; 42   : 			LogAddC(LOGC_RED,"CStreamPacketEngine XorData Error %d,%d", iStart, iEnd); 

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _iEnd$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _iStart$[ebp]
  00025	51		 push	 ecx
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NNCHDFLE@CStreamPacketEngine?5XorData?5Err@
  0002b	6a 02		 push	 2
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00033	83 c4 10	 add	 esp, 16			; 00000010H

; 43   : 			return;

  00036	e9 d1 00 00 00	 jmp	 $LN1@XorData
$LN5@XorData:

; 44   : 		}
; 45   : 
; 46   : 		BYTE byXorFilter[SIZE_SPE_XORFILTER] =
; 47   : 		{
; 48   : 			0xE7, 0x6D, 0x3A, 0x89, 0xBC, 0xB2, 0x9F, 0x73,

  0003b	c6 45 d8 e7	 mov	 BYTE PTR _byXorFilter$[ebp], 231 ; 000000e7H
  0003f	c6 45 d9 6d	 mov	 BYTE PTR _byXorFilter$[ebp+1], 109 ; 0000006dH
  00043	c6 45 da 3a	 mov	 BYTE PTR _byXorFilter$[ebp+2], 58 ; 0000003aH
  00047	c6 45 db 89	 mov	 BYTE PTR _byXorFilter$[ebp+3], 137 ; 00000089H
  0004b	c6 45 dc bc	 mov	 BYTE PTR _byXorFilter$[ebp+4], 188 ; 000000bcH
  0004f	c6 45 dd b2	 mov	 BYTE PTR _byXorFilter$[ebp+5], 178 ; 000000b2H
  00053	c6 45 de 9f	 mov	 BYTE PTR _byXorFilter$[ebp+6], 159 ; 0000009fH
  00057	c6 45 df 73	 mov	 BYTE PTR _byXorFilter$[ebp+7], 115 ; 00000073H

; 49   : 			0x23, 0xA8, 0xFE, 0xB6, 0x49, 0x5D, 0x39, 0x5D,

  0005b	c6 45 e0 23	 mov	 BYTE PTR _byXorFilter$[ebp+8], 35 ; 00000023H
  0005f	c6 45 e1 a8	 mov	 BYTE PTR _byXorFilter$[ebp+9], 168 ; 000000a8H
  00063	c6 45 e2 fe	 mov	 BYTE PTR _byXorFilter$[ebp+10], 254 ; 000000feH
  00067	c6 45 e3 b6	 mov	 BYTE PTR _byXorFilter$[ebp+11], 182 ; 000000b6H
  0006b	c6 45 e4 49	 mov	 BYTE PTR _byXorFilter$[ebp+12], 73 ; 00000049H
  0006f	c6 45 e5 5d	 mov	 BYTE PTR _byXorFilter$[ebp+13], 93 ; 0000005dH
  00073	c6 45 e6 39	 mov	 BYTE PTR _byXorFilter$[ebp+14], 57 ; 00000039H
  00077	c6 45 e7 5d	 mov	 BYTE PTR _byXorFilter$[ebp+15], 93 ; 0000005dH

; 50   : 			0x8A, 0xCB, 0x63, 0x8D, 0xEA, 0x7D, 0x2B, 0x5F,

  0007b	c6 45 e8 8a	 mov	 BYTE PTR _byXorFilter$[ebp+16], 138 ; 0000008aH
  0007f	c6 45 e9 cb	 mov	 BYTE PTR _byXorFilter$[ebp+17], 203 ; 000000cbH
  00083	c6 45 ea 63	 mov	 BYTE PTR _byXorFilter$[ebp+18], 99 ; 00000063H
  00087	c6 45 eb 8d	 mov	 BYTE PTR _byXorFilter$[ebp+19], 141 ; 0000008dH
  0008b	c6 45 ec ea	 mov	 BYTE PTR _byXorFilter$[ebp+20], 234 ; 000000eaH
  0008f	c6 45 ed 7d	 mov	 BYTE PTR _byXorFilter$[ebp+21], 125 ; 0000007dH
  00093	c6 45 ee 2b	 mov	 BYTE PTR _byXorFilter$[ebp+22], 43 ; 0000002bH
  00097	c6 45 ef 5f	 mov	 BYTE PTR _byXorFilter$[ebp+23], 95 ; 0000005fH

; 51   : 			0xC3, 0xB1, 0xE9, 0x83, 0x29, 0x51, 0xE8, 0x56

  0009b	c6 45 f0 c3	 mov	 BYTE PTR _byXorFilter$[ebp+24], 195 ; 000000c3H
  0009f	c6 45 f1 b1	 mov	 BYTE PTR _byXorFilter$[ebp+25], 177 ; 000000b1H
  000a3	c6 45 f2 e9	 mov	 BYTE PTR _byXorFilter$[ebp+26], 233 ; 000000e9H
  000a7	c6 45 f3 83	 mov	 BYTE PTR _byXorFilter$[ebp+27], 131 ; 00000083H
  000ab	c6 45 f4 29	 mov	 BYTE PTR _byXorFilter$[ebp+28], 41 ; 00000029H
  000af	c6 45 f5 51	 mov	 BYTE PTR _byXorFilter$[ebp+29], 81 ; 00000051H
  000b3	c6 45 f6 e8	 mov	 BYTE PTR _byXorFilter$[ebp+30], 232 ; 000000e8H
  000b7	c6 45 f7 56	 mov	 BYTE PTR _byXorFilter$[ebp+31], 86 ; 00000056H

; 52   : 		};
; 53   : 		for ( int i = iStart; i != iEnd; i += iDir)

  000bb	8b 45 08	 mov	 eax, DWORD PTR _iStart$[ebp]
  000be	89 45 d4	 mov	 DWORD PTR _i$1[ebp], eax
  000c1	eb 09		 jmp	 SHORT $LN4@XorData
$LN2@XorData:
  000c3	8b 45 d4	 mov	 eax, DWORD PTR _i$1[ebp]
  000c6	03 45 10	 add	 eax, DWORD PTR _iDir$[ebp]
  000c9	89 45 d4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@XorData:
  000cc	8b 45 d4	 mov	 eax, DWORD PTR _i$1[ebp]
  000cf	3b 45 0c	 cmp	 eax, DWORD PTR _iEnd$[ebp]
  000d2	74 38		 je	 SHORT $LN1@XorData

; 54   : 		{
; 55   : 			m_byBuffer[i] ^= ( m_byBuffer[i - 1] ^ byXorFilter[i%SIZE_SPE_XORFILTER]);

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	03 45 d4	 add	 eax, DWORD PTR _i$1[ebp]
  000da	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000de	8b 55 d4	 mov	 edx, DWORD PTR _i$1[ebp]
  000e1	81 e2 1f 00 00
	80		 and	 edx, -2147483617	; 8000001fH
  000e7	79 05		 jns	 SHORT $LN7@XorData
  000e9	4a		 dec	 edx
  000ea	83 ca e0	 or	 edx, -32		; ffffffe0H
  000ed	42		 inc	 edx
$LN7@XorData:
  000ee	0f b6 44 15 d8	 movzx	 eax, BYTE PTR _byXorFilter$[ebp+edx]
  000f3	33 c8		 xor	 ecx, eax
  000f5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000f8	03 55 d4	 add	 edx, DWORD PTR _i$1[ebp]
  000fb	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  000ff	33 c1		 xor	 eax, ecx
  00101	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	03 4d d4	 add	 ecx, DWORD PTR _i$1[ebp]
  00107	88 41 06	 mov	 BYTE PTR [ecx+6], al

; 56   : 		}

  0010a	eb b7		 jmp	 SHORT $LN2@XorData
$LN1@XorData:

; 57   : 	}

  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00112	33 cd		 xor	 ecx, ebp
  00114	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 0c 00	 ret	 12			; 0000000cH
?XorData@CStreamPacketEngine_Server@@IAEXHHH@Z ENDP	; CStreamPacketEngine_Server::XorData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\spe.h
;	COMDAT ?Clear@CStreamPacketEngine_Server@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CStreamPacketEngine_Server@@QAEXXZ PROC		; CStreamPacketEngine_Server::Clear, COMDAT
; _this$ = ecx

; 29   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 30   : 		m_wSize = 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 31   : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?Clear@CStreamPacketEngine_Server@@QAEXXZ ENDP		; CStreamPacketEngine_Server::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\spe.h
;	COMDAT ??1CStreamPacketEngine_Server@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CStreamPacketEngine_Server@@UAE@XZ PROC		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server, COMDAT
; _this$ = ecx

; 27   : 	virtual ~CStreamPacketEngine_Server()	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CStreamPacketEngine_Server@@6B@
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CStreamPacketEngine_Server@@UAE@XZ ENDP		; CStreamPacketEngine_Server::~CStreamPacketEngine_Server
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\spe.h
;	COMDAT ??0CStreamPacketEngine_Server@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CStreamPacketEngine_Server@@QAE@XZ PROC		; CStreamPacketEngine_Server::CStreamPacketEngine_Server, COMDAT
; _this$ = ecx

; 23   : 	CStreamPacketEngine_Server()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CStreamPacketEngine_Server@@6B@

; 24   : 	{
; 25   : 		Clear();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?Clear@CStreamPacketEngine_Server@@QAEXXZ ; CStreamPacketEngine_Server::Clear

; 26   : 	}

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0CStreamPacketEngine_Server@@QAE@XZ ENDP		; CStreamPacketEngine_Server::CStreamPacketEngine_Server
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?DestroyGIocp@@YAXXZ
_TEXT	SEGMENT
_dwCPU$1 = -4						; size = 4
?DestroyGIocp@@YAXXZ PROC				; DestroyGIocp, COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 157  : 	LogAddTD("Error-L10");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_09HNKOADHB@Error?9L10@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00014	83 c4 04	 add	 esp, 4

; 158  : 	closesocket(g_Listen);

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_Listen@@3IA ; g_Listen
  0001c	50		 push	 eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 159  : 
; 160  : 	for(DWORD dwCPU = 0; dwCPU < g_dwThreadCount; dwCPU++)

  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwCPU$1[ebp], 0
  0002a	eb 09		 jmp	 SHORT $LN4@DestroyGIo
$LN2@DestroyGIo:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _dwCPU$1[ebp]
  0002f	83 c0 01	 add	 eax, 1
  00032	89 45 fc	 mov	 DWORD PTR _dwCPU$1[ebp], eax
$LN4@DestroyGIo:
  00035	8b 45 fc	 mov	 eax, DWORD PTR _dwCPU$1[ebp]
  00038	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_dwThreadCount@@3KA ; g_dwThreadCount
  0003e	73 15		 jae	 SHORT $LN3@DestroyGIo

; 161  : 	{
; 162  : 		TerminateThread(g_ThreadHandles[dwCPU], 0);

  00040	6a 00		 push	 0
  00042	8b 45 fc	 mov	 eax, DWORD PTR _dwCPU$1[ebp]
  00045	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_ThreadHandles@@3PAPAXA[eax*4]
  0004c	51		 push	 ecx
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 163  : 	}

  00053	eb d7		 jmp	 SHORT $LN2@DestroyGIo
$LN3@DestroyGIo:

; 164  : 	TerminateThread(g_IocpThreadHandle, 0);

  00055	6a 00		 push	 0
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_IocpThreadHandle@@3PAXA ; g_IocpThreadHandle
  0005c	50		 push	 eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 165  : 
; 166  : 	if( g_CompletionPort )

  00063	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
  0006a	74 16		 je	 SHORT $LN1@DestroyGIo

; 167  : 	{
; 168  : 		CloseHandle(g_CompletionPort);

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  00071	50		 push	 eax
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 169  : 		g_CompletionPort = NULL;

  00078	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_CompletionPort@@3PAXA, 0 ; g_CompletionPort
$LN1@DestroyGIo:

; 170  : 	}
; 171  : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?DestroyGIocp@@YAXXZ ENDP				; DestroyGIocp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?ResponErrorCloseClient@@YAXH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?ResponErrorCloseClient@@YAXH@Z PROC			; ResponErrorCloseClient, COMDAT

; 1362 : { 	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1363 : 	if( index < 0 || index > MAX_OBJECT-1 ) 

  00009	83 7d 08 00	 cmp	 DWORD PTR _index$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@ResponErro
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _index$[ebp], 7399 ; 00001ce7H
  00016	7e 13		 jle	 SHORT $LN2@ResponErro
$LN3@ResponErro:

; 1364 : 	{
; 1365 : 		LogAdd("error-L1 : CloseClient index error");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5er@
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00023	83 c4 04	 add	 esp, 4

; 1366 : 		return;

  00026	e9 e9 00 00 00	 jmp	 $LN1@ResponErro
$LN2@ResponErro:

; 1367 : 	}
; 1368 : 	if( gObj[index].Connected == 0 ) 

  0002b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00038	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  0003d	75 13		 jne	 SHORT $LN4@ResponErro

; 1369 : 	{
; 1370 : 		LogAdd("error-L1 : CloseClient connect error");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0004a	83 c4 04	 add	 esp, 4

; 1371 : 		return;

  0004d	e9 c2 00 00 00	 jmp	 $LN1@ResponErro
$LN4@ResponErro:

; 1372 : 	}
; 1373 : 
; 1374 : 	//DevGamesX 01/05/2018 - OffExp
; 1375 : 	if( OffExp.Update(index, 0) )

  00052	6a 00		 push	 0
  00054	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00057	50		 push	 eax
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?OffExp@@3VcOffExp@@A ; OffExp
  0005d	e8 00 00 00 00	 call	 ?Update@cOffExp@@QAE_NHE@Z ; cOffExp::Update
  00062	0f b6 c8	 movzx	 ecx, al
  00065	85 c9		 test	 ecx, ecx
  00067	74 05		 je	 SHORT $LN5@ResponErro

; 1376 : 	{
; 1377 : 		return;

  00069	e9 a6 00 00 00	 jmp	 $LN1@ResponErro
$LN5@ResponErro:

; 1378 : 	}
; 1379 : 
; 1380 : 	if( OFFSystem.Updateoffafk(index, 0) )

  0006e	6a 00		 push	 0
  00070	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00073	50		 push	 eax
  00074	b9 00 00 00 00	 mov	 ecx, OFFSET ?OFFSystem@@3VCOFFSystem@@A ; OFFSystem
  00079	e8 00 00 00 00	 call	 ?Updateoffafk@COFFSystem@@QAE_NHE@Z ; COFFSystem::Updateoffafk
  0007e	0f b6 c8	 movzx	 ecx, al
  00081	85 c9		 test	 ecx, ecx
  00083	74 05		 je	 SHORT $LN6@ResponErro

; 1381 : 	{
; 1382 : 		return;

  00085	e9 8a 00 00 00	 jmp	 $LN1@ResponErro
$LN6@ResponErro:

; 1383 : 	}
; 1384 : 
; 1385 : 	if( OFFtrade.Updateofftrade(index, 0) )

  0008a	6a 00		 push	 0
  0008c	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0008f	50		 push	 eax
  00090	b9 00 00 00 00	 mov	 ecx, OFFSET ?OFFtrade@@3VCOFFtrade@@A ; OFFtrade
  00095	e8 00 00 00 00	 call	 ?Updateofftrade@COFFtrade@@QAE_NHE@Z ; COFFtrade::Updateofftrade
  0009a	0f b6 c8	 movzx	 ecx, al
  0009d	85 c9		 test	 ecx, ecx
  0009f	74 02		 je	 SHORT $LN7@ResponErro

; 1386 : 	{
; 1387 : 		return;

  000a1	eb 71		 jmp	 SHORT $LN1@ResponErro
$LN7@ResponErro:

; 1388 : 	}
; 1389 : 
; 1390 : 	EnterCriticalSection(&criti);

  000a3	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1391 : #ifdef NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 1392 : 	gObj[index].NPggCSAuth.Close();
; 1393 : #endif
; 1394 : 	closesocket(gObj[index].m_socket);

  000ae	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bb	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  000bf	52		 push	 edx
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 1395 : 	gObj[index].m_socket = INVALID_SOCKET;

  000c6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d3	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+20], -1

; 1396 : 
; 1397 : 	if( gObj[index].m_socket == INVALID_SOCKET )

  000db	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e8	83 7c 01 14 ff	 cmp	 DWORD PTR [ecx+eax+20], -1
  000ed	75 0e		 jne	 SHORT $LN8@ResponErro

; 1398 : 	{
; 1399 : 		LogAdd("error-L1 : CloseClient INVALID_SOCKET");

  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_@
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fa	83 c4 04	 add	 esp, 4
$LN8@ResponErro:

; 1400 : 	}
; 1401 : 
; 1402 : 	gObjDel(index);

  000fd	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00106	83 c4 04	 add	 esp, 4

; 1403 : 	LeaveCriticalSection(&criti);

  00109	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN1@ResponErro:

; 1404 :     return;
; 1405 : }

  00114	5f		 pop	 edi
  00115	5e		 pop	 esi
  00116	5b		 pop	 ebx
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
?ResponErrorCloseClient@@YAXH@Z ENDP			; ResponErrorCloseClient
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?DataSend@@YAHHPAEK@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv84 = -92						; size = 4
_lpIoCtxt$ = -24					; size = 4
_btemp$1 = -17						; size = 1
_iSize$2 = -16						; size = 4
_SendBuf$ = -12						; size = 4
_lpPerSocketContext$ = -8				; size = 4
_SendBytes$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
_dwSize$ = 16						; size = 4
?DataSend@@YAHHPAEK@Z PROC				; DataSend, COMDAT

; 897  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 898  : #ifdef PACKET_KUZIMO
; 899  : 	char tempBuff[1024 * 10];
; 900  : 
; 901  : 	int msgCode;
; 902  : 	int msgSize;
; 903  : 
; 904  : 	if((PMHC_BYTE == lpMsg[0]) || (PMHCE_BYTE == lpMsg[0]))
; 905  : 	{
; 906  : 		msgCode = lpMsg[2];
; 907  : 		msgSize = lpMsg[1];
; 908  : 	}
; 909  : 	else
; 910  : 	{
; 911  : 		msgCode = lpMsg[3];
; 912  : 		msgSize = (lpMsg[1] << 8) | lpMsg[2];
; 913  : 	}
; 914  : 
; 915  : 	wsprintf(tempBuff, "%08u	S	%-12s	UserIndex(%05d)			Msg(0x%02X)	Size(0x%05X)	", GetTickCount(), gObj[aIndex].Name, aIndex, msgCode, msgSize);
; 916  : 
; 917  : 	for(int i = 0; i < dwSize; i++)
; 918  : 	{
; 919  : 		wsprintf(&tempBuff[strlen(tempBuff)], ",%02X", lpMsg[i]);
; 920  : 	}
; 921  : 
; 922  : 	wsprintf(&tempBuff[strlen(tempBuff)], "\n");
; 923  : 	WriteLog("PacketLog.txt", tempBuff);
; 924  : #endif
; 925  : 
; 926  : 	// 음냐음냐
; 927  : //	CHAR szTEMP[256];
; 928  : //	LPPMSG_DEFAULT2 lpMsg3=(LPPMSG_DEFAULT2)lpMsg;
; 929  : //	wsprintf(szTEMP, "(S->C)[%x-%x]\n", lpMsg3->h.headcode, lpMsg3->subcode);
; 930  : //	OutputDebugString(szTEMP);
; 931  : 
; 932  : #ifdef MUTE_EVENT_MESSAGE	// 공지 다 버린다
; 933  : 	if (g_bMuteServerMessage == 1) {
; 934  : 		LPPBMSG_HEAD	h = (LPPBMSG_HEAD)lpMsg;
; 935  : 		if( h->c == 0xC1 && h->headcode == 0x0D )
; 936  : 			return TRUE;
; 937  : 	}
; 938  : #endif
; 939  : 	
; 940  : #ifdef UPGRADE_GAMESERVER_01_20041006
; 941  : 	if( aIndex < ALLOC_USEROBJECTSTART )

  00009	81 7d 08 00 19
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 6400 ; 00001900H
  00010	7d 0a		 jge	 SHORT $LN2@DataSend

; 942  : 		return TRUE;

  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	e9 18 07 00 00	 jmp	 $LN1@DataSend
$LN2@DataSend:

; 943  : #endif
; 944  : 
; 945  : 	if( gObj[aIndex].Offtrade == TRUE && gObj[aIndex].OffExp == TRUE && gObj[aIndex].OffAfk == TRUE)

  0001c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00029	0f b6 94 01 86
	1a 00 00	 movzx	 edx, BYTE PTR [ecx+eax+6790]
  00031	83 fa 01	 cmp	 edx, 1
  00034	75 3e		 jne	 SHORT $LN3@DataSend
  00036	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00043	0f b6 94 01 8c
	1a 00 00	 movzx	 edx, BYTE PTR [ecx+eax+6796]
  0004b	83 fa 01	 cmp	 edx, 1
  0004e	75 24		 jne	 SHORT $LN3@DataSend
  00050	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005d	0f b6 94 01 85
	1a 00 00	 movzx	 edx, BYTE PTR [ecx+eax+6789]
  00065	83 fa 01	 cmp	 edx, 1
  00068	75 0a		 jne	 SHORT $LN3@DataSend

; 946  : 	{
; 947  : 		return true;

  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	e9 c0 06 00 00	 jmp	 $LN1@DataSend
$LN3@DataSend:

; 948  : 	}
; 949  : 
; 950  : 	EnterCriticalSection(&criti);

  00074	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 951  : 	
; 952  : 	if( CHECK_LIMIT(aIndex, MAX_OBJECT) == FALSE )

  0007f	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00083	7d 09		 jge	 SHORT $LN28@DataSend
  00085	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
  0008c	eb 1f		 jmp	 SHORT $LN29@DataSend
$LN28@DataSend:
  0008e	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00095	7e 09		 jle	 SHORT $LN26@DataSend
  00097	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  0009e	eb 07		 jmp	 SHORT $LN27@DataSend
$LN26@DataSend:
  000a0	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
$LN27@DataSend:
  000a7	8b 45 a0	 mov	 eax, DWORD PTR tv83[ebp]
  000aa	89 45 a4	 mov	 DWORD PTR tv84[ebp], eax
$LN29@DataSend:
  000ad	83 7d a4 00	 cmp	 DWORD PTR tv84[ebp], 0
  000b1	75 53		 jne	 SHORT $LN4@DataSend

; 953  : 	{
; 954  : 		LogAdd("error-L2 : Index(%d) %x %x %x ", dwSize, lpMsg[0],lpMsg[1],lpMsg[2]);

  000b3	b8 01 00 00 00	 mov	 eax, 1
  000b8	d1 e0		 shl	 eax, 1
  000ba	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000bd	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000c1	52		 push	 edx
  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	c1 e0 00	 shl	 eax, 0
  000ca	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000cd	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000d1	52		 push	 edx
  000d2	b8 01 00 00 00	 mov	 eax, 1
  000d7	6b c8 00	 imul	 ecx, eax, 0
  000da	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000dd	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000e1	50		 push	 eax
  000e2	8b 4d 10	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  000e5	51		 push	 ecx
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LLCNDKPF@error?9L2?5?3?5Index?$CI?$CFd?$CJ?5?$CFx?5?$CFx?5?$CFx?5@
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000f1	83 c4 14	 add	 esp, 20			; 00000014H

; 955  : 		LeaveCriticalSection(&criti);

  000f4	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 956  : 		return FALSE;

  000ff	33 c0		 xor	 eax, eax
  00101	e9 2e 06 00 00	 jmp	 $LN1@DataSend
$LN4@DataSend:

; 957  : 	}
; 958  : 
; 959  : 	DWORD SendBytes;
; 960  : 	LPPER_SOCKET_CONTEXT lpPerSocketContext;
; 961  : 	LPBYTE SendBuf;
; 962  : 
; 963  : 	if( lpMsg[0] == 0xC3 || lpMsg[0] == 0xC4 )

  00106	b8 01 00 00 00	 mov	 eax, 1
  0010b	6b c8 00	 imul	 ecx, eax, 0
  0010e	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00111	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00115	3d c3 00 00 00	 cmp	 eax, 195		; 000000c3H
  0011a	74 1a		 je	 SHORT $LN7@DataSend
  0011c	b8 01 00 00 00	 mov	 eax, 1
  00121	6b c8 00	 imul	 ecx, eax, 0
  00124	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00127	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0012b	3d c4 00 00 00	 cmp	 eax, 196		; 000000c4H
  00130	0f 85 7d 01 00
	00		 jne	 $LN5@DataSend
$LN7@DataSend:

; 964  : 	{
; 965  : 		int iSize;
; 966  : 		BYTE btemp;
; 967  : 
; 968  : 		if( lpMsg[0] == 0xC3 )

  00136	b8 01 00 00 00	 mov	 eax, 1
  0013b	6b c8 00	 imul	 ecx, eax, 0
  0013e	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00141	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00145	3d c3 00 00 00	 cmp	 eax, 195		; 000000c3H
  0014a	0f 85 a3 00 00
	00		 jne	 $LN8@DataSend

; 969  : 		{
; 970  : 			btemp = lpMsg[1];

  00150	b8 01 00 00 00	 mov	 eax, 1
  00155	c1 e0 00	 shl	 eax, 0
  00158	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0015b	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0015e	88 55 ef	 mov	 BYTE PTR _btemp$1[ebp], dl

; 971  : 			lpMsg[1] = gNSerialCheck[aIndex].GetSendSerial();

  00161	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00164	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[eax*8]
  0016b	e8 00 00 00 00	 call	 ?GetSendSerial@NSerialCheck@@QAEEXZ ; NSerialCheck::GetSendSerial
  00170	b9 01 00 00 00	 mov	 ecx, 1
  00175	c1 e1 00	 shl	 ecx, 0
  00178	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0017b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 972  : 
; 973  : 			iSize			= g_SimpleModulusSC.Encrypt( ExSendBuf+2, lpMsg+1, dwSize-1);

  0017e	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00181	83 e8 01	 sub	 eax, 1
  00184	50		 push	 eax
  00185	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00188	83 c1 01	 add	 ecx, 1
  0018b	51		 push	 ecx
  0018c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00192	83 c2 02	 add	 edx, 2
  00195	52		 push	 edx
  00196	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusSC@@3VCSimpleModulus@@A ; g_SimpleModulusSC
  0019b	e8 00 00 00 00	 call	 ?Encrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Encrypt
  001a0	89 45 f0	 mov	 DWORD PTR _iSize$2[ebp], eax

; 974  : 			ExSendBuf[0]	= 0xC3;

  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	6b c8 00	 imul	 ecx, eax, 0
  001ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  001b1	c6 04 0a c3	 mov	 BYTE PTR [edx+ecx], 195	; 000000c3H

; 975  : 			ExSendBuf[1]	= iSize+2;

  001b5	8b 45 f0	 mov	 eax, DWORD PTR _iSize$2[ebp]
  001b8	83 c0 02	 add	 eax, 2
  001bb	b9 01 00 00 00	 mov	 ecx, 1
  001c0	c1 e1 00	 shl	 ecx, 0
  001c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  001c9	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 976  : 			SendBuf			= ExSendBuf;

  001cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  001d1	89 45 f4	 mov	 DWORD PTR _SendBuf$[ebp], eax

; 977  : 			dwSize			= iSize+2;

  001d4	8b 45 f0	 mov	 eax, DWORD PTR _iSize$2[ebp]
  001d7	83 c0 02	 add	 eax, 2
  001da	89 45 10	 mov	 DWORD PTR _dwSize$[ebp], eax

; 978  : 
; 979  : 			lpMsg[1]  = btemp;

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	c1 e0 00	 shl	 eax, 0
  001e5	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001e8	8a 55 ef	 mov	 dl, BYTE PTR _btemp$1[ebp]
  001eb	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 980  : 		}

  001ee	e9 be 00 00 00	 jmp	 $LN9@DataSend
$LN8@DataSend:

; 981  : 		else
; 982  : 		{
; 983  : 			btemp = lpMsg[2];

  001f3	b8 01 00 00 00	 mov	 eax, 1
  001f8	d1 e0		 shl	 eax, 1
  001fa	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001fd	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00200	88 55 ef	 mov	 BYTE PTR _btemp$1[ebp], dl

; 984  : 			lpMsg[2] = gNSerialCheck[aIndex].GetSendSerial();

  00203	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00206	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[eax*8]
  0020d	e8 00 00 00 00	 call	 ?GetSendSerial@NSerialCheck@@QAEEXZ ; NSerialCheck::GetSendSerial
  00212	b9 01 00 00 00	 mov	 ecx, 1
  00217	d1 e1		 shl	 ecx, 1
  00219	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0021c	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 985  : 
; 986  : 			iSize			= g_SimpleModulusSC.Encrypt( ExSendBuf+3, lpMsg+2, dwSize-2);

  0021f	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00222	83 e8 02	 sub	 eax, 2
  00225	50		 push	 eax
  00226	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00229	83 c1 02	 add	 ecx, 2
  0022c	51		 push	 ecx
  0022d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00233	83 c2 03	 add	 edx, 3
  00236	52		 push	 edx
  00237	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SimpleModulusSC@@3VCSimpleModulus@@A ; g_SimpleModulusSC
  0023c	e8 00 00 00 00	 call	 ?Encrypt@CSimpleModulus@@QAEHPAX0H@Z ; CSimpleModulus::Encrypt
  00241	89 45 f0	 mov	 DWORD PTR _iSize$2[ebp], eax

; 987  : 			ExSendBuf[0]	= 0xC4;

  00244	b8 01 00 00 00	 mov	 eax, 1
  00249	6b c8 00	 imul	 ecx, eax, 0
  0024c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00252	c6 04 0a c4	 mov	 BYTE PTR [edx+ecx], 196	; 000000c4H

; 988  : 			ExSendBuf[1]	= HIBYTE(iSize+3);

  00256	8b 45 f0	 mov	 eax, DWORD PTR _iSize$2[ebp]
  00259	83 c0 03	 add	 eax, 3
  0025c	c1 e8 08	 shr	 eax, 8
  0025f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00264	b9 01 00 00 00	 mov	 ecx, 1
  00269	c1 e1 00	 shl	 ecx, 0
  0026c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00272	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 989  : 			ExSendBuf[2]	= LOBYTE(iSize+3);

  00275	8b 45 f0	 mov	 eax, DWORD PTR _iSize$2[ebp]
  00278	83 c0 03	 add	 eax, 3
  0027b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00280	b9 01 00 00 00	 mov	 ecx, 1
  00285	d1 e1		 shl	 ecx, 1
  00287	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  0028d	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 990  : 			SendBuf			= ExSendBuf;

  00290	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  00295	89 45 f4	 mov	 DWORD PTR _SendBuf$[ebp], eax

; 991  : 			dwSize			= iSize+3;

  00298	8b 45 f0	 mov	 eax, DWORD PTR _iSize$2[ebp]
  0029b	83 c0 03	 add	 eax, 3
  0029e	89 45 10	 mov	 DWORD PTR _dwSize$[ebp], eax

; 992  : 			lpMsg[2] = btemp;

  002a1	b8 01 00 00 00	 mov	 eax, 1
  002a6	d1 e0		 shl	 eax, 1
  002a8	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002ab	8a 55 ef	 mov	 dl, BYTE PTR _btemp$1[ebp]
  002ae	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
$LN9@DataSend:

; 993  : 		}
; 994  : 	}

  002b1	eb 06		 jmp	 SHORT $LN6@DataSend
$LN5@DataSend:

; 995  : 	else SendBuf = lpMsg;

  002b3	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002b6	89 45 f4	 mov	 DWORD PTR _SendBuf$[ebp], eax
$LN6@DataSend:

; 996  : 
; 997  : 	if( gObj[aIndex].Connected < 1
; 998  : #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 999  : 		&& gObj[aIndex].Connected != CSS_LOGINWAIT

  002b9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c6	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  002cb	7d 26		 jge	 SHORT $LN10@DataSend
  002cd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002da	83 7c 01 04 ff	 cmp	 DWORD PTR [ecx+eax+4], -1
  002df	74 12		 je	 SHORT $LN10@DataSend

; 1000 : #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 1001 : 		)
; 1002 : 	{
; 1003 : 		LeaveCriticalSection(&criti);

  002e1	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  002e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1004 : 		return FALSE;

  002ec	33 c0		 xor	 eax, eax
  002ee	e9 41 04 00 00	 jmp	 $LN1@DataSend
$LN10@DataSend:

; 1005 : 	}
; 1006 : 		
; 1007 : 	lpPerSocketContext = gObj[aIndex].PerSocketContext;

  002f3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00300	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  00304	89 55 f8	 mov	 DWORD PTR _lpPerSocketContext$[ebp], edx

; 1008 : 	
; 1009 : 	if( dwSize > MAX_BUFF_SIZE )

  00307	81 7d 10 00 40
	00 00		 cmp	 DWORD PTR _dwSize$[ebp], 16384 ; 00004000H
  0030e	76 3e		 jbe	 SHORT $LN11@DataSend

; 1010 : 	{
; 1011 : 		LogAdd("Error : Max msg(%d) %s %d", dwSize, __FILE__, __LINE__);

  00310	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??DataSend@@YAHHPAEK@Z@4JA
  00315	83 c0 72	 add	 eax, 114		; 00000072H
  00318	50		 push	 eax
  00319	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HNMJGPF@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0031e	8b 4d 10	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  00321	51		 push	 ecx
  00322	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HOECGHIH@Error?5?3?5Max?5msg?$CI?$CFd?$CJ?5?$CFs?5?$CFd@
  00327	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0032d	83 c4 10	 add	 esp, 16			; 00000010H

; 1012 : 		CloseClient( aIndex );

  00330	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00333	50		 push	 eax
  00334	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00339	83 c4 04	 add	 esp, 4

; 1013 : 		LeaveCriticalSection(&criti);

  0033c	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00341	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1014 : 		return FALSE;

  00347	33 c0		 xor	 eax, eax
  00349	e9 e6 03 00 00	 jmp	 $LN1@DataSend
$LN11@DataSend:

; 1015 : 	}
; 1016 : 
; 1017 : 	LPPER_IO_CONTEXT	lpIoCtxt = (LPPER_IO_CONTEXT)&lpPerSocketContext->IOContext[1];

  0034e	b8 30 00 01 00	 mov	 eax, 65584		; 00010030H
  00353	c1 e0 00	 shl	 eax, 0
  00356	8b 4d f8	 mov	 ecx, DWORD PTR _lpPerSocketContext$[ebp]
  00359	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0035d	89 55 e8	 mov	 DWORD PTR _lpIoCtxt$[ebp], edx

; 1018 : 
; 1019 : 	if( lpIoCtxt->nWaitIO > 0 )	// 쓰기 작업이 아직 완료되지 않았다면.. 세컨트로 복사

  00360	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00363	83 b8 2c 00 01
	00 00		 cmp	 DWORD PTR [eax+65580], 0
  0036a	0f 8e e5 00 00
	00		 jle	 $LN12@DataSend

; 1020 : 	{	
; 1021 : 		if( (lpIoCtxt->nSecondOfs+dwSize) > MAX_BUFF_SIZE-1)	// 크기를 넘었다.

  00370	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00373	8b 88 1c 00 01
	00		 mov	 ecx, DWORD PTR [eax+65564]
  00379	03 4d 10	 add	 ecx, DWORD PTR _dwSize$[ebp]
  0037c	81 f9 ff 3f 00
	00		 cmp	 ecx, 16383		; 00003fffH
  00382	76 7e		 jbe	 SHORT $LN14@DataSend

; 1022 : 		{
; 1023 : 			LogAdd("(%d)error-L2 MAX BUFFER OVER %d %d %d [%s][%s]", aIndex, lpIoCtxt->nTotalBytes, lpIoCtxt->nSecondOfs, dwSize, gObj[aIndex].AccountID, gObj[aIndex].Name);

  00384	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0038b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00391	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00395	52		 push	 edx
  00396	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0039d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a3	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  003a7	52		 push	 edx
  003a8	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  003ab	50		 push	 eax
  003ac	8b 4d e8	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  003af	8b 91 1c 00 01
	00		 mov	 edx, DWORD PTR [ecx+65564]
  003b5	52		 push	 edx
  003b6	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  003b9	8b 88 20 00 01
	00		 mov	 ecx, DWORD PTR [eax+65568]
  003bf	51		 push	 ecx
  003c0	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  003c3	52		 push	 edx
  003c4	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@OMKJIPGE@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd@
  003c9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003cf	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1024 : 			lpIoCtxt->nWaitIO = 0;

  003d2	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  003d5	c7 80 2c 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65580], 0

; 1025 : 			CloseClient( aIndex );

  003df	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003e2	50		 push	 eax
  003e3	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  003e8	83 c4 04	 add	 esp, 4

; 1026 : 			LeaveCriticalSection(&criti);

  003eb	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  003f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1027 : 			return TRUE;

  003f6	b8 01 00 00 00	 mov	 eax, 1
  003fb	e9 34 03 00 00	 jmp	 $LN1@DataSend

; 1028 : 		}

  00400	eb 4e		 jmp	 SHORT $LN15@DataSend
$LN14@DataSend:

; 1029 : 		else
; 1030 : 		{
; 1031 : 			// 세컨드를 일단 복사..
; 1032 : 			memcpy(lpIoCtxt->BufferSecond+lpIoCtxt->nSecondOfs, SendBuf, dwSize);

  00402	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00405	50		 push	 eax
  00406	8b 4d f4	 mov	 ecx, DWORD PTR _SendBuf$[ebp]
  00409	51		 push	 ecx
  0040a	8b 55 e8	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  0040d	8b 82 1c 00 01
	00		 mov	 eax, DWORD PTR [edx+65564]
  00413	8b 4d e8	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  00416	8d 94 01 1c 80
	00 00		 lea	 edx, DWORD PTR [ecx+eax+32796]
  0041d	52		 push	 edx
  0041e	e8 00 00 00 00	 call	 _memcpy
  00423	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1033 : 			lpIoCtxt->nSecondOfs+=dwSize;

  00426	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00429	8b 88 1c 00 01
	00		 mov	 ecx, DWORD PTR [eax+65564]
  0042f	03 4d 10	 add	 ecx, DWORD PTR _dwSize$[ebp]
  00432	8b 55 e8	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  00435	89 8a 1c 00 01
	00		 mov	 DWORD PTR [edx+65564], ecx

; 1034 : 			//LogAdd("세컨드 복사.. %d+=%d (%s)", lpIoCtxt->nSecondOfs, dwSize, gObj[aIndex].AccountID);
; 1035 : 			LeaveCriticalSection(&criti);

  0043b	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00440	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1036 : 			return TRUE;

  00446	b8 01 00 00 00	 mov	 eax, 1
  0044b	e9 e4 02 00 00	 jmp	 $LN1@DataSend
$LN15@DataSend:

; 1037 : 		}
; 1038 : 	}

  00450	e9 16 01 00 00	 jmp	 $LN13@DataSend
$LN12@DataSend:

; 1039 : 	else
; 1040 : 	{
; 1041 : 		lpIoCtxt->nTotalBytes = 0;

  00455	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00458	c7 80 20 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65568], 0

; 1042 : 		if( lpIoCtxt->nSecondOfs > 0 )

  00462	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00465	83 b8 1c 00 01
	00 00		 cmp	 DWORD PTR [eax+65564], 0
  0046c	7e 42		 jle	 SHORT $LN16@DataSend

; 1043 : 		{
; 1044 : 			memcpy(lpIoCtxt->Buffer, lpIoCtxt->BufferSecond, lpIoCtxt->nSecondOfs);

  0046e	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00471	8b 88 1c 00 01
	00		 mov	 ecx, DWORD PTR [eax+65564]
  00477	51		 push	 ecx
  00478	8b 55 e8	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  0047b	81 c2 1c 80 00
	00		 add	 edx, 32796		; 0000801cH
  00481	52		 push	 edx
  00482	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00485	83 c0 1c	 add	 eax, 28			; 0000001cH
  00488	50		 push	 eax
  00489	e8 00 00 00 00	 call	 _memcpy
  0048e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1045 : 			lpIoCtxt->nTotalBytes = lpIoCtxt->nSecondOfs;

  00491	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00494	8b 4d e8	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  00497	8b 91 1c 00 01
	00		 mov	 edx, DWORD PTR [ecx+65564]
  0049d	89 90 20 00 01
	00		 mov	 DWORD PTR [eax+65568], edx

; 1046 : 			//LogAdd("프론트로 복사.. %d", lpIoCtxt->nTotalBytes);
; 1047 : 			lpIoCtxt->nSecondOfs = 0;

  004a3	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  004a6	c7 80 1c 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65564], 0
$LN16@DataSend:

; 1048 : 		}
; 1049 : 		if( (lpIoCtxt->nTotalBytes+dwSize) > MAX_BUFF_SIZE-1)	// 크기를 넘었다.

  004b0	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  004b3	8b 88 20 00 01
	00		 mov	 ecx, DWORD PTR [eax+65568]
  004b9	03 4d 10	 add	 ecx, DWORD PTR _dwSize$[ebp]
  004bc	81 f9 ff 3f 00
	00		 cmp	 ecx, 16383		; 00003fffH
  004c2	76 71		 jbe	 SHORT $LN17@DataSend

; 1050 : 		{
; 1051 : 			LogAdd("(%d)error-L2 MAX BUFFER OVER %d %d [%s][%s]", aIndex, lpIoCtxt->nTotalBytes, dwSize, gObj[aIndex].AccountID, gObj[aIndex].Name);

  004c4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004d1	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  004d5	52		 push	 edx
  004d6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004e3	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  004e7	52		 push	 edx
  004e8	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  004eb	50		 push	 eax
  004ec	8b 4d e8	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  004ef	8b 91 20 00 01
	00		 mov	 edx, DWORD PTR [ecx+65568]
  004f5	52		 push	 edx
  004f6	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004f9	50		 push	 eax
  004fa	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@MJNIMEPA@?$CI?$CFd?$CJerror?9L2?5MAX?5BUFFER?5OVER?5?$CFd@
  004ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00505	83 c4 18	 add	 esp, 24			; 00000018H

; 1052 : 			lpIoCtxt->nWaitIO = 0;

  00508	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  0050b	c7 80 2c 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65580], 0

; 1053 : 			CloseClient( aIndex );

  00515	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00518	50		 push	 eax
  00519	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0051e	83 c4 04	 add	 esp, 4

; 1054 : 			LeaveCriticalSection(&criti);

  00521	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00526	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1055 : 			return FALSE;

  0052c	33 c0		 xor	 eax, eax
  0052e	e9 01 02 00 00	 jmp	 $LN1@DataSend

; 1056 : 		}

  00533	eb 36		 jmp	 SHORT $LN13@DataSend
$LN17@DataSend:

; 1057 : 		else
; 1058 : 		{
; 1059 : 			memcpy(lpIoCtxt->Buffer+lpIoCtxt->nTotalBytes, SendBuf, dwSize);

  00535	8b 45 10	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00538	50		 push	 eax
  00539	8b 4d f4	 mov	 ecx, DWORD PTR _SendBuf$[ebp]
  0053c	51		 push	 ecx
  0053d	8b 55 e8	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  00540	8b 82 20 00 01
	00		 mov	 eax, DWORD PTR [edx+65568]
  00546	8b 4d e8	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  00549	8d 54 01 1c	 lea	 edx, DWORD PTR [ecx+eax+28]
  0054d	52		 push	 edx
  0054e	e8 00 00 00 00	 call	 _memcpy
  00553	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1060 : 			lpIoCtxt->nTotalBytes += dwSize;

  00556	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00559	8b 88 20 00 01
	00		 mov	 ecx, DWORD PTR [eax+65568]
  0055f	03 4d 10	 add	 ecx, DWORD PTR _dwSize$[ebp]
  00562	8b 55 e8	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  00565	89 8a 20 00 01
	00		 mov	 DWORD PTR [edx+65568], ecx
$LN13@DataSend:

; 1061 : 			//LogAdd("error-L4 : 메시지 복사.. %d", lpIoCtxt->nTotalBytes);
; 1062 : 		}
; 1063 : 	}
; 1064 : 	// 쓰기작업이 완료되었다면..
; 1065 : 
; 1066 : 	lpIoCtxt->wsabuf.buf	= (char*)lpIoCtxt->Buffer;

  0056b	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  0056e	83 c0 1c	 add	 eax, 28			; 0000001cH
  00571	8b 4d e8	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  00574	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1067 : 	lpIoCtxt->wsabuf.len	= lpIoCtxt->nTotalBytes;

  00577	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  0057a	8b 4d e8	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  0057d	8b 91 20 00 01
	00		 mov	 edx, DWORD PTR [ecx+65568]
  00583	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 1068 : 	lpIoCtxt->nSentBytes	= 0;

  00586	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00589	c7 80 24 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65572], 0

; 1069 : 	lpIoCtxt->IOOperation	= SEND_IO;

  00593	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00596	c7 80 28 00 01
	00 01 00 00 00	 mov	 DWORD PTR [eax+65576], 1

; 1070 : 
; 1071 : 	if (WSASend(gObj[aIndex].m_socket, &(lpIoCtxt->wsabuf), 1, &SendBytes, 0,
; 1072 : 		&(lpIoCtxt->Overlapped), NULL) == SOCKET_ERROR)

  005a0	6a 00		 push	 0
  005a2	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  005a5	50		 push	 eax
  005a6	6a 00		 push	 0
  005a8	8d 4d fc	 lea	 ecx, DWORD PTR _SendBytes$[ebp]
  005ab	51		 push	 ecx
  005ac	6a 01		 push	 1
  005ae	8b 55 e8	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  005b1	83 c2 14	 add	 edx, 20			; 00000014H
  005b4	52		 push	 edx
  005b5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c2	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  005c6	52		 push	 edx
  005c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  005cd	83 f8 ff	 cmp	 eax, -1
  005d0	0f 85 2c 01 00
	00		 jne	 $LN19@DataSend

; 1073 : 	{
; 1074 : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  005d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  005dc	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  005e1	0f 84 19 01 00
	00		 je	 $LN21@DataSend

; 1075 : 		{
; 1076 : 			lpIoCtxt->nWaitIO = 0;

  005e7	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  005ea	c7 80 2c 00 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+65580], 0

; 1077 : 
; 1078 : 			if( lpIoCtxt->wsabuf.buf[0] == 0xC1 )

  005f4	b8 01 00 00 00	 mov	 eax, 1
  005f9	6b c8 00	 imul	 ecx, eax, 0
  005fc	8b 55 e8	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  005ff	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00602	0f be 0c 08	 movsx	 ecx, BYTE PTR [eax+ecx]
  00606	81 f9 c1 00 00
	00		 cmp	 ecx, 193		; 000000c1H
  0060c	75 5f		 jne	 SHORT $LN22@DataSend

; 1079 : 			{
; 1080 : 				LogAdd("(%d)WSASend(%d) failed with error [%x][%x] %d %s ", __LINE__, aIndex, (BYTE)lpIoCtxt->wsabuf.buf[0], (BYTE)lpIoCtxt->wsabuf.buf[2], WSAGetLastError(), gObj[aIndex].Ip_addr);

  0060e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00615	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0061b	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0061f	52		 push	 edx
  00620	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00626	50		 push	 eax
  00627	b8 01 00 00 00	 mov	 eax, 1
  0062c	d1 e0		 shl	 eax, 1
  0062e	8b 4d e8	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  00631	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00634	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  00638	50		 push	 eax
  00639	b9 01 00 00 00	 mov	 ecx, 1
  0063e	6b d1 00	 imul	 edx, ecx, 0
  00641	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  00644	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00647	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  0064b	52		 push	 edx
  0064c	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0064f	50		 push	 eax
  00650	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??DataSend@@YAHHPAEK@Z@4JA
  00656	81 c1 b7 00 00
	00		 add	 ecx, 183		; 000000b7H
  0065c	51		 push	 ecx
  0065d	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5err@
  00662	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00668	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1081 : 			}

  0066b	eb 78		 jmp	 SHORT $LN23@DataSend
$LN22@DataSend:

; 1082 : 			else if( lpIoCtxt->wsabuf.buf[0] == 0xC2 )

  0066d	b8 01 00 00 00	 mov	 eax, 1
  00672	6b c8 00	 imul	 ecx, eax, 0
  00675	8b 55 e8	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  00678	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0067b	0f be 0c 08	 movsx	 ecx, BYTE PTR [eax+ecx]
  0067f	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  00685	75 5e		 jne	 SHORT $LN23@DataSend

; 1083 : 			{
; 1084 : 				LogAdd("(%d)WSASend(%d) failed with error [%x][%x] %d %s ", __LINE__, aIndex, (BYTE)lpIoCtxt->wsabuf.buf[0], (BYTE)lpIoCtxt->wsabuf.buf[3], WSAGetLastError(), gObj[aIndex].Ip_addr);

  00687	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0068e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00694	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00698	52		 push	 edx
  00699	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0069f	50		 push	 eax
  006a0	b8 01 00 00 00	 mov	 eax, 1
  006a5	6b c8 03	 imul	 ecx, eax, 3
  006a8	8b 55 e8	 mov	 edx, DWORD PTR _lpIoCtxt$[ebp]
  006ab	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  006ae	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  006b2	51		 push	 ecx
  006b3	ba 01 00 00 00	 mov	 edx, 1
  006b8	6b c2 00	 imul	 eax, edx, 0
  006bb	8b 4d e8	 mov	 ecx, DWORD PTR _lpIoCtxt$[ebp]
  006be	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006c1	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  006c5	50		 push	 eax
  006c6	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  006c9	51		 push	 ecx
  006ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??DataSend@@YAHHPAEK@Z@4JA
  006d0	81 c2 bb 00 00
	00		 add	 edx, 187		; 000000bbH
  006d6	52		 push	 edx
  006d7	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KIEJLADI@?$CI?$CFd?$CJWSASend?$CI?$CFd?$CJ?5failed?5with?5err@
  006dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  006e2	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN23@DataSend:

; 1085 : 			}
; 1086 : 			CloseClient( aIndex );

  006e5	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  006ee	83 c4 04	 add	 esp, 4

; 1087 : 			LeaveCriticalSection(&criti);

  006f1	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  006f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1088 : 			return FALSE;

  006fc	33 c0		 xor	 eax, eax
  006fe	eb 34		 jmp	 SHORT $LN1@DataSend
$LN21@DataSend:

; 1089 : 		}
; 1090 : 	}

  00700	eb 15		 jmp	 SHORT $LN20@DataSend
$LN19@DataSend:

; 1091 : 	else 
; 1092 : 	{
; 1093 : 		lpPerSocketContext->dwIOCount++;

  00702	8b 45 f8	 mov	 eax, DWORD PTR _lpPerSocketContext$[ebp]
  00705	8b 88 68 00 02
	00		 mov	 ecx, DWORD PTR [eax+131176]
  0070b	83 c1 01	 add	 ecx, 1
  0070e	8b 55 f8	 mov	 edx, DWORD PTR _lpPerSocketContext$[ebp]
  00711	89 8a 68 00 02
	00		 mov	 DWORD PTR [edx+131176], ecx
$LN20@DataSend:

; 1094 : 	}
; 1095 : 	lpIoCtxt->nWaitIO = 1;

  00717	8b 45 e8	 mov	 eax, DWORD PTR _lpIoCtxt$[ebp]
  0071a	c7 80 2c 00 01
	00 01 00 00 00	 mov	 DWORD PTR [eax+65580], 1

; 1096 : 	LeaveCriticalSection(&criti);

  00724	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00729	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 1097 : 	return TRUE;

  0072f	b8 01 00 00 00	 mov	 eax, 1
$LN1@DataSend:

; 1098 : }

  00734	5f		 pop	 edi
  00735	5e		 pop	 esi
  00736	5b		 pop	 ebx
  00737	8b e5		 mov	 esp, ebp
  00739	5d		 pop	 ebp
  0073a	c3		 ret	 0
?DataSend@@YAHHPAEK@Z ENDP				; DataSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?CloseClientEx@@YAXH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?CloseClientEx@@YAXH@Z PROC				; CloseClientEx, COMDAT

; 1333 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1334 : 	if ( index < 0 || index > MAX_OBJECT-1 )

  00009	83 7d 08 00	 cmp	 DWORD PTR _index$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@CloseClien
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _index$[ebp], 7399 ; 00001ce7H
  00016	7e 10		 jle	 SHORT $LN2@CloseClien
$LN3@CloseClien:

; 1335 : 	{
; 1336 : 		LogAdd("error-L1 : CloseClient index error");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5er@
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00023	83 c4 04	 add	 esp, 4

; 1337 : 		return;

  00026	eb 7b		 jmp	 SHORT $LN1@CloseClien
$LN2@CloseClien:

; 1338 : 	}
; 1339 : 
; 1340 : 	if ( gObj[index].Connected == 0 )

  00028	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00035	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  0003a	75 10		 jne	 SHORT $LN4@CloseClien

; 1341 : 	{
; 1342 : 		LogAdd("error-L1 : CloseClient connect error");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00047	83 c4 04	 add	 esp, 4

; 1343 : 		return;

  0004a	eb 57		 jmp	 SHORT $LN1@CloseClien
$LN4@CloseClien:

; 1344 : 	}
; 1345 : 	
; 1346 : 	EnterCriticalSection(&criti);

  0004c	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1347 : 
; 1348 : 	if ( gObj[index].m_socket != INVALID_SOCKET )

  00057	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00064	83 7c 01 14 ff	 cmp	 DWORD PTR [ecx+eax+20], -1
  00069	74 2d		 je	 SHORT $LN6@CloseClien

; 1349 : 	{
; 1350 : 		closesocket(gObj[index].m_socket );

  0006b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00078	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  0007c	52		 push	 edx
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 1351 : 		gObj[index].m_socket = INVALID_SOCKET;

  00083	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00090	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+20], -1
$LN6@CloseClien:

; 1352 : 	}
; 1353 : 	else
; 1354 : 	{
; 1355 : 		//LogAdd("error-L1 : CloseClient INVALID_SOCKET");
; 1356 : 	}
; 1357 : 
; 1358 : 	LeaveCriticalSection(&criti);

  00098	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN1@CloseClien:

; 1359 : }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
?CloseClientEx@@YAXH@Z ENDP				; CloseClientEx
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?CloseClient@@YAXH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?CloseClient@@YAXH@Z PROC				; CloseClient, COMDAT

; 1281 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1282 : #ifdef PACKET_KUZIMO
; 1283 : 	WriteLog("PacketLog.txt", "%08u	S	%-12s	UserIndex(%05d)	CloseClient\n", GetTickCount(), gObj[index].Name, index);
; 1284 : #endif
; 1285 : 
; 1286 : 	if( index < 0 || index > MAX_OBJECT-1 ) 

  00009	83 7d 08 00	 cmp	 DWORD PTR _index$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@CloseClien
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _index$[ebp], 7399 ; 00001ce7H
  00016	7e 13		 jle	 SHORT $LN2@CloseClien
$LN3@CloseClien:

; 1287 : 	{
; 1288 : 		LogAdd("error-L1 : CloseClient index error");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NBNKEDMK@error?9L1?5?3?5CloseClient?5index?5er@
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00023	83 c4 04	 add	 esp, 4

; 1289 : 		return;

  00026	e9 df 00 00 00	 jmp	 $LN1@CloseClien
$LN2@CloseClien:

; 1290 : 	}
; 1291 : 	if( gObj[index].Connected == 0 ) 

  0002b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00038	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  0003d	75 13		 jne	 SHORT $LN4@CloseClien

; 1292 : 	{
; 1293 : 		LogAdd("error-L1 : CloseClient connect error");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PBECJIMH@error?9L1?5?3?5CloseClient?5connect?5@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0004a	83 c4 04	 add	 esp, 4

; 1294 : 		return;

  0004d	e9 b8 00 00 00	 jmp	 $LN1@CloseClien
$LN4@CloseClien:

; 1295 : 	}
; 1296 : 
; 1297 : 	//DevGamesX 01/05/2018 - OffExp
; 1298 : 	if( OffExp.Update(index, 0) )

  00052	6a 00		 push	 0
  00054	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00057	50		 push	 eax
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?OffExp@@3VcOffExp@@A ; OffExp
  0005d	e8 00 00 00 00	 call	 ?Update@cOffExp@@QAE_NHE@Z ; cOffExp::Update
  00062	0f b6 c8	 movzx	 ecx, al
  00065	85 c9		 test	 ecx, ecx
  00067	74 05		 je	 SHORT $LN5@CloseClien

; 1299 : 	{
; 1300 : 		return;

  00069	e9 9c 00 00 00	 jmp	 $LN1@CloseClien
$LN5@CloseClien:

; 1301 : 	}
; 1302 : 
; 1303 : 	if( OFFSystem.Updateoffafk(index, 0) )

  0006e	6a 00		 push	 0
  00070	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00073	50		 push	 eax
  00074	b9 00 00 00 00	 mov	 ecx, OFFSET ?OFFSystem@@3VCOFFSystem@@A ; OFFSystem
  00079	e8 00 00 00 00	 call	 ?Updateoffafk@COFFSystem@@QAE_NHE@Z ; COFFSystem::Updateoffafk
  0007e	0f b6 c8	 movzx	 ecx, al
  00081	85 c9		 test	 ecx, ecx
  00083	74 05		 je	 SHORT $LN6@CloseClien

; 1304 : 	{
; 1305 : 		return;

  00085	e9 80 00 00 00	 jmp	 $LN1@CloseClien
$LN6@CloseClien:

; 1306 : 	}
; 1307 : 
; 1308 : 	if( OFFtrade.Updateofftrade(index, 0) )

  0008a	6a 00		 push	 0
  0008c	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0008f	50		 push	 eax
  00090	b9 00 00 00 00	 mov	 ecx, OFFSET ?OFFtrade@@3VCOFFtrade@@A ; OFFtrade
  00095	e8 00 00 00 00	 call	 ?Updateofftrade@COFFtrade@@QAE_NHE@Z ; COFFtrade::Updateofftrade
  0009a	0f b6 c8	 movzx	 ecx, al
  0009d	85 c9		 test	 ecx, ecx
  0009f	74 02		 je	 SHORT $LN7@CloseClien

; 1309 : 	{
; 1310 : 		return;

  000a1	eb 67		 jmp	 SHORT $LN1@CloseClien
$LN7@CloseClien:

; 1311 : 	}
; 1312 : 
; 1313 : 	EnterCriticalSection(&criti);	

  000a3	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 1314 : 
; 1315 : 	if( gObj[index].m_socket != INVALID_SOCKET )

  000ae	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bb	83 7c 01 14 ff	 cmp	 DWORD PTR [ecx+eax+20], -1
  000c0	74 2f		 je	 SHORT $LN8@CloseClien

; 1316 : 	{
; 1317 : #ifdef NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 1318 : 		gObj[index].NPggCSAuth.Close();
; 1319 : #endif
; 1320 : 		closesocket(gObj[index].m_socket);

  000c2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cf	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  000d3	52		 push	 edx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 1321 : 		gObj[index].m_socket = INVALID_SOCKET;		

  000da	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e7	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+20], -1

; 1322 : 	}

  000ef	eb 0e		 jmp	 SHORT $LN9@CloseClien
$LN8@CloseClien:

; 1323 : 	else
; 1324 : 	{
; 1325 : 		LogAdd("error-L1 : CloseClient INVALID_SOCKET");

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EMNFJCMC@error?9L1?5?3?5CloseClient?5INVALID_@
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fc	83 c4 04	 add	 esp, 4
$LN9@CloseClien:

; 1326 : 	}
; 1327 : 
; 1328 : 	LeaveCriticalSection(&criti);

  000ff	68 00 00 00 00	 push	 OFFSET ?criti@@3U_RTL_CRITICAL_SECTION@@A ; criti
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN1@CloseClien:

; 1329 :     return;
; 1330 : }

  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
?CloseClient@@YAXH@Z ENDP				; CloseClient
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?UpdateCompletionPort@@YAHIHH@Z
_TEXT	SEGMENT
_cp$ = -8						; size = 4
_lpPerSocketContext$ = -4				; size = 4
_sd$ = 8						; size = 4
_ClientIndex$ = 12					; size = 4
_bAddToList$ = 16					; size = 4
?UpdateCompletionPort@@YAHIHH@Z PROC			; UpdateCompletionPort, COMDAT

; 1199 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1200 :     LPPER_SOCKET_CONTEXT lpPerSocketContext = NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lpPerSocketContext$[ebp], 0

; 1201 : 	HANDLE			cp;
; 1202 :     cp = CreateIoCompletionPort((HANDLE)sd, g_CompletionPort, (DWORD)ClientIndex, 0); 

  00010	6a 00		 push	 0
  00012	8b 45 0c	 mov	 eax, DWORD PTR _ClientIndex$[ebp]
  00015	50		 push	 eax
  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_CompletionPort@@3PAXA ; g_CompletionPort
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR _sd$[ebp]
  00020	52		 push	 edx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16
  00027	89 45 f8	 mov	 DWORD PTR _cp$[ebp], eax

; 1203 :     
; 1204 : 	if (cp == NULL)

  0002a	83 7d f8 00	 cmp	 DWORD PTR _cp$[ebp], 0
  0002e	75 19		 jne	 SHORT $LN2@UpdateComp

; 1205 : 	{
; 1206 :         LogAdd("CreateIoCompletionPort: %d", GetLastError());

  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HHALLDPN@CreateIoCompletionPort?3?5?$CFd@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00042	83 c4 08	 add	 esp, 8

; 1207 :         return FALSE;

  00045	33 c0		 xor	 eax, eax
  00047	eb 20		 jmp	 SHORT $LN1@UpdateComp
$LN2@UpdateComp:

; 1208 : 	}
; 1209 : 	gObj[ClientIndex].PerSocketContext->dwIOCount = 0;

  00049	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _ClientIndex$[ebp], 7072
  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00056	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  0005a	c7 82 68 00 02
	00 00 00 00 00	 mov	 DWORD PTR [edx+131176], 0

; 1210 :     return TRUE; 

  00064	b8 01 00 00 00	 mov	 eax, 1
$LN1@UpdateComp:

; 1211 : } 

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?UpdateCompletionPort@@YAHIHH@Z ENDP			; UpdateCompletionPort
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?CreateGIocp@@YAHH@Z
_TEXT	SEGMENT
_ThreadID$ = -4						; size = 4
_server_port$ = 8					; size = 4
?CreateGIocp@@YAHH@Z PROC				; CreateGIocp, COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 139  : 	DWORD	ThreadID;
; 140  : 
; 141  : #ifdef PACKET_KUZIMO
; 142  : 	WriteLog("PacketLog.txt", "\n\n\n**************************** Server Start\n");
; 143  : #endif
; 144  : 	
; 145  : 	g_ServerPort = server_port;

  00009	8b 45 08	 mov	 eax, DWORD PTR _server_port$[ebp]
  0000c	a3 00 00 00 00	 mov	 DWORD PTR ?g_ServerPort@@3HA, eax ; g_ServerPort

; 146  : 	if ((g_IocpThreadHandle = CreateThread(NULL, 0, IocpServerWorker, (LPVOID)NULL,
; 147  : 			0, &ThreadID)) == NULL)

  00011	8d 45 fc	 lea	 eax, DWORD PTR _ThreadID$[ebp]
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ?IocpServerWorker@@YGKPAX@Z ; IocpServerWorker
  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00028	a3 00 00 00 00	 mov	 DWORD PTR ?g_IocpThreadHandle@@3PAXA, eax ; g_IocpThreadHandle
  0002d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_IocpThreadHandle@@3PAXA, 0 ; g_IocpThreadHandle
  00034	75 19		 jne	 SHORT $LN2@CreateGIoc

; 148  : 	{
; 149  : 		LogAdd("CreateThread() failed with error %d", GetLastError());

  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0003c	50		 push	 eax
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HNFLFMJK@CreateThread?$CI?$CJ?5failed?5with?5erro@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00048	83 c4 08	 add	 esp, 8

; 150  : 		return FALSE;

  0004b	33 c0		 xor	 eax, eax
  0004d	eb 05		 jmp	 SHORT $LN1@CreateGIoc
$LN2@CreateGIoc:

; 151  : 	}
; 152  : 	return TRUE;

  0004f	b8 01 00 00 00	 mov	 eax, 1
$LN1@CreateGIoc:

; 153  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?CreateGIocp@@YAHH@Z ENDP				; CreateGIocp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?GiocpDelete@@YAXXZ
_TEXT	SEGMENT
$T1 = -68						; size = 4
?GiocpDelete@@YAXXZ PROC				; GiocpDelete, COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 71   : 	delete ExSendBuf;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ExSendBuf@@3PAEA ; ExSendBuf
  0000e	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00011	6a 01		 push	 1
  00013	8b 4d bc	 mov	 ecx, DWORD PTR $T1[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8

; 72   : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GiocpDelete@@YAXXZ ENDP				; GiocpDelete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?GiocpInit@@YAXXZ
_TEXT	SEGMENT
$T1 = -68						; size = 4
?GiocpInit@@YAXXZ PROC					; GiocpInit, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 66   : 	ExSendBuf = new BYTE [MAX_BUFF_SIZE*2];

  00009	68 00 80 00 00	 push	 32768			; 00008000H
  0000e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00013	83 c4 04	 add	 esp, 4
  00016	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00019	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	a3 00 00 00 00	 mov	 DWORD PTR ?ExSendBuf@@3PAEA, eax ; ExSendBuf

; 67   : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GiocpInit@@YAXXZ ENDP					; GiocpInit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 535  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 536  :             return _time64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __time64
  00012	83 c4 04	 add	 esp, 4

; 537  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\giocp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
