; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CItemBagAttrEx@@QAE@XZ			; CItemBagAttrEx::CItemBagAttrEx
PUBLIC	??0_GAMBLING_RATE@@QAE@XZ			; _GAMBLING_RATE::_GAMBLING_RATE
PUBLIC	??0CGamblingItemBag@@QAE@XZ			; CGamblingItemBag::CGamblingItemBag
PUBLIC	??1CGamblingItemBag@@UAE@XZ			; CGamblingItemBag::~CGamblingItemBag
PUBLIC	?GetBagCount@CGamblingItemBag@@AAEHXZ		; CGamblingItemBag::GetBagCount
PUBLIC	?GetLevel@CGamblingItemBag@@AAEEH@Z		; CGamblingItemBag::GetLevel
PUBLIC	?GamblingItemBagInit@CGamblingItemBag@@QAEXPAD@Z ; CGamblingItemBag::GamblingItemBagInit
PUBLIC	?LoadItem@CGamblingItemBag@@QAEXPAD@Z		; CGamblingItemBag::LoadItem
PUBLIC	?GetGamblingSystemItem@CGamblingItemBag@@QAEEHEEEE@Z ; CGamblingItemBag::GetGamblingSystemItem
PUBLIC	?GamblingOptionRand@CGamblingItemBag@@QAEEH@Z	; CGamblingItemBag::GamblingOptionRand
PUBLIC	?ExcellentOptionRand@CGamblingItemBag@@QAEEXZ	; CGamblingItemBag::ExcellentOptionRand
PUBLIC	??_GCGamblingItemBag@@UAEPAXI@Z			; CGamblingItemBag::`scalar deleting destructor'
PUBLIC	??_7CGamblingItemBag@@6B@			; CGamblingItemBag::`vftable'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_03JBJLGPFL@end@				; `string'
PUBLIC	??_C@_0BF@KEOMIEDM@Load?5Script?5Error?5?$CFs@	; `string'
PUBLIC	??_R4CGamblingItemBag@@6B@			; CGamblingItemBag::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGamblingItemBag@@@8			; CGamblingItemBag `RTTI Type Descriptor'
PUBLIC	??_R3CGamblingItemBag@@8			; CGamblingItemBag::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGamblingItemBag@@8			; CGamblingItemBag::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGamblingItemBag@@8		; CGamblingItemBag::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_strcmp:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	??_ECGamblingItemBag@@UAEPAXI@Z:PROC		; CGamblingItemBag::`vector deleting destructor'
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z:PROC	; ItemSerialCreateSend
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?GetLargeRand@@YAKXZ:PROC			; GetLargeRand
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@CGamblingItemBag@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGamblingItemBag@@8 DD FLAT:??_R0?AVCGamblingItemBag@@@8 ; CGamblingItemBag::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGamblingItemBag@@8
rdata$r	ENDS
;	COMDAT ??_R2CGamblingItemBag@@8
rdata$r	SEGMENT
??_R2CGamblingItemBag@@8 DD FLAT:??_R1A@?0A@EA@CGamblingItemBag@@8 ; CGamblingItemBag::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGamblingItemBag@@8
rdata$r	SEGMENT
??_R3CGamblingItemBag@@8 DD 00H				; CGamblingItemBag::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGamblingItemBag@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGamblingItemBag@@@8
data$r	SEGMENT
??_R0?AVCGamblingItemBag@@@8 DD FLAT:??_7type_info@@6B@	; CGamblingItemBag `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGamblingItemBag@@', 00H
data$r	ENDS
;	COMDAT ??_R4CGamblingItemBag@@6B@
rdata$r	SEGMENT
??_R4CGamblingItemBag@@6B@ DD 00H			; CGamblingItemBag::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGamblingItemBag@@@8
	DD	FLAT:??_R3CGamblingItemBag@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BF@KEOMIEDM@Load?5Script?5Error?5?$CFs@
CONST	SEGMENT
??_C@_0BF@KEOMIEDM@Load?5Script?5Error?5?$CFs@ DB 'Load Script Error %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end@
CONST	SEGMENT
??_C@_03JBJLGPFL@end@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7CGamblingItemBag@@6B@
CONST	SEGMENT
??_7CGamblingItemBag@@6B@ DD FLAT:??_R4CGamblingItemBag@@6B@ ; CGamblingItemBag::`vftable'
	DD	FLAT:??_ECGamblingItemBag@@UAEPAXI@Z
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\ReadScript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 수정

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCGamblingItemBag@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGamblingItemBag@@UAEPAXI@Z PROC			; CGamblingItemBag::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CGamblingItemBag@@UAE@XZ ; CGamblingItemBag::~CGamblingItemBag
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 7c 07 00 00	 push	 1916			; 0000077cH
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GCGamblingItemBag@@UAEPAXI@Z ENDP			; CGamblingItemBag::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ?ExcellentOptionRand@CGamblingItemBag@@QAEEXZ
_TEXT	SEGMENT
_iSuccessCount$ = -16					; size = 4
_iCount$ = -12						; size = 4
_NOption$ = -5						; size = 1
_this$ = -4						; size = 4
?ExcellentOptionRand@CGamblingItemBag@@QAEEXZ PROC	; CGamblingItemBag::ExcellentOptionRand, COMDAT
; _this$ = ecx

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 536  : 	BYTE NOption=0;

  0000c	c6 45 fb 00	 mov	 BYTE PTR _NOption$[ebp], 0

; 537  : 	int iCount = 0;

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0

; 538  : 	int iSuccessCount = 0;

  00017	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iSuccessCount$[ebp], 0
$LN2@ExcellentO:

; 539  : 
; 540  : 	while( TRUE )

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	74 71		 je	 SHORT $LN3@ExcellentO

; 541  : 	{
; 542  : 		if( m_iNormalExOptionRate[iCount] >= (GetLargeRand()%1000000) )

  00027	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  0002c	33 d2		 xor	 edx, edx
  0002e	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00033	f7 f1		 div	 ecx
  00035	8b 45 f4	 mov	 eax, DWORD PTR _iCount$[ebp]
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	39 94 81 48 02
	00 00		 cmp	 DWORD PTR [ecx+eax*4+584], edx
  00042	72 1c		 jb	 SHORT $LN4@ExcellentO

; 543  : 		{
; 544  : 			NOption |= 1<<iCount;

  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	8b 4d f4	 mov	 ecx, DWORD PTR _iCount$[ebp]
  0004c	d3 e0		 shl	 eax, cl
  0004e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _NOption$[ebp]
  00052	0b c8		 or	 ecx, eax
  00054	88 4d fb	 mov	 BYTE PTR _NOption$[ebp], cl

; 545  : 			++iSuccessCount;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _iSuccessCount$[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 45 f0	 mov	 DWORD PTR _iSuccessCount$[ebp], eax
$LN4@ExcellentO:

; 546  : 		}
; 547  : 
; 548  : 		++iCount;

  00060	8b 45 f4	 mov	 eax, DWORD PTR _iCount$[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 f4	 mov	 DWORD PTR _iCount$[ebp], eax

; 549  : 
; 550  : 		if( iSuccessCount == 0 )			// 옵션이 안 붙었으므로 다시 루프 돌림

  00069	83 7d f0 00	 cmp	 DWORD PTR _iSuccessCount$[ebp], 0
  0006d	75 0f		 jne	 SHORT $LN5@ExcellentO

; 551  : 		{
; 552  : 			if( iCount >= EX_OPTION_COUNT )

  0006f	83 7d f4 06	 cmp	 DWORD PTR _iCount$[ebp], 6
  00073	7c 07		 jl	 SHORT $LN7@ExcellentO

; 553  : 				iCount = 0;

  00075	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
$LN7@ExcellentO:

; 554  : 		}

  0007c	eb 18		 jmp	 SHORT $LN6@ExcellentO
$LN5@ExcellentO:

; 555  : 		else if( iSuccessCount==1 )			// 옵션 한개짜리 엑템 완성

  0007e	83 7d f0 01	 cmp	 DWORD PTR _iSuccessCount$[ebp], 1
  00082	75 0a		 jne	 SHORT $LN8@ExcellentO

; 556  : 		{
; 557  : 			if( iCount >= EX_OPTION_COUNT )

  00084	83 7d f4 06	 cmp	 DWORD PTR _iCount$[ebp], 6
  00088	7c 02		 jl	 SHORT $LN10@ExcellentO

; 558  : 				break;

  0008a	eb 0c		 jmp	 SHORT $LN3@ExcellentO
$LN10@ExcellentO:

; 559  : 		}

  0008c	eb 08		 jmp	 SHORT $LN6@ExcellentO
$LN8@ExcellentO:

; 560  : 		else if( iSuccessCount >= 2 )		// 옵션 두개 붙었으므로 바로 루프 종료

  0008e	83 7d f0 02	 cmp	 DWORD PTR _iSuccessCount$[ebp], 2
  00092	7c 02		 jl	 SHORT $LN6@ExcellentO

; 561  : 			break;

  00094	eb 02		 jmp	 SHORT $LN3@ExcellentO
$LN6@ExcellentO:

; 562  : 	}

  00096	eb 86		 jmp	 SHORT $LN2@ExcellentO
$LN3@ExcellentO:

; 563  : 		
; 564  : 	return NOption;

  00098	8a 45 fb	 mov	 al, BYTE PTR _NOption$[ebp]

; 565  : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?ExcellentOptionRand@CGamblingItemBag@@QAEEXZ ENDP	; CGamblingItemBag::ExcellentOptionRand
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ?GamblingOptionRand@CGamblingItemBag@@QAEEH@Z
_TEXT	SEGMENT
_iCount$ = -16						; size = 4
_iFailCount$ = -12					; size = 4
_NOption$ = -5						; size = 1
_this$ = -4						; size = 4
_iOptionCount$ = 8					; size = 4
?GamblingOptionRand@CGamblingItemBag@@QAEEH@Z PROC	; CGamblingItemBag::GamblingOptionRand, COMDAT
; _this$ = ecx

; 499  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 500  : 	BYTE NOption=0;

  0000c	c6 45 fb 00	 mov	 BYTE PTR _NOption$[ebp], 0

; 501  : 	int iFailCount = 0;

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iFailCount$[ebp], 0

; 502  : 	int iCount = 0;

  00017	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
$LN2@GamblingOp:

; 503  : 
; 504  : 	while( TRUE )

  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	0f 84 87 00 00
	00		 je	 $LN3@GamblingOp

; 505  : 	{
; 506  : 		if( m_iGamblingExOptionRate[iCount] >= (GetLargeRand()%1000000) )

  0002b	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  00030	33 d2		 xor	 edx, edx
  00032	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00037	f7 f1		 div	 ecx
  00039	8b 45 f0	 mov	 eax, DWORD PTR _iCount$[ebp]
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	39 94 81 30 02
	00 00		 cmp	 DWORD PTR [ecx+eax*4+560], edx
  00046	72 15		 jb	 SHORT $LN6@GamblingOp

; 507  : 		{
; 508  : 			NOption |= 1<<iCount;

  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _iCount$[ebp]
  00050	d3 e0		 shl	 eax, cl
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _NOption$[ebp]
  00056	0b c8		 or	 ecx, eax
  00058	88 4d fb	 mov	 BYTE PTR _NOption$[ebp], cl

; 509  : 		}

  0005b	eb 09		 jmp	 SHORT $LN7@GamblingOp
$LN6@GamblingOp:

; 510  : 		else
; 511  : 			++iFailCount;

  0005d	8b 45 f4	 mov	 eax, DWORD PTR _iFailCount$[ebp]
  00060	83 c0 01	 add	 eax, 1
  00063	89 45 f4	 mov	 DWORD PTR _iFailCount$[ebp], eax
$LN7@GamblingOp:

; 512  : 
; 513  : 		if( iFailCount >= (EX_OPTION_COUNT-iOptionCount) )

  00066	b8 06 00 00 00	 mov	 eax, 6
  0006b	2b 45 08	 sub	 eax, DWORD PTR _iOptionCount$[ebp]
  0006e	39 45 f4	 cmp	 DWORD PTR _iFailCount$[ebp], eax
  00071	7c 31		 jl	 SHORT $LN8@GamblingOp
$LN4@GamblingOp:

; 514  : 		{
; 515  : 			while( TRUE )

  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	85 c0		 test	 eax, eax
  0007a	74 26		 je	 SHORT $LN5@GamblingOp

; 516  : 			{
; 517  : 				++iCount;

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _iCount$[ebp]
  0007f	83 c0 01	 add	 eax, 1
  00082	89 45 f0	 mov	 DWORD PTR _iCount$[ebp], eax

; 518  : 
; 519  : 				if( iCount >= EX_OPTION_COUNT )

  00085	83 7d f0 06	 cmp	 DWORD PTR _iCount$[ebp], 6
  00089	7c 02		 jl	 SHORT $LN9@GamblingOp

; 520  : 					break;

  0008b	eb 15		 jmp	 SHORT $LN5@GamblingOp
$LN9@GamblingOp:

; 521  : 
; 522  : 				NOption |= 1<<iCount;

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	8b 4d f0	 mov	 ecx, DWORD PTR _iCount$[ebp]
  00095	d3 e0		 shl	 eax, cl
  00097	0f b6 4d fb	 movzx	 ecx, BYTE PTR _NOption$[ebp]
  0009b	0b c8		 or	 ecx, eax
  0009d	88 4d fb	 mov	 BYTE PTR _NOption$[ebp], cl

; 523  : 			}

  000a0	eb d1		 jmp	 SHORT $LN4@GamblingOp
$LN5@GamblingOp:

; 524  : 
; 525  : 			break;

  000a2	eb 0e		 jmp	 SHORT $LN3@GamblingOp
$LN8@GamblingOp:

; 526  : 		}
; 527  : 
; 528  : 		++iCount;

  000a4	8b 45 f0	 mov	 eax, DWORD PTR _iCount$[ebp]
  000a7	83 c0 01	 add	 eax, 1
  000aa	89 45 f0	 mov	 DWORD PTR _iCount$[ebp], eax

; 529  : 	}

  000ad	e9 6c ff ff ff	 jmp	 $LN2@GamblingOp
$LN3@GamblingOp:

; 530  : 	
; 531  : 	return NOption;

  000b2	8a 45 fb	 mov	 al, BYTE PTR _NOption$[ebp]

; 532  : }

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
?GamblingOptionRand@CGamblingItemBag@@QAEEH@Z ENDP	; CGamblingItemBag::GamblingOptionRand
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ?GetGamblingSystemItem@CGamblingItemBag@@QAEEHEEEE@Z
_TEXT	SEGMENT
tv229 = -160						; size = 4
tv211 = -160						; size = 4
_iOptionTemp$1 = -92					; size = 4
_i$2 = -88						; size = 4
_iSelectedRate$3 = -84					; size = 4
_dwRandTemp$4 = -80					; size = 4
_iSelectedGroup$5 = -76					; size = 4
_iBagPositionEnd$6 = -72				; size = 4
_iBagPositionStart$7 = -68				; size = 4
_iCount$8 = -64						; size = 4
_dwExOptionTemp$9 = -60					; size = 4
_dwOptionTemp$10 = -56					; size = 4
_lpObj$ = -52						; size = 4
_iExOption$ = -48					; size = 4
_iDropItemRate$ = -44					; size = 4
_iDropItemNum$ = -40					; size = 4
_iOption3$ = -36					; size = 4
_iOption2$ = -32					; size = 4
_iOption1$ = -28					; size = 4
_Y$ = -24						; size = 4
_X$ = -20						; size = 4
_iLevel$ = -16						; size = 4
_iType$ = -12						; size = 4
_fDur$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_btMapNumber$ = 12					; size = 1
_cX$ = 16						; size = 1
_cY$ = 20						; size = 1
_btItemType$ = 24					; size = 1
?GetGamblingSystemItem@CGamblingItemBag@@QAEEHEEEE@Z PROC ; CGamblingItemBag::GetGamblingSystemItem, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 270  : #ifdef ADD_IS_ENABLED_GAMBLING_20090504
; 271  : 	if( g_bGamblingSystem == FALSE )
; 272  : 	{
; 273  : 		return FALSE;
; 274  : 	}
; 275  : #endif // ADD_IS_ENABLED_GAMBLING_20090504
; 276  : 
; 277  : 	if( !m_bLoad )					// 아이템 스크립트가 로드되지 않았다

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00016	75 07		 jne	 SHORT $LN11@GetGamblin

; 278  : 	{
; 279  : 		return FALSE;

  00018	32 c0		 xor	 al, al
  0001a	e9 f7 06 00 00	 jmp	 $LN1@GetGamblin
$LN11@GetGamblin:

; 280  : 	}
; 281  : 	
; 282  : 	float fDur		= 0;

  0001f	0f 57 c0	 xorps	 xmm0, xmm0
  00022	f3 0f 11 45 f8	 movss	 DWORD PTR _fDur$[ebp], xmm0

; 283  : 	int iType		= 0;

  00027	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iType$[ebp], 0

; 284  : 	int iLevel		= 0;

  0002e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iLevel$[ebp], 0

; 285  : 	int X			= 0;

  00035	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _X$[ebp], 0

; 286  : 	int Y			= 0;

  0003c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Y$[ebp], 0

; 287  : 	int iOption1	= 0;

  00043	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iOption1$[ebp], 0

; 288  : 	int iOption2	= 0;

  0004a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iOption2$[ebp], 0

; 289  : 	int iOption3	= 0;

  00051	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iOption3$[ebp], 0

; 290  : 	int iDropItemNum	= 0;

  00058	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _iDropItemNum$[ebp], 0

; 291  : 	int	iDropItemRate	= 0;

  0005f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iDropItemRate$[ebp], 0

; 292  : 	int iExOption	= 0;

  00066	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _iExOption$[ebp], 0

; 293  : 	
; 294  : 	
; 295  : 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  0006d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00074	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007a	89 45 cc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 296  : 
; 297  : 	if( GetBagCount() > 0 )

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?GetBagCount@CGamblingItemBag@@AAEHXZ ; CGamblingItemBag::GetBagCount
  00085	85 c0		 test	 eax, eax
  00087	0f 8e 87 06 00
	00		 jle	 $LN12@GetGamblin

; 298  : 	{
; 299  : 		if( m_iGamblingItemGetRate[btItemType] >= GetLargeRand()%1000000 )

  0008d	0f b6 75 18	 movzx	 esi, BYTE PTR _btItemType$[ebp]
  00091	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  00096	33 d2		 xor	 edx, edx
  00098	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0009d	f7 f1		 div	 ecx
  0009f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	39 94 b0 0c 02
	00 00		 cmp	 DWORD PTR [eax+esi*4+524], edx
  000a9	0f 82 b7 02 00
	00		 jb	 $LN13@GetGamblin

; 300  : 		{
; 301  : 			// 겜블링 아이템이다.
; 302  : 			iLevel = 0;

  000af	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iLevel$[ebp], 0

; 303  : 			fDur = 0;

  000b6	0f 57 c0	 xorps	 xmm0, xmm0
  000b9	f3 0f 11 45 f8	 movss	 DWORD PTR _fDur$[ebp], xmm0

; 304  : 			iOption1 = 1;

  000be	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _iOption1$[ebp], 1

; 305  : 			iOption2 = 0;

  000c5	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iOption2$[ebp], 0

; 306  : 
; 307  : 			// 추가 옵션 설정
; 308  : 			DWORD dwOptionTemp = GetLargeRand()%1000000;

  000cc	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  000d1	33 d2		 xor	 edx, edx
  000d3	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  000d8	f7 f1		 div	 ecx
  000da	89 55 c8	 mov	 DWORD PTR _dwOptionTemp$10[ebp], edx

; 309  : 			
; 310  : 			if( dwOptionTemp <= m_iAddOption[ADD_OPTION_PLUS_4] )

  000dd	b8 04 00 00 00	 mov	 eax, 4
  000e2	6b c8 00	 imul	 ecx, eax, 0
  000e5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	8b 45 c8	 mov	 eax, DWORD PTR _dwOptionTemp$10[ebp]
  000eb	3b 84 0a fc 01
	00 00		 cmp	 eax, DWORD PTR [edx+ecx+508]
  000f2	77 0c		 ja	 SHORT $LN15@GetGamblin

; 311  : 			{
; 312  : 				iOption3 = 1;

  000f4	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _iOption3$[ebp], 1

; 313  : 			}

  000fb	e9 cb 00 00 00	 jmp	 $LN21@GetGamblin
$LN15@GetGamblin:

; 314  : 			else if( dwOptionTemp <= m_iAddOption[ADD_OPTION_PLUS_4]+m_iAddOption[ADD_OPTION_PLUS_8] )

  00100	b8 04 00 00 00	 mov	 eax, 4
  00105	6b c8 00	 imul	 ecx, eax, 0
  00108	ba 04 00 00 00	 mov	 edx, 4
  0010d	c1 e2 00	 shl	 edx, 0
  00110	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00113	8b 8c 08 fc 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+508]
  0011a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011d	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  00124	39 4d c8	 cmp	 DWORD PTR _dwOptionTemp$10[ebp], ecx
  00127	77 0c		 ja	 SHORT $LN17@GetGamblin

; 315  : 			{
; 316  : 				iOption3 = 2;

  00129	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _iOption3$[ebp], 2

; 317  : 			}

  00130	e9 96 00 00 00	 jmp	 $LN21@GetGamblin
$LN17@GetGamblin:

; 318  : 			else if( dwOptionTemp <= m_iAddOption[ADD_OPTION_PLUS_4]+m_iAddOption[ADD_OPTION_PLUS_8]

  00135	b8 04 00 00 00	 mov	 eax, 4
  0013a	6b c8 00	 imul	 ecx, eax, 0
  0013d	ba 04 00 00 00	 mov	 edx, 4
  00142	c1 e2 00	 shl	 edx, 0
  00145	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00148	8b 8c 08 fc 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+508]
  0014f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00152	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  00159	ba 04 00 00 00	 mov	 edx, 4
  0015e	d1 e2		 shl	 edx, 1
  00160	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00163	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  0016a	39 4d c8	 cmp	 DWORD PTR _dwOptionTemp$10[ebp], ecx
  0016d	77 09		 ja	 SHORT $LN19@GetGamblin

; 319  : 				+m_iAddOption[ADD_OPTION_PLUS_12])
; 320  : 			{
; 321  : 				iOption3 = 3;

  0016f	c7 45 dc 03 00
	00 00		 mov	 DWORD PTR _iOption3$[ebp], 3

; 322  : 			}

  00176	eb 53		 jmp	 SHORT $LN21@GetGamblin
$LN19@GetGamblin:

; 323  : 			else if( dwOptionTemp <= m_iAddOption[ADD_OPTION_PLUS_4]+m_iAddOption[ADD_OPTION_PLUS_8]

  00178	b8 04 00 00 00	 mov	 eax, 4
  0017d	6b c8 00	 imul	 ecx, eax, 0
  00180	ba 04 00 00 00	 mov	 edx, 4
  00185	c1 e2 00	 shl	 edx, 0
  00188	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018b	8b 8c 08 fc 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+508]
  00192	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00195	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  0019c	ba 04 00 00 00	 mov	 edx, 4
  001a1	d1 e2		 shl	 edx, 1
  001a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a6	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  001ad	ba 04 00 00 00	 mov	 edx, 4
  001b2	6b c2 03	 imul	 eax, edx, 3
  001b5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001b8	03 8c 02 fc 01
	00 00		 add	 ecx, DWORD PTR [edx+eax+508]
  001bf	39 4d c8	 cmp	 DWORD PTR _dwOptionTemp$10[ebp], ecx
  001c2	77 07		 ja	 SHORT $LN21@GetGamblin

; 324  : 				+m_iAddOption[ADD_OPTION_PLUS_12]+m_iAddOption[ADD_OPTION_PLUS_16] )
; 325  : 			{
; 326  : 				iOption3 = 4;

  001c4	c7 45 dc 04 00
	00 00		 mov	 DWORD PTR _iOption3$[ebp], 4
$LN21@GetGamblin:

; 327  : 			}
; 328  : 
; 329  : 
; 330  : 			DWORD dwExOptionTemp = GetLargeRand()%1000000;

  001cb	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  001d0	33 d2		 xor	 edx, edx
  001d2	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  001d7	f7 f1		 div	 ecx
  001d9	89 55 c4	 mov	 DWORD PTR _dwExOptionTemp$9[ebp], edx

; 331  : 
; 332  : 			if( dwExOptionTemp <= m_iGamblingOptionCountRate[ATTACH_1_OPTION_RATE] )

  001dc	b8 04 00 00 00	 mov	 eax, 4
  001e1	6b c8 00	 imul	 ecx, eax, 0
  001e4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001e7	8b 45 c4	 mov	 eax, DWORD PTR _dwExOptionTemp$9[ebp]
  001ea	3b 84 0a 20 02
	00 00		 cmp	 eax, DWORD PTR [edx+ecx+544]
  001f1	77 15		 ja	 SHORT $LN22@GetGamblin

; 333  : 			{
; 334  : 				iExOption = GamblingOptionRand( ATTACH_1_OPTION_RATE+1 );

  001f3	6a 01		 push	 1
  001f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f8	e8 00 00 00 00	 call	 ?GamblingOptionRand@CGamblingItemBag@@QAEEH@Z ; CGamblingItemBag::GamblingOptionRand
  001fd	0f b6 c0	 movzx	 eax, al
  00200	89 45 d0	 mov	 DWORD PTR _iExOption$[ebp], eax

; 335  : 			}

  00203	e9 e6 00 00 00	 jmp	 $LN28@GetGamblin
$LN22@GetGamblin:

; 336  : 			else if( dwExOptionTemp <= m_iGamblingOptionCountRate[ATTACH_1_OPTION_RATE]

  00208	b8 04 00 00 00	 mov	 eax, 4
  0020d	6b c8 00	 imul	 ecx, eax, 0
  00210	ba 04 00 00 00	 mov	 edx, 4
  00215	c1 e2 00	 shl	 edx, 0
  00218	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0021b	8b 8c 08 20 02
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+544]
  00222	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00225	03 8c 10 20 02
	00 00		 add	 ecx, DWORD PTR [eax+edx+544]
  0022c	39 4d c4	 cmp	 DWORD PTR _dwExOptionTemp$9[ebp], ecx
  0022f	77 15		 ja	 SHORT $LN24@GetGamblin

; 337  : 				+ m_iGamblingOptionCountRate[ATTACH_2_OPTION_RATE] )
; 338  : 			{
; 339  : 				iExOption = GamblingOptionRand( ATTACH_2_OPTION_RATE+1 );

  00231	6a 02		 push	 2
  00233	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00236	e8 00 00 00 00	 call	 ?GamblingOptionRand@CGamblingItemBag@@QAEEH@Z ; CGamblingItemBag::GamblingOptionRand
  0023b	0f b6 c0	 movzx	 eax, al
  0023e	89 45 d0	 mov	 DWORD PTR _iExOption$[ebp], eax

; 340  : 			}

  00241	e9 a8 00 00 00	 jmp	 $LN28@GetGamblin
$LN24@GetGamblin:

; 341  : 			else if( dwExOptionTemp <= m_iGamblingOptionCountRate[ATTACH_1_OPTION_RATE]

  00246	b8 04 00 00 00	 mov	 eax, 4
  0024b	6b c8 00	 imul	 ecx, eax, 0
  0024e	ba 04 00 00 00	 mov	 edx, 4
  00253	c1 e2 00	 shl	 edx, 0
  00256	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00259	8b 8c 08 20 02
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+544]
  00260	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00263	03 8c 10 20 02
	00 00		 add	 ecx, DWORD PTR [eax+edx+544]
  0026a	ba 04 00 00 00	 mov	 edx, 4
  0026f	d1 e2		 shl	 edx, 1
  00271	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00274	03 8c 10 20 02
	00 00		 add	 ecx, DWORD PTR [eax+edx+544]
  0027b	39 4d c4	 cmp	 DWORD PTR _dwExOptionTemp$9[ebp], ecx
  0027e	77 12		 ja	 SHORT $LN26@GetGamblin

; 342  : 				+ m_iGamblingOptionCountRate[ATTACH_2_OPTION_RATE] + m_iGamblingOptionCountRate[ATTACH_3_OPTION_RATE] )
; 343  : 			{
; 344  : 				iExOption = GamblingOptionRand( ATTACH_3_OPTION_RATE+1 );

  00280	6a 03		 push	 3
  00282	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00285	e8 00 00 00 00	 call	 ?GamblingOptionRand@CGamblingItemBag@@QAEEH@Z ; CGamblingItemBag::GamblingOptionRand
  0028a	0f b6 c0	 movzx	 eax, al
  0028d	89 45 d0	 mov	 DWORD PTR _iExOption$[ebp], eax

; 345  : 			}

  00290	eb 5c		 jmp	 SHORT $LN28@GetGamblin
$LN26@GetGamblin:

; 346  : 			else if( dwExOptionTemp <= m_iGamblingOptionCountRate[ATTACH_1_OPTION_RATE]

  00292	b8 04 00 00 00	 mov	 eax, 4
  00297	6b c8 00	 imul	 ecx, eax, 0
  0029a	ba 04 00 00 00	 mov	 edx, 4
  0029f	c1 e2 00	 shl	 edx, 0
  002a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002a5	8b 8c 08 20 02
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+544]
  002ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002af	03 8c 10 20 02
	00 00		 add	 ecx, DWORD PTR [eax+edx+544]
  002b6	ba 04 00 00 00	 mov	 edx, 4
  002bb	d1 e2		 shl	 edx, 1
  002bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002c0	03 8c 10 20 02
	00 00		 add	 ecx, DWORD PTR [eax+edx+544]
  002c7	ba 04 00 00 00	 mov	 edx, 4
  002cc	6b c2 03	 imul	 eax, edx, 3
  002cf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002d2	03 8c 02 20 02
	00 00		 add	 ecx, DWORD PTR [edx+eax+544]
  002d9	39 4d c4	 cmp	 DWORD PTR _dwExOptionTemp$9[ebp], ecx
  002dc	77 10		 ja	 SHORT $LN28@GetGamblin

; 347  : 				+ m_iGamblingOptionCountRate[ATTACH_2_OPTION_RATE] + m_iGamblingOptionCountRate[ATTACH_3_OPTION_RATE]
; 348  : 				+ m_iGamblingOptionCountRate[ATTACH_4_OPTION_RATE] )
; 349  : 			{
; 350  : 				iExOption = GamblingOptionRand( ATTACH_4_OPTION_RATE+1 );

  002de	6a 04		 push	 4
  002e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002e3	e8 00 00 00 00	 call	 ?GamblingOptionRand@CGamblingItemBag@@QAEEH@Z ; CGamblingItemBag::GamblingOptionRand
  002e8	0f b6 c0	 movzx	 eax, al
  002eb	89 45 d0	 mov	 DWORD PTR _iExOption$[ebp], eax
$LN28@GetGamblin:

; 351  : 			}
; 352  : 
; 353  : 			switch( btItemType )

  002ee	0f b6 45 18	 movzx	 eax, BYTE PTR _btItemType$[ebp]
  002f2	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv211[ebp], eax
  002f8	83 bd 60 ff ff
	ff 04		 cmp	 DWORD PTR tv211[ebp], 4
  002ff	77 60		 ja	 SHORT $LN2@GetGamblin
  00301	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv211[ebp]
  00307	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN58@GetGamblin[ecx*4]
$LN29@GetGamblin:

; 354  : 			{
; 355  : 			case GAMBILNG_ITEM_TYPE_SWORD:
; 356  : 				iType = ItemGetNumberMake( 3, 11 );	// 겜블러의 낫

  0030e	6a 0b		 push	 11			; 0000000bH
  00310	6a 03		 push	 3
  00312	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00317	83 c4 08	 add	 esp, 8
  0031a	89 45 f4	 mov	 DWORD PTR _iType$[ebp], eax

; 357  : 				break;

  0031d	eb 42		 jmp	 SHORT $LN2@GetGamblin
$LN30@GetGamblin:

; 358  : 			case GAMBILNG_ITEM_TYPE_STAFF:
; 359  : 				iType = ItemGetNumberMake( 5, 33 );	// 겜블러의 지팡이

  0031f	6a 21		 push	 33			; 00000021H
  00321	6a 05		 push	 5
  00323	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00328	83 c4 08	 add	 esp, 8
  0032b	89 45 f4	 mov	 DWORD PTR _iType$[ebp], eax

; 360  : 				break;

  0032e	eb 31		 jmp	 SHORT $LN2@GetGamblin
$LN31@GetGamblin:

; 361  : 			case GAMBILNG_ITEM_TYPE_BOW:
; 362  : 				iType = ItemGetNumberMake( 4, 24 );	// 겜블러의 활

  00330	6a 18		 push	 24			; 00000018H
  00332	6a 04		 push	 4
  00334	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00339	83 c4 08	 add	 esp, 8
  0033c	89 45 f4	 mov	 DWORD PTR _iType$[ebp], eax

; 363  : 				break;

  0033f	eb 20		 jmp	 SHORT $LN2@GetGamblin
$LN32@GetGamblin:

; 364  : 			case GAMBILNG_ITEM_TYPE_SCEPTER:
; 365  : 				iType = ItemGetNumberMake( 2, 18 );	// 겜블러의 셉터

  00341	6a 12		 push	 18			; 00000012H
  00343	6a 02		 push	 2
  00345	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0034a	83 c4 08	 add	 esp, 8
  0034d	89 45 f4	 mov	 DWORD PTR _iType$[ebp], eax

; 366  : 				break;

  00350	eb 0f		 jmp	 SHORT $LN2@GetGamblin
$LN33@GetGamblin:

; 367  : 			case GAMBILNG_ITEM_TYPE_STICK:
; 368  : 				iType = ItemGetNumberMake( 5, 34 );	// 겜블러의 스틱

  00352	6a 22		 push	 34			; 00000022H
  00354	6a 05		 push	 5
  00356	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0035b	83 c4 08	 add	 esp, 8
  0035e	89 45 f4	 mov	 DWORD PTR _iType$[ebp], eax
$LN2@GetGamblin:

; 369  : 				break;
; 370  : 			}
; 371  : 		}

  00361	e9 61 03 00 00	 jmp	 $LN56@GetGamblin
$LN13@GetGamblin:

; 372  : 		else	// 겜블링 아이템이 아니다.
; 373  : 		{
; 374  : 			// BagObject[]내에서 해당 아이템 그룹의 범위를 찾는다.
; 375  : 			int iCount = 0;

  00366	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _iCount$8[ebp], 0

; 376  : 			int iBagPositionStart = 0;

  0036d	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _iBagPositionStart$7[ebp], 0

; 377  : 			int iBagPositionEnd = 0;

  00374	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _iBagPositionEnd$6[ebp], 0

; 378  : 			int iSelectedGroup = 0;

  0037b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _iSelectedGroup$5[ebp], 0

; 379  : 			
; 380  : 			switch( btItemType )

  00382	0f b6 45 18	 movzx	 eax, BYTE PTR _btItemType$[ebp]
  00386	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv229[ebp], eax
  0038c	83 bd 60 ff ff
	ff 04		 cmp	 DWORD PTR tv229[ebp], 4
  00393	77 38		 ja	 SHORT $LN4@GetGamblin
  00395	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv229[ebp]
  0039b	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN59@GetGamblin[ecx*4]
$LN34@GetGamblin:

; 381  : 			{
; 382  : 			case GAMBILNG_ITEM_TYPE_SWORD:	iSelectedGroup = ITEM_GROUP_NORMAL_SWORD_1;	break;

  003a2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _iSelectedGroup$5[ebp], 0
  003a9	eb 22		 jmp	 SHORT $LN4@GetGamblin
$LN35@GetGamblin:

; 383  : 			case GAMBILNG_ITEM_TYPE_STAFF:	iSelectedGroup = ITEM_GROUP_NORMAL_STAFF_1;	break;

  003ab	c7 45 b4 05 00
	00 00		 mov	 DWORD PTR _iSelectedGroup$5[ebp], 5
  003b2	eb 19		 jmp	 SHORT $LN4@GetGamblin
$LN36@GetGamblin:

; 384  : 			case GAMBILNG_ITEM_TYPE_BOW:	iSelectedGroup = ITEM_GROUP_NORMAL_BOW_1;	break;

  003b4	c7 45 b4 0a 00
	00 00		 mov	 DWORD PTR _iSelectedGroup$5[ebp], 10 ; 0000000aH
  003bb	eb 10		 jmp	 SHORT $LN4@GetGamblin
$LN37@GetGamblin:

; 385  : 			case GAMBILNG_ITEM_TYPE_SCEPTER:	iSelectedGroup = ITEM_GROUP_NORMAL_SCEPTER_1;	break;

  003bd	c7 45 b4 0f 00
	00 00		 mov	 DWORD PTR _iSelectedGroup$5[ebp], 15 ; 0000000fH
  003c4	eb 07		 jmp	 SHORT $LN4@GetGamblin
$LN38@GetGamblin:

; 386  : 			case GAMBILNG_ITEM_TYPE_STICK:	iSelectedGroup = ITEM_GROUP_NORMAL_STICK_1;	break;

  003c6	c7 45 b4 14 00
	00 00		 mov	 DWORD PTR _iSelectedGroup$5[ebp], 20 ; 00000014H
$LN4@GetGamblin:

; 387  : 			}
; 388  : 
; 389  : 			DWORD dwRandTemp = GetLargeRand()%1000000;

  003cd	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  003d2	33 d2		 xor	 edx, edx
  003d4	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  003d9	f7 f1		 div	 ecx
  003db	89 55 b0	 mov	 DWORD PTR _dwRandTemp$4[ebp], edx

; 390  : 			int iSelectedRate = 0;

  003de	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _iSelectedRate$3[ebp], 0

; 391  : 			for( int i=iSelectedGroup; i<iSelectedGroup+5; ++i )

  003e5	8b 45 b4	 mov	 eax, DWORD PTR _iSelectedGroup$5[ebp]
  003e8	89 45 a8	 mov	 DWORD PTR _i$2[ebp], eax
  003eb	eb 09		 jmp	 SHORT $LN8@GetGamblin
$LN6@GetGamblin:
  003ed	8b 45 a8	 mov	 eax, DWORD PTR _i$2[ebp]
  003f0	83 c0 01	 add	 eax, 1
  003f3	89 45 a8	 mov	 DWORD PTR _i$2[ebp], eax
$LN8@GetGamblin:
  003f6	8b 45 b4	 mov	 eax, DWORD PTR _iSelectedGroup$5[ebp]
  003f9	83 c0 05	 add	 eax, 5
  003fc	39 45 a8	 cmp	 DWORD PTR _i$2[ebp], eax
  003ff	7d 23		 jge	 SHORT $LN7@GetGamblin

; 392  : 			{
; 393  : 				iSelectedRate += m_stGamblingRate[i].iSelectedRate;

  00401	6b 45 a8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00405	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	8b 55 ac	 mov	 edx, DWORD PTR _iSelectedRate$3[ebp]
  0040b	03 54 01 18	 add	 edx, DWORD PTR [ecx+eax+24]
  0040f	89 55 ac	 mov	 DWORD PTR _iSelectedRate$3[ebp], edx

; 394  : 
; 395  : 				if( dwRandTemp <= iSelectedRate )

  00412	8b 45 b0	 mov	 eax, DWORD PTR _dwRandTemp$4[ebp]
  00415	3b 45 ac	 cmp	 eax, DWORD PTR _iSelectedRate$3[ebp]
  00418	77 08		 ja	 SHORT $LN39@GetGamblin

; 396  : 				{
; 397  : 					iSelectedGroup = i;

  0041a	8b 45 a8	 mov	 eax, DWORD PTR _i$2[ebp]
  0041d	89 45 b4	 mov	 DWORD PTR _iSelectedGroup$5[ebp], eax

; 398  : 					break;

  00420	eb 02		 jmp	 SHORT $LN7@GetGamblin
$LN39@GetGamblin:

; 399  : 				}
; 400  : 			}

  00422	eb c9		 jmp	 SHORT $LN6@GetGamblin
$LN7@GetGamblin:

; 401  : 	
; 402  : 			while( TRUE )

  00424	b8 01 00 00 00	 mov	 eax, 1
  00429	85 c0		 test	 eax, eax
  0042b	74 3b		 je	 SHORT $LN10@GetGamblin

; 403  : 			{
; 404  : 				iBagPositionEnd += m_iDropRatePerItemCount[iCount];

  0042d	8b 45 c0	 mov	 eax, DWORD PTR _iCount$8[ebp]
  00430	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00433	8b 55 b8	 mov	 edx, DWORD PTR _iBagPositionEnd$6[ebp]
  00436	03 94 81 64 02
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+612]
  0043d	89 55 b8	 mov	 DWORD PTR _iBagPositionEnd$6[ebp], edx

; 405  : 
; 406  : 				if( iSelectedGroup <= iCount )

  00440	8b 45 b4	 mov	 eax, DWORD PTR _iSelectedGroup$5[ebp]
  00443	3b 45 c0	 cmp	 eax, DWORD PTR _iCount$8[ebp]
  00446	7f 02		 jg	 SHORT $LN40@GetGamblin

; 407  : 					break;

  00448	eb 1e		 jmp	 SHORT $LN10@GetGamblin
$LN40@GetGamblin:

; 408  : 				
; 409  : 				iBagPositionStart += m_iDropRatePerItemCount[iCount];

  0044a	8b 45 c0	 mov	 eax, DWORD PTR _iCount$8[ebp]
  0044d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00450	8b 55 bc	 mov	 edx, DWORD PTR _iBagPositionStart$7[ebp]
  00453	03 94 81 64 02
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+612]
  0045a	89 55 bc	 mov	 DWORD PTR _iBagPositionStart$7[ebp], edx

; 410  : 				
; 411  : 				++iCount;

  0045d	8b 45 c0	 mov	 eax, DWORD PTR _iCount$8[ebp]
  00460	83 c0 01	 add	 eax, 1
  00463	89 45 c0	 mov	 DWORD PTR _iCount$8[ebp], eax

; 412  : 			}

  00466	eb bc		 jmp	 SHORT $LN7@GetGamblin
$LN10@GetGamblin:

; 413  : 
; 414  : 			iDropItemNum = ( (GetLargeRand() % (iBagPositionEnd-iBagPositionStart)) + iBagPositionStart );

  00468	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  0046d	8b 4d b8	 mov	 ecx, DWORD PTR _iBagPositionEnd$6[ebp]
  00470	2b 4d bc	 sub	 ecx, DWORD PTR _iBagPositionStart$7[ebp]
  00473	33 d2		 xor	 edx, edx
  00475	f7 f1		 div	 ecx
  00477	03 55 bc	 add	 edx, DWORD PTR _iBagPositionStart$7[ebp]
  0047a	89 55 d8	 mov	 DWORD PTR _iDropItemNum$[ebp], edx

; 415  : 			
; 416  : 			fDur  = 0;

  0047d	0f 57 c0	 xorps	 xmm0, xmm0
  00480	f3 0f 11 45 f8	 movss	 DWORD PTR _fDur$[ebp], xmm0

; 417  : 			X   = 0;

  00485	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _X$[ebp], 0

; 418  : 			Y   = 0;

  0048c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Y$[ebp], 0

; 419  : 			
; 420  : 			// 레벨
; 421  : 			iLevel	= GetLevel( iDropItemNum );

  00493	8b 45 d8	 mov	 eax, DWORD PTR _iDropItemNum$[ebp]
  00496	50		 push	 eax
  00497	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0049a	e8 00 00 00 00	 call	 ?GetLevel@CGamblingItemBag@@AAEEH@Z ; CGamblingItemBag::GetLevel
  0049f	0f b6 c8	 movzx	 ecx, al
  004a2	89 4d f0	 mov	 DWORD PTR _iLevel$[ebp], ecx

; 422  : 			iType	= ItemGetNumberMake( BagObject[iDropItemNum].m_type, BagObject[iDropItemNum].m_index );

  004a5	8b 45 d8	 mov	 eax, DWORD PTR _iDropItemNum$[ebp]
  004a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ab	0f b6 94 c1 cd
	02 00 00	 movzx	 edx, BYTE PTR [ecx+eax*8+717]
  004b3	52		 push	 edx
  004b4	8b 45 d8	 mov	 eax, DWORD PTR _iDropItemNum$[ebp]
  004b7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ba	0f b6 94 c1 cc
	02 00 00	 movzx	 edx, BYTE PTR [ecx+eax*8+716]
  004c2	52		 push	 edx
  004c3	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  004c8	83 c4 08	 add	 esp, 8
  004cb	89 45 f4	 mov	 DWORD PTR _iType$[ebp], eax

; 423  : 			
; 424  : 			if( iType == -1 )

  004ce	83 7d f4 ff	 cmp	 DWORD PTR _iType$[ebp], -1
  004d2	75 07		 jne	 SHORT $LN41@GetGamblin

; 425  : 			{
; 426  : 				return FALSE;

  004d4	32 c0		 xor	 al, al
  004d6	e9 3b 02 00 00	 jmp	 $LN1@GetGamblin
$LN41@GetGamblin:

; 427  : 			}
; 428  : 
; 429  : 			if( BagObject[iDropItemNum].m_isskill )

  004db	8b 45 d8	 mov	 eax, DWORD PTR _iDropItemNum$[ebp]
  004de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004e1	0f b6 94 c1 d0
	02 00 00	 movzx	 edx, BYTE PTR [ecx+eax*8+720]
  004e9	85 d2		 test	 edx, edx
  004eb	74 22		 je	 SHORT $LN43@GetGamblin

; 430  : 			{
; 431  : 				// 스킬이 붙을수 있으면
; 432  : 				if( m_stGamblingRate[iSelectedGroup].iSkillRate >= (GetLargeRand()%1000000) )

  004ed	6b 75 b4 14	 imul	 esi, DWORD PTR _iSelectedGroup$5[ebp], 20
  004f1	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  004f6	33 d2		 xor	 edx, edx
  004f8	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  004fd	f7 f1		 div	 ecx
  004ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00502	39 54 30 08	 cmp	 DWORD PTR [eax+esi+8], edx
  00506	72 07		 jb	 SHORT $LN43@GetGamblin

; 433  : 					iOption1 = 1;

  00508	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _iOption1$[ebp], 1
$LN43@GetGamblin:

; 434  : 			}
; 435  : 
; 436  : 			if( BagObject[iDropItemNum].m_isluck )

  0050f	8b 45 d8	 mov	 eax, DWORD PTR _iDropItemNum$[ebp]
  00512	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00515	0f b6 94 c1 d1
	02 00 00	 movzx	 edx, BYTE PTR [ecx+eax*8+721]
  0051d	85 d2		 test	 edx, edx
  0051f	74 22		 je	 SHORT $LN45@GetGamblin

; 437  : 			{	
; 438  : 				// 행운이 붙을수 있으면
; 439  : 				if( m_stGamblingRate[iSelectedGroup].iLuckRate >= GetLargeRand()%1000000 )

  00521	6b 75 b4 14	 imul	 esi, DWORD PTR _iSelectedGroup$5[ebp], 20
  00525	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  0052a	33 d2		 xor	 edx, edx
  0052c	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00531	f7 f1		 div	 ecx
  00533	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00536	39 54 30 0c	 cmp	 DWORD PTR [eax+esi+12], edx
  0053a	72 07		 jb	 SHORT $LN45@GetGamblin

; 440  : 					iOption2 = 1;

  0053c	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _iOption2$[ebp], 1
$LN45@GetGamblin:

; 441  : 			}
; 442  : 			
; 443  : 			if( BagObject[iDropItemNum].m_isoption )

  00543	8b 45 d8	 mov	 eax, DWORD PTR _iDropItemNum$[ebp]
  00546	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00549	0f b6 94 c1 d2
	02 00 00	 movzx	 edx, BYTE PTR [ecx+eax*8+722]
  00551	85 d2		 test	 edx, edx
  00553	0f 84 1e 01 00
	00		 je	 $LN54@GetGamblin

; 444  : 			{	// 추가 옵션이 붙을 수 있다면
; 445  : 				if( m_stGamblingRate[iSelectedGroup].iAddOptionRate >= GetLargeRand()%1000000 )

  00559	6b 75 b4 14	 imul	 esi, DWORD PTR _iSelectedGroup$5[ebp], 20
  0055d	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  00562	33 d2		 xor	 edx, edx
  00564	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00569	f7 f1		 div	 ecx
  0056b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0056e	39 54 30 10	 cmp	 DWORD PTR [eax+esi+16], edx
  00572	0f 82 ff 00 00
	00		 jb	 $LN54@GetGamblin

; 446  : 				{
; 447  : 					int iOptionTemp = GetLargeRand()%1000000;

  00578	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  0057d	33 d2		 xor	 edx, edx
  0057f	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00584	f7 f1		 div	 ecx
  00586	89 55 a4	 mov	 DWORD PTR _iOptionTemp$1[ebp], edx

; 448  : 
; 449  : 					if( iOptionTemp <= m_iAddOption[ADD_OPTION_PLUS_4] )

  00589	b8 04 00 00 00	 mov	 eax, 4
  0058e	6b c8 00	 imul	 ecx, eax, 0
  00591	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00594	8b 45 a4	 mov	 eax, DWORD PTR _iOptionTemp$1[ebp]
  00597	3b 84 0a fc 01
	00 00		 cmp	 eax, DWORD PTR [edx+ecx+508]
  0059e	7f 0c		 jg	 SHORT $LN48@GetGamblin

; 450  : 					{
; 451  : 						iOption3 = 1;

  005a0	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _iOption3$[ebp], 1

; 452  : 					}

  005a7	e9 cb 00 00 00	 jmp	 $LN54@GetGamblin
$LN48@GetGamblin:

; 453  : 					else if( iOptionTemp <= m_iAddOption[ADD_OPTION_PLUS_4]+m_iAddOption[ADD_OPTION_PLUS_8] )

  005ac	b8 04 00 00 00	 mov	 eax, 4
  005b1	6b c8 00	 imul	 ecx, eax, 0
  005b4	ba 04 00 00 00	 mov	 edx, 4
  005b9	c1 e2 00	 shl	 edx, 0
  005bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005bf	8b 8c 08 fc 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+508]
  005c6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005c9	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  005d0	39 4d a4	 cmp	 DWORD PTR _iOptionTemp$1[ebp], ecx
  005d3	7f 0c		 jg	 SHORT $LN50@GetGamblin

; 454  : 					{
; 455  : 						iOption3 = 2;

  005d5	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _iOption3$[ebp], 2

; 456  : 					}

  005dc	e9 96 00 00 00	 jmp	 $LN54@GetGamblin
$LN50@GetGamblin:

; 457  : 					else if( iOptionTemp <= m_iAddOption[ADD_OPTION_PLUS_4]+m_iAddOption[ADD_OPTION_PLUS_8]

  005e1	b8 04 00 00 00	 mov	 eax, 4
  005e6	6b c8 00	 imul	 ecx, eax, 0
  005e9	ba 04 00 00 00	 mov	 edx, 4
  005ee	c1 e2 00	 shl	 edx, 0
  005f1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005f4	8b 8c 08 fc 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+508]
  005fb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005fe	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  00605	ba 04 00 00 00	 mov	 edx, 4
  0060a	d1 e2		 shl	 edx, 1
  0060c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0060f	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  00616	39 4d a4	 cmp	 DWORD PTR _iOptionTemp$1[ebp], ecx
  00619	7f 09		 jg	 SHORT $LN52@GetGamblin

; 458  : 											+m_iAddOption[ADD_OPTION_PLUS_12])
; 459  : 					{
; 460  : 						iOption3 = 3;

  0061b	c7 45 dc 03 00
	00 00		 mov	 DWORD PTR _iOption3$[ebp], 3

; 461  : 					}

  00622	eb 53		 jmp	 SHORT $LN54@GetGamblin
$LN52@GetGamblin:

; 462  : 					else if( iOptionTemp <= m_iAddOption[ADD_OPTION_PLUS_4]+m_iAddOption[ADD_OPTION_PLUS_8]

  00624	b8 04 00 00 00	 mov	 eax, 4
  00629	6b c8 00	 imul	 ecx, eax, 0
  0062c	ba 04 00 00 00	 mov	 edx, 4
  00631	c1 e2 00	 shl	 edx, 0
  00634	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00637	8b 8c 08 fc 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+508]
  0063e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00641	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  00648	ba 04 00 00 00	 mov	 edx, 4
  0064d	d1 e2		 shl	 edx, 1
  0064f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00652	03 8c 10 fc 01
	00 00		 add	 ecx, DWORD PTR [eax+edx+508]
  00659	ba 04 00 00 00	 mov	 edx, 4
  0065e	6b c2 03	 imul	 eax, edx, 3
  00661	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00664	03 8c 02 fc 01
	00 00		 add	 ecx, DWORD PTR [edx+eax+508]
  0066b	39 4d a4	 cmp	 DWORD PTR _iOptionTemp$1[ebp], ecx
  0066e	7f 07		 jg	 SHORT $LN54@GetGamblin

; 463  : 											+m_iAddOption[ADD_OPTION_PLUS_12]+m_iAddOption[ADD_OPTION_PLUS_16])
; 464  : 					{
; 465  : 						iOption3 = 4;

  00670	c7 45 dc 04 00
	00 00		 mov	 DWORD PTR _iOption3$[ebp], 4
$LN54@GetGamblin:

; 466  : 					}
; 467  : 				}
; 468  : 			}
; 469  : 			
; 470  : 			if( BagObject[iDropItemNum].m_isexitem )

  00677	8b 45 d8	 mov	 eax, DWORD PTR _iDropItemNum$[ebp]
  0067a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0067d	0f b6 94 c1 d3
	02 00 00	 movzx	 edx, BYTE PTR [ecx+eax*8+723]
  00685	85 d2		 test	 edx, edx
  00687	74 3e		 je	 SHORT $LN56@GetGamblin

; 471  : 			{
; 472  : 				// 엑설런트일 가능성이 있다면
; 473  : 				if( m_stGamblingRate[iSelectedGroup].iExcellentRate >= GetLargeRand()%1000000 )	// 확률 체크

  00689	6b 75 b4 14	 imul	 esi, DWORD PTR _iSelectedGroup$5[ebp], 20
  0068d	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  00692	33 d2		 xor	 edx, edx
  00694	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00699	f7 f1		 div	 ecx
  0069b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0069e	39 54 30 14	 cmp	 DWORD PTR [eax+esi+20], edx
  006a2	72 23		 jb	 SHORT $LN56@GetGamblin

; 474  : 				{
; 475  : 					// 엑템이라는게 확정됨
; 476  : 					iExOption = ExcellentOptionRand();

  006a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a7	e8 00 00 00 00	 call	 ?ExcellentOptionRand@CGamblingItemBag@@QAEEXZ ; CGamblingItemBag::ExcellentOptionRand
  006ac	0f b6 c0	 movzx	 eax, al
  006af	89 45 d0	 mov	 DWORD PTR _iExOption$[ebp], eax

; 477  : 				
; 478  : 					// 액설런트 아이템은 행운이 붙지 않는다.
; 479  : #ifdef MODIFY_GAMBLING_ATTACH_LUCK_OPTION_20090901
; 480  : 					//iOption2 = 0;
; 481  : #else // MODIFY_GAMBLING_ATTACH_LUCK_OPTION_20090901
; 482  : 					iOption2 = 0;

  006b2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iOption2$[ebp], 0

; 483  : #endif // MODIFY_GAMBLING_ATTACH_LUCK_OPTION_20090901
; 484  : 					iOption1 = 1;

  006b9	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _iOption1$[ebp], 1

; 485  : 					
; 486  : 					// 레벨은 0이다.
; 487  : 					iLevel	= 0;

  006c0	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iLevel$[ebp], 0
$LN56@GetGamblin:

; 488  : 				}
; 489  : 			}			
; 490  : 		}
; 491  : 
; 492  : 		ItemSerialCreateSend( lpObj->m_Index, btMapNumber, (BYTE)X, (BYTE)Y, iType, iLevel, (BYTE)fDur, iOption1, iOption2, iOption3, lpObj->m_Index, iExOption );

  006c7	6a 00		 push	 0
  006c9	6a 00		 push	 0
  006cb	0f b6 45 d0	 movzx	 eax, BYTE PTR _iExOption$[ebp]
  006cf	50		 push	 eax
  006d0	8b 4d cc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  006d5	52		 push	 edx
  006d6	0f b6 45 dc	 movzx	 eax, BYTE PTR _iOption3$[ebp]
  006da	50		 push	 eax
  006db	0f b6 4d e0	 movzx	 ecx, BYTE PTR _iOption2$[ebp]
  006df	51		 push	 ecx
  006e0	0f b6 55 e4	 movzx	 edx, BYTE PTR _iOption1$[ebp]
  006e4	52		 push	 edx
  006e5	f3 0f 2c 45 f8	 cvttss2si eax, DWORD PTR _fDur$[ebp]
  006ea	0f b6 c8	 movzx	 ecx, al
  006ed	51		 push	 ecx
  006ee	0f b6 55 f0	 movzx	 edx, BYTE PTR _iLevel$[ebp]
  006f2	52		 push	 edx
  006f3	8b 45 f4	 mov	 eax, DWORD PTR _iType$[ebp]
  006f6	50		 push	 eax
  006f7	0f b6 4d e8	 movzx	 ecx, BYTE PTR _Y$[ebp]
  006fb	51		 push	 ecx
  006fc	0f b6 55 ec	 movzx	 edx, BYTE PTR _X$[ebp]
  00700	52		 push	 edx
  00701	0f b6 45 0c	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  00705	50		 push	 eax
  00706	8b 4d cc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00709	8b 11		 mov	 edx, DWORD PTR [ecx]
  0070b	52		 push	 edx
  0070c	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00711	83 c4 38	 add	 esp, 56			; 00000038H
$LN12@GetGamblin:

; 493  : 	}
; 494  : 	
; 495  : 	return TRUE;

  00714	b0 01		 mov	 al, 1
$LN1@GetGamblin:

; 496  : }

  00716	5f		 pop	 edi
  00717	5e		 pop	 esi
  00718	5b		 pop	 ebx
  00719	8b e5		 mov	 esp, ebp
  0071b	5d		 pop	 ebp
  0071c	c2 14 00	 ret	 20			; 00000014H
  0071f	90		 npad	 1
$LN58@GetGamblin:
  00720	00 00 00 00	 DD	 $LN29@GetGamblin
  00724	00 00 00 00	 DD	 $LN30@GetGamblin
  00728	00 00 00 00	 DD	 $LN31@GetGamblin
  0072c	00 00 00 00	 DD	 $LN32@GetGamblin
  00730	00 00 00 00	 DD	 $LN33@GetGamblin
$LN59@GetGamblin:
  00734	00 00 00 00	 DD	 $LN34@GetGamblin
  00738	00 00 00 00	 DD	 $LN35@GetGamblin
  0073c	00 00 00 00	 DD	 $LN36@GetGamblin
  00740	00 00 00 00	 DD	 $LN37@GetGamblin
  00744	00 00 00 00	 DD	 $LN38@GetGamblin
?GetGamblingSystemItem@CGamblingItemBag@@QAEEHEEEE@Z ENDP ; CGamblingItemBag::GetGamblingSystemItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ?LoadItem@CGamblingItemBag@@QAEXPAD@Z
_TEXT	SEGMENT
_Type$1 = -24						; size = 4
_iCount$ = -20						; size = 4
_nRateCnt$ = -16					; size = 4
_nDropRatePerItemCnt$ = -12				; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_script_file$ = 8					; size = 4
?LoadItem@CGamblingItemBag@@QAEXPAD@Z PROC		; CGamblingItemBag::LoadItem, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 	m_bLoad = FALSE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 76   : 
; 77   : 	m_iBagObjectCount = 0;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 80 60 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+608], 0

; 78   : 
; 79   : 	if((SMDFile=fopen(script_file,"r")) == NULL)	

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00028	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _fopen
  00031	83 c4 08	 add	 esp, 8
  00034	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  00039	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  00040	75 23		 jne	 SHORT $LN16@LoadItem

; 80   : 	{
; 81   : 		LogAdd(lMsg.Get(453), script_file);

  00042	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  00045	50		 push	 eax
  00046	68 c5 01 00 00	 push	 453			; 000001c5H
  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0005d	83 c4 08	 add	 esp, 8

; 82   : 		return ;

  00060	e9 80 05 00 00	 jmp	 $LN1@LoadItem
$LN16@LoadItem:

; 83   : 	}	
; 84   : 	
; 85   : 	SMDToken Token;
; 86   : 	int nDropRatePerItemCnt = 0;

  00065	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nDropRatePerItemCnt$[ebp], 0

; 87   : 	int nRateCnt			= 0;

  0006c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _nRateCnt$[ebp], 0

; 88   : 	int iCount				= 0;

  00073	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
$LN2@LoadItem:

; 89   : 
; 90   : 	while( true )

  0007a	b8 01 00 00 00	 mov	 eax, 1
  0007f	85 c0		 test	 eax, eax
  00081	0f 84 28 05 00
	00		 je	 $LN3@LoadItem

; 91   : 	{
; 92   : 		Token = (*GetToken)();

  00087	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0008c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 93   : 		if(Token == END) break;

  0008f	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00093	75 05		 jne	 SHORT $LN17@LoadItem
  00095	e9 15 05 00 00	 jmp	 $LN3@LoadItem
$LN17@LoadItem:

; 94   : 		
; 95   : 		if(Token == NUMBER)

  0009a	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  0009e	0f 85 06 05 00
	00		 jne	 $LN39@LoadItem

; 96   : 		{
; 97   : 			int Type = (int)TokenNumber;

  000a4	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000ac	89 45 e8	 mov	 DWORD PTR _Type$1[ebp], eax

; 98   : 			if( Type == 0 )

  000af	83 7d e8 00	 cmp	 DWORD PTR _Type$1[ebp], 0
  000b3	0f 85 eb 00 00
	00		 jne	 $LN19@LoadItem

; 99   : 			{	// 아이템에 스킬, 행운, 추가옵션, 엑옵션이 붙을 확 률
; 100  : 				iCount = 0;

  000b9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
$LN4@LoadItem:

; 101  : 
; 102  : 				while(true)

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 d2 00 00
	00		 je	 $LN5@LoadItem

; 103  : 				{
; 104  : 					Token = (*GetToken)();

  000cd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000d2	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 105  : 					if(Token==NAME && strcmp("end",TokenString)==NULL) break;

  000d5	83 7d f8 00	 cmp	 DWORD PTR _Token$[ebp], 0
  000d9	75 1b		 jne	 SHORT $LN21@LoadItem
  000db	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  000e5	e8 00 00 00 00	 call	 _strcmp
  000ea	83 c4 08	 add	 esp, 8
  000ed	85 c0		 test	 eax, eax
  000ef	75 05		 jne	 SHORT $LN21@LoadItem
  000f1	e9 a9 00 00 00	 jmp	 $LN5@LoadItem
$LN21@LoadItem:

; 106  : 
; 107  : 					if( iCount > ITEM_GROUP_MAX )

  000f6	83 7d ec 19	 cmp	 DWORD PTR _iCount$[ebp], 25 ; 00000019H
  000fa	7e 16		 jle	 SHORT $LN22@LoadItem

; 108  : 					{
; 109  : 						MsgBox("Load Script Error %s", script_file);

  000fc	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  000ff	50		 push	 eax
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KEOMIEDM@Load?5Script?5Error?5?$CFs@
  00105	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0010a	83 c4 08	 add	 esp, 8

; 110  : 						break;		// 배열의 범위를 넘어갔다.

  0010d	e9 8d 00 00 00	 jmp	 $LN5@LoadItem
$LN22@LoadItem:

; 111  : 					}
; 112  : 
; 113  : 					m_stGamblingRate[iCount].iSkillRate		= (int)TokenNumber;

  00112	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0011a	6b 4d ec 14	 imul	 ecx, DWORD PTR _iCount$[ebp], 20
  0011e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00121	89 44 0a 08	 mov	 DWORD PTR [edx+ecx+8], eax

; 114  : 					Token = (*GetToken)();	m_stGamblingRate[iCount].iLuckRate		= (int)TokenNumber;

  00125	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0012a	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0012d	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00135	6b 4d ec 14	 imul	 ecx, DWORD PTR _iCount$[ebp], 20
  00139	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0013c	89 44 0a 0c	 mov	 DWORD PTR [edx+ecx+12], eax

; 115  : 					Token = (*GetToken)();	m_stGamblingRate[iCount].iAddOptionRate	= (int)TokenNumber;

  00140	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00145	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00148	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00150	6b 4d ec 14	 imul	 ecx, DWORD PTR _iCount$[ebp], 20
  00154	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00157	89 44 0a 10	 mov	 DWORD PTR [edx+ecx+16], eax

; 116  : 					Token = (*GetToken)();	m_stGamblingRate[iCount].iExcellentRate	= (int)TokenNumber;

  0015b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00160	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00163	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0016b	6b 4d ec 14	 imul	 ecx, DWORD PTR _iCount$[ebp], 20
  0016f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00172	89 44 0a 14	 mov	 DWORD PTR [edx+ecx+20], eax

; 117  : 					Token = (*GetToken)();	m_stGamblingRate[iCount].iSelectedRate	= (int)TokenNumber;

  00176	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0017b	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0017e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00186	6b 4d ec 14	 imul	 ecx, DWORD PTR _iCount$[ebp], 20
  0018a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0018d	89 44 0a 18	 mov	 DWORD PTR [edx+ecx+24], eax

; 118  : 
; 119  : 					++iCount;

  00191	8b 45 ec	 mov	 eax, DWORD PTR _iCount$[ebp]
  00194	83 c0 01	 add	 eax, 1
  00197	89 45 ec	 mov	 DWORD PTR _iCount$[ebp], eax

; 120  : 				}

  0019a	e9 21 ff ff ff	 jmp	 $LN4@LoadItem
$LN5@LoadItem:

; 121  : 				
; 122  : 			}

  0019f	e9 06 04 00 00	 jmp	 $LN39@LoadItem
$LN19@LoadItem:

; 123  : 			else if( Type == 1 )

  001a4	83 7d e8 01	 cmp	 DWORD PTR _Type$1[ebp], 1
  001a8	75 74		 jne	 SHORT $LN23@LoadItem

; 124  : 			{	// 각 추가 옵션이 붙을 확률
; 125  : 				iCount = 0;

  001aa	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
$LN6@LoadItem:

; 126  : 
; 127  : 				while(true)

  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	85 c0		 test	 eax, eax
  001b8	74 5f		 je	 SHORT $LN7@LoadItem

; 128  : 				{
; 129  : 					Token = (*GetToken)();

  001ba	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001bf	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 130  : 					if(Token==NAME && strcmp("end",TokenString)==NULL) break;

  001c2	83 7d f8 00	 cmp	 DWORD PTR _Token$[ebp], 0
  001c6	75 18		 jne	 SHORT $LN25@LoadItem
  001c8	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  001d2	e8 00 00 00 00	 call	 _strcmp
  001d7	83 c4 08	 add	 esp, 8
  001da	85 c0		 test	 eax, eax
  001dc	75 02		 jne	 SHORT $LN25@LoadItem
  001de	eb 39		 jmp	 SHORT $LN7@LoadItem
$LN25@LoadItem:

; 131  : 
; 132  : 					if( iCount > ADD_OPTION_COUNT )

  001e0	83 7d ec 04	 cmp	 DWORD PTR _iCount$[ebp], 4
  001e4	7e 13		 jle	 SHORT $LN26@LoadItem

; 133  : 					{
; 134  : 						MsgBox("Load Script Error %s", script_file);

  001e6	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  001e9	50		 push	 eax
  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KEOMIEDM@Load?5Script?5Error?5?$CFs@
  001ef	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  001f4	83 c4 08	 add	 esp, 8

; 135  : 						break;		// 배열의 범위를 넘어갔다.

  001f7	eb 20		 jmp	 SHORT $LN7@LoadItem
$LN26@LoadItem:

; 136  : 					}
; 137  : 
; 138  : 					m_iAddOption[iCount]	= (int)TokenNumber;

  001f9	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00201	8b 4d ec	 mov	 ecx, DWORD PTR _iCount$[ebp]
  00204	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00207	89 84 8a fc 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+508], eax

; 139  : 
; 140  : 					++iCount;

  0020e	8b 45 ec	 mov	 eax, DWORD PTR _iCount$[ebp]
  00211	83 c0 01	 add	 eax, 1
  00214	89 45 ec	 mov	 DWORD PTR _iCount$[ebp], eax

; 141  : 				}

  00217	eb 98		 jmp	 SHORT $LN6@LoadItem
$LN7@LoadItem:

; 142  : 			}

  00219	e9 8c 03 00 00	 jmp	 $LN39@LoadItem
$LN23@LoadItem:

; 143  : 			else if( Type == 2 )

  0021e	83 7d e8 02	 cmp	 DWORD PTR _Type$1[ebp], 2
  00222	75 74		 jne	 SHORT $LN27@LoadItem

; 144  : 			{	// 각 타입별 겜블링 아이템 나올 확률
; 145  : 				iCount = 0;

  00224	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
$LN8@LoadItem:

; 146  : 
; 147  : 				while(true)

  0022b	b8 01 00 00 00	 mov	 eax, 1
  00230	85 c0		 test	 eax, eax
  00232	74 5f		 je	 SHORT $LN9@LoadItem

; 148  : 				{
; 149  : 					Token = (*GetToken)();

  00234	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00239	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 150  : 					if(Token==NAME && strcmp("end",TokenString)==NULL) break;

  0023c	83 7d f8 00	 cmp	 DWORD PTR _Token$[ebp], 0
  00240	75 18		 jne	 SHORT $LN29@LoadItem
  00242	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00247	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  0024c	e8 00 00 00 00	 call	 _strcmp
  00251	83 c4 08	 add	 esp, 8
  00254	85 c0		 test	 eax, eax
  00256	75 02		 jne	 SHORT $LN29@LoadItem
  00258	eb 39		 jmp	 SHORT $LN9@LoadItem
$LN29@LoadItem:

; 151  : 					
; 152  : 					if( iCount > GAMBILNG_ITEM_TYPE_COUNT )

  0025a	83 7d ec 05	 cmp	 DWORD PTR _iCount$[ebp], 5
  0025e	7e 13		 jle	 SHORT $LN30@LoadItem

; 153  : 					{
; 154  : 						MsgBox("Load Script Error %s", script_file);

  00260	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  00263	50		 push	 eax
  00264	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KEOMIEDM@Load?5Script?5Error?5?$CFs@
  00269	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0026e	83 c4 08	 add	 esp, 8

; 155  : 						break;		// 배열의 범위를 넘어갔다.

  00271	eb 20		 jmp	 SHORT $LN9@LoadItem
$LN30@LoadItem:

; 156  : 					}
; 157  : 					
; 158  : 					m_iGamblingItemGetRate[iCount]	= (int)TokenNumber;

  00273	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0027b	8b 4d ec	 mov	 ecx, DWORD PTR _iCount$[ebp]
  0027e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00281	89 84 8a 0c 02
	00 00		 mov	 DWORD PTR [edx+ecx*4+524], eax

; 159  : 					
; 160  : 					++iCount;

  00288	8b 45 ec	 mov	 eax, DWORD PTR _iCount$[ebp]
  0028b	83 c0 01	 add	 eax, 1
  0028e	89 45 ec	 mov	 DWORD PTR _iCount$[ebp], eax

; 161  : 				}

  00291	eb 98		 jmp	 SHORT $LN8@LoadItem
$LN9@LoadItem:

; 162  : 			}

  00293	e9 12 03 00 00	 jmp	 $LN39@LoadItem
$LN27@LoadItem:

; 163  : 			else if( Type == 3 )

  00298	83 7d e8 03	 cmp	 DWORD PTR _Type$1[ebp], 3
  0029c	75 74		 jne	 SHORT $LN31@LoadItem

; 164  : 			{	// 겜블링 아이템에 옵션이 갯수마다 붙을 확률 ( 총합은 10000이 되야함)
; 165  : 				iCount = 0;

  0029e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
$LN10@LoadItem:

; 166  : 
; 167  : 				while(true)

  002a5	b8 01 00 00 00	 mov	 eax, 1
  002aa	85 c0		 test	 eax, eax
  002ac	74 5f		 je	 SHORT $LN11@LoadItem

; 168  : 				{
; 169  : 					Token = (*GetToken)();

  002ae	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002b3	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 170  : 					if(Token==NAME && strcmp("end",TokenString)==NULL) break;

  002b6	83 7d f8 00	 cmp	 DWORD PTR _Token$[ebp], 0
  002ba	75 18		 jne	 SHORT $LN33@LoadItem
  002bc	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  002c1	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  002c6	e8 00 00 00 00	 call	 _strcmp
  002cb	83 c4 08	 add	 esp, 8
  002ce	85 c0		 test	 eax, eax
  002d0	75 02		 jne	 SHORT $LN33@LoadItem
  002d2	eb 39		 jmp	 SHORT $LN11@LoadItem
$LN33@LoadItem:

; 171  : 					
; 172  : 					if( iCount > ATTACH_OPTION_COUNT )

  002d4	83 7d ec 04	 cmp	 DWORD PTR _iCount$[ebp], 4
  002d8	7e 13		 jle	 SHORT $LN34@LoadItem

; 173  : 					{
; 174  : 						MsgBox("Load Script Error %s", script_file);

  002da	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  002dd	50		 push	 eax
  002de	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KEOMIEDM@Load?5Script?5Error?5?$CFs@
  002e3	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002e8	83 c4 08	 add	 esp, 8

; 175  : 						break;		// 배열의 범위를 넘어갔다.

  002eb	eb 20		 jmp	 SHORT $LN11@LoadItem
$LN34@LoadItem:

; 176  : 					}
; 177  : 					
; 178  : 					m_iGamblingOptionCountRate[iCount]	= (int)TokenNumber;

  002ed	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002f5	8b 4d ec	 mov	 ecx, DWORD PTR _iCount$[ebp]
  002f8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002fb	89 84 8a 20 02
	00 00		 mov	 DWORD PTR [edx+ecx*4+544], eax

; 179  : 					
; 180  : 					++iCount;

  00302	8b 45 ec	 mov	 eax, DWORD PTR _iCount$[ebp]
  00305	83 c0 01	 add	 eax, 1
  00308	89 45 ec	 mov	 DWORD PTR _iCount$[ebp], eax

; 181  : 				}

  0030b	eb 98		 jmp	 SHORT $LN10@LoadItem
$LN11@LoadItem:

; 182  : 			}

  0030d	e9 98 02 00 00	 jmp	 $LN39@LoadItem
$LN31@LoadItem:

; 183  : 			else if( Type == 4 )

  00312	83 7d e8 04	 cmp	 DWORD PTR _Type$1[ebp], 4
  00316	0f 85 94 00 00
	00		 jne	 $LN35@LoadItem

; 184  : 			{	// 각 엑설런트 옵션이 붙을 확률 ( 총합은 10000이 되야함)
; 185  : 				iCount = 0;

  0031c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0
$LN12@LoadItem:

; 186  : 
; 187  : 				while(true)

  00323	b8 01 00 00 00	 mov	 eax, 1
  00328	85 c0		 test	 eax, eax
  0032a	74 7f		 je	 SHORT $LN13@LoadItem

; 188  : 				{
; 189  : 					Token = (*GetToken)();

  0032c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00331	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 190  : 					if(Token==NAME && strcmp("end",TokenString)==NULL) break;

  00334	83 7d f8 00	 cmp	 DWORD PTR _Token$[ebp], 0
  00338	75 18		 jne	 SHORT $LN37@LoadItem
  0033a	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  0033f	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00344	e8 00 00 00 00	 call	 _strcmp
  00349	83 c4 08	 add	 esp, 8
  0034c	85 c0		 test	 eax, eax
  0034e	75 02		 jne	 SHORT $LN37@LoadItem
  00350	eb 59		 jmp	 SHORT $LN13@LoadItem
$LN37@LoadItem:

; 191  : 					
; 192  : 					if( iCount > EX_OPTION_COUNT )

  00352	83 7d ec 06	 cmp	 DWORD PTR _iCount$[ebp], 6
  00356	7e 13		 jle	 SHORT $LN38@LoadItem

; 193  : 					{
; 194  : 						MsgBox("Load Script Error %s", script_file);

  00358	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  0035b	50		 push	 eax
  0035c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KEOMIEDM@Load?5Script?5Error?5?$CFs@
  00361	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00366	83 c4 08	 add	 esp, 8

; 195  : 						break;		// 배열의 범위를 넘어갔다.

  00369	eb 40		 jmp	 SHORT $LN13@LoadItem
$LN38@LoadItem:

; 196  : 					}
; 197  : 					
; 198  : 					m_iGamblingExOptionRate[iCount]	= (int)TokenNumber;

  0036b	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00373	8b 4d ec	 mov	 ecx, DWORD PTR _iCount$[ebp]
  00376	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00379	89 84 8a 30 02
	00 00		 mov	 DWORD PTR [edx+ecx*4+560], eax

; 199  : 					 Token = (*GetToken)();	m_iNormalExOptionRate[iCount]	= (int)TokenNumber;

  00380	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00385	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00388	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00390	8b 4d ec	 mov	 ecx, DWORD PTR _iCount$[ebp]
  00393	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00396	89 84 8a 48 02
	00 00		 mov	 DWORD PTR [edx+ecx*4+584], eax

; 200  : 					
; 201  : 					++iCount;

  0039d	8b 45 ec	 mov	 eax, DWORD PTR _iCount$[ebp]
  003a0	83 c0 01	 add	 eax, 1
  003a3	89 45 ec	 mov	 DWORD PTR _iCount$[ebp], eax

; 202  : 				}

  003a6	e9 78 ff ff ff	 jmp	 $LN12@LoadItem
$LN13@LoadItem:

; 203  : 			}

  003ab	e9 fa 01 00 00	 jmp	 $LN39@LoadItem
$LN35@LoadItem:

; 204  : 			else if( Type >= 5 )

  003b0	83 7d e8 05	 cmp	 DWORD PTR _Type$1[ebp], 5
  003b4	0f 8c f0 01 00
	00		 jl	 $LN39@LoadItem

; 205  : 			{	// 아이템 리스트
; 206  : 				nDropRatePerItemCnt = 0;

  003ba	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nDropRatePerItemCnt$[ebp], 0
$LN14@LoadItem:

; 207  : 
; 208  : 				while(true)

  003c1	b8 01 00 00 00	 mov	 eax, 1
  003c6	85 c0		 test	 eax, eax
  003c8	0f 84 bf 01 00
	00		 je	 $LN15@LoadItem

; 209  : 				{
; 210  : 					Token = (*GetToken)();

  003ce	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003d3	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 211  : 					if(Token==NAME && strcmp("end",TokenString)==NULL)

  003d6	83 7d f8 00	 cmp	 DWORD PTR _Token$[ebp], 0
  003da	75 2b		 jne	 SHORT $LN40@LoadItem
  003dc	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  003e1	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  003e6	e8 00 00 00 00	 call	 _strcmp
  003eb	83 c4 08	 add	 esp, 8
  003ee	85 c0		 test	 eax, eax
  003f0	75 15		 jne	 SHORT $LN40@LoadItem

; 212  : 					{
; 213  : 						m_iDropRatePerItemCount[nRateCnt] = nDropRatePerItemCnt;

  003f2	8b 45 f0	 mov	 eax, DWORD PTR _nRateCnt$[ebp]
  003f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003f8	8b 55 f4	 mov	 edx, DWORD PTR _nDropRatePerItemCnt$[ebp]
  003fb	89 94 81 64 02
	00 00		 mov	 DWORD PTR [ecx+eax*4+612], edx

; 214  : 						break;

  00402	e9 86 01 00 00	 jmp	 $LN15@LoadItem
$LN40@LoadItem:

; 215  : 					}
; 216  : 
; 217  : 					BagObject[m_iBagObjectCount].m_type = (int)TokenNumber;					

  00407	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0040f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00412	8b 91 60 02 00
	00		 mov	 edx, DWORD PTR [ecx+608]
  00418	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0041b	88 84 d1 cc 02
	00 00		 mov	 BYTE PTR [ecx+edx*8+716], al

; 218  : 
; 219  : 					Token = (*GetToken)();	BagObject[m_iBagObjectCount].m_index = (int)TokenNumber;

  00422	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00427	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0042a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00432	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00435	8b 91 60 02 00
	00		 mov	 edx, DWORD PTR [ecx+608]
  0043b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0043e	88 84 d1 cd 02
	00 00		 mov	 BYTE PTR [ecx+edx*8+717], al

; 220  : 
; 221  : 					Token = (*GetToken)();	BagObject[m_iBagObjectCount].m_minLevel = (int)TokenNumber;

  00445	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0044a	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0044d	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00455	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00458	8b 91 60 02 00
	00		 mov	 edx, DWORD PTR [ecx+608]
  0045e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00461	88 84 d1 ce 02
	00 00		 mov	 BYTE PTR [ecx+edx*8+718], al

; 222  : 					Token = (*GetToken)();	BagObject[m_iBagObjectCount].m_maxLevel = (int)TokenNumber;

  00468	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0046d	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00470	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00478	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0047b	8b 91 60 02 00
	00		 mov	 edx, DWORD PTR [ecx+608]
  00481	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00484	88 84 d1 cf 02
	00 00		 mov	 BYTE PTR [ecx+edx*8+719], al

; 223  : 					Token = (*GetToken)();	BagObject[m_iBagObjectCount].m_isskill	= (int)TokenNumber;

  0048b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00490	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00493	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0049b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0049e	8b 91 60 02 00
	00		 mov	 edx, DWORD PTR [ecx+608]
  004a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004a7	88 84 d1 d0 02
	00 00		 mov	 BYTE PTR [ecx+edx*8+720], al

; 224  : 					Token = (*GetToken)();	BagObject[m_iBagObjectCount].m_isluck	= (int)TokenNumber;

  004ae	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004b3	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  004b6	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004c1	8b 91 60 02 00
	00		 mov	 edx, DWORD PTR [ecx+608]
  004c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ca	88 84 d1 d1 02
	00 00		 mov	 BYTE PTR [ecx+edx*8+721], al

; 225  : 					Token = (*GetToken)();	BagObject[m_iBagObjectCount].m_isoption = (int)TokenNumber;

  004d1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004d6	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  004d9	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004e4	8b 91 60 02 00
	00		 mov	 edx, DWORD PTR [ecx+608]
  004ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ed	88 84 d1 d2 02
	00 00		 mov	 BYTE PTR [ecx+edx*8+722], al

; 226  : 					Token = (*GetToken)();	BagObject[m_iBagObjectCount].m_isexitem = (int)TokenNumber;

  004f4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004f9	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  004fc	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00504	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00507	8b 91 60 02 00
	00		 mov	 edx, DWORD PTR [ecx+608]
  0050d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00510	88 84 d1 d3 02
	00 00		 mov	 BYTE PTR [ecx+edx*8+723], al

; 227  : 
; 228  : 					if(BagObject[m_iBagObjectCount].m_minLevel > BagObject[m_iBagObjectCount].m_maxLevel)

  00517	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0051a	8b 88 60 02 00
	00		 mov	 ecx, DWORD PTR [eax+608]
  00520	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00523	0f b6 84 ca ce
	02 00 00	 movzx	 eax, BYTE PTR [edx+ecx*8+718]
  0052b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0052e	8b 91 60 02 00
	00		 mov	 edx, DWORD PTR [ecx+608]
  00534	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00537	0f b6 94 d1 cf
	02 00 00	 movzx	 edx, BYTE PTR [ecx+edx*8+719]
  0053f	3b c2		 cmp	 eax, edx
  00541	7e 16		 jle	 SHORT $LN41@LoadItem

; 229  : 					{
; 230  : 						MsgBox("Load Script Error %s", script_file);

  00543	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  00546	50		 push	 eax
  00547	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KEOMIEDM@Load?5Script?5Error?5?$CFs@
  0054c	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00551	83 c4 08	 add	 esp, 8

; 231  : 						return;

  00554	e9 8c 00 00 00	 jmp	 $LN1@LoadItem
$LN41@LoadItem:

; 232  : 					}
; 233  : 
; 234  : 					nDropRatePerItemCnt++;

  00559	8b 45 f4	 mov	 eax, DWORD PTR _nDropRatePerItemCnt$[ebp]
  0055c	83 c0 01	 add	 eax, 1
  0055f	89 45 f4	 mov	 DWORD PTR _nDropRatePerItemCnt$[ebp], eax

; 235  : 					m_iBagObjectCount++;

  00562	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00565	8b 88 60 02 00
	00		 mov	 ecx, DWORD PTR [eax+608]
  0056b	83 c1 01	 add	 ecx, 1
  0056e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00571	89 8a 60 02 00
	00		 mov	 DWORD PTR [edx+608], ecx

; 236  : 					if( m_iBagObjectCount > MAX_ITEMBAGEX-1 ) break;

  00577	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0057a	81 b8 60 02 00
	00 95 00 00 00	 cmp	 DWORD PTR [eax+608], 149 ; 00000095H
  00584	7e 02		 jle	 SHORT $LN42@LoadItem
  00586	eb 05		 jmp	 SHORT $LN15@LoadItem
$LN42@LoadItem:

; 237  : 				}

  00588	e9 34 fe ff ff	 jmp	 $LN14@LoadItem
$LN15@LoadItem:

; 238  : 				
; 239  : 				nRateCnt++;

  0058d	8b 45 f0	 mov	 eax, DWORD PTR _nRateCnt$[ebp]
  00590	83 c0 01	 add	 eax, 1
  00593	89 45 f0	 mov	 DWORD PTR _nRateCnt$[ebp], eax

; 240  : 				if( nRateCnt > ITEM_GROUP_MAX-1 ) break;

  00596	83 7d f0 18	 cmp	 DWORD PTR _nRateCnt$[ebp], 24 ; 00000018H
  0059a	7e 02		 jle	 SHORT $LN43@LoadItem
  0059c	eb 11		 jmp	 SHORT $LN3@LoadItem
$LN43@LoadItem:

; 241  : 
; 242  : 				m_iRateKindCount = nRateCnt;

  0059e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005a1	8b 4d f0	 mov	 ecx, DWORD PTR _nRateCnt$[ebp]
  005a4	89 88 c8 02 00
	00		 mov	 DWORD PTR [eax+712], ecx
$LN39@LoadItem:

; 243  : 			}
; 244  : 		}
; 245  : 	}

  005aa	e9 cb fa ff ff	 jmp	 $LN2@LoadItem
$LN3@LoadItem:

; 246  : 
; 247  : 	fclose(SMDFile);	

  005af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  005b4	50		 push	 eax
  005b5	e8 00 00 00 00	 call	 _fclose
  005ba	83 c4 04	 add	 esp, 4

; 248  : 	LogAdd(lMsg.Get(454), script_file);

  005bd	8b 45 08	 mov	 eax, DWORD PTR _script_file$[ebp]
  005c0	50		 push	 eax
  005c1	68 c6 01 00 00	 push	 454			; 000001c6H
  005c6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  005d1	50		 push	 eax
  005d2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  005d8	83 c4 08	 add	 esp, 8

; 249  : 
; 250  : 	m_bLoad = TRUE;

  005db	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005de	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
$LN1@LoadItem:

; 251  : }

  005e5	5f		 pop	 edi
  005e6	5e		 pop	 esi
  005e7	5b		 pop	 ebx
  005e8	8b e5		 mov	 esp, ebp
  005ea	5d		 pop	 ebp
  005eb	c2 04 00	 ret	 4
?LoadItem@CGamblingItemBag@@QAEXPAD@Z ENDP		; CGamblingItemBag::LoadItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ?GamblingItemBagInit@CGamblingItemBag@@QAEXPAD@Z
_TEXT	SEGMENT
_i$1 = -24						; size = 4
_i$2 = -20						; size = 4
_i$3 = -16						; size = 4
_i$4 = -12						; size = 4
_i$5 = -8						; size = 4
_this$ = -4						; size = 4
_name$ = 8						; size = 4
?GamblingItemBagInit@CGamblingItemBag@@QAEXPAD@Z PROC	; CGamblingItemBag::GamblingItemBagInit, COMDAT
; _this$ = ecx

; 46   : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : 	m_bLoad = FALSE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 48   : 	m_iBagObjectCount = 0;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 80 60 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+608], 0

; 49   : 	m_iRateKindCount = 0;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 80 c8 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+712], 0

; 50   : 
; 51   : 	for( int i=0; i<ADD_OPTION_COUNT; ++i )

  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@GamblingIt
$LN2@GamblingIt:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$5[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@GamblingIt:
  00042	83 7d f8 04	 cmp	 DWORD PTR _i$5[ebp], 4
  00046	7d 13		 jge	 SHORT $LN3@GamblingIt

; 52   : 		m_iAddOption[i] = 0;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _i$5[ebp]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	c7 84 81 fc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+508], 0
  00059	eb de		 jmp	 SHORT $LN2@GamblingIt
$LN3@GamblingIt:

; 53   : 
; 54   : 	for( int i=0; i<GAMBILNG_ITEM_TYPE_COUNT; ++i )

  0005b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  00062	eb 09		 jmp	 SHORT $LN7@GamblingIt
$LN5@GamblingIt:
  00064	8b 45 f4	 mov	 eax, DWORD PTR _i$4[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 f4	 mov	 DWORD PTR _i$4[ebp], eax
$LN7@GamblingIt:
  0006d	83 7d f4 05	 cmp	 DWORD PTR _i$4[ebp], 5
  00071	7d 13		 jge	 SHORT $LN6@GamblingIt

; 55   : 		m_iGamblingItemGetRate[i] = 0;

  00073	8b 45 f4	 mov	 eax, DWORD PTR _i$4[ebp]
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	c7 84 81 0c 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+524], 0
  00084	eb de		 jmp	 SHORT $LN5@GamblingIt
$LN6@GamblingIt:

; 56   : 
; 57   : 	for( int i=0; i<ATTACH_OPTION_COUNT; ++i )

  00086	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  0008d	eb 09		 jmp	 SHORT $LN10@GamblingIt
$LN8@GamblingIt:
  0008f	8b 45 f0	 mov	 eax, DWORD PTR _i$3[ebp]
  00092	83 c0 01	 add	 eax, 1
  00095	89 45 f0	 mov	 DWORD PTR _i$3[ebp], eax
$LN10@GamblingIt:
  00098	83 7d f0 04	 cmp	 DWORD PTR _i$3[ebp], 4
  0009c	7d 02		 jge	 SHORT $LN9@GamblingIt

; 58   : 		m_iGamblingOptionCountRate[i];

  0009e	eb ef		 jmp	 SHORT $LN8@GamblingIt
$LN9@GamblingIt:

; 59   : 
; 60   : 	for( int i=0; i<EX_OPTION_COUNT; ++i )

  000a0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  000a7	eb 09		 jmp	 SHORT $LN13@GamblingIt
$LN11@GamblingIt:
  000a9	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  000ac	83 c0 01	 add	 eax, 1
  000af	89 45 ec	 mov	 DWORD PTR _i$2[ebp], eax
$LN13@GamblingIt:
  000b2	83 7d ec 06	 cmp	 DWORD PTR _i$2[ebp], 6
  000b6	7d 02		 jge	 SHORT $LN12@GamblingIt

; 61   : 	{
; 62   : 		m_iGamblingExOptionRate[i];
; 63   : 		m_iNormalExOptionRate[i];
; 64   : 	}

  000b8	eb ef		 jmp	 SHORT $LN11@GamblingIt
$LN12@GamblingIt:

; 65   : 
; 66   : 	for( int i=0; i<ITEM_GROUP_MAX; ++i )

  000ba	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  000c1	eb 09		 jmp	 SHORT $LN16@GamblingIt
$LN14@GamblingIt:
  000c3	8b 45 e8	 mov	 eax, DWORD PTR _i$1[ebp]
  000c6	83 c0 01	 add	 eax, 1
  000c9	89 45 e8	 mov	 DWORD PTR _i$1[ebp], eax
$LN16@GamblingIt:
  000cc	83 7d e8 19	 cmp	 DWORD PTR _i$1[ebp], 25	; 00000019H
  000d0	7d 13		 jge	 SHORT $LN15@GamblingIt

; 67   : 		m_iDropRatePerItemCount[i] = 0;

  000d2	8b 45 e8	 mov	 eax, DWORD PTR _i$1[ebp]
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	c7 84 81 64 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+612], 0
  000e3	eb de		 jmp	 SHORT $LN14@GamblingIt
$LN15@GamblingIt:

; 68   : 	
; 69   : 	
; 70   : 	LoadItem(gDirPath.GetNewPath(name));	

  000e5	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  000e8	50		 push	 eax
  000e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000ee	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000f3	50		 push	 eax
  000f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	e8 00 00 00 00	 call	 ?LoadItem@CGamblingItemBag@@QAEXPAD@Z ; CGamblingItemBag::LoadItem

; 71   : }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?GamblingItemBagInit@CGamblingItemBag@@QAEXPAD@Z ENDP	; CGamblingItemBag::GamblingItemBagInit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ?GetLevel@CGamblingItemBag@@AAEEH@Z
_TEXT	SEGMENT
_level$ = -12						; size = 4
_sub$ = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?GetLevel@CGamblingItemBag@@AAEEH@Z PROC		; CGamblingItemBag::GetLevel, COMDAT
; _this$ = ecx

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 255  : 	if( n < 0 || n > MAX_ITEMBAGEX-1 ) return 0;

  0000c	83 7d 08 00	 cmp	 DWORD PTR _n$[ebp], 0
  00010	7c 09		 jl	 SHORT $LN3@GetLevel
  00012	81 7d 08 95 00
	00 00		 cmp	 DWORD PTR _n$[ebp], 149	; 00000095H
  00019	7e 04		 jle	 SHORT $LN2@GetLevel
$LN3@GetLevel:
  0001b	32 c0		 xor	 al, al
  0001d	eb 72		 jmp	 SHORT $LN1@GetLevel
$LN2@GetLevel:

; 256  : 	
; 257  : 	if( BagObject[n].m_minLevel == BagObject[n].m_maxLevel )

  0001f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	0f b6 94 c1 ce
	02 00 00	 movzx	 edx, BYTE PTR [ecx+eax*8+718]
  0002d	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	0f b6 84 c1 cf
	02 00 00	 movzx	 eax, BYTE PTR [ecx+eax*8+719]
  0003b	3b d0		 cmp	 edx, eax
  0003d	75 0f		 jne	 SHORT $LN4@GetLevel

; 258  : 	{
; 259  : 		return BagObject[n].m_minLevel;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8a 84 c1 ce 02
	00 00		 mov	 al, BYTE PTR [ecx+eax*8+718]
  0004c	eb 43		 jmp	 SHORT $LN1@GetLevel
$LN4@GetLevel:

; 260  : 	}
; 261  : 	
; 262  : 	int sub = BagObject[n].m_maxLevel - BagObject[n].m_minLevel + 1;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	0f b6 94 c1 cf
	02 00 00	 movzx	 edx, BYTE PTR [ecx+eax*8+719]
  0005c	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	0f b6 84 c1 ce
	02 00 00	 movzx	 eax, BYTE PTR [ecx+eax*8+718]
  0006a	2b d0		 sub	 edx, eax
  0006c	83 c2 01	 add	 edx, 1
  0006f	89 55 f8	 mov	 DWORD PTR _sub$[ebp], edx

; 263  : 	int level = BagObject[n].m_minLevel+rand()%sub;

  00072	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	0f b6 b4 c1 ce
	02 00 00	 movzx	 esi, BYTE PTR [ecx+eax*8+718]
  00080	e8 00 00 00 00	 call	 _rand
  00085	99		 cdq
  00086	f7 7d f8	 idiv	 DWORD PTR _sub$[ebp]
  00089	03 f2		 add	 esi, edx
  0008b	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi

; 264  : 	
; 265  : 	return level;

  0008e	8a 45 f4	 mov	 al, BYTE PTR _level$[ebp]
$LN1@GetLevel:

; 266  : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?GetLevel@CGamblingItemBag@@AAEEH@Z ENDP		; CGamblingItemBag::GetLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.h
;	COMDAT ?GetBagCount@CGamblingItemBag@@AAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBagCount@CGamblingItemBag@@AAEHXZ PROC		; CGamblingItemBag::GetBagCount, COMDAT
; _this$ = ecx

; 130  : 	int		GetBagCount(){return m_iBagObjectCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 80 60 02 00
	00		 mov	 eax, DWORD PTR [eax+608]
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetBagCount@CGamblingItemBag@@AAEHXZ ENDP		; CGamblingItemBag::GetBagCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ??1CGamblingItemBag@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CGamblingItemBag@@UAE@XZ PROC			; CGamblingItemBag::~CGamblingItemBag, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGamblingItemBag@@6B@

; 43   : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CGamblingItemBag@@UAE@XZ ENDP			; CGamblingItemBag::~CGamblingItemBag
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.h
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ??0CGamblingItemBag@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CGamblingItemBag@@QAE@XZ PROC			; CGamblingItemBag::CGamblingItemBag, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGamblingItemBag@@6B@
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.h

; 114  : 	BOOL	m_bLoad;

  00015	68 00 00 00 00	 push	 OFFSET ??0_GAMBLING_RATE@@QAE@XZ ; _GAMBLING_RATE::_GAMBLING_RATE
  0001a	6a 19		 push	 25			; 00000019H
  0001c	6a 14		 push	 20			; 00000014H
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z

; 115  : 	
; 116  : 	GAMBLING_RATE m_stGamblingRate[ITEM_GROUP_MAX];			// 확률 관련 구조체 변수
; 117  : 	int		m_iAddOption[ADD_OPTION_COUNT];					// 추가 옵션이 붙을때 각 추가 옵션별 붙을 확률
; 118  : 	int		m_iGamblingItemGetRate[GAMBILNG_ITEM_TYPE_COUNT];	// 각 타입별 겜블링 아이템이 나올 확률
; 119  : 	int		m_iGamblingOptionCountRate[ATTACH_OPTION_COUNT];	// 겜블링 아이템에 옵션이 여러개 붙을 확률
; 120  : 	int		m_iGamblingExOptionRate[EX_OPTION_COUNT];		// 겜블링 아이템에 각 엑설런트 옵션이 붙을 확률
; 121  : 	int		m_iNormalExOptionRate[EX_OPTION_COUNT];			// 보통 엑설런트 아이템에 각 엑설런트 옵션이 붙을 확률
; 122  : 
; 123  : 	int		m_iBagObjectCount;							// 아이템 리스트 수
; 124  : 	int		m_iDropRatePerItemCount[ITEM_GROUP_MAX];	// 확률당 아이템 수
; 125  : 	int		m_iRateKindCount;							// 확률 종류 개수

  0002a	68 00 00 00 00	 push	 OFFSET ??0CItemBagAttrEx@@QAE@XZ ; CItemBagAttrEx::CItemBagAttrEx
  0002f	68 96 00 00 00	 push	 150			; 00000096H
  00034	6a 08		 push	 8
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	05 cc 02 00 00	 add	 eax, 716		; 000002ccH
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp

; 39   : }

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??0CGamblingItemBag@@QAE@XZ ENDP			; CGamblingItemBag::CGamblingItemBag
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.h
;	COMDAT ??0_GAMBLING_RATE@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_GAMBLING_RATE@@QAE@XZ PROC				; _GAMBLING_RATE::_GAMBLING_RATE, COMDAT
; _this$ = ecx

; 97   : 	_GAMBLING_RATE()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 98   : 	{
; 99   : 		iSkillRate = 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 100  : 		iLuckRate = 0;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 101  : 		iAddOptionRate = 0;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 102  : 		iExcellentRate = 0;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 103  : 		iSelectedRate = 0;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 104  : 	}

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??0_GAMBLING_RATE@@QAE@XZ ENDP				; _GAMBLING_RATE::_GAMBLING_RATE
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ItemBagEx.h
;	COMDAT ??0CItemBagAttrEx@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CItemBagAttrEx@@QAE@XZ PROC				; CItemBagAttrEx::CItemBagAttrEx, COMDAT
; _this$ = ecx

; 28   : 	CItemBagAttrEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	{
; 30   : 		m_type  =0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 31   : 		m_index  =0;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 32   : 		m_minLevel  =0;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 33   : 		m_maxLevel  =0;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 34   : 		m_isskill  =0;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 35   : 		m_isluck  =0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c6 40 05 00	 mov	 BYTE PTR [eax+5], 0

; 36   : 		m_isoption  =0;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c6 40 06 00	 mov	 BYTE PTR [eax+6], 0

; 37   : 		m_isexitem = 0;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c6 40 07 00	 mov	 BYTE PTR [eax+7], 0

; 38   : 	}

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??0CItemBagAttrEx@@QAE@XZ ENDP				; CItemBagAttrEx::CItemBagAttrEx
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GamblingSystem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -68						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	89 45 bc	 mov	 DWORD PTR tv66[ebp], eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  00012	83 e9 01	 sub	 ecx, 1
  00015	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00018	83 7d bc 00	 cmp	 DWORD PTR tv66[ebp], 0
  0001c	76 11		 jbe	 SHORT $LN1@vector
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00021	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00024	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00027	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  0002a	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  0002d	eb da		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
