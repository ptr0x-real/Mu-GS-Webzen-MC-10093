; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CDevilSquare@@QAE@XZ				; CDevilSquare::CDevilSquare
PUBLIC	??1CDevilSquare@@UAE@XZ				; CDevilSquare::~CDevilSquare
PUBLIC	?Init@CDevilSquare@@QAEXXZ			; CDevilSquare::Init
PUBLIC	?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState
PUBLIC	?Run@CDevilSquare@@QAEHXZ			; CDevilSquare::Run
PUBLIC	?SetMonster@CDevilSquare@@QAEXXZ		; CDevilSquare::SetMonster
PUBLIC	?ClearMonstr@CDevilSquare@@QAEXXZ		; CDevilSquare::ClearMonstr
PUBLIC	?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z ; CDevilSquare::gDevilSquareMonsterRegen
PUBLIC	?DieProcDevilSquare@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z ; CDevilSquare::DieProcDevilSquare
PUBLIC	?gObjMonsterExpSingle@CDevilSquare@@QAEHPAVOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjMonsterExpSingle
PUBLIC	?gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjExpParty
PUBLIC	?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjMonsterScoreDivision
PUBLIC	?Load@CDevilSquare@@QAEXPAD@Z			; CDevilSquare::Load
PUBLIC	?CalcScore@CDevilSquare@@QAEXXZ			; CDevilSquare::CalcScore
PUBLIC	?SetClose@CDevilSquare@@QAEXXZ			; CDevilSquare::SetClose
PUBLIC	?SetOpen@CDevilSquare@@AAEXXZ			; CDevilSquare::SetOpen
PUBLIC	?SetPlaying@CDevilSquare@@AAEXXZ		; CDevilSquare::SetPlaying
PUBLIC	?ProcClose@CDevilSquare@@AAEXXZ			; CDevilSquare::ProcClose
PUBLIC	?ProcOpen@CDevilSquare@@AAEXXZ			; CDevilSquare::ProcOpen
PUBLIC	?ProcPlaying@CDevilSquare@@AAEXXZ		; CDevilSquare::ProcPlaying
PUBLIC	?SendEventStartMsg@CDevilSquare@@AAEXXZ		; CDevilSquare::SendEventStartMsg
PUBLIC	?ItemClear@CDevilSquare@@AAEXXZ			; CDevilSquare::ItemClear
PUBLIC	?CheckSync@CDevilSquare@@AAEXXZ			; CDevilSquare::CheckSync
PUBLIC	?SendLiveCall@CDevilSquare@@AAEXXZ		; CDevilSquare::SendLiveCall
PUBLIC	?gObjScoreClear@CDevilSquare@@AAEXXZ		; CDevilSquare::gObjScoreClear
PUBLIC	?CheckInvalidUser@CDevilSquare@@AAEXXZ		; CDevilSquare::CheckInvalidUser
PUBLIC	??_GCDevilSquare@@UAEPAXI@Z			; CDevilSquare::`scalar deleting destructor'
PUBLIC	?DevilSquareEventProtocolCore@@YAXEPAEH@Z	; DevilSquareEventProtocolCore
PUBLIC	?DataSendRank@@YAXPADH@Z			; DataSendRank
PUBLIC	?DevilSquareThreadFunc@@YGIPAX@Z		; DevilSquareThreadFunc
PUBLIC	??_7CDevilSquare@@6B@				; CDevilSquare::`vftable'
PUBLIC	?g_DevilSquare@@3VCDevilSquare@@A		; g_DevilSquare
PUBLIC	??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0CH@BBCAEKDP@?$FLDevilSquare?$FN?5Info?5file?5Load?5Fa@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end@				; `string'
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@	; `string'
PUBLIC	??_C@_0BE@JMFNFMMP@?$FLDevilSquare?$FN?5Close@	; `string'
PUBLIC	??_C@_0CN@MKAKKBKJ@?$FLDevilSquare?$FN?5Sync?5Open?5Time?4?5?$FL@ ; `string'
PUBLIC	??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Mont@ ; `string'
PUBLIC	??_C@_0CM@CCIHNOCP@?$FLDevilSquare?$FN?5Invalid?5DevilSqua@ ; `string'
PUBLIC	??_C@_0CL@GIDNIGIL@?$FLDevilSquare?$FN?5Monter?5Regen?5?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0BK@JCOFCPLC@?$FLDevilSquare?$FN?5Start?5Event@ ; `string'
PUBLIC	??_C@_0CE@KOGNJHLF@?$FLDevilSquare?$FN?5Dead?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z@4JA ; `CDevilSquare::gObjExpParty'::`1'::__LINE__Var
PUBLIC	??_C@_0DO@BBHGJELM@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@	; `string'
PUBLIC	??_C@_0DP@NODHEOAH@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Found?5us@ ; `string'
PUBLIC	??_R4CDevilSquare@@6B@				; CDevilSquare::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDevilSquare@@@8			; CDevilSquare `RTTI Type Descriptor'
PUBLIC	??_R3CDevilSquare@@8				; CDevilSquare::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDevilSquare@@8				; CDevilSquare::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDevilSquare@@8			; CDevilSquare::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@4069000000000000
PUBLIC	__real@42c80000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	__localtime64:PROC
EXTRN	__time64:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	__beginthreadex:PROC
EXTRN	?Clear@CMagicInf@@QAEXXZ:PROC			; CMagicInf::Clear
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjUserKill@@YAXH@Z:PROC			; gObjUserKill
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjSetPosMonster@@YAHHH@Z:PROC		; gObjSetPosMonster
EXTRN	?gObjLevelUp@@YA_NPAVOBJECTSTRUCT@@HHH@Z:PROC	; gObjLevelUp
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCKillPlayerExpSend@@YAXHHHHH@Z:PROC		; GCKillPlayerExpSend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?AllSendSameMapMsg@@YAXPAEHE@Z:PROC		; AllSendSameMapMsg
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?_checkCondition@CDynamicExperience@@QAEMPAVOBJECTSTRUCT@@@Z:PROC ; CDynamicExperience::_checkCondition
EXTRN	?_getNewExperience@CDynamicExperience@@QAEKKM@Z:PROC ; CDynamicExperience::_getNewExperience
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	??0CDevilSquareGround@@QAE@XZ:PROC		; CDevilSquareGround::CDevilSquareGround
EXTRN	??1CDevilSquareGround@@UAE@XZ:PROC		; CDevilSquareGround::~CDevilSquareGround
EXTRN	?Init@CDevilSquareGround@@QAEXH@Z:PROC		; CDevilSquareGround::Init
EXTRN	?Clear@CDevilSquareGround@@QAEXXZ:PROC		; CDevilSquareGround::Clear
EXTRN	?SetBonus@CDevilSquareGround@@QAEXHHH@Z:PROC	; CDevilSquareGround::SetBonus
EXTRN	?Set@CDevilSquareGround@@QAEXGHH@Z:PROC		; CDevilSquareGround::Set
EXTRN	?SetBoss@CDevilSquareGround@@QAEXGHHHHH@Z:PROC	; CDevilSquareGround::SetBoss
EXTRN	?RegenBossMonster@CDevilSquareGround@@QAEXH@Z:PROC ; CDevilSquareGround::RegenBossMonster
EXTRN	?GetMonsterType@CDevilSquareGround@@QAEGH@Z:PROC ; CDevilSquareGround::GetMonsterType
EXTRN	?ClearScore@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::ClearScore
EXTRN	?SortScore@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::SortScore
EXTRN	?InsertObj@CDevilSquareGround@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CDevilSquareGround::InsertObj
EXTRN	?SendScore@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::SendScore
EXTRN	??_ECDevilSquare@@UAEPAXI@Z:PROC		; CDevilSquare::`vector deleting destructor'
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjMonsterRegen
EXTRN	?gObjMonsterHitDamageUserDel@@YAHPAVOBJECTSTRUCT@@@Z:PROC ; gObjMonsterHitDamageUserDel
EXTRN	?gObjMonsterLastHitDamageUser@@YAHPAVOBJECTSTRUCT@@AAH@Z:PROC ; gObjMonsterLastHitDamageUser
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?EGBloodCastleEnterCountCheck@@YAXPAUPMSG_ANS_BLOODCASTLEENTERCHECK@@@Z:PROC ; EGBloodCastleEnterCountCheck
EXTRN	?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z:PROC ; EGAnsBloodCastleEnterCount
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?_dynamic_experience@@3VCDynamicExperience@@A:BYTE ; _dynamic_experience
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?DevilSquareEventConnect@@3HA:DWORD		; DevilSquareEventConnect
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?gLevelExperience@@3PAKA:BYTE			; gLevelExperience
EXTRN	?gAddExperience@@3MA:DWORD			; gAddExperience
EXTRN	?gDevilSquareEvent@@3HA:DWORD			; gDevilSquareEvent
EXTRN	?gDevilSquareEventServerIp@@3PADA:BYTE		; gDevilSquareEventServerIp
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?wsRServerCli@@3VwsJoinServerCli@@A:BYTE	; wsRServerCli
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_DevilSquare@@3VCDevilSquare@@A DB 0ff0H DUP (?)	; g_DevilSquare
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CDevilSquare@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDevilSquare@@8 DD FLAT:??_R0?AVCDevilSquare@@@8 ; CDevilSquare::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDevilSquare@@8
rdata$r	ENDS
;	COMDAT ??_R2CDevilSquare@@8
rdata$r	SEGMENT
??_R2CDevilSquare@@8 DD FLAT:??_R1A@?0A@EA@CDevilSquare@@8 ; CDevilSquare::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDevilSquare@@8
rdata$r	SEGMENT
??_R3CDevilSquare@@8 DD 00H				; CDevilSquare::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDevilSquare@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDevilSquare@@@8
data$r	SEGMENT
??_R0?AVCDevilSquare@@@8 DD FLAT:??_7type_info@@6B@	; CDevilSquare `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDevilSquare@@', 00H
data$r	ENDS
;	COMDAT ??_R4CDevilSquare@@6B@
rdata$r	SEGMENT
??_R4CDevilSquare@@6B@ DD 00H				; CDevilSquare::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDevilSquare@@@8
	DD	FLAT:??_R3CDevilSquare@@8
rdata$r	ENDS
;	COMDAT ??_C@_0DP@NODHEOAH@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Found?5us@
CONST	SEGMENT
??_C@_0DP@NODHEOAH@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Found?5us@ DB '['
	DB	'DevilSquare] [%s][%s] Found user in DevilSquare [State:Close]'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@ DB 'error : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@BBHGJELM@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0DO@BBHGJELM@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onl'
	DB	'ine\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z@4JA DD 0677H ; `CDevilSquare::gObjExpParty'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@KOGNJHLF@?$FLDevilSquare?$FN?5Dead?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CE@KOGNJHLF@?$FLDevilSquare?$FN?5Dead?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN@ DB '['
	DB	'DevilSquare] Dead [%s][%s][%d][%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JCOFCPLC@?$FLDevilSquare?$FN?5Start?5Event@
CONST	SEGMENT
??_C@_0BK@JCOFCPLC@?$FLDevilSquare?$FN?5Start?5Event@ DB '[DevilSquare] S'
	DB	'tart Event', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GIDNIGIL@?$FLDevilSquare?$FN?5Monter?5Regen?5?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CL@GIDNIGIL@?$FLDevilSquare?$FN?5Monter?5Regen?5?$FL?$CFd?$FN@ DB '['
	DB	'DevilSquare] Monter Regen [%d][%d][%d,%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CCIHNOCP@?$FLDevilSquare?$FN?5Invalid?5DevilSqua@
CONST	SEGMENT
??_C@_0CM@CCIHNOCP@?$FLDevilSquare?$FN?5Invalid?5DevilSqua@ DB '[DevilSqu'
	DB	'are] Invalid DevilSquareIndex [%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Mont@
CONST	SEGMENT
??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Mont@ DB '['
	DB	'DevilSquare] [%d] Invalid MonterType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MKAKKBKJ@?$FLDevilSquare?$FN?5Sync?5Open?5Time?4?5?$FL@
CONST	SEGMENT
??_C@_0CN@MKAKKBKJ@?$FLDevilSquare?$FN?5Sync?5Open?5Time?4?5?$FL@ DB '[De'
	DB	'vilSquare] Sync Open Time. [%d]min remain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JMFNFMMP@?$FLDevilSquare?$FN?5Close@
CONST	SEGMENT
??_C@_0BE@JMFNFMMP@?$FLDevilSquare?$FN?5Close@ DB '[DevilSquare] Close', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end@
CONST	SEGMENT
??_C@_03JBJLGPFL@end@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BBCAEKDP@?$FLDevilSquare?$FN?5Info?5file?5Load?5Fa@
CONST	SEGMENT
??_C@_0CH@BBCAEKDP@?$FLDevilSquare?$FN?5Info?5file?5Load?5Fa@ DB '[DevilS'
	DB	'quare] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@
CONST	SEGMENT
??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@ DB 'Can not connec'
	DB	't Ranking Server', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CDevilSquare@@6B@
CONST	SEGMENT
??_7CDevilSquare@@6B@ DD FLAT:??_R4CDevilSquare@@6B@	; CDevilSquare::`vftable'
	DD	FLAT:??_ECDevilSquare@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CDevilSquare@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_DevilSquare$initializer$@@3P6AXXZA DD FLAT:??__Eg_DevilSquare@@YAXXZ ; g_DevilSquare$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?DevilSquareThreadFunc@@YGIPAX@Z
_TEXT	SEGMENT
_pDevilSquare$ = -4					; size = 4
_p$ = 8							; size = 4
?DevilSquareThreadFunc@@YGIPAX@Z PROC			; DevilSquareThreadFunc, COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 74   : 	CDevilSquare* pDevilSquare = (CDevilSquare*)p;

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pDevilSquare$[ebp], eax

; 75   : 	return pDevilSquare->Run();	

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _pDevilSquare$[ebp]
  00012	e8 00 00 00 00	 call	 ?Run@CDevilSquare@@QAEHXZ ; CDevilSquare::Run

; 76   : }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?DevilSquareThreadFunc@@YGIPAX@Z ENDP			; DevilSquareThreadFunc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fg_DevilSquare@@YAXXZ
text$yd	SEGMENT
??__Fg_DevilSquare@@YAXXZ PROC				; `dynamic atexit destructor for 'g_DevilSquare'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0000e	e8 00 00 00 00	 call	 ??1CDevilSquare@@UAE@XZ	; CDevilSquare::~CDevilSquare
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_DevilSquare@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_DevilSquare''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ??__Eg_DevilSquare@@YAXXZ
text$di	SEGMENT
??__Eg_DevilSquare@@YAXXZ PROC				; `dynamic initializer for 'g_DevilSquare'', COMDAT

; 68   : CDevilSquare			g_DevilSquare;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0000e	e8 00 00 00 00	 call	 ??0CDevilSquare@@QAE@XZ	; CDevilSquare::CDevilSquare
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_DevilSquare@@YAXXZ ; `dynamic atexit destructor for 'g_DevilSquare''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_DevilSquare@@YAXXZ ENDP				; `dynamic initializer for 'g_DevilSquare''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1번 캐슬 - 축석

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1번 캐슬 - 영석

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2번 캐슬 - 축석

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2번 캐슬 - 영석

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3번 캐슬 - 축석

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3번 캐슬 - 영석

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4번 캐슬 - 축석

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4번 캐슬 - 영석

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5번 캐슬 - 축석

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5번 캐슬 - 영석

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6번 캐슬 - 축석

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6번 캐슬 - 영석

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\Readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 수정

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?DataSendRank@@YAXPADH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
_size$ = 12						; size = 4
?DataSendRank@@YAXPADH@Z PROC				; DataSendRank, COMDAT

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 127  : 	if( !IsDevilSquareEventConnected && !DevilSquareEventConnect )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00010	75 5d		 jne	 SHORT $LN2@DataSendRa
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  00019	75 54		 jne	 SHORT $LN2@DataSendRa

; 128  : 	{
; 129  : 		wsRServerCli.Close();

  0001b	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  00020	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 130  : 		wsRServerCli.CreateSocket(ghWnd);

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0002a	50		 push	 eax
  0002b	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  00030	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 131  : 		if( GMRankingServerConnect(gDevilSquareEventServerIp, WM_ASS_RANKINGCLIMSG) == FALSE )

  00035	68 0c 04 00 00	 push	 1036			; 0000040cH
  0003a	68 00 00 00 00	 push	 OFFSET ?gDevilSquareEventServerIp@@3PADA ; gDevilSquareEventServerIp
  0003f	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  00044	83 c4 08	 add	 esp, 8
  00047	85 c0		 test	 eax, eax
  00049	75 1a		 jne	 SHORT $LN3@DataSendRa

; 132  : 		{
; 133  : 			IsDevilSquareEventConnected = 0;

  0004b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected

; 134  : 			LogAddTD("Can not connect Ranking Server");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00060	83 c4 04	 add	 esp, 4

; 135  : 			return;

  00063	eb 2e		 jmp	 SHORT $LN1@DataSendRa
$LN3@DataSendRa:

; 136  : 		}	
; 137  : 		IsDevilSquareEventConnected = 1;

  00065	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN2@DataSendRa:

; 138  : 	}
; 139  : 
; 140  : 	if( !DevilSquareEventConnect && IsDevilSquareEventConnected )

  0006f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  00076	75 1b		 jne	 SHORT $LN1@DataSendRa
  00078	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  0007f	74 12		 je	 SHORT $LN1@DataSendRa

; 141  : 		wsRServerCli.DataSend(pMsg, size);

  00081	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00084	50		 push	 eax
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  00088	51		 push	 ecx
  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  0008e	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN1@DataSendRa:

; 142  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?DataSendRank@@YAXPADH@Z ENDP				; DataSendRank
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?DevilSquareEventProtocolCore@@YAXEPAEH@Z
_TEXT	SEGMENT
tv65 = -68						; size = 4
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?DevilSquareEventProtocolCore@@YAXEPAEH@Z PROC		; DevilSquareEventProtocolCore, COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 82   : 	switch( protoNum )

  00009	8a 45 08	 mov	 al, BYTE PTR _protoNum$[ebp]
  0000c	88 45 bc	 mov	 BYTE PTR tv65[ebp], al
  0000f	80 7d bc 08	 cmp	 BYTE PTR tv65[ebp], 8
  00013	74 0a		 je	 SHORT $LN5@DevilSquar
  00015	80 7d bc 0b	 cmp	 BYTE PTR tv65[ebp], 11	; 0000000bH
  00019	74 12		 je	 SHORT $LN6@DevilSquar
  0001b	eb 1c		 jmp	 SHORT $LN1@DevilSquar

; 83   : 	{
; 84   : 	case 0x01 :
; 85   : 		//CBUPR_ItemRequestRecv((LPCB_PMSG_REQ_PRESENT_RESULT)aRecv);
; 86   : 		break;

  0001d	eb 1a		 jmp	 SHORT $LN1@DevilSquar
$LN5@DevilSquar:

; 87   : 
; 88   : #ifdef BLOODCASTLE_CHECK_ENTERCOUNT_20040304
; 89   : 	case 0x08 :		// 블러드캐슬에 입장 가능한지 (횟수가 남았는지) 확인
; 90   : 		EGBloodCastleEnterCountCheck ((LPPMSG_ANS_BLOODCASTLEENTERCHECK) aRecv);

  0001f	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?EGBloodCastleEnterCountCheck@@YAXPAUPMSG_ANS_BLOODCASTLEENTERCHECK@@@Z ; EGBloodCastleEnterCountCheck
  00028	83 c4 04	 add	 esp, 4

; 91   : 		break;

  0002b	eb 0c		 jmp	 SHORT $LN1@DevilSquar
$LN6@DevilSquar:

; 92   : #endif
; 93   : 
; 94   : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 95   : #ifdef BLOODCASTLE_CHECK_ENTERCOUNT_20040304
; 96   : 	case 0x0B :		// 블러드캐슬 입장 가능횟수를 얻어온다.
; 97   : 		EGAnsBloodCastleEnterCount ((LPPMSG_ANS_BLOODCASTLE_ENTERCOUNT) aRecv);

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z ; EGAnsBloodCastleEnterCount
  00036	83 c4 04	 add	 esp, 4
$LN1@DevilSquar:

; 98   : 		break;
; 99   : #endif
; 100  : #endif
; 101  : 		
; 102  : #ifdef DEVILSQUARE_CHECK_ENTERCOUNT_20040715
; 103  : 	case 0x0F :		// 데빌스퀘어 입장 가능횟수를 얻어온다.
; 104  : 		EGAnsDevilSquareEnterCount((LPPMSG_ANS_DEVILSQUARE_ENTERCOUNT) aRecv);
; 105  : 		break;
; 106  : 	case 0x10 :		// 데빌스퀘어에 입장 가능한지 (횟수가 남았는지) 확인
; 107  : 		EGAnsDevilSquareEnterCountCheck((LPPMSG_ANS_DEVILSQUAREENTERCHECK) aRecv);
; 108  : 		break;
; 109  : #endif
; 110  : 
; 111  : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	// 랭킹서버로 부터 온 데이타 처리
; 112  : 	case 0x12:
; 113  : 		g_IllusionTempleEvent.EGAnsIllusionTempleEnterCountCheck((LPPMSG_ANS_ILLUSION_TEMPLE_ENTERCOUNTCHECK) aRecv);
; 114  : 		break;
; 115  : #endif
; 116  : 		
; 117  : #ifdef ADD_SEASON_3_NEW_UI_20071122	
; 118  : 	case 0x14:
; 119  : 		g_IllusionTempleEvent.EGAnsIllusionTempleEnterCount((LPPMSG_ANS_ILLUSIONTEMPLE_ENTERCOUNT) aRecv);
; 120  : 		break;
; 121  : #endif
; 122  : 	}
; 123  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?DevilSquareEventProtocolCore@@YAXEPAEH@Z ENDP		; DevilSquareEventProtocolCore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCDevilSquare@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDevilSquare@@UAEPAXI@Z PROC			; CDevilSquare::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CDevilSquare@@UAE@XZ	; CDevilSquare::~CDevilSquare
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 f0 0f 00 00	 push	 4080			; 00000ff0H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GCDevilSquare@@UAEPAXI@Z ENDP			; CDevilSquare::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?CheckInvalidUser@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_this$ = -4						; size = 4
?CheckInvalidUser@CDevilSquare@@AAEXXZ PROC		; CDevilSquare::CheckInvalidUser, COMDAT
; _this$ = ecx

; 2305 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2306 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0000c	c7 45 f8 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00013	eb 09		 jmp	 SHORT $LN4@CheckInval
$LN2@CheckInval:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@CheckInval:
  0001e	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00025	0f 8d a4 00 00
	00		 jge	 $LN1@CheckInval

; 2307 : 	{
; 2308 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 2309 : 		if( gObj[n].Connected == 3 && CHECK_DEVILSQUARE(gObj[n].MapNumber)  && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )
; 2310 : #else
; 2311 : 		if( gObj[n].Connected == 3 && gObj[n].MapNumber == 9  && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )

  0002b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00038	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0003d	0f 85 87 00 00
	00		 jne	 $LN5@CheckInval
  00043	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00050	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00058	83 fa 09	 cmp	 edx, 9
  0005b	75 6d		 jne	 SHORT $LN5@CheckInval
  0005d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006a	83 bc 01 80 1a
	00 00 02	 cmp	 DWORD PTR [ecx+eax+6784], 2
  00072	74 56		 je	 SHORT $LN5@CheckInval

; 2312 : #endif
; 2313 : 		{
; 2314 : 			if( m_eState == DevilSquare_CLOSE )

  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00077	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0007b	75 4d		 jne	 SHORT $LN5@CheckInval

; 2315 : 			{	// 게임중이 아니다
; 2316 : 				LogAddC(LOGC_RED,"[DevilSquare] [%s][%s] Found user in DevilSquare [State:Close]",

  0007d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008a	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0008e	52		 push	 edx
  0008f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009c	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000a0	52		 push	 edx
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@NODHEOAH@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Found?5us@
  000a6	6a 02		 push	 2
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000ae	83 c4 10	 add	 esp, 16			; 00000010H

; 2317 : 						gObj[n].AccountID, 
; 2318 : 						gObj[n].Name);
; 2319 : 				gObjUserKill(gObj[n].m_Index);

  000b1	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  000b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000be	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000c1	52		 push	 edx
  000c2	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  000c7	83 c4 04	 add	 esp, 4
$LN5@CheckInval:

; 2320 : 			}			
; 2321 : 		}
; 2322 : 	}

  000ca	e9 46 ff ff ff	 jmp	 $LN2@CheckInval
$LN1@CheckInval:

; 2323 : }

  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
?CheckInvalidUser@CDevilSquare@@AAEXXZ ENDP		; CDevilSquare::CheckInvalidUser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?gObjScoreClear@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_this$ = -4						; size = 4
?gObjScoreClear@CDevilSquare@@AAEXXZ PROC		; CDevilSquare::gObjScoreClear, COMDAT
; _this$ = ecx

; 2288 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2289 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0000c	c7 45 f8 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00013	eb 09		 jmp	 SHORT $LN4@gObjScoreC
$LN2@gObjScoreC:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjScoreC:
  0001e	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00025	0f 8d 92 00 00
	00		 jge	 $LN1@gObjScoreC

; 2290 : 	{
; 2291 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 2292 : 		if( gObj[n].Connected == 3 && CHECK_DEVILSQUARE(gObj[n].MapNumber)  && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )
; 2293 : #else
; 2294 : 		if( gObj[n].Connected == 3 && gObj[n].MapNumber == 9  && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )

  0002b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00038	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0003d	75 79		 jne	 SHORT $LN5@gObjScoreC
  0003f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00054	83 fa 09	 cmp	 edx, 9
  00057	75 5f		 jne	 SHORT $LN5@gObjScoreC
  00059	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00066	83 bc 01 80 1a
	00 00 02	 cmp	 DWORD PTR [ecx+eax+6784], 2
  0006e	74 48		 je	 SHORT $LN5@gObjScoreC

; 2295 : #endif
; 2296 : 		{	
; 2297 : 			gObj[n].m_nEventScore = 0;

  00070	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007d	c7 84 01 c4 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3268], 0

; 2298 : 			gObj[n].m_nEventMoney = 0;

  00088	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00095	c7 84 01 cc 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3276], 0

; 2299 : 			gObj[n].m_nEventExp = 0;	

  000a0	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ad	c7 84 01 c8 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3272], 0
$LN5@gObjScoreC:

; 2300 : 		}
; 2301 : 	}

  000b8	e9 58 ff ff ff	 jmp	 $LN2@gObjScoreC
$LN1@gObjScoreC:

; 2302 : }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?gObjScoreClear@CDevilSquare@@AAEXXZ ENDP		; CDevilSquare::gObjScoreClear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?SendLiveCall@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 3
_this$ = -4						; size = 4
?SendLiveCall@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::SendLiveCall, COMDAT
; _this$ = ecx

; 2279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2280 : 	PMSG_ANS_EVENTLIVE pMsg;	
; 2281 : 	pMsg.h.c		= PMHC_BYTE;

  0000c	c6 45 f8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 2282 : 	pMsg.h.headcode	= 0x03;

  00010	c6 45 fa 03	 mov	 BYTE PTR _pMsg$[ebp+2], 3

; 2283 : 	pMsg.h.size		= sizeof( pMsg );	

  00014	c6 45 f9 03	 mov	 BYTE PTR _pMsg$[ebp+1], 3

; 2284 : 	DataSendRank((char*)&pMsg, pMsg.h.size);

  00018	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001c	50		 push	 eax
  0001d	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ?DataSendRank@@YAXPADH@Z ; DataSendRank
  00026	83 c4 08	 add	 esp, 8

; 2285 : }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?SendLiveCall@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::SendLiveCall
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?CheckSync@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_ltime$ = -16						; size = 8
_today$ = -8						; size = 4
_this$ = -4						; size = 4
?CheckSync@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::CheckSync, COMDAT
; _this$ = ecx

; 844  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 845  : #if TESTSERVER == 1
; 846  : 	m_iRemainTime = 1;
; 847  : 	return;
; 848  : #endif
; 849  : 
; 850  : 	struct tm *today;
; 851  : 	time_t ltime;
; 852  : 	
; 853  : 	time( &ltime );

  0000c	8d 45 f0	 lea	 eax, DWORD PTR _ltime$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _time
  00015	83 c4 04	 add	 esp, 4

; 854  : 	today = localtime( &ltime );

  00018	8d 45 f0	 lea	 eax, DWORD PTR _ltime$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _localtime
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 f8	 mov	 DWORD PTR _today$[ebp], eax

; 855  : 
; 856  : #ifdef FOR_JAPAN
; 857  : 	if( (today->tm_hour%2) == 0 )
; 858  : #else
; 859  : 	if( (today->tm_hour%2) == 1 )

  00027	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  0002a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002d	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  00033	79 05		 jns	 SHORT $LN8@CheckSync
  00035	49		 dec	 ecx
  00036	83 c9 fe	 or	 ecx, -2			; fffffffeH
  00039	41		 inc	 ecx
$LN8@CheckSync:
  0003a	83 f9 01	 cmp	 ecx, 1
  0003d	75 19		 jne	 SHORT $LN2@CheckSync

; 860  : #endif
; 861  : 	{
; 862  : 		m_iRemainTime = 120 - today->tm_min - m_iOpenTime;		

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  00042	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00047	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  0004a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	2b 4a 28	 sub	 ecx, DWORD PTR [edx+40]
  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 863  : 	}

  00056	eb 48		 jmp	 SHORT $LN3@CheckSync
$LN2@CheckSync:

; 864  : 	else
; 865  : 	{
; 866  : 		if( today->tm_min >= 55 )

  00058	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  0005b	83 78 04 37	 cmp	 DWORD PTR [eax+4], 55	; 00000037H
  0005f	7c 28		 jl	 SHORT $LN4@CheckSync

; 867  : 		{
; 868  : 			m_iRemainTime = 60 - today->tm_min - m_iOpenTime;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  00064	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00069	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  0006c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	2b 4a 28	 sub	 ecx, DWORD PTR [edx+40]
  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 869  : 			m_iRemainTime += 120;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0007e	83 c1 78	 add	 ecx, 120		; 00000078H
  00081	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00084	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 870  : 		}

  00087	eb 17		 jmp	 SHORT $LN3@CheckSync
$LN4@CheckSync:

; 871  : 		else
; 872  : 		{
; 873  : 			m_iRemainTime = 60 - today->tm_min - m_iOpenTime;

  00089	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  0008c	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00091	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00094	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00097	2b 4a 28	 sub	 ecx, DWORD PTR [edx+40]
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN3@CheckSync:

; 874  : 		}
; 875  : 	}
; 876  : 
; 877  : 	if( m_iRemainTime < 0 )

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000a7	7d 0f		 jge	 SHORT $LN6@CheckSync

; 878  : 	{
; 879  : 		m_iRemainTime += 60;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000af	83 c1 3c	 add	 ecx, 60			; 0000003cH
  000b2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b5	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN6@CheckSync:

; 880  : 	}
; 881  : 
; 882  : 	LogAddTD("[DevilSquare] Sync Open Time. [%d]min remain", m_iRemainTime);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000be	51		 push	 ecx
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@MKAKKBKJ@?$FLDevilSquare?$FN?5Sync?5Open?5Time?4?5?$FL@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ca	83 c4 08	 add	 esp, 8

; 883  : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
?CheckSync@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::CheckSync
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?ItemClear@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_CurTime$ = -8						; size = 4
_this$ = -4						; size = 4
?ItemClear@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::ItemClear, COMDAT
; _this$ = ecx

; 2240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2241 : 	DWORD CurTime=GetTickCount();

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00012	89 45 f8	 mov	 DWORD PTR _CurTime$[ebp], eax

; 2242 : 	for( int i = 0; i < MAX_MAPITEM; i++ )

  00015	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0001c	eb 09		 jmp	 SHORT $LN4@ItemClear
$LN2@ItemClear:
  0001e	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00021	83 c0 01	 add	 eax, 1
  00024	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@ItemClear:
  00027	81 7d f4 2c 01
	00 00		 cmp	 DWORD PTR _i$1[ebp], 300 ; 0000012cH
  0002e	7d 22		 jge	 SHORT $LN1@ItemClear

; 2243 : 	{
; 2244 : 		MapC[9].m_cItem[i].m_State	= OBJST_DIECMD;

  00030	b8 8c 04 05 00	 mov	 eax, 328844		; 0005048cH
  00035	6b c8 09	 imul	 ecx, eax, 9
  00038	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0003e	69 55 f4 48 04
	00 00		 imul	 edx, DWORD PTR _i$1[ebp], 1096
  00045	c7 84 11 d0 00
	00 00 08 00 00
	00		 mov	 DWORD PTR [ecx+edx+208], 8

; 2245 : 	}

  00050	eb cc		 jmp	 SHORT $LN2@ItemClear
$LN1@ItemClear:

; 2246 : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?ItemClear@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::ItemClear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?SendEventStartMsg@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_n$1 = -556						; size = 4
_pWithOutEvneter$ = -552				; size = 272
_pToEventer$ = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?SendEventStartMsg@CDevilSquare@@AAEXXZ PROC		; CDevilSquare::SendEventStartMsg, COMDAT
; _this$ = ecx

; 1344 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 02 00
	00		 sub	 esp, 684		; 000002acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1345 : 	PMSG_NOTICE	pToEventer;
; 1346 : 	PMSG_NOTICE	pWithOutEvneter;
; 1347 : 	
; 1348 : #ifdef MODIFY_NOTICE_20040325
; 1349 : 	TNotice::MakeNoticeMsg( &pToEventer, 0, lMsg.Get(707) );

  00019	68 c3 02 00 00	 push	 707			; 000002c3H
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00029	50		 push	 eax
  0002a	6a 00		 push	 0
  0002c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pToEventer$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1350 : 	TNotice::MakeNoticeMsg( &pWithOutEvneter, 0, lMsg.Get(708) );

  0003b	68 c4 02 00 00	 push	 708			; 000002c4H
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0004b	50		 push	 eax
  0004c	6a 00		 push	 0
  0004e	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _pWithOutEvneter$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1351 : #else
; 1352 : 	pToEventer.type		= 0;	
; 1353 : 	strcpy(pToEventer.Notice, lMsg.Get(707));	// [악마의 광장]이벤트가 시작되었습니다
; 1354 : 	PHeadSetB((LPBYTE)&pToEventer, 0x0D, 4+(strlen(pToEventer.Notice)+1));
; 1355 : 
; 1356 : 	pWithOutEvneter.type		= 0;
; 1357 : 	strcpy(pWithOutEvneter.Notice, lMsg.Get(708));	//[악마의 광장] 문이 닫혔습니다. 늦으신 분들은 다음기회를 이용해주세요
; 1358 : 	PHeadSetB((LPBYTE)&pWithOutEvneter, 0x0D, 4+(strlen(pWithOutEvneter.Notice)+1));
; 1359 : #endif
; 1360 : 
; 1361 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0005d	c7 85 d4 fd ff
	ff 00 19 00 00	 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00067	eb 0f		 jmp	 SHORT $LN4@SendEventS
$LN2@SendEventS:
  00069	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@SendEventS:
  00078	81 bd d4 fd ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00082	0f 8d 91 00 00
	00		 jge	 $LN3@SendEventS

; 1362 : 	{
; 1363 : 		if( gObj[n].Connected == 3 )

  00088	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00098	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0009d	75 75		 jne	 SHORT $LN5@SendEventS

; 1364 : 		{
; 1365 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 1366 : 			if( CHECK_DEVILSQUARE(gObj[n].MapNumber) && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )
; 1367 : #else
; 1368 : 			if( gObj[n].MapNumber == 9 && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )

  0009f	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000b7	83 fa 09	 cmp	 edx, 9
  000ba	75 3a		 jne	 SHORT $LN6@SendEventS
  000bc	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cc	83 bc 01 80 1a
	00 00 02	 cmp	 DWORD PTR [ecx+eax+6784], 2
  000d4	74 20		 je	 SHORT $LN6@SendEventS

; 1369 : #endif
; 1370 : 			{
; 1371 : 				DataSend(n, (LPBYTE)&pToEventer, pToEventer.h.size);

  000d6	0f b6 85 e9 fe
	ff ff		 movzx	 eax, BYTE PTR _pToEventer$[ebp+1]
  000dd	50		 push	 eax
  000de	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pToEventer$[ebp]
  000e4	51		 push	 ecx
  000e5	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _n$1[ebp]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1372 : 			}

  000f4	eb 1e		 jmp	 SHORT $LN5@SendEventS
$LN6@SendEventS:

; 1373 : 			else
; 1374 : 			{
; 1375 : 				DataSend(n, (LPBYTE)&pWithOutEvneter, pWithOutEvneter.h.size);

  000f6	0f b6 85 d9 fd
	ff ff		 movzx	 eax, BYTE PTR _pWithOutEvneter$[ebp+1]
  000fd	50		 push	 eax
  000fe	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _pWithOutEvneter$[ebp]
  00104	51		 push	 ecx
  00105	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _n$1[ebp]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendEventS:

; 1376 : 			}
; 1377 : 		}
; 1378 : 	}

  00114	e9 50 ff ff ff	 jmp	 $LN2@SendEventS
$LN3@SendEventS:

; 1379 : 
; 1380 : 	LogAddTD("[DevilSquare] Start Event");

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JCOFCPLC@?$FLDevilSquare?$FN?5Start?5Event@
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00124	83 c4 04	 add	 esp, 4

; 1381 : }

  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
?SendEventStartMsg@CDevilSquare@@AAEXXZ ENDP		; CDevilSquare::SendEventStartMsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?ProcPlaying@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_i$1 = -292						; size = 4
_pMsg$2 = -288						; size = 272
_pMsg$3 = -16						; size = 4
_iTime$4 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcPlaying@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::ProcPlaying, COMDAT
; _this$ = ecx

; 1129 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1130 : 	if( m_iremainTimeSec != -1 )

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  00020	0f 84 9b 00 00
	00		 je	 $LN5@ProcPlayin

; 1131 : 	{	// 1분대 부터 초단위 카운트
; 1132 : 		int	iTime = (GetTickCount()-m_iTime)/1000;

  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
  00032	33 d2		 xor	 edx, edx
  00034	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00039	f7 f1		 div	 ecx
  0003b	89 45 f4	 mov	 DWORD PTR _iTime$4[ebp], eax

; 1133 : 
; 1134 : 		if( iTime != 0 )

  0003e	83 7d f4 00	 cmp	 DWORD PTR _iTime$4[ebp], 0
  00042	74 78		 je	 SHORT $LN7@ProcPlayin

; 1135 : 		{
; 1136 : 			m_iremainTimeSec -= iTime;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004a	2b 4d f4	 sub	 ecx, DWORD PTR _iTime$4[ebp]
  0004d	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00050	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1137 : 			m_iTime += iTime*1000;

  00053	69 45 f4 e8 03
	00 00		 imul	 eax, DWORD PTR _iTime$4[ebp], 1000
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00060	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00063	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1138 : 
; 1139 : 			if( m_iremainTimeSec <= 30 && !m_bSendTimeCount )

  00066	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	83 78 10 1e	 cmp	 DWORD PTR [eax+16], 30	; 0000001eH
  0006d	7f 3a		 jg	 SHORT $LN8@ProcPlayin
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00076	75 31		 jne	 SHORT $LN8@ProcPlayin

; 1140 : 			{
; 1141 : 				PMSG_SET_DEVILSQUARE pMsg;
; 1142 : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof( pMsg ));

  00078	6a 04		 push	 4
  0007a	68 92 00 00 00	 push	 146			; 00000092H
  0007f	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$3[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1143 : 				pMsg.Type = 2;

  0008b	c6 45 f3 02	 mov	 BYTE PTR _pMsg$3[ebp+3], 2

; 1144 : #ifdef MODIFY_DEVILSQUARE_CLOSE_MSG_20080717
; 1145 : 				//맵 안에 유저만 보낸다. riverstyx
; 1146 : 				for( int n=0; n<MAX_OBJECT; n++)
; 1147 : 				{
; 1148 : 					if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) && 
; 1149 : 						CHECK_DEVILSQUARE(gObj[n].MapNumber) && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )
; 1150 : 					{
; 1151 : 						DataSend(n, (LPBYTE)&pMsg, sizeof( pMsg ));
; 1152 : 					}
; 1153 : 				}
; 1154 : #else
; 1155 : 				AllSendSameMapMsg((LPBYTE)&pMsg, sizeof( pMsg ), 9);

  0008f	6a 09		 push	 9
  00091	6a 04		 push	 4
  00093	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$3[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?AllSendSameMapMsg@@YAXPAEHE@Z ; AllSendSameMapMsg
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1156 : #endif // MODIFY_DEVILSQUARE_CLOSE_MSG_20080717				
; 1157 : 				m_bSendTimeCount = TRUE;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [eax+20], 1
$LN8@ProcPlayin:

; 1158 : 			}
; 1159 : 			
; 1160 : 			if( m_iremainTimeSec < 1 )

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  000b0	7d 0a		 jge	 SHORT $LN7@ProcPlayin

; 1161 : 			{	// 상태 전환
; 1162 : 				//AllSendServerMsg("[악마의 광장]이 닫혔습니다");				
; 1163 : 				SetState(DevilSquare_CLOSE);

  000b2	6a 00		 push	 0
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState
$LN7@ProcPlayin:

; 1164 : 			}
; 1165 : 		}
; 1166 : 	}

  000bc	e9 16 01 00 00	 jmp	 $LN1@ProcPlayin
$LN5@ProcPlayin:

; 1167 : 	else if( m_iTime < GetTickCount() )

  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  000cd	0f 83 04 01 00
	00		 jae	 $LN1@ProcPlayin

; 1168 : 	{
; 1169 : 		m_iRemainTime--;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000d9	83 e9 01	 sub	 ecx, 1
  000dc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000df	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1170 : 		if( m_iRemainTime > 0 )

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000e9	0f 8e e8 00 00
	00		 jle	 $LN1@ProcPlayin

; 1171 : 		{
; 1172 : 			if( !(m_iRemainTime % 5) )

  000ef	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000f5	99		 cdq
  000f6	b9 05 00 00 00	 mov	 ecx, 5
  000fb	f7 f9		 idiv	 ecx
  000fd	85 d2		 test	 edx, edx
  000ff	75 52		 jne	 SHORT $LN12@ProcPlayin

; 1173 : 			{
; 1174 : 				PMSG_NOTICE	pMsg;
; 1175 : 
; 1176 : #ifdef MODIFY_NOTICE_20040325
; 1177 : 				TNotice::MakeNoticeMsgEx( &pMsg, 0, lMsg.Get(706), m_iRemainTime);

  00101	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00104	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00107	51		 push	 ecx
  00108	68 c2 02 00 00	 push	 706			; 000002c2H
  0010d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00118	50		 push	 eax
  00119	6a 00		 push	 0
  0011b	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$2[ebp]
  00121	52		 push	 edx
  00122	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  00127	83 c4 10	 add	 esp, 16			; 00000010H

; 1178 : 				LogAddTD(pMsg.Notice);

  0012a	8d 85 ed fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$2[ebp+13]
  00130	50		 push	 eax
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00137	83 c4 04	 add	 esp, 4

; 1179 : #else
; 1180 : 				wsprintf(pMsg.Notice, lMsg.Get(706), m_iRemainTime);	// %d분후 [악마의 광장] 문이 닫힙니다
; 1181 : 				LogAddTD(pMsg.Notice);
; 1182 : 				
; 1183 : 				PHeadSetB((LPBYTE)&pMsg, 0x0D, 4+(strlen(pMsg.Notice)+1));
; 1184 : 				pMsg.type		= 0;
; 1185 : #endif
; 1186 : 
; 1187 : 				AllSendSameMapMsg((LPBYTE)&pMsg, pMsg.h.size, 9);

  0013a	6a 09		 push	 9
  0013c	0f b6 85 e1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$2[ebp+1]
  00143	50		 push	 eax
  00144	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$2[ebp]
  0014a	51		 push	 ecx
  0014b	e8 00 00 00 00	 call	 ?AllSendSameMapMsg@@YAXPAEHE@Z ; AllSendSameMapMsg
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@ProcPlayin:

; 1188 : 			}
; 1189 : 
; 1190 : 			for( int i = 0; i < MAX_DEVILSQUARE; i++ )

  00153	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  0015d	eb 0f		 jmp	 SHORT $LN4@ProcPlayin
$LN2@ProcPlayin:
  0015f	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00165	83 c0 01	 add	 eax, 1
  00168	89 85 dc fe ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@ProcPlayin:
  0016e	83 bd dc fe ff
	ff 04		 cmp	 DWORD PTR _i$1[ebp], 4
  00175	7d 25		 jge	 SHORT $LN3@ProcPlayin

; 1191 : 			{	// 보스 몬스터 리젠을 설정한다
; 1192 : 				m_DevilSquareGround[i].RegenBossMonster(m_iPlaytime-m_iRemainTime);

  00177	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017d	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00180	2b 51 0c	 sub	 edx, DWORD PTR [ecx+12]
  00183	52		 push	 edx
  00184	69 85 dc fe ff
	ff e0 03 00 00	 imul	 eax, DWORD PTR _i$1[ebp], 992
  0018e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00191	8d 4c 01 30	 lea	 ecx, DWORD PTR [ecx+eax+48]
  00195	e8 00 00 00 00	 call	 ?RegenBossMonster@CDevilSquareGround@@QAEXH@Z ; CDevilSquareGround::RegenBossMonster

; 1193 : 			}

  0019a	eb c3		 jmp	 SHORT $LN2@ProcPlayin
$LN3@ProcPlayin:

; 1194 : 
; 1195 : 			if( m_iRemainTime == 1 && m_iremainTimeSec == -1 )

  0019c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019f	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  001a3	75 21		 jne	 SHORT $LN13@ProcPlayin
  001a5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a8	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  001ac	75 18		 jne	 SHORT $LN13@ProcPlayin

; 1196 : 			{
; 1197 : 				m_iremainTimeSec = 60;

  001ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001b1	c7 40 10 3c 00
	00 00		 mov	 DWORD PTR [eax+16], 60	; 0000003cH

; 1198 : 				m_iTime = GetTickCount();

  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1199 : 			}			

  001c4	eb 11		 jmp	 SHORT $LN1@ProcPlayin
$LN13@ProcPlayin:

; 1200 : 			else
; 1201 : 			{
; 1202 : 				m_iTime = GetTickCount()+DEVILSQUARE_MIN;

  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001cc	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  001d1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d4	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@ProcPlayin:

; 1203 : 			}
; 1204 : 		}
; 1205 : 	}
; 1206 : }

  001d7	5f		 pop	 edi
  001d8	5e		 pop	 esi
  001d9	5b		 pop	 ebx
  001da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001dd	33 cd		 xor	 ecx, ebp
  001df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e4	8b e5		 mov	 esp, ebp
  001e6	5d		 pop	 ebp
  001e7	c3		 ret	 0
?ProcPlaying@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::ProcPlaying
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?ProcOpen@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
tv216 = -368						; size = 4
tv203 = -368						; size = 4
tv151 = -368						; size = 4
tv138 = -368						; size = 4
tv217 = -364						; size = 4
tv204 = -364						; size = 4
tv152 = -364						; size = 4
tv139 = -364						; size = 4
_n$1 = -296						; size = 4
_pNotice$2 = -292					; size = 272
_n$3 = -20						; size = 4
_pMsg$4 = -16						; size = 4
_iTime$5 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcOpen@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::ProcOpen, COMDAT
; _this$ = ecx

; 1034 : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1035 : 	if( m_iremainTimeSec != -1 )

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  00020	0f 84 e5 01 00
	00		 je	 $LN8@ProcOpen

; 1036 : 	{	// 1분대 부터 초단위 카운트
; 1037 : 		int	iTime = (GetTickCount()-m_iTime)/1000;

  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
  00032	33 d2		 xor	 edx, edx
  00034	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00039	f7 f1		 div	 ecx
  0003b	89 45 f4	 mov	 DWORD PTR _iTime$5[ebp], eax

; 1038 : 
; 1039 : 		if( iTime != 0 )

  0003e	83 7d f4 00	 cmp	 DWORD PTR _iTime$5[ebp], 0
  00042	0f 84 be 01 00
	00		 je	 $LN10@ProcOpen

; 1040 : 		{
; 1041 : 			m_iremainTimeSec -= iTime;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004e	2b 4d f4	 sub	 ecx, DWORD PTR _iTime$5[ebp]
  00051	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00054	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1042 : 			m_iTime += iTime*1000;

  00057	69 45 f4 e8 03
	00 00		 imul	 eax, DWORD PTR _iTime$5[ebp], 1000
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00064	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00067	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1043 : 			
; 1044 : 			if( m_iremainTimeSec <= 30 && !m_bSendTimeCount )

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	83 78 10 1e	 cmp	 DWORD PTR [eax+16], 30	; 0000001eH
  00071	0f 8f 74 01 00
	00		 jg	 $LN11@ProcOpen
  00077	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0007e	0f 85 67 01 00
	00		 jne	 $LN11@ProcOpen

; 1045 : 			{	// 30초에 카운트 명령 보낸다
; 1046 : 				PMSG_SET_DEVILSQUARE pMsg;
; 1047 : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof( pMsg ));

  00084	6a 04		 push	 4
  00086	68 92 00 00 00	 push	 146			; 00000092H
  0008b	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$4[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1048 : 				pMsg.Type = 1;

  00097	c6 45 f3 01	 mov	 BYTE PTR _pMsg$4[ebp+3], 1

; 1049 : #ifdef FOR_BLOODCASTLE
; 1050 : 				for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0009b	c7 45 ec 00 19
	00 00		 mov	 DWORD PTR _n$3[ebp], 6400 ; 00001900H
  000a2	eb 09		 jmp	 SHORT $LN4@ProcOpen
$LN2@ProcOpen:
  000a4	8b 45 ec	 mov	 eax, DWORD PTR _n$3[ebp]
  000a7	83 c0 01	 add	 eax, 1
  000aa	89 45 ec	 mov	 DWORD PTR _n$3[ebp], eax
$LN4@ProcOpen:
  000ad	81 7d ec e8 1c
	00 00		 cmp	 DWORD PTR _n$3[ebp], 7400 ; 00001ce8H
  000b4	0f 8d 27 01 00
	00		 jge	 $LN3@ProcOpen

; 1051 : 				{
; 1052 : 					if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) && (!CHECK_BLOODCASTLE(gObj[n].MapNumber)) 
; 1053 : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 1054 : 						&& (!CHECK_CHAOSCASTLE(gObj[n].MapNumber))

  000ba	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$3[ebp], 7072
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  000cc	0f 85 0a 01 00
	00		 jne	 $LN12@ProcOpen
  000d2	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$3[ebp], 7072
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000df	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000e4	83 fa 01	 cmp	 edx, 1
  000e7	0f 85 ef 00 00
	00		 jne	 $LN12@ProcOpen
  000ed	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$3[ebp], 7072
  000f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fa	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00102	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00105	7d 0c		 jge	 SHORT $LN22@ProcOpen
  00107	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv139[ebp], 0
  00111	eb 3c		 jmp	 SHORT $LN23@ProcOpen
$LN22@ProcOpen:
  00113	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$3[ebp], 7072
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00120	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00128	83 fa 11	 cmp	 edx, 17			; 00000011H
  0012b	7e 0c		 jle	 SHORT $LN20@ProcOpen
  0012d	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv138[ebp], 0
  00137	eb 0a		 jmp	 SHORT $LN21@ProcOpen
$LN20@ProcOpen:
  00139	c7 85 90 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv138[ebp], 1
$LN21@ProcOpen:
  00143	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv138[ebp]
  00149	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv139[ebp], eax
$LN23@ProcOpen:
  0014f	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv139[ebp], 0
  00156	0f 85 80 00 00
	00		 jne	 $LN12@ProcOpen
  0015c	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$3[ebp], 7072
  00163	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00169	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00171	83 fa 12	 cmp	 edx, 18			; 00000012H
  00174	7d 0c		 jge	 SHORT $LN26@ProcOpen
  00176	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
  00180	eb 3c		 jmp	 SHORT $LN27@ProcOpen
$LN26@ProcOpen:
  00182	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$3[ebp], 7072
  00189	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018f	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00197	83 fa 17	 cmp	 edx, 23			; 00000017H
  0019a	7e 0c		 jle	 SHORT $LN24@ProcOpen
  0019c	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv151[ebp], 0
  001a6	eb 0a		 jmp	 SHORT $LN25@ProcOpen
$LN24@ProcOpen:
  001a8	c7 85 90 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv151[ebp], 1
$LN25@ProcOpen:
  001b2	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv151[ebp]
  001b8	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv152[ebp], eax
$LN27@ProcOpen:
  001be	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv152[ebp], 0
  001c5	75 15		 jne	 SHORT $LN12@ProcOpen

; 1055 : #endif
; 1056 : 						)
; 1057 : 					{
; 1058 : 						DataSend(n, (LPBYTE)&pMsg, pMsg.h.size);

  001c7	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$4[ebp+1]
  001cb	50		 push	 eax
  001cc	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$4[ebp]
  001cf	51		 push	 ecx
  001d0	8b 55 ec	 mov	 edx, DWORD PTR _n$3[ebp]
  001d3	52		 push	 edx
  001d4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@ProcOpen:

; 1059 : 					}
; 1060 : 				}

  001dc	e9 c3 fe ff ff	 jmp	 $LN2@ProcOpen
$LN3@ProcOpen:

; 1061 : #else
; 1062 : 				AllSendMsg((LPBYTE)&pMsg, sizeof( pMsg ));
; 1063 : #endif				
; 1064 : 
; 1065 : 				m_bSendTimeCount = TRUE;

  001e1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001e4	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [eax+20], 1
$LN11@ProcOpen:

; 1066 : 			}			
; 1067 : 			
; 1068 : 			if( m_iremainTimeSec < 1 )

  001eb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001ee	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  001f2	7d 12		 jge	 SHORT $LN10@ProcOpen

; 1069 : 			{	// 상태 전환
; 1070 : 				SendEventStartMsg();

  001f4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f7	e8 00 00 00 00	 call	 ?SendEventStartMsg@CDevilSquare@@AAEXXZ ; CDevilSquare::SendEventStartMsg

; 1071 : 				SetState(DevilSquare_PLAYING);

  001fc	6a 02		 push	 2
  001fe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00201	e8 00 00 00 00	 call	 ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState
$LN10@ProcOpen:

; 1072 : 			}			
; 1073 : 		}
; 1074 : 	}

  00206	e9 23 02 00 00	 jmp	 $LN1@ProcOpen
$LN8@ProcOpen:

; 1075 : 	else if( m_iTime < GetTickCount() )

  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00211	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00214	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00217	0f 83 11 02 00
	00		 jae	 $LN1@ProcOpen

; 1076 : 	{	
; 1077 : 		ClearMonstr();

  0021d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00220	e8 00 00 00 00	 call	 ?ClearMonstr@CDevilSquare@@QAEXXZ ; CDevilSquare::ClearMonstr

; 1078 : 		m_iRemainTime--;

  00225	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00228	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0022b	83 e9 01	 sub	 ecx, 1
  0022e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00231	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1079 : 		if( m_iRemainTime > 0 )

  00234	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00237	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0023b	0f 8e b2 01 00
	00		 jle	 $LN15@ProcOpen

; 1080 : 		{
; 1081 : 
; 1082 : #ifdef FOR_BLOODCASTLE
; 1083 : 			PMSG_NOTICE	pNotice;
; 1084 : 
; 1085 : #ifdef MODIFY_NOTICE_20040325
; 1086 : 			TNotice::MakeNoticeMsgEx( &pNotice, 0, lMsg.Get(705), m_iRemainTime);

  00241	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00244	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00247	51		 push	 ecx
  00248	68 c1 02 00 00	 push	 705			; 000002c1H
  0024d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00252	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00258	50		 push	 eax
  00259	6a 00		 push	 0
  0025b	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$2[ebp]
  00261	52		 push	 edx
  00262	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  00267	83 c4 10	 add	 esp, 16			; 00000010H

; 1087 : #else
; 1088 : 			pNotice.type		= 0;
; 1089 : 			wsprintf(pNotice.Notice, lMsg.Get(705), m_iRemainTime);	//%d분후 [악마의 광장] 이벤트가 시작 됩니다
; 1090 : 			PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 1091 : #endif
; 1092 : 
; 1093 : 			for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0026a	c7 85 d8 fe ff
	ff 00 19 00 00	 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00274	eb 0f		 jmp	 SHORT $LN7@ProcOpen
$LN5@ProcOpen:
  00276	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  0027c	83 c0 01	 add	 eax, 1
  0027f	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN7@ProcOpen:
  00285	81 bd d8 fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  0028f	0f 8d 42 01 00
	00		 jge	 $LN6@ProcOpen

; 1094 : 			{
; 1095 : 				if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) && (!CHECK_BLOODCASTLE(gObj[n].MapNumber))
; 1096 : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 1097 : 						&& (!CHECK_CHAOSCASTLE(gObj[n].MapNumber))

  00295	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0029f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a5	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  002aa	0f 85 22 01 00
	00		 jne	 $LN16@ProcOpen
  002b0	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  002ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c0	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  002c5	83 fa 01	 cmp	 edx, 1
  002c8	0f 85 04 01 00
	00		 jne	 $LN16@ProcOpen
  002ce	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  002d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002de	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  002e6	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  002e9	7d 0c		 jge	 SHORT $LN30@ProcOpen
  002eb	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv204[ebp], 0
  002f5	eb 3f		 jmp	 SHORT $LN31@ProcOpen
$LN30@ProcOpen:
  002f7	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00301	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00307	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0030f	83 fa 11	 cmp	 edx, 17			; 00000011H
  00312	7e 0c		 jle	 SHORT $LN28@ProcOpen
  00314	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv203[ebp], 0
  0031e	eb 0a		 jmp	 SHORT $LN29@ProcOpen
$LN28@ProcOpen:
  00320	c7 85 90 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv203[ebp], 1
$LN29@ProcOpen:
  0032a	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv203[ebp]
  00330	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv204[ebp], eax
$LN31@ProcOpen:
  00336	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv204[ebp], 0
  0033d	0f 85 8f 00 00
	00		 jne	 $LN16@ProcOpen
  00343	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0034d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00353	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0035b	83 fa 12	 cmp	 edx, 18			; 00000012H
  0035e	7d 0c		 jge	 SHORT $LN34@ProcOpen
  00360	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv217[ebp], 0
  0036a	eb 3f		 jmp	 SHORT $LN35@ProcOpen
$LN34@ProcOpen:
  0036c	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00376	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0037c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00384	83 fa 17	 cmp	 edx, 23			; 00000017H
  00387	7e 0c		 jle	 SHORT $LN32@ProcOpen
  00389	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv216[ebp], 0
  00393	eb 0a		 jmp	 SHORT $LN33@ProcOpen
$LN32@ProcOpen:
  00395	c7 85 90 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv216[ebp], 1
$LN33@ProcOpen:
  0039f	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv216[ebp]
  003a5	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv217[ebp], eax
$LN35@ProcOpen:
  003ab	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv217[ebp], 0
  003b2	75 1e		 jne	 SHORT $LN16@ProcOpen

; 1098 : #endif
; 1099 : 					)
; 1100 : 				{
; 1101 : 					DataSend(n, (LPBYTE)&pNotice, pNotice.h.size);

  003b4	0f b6 85 dd fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$2[ebp+1]
  003bb	50		 push	 eax
  003bc	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$2[ebp]
  003c2	51		 push	 ecx
  003c3	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _n$1[ebp]
  003c9	52		 push	 edx
  003ca	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@ProcOpen:

; 1102 : 				}
; 1103 : 			}

  003d2	e9 9f fe ff ff	 jmp	 $LN5@ProcOpen
$LN6@ProcOpen:

; 1104 : 
; 1105 : 			LogAddTD(pNotice.Notice);

  003d7	8d 85 e9 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$2[ebp+13]
  003dd	50		 push	 eax
  003de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003e4	83 c4 04	 add	 esp, 4

; 1106 : #else
; 1107 : 			char msg[255];
; 1108 : 			wsprintf(msg, lMsg.Get(705), m_iRemainTime);			//%d분후 [악마의 광장] 이벤트가 시작 됩니다
; 1109 : 			AllSendServerMsg(msg);
; 1110 : 
; 1111 : 			LogAddTD(msg);
; 1112 : #endif
; 1113 : 			m_iTime = GetTickCount();

  003e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  003ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003f0	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN15@ProcOpen:

; 1114 : 		}		
; 1115 : 		
; 1116 : 		if( m_iRemainTime == 1 && m_iremainTimeSec == -1 )

  003f3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003f6	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  003fa	75 21		 jne	 SHORT $LN17@ProcOpen
  003fc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003ff	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  00403	75 18		 jne	 SHORT $LN17@ProcOpen

; 1117 : 		{
; 1118 : 			m_iremainTimeSec = 60;

  00405	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00408	c7 40 10 3c 00
	00 00		 mov	 DWORD PTR [eax+16], 60	; 0000003cH

; 1119 : 			m_iTime = GetTickCount();

  0040f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00415	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00418	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1120 : 		}			

  0041b	eb 11		 jmp	 SHORT $LN1@ProcOpen
$LN17@ProcOpen:

; 1121 : 		else
; 1122 : 		{
; 1123 : 			m_iTime = GetTickCount()+DEVILSQUARE_MIN;

  0041d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00423	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  00428	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0042b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@ProcOpen:

; 1124 : 		}
; 1125 : 	}		
; 1126 : }

  0042e	5f		 pop	 edi
  0042f	5e		 pop	 esi
  00430	5b		 pop	 ebx
  00431	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00434	33 cd		 xor	 ecx, ebp
  00436	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0043b	8b e5		 mov	 esp, ebp
  0043d	5d		 pop	 ebp
  0043e	c3		 ret	 0
?ProcOpen@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::ProcOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?ProcClose@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
tv287 = -712						; size = 4
tv274 = -712						; size = 4
tv201 = -712						; size = 4
tv188 = -712						; size = 4
tv151 = -712						; size = 4
tv138 = -712						; size = 4
tv288 = -708						; size = 4
tv275 = -708						; size = 4
tv202 = -708						; size = 4
tv189 = -708						; size = 4
tv152 = -708						; size = 4
tv139 = -708						; size = 4
_n$1 = -576						; size = 4
_pNotice$2 = -572					; size = 272
_n$3 = -300						; size = 4
_n$4 = -296						; size = 4
_pNotice$5 = -292					; size = 272
_n$6 = -20						; size = 4
_pMsg$7 = -16						; size = 4
_iTime$8 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcClose@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::ProcClose, COMDAT
; _this$ = ecx

; 891  : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 02 00
	00		 sub	 esp, 712		; 000002c8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 892  : 	if( m_iremainTimeSec != -1 )

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  00020	0f 84 80 03 00
	00		 je	 $LN14@ProcClose

; 893  : 	{	// 1분대 부터 초단위 카운트
; 894  : 
; 895  : 		int	iTime = (GetTickCount()-m_iTime)/1000;

  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
  00032	33 d2		 xor	 edx, edx
  00034	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00039	f7 f1		 div	 ecx
  0003b	89 45 f4	 mov	 DWORD PTR _iTime$8[ebp], eax

; 896  : 
; 897  : 		if( iTime != 0 )

  0003e	83 7d f4 00	 cmp	 DWORD PTR _iTime$8[ebp], 0
  00042	0f 84 59 03 00
	00		 je	 $LN16@ProcClose

; 898  : 		{
; 899  : 			m_iremainTimeSec -= iTime;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004e	2b 4d f4	 sub	 ecx, DWORD PTR _iTime$8[ebp]
  00051	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00054	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 900  : 			m_iTime += iTime*1000;

  00057	69 45 f4 e8 03
	00 00		 imul	 eax, DWORD PTR _iTime$8[ebp], 1000
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00064	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00067	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 901  : 
; 902  : 			if( m_iremainTimeSec <= 30 && !m_bSendTimeCount )

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	83 78 10 1e	 cmp	 DWORD PTR [eax+16], 30	; 0000001eH
  00071	0f 8f 74 01 00
	00		 jg	 $LN17@ProcClose
  00077	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0007e	0f 85 67 01 00
	00		 jne	 $LN17@ProcClose

; 903  : 			{	// 30초에 카운트 명령 보낸다
; 904  : 				PMSG_SET_DEVILSQUARE pMsg;
; 905  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof( pMsg ));

  00084	6a 04		 push	 4
  00086	68 92 00 00 00	 push	 146			; 00000092H
  0008b	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$7[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 906  : 				pMsg.Type = 0;

  00097	c6 45 f3 00	 mov	 BYTE PTR _pMsg$7[ebp+3], 0

; 907  : #ifdef FOR_BLOODCASTLE
; 908  : 				for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0009b	c7 45 ec 00 19
	00 00		 mov	 DWORD PTR _n$6[ebp], 6400 ; 00001900H
  000a2	eb 09		 jmp	 SHORT $LN4@ProcClose
$LN2@ProcClose:
  000a4	8b 45 ec	 mov	 eax, DWORD PTR _n$6[ebp]
  000a7	83 c0 01	 add	 eax, 1
  000aa	89 45 ec	 mov	 DWORD PTR _n$6[ebp], eax
$LN4@ProcClose:
  000ad	81 7d ec e8 1c
	00 00		 cmp	 DWORD PTR _n$6[ebp], 7400 ; 00001ce8H
  000b4	0f 8d 27 01 00
	00		 jge	 $LN3@ProcClose

; 909  : 				{
; 910  : 					if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) && (!CHECK_BLOODCASTLE(gObj[n].MapNumber))
; 911  : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 912  : 						&& (!CHECK_CHAOSCASTLE(gObj[n].MapNumber))

  000ba	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$6[ebp], 7072
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  000cc	0f 85 0a 01 00
	00		 jne	 $LN18@ProcClose
  000d2	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$6[ebp], 7072
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000df	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000e4	83 fa 01	 cmp	 edx, 1
  000e7	0f 85 ef 00 00
	00		 jne	 $LN18@ProcClose
  000ed	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$6[ebp], 7072
  000f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fa	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00102	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00105	7d 0c		 jge	 SHORT $LN33@ProcClose
  00107	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv139[ebp], 0
  00111	eb 3c		 jmp	 SHORT $LN34@ProcClose
$LN33@ProcClose:
  00113	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$6[ebp], 7072
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00120	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00128	83 fa 11	 cmp	 edx, 17			; 00000011H
  0012b	7e 0c		 jle	 SHORT $LN31@ProcClose
  0012d	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv138[ebp], 0
  00137	eb 0a		 jmp	 SHORT $LN32@ProcClose
$LN31@ProcClose:
  00139	c7 85 38 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv138[ebp], 1
$LN32@ProcClose:
  00143	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR tv138[ebp]
  00149	89 85 3c fd ff
	ff		 mov	 DWORD PTR tv139[ebp], eax
$LN34@ProcClose:
  0014f	83 bd 3c fd ff
	ff 00		 cmp	 DWORD PTR tv139[ebp], 0
  00156	0f 85 80 00 00
	00		 jne	 $LN18@ProcClose
  0015c	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$6[ebp], 7072
  00163	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00169	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00171	83 fa 12	 cmp	 edx, 18			; 00000012H
  00174	7d 0c		 jge	 SHORT $LN37@ProcClose
  00176	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
  00180	eb 3c		 jmp	 SHORT $LN38@ProcClose
$LN37@ProcClose:
  00182	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$6[ebp], 7072
  00189	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018f	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00197	83 fa 17	 cmp	 edx, 23			; 00000017H
  0019a	7e 0c		 jle	 SHORT $LN35@ProcClose
  0019c	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv151[ebp], 0
  001a6	eb 0a		 jmp	 SHORT $LN36@ProcClose
$LN35@ProcClose:
  001a8	c7 85 38 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv151[ebp], 1
$LN36@ProcClose:
  001b2	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR tv151[ebp]
  001b8	89 85 3c fd ff
	ff		 mov	 DWORD PTR tv152[ebp], eax
$LN38@ProcClose:
  001be	83 bd 3c fd ff
	ff 00		 cmp	 DWORD PTR tv152[ebp], 0
  001c5	75 15		 jne	 SHORT $LN18@ProcClose

; 913  : #endif
; 914  : 						)
; 915  : 					{
; 916  : 						DataSend(n, (LPBYTE)&pMsg, pMsg.h.size);

  001c7	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$7[ebp+1]
  001cb	50		 push	 eax
  001cc	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$7[ebp]
  001cf	51		 push	 ecx
  001d0	8b 55 ec	 mov	 edx, DWORD PTR _n$6[ebp]
  001d3	52		 push	 edx
  001d4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@ProcClose:

; 917  : 					}
; 918  : 				}

  001dc	e9 c3 fe ff ff	 jmp	 $LN2@ProcClose
$LN3@ProcClose:

; 919  : #else
; 920  : 				AllSendMsg((LPBYTE)&pMsg, sizeof( pMsg ));
; 921  : #endif				
; 922  : 				m_bSendTimeCount = TRUE;

  001e1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001e4	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [eax+20], 1
$LN17@ProcClose:

; 923  : 			}			
; 924  : 			
; 925  : 			if( m_iremainTimeSec < 1 )

  001eb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001ee	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  001f2	0f 8d a9 01 00
	00		 jge	 $LN16@ProcClose

; 926  : 			{	// 상태 전환
; 927  : #ifdef FOR_BLOODCASTLE
; 928  : 				PMSG_NOTICE	pNotice;
; 929  : 
; 930  : #ifdef MODIFY_NOTICE_20040325
; 931  : 				TNotice::MakeNoticeMsg( &pNotice, 0, lMsg.Get(703));

  001f8	68 bf 02 00 00	 push	 703			; 000002bfH
  001fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00202	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00208	50		 push	 eax
  00209	6a 00		 push	 0
  0020b	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$5[ebp]
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00217	83 c4 0c	 add	 esp, 12			; 0000000cH

; 932  : #else
; 933  : 				pNotice.type		= 0;
; 934  : 				strcpy(pNotice.Notice, lMsg.Get(703));	//"[악마의 광장] 문이 열렸습니다"
; 935  : 				PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 936  : #endif
; 937  : 
; 938  : 				for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0021a	c7 85 d8 fe ff
	ff 00 19 00 00	 mov	 DWORD PTR _n$4[ebp], 6400 ; 00001900H
  00224	eb 0f		 jmp	 SHORT $LN7@ProcClose
$LN5@ProcClose:
  00226	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0022c	83 c0 01	 add	 eax, 1
  0022f	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _n$4[ebp], eax
$LN7@ProcClose:
  00235	81 bd d8 fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _n$4[ebp], 7400 ; 00001ce8H
  0023f	0f 8d 42 01 00
	00		 jge	 $LN6@ProcClose

; 939  : 				{
; 940  : 					if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) && (!CHECK_BLOODCASTLE(gObj[n].MapNumber))
; 941  : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 942  : 						&& (!CHECK_CHAOSCASTLE(gObj[n].MapNumber))

  00245	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$4[ebp], 7072
  0024f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00255	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0025a	0f 85 22 01 00
	00		 jne	 $LN20@ProcClose
  00260	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$4[ebp], 7072
  0026a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00270	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00275	83 fa 01	 cmp	 edx, 1
  00278	0f 85 04 01 00
	00		 jne	 $LN20@ProcClose
  0027e	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$4[ebp], 7072
  00288	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0028e	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00296	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00299	7d 0c		 jge	 SHORT $LN41@ProcClose
  0029b	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv189[ebp], 0
  002a5	eb 3f		 jmp	 SHORT $LN42@ProcClose
$LN41@ProcClose:
  002a7	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$4[ebp], 7072
  002b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b7	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  002bf	83 fa 11	 cmp	 edx, 17			; 00000011H
  002c2	7e 0c		 jle	 SHORT $LN39@ProcClose
  002c4	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv188[ebp], 0
  002ce	eb 0a		 jmp	 SHORT $LN40@ProcClose
$LN39@ProcClose:
  002d0	c7 85 38 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv188[ebp], 1
$LN40@ProcClose:
  002da	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR tv188[ebp]
  002e0	89 85 3c fd ff
	ff		 mov	 DWORD PTR tv189[ebp], eax
$LN42@ProcClose:
  002e6	83 bd 3c fd ff
	ff 00		 cmp	 DWORD PTR tv189[ebp], 0
  002ed	0f 85 8f 00 00
	00		 jne	 $LN20@ProcClose
  002f3	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$4[ebp], 7072
  002fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00303	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0030b	83 fa 12	 cmp	 edx, 18			; 00000012H
  0030e	7d 0c		 jge	 SHORT $LN45@ProcClose
  00310	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv202[ebp], 0
  0031a	eb 3f		 jmp	 SHORT $LN46@ProcClose
$LN45@ProcClose:
  0031c	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$4[ebp], 7072
  00326	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0032c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00334	83 fa 17	 cmp	 edx, 23			; 00000017H
  00337	7e 0c		 jle	 SHORT $LN43@ProcClose
  00339	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
  00343	eb 0a		 jmp	 SHORT $LN44@ProcClose
$LN43@ProcClose:
  00345	c7 85 38 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv201[ebp], 1
$LN44@ProcClose:
  0034f	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR tv201[ebp]
  00355	89 85 3c fd ff
	ff		 mov	 DWORD PTR tv202[ebp], eax
$LN46@ProcClose:
  0035b	83 bd 3c fd ff
	ff 00		 cmp	 DWORD PTR tv202[ebp], 0
  00362	75 1e		 jne	 SHORT $LN20@ProcClose

; 943  : #endif
; 944  : 						)
; 945  : 					{
; 946  : 						DataSend(n, (LPBYTE)&pNotice, pNotice.h.size);

  00364	0f b6 85 dd fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$5[ebp+1]
  0036b	50		 push	 eax
  0036c	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$5[ebp]
  00372	51		 push	 ecx
  00373	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _n$4[ebp]
  00379	52		 push	 edx
  0037a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0037f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@ProcClose:

; 947  : 					}
; 948  : 				}

  00382	e9 9f fe ff ff	 jmp	 $LN5@ProcClose
$LN6@ProcClose:

; 949  : 				LogAddTD(pNotice.Notice);

  00387	8d 85 e9 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$5[ebp+13]
  0038d	50		 push	 eax
  0038e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00394	83 c4 04	 add	 esp, 4

; 950  : #else
; 951  : 				char msg[255];
; 952  : 				wsprintf(msg, lMsg.Get(703));	//"[악마의 광장] 문이 열렸습니다"
; 953  : 				AllSendServerMsg(msg);
; 954  : 				LogAddTD(msg);
; 955  : #endif				
; 956  : 				SetState(DevilSquare_OPEN);

  00397	6a 01		 push	 1
  00399	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0039c	e8 00 00 00 00	 call	 ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState
$LN16@ProcClose:

; 957  : 			}			
; 958  : 		}
; 959  : 	}

  003a1	e9 d4 02 00 00	 jmp	 $LN1@ProcClose
$LN14@ProcClose:

; 960  : 	else if( m_iTime < GetTickCount() )

  003a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  003ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003af	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  003b2	0f 83 c2 02 00
	00		 jae	 $LN1@ProcClose

; 961  : 	{	
; 962  : 		ClearMonstr();

  003b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003bb	e8 00 00 00 00	 call	 ?ClearMonstr@CDevilSquare@@QAEXXZ ; CDevilSquare::ClearMonstr

; 963  : 		m_iRemainTime--;

  003c0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003c3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  003c6	83 e9 01	 sub	 ecx, 1
  003c9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003cc	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 964  : 
; 965  : 		if( !m_bFlag )

  003cf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003d2	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  003d6	0f 85 92 00 00
	00		 jne	 $LN22@ProcClose

; 966  : 		{	// 광장을 빠져나가기까지 일분의 시간을 준다
; 967  : 			for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  003dc	c7 85 d4 fe ff
	ff 00 19 00 00	 mov	 DWORD PTR _n$3[ebp], 6400 ; 00001900H
  003e6	eb 0f		 jmp	 SHORT $LN10@ProcClose
$LN8@ProcClose:
  003e8	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _n$3[ebp]
  003ee	83 c0 01	 add	 eax, 1
  003f1	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _n$3[ebp], eax
$LN10@ProcClose:
  003f7	81 bd d4 fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _n$3[ebp], 7400 ; 00001ce8H
  00401	7d 61		 jge	 SHORT $LN9@ProcClose

; 968  : 			{
; 969  : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 970  : 				if( gObj[n].Connected == 3 && CHECK_DEVILSQUARE(gObj[n].MapNumber) && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )
; 971  : #else
; 972  : 				if( gObj[n].Connected == 3 && gObj[n].MapNumber == 9  && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )

  00403	69 85 d4 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 7072
  0040d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00413	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00418	75 48		 jne	 SHORT $LN24@ProcClose
  0041a	69 85 d4 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 7072
  00424	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0042a	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00432	83 fa 09	 cmp	 edx, 9
  00435	75 2b		 jne	 SHORT $LN24@ProcClose
  00437	69 85 d4 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$3[ebp], 7072
  00441	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00447	83 bc 01 80 1a
	00 00 02	 cmp	 DWORD PTR [ecx+eax+6784], 2
  0044f	74 11		 je	 SHORT $LN24@ProcClose

; 973  : #endif
; 974  : 				{					
; 975  : 					gObjMoveGate(n, 27);

  00451	6a 1b		 push	 27			; 0000001bH
  00453	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _n$3[ebp]
  00459	50		 push	 eax
  0045a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0045f	83 c4 08	 add	 esp, 8
$LN24@ProcClose:

; 976  : 				}
; 977  : 			}

  00462	eb 84		 jmp	 SHORT $LN8@ProcClose
$LN9@ProcClose:

; 978  : 			ItemClear();

  00464	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00467	e8 00 00 00 00	 call	 ?ItemClear@CDevilSquare@@AAEXXZ ; CDevilSquare::ItemClear

; 979  : 		}

  0046c	eb 08		 jmp	 SHORT $LN23@ProcClose
$LN22@ProcClose:

; 980  : 		else
; 981  : 		{
; 982  : 			CheckInvalidUser();

  0046e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00471	e8 00 00 00 00	 call	 ?CheckInvalidUser@CDevilSquare@@AAEXXZ ; CDevilSquare::CheckInvalidUser
$LN23@ProcClose:

; 983  : 		}
; 984  : 
; 985  : 		if( m_iRemainTime <= 15 )

  00476	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00479	83 78 0c 0f	 cmp	 DWORD PTR [eax+12], 15	; 0000000fH
  0047d	0f 8f bc 01 00
	00		 jg	 $LN25@ProcClose

; 986  : 		{
; 987  : 			if( !(m_iRemainTime % 5) )

  00483	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00486	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00489	99		 cdq
  0048a	b9 05 00 00 00	 mov	 ecx, 5
  0048f	f7 f9		 idiv	 ecx
  00491	85 d2		 test	 edx, edx
  00493	0f 85 a6 01 00
	00		 jne	 $LN25@ProcClose

; 988  : 			{
; 989  : #ifdef FOR_BLOODCASTLE
; 990  : 				PMSG_NOTICE	pNotice;
; 991  : 					
; 992  : #ifdef MODIFY_NOTICE_20040325
; 993  : 				TNotice::MakeNoticeMsgEx( &pNotice, 0, lMsg.Get(704), m_iRemainTime);

  00499	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0049c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0049f	51		 push	 ecx
  004a0	68 c0 02 00 00	 push	 704			; 000002c0H
  004a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  004b0	50		 push	 eax
  004b1	6a 00		 push	 0
  004b3	8d 95 c4 fd ff
	ff		 lea	 edx, DWORD PTR _pNotice$2[ebp]
  004b9	52		 push	 edx
  004ba	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  004bf	83 c4 10	 add	 esp, 16			; 00000010H

; 994  : #else
; 995  : 				pNotice.type		= 0;
; 996  : 				wsprintf(pNotice.Notice, lMsg.Get(704), m_iRemainTime);	//[악마의 광장] 문이 열리기 %d분전 
; 997  : 				PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 998  : #endif
; 999  : 
; 1000 : 				for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  004c2	c7 85 c0 fd ff
	ff 00 19 00 00	 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  004cc	eb 0f		 jmp	 SHORT $LN13@ProcClose
$LN11@ProcClose:
  004ce	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  004d4	83 c0 01	 add	 eax, 1
  004d7	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN13@ProcClose:
  004dd	81 bd c0 fd ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  004e7	0f 8d 42 01 00
	00		 jge	 $LN12@ProcClose

; 1001 : 				{
; 1002 : 					if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) && (!CHECK_BLOODCASTLE(gObj[n].MapNumber)) 
; 1003 : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 1004 : 						&& (!CHECK_CHAOSCASTLE(gObj[n].MapNumber))

  004ed	69 85 c0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  004f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004fd	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00502	0f 85 22 01 00
	00		 jne	 $LN27@ProcClose
  00508	69 85 c0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00512	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00518	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0051d	83 fa 01	 cmp	 edx, 1
  00520	0f 85 04 01 00
	00		 jne	 $LN27@ProcClose
  00526	69 85 c0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00530	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00536	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0053e	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00541	7d 0c		 jge	 SHORT $LN49@ProcClose
  00543	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv275[ebp], 0
  0054d	eb 3f		 jmp	 SHORT $LN50@ProcClose
$LN49@ProcClose:
  0054f	69 85 c0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00559	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0055f	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00567	83 fa 11	 cmp	 edx, 17			; 00000011H
  0056a	7e 0c		 jle	 SHORT $LN47@ProcClose
  0056c	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv274[ebp], 0
  00576	eb 0a		 jmp	 SHORT $LN48@ProcClose
$LN47@ProcClose:
  00578	c7 85 38 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv274[ebp], 1
$LN48@ProcClose:
  00582	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR tv274[ebp]
  00588	89 85 3c fd ff
	ff		 mov	 DWORD PTR tv275[ebp], eax
$LN50@ProcClose:
  0058e	83 bd 3c fd ff
	ff 00		 cmp	 DWORD PTR tv275[ebp], 0
  00595	0f 85 8f 00 00
	00		 jne	 $LN27@ProcClose
  0059b	69 85 c0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  005a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ab	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  005b3	83 fa 12	 cmp	 edx, 18			; 00000012H
  005b6	7d 0c		 jge	 SHORT $LN53@ProcClose
  005b8	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv288[ebp], 0
  005c2	eb 3f		 jmp	 SHORT $LN54@ProcClose
$LN53@ProcClose:
  005c4	69 85 c0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  005ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005d4	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  005dc	83 fa 17	 cmp	 edx, 23			; 00000017H
  005df	7e 0c		 jle	 SHORT $LN51@ProcClose
  005e1	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv287[ebp], 0
  005eb	eb 0a		 jmp	 SHORT $LN52@ProcClose
$LN51@ProcClose:
  005ed	c7 85 38 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv287[ebp], 1
$LN52@ProcClose:
  005f7	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR tv287[ebp]
  005fd	89 85 3c fd ff
	ff		 mov	 DWORD PTR tv288[ebp], eax
$LN54@ProcClose:
  00603	83 bd 3c fd ff
	ff 00		 cmp	 DWORD PTR tv288[ebp], 0
  0060a	75 1e		 jne	 SHORT $LN27@ProcClose

; 1005 : #endif
; 1006 : 						)
; 1007 : 					{
; 1008 : 						DataSend(n, (LPBYTE)&pNotice, pNotice.h.size);

  0060c	0f b6 85 c5 fd
	ff ff		 movzx	 eax, BYTE PTR _pNotice$2[ebp+1]
  00613	50		 push	 eax
  00614	8d 8d c4 fd ff
	ff		 lea	 ecx, DWORD PTR _pNotice$2[ebp]
  0061a	51		 push	 ecx
  0061b	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _n$1[ebp]
  00621	52		 push	 edx
  00622	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00627	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@ProcClose:

; 1009 : 					}
; 1010 : 				}

  0062a	e9 9f fe ff ff	 jmp	 $LN11@ProcClose
$LN12@ProcClose:

; 1011 : 				LogAddTD(pNotice.Notice);

  0062f	8d 85 d1 fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$2[ebp+13]
  00635	50		 push	 eax
  00636	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0063c	83 c4 04	 add	 esp, 4
$LN25@ProcClose:

; 1012 : #else
; 1013 : 				char msg[255];
; 1014 : 				wsprintf(msg, lMsg.Get(703));	//"[악마의 광장] 문이 열렸습니다"
; 1015 : 				AllSendServerMsg(msg);
; 1016 : 				LogAddTD(msg);
; 1017 : #endif	
; 1018 : 			}
; 1019 : 		}
; 1020 : 		
; 1021 : 		if( m_iRemainTime == 1 && m_iremainTimeSec == -1 )

  0063f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00642	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00646	75 21		 jne	 SHORT $LN28@ProcClose
  00648	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0064b	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  0064f	75 18		 jne	 SHORT $LN28@ProcClose

; 1022 : 		{
; 1023 : 			m_iremainTimeSec = 60;

  00651	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00654	c7 40 10 3c 00
	00 00		 mov	 DWORD PTR [eax+16], 60	; 0000003cH

; 1024 : 			m_iTime = GetTickCount();

  0065b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00661	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00664	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1025 : 		}			

  00667	eb 11		 jmp	 SHORT $LN1@ProcClose
$LN28@ProcClose:

; 1026 : 		else
; 1027 : 		{
; 1028 : 			m_iTime = GetTickCount()+DEVILSQUARE_MIN;

  00669	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0066f	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  00674	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00677	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@ProcClose:

; 1029 : 		}
; 1030 : 	}		
; 1031 : }

  0067a	5f		 pop	 edi
  0067b	5e		 pop	 esi
  0067c	5b		 pop	 ebx
  0067d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00680	33 cd		 xor	 ecx, ebp
  00682	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00687	8b e5		 mov	 esp, ebp
  00689	5d		 pop	 ebp
  0068a	c3		 ret	 0
?ProcClose@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::ProcClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?SetPlaying@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetPlaying@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::SetPlaying, COMDAT
; _this$ = ecx

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 457  : 	gObjScoreClear();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?gObjScoreClear@CDevilSquare@@AAEXXZ ; CDevilSquare::gObjScoreClear

; 458  : 	SetMonster();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?SetMonster@CDevilSquare@@QAEXXZ ; CDevilSquare::SetMonster

; 459  : 
; 460  : 	m_iRemainTime = m_iPlaytime;	

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00025	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 461  : 
; 462  : 	if( m_iPlaytime <= 1 )

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 2c 01	 cmp	 DWORD PTR [eax+44], 1
  0002f	7f 18		 jg	 SHORT $LN2@SetPlaying

; 463  : 	{
; 464  : 		m_iTime = GetTickCount();

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 465  : 		m_iremainTimeSec = 60;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 40 10 3c 00
	00 00		 mov	 DWORD PTR [eax+16], 60	; 0000003cH

; 466  : 	}

  00047	eb 1b		 jmp	 SHORT $LN3@SetPlaying
$LN2@SetPlaying:

; 467  : 	else
; 468  : 	{
; 469  : 		m_iTime = GetTickCount()+DEVILSQUARE_MIN;

  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004f	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 470  : 		m_iremainTimeSec = -1;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1
$LN3@SetPlaying:

; 471  : 	}
; 472  : 
; 473  : 	m_bSendTimeCount = FALSE;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 474  : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?SetPlaying@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::SetPlaying
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?SetOpen@CDevilSquare@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetOpen@CDevilSquare@@AAEXXZ PROC			; CDevilSquare::SetOpen, COMDAT
; _this$ = ecx

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 439  : 	m_iRemainTime = m_iOpenTime;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00015	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 440  : 	
; 441  : 	if( m_iOpenTime <= 1 )

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 78 28 01	 cmp	 DWORD PTR [eax+40], 1
  0001f	7f 18		 jg	 SHORT $LN2@SetOpen

; 442  : 	{
; 443  : 		m_iTime = GetTickCount();

  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 444  : 		m_iremainTimeSec = 60;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 10 3c 00
	00 00		 mov	 DWORD PTR [eax+16], 60	; 0000003cH

; 445  : 	}

  00037	eb 1b		 jmp	 SHORT $LN3@SetOpen
$LN2@SetOpen:

; 446  : 	else
; 447  : 	{
; 448  : 		m_iTime = GetTickCount()+DEVILSQUARE_MIN;

  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0003f	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 449  : 		m_iremainTimeSec = -1;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1
$LN3@SetOpen:

; 450  : 	}
; 451  : 
; 452  : 	m_bSendTimeCount = FALSE;

  00054	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00057	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 453  : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?SetOpen@CDevilSquare@@AAEXXZ ENDP			; CDevilSquare::SetOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?SetClose@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?SetClose@CDevilSquare@@QAEXXZ PROC			; CDevilSquare::SetClose, COMDAT
; _this$ = ecx

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 400  : 	if( LogAdd )

  0000c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?LogAdd@@3P6AXPADZZA, 0 ; LogAdd
  00013	74 0e		 je	 SHORT $LN5@SetClose

; 401  : 	{
; 402  : 		LogAddTD("[DevilSquare] Close");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JMFNFMMP@?$FLDevilSquare?$FN?5Close@
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00020	83 c4 04	 add	 esp, 4
$LN5@SetClose:

; 403  : 	}
; 404  : 
; 405  : 	// 몬스터 정리
; 406  : 	ClearMonstr();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?ClearMonstr@CDevilSquare@@QAEXXZ ; CDevilSquare::ClearMonstr

; 407  : 	// 등수 계산 (등수 계산 하면서, 보너스 경험치 젠 정보를 같이 전송해준다)
; 408  : 	CalcScore();	

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?CalcScore@CDevilSquare@@QAEXXZ ; CDevilSquare::CalcScore

; 409  : 
; 410  : 	for( int i = 0; i < MAX_DEVILSQUARE; i++ )

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0003a	eb 09		 jmp	 SHORT $LN4@SetClose
$LN2@SetClose:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003f	83 c0 01	 add	 eax, 1
  00042	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SetClose:
  00045	83 7d f8 04	 cmp	 DWORD PTR _i$1[ebp], 4
  00049	7d 15		 jge	 SHORT $LN3@SetClose

; 411  : 	{
; 412  : 		m_DevilSquareGround[i].Clear();

  0004b	69 45 f8 e0 03
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 992
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8d 4c 01 30	 lea	 ecx, DWORD PTR [ecx+eax+48]
  00059	e8 00 00 00 00	 call	 ?Clear@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::Clear

; 413  : 	}

  0005e	eb dc		 jmp	 SHORT $LN2@SetClose
$LN3@SetClose:

; 414  : 
; 415  : 	m_iRemainTime = m_iCloseTime;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00069	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 416  : 
; 417  : #if TESTSERVER == 0
; 418  : 	CheckSync();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?CheckSync@CDevilSquare@@AAEXXZ ; CDevilSquare::CheckSync

; 419  : #endif
; 420  : 
; 421  : 
; 422  : 	m_bFlag = FALSE;

  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00077	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 423  : 
; 424  : 	if( m_iRemainTime <= 1 )

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00085	7f 18		 jg	 SHORT $LN6@SetClose

; 425  : 	{
; 426  : 		m_iTime = GetTickCount();

  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 427  : 		m_iremainTimeSec = 60;

  00093	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00096	c7 40 10 3c 00
	00 00		 mov	 DWORD PTR [eax+16], 60	; 0000003cH

; 428  : 	}

  0009d	eb 1b		 jmp	 SHORT $LN7@SetClose
$LN6@SetClose:

; 429  : 	else
; 430  : 	{
; 431  : 		m_iTime = GetTickCount()+DEVILSQUARE_MIN;

  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000a5	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 432  : 		m_iremainTimeSec = -1;

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1
$LN7@SetClose:

; 433  : 	}
; 434  : 	m_bSendTimeCount = FALSE;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 435  : }

  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
?SetClose@CDevilSquare@@QAEXXZ ENDP			; CDevilSquare::SetClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?CalcScore@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_n$2 = -12						; size = 4
_n$3 = -8						; size = 4
_this$ = -4						; size = 4
?CalcScore@CDevilSquare@@QAEXXZ PROC			; CDevilSquare::CalcScore, COMDAT
; _this$ = ecx

; 2249 : {	// 랭킹을 구하고, 각각의 클라이언트에게 전송해준다

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2250 : 	for( int n = 0 ;n < MAX_DEVILSQUARE; n++ )

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$3[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@CalcScore
$LN2@CalcScore:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _n$3[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _n$3[ebp], eax
$LN4@CalcScore:
  0001e	83 7d f8 04	 cmp	 DWORD PTR _n$3[ebp], 4
  00022	7d 15		 jge	 SHORT $LN3@CalcScore

; 2251 : 	{	// 점수 초기화 
; 2252 : 		m_DevilSquareGround[n].ClearScore();

  00024	69 45 f8 e0 03
	00 00		 imul	 eax, DWORD PTR _n$3[ebp], 992
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8d 4c 01 30	 lea	 ecx, DWORD PTR [ecx+eax+48]
  00032	e8 00 00 00 00	 call	 ?ClearScore@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::ClearScore

; 2253 : 	}

  00037	eb dc		 jmp	 SHORT $LN2@CalcScore
$LN3@CalcScore:

; 2254 : 
; 2255 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00039	c7 45 f4 00 19
	00 00		 mov	 DWORD PTR _n$2[ebp], 6400 ; 00001900H
  00040	eb 09		 jmp	 SHORT $LN7@CalcScore
$LN5@CalcScore:
  00042	8b 45 f4	 mov	 eax, DWORD PTR _n$2[ebp]
  00045	83 c0 01	 add	 eax, 1
  00048	89 45 f4	 mov	 DWORD PTR _n$2[ebp], eax
$LN7@CalcScore:
  0004b	81 7d f4 e8 1c
	00 00		 cmp	 DWORD PTR _n$2[ebp], 7400 ; 00001ce8H
  00052	7d 7f		 jge	 SHORT $LN6@CalcScore

; 2256 : 	{	// 각각의 광장에 객체를 넣어주고,
; 2257 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 2258 : 		if( gObj[n].Connected == 3 && CHECK_DEVILSQUARE(gObj[n].MapNumber)  && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )
; 2259 : #else
; 2260 : 		if( gObj[n].Connected == 3 && gObj[n].MapNumber == 9  && gObj[n].m_stateEngagePVP != PVP_USER_PLAYING )

  00054	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00061	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00066	75 66		 jne	 SHORT $LN11@CalcScore
  00068	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00075	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0007d	83 fa 09	 cmp	 edx, 9
  00080	75 4c		 jne	 SHORT $LN11@CalcScore
  00082	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008f	83 bc 01 80 1a
	00 00 02	 cmp	 DWORD PTR [ecx+eax+6784], 2
  00097	74 35		 je	 SHORT $LN11@CalcScore

; 2261 : #endif
; 2262 : 		{	
; 2263 : #ifdef DEVILSQUARE_EXTEND_20050221
; 2264 : 			if (CHECK_DEVILSQUARE_INDEX(gObj[n].m_bDevilSquareIndex))
; 2265 : #endif
; 2266 : 			m_DevilSquareGround[gObj[n].m_bDevilSquareIndex].InsertObj(&gObj[n]);

  00099	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  000a0	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a6	50		 push	 eax
  000a7	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$2[ebp], 7072
  000ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b4	0f b6 84 0a d0
	0c 00 00	 movzx	 eax, BYTE PTR [edx+ecx+3280]
  000bc	69 c8 e0 03 00
	00		 imul	 ecx, eax, 992
  000c2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c5	8d 4c 0a 30	 lea	 ecx, DWORD PTR [edx+ecx+48]
  000c9	e8 00 00 00 00	 call	 ?InsertObj@CDevilSquareGround@@QAEXPAVOBJECTSTRUCT@@@Z ; CDevilSquareGround::InsertObj
$LN11@CalcScore:

; 2267 : 		}
; 2268 : 	}

  000ce	e9 6f ff ff ff	 jmp	 $LN5@CalcScore
$LN6@CalcScore:

; 2269 : 
; 2270 : 	for( int n = 0 ;n < MAX_DEVILSQUARE; n++ )

  000d3	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  000da	eb 09		 jmp	 SHORT $LN10@CalcScore
$LN8@CalcScore:
  000dc	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  000df	83 c0 01	 add	 eax, 1
  000e2	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN10@CalcScore:
  000e5	83 7d f0 04	 cmp	 DWORD PTR _n$1[ebp], 4
  000e9	7d 28		 jge	 SHORT $LN1@CalcScore

; 2271 : 	{	// 점수별로 정렬한후  
; 2272 : 		m_DevilSquareGround[n].SortScore();

  000eb	69 45 f0 e0 03
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 992
  000f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	8d 4c 01 30	 lea	 ecx, DWORD PTR [ecx+eax+48]
  000f9	e8 00 00 00 00	 call	 ?SortScore@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::SortScore

; 2273 : 		// 각각에게 스코어를 보낸다
; 2274 : 		m_DevilSquareGround[n].SendScore();

  000fe	69 45 f0 e0 03
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 992
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	8d 4c 01 30	 lea	 ecx, DWORD PTR [ecx+eax+48]
  0010c	e8 00 00 00 00	 call	 ?SendScore@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::SendScore

; 2275 : 	}

  00111	eb c9		 jmp	 SHORT $LN8@CalcScore
$LN1@CalcScore:

; 2276 : }

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
?CalcScore@CDevilSquare@@QAEXXZ ENDP			; CDevilSquare::CalcScore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?Load@CDevilSquare@@QAEXPAD@Z
_TEXT	SEGMENT
_exp$1 = -64						; size = 4
_zen$2 = -60						; size = 4
_rank$3 = -56						; size = 4
_index$4 = -52						; size = 4
_ty$ = -48						; size = 4
_tx$ = -44						; size = 4
_y$ = -40						; size = 4
_x$ = -36						; size = 4
_endtime$ = -32						; size = 4
_starttime$ = -28					; size = 4
_monstertype$ = -24					; size = 4
_type$ = -20						; size = 4
_number$ = -16						; size = 4
_Token$ = -12						; size = 4
_i$5 = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Load@CDevilSquare@@QAEXPAD@Z PROC			; CDevilSquare::Load, COMDAT
; _this$ = ecx

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 232  : 	for( int i = 0; i < MAX_DEVILSQUARE; i++ )

  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  00016	eb 09		 jmp	 SHORT $LN4@Load
$LN2@Load:
  00018	8b 45 f8	 mov	 eax, DWORD PTR _i$5[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 45 f8	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@Load:
  00021	83 7d f8 04	 cmp	 DWORD PTR _i$5[ebp], 4
  00025	7d 19		 jge	 SHORT $LN3@Load

; 233  : 	{
; 234  : 		m_DevilSquareGround[i].Init(i);

  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$5[ebp]
  0002a	50		 push	 eax
  0002b	69 4d f8 e0 03
	00 00		 imul	 ecx, DWORD PTR _i$5[ebp], 992
  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8d 4c 0a 30	 lea	 ecx, DWORD PTR [edx+ecx+48]
  00039	e8 00 00 00 00	 call	 ?Init@CDevilSquareGround@@QAEXH@Z ; CDevilSquareGround::Init

; 235  : 	}

  0003e	eb d8		 jmp	 SHORT $LN2@Load
$LN3@Load:

; 236  : 
; 237  : 	if((SMDFile=fopen(filename,"r")) == NULL)	

  00040	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00045	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _fopen
  0004e	83 c4 08	 add	 esp, 8
  00051	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  00056	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  0005d	75 16		 jne	 SHORT $LN9@Load

; 238  : 	{
; 239  : 		MsgBox("[DevilSquare] Info file Load Fail [%s]", filename);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BBCAEKDP@?$FLDevilSquare?$FN?5Info?5file?5Load?5Fa@
  00068	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0006d	83 c4 08	 add	 esp, 8

; 240  : 		return ;

  00070	e9 c8 02 00 00	 jmp	 $LN1@Load
$LN9@Load:

; 241  : 	}
; 242  : 	SMDToken Token;
; 243  : 	
; 244  : 	int  number, type;
; 245  : 	int	 monstertype;
; 246  : 	int	 starttime;
; 247  : 	int  endtime;
; 248  : 
; 249  : 	int  x, y, tx, ty;	
; 250  : 	
; 251  : 	while( true )

  00075	b8 01 00 00 00	 mov	 eax, 1
  0007a	85 c0		 test	 eax, eax
  0007c	0f 84 9b 02 00
	00		 je	 $LN6@Load

; 252  : 	{
; 253  : 		Token = (*GetToken)();

  00082	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00087	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 254  : 		if(Token == END) break;

  0008a	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  0008e	75 05		 jne	 SHORT $LN10@Load
  00090	e9 88 02 00 00	 jmp	 $LN6@Load
$LN10@Load:

; 255  : 		type = (int)TokenNumber;

  00095	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0009d	89 45 ec	 mov	 DWORD PTR _type$[ebp], eax
$LN7@Load:

; 256  : 		while(1)

  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	85 c0		 test	 eax, eax
  000a7	0f 84 6b 02 00
	00		 je	 $LN8@Load

; 257  : 		{				
; 258  : 			if( type == 0 )

  000ad	83 7d ec 00	 cmp	 DWORD PTR _type$[ebp], 0
  000b1	75 62		 jne	 SHORT $LN11@Load

; 259  : 			{	// 악마의 광장 게임시간 설정
; 260  : 				Token = (*GetToken)();

  000b3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000b8	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 261  : 				if(strcmp("end",TokenString)==NULL) break;

  000bb	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  000c5	e8 00 00 00 00	 call	 _strcmp
  000ca	83 c4 08	 add	 esp, 8
  000cd	85 c0		 test	 eax, eax
  000cf	75 05		 jne	 SHORT $LN13@Load
  000d1	e9 42 02 00 00	 jmp	 $LN8@Load
$LN13@Load:

; 262  : 
; 263  : 				m_iCloseTime = (int)TokenNumber;

  000d6	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 264  : 				Token = (*GetToken)(); m_iOpenTime = (int)TokenNumber;

  000e4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000e9	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  000ec	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 265  : 				Token = (*GetToken)(); m_iPlaytime = (int)TokenNumber;

  000fa	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000ff	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00102	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0010a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 266  : 			}

  00110	e9 fe 01 00 00	 jmp	 $LN20@Load
$LN11@Load:

; 267  : 			else if( type == 1 )

  00115	83 7d ec 01	 cmp	 DWORD PTR _type$[ebp], 1
  00119	0f 85 8c 00 00
	00		 jne	 $LN14@Load

; 268  : 			{	// 기본 몬스터 리젠 설정				
; 269  : 				Token = (*GetToken)();

  0011f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00124	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 270  : 				if(strcmp("end",TokenString)==NULL) break;

  00127	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00131	e8 00 00 00 00	 call	 _strcmp
  00136	83 c4 08	 add	 esp, 8
  00139	85 c0		 test	 eax, eax
  0013b	75 05		 jne	 SHORT $LN16@Load
  0013d	e9 d6 01 00 00	 jmp	 $LN8@Load
$LN16@Load:

; 271  : 
; 272  : 				number = (int)TokenNumber;			

  00142	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0014a	89 45 f0	 mov	 DWORD PTR _number$[ebp], eax

; 273  : 				Token = (*GetToken)(); monstertype		= (int)TokenNumber;

  0014d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00152	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00155	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0015d	89 45 e8	 mov	 DWORD PTR _monstertype$[ebp], eax

; 274  : 				Token = (*GetToken)(); starttime		= (int)TokenNumber;			

  00160	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00165	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00168	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00170	89 45 e4	 mov	 DWORD PTR _starttime$[ebp], eax

; 275  : 				Token = (*GetToken)(); endtime			= (int)TokenNumber;

  00173	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00178	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0017b	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00183	89 45 e0	 mov	 DWORD PTR _endtime$[ebp], eax

; 276  : 				
; 277  : 				m_DevilSquareGround[number].Set(monstertype, starttime, endtime);		// 저주받은왕

  00186	8b 45 e0	 mov	 eax, DWORD PTR _endtime$[ebp]
  00189	50		 push	 eax
  0018a	8b 4d e4	 mov	 ecx, DWORD PTR _starttime$[ebp]
  0018d	51		 push	 ecx
  0018e	0f b7 55 e8	 movzx	 edx, WORD PTR _monstertype$[ebp]
  00192	52		 push	 edx
  00193	69 45 f0 e0 03
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 992
  0019a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	8d 4c 01 30	 lea	 ecx, DWORD PTR [ecx+eax+48]
  001a1	e8 00 00 00 00	 call	 ?Set@CDevilSquareGround@@QAEXGHH@Z ; CDevilSquareGround::Set

; 278  : 			}				

  001a6	e9 68 01 00 00	 jmp	 $LN20@Load
$LN14@Load:

; 279  : 			else if( type == 2 )

  001ab	83 7d ec 02	 cmp	 DWORD PTR _type$[ebp], 2
  001af	0f 85 d1 00 00
	00		 jne	 $LN17@Load

; 280  : 			{
; 281  : 				Token = (*GetToken)();

  001b5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001ba	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 282  : 				if(strcmp("end",TokenString)==NULL) break;

  001bd	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  001c7	e8 00 00 00 00	 call	 _strcmp
  001cc	83 c4 08	 add	 esp, 8
  001cf	85 c0		 test	 eax, eax
  001d1	75 05		 jne	 SHORT $LN19@Load
  001d3	e9 40 01 00 00	 jmp	 $LN8@Load
$LN19@Load:

; 283  : 
; 284  : 				number = (int)TokenNumber;			

  001d8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001e0	89 45 f0	 mov	 DWORD PTR _number$[ebp], eax

; 285  : 				Token = (*GetToken)(); monstertype		= (int)TokenNumber;

  001e3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001e8	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  001eb	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001f3	89 45 e8	 mov	 DWORD PTR _monstertype$[ebp], eax

; 286  : 				Token = (*GetToken)(); starttime		= (int)TokenNumber;

  001f6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001fb	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  001fe	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00206	89 45 e4	 mov	 DWORD PTR _starttime$[ebp], eax

; 287  : 				
; 288  : 				Token = (*GetToken)(); x		= (int)TokenNumber;

  00209	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0020e	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00211	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00219	89 45 dc	 mov	 DWORD PTR _x$[ebp], eax

; 289  : 				Token = (*GetToken)(); y		= (int)TokenNumber;

  0021c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00221	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00224	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0022c	89 45 d8	 mov	 DWORD PTR _y$[ebp], eax

; 290  : 				Token = (*GetToken)(); tx		= (int)TokenNumber;

  0022f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00234	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00237	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0023f	89 45 d4	 mov	 DWORD PTR _tx$[ebp], eax

; 291  : 				Token = (*GetToken)(); ty		= (int)TokenNumber;

  00242	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00247	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0024a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00252	89 45 d0	 mov	 DWORD PTR _ty$[ebp], eax

; 292  : 
; 293  : 				m_DevilSquareGround[number].SetBoss(monstertype, starttime, x, y, tx, ty);

  00255	8b 45 d0	 mov	 eax, DWORD PTR _ty$[ebp]
  00258	50		 push	 eax
  00259	8b 4d d4	 mov	 ecx, DWORD PTR _tx$[ebp]
  0025c	51		 push	 ecx
  0025d	8b 55 d8	 mov	 edx, DWORD PTR _y$[ebp]
  00260	52		 push	 edx
  00261	8b 45 dc	 mov	 eax, DWORD PTR _x$[ebp]
  00264	50		 push	 eax
  00265	8b 4d e4	 mov	 ecx, DWORD PTR _starttime$[ebp]
  00268	51		 push	 ecx
  00269	0f b7 55 e8	 movzx	 edx, WORD PTR _monstertype$[ebp]
  0026d	52		 push	 edx
  0026e	69 45 f0 e0 03
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 992
  00275	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00278	8d 4c 01 30	 lea	 ecx, DWORD PTR [ecx+eax+48]
  0027c	e8 00 00 00 00	 call	 ?SetBoss@CDevilSquareGround@@QAEXGHHHHH@Z ; CDevilSquareGround::SetBoss

; 294  : 			}

  00281	e9 8d 00 00 00	 jmp	 $LN20@Load
$LN17@Load:

; 295  : 			else if( type == 3 )

  00286	83 7d ec 03	 cmp	 DWORD PTR _type$[ebp], 3
  0028a	0f 85 83 00 00
	00		 jne	 $LN20@Load

; 296  : 			{
; 297  : 				int index, rank, zen, exp;
; 298  : 
; 299  : 				Token = (*GetToken)();

  00290	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00295	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 300  : 				if(strcmp("end",TokenString)==NULL) break;

  00298	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  002a2	e8 00 00 00 00	 call	 _strcmp
  002a7	83 c4 08	 add	 esp, 8
  002aa	85 c0		 test	 eax, eax
  002ac	75 02		 jne	 SHORT $LN21@Load
  002ae	eb 68		 jmp	 SHORT $LN8@Load
$LN21@Load:

; 301  : 
; 302  : 				index = (int)TokenNumber;			

  002b0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002b8	89 45 cc	 mov	 DWORD PTR _index$4[ebp], eax

; 303  : 				Token = (*GetToken)(); rank		= (int)TokenNumber;

  002bb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002c0	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  002c3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002cb	89 45 c8	 mov	 DWORD PTR _rank$3[ebp], eax

; 304  : 				Token = (*GetToken)(); exp		= (int)TokenNumber;

  002ce	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002d3	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  002d6	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002de	89 45 c0	 mov	 DWORD PTR _exp$1[ebp], eax

; 305  : 				Token = (*GetToken)(); zen		= (int)TokenNumber;

  002e1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002e6	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  002e9	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002f1	89 45 c4	 mov	 DWORD PTR _zen$2[ebp], eax

; 306  : 				m_DevilSquareGround[index].SetBonus(rank, exp, zen);

  002f4	8b 45 c4	 mov	 eax, DWORD PTR _zen$2[ebp]
  002f7	50		 push	 eax
  002f8	8b 4d c0	 mov	 ecx, DWORD PTR _exp$1[ebp]
  002fb	51		 push	 ecx
  002fc	8b 55 c8	 mov	 edx, DWORD PTR _rank$3[ebp]
  002ff	52		 push	 edx
  00300	69 45 cc e0 03
	00 00		 imul	 eax, DWORD PTR _index$4[ebp], 992
  00307	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0030a	8d 4c 01 30	 lea	 ecx, DWORD PTR [ecx+eax+48]
  0030e	e8 00 00 00 00	 call	 ?SetBonus@CDevilSquareGround@@QAEXHHH@Z ; CDevilSquareGround::SetBonus
$LN20@Load:

; 307  : 			}
; 308  : #ifdef UPDATE_DEVIL_SQUARE_START_TIME_20070511	// 파일 로드시 시작 시간 읽음
; 309  : 			else if( type == 4)
; 310  : 			{
; 311  : 				Token = (*GetToken)();
; 312  : 				if(strcmp("end",TokenString)==NULL) break;
; 313  : 			
; 314  : 				DEVIL_SQARE_STARTTIME startTime;
; 315  : 		
; 316  : 				startTime.nHour = (int)TokenNumber;
; 317  : 				Token = (*GetToken)(); startTime.nMin = (int)TokenNumber;
; 318  : 
; 319  : 				m_lstStartTime.push_back(startTime);			
; 320  : 			}
; 321  : #endif //UPDATE_DEVIL_SQUARE_START_TIME_20070511
; 322  : #ifdef UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 323  : 			else if( type == 5 )
; 324  : 			{	// 악마의 광장 보상 경험치 비율
; 325  : 				Token = (*GetToken)();
; 326  : 				if( strcmp("end", TokenString) == NULL )
; 327  : 				{
; 328  : 					// 읽어온 비율을 적용 시킨다.
; 329  : 					for( INT i=0; i<MAX_DEVILSQUARE; ++i )
; 330  : 						m_DevilSquareGround[i].ApplyBonusRate( m_fRewardExpRate[i] );
; 331  : 					break;
; 332  : 				}
; 333  : 
; 334  : 				INT iDSquare = (int)TokenNumber;				
; 335  : 				if( CHECK_LIMIT(iDSquare, MAX_DEVILSQUARE) ) {
; 336  : 					Token = (*GetToken)();
; 337  : 					m_fRewardExpRate[iDSquare] = (FLOAT)TokenNumber;						
; 338  : 				}
; 339  : 				else Token = (*GetToken)();				
; 340  : 			}
; 341  : #endif //UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 342  : 		}

  00313	e9 88 fd ff ff	 jmp	 $LN7@Load
$LN8@Load:

; 343  : 	}

  00318	e9 58 fd ff ff	 jmp	 $LN9@Load
$LN6@Load:

; 344  : 	fclose(SMDFile);

  0031d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00322	50		 push	 eax
  00323	e8 00 00 00 00	 call	 _fclose
  00328	83 c4 04	 add	 esp, 4

; 345  : 
; 346  : 	LogAdd("%s file load!", filename);

  0032b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0032e	50		 push	 eax
  0032f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@
  00334	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0033a	83 c4 08	 add	 esp, 8
$LN1@Load:

; 347  : 
; 348  : // grooving 사내 테스트 악마의 광장 시간 조정
; 349  : #if TESTSERVER == 1 && defined(UPDATE_DEVIL_SQUARE_START_TIME_20070511)
; 350  : 
; 351  : 	m_iCloseTime = 2;
; 352  : 	m_iOpenTime = 1;
; 353  : 	m_iPlaytime = 5;
; 354  : 
; 355  : 	DEVIL_SQARE_STARTTIME startTime;
; 356  : 
; 357  : 	m_lstStartTime.clear();
; 358  : 
; 359  : 	for( int i = 0; i < 24; i++)
; 360  : 	{
; 361  : 		startTime.nHour = i;
; 362  : 		
; 363  : 		for( int j = 0; j < 60; j+= 6 )
; 364  : 		{
; 365  : 			startTime.nMin = j;
; 366  : 			
; 367  : 			m_lstStartTime.push_back(startTime);
; 368  : 		}
; 369  : 	}			
; 370  : #endif//TESTSERVER
; 371  : }

  0033d	5f		 pop	 edi
  0033e	5e		 pop	 esi
  0033f	5b		 pop	 ebx
  00340	8b e5		 mov	 esp, ebp
  00342	5d		 pop	 ebp
  00343	c2 04 00	 ret	 4
?Load@CDevilSquare@@QAEXPAD@Z ENDP			; CDevilSquare::Load
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
_score$1 = -20						; size = 4
_LastHitObjNum$ = -16					; size = 4
_HitIndex$ = -12					; size = 4
_lpTargetObj$ = -8					; size = 4
_this$ = -4						; size = 4
_lpMonObj$ = 8						; size = 4
_lpObj$ = 12						; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z PROC ; CDevilSquare::gObjMonsterScoreDivision, COMDAT
; _this$ = ecx

; 2220 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2221 : 	LPOBJECTSTRUCT lpTargetObj;	
; 2222 : 	gObjMonsterHitDamageUserDel(lpMonObj);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpMonObj$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageUserDel@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageUserDel
  00015	83 c4 04	 add	 esp, 4

; 2223 : 
; 2224 : 	lpMonObj->Money = 0;

  00018	8b 45 08	 mov	 eax, DWORD PTR _lpMonObj$[ebp]
  0001b	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0

; 2225 : 
; 2226 : 	int HitIndex;
; 2227 : 	int LastHitObjNum = gObjMonsterLastHitDamageUser(lpMonObj, HitIndex);

  00025	8d 45 f4	 lea	 eax, DWORD PTR _HitIndex$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?gObjMonsterLastHitDamageUser@@YAHPAVOBJECTSTRUCT@@AAH@Z ; gObjMonsterLastHitDamageUser
  00032	83 c4 08	 add	 esp, 8
  00035	89 45 f0	 mov	 DWORD PTR _LastHitObjNum$[ebp], eax

; 2228 : 
; 2229 : 	if( LastHitObjNum != -1 )

  00038	83 7d f0 ff	 cmp	 DWORD PTR _LastHitObjNum$[ebp], -1
  0003c	74 6d		 je	 SHORT $LN2@gObjMonste

; 2230 : 	{
; 2231 : 		lpTargetObj = &gObj[LastHitObjNum];

  0003e	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _LastHitObjNum$[ebp], 7072
  00045	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004b	89 45 f8	 mov	 DWORD PTR _lpTargetObj$[ebp], eax

; 2232 : 		int score = (int)(float)((lpMonObj->sHD[HitIndex].HitDamage/lpMonObj->MaxLife)*lpMonObj->Level);

  0004e	6b 45 f4 0c	 imul	 eax, DWORD PTR _HitIndex$[ebp], 12
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  00055	f3 0f 2a 84 01
	78 0a 00 00	 cvtsi2ss xmm0, DWORD PTR [ecx+eax+2680]
  0005e	8b 55 08	 mov	 edx, DWORD PTR _lpMonObj$[ebp]
  00061	f3 0f 5e 82 c0
	00 00 00	 divss	 xmm0, DWORD PTR [edx+192]
  00069	8b 45 08	 mov	 eax, DWORD PTR _lpMonObj$[ebp]
  0006c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00073	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00077	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0007b	f3 0f 2c d0	 cvttss2si edx, xmm0
  0007f	89 55 ec	 mov	 DWORD PTR _score$1[ebp], edx

; 2233 : 		score *= (lpTargetObj->m_bDevilSquareIndex+1);

  00082	8b 45 f8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00085	0f b6 88 d0 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3280]
  0008c	83 c1 01	 add	 ecx, 1
  0008f	0f af 4d ec	 imul	 ecx, DWORD PTR _score$1[ebp]
  00093	89 4d ec	 mov	 DWORD PTR _score$1[ebp], ecx

; 2234 : 		lpTargetObj->m_nEventScore += score;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00099	8b 88 c4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3268]
  0009f	03 4d ec	 add	 ecx, DWORD PTR _score$1[ebp]
  000a2	8b 55 f8	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000a5	89 8a c4 0c 00
	00		 mov	 DWORD PTR [edx+3268], ecx
$LN2@gObjMonste:

; 2235 : 	}
; 2236 : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 10 00	 ret	 16			; 00000010H
?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z ENDP ; CDevilSquare::gObjMonsterScoreDivision
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
tv89 = -172						; size = 4
tv90 = -168						; size = 4
_mymaxexp$1 = -100					; size = 4
_toplevel$ = -96					; size = 4
_lpPartyObj$ = -92					; size = 4
_bCheckSetParty$ = -88					; size = 5
_bApplaySetParty$ = -80					; size = 4
_viewpercent$ = -76					; size = 4
_viewplayer$ = -72					; size = 4
_dis$ = -68						; size = 20
_partycount$ = -48					; size = 4
_partylevel$ = -44					; size = 4
_totallevel$ = -40					; size = 4
_partynum$ = -36					; size = 4
_number$ = -32						; size = 4
_level$ = -28						; size = 4
_totalexp$ = -24					; size = 4
_maxexp$ = -20						; size = 4
_exp$ = -16						; size = 4
_n$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
?gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z PROC ; CDevilSquare::gObjExpParty, COMDAT
; _this$ = ecx

; 1655 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1656 : 	int n;
; 1657 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912
; 1658 : 	INT64 exp, maxexp=0, totalexp;
; 1659 : #else
; 1660 : 	int exp, maxexp=0, totalexp;

  00019	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _maxexp$[ebp], 0

; 1661 : #endif
; 1662 : 
; 1663 : #ifdef MODIFY_GETTING_EXP_RATE_20060214
; 1664 : 	int level = ((lpTargetObj->Level+25)*lpTargetObj->Level)/3;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00023	0f bf 80 a0 00
	00 00		 movsx	 eax, WORD PTR [eax+160]
  0002a	83 c0 19	 add	 eax, 25			; 00000019H
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00030	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  00037	0f af c2	 imul	 eax, edx
  0003a	99		 cdq
  0003b	b9 03 00 00 00	 mov	 ecx, 3
  00040	f7 f9		 idiv	 ecx
  00042	89 45 e4	 mov	 DWORD PTR _level$[ebp], eax

; 1665 : #else
; 1666 : #ifdef MODIFY_GETTING_EXP_RATE_20051116
; 1667 : 	int level = ((lpTargetObj->Level+20)*lpTargetObj->Level)/4;
; 1668 : #else
; 1669 : 	int level = ((lpTargetObj->Level+10)*lpTargetObj->Level)/4;
; 1670 : #endif
; 1671 : #endif // MODIFY_GETTING_EXP_RATE_20060214
; 1672 : 
; 1673 : 	int number;
; 1674 : 	int partynum=0;

  00045	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _partynum$[ebp], 0

; 1675 : 	int totallevel=0;

  0004c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _totallevel$[ebp], 0

; 1676 : 	int partylevel;
; 1677 : 	int partycount;
; 1678 : 	int dis[MAX_PARTYUSER];
; 1679 : 	int viewplayer=0;

  00053	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _viewplayer$[ebp], 0

; 1680 : 	int viewpercent=100;

  0005a	c7 45 b4 64 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 100 ; 00000064H

; 1681 : 
; 1682 : 	int bApplaySetParty = FALSE;	// 셋트파티 경험치를 적용하는가?

  00061	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _bApplaySetParty$[ebp], 0

; 1683 : 
; 1684 : #ifdef UPDATE_ADD_NEW_PARTY_SET_EXP_20080325
; 1685 : 	BYTE bCheckSetParty[6];
; 1686 : #else
; 1687 : 	#ifdef DARKLORD_WORK
; 1688 : 		BYTE bCheckSetParty[5];
; 1689 : 	#else
; 1690 : 		BYTE bCheckSetParty[4];
; 1691 : 	#endif //DARKLORD_WORK
; 1692 : #endif //UPDATE_ADD_NEW_PARTY_SET_20080325	
; 1693 : 	
; 1694 : 	LPOBJECTSTRUCT lpPartyObj;
; 1695 : 
; 1696 : 	partynum = lpObj->PartyNumber;

  00068	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006b	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  00071	89 4d dc	 mov	 DWORD PTR _partynum$[ebp], ecx

; 1697 : 
; 1698 : #ifdef MODIFY_PARTY_PLAY_EXPERIENCE_20070208
; 1699 : 
; 1700 : 	// 가장 높은 레벨의 파티원의 레벨
; 1701 : 	int toplevel = 0;
; 1702 : 	int iTmpDis;
; 1703 : 	// 최대 레벨의 파티원 구하기
; 1704 : 	for( n=0; n<MAX_PARTYUSER; n++)
; 1705 : 	{
; 1706 : 		number = gParty.m_PartyS[partynum].Number[n];
; 1707 : 		if( number >= 0 )
; 1708 : 		{
; 1709 : 			lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];
; 1710 : 
; 1711 : #ifdef MODIFY_PARTY_PLAY_EXPERIENCE_2_20070320
; 1712 : 			iTmpDis = gObjCalDistance(lpTargetObj, lpPartyObj);
; 1713 : #else
; 1714 : 			iTmpDis = gObjCalDistance(lpTargetObj, &lpPartyObj[number]);
; 1715 : #endif
; 1716 : 
; 1717 : #ifdef MODIFY_MASTER_LEVEL_DEVIL_SQUARE_PARTY_EXP_BUGFIX_20080625	// 종합레벨 적용
; 1718 : 			if( iTmpDis < 10 && ( lpPartyObj->Level + lpPartyObj->m_nMasterLevel ) > toplevel )
; 1719 : 			{
; 1720 : 				toplevel = lpPartyObj->Level + lpPartyObj->m_nMasterLevel;
; 1721 : 			}
; 1722 : #else
; 1723 : 			if( iTmpDis < 10 && lpPartyObj->Level > toplevel )
; 1724 : 			{
; 1725 : 				toplevel = lpPartyObj->Level;
; 1726 : 			}
; 1727 : #endif // MODIFY_MASTER_LEVEL_DEVIL_SQUARE_PARTY_EXP_BUGFIX_20080625
; 1728 : 		}
; 1729 : 	}
; 1730 : 
; 1731 : #else	// MODIFY_PARTY_PLAY_EXPERIENCE_20070208
; 1732 : 	
; 1733 : #ifdef UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 1734 : 	// 가장 높은 레벨의 파티원의 레벨
; 1735 : 	int toplevel = 0;

  00074	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _toplevel$[ebp], 0

; 1736 : 	// 최대 레벨의 파티원 구하기
; 1737 : 	for( n=0; n<MAX_PARTYUSER; n++)

  0007b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00082	eb 09		 jmp	 SHORT $LN4@gObjExpPar
$LN2@gObjExpPar:
  00084	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00087	83 c0 01	 add	 eax, 1
  0008a	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjExpPar:
  0008d	83 7d f4 05	 cmp	 DWORD PTR _n$[ebp], 5
  00091	7d 45		 jge	 SHORT $LN3@gObjExpPar

; 1738 : 	{
; 1739 : 		number = gParty.m_PartyS[partynum].Number[n];

  00093	6b 45 dc 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  00097	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  0009a	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  000a1	89 55 e0	 mov	 DWORD PTR _number$[ebp], edx

; 1740 : 		if( number >= 0 )

  000a4	83 7d e0 00	 cmp	 DWORD PTR _number$[ebp], 0
  000a8	7c 2c		 jl	 SHORT $LN12@gObjExpPar

; 1741 : 		{
; 1742 : 			lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];

  000aa	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000b1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b7	89 45 a4	 mov	 DWORD PTR _lpPartyObj$[ebp], eax

; 1743 : 
; 1744 : 			if( lpPartyObj->Level > toplevel )

  000ba	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  000bd	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000c4	3b 4d a0	 cmp	 ecx, DWORD PTR _toplevel$[ebp]
  000c7	7e 0d		 jle	 SHORT $LN12@gObjExpPar

; 1745 : 			{
; 1746 : 				toplevel = lpPartyObj->Level;

  000c9	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  000cc	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000d3	89 4d a0	 mov	 DWORD PTR _toplevel$[ebp], ecx
$LN12@gObjExpPar:

; 1747 : 			}
; 1748 : 		}
; 1749 : 	}

  000d6	eb ac		 jmp	 SHORT $LN2@gObjExpPar
$LN3@gObjExpPar:

; 1750 : #endif	// UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 1751 : 
; 1752 : #endif	// MODIFY_PARTY_PLAY_EXPERIENCE_20070208
; 1753 : 	
; 1754 : 	if( !CHECK_LIMIT(partynum, MAX_PARTY) )

  000d8	83 7d dc 00	 cmp	 DWORD PTR _partynum$[ebp], 0
  000dc	7d 0c		 jge	 SHORT $LN63@gObjExpPar
  000de	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
  000e8	eb 2b		 jmp	 SHORT $LN64@gObjExpPar
$LN63@gObjExpPar:
  000ea	81 7d dc e7 1c
	00 00		 cmp	 DWORD PTR _partynum$[ebp], 7399 ; 00001ce7H
  000f1	7e 0c		 jle	 SHORT $LN61@gObjExpPar
  000f3	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv89[ebp], 0
  000fd	eb 0a		 jmp	 SHORT $LN62@gObjExpPar
$LN61@gObjExpPar:
  000ff	c7 85 54 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv89[ebp], 1
$LN62@gObjExpPar:
  00109	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv89[ebp]
  0010f	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
$LN64@gObjExpPar:
  00115	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR tv90[ebp], 0
  0011c	75 21		 jne	 SHORT $LN13@gObjExpPar

; 1755 : 	{
; 1756 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0011e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z@4JA
  00123	83 c0 65	 add	 eax, 101		; 00000065H
  00126	50		 push	 eax
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@BBHGJELM@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1757 : 		return;

  0013a	e9 b4 04 00 00	 jmp	 $LN1@gObjExpPar
$LN13@gObjExpPar:

; 1758 : 	}
; 1759 : 
; 1760 : 	partycount = gParty.m_PartyS[partynum].Count;

  0013f	6b 45 dc 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  00143	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+8]
  00149	89 4d d0	 mov	 DWORD PTR _partycount$[ebp], ecx

; 1761 : 	for( n=0; n<MAX_PARTYUSER; n++)

  0014c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00153	eb 09		 jmp	 SHORT $LN7@gObjExpPar
$LN5@gObjExpPar:
  00155	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00158	83 c0 01	 add	 eax, 1
  0015b	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjExpPar:
  0015e	83 7d f4 05	 cmp	 DWORD PTR _n$[ebp], 5
  00162	0f 8d dd 00 00
	00		 jge	 $LN6@gObjExpPar

; 1762 : 	{
; 1763 : 		number = gParty.m_PartyS[partynum].Number[n];

  00168	6b 45 dc 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  0016c	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  0016f	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  00176	89 55 e0	 mov	 DWORD PTR _number$[ebp], edx

; 1764 : 		if( number >= 0 )

  00179	83 7d e0 00	 cmp	 DWORD PTR _number$[ebp], 0
  0017d	0f 8c bd 00 00
	00		 jl	 $LN16@gObjExpPar

; 1765 : 		{
; 1766 : 			lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];

  00183	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0018a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00190	89 45 a4	 mov	 DWORD PTR _lpPartyObj$[ebp], eax

; 1767 : 			
; 1768 : 			// 같은 맵에 존재하거나..
; 1769 : 			if( lpTargetObj->MapNumber == lpPartyObj->MapNumber) 

  00193	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00196	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0019d	8b 55 a4	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  001a0	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  001a7	3b c8		 cmp	 ecx, eax
  001a9	0f 85 91 00 00
	00		 jne	 $LN16@gObjExpPar

; 1770 : 			{
; 1771 : 				dis[n] = gObjCalDistance(lpTargetObj, &gObj[number]);

  001af	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  001b6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bc	50		 push	 eax
  001bd	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  001c0	51		 push	 ecx
  001c1	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  001c6	83 c4 08	 add	 esp, 8
  001c9	8b 55 f4	 mov	 edx, DWORD PTR _n$[ebp]
  001cc	89 44 95 bc	 mov	 DWORD PTR _dis$[ebp+edx*4], eax

; 1772 : 				if( dis[n] < 10 )

  001d0	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  001d3	83 7c 85 bc 0a	 cmp	 DWORD PTR _dis$[ebp+eax*4], 10 ; 0000000aH
  001d8	7d 66		 jge	 SHORT $LN16@gObjExpPar

; 1773 : 				{
; 1774 : 					lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];

  001da	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  001e1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e7	89 45 a4	 mov	 DWORD PTR _lpPartyObj$[ebp], eax

; 1775 : #ifdef MODIFY_MASTER_LEVEL_DEVIL_SQUARE_PARTY_EXP_BUGFIX_20080625
; 1776 : 					// 종합레벨 적용 - 파티경험치 계산 : 레벨 200이상 차이날 때 처리
; 1777 : 					// 경험치 계산 방식 수정을 위해 레벨 200이상 차이나는 유저의 레벨에 200을 더함
; 1778 : 					if( toplevel >= ( lpPartyObj->Level + lpPartyObj->m_nMasterLevel + 200 ) )
; 1779 : 					{
; 1780 : 						totallevel += lpPartyObj->Level + lpPartyObj->m_nMasterLevel + 200;
; 1781 : 					}
; 1782 : 					else
; 1783 : 					{
; 1784 : 						totallevel += lpPartyObj->Level + lpPartyObj->m_nMasterLevel;
; 1785 : 					}
; 1786 : #else
; 1787 : 	#ifdef UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 1788 : 					// 경험치 계산 방식 수정을 위해 레벨 200이상 차이나는 유저의 레벨에 200을 더함 - hnine
; 1789 : 					if( toplevel >= (lpPartyObj->Level + 200) )

  001ea	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  001ed	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  001f4	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  001fa	39 4d a0	 cmp	 DWORD PTR _toplevel$[ebp], ecx
  001fd	7c 19		 jl	 SHORT $LN17@gObjExpPar

; 1790 : 					{
; 1791 : 						totallevel += lpPartyObj->Level + 200;

  001ff	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  00202	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00209	8b 55 d8	 mov	 edx, DWORD PTR _totallevel$[ebp]
  0020c	8d 84 0a c8 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx+200]
  00213	89 45 d8	 mov	 DWORD PTR _totallevel$[ebp], eax

; 1792 : 					}

  00216	eb 10		 jmp	 SHORT $LN18@gObjExpPar
$LN17@gObjExpPar:

; 1793 : 					else
; 1794 : 					{
; 1795 : 						totallevel += lpPartyObj->Level;

  00218	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0021b	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00222	03 4d d8	 add	 ecx, DWORD PTR _totallevel$[ebp]
  00225	89 4d d8	 mov	 DWORD PTR _totallevel$[ebp], ecx
$LN18@gObjExpPar:

; 1796 : 					}
; 1797 : 	#else
; 1798 : 					totallevel += lpPartyObj->Level;
; 1799 : 	#endif
; 1800 : #endif // MODIFY_MASTER_LEVEL_DEVIL_SQUARE_PARTY_EXP_BUGFIX_20080625
; 1801 : 					viewplayer++;

  00228	8b 45 b8	 mov	 eax, DWORD PTR _viewplayer$[ebp]
  0022b	83 c0 01	 add	 eax, 1
  0022e	89 45 b8	 mov	 DWORD PTR _viewplayer$[ebp], eax

; 1802 : 					
; 1803 : 					bCheckSetParty[lpPartyObj->Class] = 1;

  00231	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  00234	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0023b	c6 44 0d a8 01	 mov	 BYTE PTR _bCheckSetParty$[ebp+ecx], 1
$LN16@gObjExpPar:

; 1804 : 				}
; 1805 : 			}
; 1806 : 		}
; 1807 : 	}

  00240	e9 10 ff ff ff	 jmp	 $LN5@gObjExpPar
$LN6@gObjExpPar:

; 1808 : 	
; 1809 : #ifdef UPDATE_ADD_NEW_PARTY_SET_EXP_20080325
; 1810 : 	if( bCheckSetParty[0] && bCheckSetParty[1] && bCheckSetParty[2]			// 법사, 기사, 요정 세트
; 1811 : 		|| bCheckSetParty[3] && bCheckSetParty[4] && bCheckSetParty[5] )	// 마검사, 다크로드, 소환술사 세트
; 1812 : #else
; 1813 : 	if( bCheckSetParty[0] && bCheckSetParty[1] && bCheckSetParty[2] )		// 법사, 기사, 요정 세트

  00245	b8 01 00 00 00	 mov	 eax, 1
  0024a	6b c8 00	 imul	 ecx, eax, 0
  0024d	0f b6 54 0d a8	 movzx	 edx, BYTE PTR _bCheckSetParty$[ebp+ecx]
  00252	85 d2		 test	 edx, edx
  00254	74 28		 je	 SHORT $LN19@gObjExpPar
  00256	b8 01 00 00 00	 mov	 eax, 1
  0025b	c1 e0 00	 shl	 eax, 0
  0025e	0f b6 4c 05 a8	 movzx	 ecx, BYTE PTR _bCheckSetParty$[ebp+eax]
  00263	85 c9		 test	 ecx, ecx
  00265	74 17		 je	 SHORT $LN19@gObjExpPar
  00267	b8 01 00 00 00	 mov	 eax, 1
  0026c	d1 e0		 shl	 eax, 1
  0026e	0f b6 4c 05 a8	 movzx	 ecx, BYTE PTR _bCheckSetParty$[ebp+eax]
  00273	85 c9		 test	 ecx, ecx
  00275	74 07		 je	 SHORT $LN19@gObjExpPar

; 1814 : #endif //UPDATE_ADD_NEW_PARTY_SET_EXP_20080325
; 1815 : 	{	// 셋트 파티 적용(법사, 기사, 요정만 있으면 된다)
; 1816 : 		bApplaySetParty = TRUE;

  00277	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _bApplaySetParty$[ebp], 1
$LN19@gObjExpPar:

; 1817 : 	}
; 1818 : 
; 1819 : 	if( viewplayer > 1 )

  0027e	83 7d b8 01	 cmp	 DWORD PTR _viewplayer$[ebp], 1
  00282	0f 8e 8b 00 00
	00		 jle	 $LN20@gObjExpPar

; 1820 : 	{
; 1821 : 
; 1822 : #ifdef MODIFY_GETTING_EXP_RATE_20060214
; 1823 : 		if( bApplaySetParty )

  00288	83 7d b0 00	 cmp	 DWORD PTR _bApplaySetParty$[ebp], 0
  0028c	74 36		 je	 SHORT $LN22@gObjExpPar

; 1824 : 		{	
; 1825 : 			// 세트 경험치가 적용되면
; 1826 : 			if( viewplayer == 3 )		

  0028e	83 7d b8 03	 cmp	 DWORD PTR _viewplayer$[ebp], 3
  00292	75 09		 jne	 SHORT $LN24@gObjExpPar

; 1827 : 			{
; 1828 : 				viewpercent = 230;

  00294	c7 45 b4 e6 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 230 ; 000000e6H

; 1829 : 			}

  0029b	eb 25		 jmp	 SHORT $LN29@gObjExpPar
$LN24@gObjExpPar:

; 1830 : 			else if( viewplayer == 4 )

  0029d	83 7d b8 04	 cmp	 DWORD PTR _viewplayer$[ebp], 4
  002a1	75 09		 jne	 SHORT $LN26@gObjExpPar

; 1831 : 			{
; 1832 : 				viewpercent = 270;

  002a3	c7 45 b4 0e 01
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 270 ; 0000010eH

; 1833 : 			}

  002aa	eb 16		 jmp	 SHORT $LN29@gObjExpPar
$LN26@gObjExpPar:

; 1834 : 			else if( viewplayer >= 5 )	

  002ac	83 7d b8 05	 cmp	 DWORD PTR _viewplayer$[ebp], 5
  002b0	7c 09		 jl	 SHORT $LN28@gObjExpPar

; 1835 : 			{
; 1836 : 				viewpercent = 300;

  002b2	c7 45 b4 2c 01
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 300 ; 0000012cH

; 1837 : 			}

  002b9	eb 07		 jmp	 SHORT $LN29@gObjExpPar
$LN28@gObjExpPar:

; 1838 : 			else
; 1839 : 			{
; 1840 : 				viewpercent = 120;

  002bb	c7 45 b4 78 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 120 ; 00000078H
$LN29@gObjExpPar:

; 1841 : 			}
; 1842 : 		}

  002c2	eb 43		 jmp	 SHORT $LN37@gObjExpPar
$LN22@gObjExpPar:

; 1843 : 		else
; 1844 : 		{
; 1845 : 			if( viewplayer == 2 )

  002c4	83 7d b8 02	 cmp	 DWORD PTR _viewplayer$[ebp], 2
  002c8	75 09		 jne	 SHORT $LN30@gObjExpPar

; 1846 : 			{
; 1847 : 				viewpercent = 160;

  002ca	c7 45 b4 a0 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 160 ; 000000a0H

; 1848 : 			}

  002d1	eb 34		 jmp	 SHORT $LN37@gObjExpPar
$LN30@gObjExpPar:

; 1849 : 			else if( viewplayer == 3 )

  002d3	83 7d b8 03	 cmp	 DWORD PTR _viewplayer$[ebp], 3
  002d7	75 09		 jne	 SHORT $LN32@gObjExpPar

; 1850 : 			{
; 1851 : 				viewpercent = 180;

  002d9	c7 45 b4 b4 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 180 ; 000000b4H

; 1852 : 			}

  002e0	eb 25		 jmp	 SHORT $LN37@gObjExpPar
$LN32@gObjExpPar:

; 1853 : 			else if( viewplayer == 4 )	

  002e2	83 7d b8 04	 cmp	 DWORD PTR _viewplayer$[ebp], 4
  002e6	75 09		 jne	 SHORT $LN34@gObjExpPar

; 1854 : 			{
; 1855 : 				viewpercent = 200;

  002e8	c7 45 b4 c8 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 200 ; 000000c8H

; 1856 : 			}

  002ef	eb 16		 jmp	 SHORT $LN37@gObjExpPar
$LN34@gObjExpPar:

; 1857 : 			else if( viewplayer >= 5 )	

  002f1	83 7d b8 05	 cmp	 DWORD PTR _viewplayer$[ebp], 5
  002f5	7c 09		 jl	 SHORT $LN36@gObjExpPar

; 1858 : 			{
; 1859 : 				viewpercent = 220;

  002f7	c7 45 b4 dc 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 220 ; 000000dcH

; 1860 : 			}

  002fe	eb 07		 jmp	 SHORT $LN37@gObjExpPar
$LN36@gObjExpPar:

; 1861 : 			else
; 1862 : 			{
; 1863 : 				viewpercent = 120;

  00300	c7 45 b4 78 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 120 ; 00000078H
$LN37@gObjExpPar:

; 1864 : 			}
; 1865 : 		}
; 1866 : #else
; 1867 : #ifdef MODIFY_GETTING_EXP_RATE_20051116
; 1868 : 		if( bApplaySetParty )
; 1869 : 		{	
; 1870 : 			// 세트 경험치가 적용되면
; 1871 : 			if( viewplayer == 3 )		
; 1872 : 			{
; 1873 : 				viewpercent = 170;
; 1874 : 			}
; 1875 : 			else if( viewplayer == 4 )
; 1876 : 			{
; 1877 : 				viewpercent = 190;
; 1878 : 			}
; 1879 : 			else if( viewplayer >= 5 )	
; 1880 : 			{
; 1881 : 				viewpercent = 220;
; 1882 : 			}
; 1883 : 			else
; 1884 : 			{
; 1885 : 				viewpercent = 120;
; 1886 : 			}
; 1887 : 
; 1888 : 		}
; 1889 : 		else
; 1890 : 		{
; 1891 : 			if( viewplayer == 3 )
; 1892 : 			{
; 1893 : 				viewpercent = 150;
; 1894 : 			}
; 1895 : 			else if( viewplayer == 4 )	
; 1896 : 			{
; 1897 : 				viewpercent = 170;
; 1898 : 			}
; 1899 : 			else if( viewplayer >= 5 )	
; 1900 : 			{
; 1901 : 				viewpercent = 190;
; 1902 : 			}
; 1903 : 			else
; 1904 : 			{
; 1905 : 				viewpercent = 120;
; 1906 : 			}
; 1907 : 			
; 1908 : 		}
; 1909 : 
; 1910 : #else
; 1911 : 		if( bApplaySetParty )
; 1912 : 		{	// 세트 경험치가 적용되면
; 1913 : 			if( viewplayer == 3 )	viewpercent = 170;
; 1914 : 			else if( viewplayer == 4 )	viewpercent = 190;
; 1915 : 			else if( viewplayer >= 5 )	viewpercent = 220;
; 1916 : 			else viewpercent = 120;
; 1917 : 		}	
; 1918 : 		else
; 1919 : 		{
; 1920 : 			if( viewplayer == 3 )	viewpercent = 150;
; 1921 : 			else if( viewplayer == 4 )	viewpercent = 170;
; 1922 : 			else if( viewplayer >= 5 )	viewpercent = 190;
; 1923 : 			else viewpercent = 120;
; 1924 : 		}
; 1925 : 
; 1926 : #endif // MODIFY_GETTING_EXP_RATE_20051116
; 1927 : #endif // MODIFY_GETTING_EXP_RATE_20060214
; 1928 : 			
; 1929 : 		partylevel = totallevel/viewplayer;

  00307	8b 45 d8	 mov	 eax, DWORD PTR _totallevel$[ebp]
  0030a	99		 cdq
  0030b	f7 7d b8	 idiv	 DWORD PTR _viewplayer$[ebp]
  0030e	89 45 d4	 mov	 DWORD PTR _partylevel$[ebp], eax

; 1930 : 	}

  00311	eb 06		 jmp	 SHORT $LN21@gObjExpPar
$LN20@gObjExpPar:

; 1931 : 	else
; 1932 : 	{
; 1933 : 		partylevel = totallevel;

  00313	8b 45 d8	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00316	89 45 d4	 mov	 DWORD PTR _partylevel$[ebp], eax
$LN21@gObjExpPar:

; 1934 : 	}
; 1935 : 	//LogAdd("viewpercent : Monster:%d %d %d party level : %d",level, viewpercent, totallevel, partylevel);
; 1936 : 
; 1937 : 	
; 1938 : 	if((lpTargetObj->Level+10) < partylevel)

  00319	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0031c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00323	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00326	3b 4d d4	 cmp	 ecx, DWORD PTR _partylevel$[ebp]
  00329	7d 1a		 jge	 SHORT $LN38@gObjExpPar

; 1939 : 	{
; 1940 : 		level =  level * (lpTargetObj->Level+10) / partylevel;

  0032b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0032e	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00335	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00338	8b c1		 mov	 eax, ecx
  0033a	0f af 45 e4	 imul	 eax, DWORD PTR _level$[ebp]
  0033e	99		 cdq
  0033f	f7 7d d4	 idiv	 DWORD PTR _partylevel$[ebp]
  00342	89 45 e4	 mov	 DWORD PTR _level$[ebp], eax
$LN38@gObjExpPar:

; 1941 : 	}
; 1942 : 
; 1943 : 	
; 1944 : #ifdef EXP_CAL_CHANGE
; 1945 : 	if( lpTargetObj->Level >= 65 )	

  00345	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00348	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0034f	83 f9 41	 cmp	 ecx, 65			; 00000041H
  00352	7c 63		 jl	 SHORT $LN41@gObjExpPar

; 1946 : 	{	// 몬스터 레벨이 50이상이면
; 1947 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	// 종합레벨 - 악마의광장 몬스터레벨 계산 조정
; 1948 : 		if( viewplayer == 1 )
; 1949 : 		{
; 1950 : 			level += ( ( lpTargetObj->Level + lpTargetObj->m_nMasterLevel ) - 64 ) * ( lpTargetObj->Level / 4 );
; 1951 : 		}
; 1952 : 		else
; 1953 : 		{
; 1954 : 			level += 200 - ( ( lpObj->Level + lpObj->m_nMasterLevel ) * 0.2 );
; 1955 : 		}
; 1956 : #else
; 1957 : 		if( viewplayer == 1 )

  00354	83 7d b8 01	 cmp	 DWORD PTR _viewplayer$[ebp], 1
  00358	75 2b		 jne	 SHORT $LN40@gObjExpPar

; 1958 : 		{
; 1959 : 	#ifdef MODIFY_GETTING_EXP_RATE_20051116
; 1960 : 			level += (lpTargetObj->Level-64)*(lpTargetObj->Level/3);
; 1961 : 	#else
; 1962 : 			level += (lpTargetObj->Level-64)*(lpTargetObj->Level/4);

  0035a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0035d	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00364	83 e9 40	 sub	 ecx, 64			; 00000040H
  00367	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0036a	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  00371	99		 cdq
  00372	83 e2 03	 and	 edx, 3
  00375	03 c2		 add	 eax, edx
  00377	c1 f8 02	 sar	 eax, 2
  0037a	0f af c8	 imul	 ecx, eax
  0037d	03 4d e4	 add	 ecx, DWORD PTR _level$[ebp]
  00380	89 4d e4	 mov	 DWORD PTR _level$[ebp], ecx

; 1963 : 	#endif
; 1964 : 		}

  00383	eb 32		 jmp	 SHORT $LN41@gObjExpPar
$LN40@gObjExpPar:

; 1965 : 		else
; 1966 : 		{
; 1967 : #ifdef MODIFY_MASTER_LEVEL_DEVIL_SQUARE_PARTY_EXP_BUGFIX_20080625
; 1968 : 			level += 200 - ( ( lpObj->Level + lpObj->m_nMasterLevel ) * 0.2 );
; 1969 : #else
; 1970 : 			level += 200 - (lpObj->Level*0.2);

  00385	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00388	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0038f	f2 0f 2a c1	 cvtsi2sd xmm0, ecx
  00393	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fc999999999999a
  0039b	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4069000000000000
  003a3	f2 0f 5c c8	 subsd	 xmm1, xmm0
  003a7	f2 0f 2a 45 e4	 cvtsi2sd xmm0, DWORD PTR _level$[ebp]
  003ac	f2 0f 58 c1	 addsd	 xmm0, xmm1
  003b0	f2 0f 2c d0	 cvttsd2si edx, xmm0
  003b4	89 55 e4	 mov	 DWORD PTR _level$[ebp], edx
$LN41@gObjExpPar:

; 1971 : #endif // MODIFY_MASTER_LEVEL_DEVIL_SQUARE_PARTY_EXP_BUGFIX_20080625
; 1972 : 		}
; 1973 : #endif	// MASTER_LEVEL_UP_SYSTEM_20070912
; 1974 : 	}
; 1975 : #endif
; 1976 : 
; 1977 : 	if( level > 0 ) 

  003b7	83 7d e4 00	 cmp	 DWORD PTR _level$[ebp], 0
  003bb	7e 0d		 jle	 SHORT $LN42@gObjExpPar

; 1978 : 	{
; 1979 : 		maxexp = level/2;

  003bd	8b 45 e4	 mov	 eax, DWORD PTR _level$[ebp]
  003c0	99		 cdq
  003c1	2b c2		 sub	 eax, edx
  003c3	d1 f8		 sar	 eax, 1
  003c5	89 45 ec	 mov	 DWORD PTR _maxexp$[ebp], eax

; 1980 : 	}

  003c8	eb 07		 jmp	 SHORT $LN43@gObjExpPar
$LN42@gObjExpPar:

; 1981 : 	else level = 0;

  003ca	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN43@gObjExpPar:

; 1982 : 
; 1983 : 	if( maxexp < 1 ) {

  003d1	83 7d ec 01	 cmp	 DWORD PTR _maxexp$[ebp], 1
  003d5	7d 08		 jge	 SHORT $LN44@gObjExpPar

; 1984 : 		totalexp = level;

  003d7	8b 45 e4	 mov	 eax, DWORD PTR _level$[ebp]
  003da	89 45 e8	 mov	 DWORD PTR _totalexp$[ebp], eax

; 1985 : 	}

  003dd	eb 0f		 jmp	 SHORT $LN45@gObjExpPar
$LN44@gObjExpPar:

; 1986 : 	else 
; 1987 : 	{
; 1988 : 		totalexp = level+(rand()%maxexp);

  003df	e8 00 00 00 00	 call	 _rand
  003e4	99		 cdq
  003e5	f7 7d ec	 idiv	 DWORD PTR _maxexp$[ebp]
  003e8	03 55 e4	 add	 edx, DWORD PTR _level$[ebp]
  003eb	89 55 e8	 mov	 DWORD PTR _totalexp$[ebp], edx
$LN45@gObjExpPar:

; 1989 : 	}
; 1990 : 	
; 1991 : 	if( lpTargetObj->Type == OBJTYPE_MONSTER )

  003ee	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003f1	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  003f5	83 f9 02	 cmp	 ecx, 2
  003f8	75 0c		 jne	 SHORT $LN46@gObjExpPar

; 1992 : 	{
; 1993 : 		lpTargetObj->Money = totalexp;

  003fa	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003fd	8b 4d e8	 mov	 ecx, DWORD PTR _totalexp$[ebp]
  00400	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx
$LN46@gObjExpPar:

; 1994 : 	}
; 1995 : 
; 1996 : 	for( n=0; n<MAX_PARTYUSER; n++)

  00406	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0040d	eb 09		 jmp	 SHORT $LN10@gObjExpPar
$LN8@gObjExpPar:
  0040f	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00412	83 c0 01	 add	 eax, 1
  00415	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN10@gObjExpPar:
  00418	83 7d f4 05	 cmp	 DWORD PTR _n$[ebp], 5
  0041c	0f 8d d1 01 00
	00		 jge	 $LN9@gObjExpPar

; 1997 : 	{
; 1998 : 		number = gParty.m_PartyS[partynum].Number[n];

  00422	6b 45 dc 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  00426	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  00429	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  00430	89 55 e0	 mov	 DWORD PTR _number$[ebp], edx

; 1999 : 		if( number >= 0 )

  00433	83 7d e0 00	 cmp	 DWORD PTR _number$[ebp], 0
  00437	0f 8c b1 01 00
	00		 jl	 $LN59@gObjExpPar

; 2000 : 		{
; 2001 : 			lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];

  0043d	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00444	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0044a	89 45 a4	 mov	 DWORD PTR _lpPartyObj$[ebp], eax

; 2002 : 			
; 2003 : 			// 같은 맵에 존재하거나..
; 2004 : 			if( lpTargetObj->MapNumber == lpPartyObj->MapNumber) 

  0044d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00450	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00457	8b 55 a4	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  0045a	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00461	3b c8		 cmp	 ecx, eax
  00463	0f 85 85 01 00
	00		 jne	 $LN59@gObjExpPar

; 2005 : 			{
; 2006 : 				// 비슷한 거리에 존재하는 플레이어만..
; 2007 : 				if( dis[n] < 10 )

  00469	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  0046c	83 7c 85 bc 0a	 cmp	 DWORD PTR _dis$[ebp+eax*4], 10 ; 0000000aH
  00471	0f 8d 77 01 00
	00		 jge	 $LN59@gObjExpPar

; 2008 : 				{
; 2009 : #ifdef MODIFY_MASTER_LEVEL_DEVIL_SQUARE_PARTY_EXP_BUGFIX_20080625
; 2010 : 					// 종합레벨 적용 - 파티 경험치 구할 때 최대 경험치 구하기
; 2011 : 					INT64 mymaxexp = 0;
; 2012 : 					if( !g_MasterLevelSystem.CheckMLGetExp( lpPartyObj, lpTargetObj ) )
; 2013 : 					{	
; 2014 : 						// 파티먹은 마스터레벨 유저라도 제한레벨 이하의 몬스터를 잡으면 경치 없다.
; 2015 : 						exp = 0;
; 2016 : 					}
; 2017 : 					else
; 2018 : 					{
; 2019 : 						if( g_MasterLevelSystem.IsMasterLevelUser( lpPartyObj ) )
; 2020 : 						{
; 2021 : 							mymaxexp = lpPartyObj->m_i64NextMasterLevelExp;
; 2022 : 						}
; 2023 : 						else
; 2024 : 						{
; 2025 : 							mymaxexp = gLevelExperience[lpPartyObj->Level];
; 2026 : 						}				
; 2027 : 						
; 2028 : 						exp = ( totalexp * viewpercent ) * ( lpPartyObj->Level + lpPartyObj->m_nMasterLevel ) / totallevel / 100;
; 2029 : 					}
; 2030 : #else
; 2031 : 					DWORD mymaxexp = gLevelExperience[lpPartyObj->Level];

  00477	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0047a	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00481	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]
  00488	89 55 9c	 mov	 DWORD PTR _mymaxexp$1[ebp], edx

; 2032 : 					
; 2033 : 					exp = (totalexp*viewpercent)*lpPartyObj->Level/totallevel/100;

  0048b	8b 45 e8	 mov	 eax, DWORD PTR _totalexp$[ebp]
  0048e	0f af 45 b4	 imul	 eax, DWORD PTR _viewpercent$[ebp]
  00492	8b 4d a4	 mov	 ecx, DWORD PTR _lpPartyObj$[ebp]
  00495	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  0049c	0f af c2	 imul	 eax, edx
  0049f	99		 cdq
  004a0	f7 7d d8	 idiv	 DWORD PTR _totallevel$[ebp]
  004a3	99		 cdq
  004a4	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  004a9	f7 f9		 idiv	 ecx
  004ab	89 45 f0	 mov	 DWORD PTR _exp$[ebp], eax

; 2034 : #endif // MODIFY_MASTER_LEVEL_DEVIL_SQUARE_PARTY_EXP_BUGFIX_20080625
; 2035 : 					
; 2036 : 					// 자신의 경험치 최대값보다 크면..
; 2037 : 					if( exp > mymaxexp ) exp = mymaxexp;

  004ae	8b 45 f0	 mov	 eax, DWORD PTR _exp$[ebp]
  004b1	3b 45 9c	 cmp	 eax, DWORD PTR _mymaxexp$1[ebp]
  004b4	76 06		 jbe	 SHORT $LN50@gObjExpPar
  004b6	8b 45 9c	 mov	 eax, DWORD PTR _mymaxexp$1[ebp]
  004b9	89 45 f0	 mov	 DWORD PTR _exp$[ebp], eax
$LN50@gObjExpPar:

; 2038 : 					
; 2039 : 					// PK는 경험치를 안준다.
; 2040 : 					if( lpPartyObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER )

  004bc	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  004bf	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  004c3	83 f9 01	 cmp	 ecx, 1
  004c6	75 13		 jne	 SHORT $LN51@gObjExpPar
  004c8	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  004cb	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  004cf	83 f9 01	 cmp	 ecx, 1
  004d2	75 07		 jne	 SHORT $LN51@gObjExpPar

; 2041 : 					{
; 2042 : 						exp = 0;

  004d4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _exp$[ebp], 0
$LN51@gObjExpPar:

; 2043 : 					}
; 2044 : 	#ifdef MASTER_LEVEL_UP_SYSTEM_20070912	// 경험치 증가 - 마스터레벨 유저는 제외	
; 2045 : 					if( !g_MasterLevelSystem.IsMasterLevelUser( lpPartyObj ) )
; 2046 : 						exp = (int)((float)exp*gAddExperience);
; 2047 : 	#else					
; 2048 : 					exp = (int)((float)exp*gAddExperience);

  004db	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _exp$[ebp]
  004e0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?gAddExperience@@3MA
  004e8	f3 0f 2c c0	 cvttss2si eax, xmm0
  004ec	89 45 f0	 mov	 DWORD PTR _exp$[ebp], eax

; 2049 : 	#endif
; 2050 : #if defined(PCBANG_POINT_SYSTEM_20070206) && defined(ADD_PCBANG_EXPRATE)
; 2051 : 					if( !g_MasterLevelSystem.IsMasterLevelUser( lpPartyObj ) )
; 2052 : 						g_PCBangPointSystem.CheckPCBangAddExperience(lpPartyObj, exp);
; 2053 : #endif // ADD_PCBANG_EXPRATE
; 2054 : 
; 2055 : #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004					// !! NOT
; 2056 : 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 2057 : 		#ifdef MODIFY_MARKITEM_EFFECT_REMOVE_IN_EVENTMAP_20070328
; 2058 : 					if( lpPartyObj->m_wExprienceRate == 0 )
; 2059 : 					{
; 2060 : 						exp = 0;
; 2061 : 					}
; 2062 : 					else
; 2063 : 					{
; 2064 : 						exp = (int)(exp * ((float)lpPartyObj->m_wExprienceRate / 100 ));
; 2065 : 					}
; 2066 : 		#else
; 2067 : 					if( lpPartyObj->m_wExprienceRate > 0 )

  004ef	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  004f2	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  004f9	85 c9		 test	 ecx, ecx
  004fb	7e 26		 jle	 SHORT $LN52@gObjExpPar

; 2068 : 					{
; 2069 : 						exp = (int)(exp * ((float)lpPartyObj->m_wExprienceRate / 100 ));

  004fd	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _exp$[ebp]
  00502	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  00505	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  0050c	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00510	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@42c80000
  00518	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0051c	f3 0f 2c d0	 cvttss2si edx, xmm0
  00520	89 55 f0	 mov	 DWORD PTR _exp$[ebp], edx
$LN52@gObjExpPar:

; 2070 : 					}
; 2071 : 		#endif // MODIFY_MARKITEM_EFFECT_REMOVE_IN_EVENTMAP_20070328
; 2072 : 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 2073 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2074 : 
; 2075 : #ifdef MU_CRYWOLF_PENALTY_20051215
; 2076 : 					// MVP 실패 : 경험치 획득 감소 
; 2077 : 					if( g_CrywolfSync.GetOccupationState() == CRYWOLF_OCCUPATION_STATE_OCCUPIED 
; 2078 : 						&& g_iCrywolfApplyMvpPenalty	
; 2079 : 					  )
; 2080 : 					{
; 2081 : 						exp = exp * g_CrywolfSync.GetGettingExpPenaltyRate() / 100;
; 2082 : 					}
; 2083 : #endif
; 2084 : 					
; 2085 : 					if( exp > 0 ) {

  00523	83 7d f0 00	 cmp	 DWORD PTR _exp$[ebp], 0
  00527	0f 8e 87 00 00
	00		 jle	 $LN57@gObjExpPar

; 2086 : 						if( lpPartyObj->Type == OBJTYPE_CHARACTER ) 

  0052d	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  00530	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00534	83 f9 01	 cmp	 ecx, 1
  00537	75 7b		 jne	 SHORT $LN57@gObjExpPar

; 2087 : 						{
; 2088 : #ifdef CHN_PLAYTIME_LIMIT_SYSTEM_20050818	// 중국변경> . 전체 몬스터 아이템 드롭 확률을 조정함.
; 2089 : 							if (g_bChnPlayTimeLimitOn)
; 2090 : 							{
; 2091 : 	#ifdef MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 2092 : 								if( lpPartyObj->m_iVerifyType != PLAYTIME_LIMIT_VERIFY_ADULT )
; 2093 : 								{
; 2094 : 									if (lpPartyObj->m_iPlayTimeLimit >= 5*60*60)
; 2095 : 									{
; 2096 : 										exp = exp * g_iChnPlayTimeLimitLevel2Exp / 100;
; 2097 : 									}
; 2098 : 									else if (lpPartyObj->m_iPlayTimeLimit >= 3*60*60)
; 2099 : 									{
; 2100 : 										exp = exp * g_iChnPlayTimeLimitLevel1Exp / 100;
; 2101 : 									}
; 2102 : 								}
; 2103 : 	#else
; 2104 : 								if (lpPartyObj->m_iPlayTimeLimit >= 5*60*60)
; 2105 : 								{
; 2106 : 									exp = exp * g_iChnPlayTimeLimitLevel2Exp / 100;
; 2107 : 								}
; 2108 : 								else if (lpPartyObj->m_iPlayTimeLimit >= 3*60*60)
; 2109 : 								{
; 2110 : 									exp = exp * g_iChnPlayTimeLimitLevel1Exp / 100;
; 2111 : 								}
; 2112 : 	#endif // MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 2113 : 							}
; 2114 : #endif
; 2115 : 
; 2116 : 							
; 2117 : #ifdef VTM_PLAYTIME_LIMIT_SYSTEM_20060626	// 베트남 : 데비스퀘어 경험치 획득량 조정
; 2118 : 							if (g_bVtmPlayTimeLimitOn) 
; 2119 : 							{
; 2120 : 								if (lpPartyObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel2Time * 60) 
; 2121 : 								{
; 2122 : 									exp = exp * g_iVtmPlayTimeLimitLevel2Exp / 100;
; 2123 : 								}
; 2124 : 								else if (lpPartyObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel1Time * 60) 
; 2125 : 								{
; 2126 : 									exp = exp * g_iVtmPlayTimeLimitLevel1Exp / 100;
; 2127 : 								}
; 2128 : 							}
; 2129 : #endif
; 2130 : 
; 2131 : 
; 2132 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2133 : 	#ifdef MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 2134 : 								CheckItemOptForGetExpEx(lpPartyObj, exp);
; 2135 : 	#else // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 2136 : 	//--> MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC 적용 후 아래코드 삭제할 예정
; 2137 : 	#ifdef BUGFIX_BUFF_EFFECT_SYSTEM_FOR_PCBANG_ITEM_20071205
; 2138 : 							g_PCBangPointSystem.CheckItemOptForGetExp( lpPartyObj, exp );
; 2139 : 	#else
; 2140 : 		#ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 2141 : 							CheckItemOptForGetExp(lpPartyObj, exp);
; 2142 : 		#else
; 2143 : 							int iExpRate = 0;
; 2144 : 							iExpRate = gObjGetTotalValueOfEffect( lpPartyObj, EFFECTTYPE_EXPERIENCE );
; 2145 : 							if( gObjCheckUsedBuffEffect( lpPartyObj, BUFFTYPE_PCBANG_POINT_MARK3 ) == false
; 2146 : 								&& iExpRate == 0
; 2147 : 							)
; 2148 : 							{
; 2149 : 								iExpRate = 100;
; 2150 : 							}
; 2151 : 
; 2152 : 							exp = ( exp * iExpRate ) / 100;
; 2153 : 		#endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 2154 : 
; 2155 : 	#endif	// BUGFIX_BUFF_EFFECT_SYSTEM_FOR_PCBANG_ITEM_20071205
; 2156 : 	//<--
; 2157 : 	#endif // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 2158 : 
; 2159 : 							lpPartyObj->Experience += exp;
; 2160 : 							lpPartyObj->m_nEventExp += exp;
; 2161 : #else
; 2162 : 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 2163 : 							if( lpPartyObj->m_wExprienceRate > 0 )

  00539	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0053c	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  00543	85 c9		 test	 ecx, ecx
  00545	7e 2a		 jle	 SHORT $LN55@gObjExpPar

; 2164 : 							{
; 2165 : 								lpPartyObj->Experience += exp;

  00547	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0054a	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00550	03 4d f0	 add	 ecx, DWORD PTR _exp$[ebp]
  00553	8b 55 a4	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  00556	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 2166 : 								lpPartyObj->m_nEventExp += exp;

  0055c	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0055f	8b 88 c8 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3272]
  00565	03 4d f0	 add	 ecx, DWORD PTR _exp$[ebp]
  00568	8b 55 a4	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  0056b	89 8a c8 0c 00
	00		 mov	 DWORD PTR [edx+3272], ecx
$LN55@gObjExpPar:

; 2167 : 							}
; 2168 : 	#else
; 2169 : 							lpPartyObj->Experience += exp;
; 2170 : 							lpPartyObj->m_nEventExp += exp;
; 2171 : 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 2172 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2173 : 
; 2174 : 							if(lpTargetObj->Money < exp)

  00571	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00574	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0057a	3b 4d f0	 cmp	 ecx, DWORD PTR _exp$[ebp]
  0057d	7d 0c		 jge	 SHORT $LN56@gObjExpPar

; 2175 : 							{
; 2176 : 								lpTargetObj->Money = exp;

  0057f	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00582	8b 4d f0	 mov	 ecx, DWORD PTR _exp$[ebp]
  00585	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx
$LN56@gObjExpPar:

; 2177 : 							}
; 2178 : 
; 2179 : 							/*if( exp > 1200 )
; 2180 : 							{
; 2181 : 								LogAddC(LOGC_RED, lMsg.Get(526), lpPartyObj->AccountID, lpPartyObj->Name, lpPartyObj->Level, exp, lpTargetObj->Name);
; 2182 : 							}*/
; 2183 : 							//LogAdd("획득 : [%s][%s] [%s] %d (%d / %d:%d)", lpPartyObj->AccountID, lpPartyObj->Name, lpTargetObj->Name, exp, lpPartyObj->MapNumber, lpPartyObj->X, lpPartyObj->Y);
; 2184 : 
; 2185 : #ifdef MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 2186 : 							if (gObjLevelUp(lpPartyObj, exp, lpTargetObj->Class, EVENT_TYPE_PARTY ) == false)

  0058b	6a 01		 push	 1
  0058d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00590	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00597	51		 push	 ecx
  00598	8b 55 f0	 mov	 edx, DWORD PTR _exp$[ebp]
  0059b	52		 push	 edx
  0059c	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0059f	50		 push	 eax
  005a0	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAVOBJECTSTRUCT@@HHH@Z ; gObjLevelUp
  005a5	83 c4 10	 add	 esp, 16			; 00000010H
  005a8	0f b6 c8	 movzx	 ecx, al
  005ab	85 c9		 test	 ecx, ecx
  005ad	75 05		 jne	 SHORT $LN57@gObjExpPar

; 2187 : 								continue;

  005af	e9 5b fe ff ff	 jmp	 $LN8@gObjExpPar
$LN57@gObjExpPar:

; 2188 : #else
; 2189 : 	#ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 2190 : 							if (gObjLevelUp(lpPartyObj, exp) == false)
; 2191 : 								continue;
; 2192 : 	#endif
; 2193 : #endif // MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 2194 : 
; 2195 : 						}
; 2196 : 					}
; 2197 : 					if( lpPartyObj->Type == OBJTYPE_CHARACTER )

  005b4	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  005b7	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  005bb	83 f9 01	 cmp	 ecx, 1
  005be	75 2e		 jne	 SHORT $LN59@gObjExpPar

; 2198 : 					{
; 2199 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2200 : 						GCKillPlayerExpSend(lpPartyObj->m_Index, lpTargetObj->m_Index, exp, AttackDamage, MSBFlag);
; 2201 : #else
; 2202 : 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 2203 : 						if( lpPartyObj->m_wExprienceRate > 0 )

  005c0	8b 45 a4	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  005c3	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  005ca	85 c9		 test	 ecx, ecx
  005cc	7e 20		 jle	 SHORT $LN59@gObjExpPar

; 2204 : 						{
; 2205 : 							GCKillPlayerExpSend(lpPartyObj->m_Index, lpTargetObj->m_Index, exp, AttackDamage, MSBFlag);

  005ce	8b 45 14	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  005d1	50		 push	 eax
  005d2	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  005d5	51		 push	 ecx
  005d6	8b 55 f0	 mov	 edx, DWORD PTR _exp$[ebp]
  005d9	52		 push	 edx
  005da	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  005dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  005df	51		 push	 ecx
  005e0	8b 55 a4	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  005e3	8b 02		 mov	 eax, DWORD PTR [edx]
  005e5	50		 push	 eax
  005e6	e8 00 00 00 00	 call	 ?GCKillPlayerExpSend@@YAXHHHHH@Z ; GCKillPlayerExpSend
  005eb	83 c4 14	 add	 esp, 20			; 00000014H
$LN59@gObjExpPar:

; 2206 : 						}
; 2207 : 	#else
; 2208 : 						GCKillPlayerExpSend(lpPartyObj->m_Index, lpTargetObj->m_Index, exp, AttackDamage, MSBFlag);
; 2209 : 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 2210 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2211 : 					}
; 2212 : 				}
; 2213 : 			}
; 2214 : 		}
; 2215 : 	}

  005ee	e9 1c fe ff ff	 jmp	 $LN8@gObjExpPar
$LN9@gObjExpPar:
$LN1@gObjExpPar:

; 2216 : }

  005f3	5f		 pop	 edi
  005f4	5e		 pop	 esi
  005f5	5b		 pop	 ebx
  005f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f9	33 cd		 xor	 ecx, ebp
  005fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00600	8b e5		 mov	 esp, ebp
  00602	5d		 pop	 ebp
  00603	c2 10 00	 ret	 16			; 00000010H
?gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z ENDP ; CDevilSquare::gObjExpParty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?gObjMonsterExpSingle@CDevilSquare@@QAEHPAVOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
__fDivider$ = -24					; size = 4
_mymaxexp$ = -20					; size = 4
_level$ = -16						; size = 4
_maxexp$ = -12						; size = 4
_exp$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_dmg$ = 16						; size = 4
_tot_dmg$ = 20						; size = 4
?gObjMonsterExpSingle@CDevilSquare@@QAEHPAVOBJECTSTRUCT@@0HH@Z PROC ; CDevilSquare::gObjMonsterExpSingle, COMDAT
; _this$ = ecx

; 1440 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1441 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912
; 1442 : 	INT64 exp, maxexp=0;
; 1443 : #else
; 1444 : 	int exp, maxexp=0;

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _maxexp$[ebp], 0

; 1445 : #endif
; 1446 : 
; 1447 : #ifdef MODIFY_GETTING_EXP_RATE_20060214
; 1448 : 	int level = ((lpTargetObj->Level+25)*lpTargetObj->Level)/3;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00016	0f bf 80 a0 00
	00 00		 movsx	 eax, WORD PTR [eax+160]
  0001d	83 c0 19	 add	 eax, 25			; 00000019H
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00023	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  0002a	0f af c2	 imul	 eax, edx
  0002d	99		 cdq
  0002e	b9 03 00 00 00	 mov	 ecx, 3
  00033	f7 f9		 idiv	 ecx
  00035	89 45 f0	 mov	 DWORD PTR _level$[ebp], eax

; 1449 : #else
; 1450 : #ifdef MODIFY_GETTING_EXP_RATE_20051116
; 1451 : 	int level = ((lpTargetObj->Level+20)*lpTargetObj->Level)/4;
; 1452 : #else
; 1453 : 	int level = ((lpTargetObj->Level+10)*lpTargetObj->Level)/4;	
; 1454 : #endif
; 1455 : #endif // MODIFY_GETTING_EXP_RATE_20060214
; 1456 : 	
; 1457 : 	// 자신의 레벨보다 10 작으면 깎이기 시작해서..
; 1458 : 	if( (lpTargetObj->Level+10) < lpObj->Level )

  00038	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0003b	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00042	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00045	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00048	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  0004f	3b c8		 cmp	 ecx, eax
  00051	7d 23		 jge	 SHORT $LN2@gObjMonste

; 1459 : 	{
; 1460 : 		level =  level * (lpTargetObj->Level+10) / lpObj->Level;

  00053	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00056	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0005d	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00060	8b c1		 mov	 eax, ecx
  00062	0f af 45 f0	 imul	 eax, DWORD PTR _level$[ebp]
  00066	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00069	0f bf 8a a0 00
	00 00		 movsx	 ecx, WORD PTR [edx+160]
  00070	99		 cdq
  00071	f7 f9		 idiv	 ecx
  00073	89 45 f0	 mov	 DWORD PTR _level$[ebp], eax
$LN2@gObjMonste:

; 1461 : 	}
; 1462 : 	
; 1463 : #ifdef EXP_CAL_CHANGE	
; 1464 : 	if( lpTargetObj->Level >= 65 )	

  00076	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00079	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00080	83 f9 41	 cmp	 ecx, 65			; 00000041H
  00083	7c 29		 jl	 SHORT $LN3@gObjMonste

; 1465 : 	{	// 몬스터 레벨이 50이상이면
; 1466 : 
; 1467 : 	#ifdef MODIFY_GETTING_EXP_RATE_20051116
; 1468 : 		level += (lpTargetObj->Level-64)*(lpTargetObj->Level/3);
; 1469 : 	#else
; 1470 : 		level += (lpTargetObj->Level-64)*(lpTargetObj->Level/4);

  00085	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00088	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0008f	83 e9 40	 sub	 ecx, 64			; 00000040H
  00092	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00095	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  0009c	99		 cdq
  0009d	83 e2 03	 and	 edx, 3
  000a0	03 c2		 add	 eax, edx
  000a2	c1 f8 02	 sar	 eax, 2
  000a5	0f af c8	 imul	 ecx, eax
  000a8	03 4d f0	 add	 ecx, DWORD PTR _level$[ebp]
  000ab	89 4d f0	 mov	 DWORD PTR _level$[ebp], ecx
$LN3@gObjMonste:

; 1471 : 	#endif
; 1472 : 
; 1473 : 	}
; 1474 : #endif
; 1475 : 
; 1476 : 	if( level > 0 )

  000ae	83 7d f0 00	 cmp	 DWORD PTR _level$[ebp], 0
  000b2	7e 0d		 jle	 SHORT $LN4@gObjMonste

; 1477 : 	{
; 1478 : 		maxexp = level/2;

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _level$[ebp]
  000b7	99		 cdq
  000b8	2b c2		 sub	 eax, edx
  000ba	d1 f8		 sar	 eax, 1
  000bc	89 45 f4	 mov	 DWORD PTR _maxexp$[ebp], eax

; 1479 : 	}

  000bf	eb 07		 jmp	 SHORT $LN5@gObjMonste
$LN4@gObjMonste:

; 1480 : 	else level = 0;

  000c1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN5@gObjMonste:

; 1481 : 
; 1482 : 	if( maxexp < 1 ) {

  000c8	83 7d f4 01	 cmp	 DWORD PTR _maxexp$[ebp], 1
  000cc	7d 08		 jge	 SHORT $LN6@gObjMonste

; 1483 : 		exp = level;

  000ce	8b 45 f0	 mov	 eax, DWORD PTR _level$[ebp]
  000d1	89 45 f8	 mov	 DWORD PTR _exp$[ebp], eax

; 1484 : 	}

  000d4	eb 0f		 jmp	 SHORT $LN7@gObjMonste
$LN6@gObjMonste:

; 1485 : 	else
; 1486 : 	{
; 1487 : 		exp = level+(rand()%maxexp);		

  000d6	e8 00 00 00 00	 call	 _rand
  000db	99		 cdq
  000dc	f7 7d f4	 idiv	 DWORD PTR _maxexp$[ebp]
  000df	03 55 f0	 add	 edx, DWORD PTR _level$[ebp]
  000e2	89 55 f8	 mov	 DWORD PTR _exp$[ebp], edx
$LN7@gObjMonste:

; 1488 : 	}
; 1489 : 	
; 1490 : 	exp = (dmg*exp)/tot_dmg;	

  000e5	8b 45 10	 mov	 eax, DWORD PTR _dmg$[ebp]
  000e8	0f af 45 f8	 imul	 eax, DWORD PTR _exp$[ebp]
  000ec	99		 cdq
  000ed	f7 7d 14	 idiv	 DWORD PTR _tot_dmg$[ebp]
  000f0	89 45 f8	 mov	 DWORD PTR _exp$[ebp], eax

; 1491 : 
; 1492 : 	DWORD mymaxexp = gLevelExperience[lpObj->Level];

  000f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f6	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000fd	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]
  00104	89 55 ec	 mov	 DWORD PTR _mymaxexp$[ebp], edx

; 1493 : 	// 자신의 경험치 최대값보다 크면..
; 1494 : 	if( exp > mymaxexp ) exp = mymaxexp;

  00107	8b 45 f8	 mov	 eax, DWORD PTR _exp$[ebp]
  0010a	3b 45 ec	 cmp	 eax, DWORD PTR _mymaxexp$[ebp]
  0010d	76 06		 jbe	 SHORT $LN8@gObjMonste
  0010f	8b 45 ec	 mov	 eax, DWORD PTR _mymaxexp$[ebp]
  00112	89 45 f8	 mov	 DWORD PTR _exp$[ebp], eax
$LN8@gObjMonste:

; 1495 : 
; 1496 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	// 경험치 증가 - 마스터레벨 유저는 제외	
; 1497 : 	if( !g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 1498 : 		exp = (int)((float)exp*gAddExperience);
; 1499 : #else
; 1500 : 	exp = (int)((float)exp*gAddExperience);

  00115	f3 0f 2a 45 f8	 cvtsi2ss xmm0, DWORD PTR _exp$[ebp]
  0011a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?gAddExperience@@3MA
  00122	f3 0f 2c c0	 cvttss2si eax, xmm0
  00126	89 45 f8	 mov	 DWORD PTR _exp$[ebp], eax

; 1501 : 
; 1502 : 	float _fDivider = _dynamic_experience._checkCondition(lpObj);

  00129	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012c	50		 push	 eax
  0012d	b9 00 00 00 00	 mov	 ecx, OFFSET ?_dynamic_experience@@3VCDynamicExperience@@A ; _dynamic_experience
  00132	e8 00 00 00 00	 call	 ?_checkCondition@CDynamicExperience@@QAEMPAVOBJECTSTRUCT@@@Z ; CDynamicExperience::_checkCondition
  00137	d9 5d e8	 fstp	 DWORD PTR __fDivider$[ebp]

; 1503 : 	// ----
; 1504 : 	if (_fDivider != 0) 

  0013a	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR __fDivider$[ebp]
  0013f	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00146	9f		 lahf
  00147	f6 c4 44	 test	 ah, 68			; 00000044H
  0014a	7b 1c		 jnp	 SHORT $LN9@gObjMonste

; 1505 : 	{
; 1506 : 		exp = _dynamic_experience._getNewExperience(exp, _fDivider);

  0014c	51		 push	 ecx
  0014d	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR __fDivider$[ebp]
  00152	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00157	8b 45 f8	 mov	 eax, DWORD PTR _exp$[ebp]
  0015a	50		 push	 eax
  0015b	b9 00 00 00 00	 mov	 ecx, OFFSET ?_dynamic_experience@@3VCDynamicExperience@@A ; _dynamic_experience
  00160	e8 00 00 00 00	 call	 ?_getNewExperience@CDynamicExperience@@QAEKKM@Z ; CDynamicExperience::_getNewExperience
  00165	89 45 f8	 mov	 DWORD PTR _exp$[ebp], eax
$LN9@gObjMonste:

; 1507 : 	}
; 1508 : 
; 1509 : #endif
; 1510 : 
; 1511 : #if defined(PCBANG_POINT_SYSTEM_20070206) && defined(ADD_PCBANG_EXPRATE)
; 1512 : 	if( !g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 1513 : 		g_PCBangPointSystem.CheckPCBangAddExperience(lpObj, exp);
; 1514 : #endif // ADD_PCBANG_EXPRATE
; 1515 : 
; 1516 : #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004					 // !! NOT
; 1517 : 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 1518 : 		#ifdef MODIFY_MARKITEM_EFFECT_REMOVE_IN_EVENTMAP_20070328
; 1519 : 	if( lpObj->m_wExprienceRate == 0 )
; 1520 : 	{
; 1521 : 		exp = 0;
; 1522 : 	}
; 1523 : 	else
; 1524 : 	{
; 1525 : 		exp = (int)(exp * ((float)lpObj->m_wExprienceRate / 100 ));
; 1526 : 	}
; 1527 : 		#else
; 1528 : 	if( lpObj->m_wExprienceRate > 0 )

  00168	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016b	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  00172	85 c9		 test	 ecx, ecx
  00174	7e 26		 jle	 SHORT $LN10@gObjMonste

; 1529 : 	{
; 1530 : 		exp = (int)(exp * ((float)lpObj->m_wExprienceRate / 100 ));

  00176	f3 0f 2a 45 f8	 cvtsi2ss xmm0, DWORD PTR _exp$[ebp]
  0017b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017e	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  00185	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00189	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@42c80000
  00191	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00195	f3 0f 2c d0	 cvttss2si edx, xmm0
  00199	89 55 f8	 mov	 DWORD PTR _exp$[ebp], edx
$LN10@gObjMonste:

; 1531 : 	}
; 1532 : 		#endif // MODIFY_MARKITEM_EFFECT_REMOVE_IN_EVENTMAP_20070328
; 1533 : 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 1534 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1535 : 
; 1536 : 	//LogAdd("획득 : [%s][%s] [%s] %d (%d / %d:%d)", lpObj->AccountID, lpObj->Name, lpTargetObj->Name, exp, lpObj->MapNumber, lpObj->X, lpObj->Y);
; 1537 : 
; 1538 : #ifdef MU_CRYWOLF_PENALTY_20051215
; 1539 : 	// MVP 실패 : 경험치 획득 감소 
; 1540 : 	if( g_CrywolfSync.GetOccupationState() == CRYWOLF_OCCUPATION_STATE_OCCUPIED 
; 1541 : 		&& g_iCrywolfApplyMvpPenalty	
; 1542 : 	  )
; 1543 : 	{
; 1544 : 		exp = exp * g_CrywolfSync.GetGettingExpPenaltyRate() / 100;
; 1545 : 	}
; 1546 : #endif
; 1547 : 
; 1548 : 	if( exp > 0 ) 

  0019c	83 7d f8 00	 cmp	 DWORD PTR _exp$[ebp], 0
  001a0	0f 8e 9a 00 00
	00		 jle	 $LN14@gObjMonste

; 1549 : 	{
; 1550 : 		if( lpObj->Type == OBJTYPE_CHARACTER )

  001a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a9	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  001ad	83 f9 01	 cmp	 ecx, 1
  001b0	0f 85 8a 00 00
	00		 jne	 $LN14@gObjMonste

; 1551 : 		{
; 1552 : #ifdef CHN_PLAYTIME_LIMIT_SYSTEM_20050818	// 중국변경> . 전체 몬스터 아이템 드롭 확률을 조정함.
; 1553 : 			if (g_bChnPlayTimeLimitOn)
; 1554 : 			{
; 1555 : 	#ifdef MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 1556 : 				if( lpObj->m_iVerifyType != PLAYTIME_LIMIT_VERIFY_ADULT )
; 1557 : 				{
; 1558 : 					if (lpObj->m_iPlayTimeLimit >= 5*60*60) {
; 1559 : 						exp = exp * g_iChnPlayTimeLimitLevel2Exp / 100;
; 1560 : 					}
; 1561 : 					else if (lpObj->m_iPlayTimeLimit >= 3*60*60) {
; 1562 : 						exp = exp * g_iChnPlayTimeLimitLevel1Exp / 100;
; 1563 : 					}
; 1564 : 				}
; 1565 : 	#else
; 1566 : 				if (lpObj->m_iPlayTimeLimit >= 5*60*60) {
; 1567 : 					exp = exp * g_iChnPlayTimeLimitLevel2Exp / 100;
; 1568 : 				}
; 1569 : 				else if (lpObj->m_iPlayTimeLimit >= 3*60*60) {
; 1570 : 					exp = exp * g_iChnPlayTimeLimitLevel1Exp / 100;
; 1571 : 				}
; 1572 : 	#endif // MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 1573 : 			}
; 1574 : #endif
; 1575 : 
; 1576 : #ifdef VTM_PLAYTIME_LIMIT_SYSTEM_20060626	// 베트남 : 데빌스퀘어 경험치 획득량 조정
; 1577 : 			if (g_bVtmPlayTimeLimitOn) 
; 1578 : 			{
; 1579 : 				if (lpObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel2Time * 60) 
; 1580 : 				{
; 1581 : 					exp = exp * g_iVtmPlayTimeLimitLevel2Exp / 100;
; 1582 : 				}
; 1583 : 				else if (lpObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel1Time * 60) 
; 1584 : 				{
; 1585 : 					exp = exp * g_iVtmPlayTimeLimitLevel1Exp / 100;
; 1586 : 				}
; 1587 : 			}
; 1588 : #endif
; 1589 : 
; 1590 : /*#ifdef PCBANG_POINT_SYSTEM_20070206		// 악마의광장 - PC방 아이템 적용 확인(경험치)
; 1591 : 			g_PCBangPointSystem.CheckItemOptForGetExp( lpObj, exp );
; 1592 : #endif*/
; 1593 : #ifdef MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 1594 : 			CheckItemOptForGetExpEx(lpObj, exp);
; 1595 : #else
; 1596 : //--> MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC 적용 후 아래코드 삭제할 예정			
; 1597 : #ifdef BUGFIX_BUFF_EFFECT_SYSTEM_FOR_PCBANG_ITEM_20071205
; 1598 : 			g_PCBangPointSystem.CheckItemOptForGetExp( lpObj, exp );
; 1599 : #else
; 1600 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1601 : 			
; 1602 : 	#ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 1603 : 			CheckItemOptForGetExp(lpObj, exp);
; 1604 : 	#else
; 1605 : 			//20080416 - 아래 코드는 삭제해도 될것 같음
; 1606 : 			int iExpRate = 0;
; 1607 : 			iExpRate = gObjGetTotalValueOfEffect( lpObj, EFFECTTYPE_EXPERIENCE );
; 1608 : 			if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_PCBANG_POINT_MARK3 ) == false
; 1609 : 				&& iExpRate == 0
; 1610 : 				)
; 1611 : 			{
; 1612 : 				iExpRate = 100;
; 1613 : 			}
; 1614 : 			exp = ( exp * iExpRate ) / 100;
; 1615 : 	#endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 1616 : 			
; 1617 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1618 : #endif	// BUGFIX_BUFF_EFFECT_SYSTEM_FOR_PCBANG_ITEM_20071205			
; 1619 : //<--
; 1620 : #endif // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 1621 : 
; 1622 : 			lpObj->Experience += exp;

  001b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b9	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  001bf	03 4d f8	 add	 ecx, DWORD PTR _exp$[ebp]
  001c2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001c5	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 1623 : 			lpObj->m_nEventExp += exp;

  001cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ce	8b 88 c8 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3272]
  001d4	03 4d f8	 add	 ecx, DWORD PTR _exp$[ebp]
  001d7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001da	89 8a c8 0c 00
	00		 mov	 DWORD PTR [edx+3272], ecx

; 1624 : 
; 1625 : #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004		// !!NOT
; 1626 : 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 1627 : 			if( lpObj->m_wExprienceRate > 0 )

  001e0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e3	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  001ea	85 c9		 test	 ecx, ecx
  001ec	7e 2a		 jle	 SHORT $LN13@gObjMonste

; 1628 : 			{
; 1629 : 				lpObj->Experience += exp;

  001ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f1	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  001f7	03 4d f8	 add	 ecx, DWORD PTR _exp$[ebp]
  001fa	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001fd	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 1630 : 				lpObj->m_nEventExp += exp;

  00203	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00206	8b 88 c8 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3272]
  0020c	03 4d f8	 add	 ecx, DWORD PTR _exp$[ebp]
  0020f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00212	89 8a c8 0c 00
	00		 mov	 DWORD PTR [edx+3272], ecx
$LN13@gObjMonste:

; 1631 : 			}
; 1632 : 	#else
; 1633 : 			lpObj->Experience += exp;
; 1634 : 			lpObj->m_nEventExp += exp;
; 1635 : 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 1636 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1637 : 
; 1638 : #ifdef MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 1639 : 			if (gObjLevelUp(lpObj, exp, lpTargetObj->Class, EVENT_TYPE_NONE ) == false)

  00218	6a 00		 push	 0
  0021a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0021d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00224	51		 push	 ecx
  00225	8b 55 f8	 mov	 edx, DWORD PTR _exp$[ebp]
  00228	52		 push	 edx
  00229	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAVOBJECTSTRUCT@@HHH@Z ; gObjLevelUp
  00232	83 c4 10	 add	 esp, 16			; 00000010H
  00235	0f b6 c8	 movzx	 ecx, al
  00238	85 c9		 test	 ecx, ecx
  0023a	75 04		 jne	 SHORT $LN14@gObjMonste

; 1640 : 				return 0;

  0023c	33 c0		 xor	 eax, eax
  0023e	eb 03		 jmp	 SHORT $LN1@gObjMonste
$LN14@gObjMonste:

; 1641 : #else
; 1642 : 	#ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 1643 : 			if (gObjLevelUp(lpObj, exp) == false)
; 1644 : 				return 0;
; 1645 : 	#endif
; 1646 : #endif // MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 1647 : 
; 1648 : 		}
; 1649 : 	}
; 1650 : 	return exp;

  00240	8b 45 f8	 mov	 eax, DWORD PTR _exp$[ebp]
$LN1@gObjMonste:

; 1651 : }

  00243	5f		 pop	 edi
  00244	5e		 pop	 esi
  00245	5b		 pop	 ebx
  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c2 10 00	 ret	 16			; 00000010H
?gObjMonsterExpSingle@CDevilSquare@@QAEHPAVOBJECTSTRUCT@@0HH@Z ENDP ; CDevilSquare::gObjMonsterExpSingle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?DieProcDevilSquare@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -304						; size = 40
_msg$ = -264						; size = 255
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?DieProcDevilSquare@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CDevilSquare::DieProcDevilSquare, COMDAT
; _this$ = ecx

; 1386 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1387 : 	char msg[255];
; 1388 : 
; 1389 : 	wsprintf(msg, lMsg.Get(709), lpObj->m_nEventScore);	//실패하셨군요. 사냥점수는%d점이며 다음 기회에 다시 도전해보시기 바랍니다

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	8b 88 c4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3268]
  00022	51		 push	 ecx
  00023	68 c5 02 00 00	 push	 709			; 000002c5H
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00033	50		 push	 eax
  00034	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _msg$[ebp]
  0003a	52		 push	 edx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 : 	GCServerMsgStringSend(msg, lpObj->m_Index, 1);	

  00044	6a 01		 push	 1
  00046	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _msg$[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1391 : 
; 1392 : 	if( lpObj->m_nEventScore <= 0 )

  0005b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005e	83 b8 c4 0c 00
	00 00		 cmp	 DWORD PTR [eax+3268], 0
  00065	7f 05		 jg	 SHORT $LN2@DieProcDev

; 1393 : 		return;

  00067	e9 97 01 00 00	 jmp	 $LN1@DieProcDev
$LN2@DieProcDev:

; 1394 : 
; 1395 : 	PMSG_ANS_EVENTUSERSCORE pMsg;	
; 1396 : 	
; 1397 : 	pMsg.h.c		= PMHC_BYTE;

  0006c	c6 85 d0 fe ff
	ff c1		 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 1398 : 	pMsg.h.headcode	= 0x01;

  00073	c6 85 d2 fe ff
	ff 01		 mov	 BYTE PTR _pMsg$[ebp+2], 1

; 1399 : 	pMsg.h.size		= sizeof( pMsg );

  0007a	c6 85 d1 fe ff
	ff 28		 mov	 BYTE PTR _pMsg$[ebp+1], 40 ; 00000028H

; 1400 : 	
; 1401 : 	pMsg.SquareNum = lpObj->m_bDevilSquareIndex;

  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	0f b6 88 d0 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3280]
  0008b	89 8d f4 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+36], ecx

; 1402 : 	pMsg.Class = lpObj->Class;

  00091	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00094	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0009b	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+32], ecx

; 1403 : 	
; 1404 : 	if( lpObj->Class == 1 )

  000a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a4	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000ab	83 f9 01	 cmp	 ecx, 1
  000ae	0f 85 95 00 00
	00		 jne	 $LN3@DieProcDev

; 1405 : 	{	// 가중치 적용
; 1406 : 		if( 
; 1407 : #ifdef DEVILSQUARE_EXTEND_20050221
; 1408 : 			lpObj->Class >= 0 && lpObj->Class < 5 && 
; 1409 : 			CHECK_DEVILSQUARE_INDEX(lpObj->m_bDevilSquareIndex) && lpObj->m_stateEngagePVP != PVP_USER_PLAYING
; 1410 : #else
; 1411 : 			lpObj->Class >= 0 && lpObj->Class < 4 && 
; 1412 : 			lpObj->m_bDevilSquareIndex >= 0 && lpObj->m_bDevilSquareIndex < 4 && lpObj->m_stateEngagePVP != PVP_USER_PLAYING

  000b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b7	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000be	85 c9		 test	 ecx, ecx
  000c0	7c 76		 jl	 SHORT $LN5@DieProcDev
  000c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c5	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000cc	83 f9 04	 cmp	 ecx, 4
  000cf	7d 67		 jge	 SHORT $LN5@DieProcDev
  000d1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d4	0f b6 88 d0 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3280]
  000db	85 c9		 test	 ecx, ecx
  000dd	7c 59		 jl	 SHORT $LN5@DieProcDev
  000df	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e2	0f b6 88 d0 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3280]
  000e9	83 f9 04	 cmp	 ecx, 4
  000ec	7d 4a		 jge	 SHORT $LN5@DieProcDev
  000ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f1	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  000f8	74 3e		 je	 SHORT $LN5@DieProcDev

; 1413 : #endif
; 1414 : 			)
; 1415 : 		{
; 1416 : 			lpObj->m_nEventScore += m_BonusScoreTable[lpObj->Class][lpObj->m_bDevilSquareIndex]/100;

  000fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fd	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00104	c1 e1 04	 shl	 ecx, 4
  00107	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0010a	8d 84 0a b0 0f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4016]
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00114	0f b6 91 d0 0c
	00 00		 movzx	 edx, BYTE PTR [ecx+3280]
  0011b	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  0011e	99		 cdq
  0011f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00124	f7 f9		 idiv	 ecx
  00126	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00129	03 82 c4 0c 00
	00		 add	 eax, DWORD PTR [edx+3268]
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00132	89 81 c4 0c 00
	00		 mov	 DWORD PTR [ecx+3268], eax
$LN5@DieProcDev:

; 1417 : 		}
; 1418 : 		pMsg.Score = lpObj->m_nEventScore;

  00138	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013b	8b 88 c4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3268]
  00141	89 8d ec fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+28], ecx

; 1419 : 	}

  00147	eb 0f		 jmp	 SHORT $LN4@DieProcDev
$LN3@DieProcDev:

; 1420 : 	else
; 1421 : 	{
; 1422 : 		pMsg.Score	= lpObj->m_nEventScore;

  00149	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014c	8b 88 c4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3268]
  00152	89 8d ec fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+28], ecx
$LN4@DieProcDev:

; 1423 : 	}
; 1424 : 
; 1425 : 	pMsg.ServerCode=gGameServerCode;

  00158	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0015f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 1426 : 	memcpy(pMsg.AccountID, lpObj->AccountID, MAX_IDSTRING);

  00165	6a 0a		 push	 10			; 0000000aH
  00167	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016a	83 c0 68	 add	 eax, 104		; 00000068H
  0016d	50		 push	 eax
  0016e	8d 8d d3 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 _memcpy
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1427 : 	memcpy(pMsg.GameID,    lpObj->Name, MAX_IDSTRING);

  0017d	6a 0a		 push	 10			; 0000000aH
  0017f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00182	83 c0 73	 add	 eax, 115		; 00000073H
  00185	50		 push	 eax
  00186	8d 8d dd fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+13]
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 _memcpy
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1428 : 
; 1429 : 	DataSendRank((char*)&pMsg, pMsg.h.size);

  00195	0f b6 85 d1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0019c	50		 push	 eax
  0019d	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 ?DataSendRank@@YAXPADH@Z ; DataSendRank
  001a9	83 c4 08	 add	 esp, 8

; 1430 : //	gUdpSocCRank.SendData((LPBYTE)&pMsg, pMsg.h.size);
; 1431 : 	LogAddTD("[DevilSquare] Dead [%s][%s][%d][%d]", lpObj->AccountID, lpObj->Name, lpObj->m_nEventExp, lpObj->m_nEventScore);

  001ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001af	8b 88 c4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3268]
  001b5	51		 push	 ecx
  001b6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001b9	8b 82 c8 0c 00
	00		 mov	 eax, DWORD PTR [edx+3272]
  001bf	50		 push	 eax
  001c0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c3	83 c1 73	 add	 ecx, 115		; 00000073H
  001c6	51		 push	 ecx
  001c7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001ca	83 c2 68	 add	 edx, 104		; 00000068H
  001cd	52		 push	 edx
  001ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KOGNJHLF@?$FLDevilSquare?$FN?5Dead?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN@
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001d9	83 c4 14	 add	 esp, 20			; 00000014H

; 1432 : 
; 1433 : 	lpObj->m_nEventScore = 0;

  001dc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001df	c7 80 c4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3268], 0

; 1434 : 	lpObj->m_nEventMoney = 0;

  001e9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ec	c7 80 cc 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3276], 0

; 1435 : 	lpObj->m_nEventExp = 0;	

  001f6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f9	c7 80 c8 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3272], 0
$LN1@DieProcDev:

; 1436 : }

  00203	5f		 pop	 edi
  00204	5e		 pop	 esi
  00205	5b		 pop	 ebx
  00206	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00209	33 cd		 xor	 ecx, ebp
  0020b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c2 04 00	 ret	 4
?DieProcDevilSquare@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CDevilSquare::DieProcDevilSquare
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_monstertype$ = -12					; size = 2
_devilsquareindex$ = -5					; size = 1
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CDevilSquare::gDevilSquareMonsterRegen, COMDAT
; _this$ = ecx

; 1302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1303 : 	BYTE devilsquareindex = lpObj->m_bDevilSquareIndex;	

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	8a 88 d0 0c 00
	00		 mov	 cl, BYTE PTR [eax+3280]
  00015	88 4d fb	 mov	 BYTE PTR _devilsquareindex$[ebp], cl

; 1304 : 	if( devilsquareindex < 0 || devilsquareindex >= MAX_DEVILSQUARE )

  00018	0f b6 45 fb	 movzx	 eax, BYTE PTR _devilsquareindex$[ebp]
  0001c	85 c0		 test	 eax, eax
  0001e	7c 09		 jl	 SHORT $LN6@gDevilSqua
  00020	0f b6 45 fb	 movzx	 eax, BYTE PTR _devilsquareindex$[ebp]
  00024	83 f8 04	 cmp	 eax, 4
  00027	7c 18		 jl	 SHORT $LN5@gDevilSqua
$LN6@gDevilSqua:

; 1305 : 	{		
; 1306 : 		LogAddTD("[DevilSquare] Invalid DevilSquareIndex [%d]", devilsquareindex);

  00029	0f b6 45 fb	 movzx	 eax, BYTE PTR _devilsquareindex$[ebp]
  0002d	50		 push	 eax
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@CCIHNOCP@?$FLDevilSquare?$FN?5Invalid?5DevilSqua@
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00039	83 c4 08	 add	 esp, 8

; 1307 : 		return;

  0003c	e9 2e 01 00 00	 jmp	 $LN1@gDevilSqua
$LN5@gDevilSqua:

; 1308 : 	}
; 1309 : 
; 1310 : 	if( lpObj->m_PosNum == -1 )

  00041	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00044	0f bf 88 0c 02
	00 00		 movsx	 ecx, WORD PTR [eax+524]
  0004b	83 f9 ff	 cmp	 ecx, -1
  0004e	75 13		 jne	 SHORT $LN7@gDevilSqua

; 1311 : 	{	// 보스 몬스터는 한번죽으면 다시 리젠되지 않는다
; 1312 : 		gObjDel(lpObj->m_Index);

  00050	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0005b	83 c4 04	 add	 esp, 4

; 1313 : 		return;

  0005e	e9 0c 01 00 00	 jmp	 $LN1@gDevilSqua
$LN7@gDevilSqua:

; 1314 : 	}
; 1315 : 
; 1316 : #ifdef ENHANCE_MONSTER_TYPE_TO_WORD_20040618
; 1317 : 	WORD monstertype = m_DevilSquareGround[devilsquareindex].GetMonsterType(m_iPlaytime-m_iRemainTime);

  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  0006c	2b 51 0c	 sub	 edx, DWORD PTR [ecx+12]
  0006f	52		 push	 edx
  00070	0f b6 45 fb	 movzx	 eax, BYTE PTR _devilsquareindex$[ebp]
  00074	69 c8 e0 03 00
	00		 imul	 ecx, eax, 992
  0007a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	8d 4c 0a 30	 lea	 ecx, DWORD PTR [edx+ecx+48]
  00081	e8 00 00 00 00	 call	 ?GetMonsterType@CDevilSquareGround@@QAEGH@Z ; CDevilSquareGround::GetMonsterType
  00086	66 89 45 f4	 mov	 WORD PTR _monstertype$[ebp], ax

; 1318 : #else
; 1319 : 	BYTE monstertype = m_DevilSquareGround[devilsquareindex].GetMonsterType(m_iPlaytime-m_iRemainTime);
; 1320 : #endif
; 1321 : 	if( monstertype == 0xff )

  0008a	0f b7 45 f4	 movzx	 eax, WORD PTR _monstertype$[ebp]
  0008e	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00093	75 18		 jne	 SHORT $LN8@gDevilSqua

; 1322 : 	{		
; 1323 : 		LogAddTD("[DevilSquare] [%d] Invalid MonterType", monstertype);

  00095	0f b7 45 f4	 movzx	 eax, WORD PTR _monstertype$[ebp]
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Mont@
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a5	83 c4 08	 add	 esp, 8

; 1324 : 		return;

  000a8	e9 c2 00 00 00	 jmp	 $LN1@gDevilSqua
$LN8@gDevilSqua:

; 1325 : 	}	
; 1326 : 	
; 1327 : 	for( int n=0; n<MAX_MAGIC; n++)

  000ad	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  000b4	eb 09		 jmp	 SHORT $LN4@gDevilSqua
$LN2@gDevilSqua:
  000b6	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  000b9	83 c0 01	 add	 eax, 1
  000bc	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gDevilSqua:
  000bf	83 7d f0 3c	 cmp	 DWORD PTR _n$1[ebp], 60	; 0000003cH
  000c3	7d 16		 jge	 SHORT $LN3@gDevilSqua

; 1328 : 	{
; 1329 : 		lpObj->Magic[n].Clear();		

  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _n$1[ebp]
  000c8	c1 e1 04	 shl	 ecx, 4
  000cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ce	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  000d4	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear

; 1330 : 	}

  000d9	eb db		 jmp	 SHORT $LN2@gDevilSqua
$LN3@gDevilSqua:

; 1331 : 	
; 1332 : 	gObjSetMonster(lpObj->m_Index, monstertype);

  000db	0f b7 45 f4	 movzx	 eax, WORD PTR _monstertype$[ebp]
  000df	50		 push	 eax
  000e0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  000eb	83 c4 08	 add	 esp, 8

; 1333 : 	lpObj->DieRegen	= 0;

  000ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f1	c6 80 fe 01 00
	00 00		 mov	 BYTE PTR [eax+510], 0

; 1334 : 	gObjMonsterRegen(lpObj);

  000f8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterRegen
  00101	83 c4 04	 add	 esp, 4

; 1335 : 	CreateFrustrum(lpObj->X,lpObj->Y, lpObj->m_Index);

  00104	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00107	8b 08		 mov	 ecx, DWORD PTR [eax]
  00109	51		 push	 ecx
  0010a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0010d	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  00114	50		 push	 eax
  00115	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00118	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1336 : 
; 1337 : 	lpObj->m_bDevilSquareIndex = devilsquareindex;	

  00128	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012b	8a 4d fb	 mov	 cl, BYTE PTR _devilsquareindex$[ebp]
  0012e	88 88 d0 0c 00
	00		 mov	 BYTE PTR [eax+3280], cl

; 1338 : 	lpObj->MaxRegenTime = 1000;	

  00134	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00137	c7 80 08 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+520], 1000 ; 000003e8H

; 1339 : 	
; 1340 : 	LogAddTD("[DevilSquare] Monter Regen [%d][%d][%d,%d]", monstertype, devilsquareindex, lpObj->X,lpObj->Y);

  00141	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00144	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0014b	51		 push	 ecx
  0014c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0014f	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00156	50		 push	 eax
  00157	0f b6 4d fb	 movzx	 ecx, BYTE PTR _devilsquareindex$[ebp]
  0015b	51		 push	 ecx
  0015c	0f b7 55 f4	 movzx	 edx, WORD PTR _monstertype$[ebp]
  00160	52		 push	 edx
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@GIDNIGIL@?$FLDevilSquare?$FN?5Monter?5Regen?5?$FL?$CFd?$FN@
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0016c	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@gDevilSqua:

; 1341 : }

  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	5b		 pop	 ebx
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c2 04 00	 ret	 4
?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CDevilSquare::gDevilSquareMonsterRegen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?ClearMonstr@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_this$ = -4						; size = 4
?ClearMonstr@CDevilSquare@@QAEXXZ PROC			; CDevilSquare::ClearMonstr, COMDAT
; _this$ = ecx

; 1287 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1288 : 	for( int n=0; n<MAX_MONSTER; n++)

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@ClearMonst
$LN2@ClearMonst:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@ClearMonst:
  0001e	81 7d f8 a8 16
	00 00		 cmp	 DWORD PTR _n$1[ebp], 5800 ; 000016a8H
  00025	7d 28		 jge	 SHORT $LN1@ClearMonst

; 1289 : 	{
; 1290 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 1291 : 		if( CHECK_DEVILSQUARE(gObj[n].MapNumber) )
; 1292 : #else
; 1293 : 		if( gObj[n].MapNumber == 9 )

  00027	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0003c	83 fa 09	 cmp	 edx, 9
  0003f	75 0c		 jne	 SHORT $LN5@ClearMonst

; 1294 : #endif
; 1295 : 		{
; 1296 : 			gObjDel(n);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0004a	83 c4 04	 add	 esp, 4
$LN5@ClearMonst:

; 1297 : 		}
; 1298 : 	}

  0004d	eb c6		 jmp	 SHORT $LN2@ClearMonst
$LN1@ClearMonst:

; 1299 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?ClearMonstr@CDevilSquare@@QAEXXZ ENDP			; CDevilSquare::ClearMonstr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?SetMonster@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
_devilSquareIndex$1 = -17				; size = 1
_monstertype$2 = -16					; size = 2
_n$3 = -12						; size = 4
_result$ = -8						; size = 4
_this$ = -4						; size = 4
?SetMonster@CDevilSquare@@QAEXXZ PROC			; CDevilSquare::SetMonster, COMDAT
; _this$ = ecx

; 1209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1210 : 	int result;	
; 1211 : 	for( int n=0; n<gMSetBase.m_Count; n++)

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$3[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@SetMonster
$LN2@SetMonster:
  00015	8b 45 f4	 mov	 eax, DWORD PTR _n$3[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f4	 mov	 DWORD PTR _n$3[ebp], eax
$LN4@SetMonster:
  0001e	8b 45 f4	 mov	 eax, DWORD PTR _n$3[ebp]
  00021	3b 05 e4 0f 01
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+69604
  00027	0f 8d 15 01 00
	00		 jge	 $LN1@SetMonster

; 1212 : 	{
; 1213 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 1214 : 		if( CHECK_DEVILSQUARE(gMSetBase.m_Mp[n].m_MapNumber) )
; 1215 : #else
; 1216 : 		if( gMSetBase.m_Mp[n].m_MapNumber == 9 )

  0002d	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$3[ebp], 12
  00031	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  00038	83 f9 09	 cmp	 ecx, 9
  0003b	0f 85 fc 00 00
	00		 jne	 $LN5@SetMonster

; 1217 : #endif
; 1218 : 		{
; 1219 : #ifdef ENHANCE_MONSTER_TYPE_TO_WORD_20040618
; 1220 : 			WORD monstertype = gMSetBase.m_Mp[n].m_Type;

  00041	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$3[ebp], 12
  00045	66 8b 88 06 00
	00 00		 mov	 cx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  0004c	66 89 4d f0	 mov	 WORD PTR _monstertype$2[ebp], cx

; 1221 : #else
; 1222 : 			BYTE monstertype = gMSetBase.m_Mp[n].m_Type;
; 1223 : #endif
; 1224 : 
; 1225 : 			gMSetBase.m_Mp[n].m_X;
; 1226 : 			gMSetBase.m_Mp[n].m_Y;
; 1227 : 
; 1228 : 			BYTE devilSquareIndex = 0xff;

  00050	c6 45 ef ff	 mov	 BYTE PTR _devilSquareIndex$1[ebp], 255 ; 000000ffH

; 1229 : 
; 1230 : 			if( gMSetBase.m_Mp[n].m_X == 119 )

  00054	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$3[ebp], 12
  00058	0f b6 88 0a 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10]
  0005f	83 f9 77	 cmp	 ecx, 119		; 00000077H
  00062	75 06		 jne	 SHORT $LN6@SetMonster

; 1231 : 			{
; 1232 : 				devilSquareIndex = 0;

  00064	c6 45 ef 00	 mov	 BYTE PTR _devilSquareIndex$1[ebp], 0

; 1233 : 			}

  00068	eb 40		 jmp	 SHORT $LN7@SetMonster
$LN6@SetMonster:

; 1234 : 			else if( gMSetBase.m_Mp[n].m_X == 121 )

  0006a	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$3[ebp], 12
  0006e	0f b6 88 0a 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10]
  00075	83 f9 79	 cmp	 ecx, 121		; 00000079H
  00078	75 06		 jne	 SHORT $LN8@SetMonster

; 1235 : 			{
; 1236 : 				devilSquareIndex = 1;

  0007a	c6 45 ef 01	 mov	 BYTE PTR _devilSquareIndex$1[ebp], 1

; 1237 : 			}

  0007e	eb 2a		 jmp	 SHORT $LN7@SetMonster
$LN8@SetMonster:

; 1238 : 			else if( gMSetBase.m_Mp[n].m_X == 49 )

  00080	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$3[ebp], 12
  00084	0f b6 88 0a 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10]
  0008b	83 f9 31	 cmp	 ecx, 49			; 00000031H
  0008e	75 06		 jne	 SHORT $LN10@SetMonster

; 1239 : 			{
; 1240 : 				devilSquareIndex = 2;

  00090	c6 45 ef 02	 mov	 BYTE PTR _devilSquareIndex$1[ebp], 2

; 1241 : 			}

  00094	eb 14		 jmp	 SHORT $LN7@SetMonster
$LN10@SetMonster:

; 1242 : 			else if( gMSetBase.m_Mp[n].m_X == 53 )

  00096	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$3[ebp], 12
  0009a	0f b6 88 0a 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10]
  000a1	83 f9 35	 cmp	 ecx, 53			; 00000035H
  000a4	75 04		 jne	 SHORT $LN7@SetMonster

; 1243 : 			{
; 1244 : 				devilSquareIndex = 3;

  000a6	c6 45 ef 03	 mov	 BYTE PTR _devilSquareIndex$1[ebp], 3
$LN7@SetMonster:

; 1245 : 			}
; 1246 : #ifdef DEVILSQUARE_EXTEND_20050221		// 광장 일반몬스터 배치 (시작 X 중요)
; 1247 : 			else if( gMSetBase.m_Mp[n].m_X == 120 )
; 1248 : 			{
; 1249 : 				devilSquareIndex = 4;
; 1250 : 			}
; 1251 : 			else if( gMSetBase.m_Mp[n].m_X == 122 )
; 1252 : 			{
; 1253 : 				devilSquareIndex = 5;
; 1254 : 			}
; 1255 : #endif
; 1256 : #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010	// 광장7 일반몬스터 배치
; 1257 : 			else if( gMSetBase.m_Mp[n].m_X == 50 )
; 1258 : 			{
; 1259 : 				devilSquareIndex = 6;
; 1260 : 			}
; 1261 : #endif
; 1262 : 
; 1263 : 			if( devilSquareIndex == 0xff )

  000aa	0f b6 45 ef	 movzx	 eax, BYTE PTR _devilSquareIndex$1[ebp]
  000ae	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000b3	75 18		 jne	 SHORT $LN13@SetMonster

; 1264 : 			{	// 악마의 광장에 들어가는 몬스터가 아니다				
; 1265 : 				LogAddTD("[DevilSquare] [%d] Invalid MonterType", monstertype);

  000b5	0f b7 45 f0	 movzx	 eax, WORD PTR _monstertype$2[ebp]
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BJLCICGN@?$FLDevilSquare?$FN?5?$FL?$CFd?$FN?5Invalid?5Mont@
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c5	83 c4 08	 add	 esp, 8

; 1266 : 				continue;

  000c8	e9 48 ff ff ff	 jmp	 $LN2@SetMonster
$LN13@SetMonster:

; 1267 : 			}
; 1268 : 
; 1269 : #ifdef MAP_SERVER_ADD_MONSTER_20041216		// 맵서버 관련 몬스터, NPC 추가 (서버가 가지고 있는 맵만 추가가 가능하다.)
; 1270 : 			result = gObjAddMonster(gMSetBase.m_Mp[n].m_MapNumber);

  000cd	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$3[ebp], 12
  000d1	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  000de	83 c4 04	 add	 esp, 4
  000e1	0f bf d0	 movsx	 edx, ax
  000e4	89 55 f8	 mov	 DWORD PTR _result$[ebp], edx

; 1271 : #else
; 1272 : 			result = gObjAdd();
; 1273 : #endif
; 1274 : 			if( result >= 0 )

  000e7	83 7d f8 00	 cmp	 DWORD PTR _result$[ebp], 0
  000eb	7c 50		 jl	 SHORT $LN5@SetMonster

; 1275 : 			{
; 1276 : 				gObjSetPosMonster(result, n);

  000ed	8b 45 f4	 mov	 eax, DWORD PTR _n$3[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _result$[ebp]
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  000fa	83 c4 08	 add	 esp, 8

; 1277 : 				gObjSetMonster(result, monstertype);

  000fd	0f b7 45 f0	 movzx	 eax, WORD PTR _monstertype$2[ebp]
  00101	50		 push	 eax
  00102	8b 4d f8	 mov	 ecx, DWORD PTR _result$[ebp]
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  0010b	83 c4 08	 add	 esp, 8

; 1278 : 
; 1279 : 				gObj[result].MaxRegenTime = 1000;

  0010e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00115	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011b	c7 84 01 08 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [ecx+eax+520], 1000 ; 000003e8H

; 1280 : 				gObj[result].m_bDevilSquareIndex = devilSquareIndex;

  00126	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00133	8a 55 ef	 mov	 dl, BYTE PTR _devilSquareIndex$1[ebp]
  00136	88 94 01 d0 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3280], dl
$LN5@SetMonster:

; 1281 : 			}
; 1282 : 		}
; 1283 : 	}

  0013d	e9 d3 fe ff ff	 jmp	 $LN2@SetMonster
$LN1@SetMonster:

; 1284 : }

  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
?SetMonster@CDevilSquare@@QAEXXZ ENDP			; CDevilSquare::SetMonster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?Run@CDevilSquare@@QAEHXZ
_TEXT	SEGMENT
tv68 = -76						; size = 4
_count$ = -8						; size = 4
_this$ = -4						; size = 4
?Run@CDevilSquare@@QAEHXZ PROC				; CDevilSquare::Run, COMDAT
; _this$ = ecx

; 594  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 595  : 	int count = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN2@Run:

; 596  : 	while(!m_bQuit)

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0001a	75 6d		 jne	 SHORT $LN3@Run

; 597  : 	{
; 598  : 		if( gDevilSquareEvent )

  0001c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDevilSquareEvent@@3HA, 0 ; gDevilSquareEvent
  00023	74 39		 je	 SHORT $LN6@Run

; 599  : 		{
; 600  : 			switch(m_eState)

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002b	89 4d b4	 mov	 DWORD PTR tv68[ebp], ecx
  0002e	83 7d b4 00	 cmp	 DWORD PTR tv68[ebp], 0
  00032	74 0e		 je	 SHORT $LN7@Run
  00034	83 7d b4 01	 cmp	 DWORD PTR tv68[ebp], 1
  00038	74 12		 je	 SHORT $LN8@Run
  0003a	83 7d b4 02	 cmp	 DWORD PTR tv68[ebp], 2
  0003e	74 16		 je	 SHORT $LN9@Run
  00040	eb 1c		 jmp	 SHORT $LN6@Run
$LN7@Run:

; 601  : 			{
; 602  : 				case DevilSquare_CLOSE:
; 603  : 					{
; 604  : 						ProcClose();

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?ProcClose@CDevilSquare@@AAEXXZ ; CDevilSquare::ProcClose

; 605  : 					}
; 606  : 				break;

  0004a	eb 12		 jmp	 SHORT $LN6@Run
$LN8@Run:

; 607  : 
; 608  : 				case DevilSquare_OPEN:
; 609  : 					{
; 610  : 						ProcOpen();

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?ProcOpen@CDevilSquare@@AAEXXZ ; CDevilSquare::ProcOpen

; 611  : 					}
; 612  : 				break;

  00054	eb 08		 jmp	 SHORT $LN6@Run
$LN9@Run:

; 613  : 
; 614  : 				case DevilSquare_PLAYING:
; 615  : 					{
; 616  : 						ProcPlaying();

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?ProcPlaying@CDevilSquare@@AAEXXZ ; CDevilSquare::ProcPlaying
$LN6@Run:

; 617  : 					}
; 618  : 				break;
; 619  : 			}		
; 620  : 		}
; 621  : 		Sleep(100);

  0005e	6a 64		 push	 100			; 00000064H
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 622  : 
; 623  : 		count++;

  00066	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00069	83 c0 01	 add	 eax, 1
  0006c	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 624  : 		if( count > 10*60 )

  0006f	81 7d f8 58 02
	00 00		 cmp	 DWORD PTR _count$[ebp], 600 ; 00000258H
  00076	7e 0f		 jle	 SHORT $LN10@Run

; 625  : 		{
; 626  : #ifdef DELETE_DEVILSQURE_MESSAGE_TO_RANKINGSERVER_20070223
; 627  : 			SendLiveCall();

  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?SendLiveCall@CDevilSquare@@AAEXXZ ; CDevilSquare::SendLiveCall

; 628  : #endif
; 629  : 			count = 0;

  00080	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN10@Run:

; 630  : 
; 631  : #ifdef AUTH_GAMESERVER_CHECKKEY
; 632  : 	if( szAuthKey[12] != AUTH_CHECK_12 )
; 633  : 		DestroyGIocp();
; 634  : #endif
; 635  : 
; 636  : 		}
; 637  : 	}

  00087	eb 8a		 jmp	 SHORT $LN2@Run
$LN3@Run:

; 638  : 
; 639  : 	return TRUE;

  00089	b8 01 00 00 00	 mov	 eax, 1

; 640  : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?Run@CDevilSquare@@QAEHXZ ENDP				; CDevilSquare::Run
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z
_TEXT	SEGMENT
tv66 = -72						; size = 4
_this$ = -4						; size = 4
_eState$ = 8						; size = 4
?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z PROC ; CDevilSquare::SetState, COMDAT
; _this$ = ecx

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 374  : 	m_eState = eState;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _eState$[ebp]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 375  : 
; 376  : 	switch(m_eState)

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	89 4d b8	 mov	 DWORD PTR tv66[ebp], ecx
  0001e	83 7d b8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00022	74 0e		 je	 SHORT $LN4@SetState
  00024	83 7d b8 01	 cmp	 DWORD PTR tv66[ebp], 1
  00028	74 12		 je	 SHORT $LN5@SetState
  0002a	83 7d b8 02	 cmp	 DWORD PTR tv66[ebp], 2
  0002e	74 16		 je	 SHORT $LN6@SetState
  00030	eb 1c		 jmp	 SHORT $LN1@SetState
$LN4@SetState:

; 377  : 	{
; 378  : 		case DevilSquare_CLOSE:
; 379  : 			{
; 380  : 				SetClose();

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?SetClose@CDevilSquare@@QAEXXZ ; CDevilSquare::SetClose

; 381  : 			}
; 382  : 		break;

  0003a	eb 12		 jmp	 SHORT $LN1@SetState
$LN5@SetState:

; 383  : 
; 384  : 		case DevilSquare_OPEN:
; 385  : 			{
; 386  : 				SetOpen();

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?SetOpen@CDevilSquare@@AAEXXZ ; CDevilSquare::SetOpen

; 387  : 			}
; 388  : 		break;

  00044	eb 08		 jmp	 SHORT $LN1@SetState
$LN6@SetState:

; 389  : 
; 390  : 		case DevilSquare_PLAYING:
; 391  : 			{
; 392  : 				SetPlaying();

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?SetPlaying@CDevilSquare@@AAEXXZ ; CDevilSquare::SetPlaying
$LN1@SetState:

; 393  : 			}
; 394  : 		break;
; 395  : 	}
; 396  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ENDP ; CDevilSquare::SetState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?Init@CDevilSquare@@QAEXXZ
_TEXT	SEGMENT
_dwThreadId$ = -8					; size = 4
_this$ = -4						; size = 4
?Init@CDevilSquare@@QAEXXZ PROC				; CDevilSquare::Init, COMDAT
; _this$ = ecx

; 219  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 	m_bQuit = TRUE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 221  : 	Sleep(500);

  00016	68 f4 01 00 00	 push	 500			; 000001f4H
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 222  : 	SetState(DevilSquare_CLOSE);

  00021	6a 00		 push	 0
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?SetState@CDevilSquare@@QAEXW4eDevilSquareState@@@Z ; CDevilSquare::SetState

; 223  : 
; 224  : 	m_bQuit = FALSE;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 225  : 
; 226  : 	UINT	dwThreadId;	
; 227  : 	m_hThread = _beginthreadex(NULL, NULL, DevilSquareThreadFunc, this, NULL, &dwThreadId);

  00035	8d 45 f8	 lea	 eax, DWORD PTR _dwThreadId$[ebp]
  00038	50		 push	 eax
  00039	6a 00		 push	 0
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	51		 push	 ecx
  0003f	68 00 00 00 00	 push	 OFFSET ?DevilSquareThreadFunc@@YGIPAX@Z ; DevilSquareThreadFunc
  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	e8 00 00 00 00	 call	 __beginthreadex
  0004d	83 c4 18	 add	 esp, 24			; 00000018H
  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 228  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?Init@CDevilSquare@@QAEXXZ ENDP				; CDevilSquare::Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ??1CDevilSquare@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CDevilSquare@@UAE@XZ PROC				; CDevilSquare::~CDevilSquare, COMDAT
; _this$ = ecx

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CDevilSquare@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDevilSquare@@6B@

; 215  : 	m_bQuit = TRUE;

  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 216  : }

  0003e	68 00 00 00 00	 push	 OFFSET ??1CDevilSquareGround@@UAE@XZ ; CDevilSquareGround::~CDevilSquareGround
  00043	6a 04		 push	 4
  00045	68 e0 03 00 00	 push	 992			; 000003e0H
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 30	 add	 eax, 48			; 00000030H
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
  0006c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CDevilSquare@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CDevilSquare@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CDevilSquare@@UAE@XZ ENDP				; CDevilSquare::~CDevilSquare
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ??0CDevilSquare@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CDevilSquare@@QAE@XZ PROC				; CDevilSquare::CDevilSquare, COMDAT
; _this$ = ecx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDevilSquare@@6B@
  00015	68 00 00 00 00	 push	 OFFSET ??1CDevilSquareGround@@UAE@XZ ; CDevilSquareGround::~CDevilSquareGround
  0001a	68 00 00 00 00	 push	 OFFSET ??0CDevilSquareGround@@QAE@XZ ; CDevilSquareGround::CDevilSquareGround
  0001f	6a 04		 push	 4
  00021	68 e0 03 00 00	 push	 992			; 000003e0H
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 c0 30	 add	 eax, 48			; 00000030H
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z

; 152  : 	m_bQuit = FALSE;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 153  : 	m_iCloseTime = 2;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c7 40 24 02 00
	00 00		 mov	 DWORD PTR [eax+36], 2

; 154  : 	m_iOpenTime = 2;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	c7 40 28 02 00
	00 00		 mov	 DWORD PTR [eax+40], 2

; 155  : 	m_iPlaytime = 10;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	c7 40 2c 0a 00
	00 00		 mov	 DWORD PTR [eax+44], 10	; 0000000aH

; 156  : 
; 157  : 	m_BonusScoreTable[CLASS_WIZARD][0] = 0;

  0005a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0005f	6b c8 00	 imul	 ecx, eax, 0
  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8d 84 0a b0 0f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4016]
  0006c	b9 04 00 00 00	 mov	 ecx, 4
  00071	6b d1 00	 imul	 edx, ecx, 0
  00074	c7 04 10 00 00
	00 00		 mov	 DWORD PTR [eax+edx], 0

; 158  : 	m_BonusScoreTable[CLASS_WIZARD][1] = 0;

  0007b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00080	6b c8 00	 imul	 ecx, eax, 0
  00083	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00086	8d 84 0a b0 0f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4016]
  0008d	b9 04 00 00 00	 mov	 ecx, 4
  00092	c1 e1 00	 shl	 ecx, 0
  00095	c7 04 08 00 00
	00 00		 mov	 DWORD PTR [eax+ecx], 0

; 159  : 	m_BonusScoreTable[CLASS_WIZARD][2] = 0;

  0009c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000a1	6b c8 00	 imul	 ecx, eax, 0
  000a4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a7	8d 84 0a b0 0f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4016]
  000ae	b9 04 00 00 00	 mov	 ecx, 4
  000b3	d1 e1		 shl	 ecx, 1
  000b5	c7 04 08 00 00
	00 00		 mov	 DWORD PTR [eax+ecx], 0

; 160  : 	m_BonusScoreTable[CLASS_WIZARD][3] = 170;

  000bc	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000c1	6b c8 00	 imul	 ecx, eax, 0
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8d 84 0a b0 0f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4016]
  000ce	b9 04 00 00 00	 mov	 ecx, 4
  000d3	6b d1 03	 imul	 edx, ecx, 3
  000d6	c7 04 10 aa 00
	00 00		 mov	 DWORD PTR [eax+edx], 170 ; 000000aaH

; 161  : 
; 162  : 	m_BonusScoreTable[CLASS_KNIGHT][0] = 20;

  000dd	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000e2	c1 e0 00	 shl	 eax, 0
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	8d 94 01 b0 0f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+4016]
  000ef	b8 04 00 00 00	 mov	 eax, 4
  000f4	6b c8 00	 imul	 ecx, eax, 0
  000f7	c7 04 0a 14 00
	00 00		 mov	 DWORD PTR [edx+ecx], 20	; 00000014H

; 163  : 	m_BonusScoreTable[CLASS_KNIGHT][1] = 90;

  000fe	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00103	c1 e0 00	 shl	 eax, 0
  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	8d 94 01 b0 0f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+4016]
  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	c1 e0 00	 shl	 eax, 0
  00118	c7 04 02 5a 00
	00 00		 mov	 DWORD PTR [edx+eax], 90	; 0000005aH

; 164  : 	m_BonusScoreTable[CLASS_KNIGHT][2] = 120;

  0011f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00124	c1 e0 00	 shl	 eax, 0
  00127	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	8d 94 01 b0 0f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+4016]
  00131	b8 04 00 00 00	 mov	 eax, 4
  00136	d1 e0		 shl	 eax, 1
  00138	c7 04 02 78 00
	00 00		 mov	 DWORD PTR [edx+eax], 120 ; 00000078H

; 165  : 	m_BonusScoreTable[CLASS_KNIGHT][3] = 400;

  0013f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00144	c1 e0 00	 shl	 eax, 0
  00147	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	8d 94 01 b0 0f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+4016]
  00151	b8 04 00 00 00	 mov	 eax, 4
  00156	6b c8 03	 imul	 ecx, eax, 3
  00159	c7 04 0a 90 01
	00 00		 mov	 DWORD PTR [edx+ecx], 400 ; 00000190H

; 166  : 
; 167  : 	m_BonusScoreTable[CLASS_ELF][0] = 10;

  00160	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00165	d1 e0		 shl	 eax, 1
  00167	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	8d 94 01 b0 0f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+4016]
  00171	b8 04 00 00 00	 mov	 eax, 4
  00176	6b c8 00	 imul	 ecx, eax, 0
  00179	c7 04 0a 0a 00
	00 00		 mov	 DWORD PTR [edx+ecx], 10	; 0000000aH

; 168  : 	m_BonusScoreTable[CLASS_ELF][1] = 10;

  00180	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00185	d1 e0		 shl	 eax, 1
  00187	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	8d 94 01 b0 0f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+4016]
  00191	b8 04 00 00 00	 mov	 eax, 4
  00196	c1 e0 00	 shl	 eax, 0
  00199	c7 04 02 0a 00
	00 00		 mov	 DWORD PTR [edx+eax], 10	; 0000000aH

; 169  : 	m_BonusScoreTable[CLASS_ELF][2] = 10;

  001a0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001a5	d1 e0		 shl	 eax, 1
  001a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001aa	8d 94 01 b0 0f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+4016]
  001b1	b8 04 00 00 00	 mov	 eax, 4
  001b6	d1 e0		 shl	 eax, 1
  001b8	c7 04 02 0a 00
	00 00		 mov	 DWORD PTR [edx+eax], 10	; 0000000aH

; 170  : 	m_BonusScoreTable[CLASS_ELF][3] = 200;

  001bf	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001c4	d1 e0		 shl	 eax, 1
  001c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c9	8d 94 01 b0 0f
	00 00		 lea	 edx, DWORD PTR [ecx+eax+4016]
  001d0	b8 04 00 00 00	 mov	 eax, 4
  001d5	6b c8 03	 imul	 ecx, eax, 3
  001d8	c7 04 0a c8 00
	00 00		 mov	 DWORD PTR [edx+ecx], 200 ; 000000c8H

; 171  : 
; 172  : 	m_BonusScoreTable[CLASS_MAGUMSA][0] = 0;

  001df	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001e4	6b c8 03	 imul	 ecx, eax, 3
  001e7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001ea	8d 84 0a b0 0f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4016]
  001f1	b9 04 00 00 00	 mov	 ecx, 4
  001f6	6b d1 00	 imul	 edx, ecx, 0
  001f9	c7 04 10 00 00
	00 00		 mov	 DWORD PTR [eax+edx], 0

; 173  : 	m_BonusScoreTable[CLASS_MAGUMSA][1] = 0;

  00200	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00205	6b c8 03	 imul	 ecx, eax, 3
  00208	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0020b	8d 84 0a b0 0f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4016]
  00212	b9 04 00 00 00	 mov	 ecx, 4
  00217	c1 e1 00	 shl	 ecx, 0
  0021a	c7 04 08 00 00
	00 00		 mov	 DWORD PTR [eax+ecx], 0

; 174  : 	m_BonusScoreTable[CLASS_MAGUMSA][2] = 0;

  00221	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00226	6b c8 03	 imul	 ecx, eax, 3
  00229	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0022c	8d 84 0a b0 0f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4016]
  00233	b9 04 00 00 00	 mov	 ecx, 4
  00238	d1 e1		 shl	 ecx, 1
  0023a	c7 04 08 00 00
	00 00		 mov	 DWORD PTR [eax+ecx], 0

; 175  : 	m_BonusScoreTable[CLASS_MAGUMSA][3] = 0;

  00241	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00246	6b c8 03	 imul	 ecx, eax, 3
  00249	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0024c	8d 84 0a b0 0f
	00 00		 lea	 eax, DWORD PTR [edx+ecx+4016]
  00253	b9 04 00 00 00	 mov	 ecx, 4
  00258	6b d1 03	 imul	 edx, ecx, 3
  0025b	c7 04 10 00 00
	00 00		 mov	 DWORD PTR [eax+edx], 0

; 176  : 
; 177  : #ifdef DEVILSQUARE_EXTEND_20050221	// 추가 보너스 테이블 추가 (5,6광장 + 다크로드)
; 178  : 	m_BonusScoreTable[CLASS_WIZARD][4] = 170;
; 179  : 	m_BonusScoreTable[CLASS_WIZARD][5] = 170;
; 180  : 
; 181  : 	m_BonusScoreTable[CLASS_KNIGHT][4] = 400;
; 182  : 	m_BonusScoreTable[CLASS_KNIGHT][5] = 400;
; 183  : 
; 184  : 	m_BonusScoreTable[CLASS_ELF][4] = 200;
; 185  : 	m_BonusScoreTable[CLASS_ELF][5] = 200;
; 186  : 
; 187  : 	m_BonusScoreTable[CLASS_MAGUMSA][4] = 0;
; 188  : 	m_BonusScoreTable[CLASS_MAGUMSA][5] = 0;
; 189  : 
; 190  : 	m_BonusScoreTable[CLASS_DARKLORD][0] = 0;
; 191  : 	m_BonusScoreTable[CLASS_DARKLORD][1] = 0;
; 192  : 	m_BonusScoreTable[CLASS_DARKLORD][2] = 0;
; 193  : 	m_BonusScoreTable[CLASS_DARKLORD][3] = 0;
; 194  : 	m_BonusScoreTable[CLASS_DARKLORD][4] = 0;
; 195  : 	m_BonusScoreTable[CLASS_DARKLORD][5] = 0;
; 196  : #endif
; 197  : 
; 198  : #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010	// 추가 보너스 테이블
; 199  : 	m_BonusScoreTable[CLASS_WIZARD][6]		= 170;
; 200  : 	m_BonusScoreTable[CLASS_KNIGHT][6]		= 400;
; 201  : 	m_BonusScoreTable[CLASS_ELF][6]			= 200;
; 202  : 	m_BonusScoreTable[CLASS_MAGUMSA][6]		= 0;
; 203  : 	m_BonusScoreTable[CLASS_DARKLORD][6]	= 0;
; 204  : #endif
; 205  : 	
; 206  : #ifdef UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 207  : 	for( int i=0; i<MAX_DEVILSQUARE; ++i )
; 208  : 		m_fRewardExpRate[i] = 1.0f;
; 209  : #endif //UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 210  : 
; 211  : }

  00262	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	5b		 pop	 ebx
  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c3		 ret	 0
??0CDevilSquare@@QAE@XZ ENDP				; CDevilSquare::CDevilSquare
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 535  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 536  :             return _time64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __time64
  00012	83 c4 04	 add	 esp, 4

; 537  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 509  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 510  :             #pragma warning(push)
; 511  :             #pragma warning(disable: 4996)
; 512  :             return _localtime64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __localtime64
  00012	83 c4 04	 add	 esp, 4

; 513  :             #pragma warning(pop)
; 514  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
