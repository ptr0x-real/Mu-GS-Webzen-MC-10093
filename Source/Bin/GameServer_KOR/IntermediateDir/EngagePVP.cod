; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0CEngagePVP@@QAE@XZ				; CEngagePVP::CEngagePVP
PUBLIC	??1CEngagePVP@@QAE@XZ				; CEngagePVP::~CEngagePVP
PUBLIC	?Load@CEngagePVP@@QAEXPBD@Z			; CEngagePVP::Load
PUBLIC	?Run@CEngagePVP@@QAEXXZ				; CEngagePVP::Run
PUBLIC	?ProcessUserRequest@CEngagePVP@@QAEXPAVOBJECTSTRUCT@@@Z ; CEngagePVP::ProcessUserRequest
PUBLIC	?DeleteUser@CEngagePVP@@QAEXH@Z			; CEngagePVP::DeleteUser
PUBLIC	?Clear@CEngagePVP@@AAEXXZ			; CEngagePVP::Clear
PUBLIC	?ClearUser@CEngagePVP@@AAEXH@Z			; CEngagePVP::ClearUser
PUBLIC	?ProcessClosed@CEngagePVP@@AAEXXZ		; CEngagePVP::ProcessClosed
PUBLIC	?ProcessRunning@CEngagePVP@@AAEXXZ		; CEngagePVP::ProcessRunning
PUBLIC	?ProcessFinish@CEngagePVP@@AAEXXZ		; CEngagePVP::ProcessFinish
PUBLIC	??0?$allocator@U?$_List_node@HPAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<int,void *> >::allocator<std::_List_node<int,void *> >
PUBLIC	?deallocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEXQAU?$_List_node@HPAX@2@I@Z ; std::allocator<std::_List_node<int,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z ; std::allocator<std::_List_node<int,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@2@QAU?$_List_node@HPAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@HPAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::max_size
PUBLIC	??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
PUBLIC	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
PUBLIC	?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
PUBLIC	?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
PUBLIC	?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@PAU?$_List_node@HPAX@2@@Z ; std::list<int,std::allocator<int> >::_Make_iter
PUBLIC	?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ	; std::list<int,std::allocator<int> >::size
PUBLIC	?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::max_size
PUBLIC	?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::push_back
PUBLIC	?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ; std::list<int,std::allocator<int> >::erase
PUBLIC	?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ	; std::list<int,std::allocator<int> >::clear
PUBLIC	?_Tidy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ	; std::list<int,std::allocator<int> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ ; std::list<int,std::allocator<int> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$list@HV?$allocator@H@std@@@std@@ABEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@H@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<int> >::_List_val<std::_List_simple_types<int> >
PUBLIC	?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXPAU?$_List_node@HPAX@2@@Z ; std::_List_val<std::_List_simple_types<int> >::_Orphan_ptr2
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<int> >::_Orphan_non_end
PUBLIC	?_Unlinknode@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEPAU?$_List_node@HPAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<int> >::_Unlinknode
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first
PUBLIC	??0?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::allocator<std::_List_node<REWARD_ITEM,void *> >
PUBLIC	?deallocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEXQAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@QAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::max_size
PUBLIC	??0?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >
PUBLIC	??1?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::~list<REWARD_ITEM,std::allocator<REWARD_ITEM> >
PUBLIC	?begin@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::begin
PUBLIC	?end@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::end
PUBLIC	?max_size@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QBEIXZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::max_size
PUBLIC	?push_back@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXABUREWARD_ITEM@@@Z ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::push_back
PUBLIC	?clear@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXXZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::clear
PUBLIC	?_Tidy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal
PUBLIC	?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<REWARD_ITEM> >::_List_val<std::_List_simple_types<REWARD_ITEM> >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<REWARD_ITEM> >::_Orphan_non_end
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Get_first
PUBLIC	??0?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<EVENT_TIME,void *> >::allocator<std::_List_node<EVENT_TIME,void *> >
PUBLIC	?deallocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEXQAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ; std::allocator<std::_List_node<EVENT_TIME,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ; std::allocator<std::_List_node<EVENT_TIME,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@QAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::max_size
PUBLIC	??0?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::list<EVENT_TIME,std::allocator<EVENT_TIME> >
PUBLIC	??1?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::~list<EVENT_TIME,std::allocator<EVENT_TIME> >
PUBLIC	?begin@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::begin
PUBLIC	?end@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::end
PUBLIC	?max_size@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QBEIXZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::max_size
PUBLIC	?push_back@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXABUEVENT_TIME@@@Z ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::push_back
PUBLIC	?clear@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXXZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::clear
PUBLIC	?_Tidy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal
PUBLIC	?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<EVENT_TIME> >::_List_val<std::_List_simple_types<EVENT_TIME> >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<EVENT_TIME> >::_Orphan_non_end
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Get_first
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEABHXZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_iterator<std::_List_val<std::_List_simple_types<int> > >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> >,std::_Iterator_base0>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEABUEVENT_TIME@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator*
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator++
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator!=
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEAAUEVENT_TIME@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator*
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator++
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> >,std::_Iterator_base0>
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEABUREWARD_ITEM@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator*
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator++
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator!=
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEAAUREWARD_ITEM@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator*
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator++
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ; std::_List_node<EVENT_TIME,void *>::_Free_non_head<std::allocator<std::_List_node<EVENT_TIME,void *> > >
PUBLIC	??$_Emplace@ABUEVENT_TIME@@@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@1@QAU21@ABUEVENT_TIME@@@Z ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Emplace<EVENT_TIME const &>
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<EVENT_TIME> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1><>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ; std::_List_node<REWARD_ITEM,void *>::_Free_non_head<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
PUBLIC	??$_Emplace@ABUREWARD_ITEM@@@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@1@QAU21@ABUREWARD_ITEM@@@Z ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Emplace<REWARD_ITEM const &>
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1><>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Free_non_head<std::allocator<std::_List_node<int,void *> > >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Freenode<std::allocator<std::_List_node<int,void *> > >
PUBLIC	??$_Emplace@ABH@?$list@HV?$allocator@H@std@@@std@@QAEPAU?$_List_node@HPAX@1@QAU21@ABH@Z ; std::list<int,std::allocator<int> >::_Emplace<int const &>
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<int> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1><>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ; std::_List_node<EVENT_TIME,void *>::_Freenode0<std::allocator<std::_List_node<EVENT_TIME,void *> > >
PUBLIC	??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ; std::_List_node<REWARD_ITEM,void *>::_Freenode0<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
PUBLIC	??$_Construct_in_place@PAU?$_List_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@0@Z ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Freenode0<std::allocator<std::_List_node<int,void *> > >
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@H@std@@@0@ABV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<int> > const >
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YAII@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Get_size_of_n@$0CA@@std@@YAII@Z		; std::_Get_size_of_n<32>
PUBLIC	??$_Get_size_of_n@$0M@@std@@YAII@Z		; std::_Get_size_of_n<12>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ; std::_List_node<EVENT_TIME,void *>::_Freenode<std::allocator<std::_List_node<EVENT_TIME,void *> > >
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Transfer_before
PUBLIC	??$forward@ABUEVENT_TIME@@@std@@YAABUEVENT_TIME@@ABU1@@Z ; std::forward<EVENT_TIME const &>
PUBLIC	??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > ><EVENT_TIME const &>
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ; std::_List_node<REWARD_ITEM,void *>::_Freenode<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Transfer_before
PUBLIC	??$forward@ABUREWARD_ITEM@@@std@@YAABUREWARD_ITEM@@ABU1@@Z ; std::forward<REWARD_ITEM const &>
PUBLIC	??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > ><REWARD_ITEM const &>
PUBLIC	??$addressof@H@std@@YAPAHAAH@Z			; std::addressof<int>
PUBLIC	??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<int>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEPAU?$_List_node@HPAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::_Transfer_before
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > ><int const &>
PUBLIC	??$addressof@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAPAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<EVENT_TIME,void *> *>
PUBLIC	??$forward@AAPAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAAAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<EVENT_TIME,void *> * &>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<EVENT_TIME,void *> *>
PUBLIC	??$addressof@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAPAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<REWARD_ITEM,void *> *>
PUBLIC	??$forward@AAPAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<REWARD_ITEM,void *> * &>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<REWARD_ITEM,void *> *>
PUBLIC	??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<int,void *> *>
PUBLIC	??$forward@AAPAU?$_List_node@HPAX@std@@@std@@YAAAPAU?$_List_node@HPAX@0@AAPAU10@@Z ; std::forward<std::_List_node<int,void *> * &>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@HPAX@std@@@std@@YAXAAPAU?$_List_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_List_node<int,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * const &>
PUBLIC	??$addressof@UREWARD_ITEM@@@std@@YAPAUREWARD_ITEM@@AAU1@@Z ; std::addressof<REWARD_ITEM>
PUBLIC	??$destroy@UREWARD_ITEM@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::destroy<REWARD_ITEM>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * const &>
PUBLIC	??$addressof@UEVENT_TIME@@@std@@YAPAUEVENT_TIME@@AAU1@@Z ; std::addressof<EVENT_TIME>
PUBLIC	??$destroy@UEVENT_TIME@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::destroy<EVENT_TIME>
PUBLIC	??$construct@UEVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::construct<EVENT_TIME,EVENT_TIME const &>
PUBLIC	??$construct@UREWARD_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::construct<REWARD_ITEM,REWARD_ITEM const &>
PUBLIC	??$construct@HABH@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<int,int const &>
PUBLIC	??$forward@ABQAU?$_List_node@HPAX@std@@@std@@YAABQAU?$_List_node@HPAX@0@ABQAU10@@Z ; std::forward<std::_List_node<int,void *> * const &>
PUBLIC	??$forward@ABQAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAABQAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z ; std::forward<std::_List_node<REWARD_ITEM,void *> * const &>
PUBLIC	??$forward@ABQAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAABQAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z ; std::forward<std::_List_node<EVENT_TIME,void *> * const &>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	?g_PvpEvent@@3VCEngagePVP@@A			; g_PvpEvent
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_0CE@DKMGGMNL@?$FLPVP?5Event?$FN?5Registrado?5en?5el?5ev@ ; `string'
PUBLIC	??_C@_0DB@KKDKFAML@?$FLPVP?5System?$FN?5?9?5File?5load?5error?5@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0CG@FELFEBKG@?$FLPVP?5System?$FN?5Info?5file?5Load?5Fai@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end@				; `string'
PUBLIC	__TI2PAD
PUBLIC	__CTA2PAD
PUBLIC	??_R0PAD@8					; char * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAD@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	??_C@_0BH@PDAGGAGG@Item?5type?5out?5of?5range@	; `string'
PUBLIC	??_C@_0BI@FJIGPCBB@Item?5index?5out?5of?5range@	; `string'
PUBLIC	??_C@_0BL@MNBPNGAL@?$FLPVP?5System?$FN?5?$CFs?5file?5load?$CB@ ; `string'
PUBLIC	??_C@_0BL@HDPCIDGI@?$FLPVP?5System?$FN?5Event?5Enabled@ ; `string'
PUBLIC	??_C@_0BM@OKBKMMIF@?$FLPVP?5System?$FN?5Event?5Disabled@ ; `string'
PUBLIC	??_C@_0DK@IJLLDIOM@?$FLPVP?5System?$FN?5?9?5Loading?5Exceptio@ ; `string'
PUBLIC	??_C@_0BF@BJNKEBMD@?4?4?2data?2PVPEvent?4cfg@	; `string'
PUBLIC	??_C@_0BJ@HNNMMGEC@?$FLPVP?5System?$FN?5Event?5Start@ ; `string'
PUBLIC	??_C@_0CN@FJOHLNMO@?$FLPVP?5Event?$FN?5Inicio?5el?5evento?$CB?5?9@ ; `string'
PUBLIC	??_C@_0CN@LEEAJCJL@?$FLPVP?5Event?$FN?5Faltan?5?$CFd?5minutos?5p@ ; `string'
PUBLIC	??_C@_0CO@CBGOEHLE@?$FLPVP?5Event?$FN?5Faltan?5?$CFd?5segundos?5@ ; `string'
PUBLIC	??_C@_0DH@NHBJFALI@?$FLPVP?5Event?$FN?5El?5ganador?5del?5even@ ; `string'
PUBLIC	??_C@_0BN@FFOEKPGN@?$FLPVP?5Event?$FN?5No?5hubo?5ganador?$CB@ ; `string'
PUBLIC	??_C@_0DD@OCPAALGN@?$FLPVP?5Event?$FN?5Se?5termino?5el?5tiemp@ ; `string'
PUBLIC	??_C@_0BO@BLGPGPMM@?$FLPVP?5Event?$FN?5quedan?5?$CFd?5minutos@ ; `string'
PUBLIC	??_C@_0BP@NIIDFAII@?$FLPVP?5Event?$FN?5quedan?5?$CFd?5segundos@ ; `string'
PUBLIC	??_C@_05KHGEPAAH@?1fire@			; `string'
PUBLIC	??_C@_0CP@OIEOHOKH@?$FLPVP?5Event?$FN?5La?5arena?5se?5cerrara@ ; `string'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	__real@00000000
PUBLIC	__real@41f80000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_strcmp:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	__localtime64:PROC
EXTRN	__time64:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	??0TNotice@@QAE@E@Z:PROC			; TNotice::TNotice
EXTRN	?SendToUser@TNotice@@QAAXHPADZZ:PROC		; TNotice::SendToUser
EXTRN	?SendToAllUser@TNotice@@QAAXPADZZ:PROC		; TNotice::SendToAllUser
EXTRN	?ManagementProc@CGMMng@@QAEHPAVOBJECTSTRUCT@@PADH@Z:PROC ; CGMMng::ManagementProc
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z:PROC	; ItemSerialCreateSend
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?cManager@@3VCGMMng@@A:BYTE			; cManager
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_PvpEvent@@3VCEngagePVP@@A DB 078H DUP (?)		; g_PvpEvent
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT __real@41f80000
CONST	SEGMENT
__real@41f80000 DD 041f80000r			; 31
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OIEOHOKH@?$FLPVP?5Event?$FN?5La?5arena?5se?5cerrara@
CONST	SEGMENT
??_C@_0CP@OIEOHOKH@?$FLPVP?5Event?$FN?5La?5arena?5se?5cerrara@ DB '[PVP E'
	DB	'vent] La arena se cerrara en %d segundos', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KHGEPAAH@?1fire@
CONST	SEGMENT
??_C@_05KHGEPAAH@?1fire@ DB '/fire', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NIIDFAII@?$FLPVP?5Event?$FN?5quedan?5?$CFd?5segundos@
CONST	SEGMENT
??_C@_0BP@NIIDFAII@?$FLPVP?5Event?$FN?5quedan?5?$CFd?5segundos@ DB '[PVP '
	DB	'Event] quedan %d segundos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BLGPGPMM@?$FLPVP?5Event?$FN?5quedan?5?$CFd?5minutos@
CONST	SEGMENT
??_C@_0BO@BLGPGPMM@?$FLPVP?5Event?$FN?5quedan?5?$CFd?5minutos@ DB '[PVP E'
	DB	'vent] quedan %d minutos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@OCPAALGN@?$FLPVP?5Event?$FN?5Se?5termino?5el?5tiemp@
CONST	SEGMENT
??_C@_0DD@OCPAALGN@?$FLPVP?5Event?$FN?5Se?5termino?5el?5tiemp@ DB '[PVP E'
	DB	'vent] Se termino el tiempo, no hubo ganador!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FFOEKPGN@?$FLPVP?5Event?$FN?5No?5hubo?5ganador?$CB@
CONST	SEGMENT
??_C@_0BN@FFOEKPGN@?$FLPVP?5Event?$FN?5No?5hubo?5ganador?$CB@ DB '[PVP Ev'
	DB	'ent] No hubo ganador!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NHBJFALI@?$FLPVP?5Event?$FN?5El?5ganador?5del?5even@
CONST	SEGMENT
??_C@_0DH@NHBJFALI@?$FLPVP?5Event?$FN?5El?5ganador?5del?5even@ DB '[PVP E'
	DB	'vent] El ganador del evento es %s - Felicidades!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CBGOEHLE@?$FLPVP?5Event?$FN?5Faltan?5?$CFd?5segundos?5@
CONST	SEGMENT
??_C@_0CO@CBGOEHLE@?$FLPVP?5Event?$FN?5Faltan?5?$CFd?5segundos?5@ DB '[PV'
	DB	'P Event] Faltan %d segundos para el inicio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LEEAJCJL@?$FLPVP?5Event?$FN?5Faltan?5?$CFd?5minutos?5p@
CONST	SEGMENT
??_C@_0CN@LEEAJCJL@?$FLPVP?5Event?$FN?5Faltan?5?$CFd?5minutos?5p@ DB '[PV'
	DB	'P Event] Faltan %d minutos para el inicio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FJOHLNMO@?$FLPVP?5Event?$FN?5Inicio?5el?5evento?$CB?5?9@
CONST	SEGMENT
??_C@_0CN@FJOHLNMO@?$FLPVP?5Event?$FN?5Inicio?5el?5evento?$CB?5?9@ DB '[P'
	DB	'VP Event] Inicio el evento! - %d jugadores', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HNNMMGEC@?$FLPVP?5System?$FN?5Event?5Start@
CONST	SEGMENT
??_C@_0BJ@HNNMMGEC@?$FLPVP?5System?$FN?5Event?5Start@ DB '[PVP System] Ev'
	DB	'ent Start', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BJNKEBMD@?4?4?2data?2PVPEvent?4cfg@
CONST	SEGMENT
??_C@_0BF@BJNKEBMD@?4?4?2data?2PVPEvent?4cfg@ DB '..\data\PVPEvent.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@IJLLDIOM@?$FLPVP?5System?$FN?5?9?5Loading?5Exceptio@
CONST	SEGMENT
??_C@_0DK@IJLLDIOM@?$FLPVP?5System?$FN?5?9?5Loading?5Exceptio@ DB '[PVP S'
	DB	'ystem] - Loading Exception Error (%s) - (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OKBKMMIF@?$FLPVP?5System?$FN?5Event?5Disabled@
CONST	SEGMENT
??_C@_0BM@OKBKMMIF@?$FLPVP?5System?$FN?5Event?5Disabled@ DB '[PVP System]'
	DB	' Event Disabled', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HDPCIDGI@?$FLPVP?5System?$FN?5Event?5Enabled@
CONST	SEGMENT
??_C@_0BL@HDPCIDGI@?$FLPVP?5System?$FN?5Event?5Enabled@ DB '[PVP System] '
	DB	'Event Enabled', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MNBPNGAL@?$FLPVP?5System?$FN?5?$CFs?5file?5load?$CB@
CONST	SEGMENT
??_C@_0BL@MNBPNGAL@?$FLPVP?5System?$FN?5?$CFs?5file?5load?$CB@ DB '[PVP S'
	DB	'ystem] %s file load!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FJIGPCBB@Item?5index?5out?5of?5range@
CONST	SEGMENT
??_C@_0BI@FJIGPCBB@Item?5index?5out?5of?5range@ DB 'Item index out of ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PDAGGAGG@Item?5type?5out?5of?5range@
CONST	SEGMENT
??_C@_0BH@PDAGGAGG@Item?5type?5out?5of?5range@ DB 'Item type out of range'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
data$r	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
data$r	ENDS
;	COMDAT __CT??_R0PAD@84
xdata$x	SEGMENT
__CT??_R0PAD@84 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAD@8
data$r	SEGMENT
??_R0PAD@8 DD	FLAT:??_7type_info@@6B@			; char * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAD', 00H
data$r	ENDS
;	COMDAT __CTA2PAD
xdata$x	SEGMENT
__CTA2PAD DD	02H
	DD	FLAT:__CT??_R0PAD@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI2PAD
xdata$x	SEGMENT
__TI2PAD DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAD
xdata$x	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end@
CONST	SEGMENT
??_C@_03JBJLGPFL@end@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FELFEBKG@?$FLPVP?5System?$FN?5Info?5file?5Load?5Fai@
CONST	SEGMENT
??_C@_0CG@FELFEBKG@?$FLPVP?5System?$FN?5Info?5file?5Load?5Fai@ DB '[PVP S'
	DB	'ystem] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KKDKFAML@?$FLPVP?5System?$FN?5?9?5File?5load?5error?5@
CONST	SEGMENT
??_C@_0DB@KKDKFAML@?$FLPVP?5System?$FN?5?9?5File?5load?5error?5@ DB '[PVP'
	DB	' System] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DKMGGMNL@?$FLPVP?5Event?$FN?5Registrado?5en?5el?5ev@
CONST	SEGMENT
??_C@_0CE@DKMGGMNL@?$FLPVP?5Event?$FN?5Registrado?5en?5el?5ev@ DB '[PVP E'
	DB	'vent] Registrado en el evento', 00H		; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z$0
__ehfuncinfo$??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z$0
__ehfuncinfo$??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z$0
__ehfuncinfo$??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?Load@CEngagePVP@@QAEXPBD@Z$2 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffb0H
	DD	FLAT:__catch$?Load@CEngagePVP@@QAEXPBD@Z$0
__unwindtable$?Load@CEngagePVP@@QAEXPBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Load@CEngagePVP@@QAEXPBD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?Load@CEngagePVP@@QAEXPBD@Z$2
__ehfuncinfo$?Load@CEngagePVP@@QAEXPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Load@CEngagePVP@@QAEXPBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Load@CEngagePVP@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CEngagePVP@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CEngagePVP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CEngagePVP@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CEngagePVP@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CEngagePVP@@QAE@XZ$2
__ehfuncinfo$??0CEngagePVP@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CEngagePVP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_PvpEvent$initializer$@@3P6AXXZA DD FLAT:??__Eg_PvpEvent@@YAXXZ ; g_PvpEvent$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABQAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAABQAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAABQAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_List_node<EVENT_TIME,void *> * const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABQAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAABQAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_List_node<EVENT_TIME,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABQAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAABQAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAABQAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_List_node<REWARD_ITEM,void *> * const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABQAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAABQAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_List_node<REWARD_ITEM,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABQAU?$_List_node@HPAX@std@@@std@@YAABQAU?$_List_node@HPAX@0@ABQAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAU?$_List_node@HPAX@std@@@std@@YAABQAU?$_List_node@HPAX@0@ABQAU10@@Z PROC ; std::forward<std::_List_node<int,void *> * const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABQAU?$_List_node@HPAX@std@@@std@@YAABQAU?$_List_node@HPAX@0@ABQAU10@@Z ENDP ; std::forward<std::_List_node<int,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAHABH@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAHABH@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<int,int const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 04		 push	 4
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 02		 mov	 DWORD PTR [edx], eax

; 695  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAHABH@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@UREWARD_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UREWARD_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::construct<REWARD_ITEM,REWARD_ITEM const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 18		 push	 24			; 00000018H
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABUREWARD_ITEM@@@std@@YAABUREWARD_ITEM@@ABU1@@Z ; std::forward<REWARD_ITEM const &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 0a		 mov	 DWORD PTR [edx], ecx
  0002d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00030	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00033	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00036	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00039	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003c	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0003f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00042	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00045	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00048	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 695  :     }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
??$construct@UREWARD_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::construct<REWARD_ITEM,REWARD_ITEM const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@UEVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UEVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::construct<EVENT_TIME,EVENT_TIME const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 08		 push	 8
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABUEVENT_TIME@@@std@@YAABUEVENT_TIME@@ABU1@@Z ; std::forward<EVENT_TIME const &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 10		 mov	 edx, DWORD PTR [eax]
  00028	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002b	8b 4d bc	 mov	 ecx, DWORD PTR $T1[ebp]
  0002e	89 11		 mov	 DWORD PTR [ecx], edx
  00030	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 695  :     }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$construct@UEVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::construct<EVENT_TIME,EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$destroy@UEVENT_TIME@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UEVENT_TIME@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::destroy<EVENT_TIME>, COMDAT

; 698  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 699  :         _Ptr->~_Uty();
; 700  :     }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$destroy@UEVENT_TIME@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::destroy<EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@UEVENT_TIME@@@std@@YAPAUEVENT_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UEVENT_TIME@@@std@@YAPAUEVENT_TIME@@AAU1@@Z PROC ; std::addressof<EVENT_TIME>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@UEVENT_TIME@@@std@@YAPAUEVENT_TIME@@AAU1@@Z ENDP ; std::addressof<EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAPAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<EVENT_TIME,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@ABQAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAABQAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z ; std::forward<std::_List_node<EVENT_TIME,void *> * const &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$destroy@UREWARD_ITEM@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UREWARD_ITEM@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::destroy<REWARD_ITEM>, COMDAT

; 698  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 699  :         _Ptr->~_Uty();
; 700  :     }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$destroy@UREWARD_ITEM@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::destroy<REWARD_ITEM>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@UREWARD_ITEM@@@std@@YAPAUREWARD_ITEM@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UREWARD_ITEM@@@std@@YAPAUREWARD_ITEM@@AAU1@@Z PROC ; std::addressof<REWARD_ITEM>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@UREWARD_ITEM@@@std@@YAPAUREWARD_ITEM@@AAU1@@Z ENDP ; std::addressof<REWARD_ITEM>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAPAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<REWARD_ITEM,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@ABQAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAABQAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z ; std::forward<std::_List_node<REWARD_ITEM,void *> * const &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<int,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@ABQAU?$_List_node@HPAX@std@@@std@@YAABQAU?$_List_node@HPAX@0@ABQAU10@@Z ; std::forward<std::_List_node<int,void *> * const &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@HPAX@std@@@std@@YAXAAPAU?$_List_node@HPAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@HPAX@std@@@std@@YAXAAPAU?$_List_node@HPAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<int,void *> *>, COMDAT

; 267  : void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 268  :     _Obj.~_Ty();
; 269  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@HPAX@std@@@std@@YAXAAPAU?$_List_node@HPAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@HPAX@std@@@std@@YAAAPAU?$_List_node@HPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@HPAX@std@@@std@@YAAAPAU?$_List_node@HPAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<int,void *> * &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAPAU?$_List_node@HPAX@std@@@std@@YAAAPAU?$_List_node@HPAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<int,void *> *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<REWARD_ITEM,void *> *>, COMDAT

; 267  : void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 268  :     _Obj.~_Ty();
; 269  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<REWARD_ITEM,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<REWARD_ITEM,void *> * &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAPAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<REWARD_ITEM,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAPAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAPAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<REWARD_ITEM,void *> *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAPAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<REWARD_ITEM,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<EVENT_TIME,void *> *>, COMDAT

; 267  : void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 268  :     _Obj.~_Ty();
; 269  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<EVENT_TIME,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAAAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAAAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<EVENT_TIME,void *> * &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAPAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAAAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<EVENT_TIME,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAPAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAPAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<EVENT_TIME,void *> *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAPAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<EVENT_TIME,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > ><int const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Allocate

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00046	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0004f	83 c4 04	 add	 esp, 4
  00052	50		 push	 eax
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00059	83 c2 08	 add	 edx, 8
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ??$addressof@H@std@@YAPAHAAH@Z ; std::addressof<int>
  00062	83 c4 04	 add	 esp, 4
  00065	50		 push	 eax
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<int,int const &>
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 588  :     }

  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > ><int const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEPAU?$_List_node@HPAX@2@QAU32@@Z
_TEXT	SEGMENT
__Result$ = -12						; size = 4
__Insert_after$ = -8					; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEPAU?$_List_node@HPAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	89 4d f8	 mov	 DWORD PTR __Insert_after$[ebp], ecx

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00015	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * const &>
  00025	83 c4 08	 add	 esp, 8

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00028	8d 45 f8	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	83 c2 04	 add	 edx, 4
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * const &>
  0003b	83 c4 08	 add	 esp, 8

; 603  :         const auto _Result    = this->_Ptr;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00044	89 4d f4	 mov	 DWORD PTR __Result$[ebp], ecx

; 604  :         this->_Ptr            = pointer{};

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00051	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp]
  00060	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00062	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEPAU?$_List_node@HPAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 21		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	83 c1 08	 add	 ecx, 8
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$addressof@H@std@@YAPAHAAH@Z ; std::addressof<int>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<int>
  00052	83 c4 08	 add	 esp, 8
$LN1@List_node_:

; 593  :         }
; 594  :     }

  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
  0006f	cc		 int	 3
  00070	cc		 int	 3
  00071	cc		 int	 3
  00072	cc		 int	 3
  00073	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >, COMDAT
; _this$ = ecx

; 1051 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         if (_Ptr) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 13		 je	 SHORT $LN3@Alloc_cons

; 1053 :             _Al.deallocate(_Ptr, 1);

  00034	6a 01		 push	 1
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	51		 push	 ecx
  0003d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEXQAU?$_List_node@HPAX@2@I@Z ; std::allocator<std::_List_node<int,void *> >::deallocate
$LN3@Alloc_cons:

; 1054 :         }
; 1055 :     }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1046 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1047 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1048 :         _Ptr = _Al.allocate(1);

  00016	6a 01		 push	 1
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z ; std::allocator<std::_List_node<int,void *> >::allocate
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1049 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >, COMDAT
; _this$ = ecx

; 1040 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<int>, COMDAT

; 698  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 699  :         _Ptr->~_Uty();
; 700  :     }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@H@std@@YAPAHAAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@H@std@@YAPAHAAH@Z PROC			; std::addressof<int>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@H@std@@YAPAHAAH@Z ENDP			; std::addressof<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > ><REWARD_ITEM const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Allocate

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00046	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$forward@ABUREWARD_ITEM@@@std@@YAABUREWARD_ITEM@@ABU1@@Z ; std::forward<REWARD_ITEM const &>
  0004f	83 c4 04	 add	 esp, 4
  00052	50		 push	 eax
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00059	83 c2 08	 add	 edx, 8
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ??$addressof@UREWARD_ITEM@@@std@@YAPAUREWARD_ITEM@@AAU1@@Z ; std::addressof<REWARD_ITEM>
  00062	83 c4 04	 add	 esp, 4
  00065	50		 push	 eax
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$construct@UREWARD_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::construct<REWARD_ITEM,REWARD_ITEM const &>
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 588  :     }

  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > ><REWARD_ITEM const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABUREWARD_ITEM@@@std@@YAABUREWARD_ITEM@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUREWARD_ITEM@@@std@@YAABUREWARD_ITEM@@ABU1@@Z PROC ; std::forward<REWARD_ITEM const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUREWARD_ITEM@@@std@@YAABUREWARD_ITEM@@ABU1@@Z ENDP ; std::forward<REWARD_ITEM const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Result$ = -12						; size = 4
__Insert_after$ = -8					; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	89 4d f8	 mov	 DWORD PTR __Insert_after$[ebp], ecx

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00015	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * const &>
  00025	83 c4 08	 add	 esp, 8

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00028	8d 45 f8	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	83 c2 04	 add	 edx, 4
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * const &>
  0003b	83 c4 08	 add	 esp, 8

; 603  :         const auto _Result    = this->_Ptr;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00044	89 4d f4	 mov	 DWORD PTR __Result$[ebp], ecx

; 604  :         this->_Ptr            = pointer{};

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00051	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp]
  00060	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00062	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 21		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	83 c1 08	 add	 ecx, 8
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$addressof@UREWARD_ITEM@@@std@@YAPAUREWARD_ITEM@@AAU1@@Z ; std::addressof<REWARD_ITEM>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ??$destroy@UREWARD_ITEM@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::destroy<REWARD_ITEM>
  00052	83 c4 08	 add	 esp, 8
$LN1@List_node_:

; 593  :         }
; 594  :     }

  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
  0006f	cc		 int	 3
  00070	cc		 int	 3
  00071	cc		 int	 3
  00072	cc		 int	 3
  00073	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >, COMDAT
; _this$ = ecx

; 1051 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         if (_Ptr) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 13		 je	 SHORT $LN3@Alloc_cons

; 1053 :             _Al.deallocate(_Ptr, 1);

  00034	6a 01		 push	 1
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	51		 push	 ecx
  0003d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEXQAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::deallocate
$LN3@Alloc_cons:

; 1054 :         }
; 1055 :     }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1046 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1047 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1048 :         _Ptr = _Al.allocate(1);

  00016	6a 01		 push	 1
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::allocate
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1049 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >, COMDAT
; _this$ = ecx

; 1040 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<REWARD_ITEM,void *>::_Freenode<std::allocator<std::_List_node<REWARD_ITEM,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	83 c0 08	 add	 eax, 8
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$addressof@UREWARD_ITEM@@@std@@YAPAUREWARD_ITEM@@AAU1@@Z ; std::addressof<REWARD_ITEM>
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$destroy@UREWARD_ITEM@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@QAUREWARD_ITEM@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::destroy<REWARD_ITEM>
  00041	83 c4 08	 add	 esp, 8

; 318  :         _Freenode0(_Al, _Ptr);

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00047	50		 push	 eax
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ; std::_List_node<REWARD_ITEM,void *>::_Freenode0<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
  00051	83 c4 08	 add	 esp, 8

; 319  :     }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<REWARD_ITEM,void *>::_Freenode<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > ><EVENT_TIME const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Allocate

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00046	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$forward@ABUEVENT_TIME@@@std@@YAABUEVENT_TIME@@ABU1@@Z ; std::forward<EVENT_TIME const &>
  0004f	83 c4 04	 add	 esp, 4
  00052	50		 push	 eax
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00059	83 c2 08	 add	 edx, 8
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ??$addressof@UEVENT_TIME@@@std@@YAPAUEVENT_TIME@@AAU1@@Z ; std::addressof<EVENT_TIME>
  00062	83 c4 04	 add	 esp, 4
  00065	50		 push	 eax
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$construct@UEVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::construct<EVENT_TIME,EVENT_TIME const &>
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 588  :     }

  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > ><EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABUEVENT_TIME@@@std@@YAABUEVENT_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUEVENT_TIME@@@std@@YAABUEVENT_TIME@@ABU1@@Z PROC ; std::forward<EVENT_TIME const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUEVENT_TIME@@@std@@YAABUEVENT_TIME@@ABU1@@Z ENDP ; std::forward<EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Result$ = -12						; size = 4
__Insert_after$ = -8					; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	89 4d f8	 mov	 DWORD PTR __Insert_after$[ebp], ecx

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00015	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * const &>
  00025	83 c4 08	 add	 esp, 8

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00028	8d 45 f8	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	83 c2 04	 add	 edx, 4
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * const &>
  0003b	83 c4 08	 add	 esp, 8

; 603  :         const auto _Result    = this->_Ptr;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00044	89 4d f4	 mov	 DWORD PTR __Result$[ebp], ecx

; 604  :         this->_Ptr            = pointer{};

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00051	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp]
  00060	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00062	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 21		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	83 c1 08	 add	 ecx, 8
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$addressof@UEVENT_TIME@@@std@@YAPAUEVENT_TIME@@AAU1@@Z ; std::addressof<EVENT_TIME>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ??$destroy@UEVENT_TIME@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::destroy<EVENT_TIME>
  00052	83 c4 08	 add	 esp, 8
$LN1@List_node_:

; 593  :         }
; 594  :     }

  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
  0006f	cc		 int	 3
  00070	cc		 int	 3
  00071	cc		 int	 3
  00072	cc		 int	 3
  00073	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >, COMDAT
; _this$ = ecx

; 1051 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         if (_Ptr) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 13		 je	 SHORT $LN3@Alloc_cons

; 1053 :             _Al.deallocate(_Ptr, 1);

  00034	6a 01		 push	 1
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	51		 push	 ecx
  0003d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEXQAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ; std::allocator<std::_List_node<EVENT_TIME,void *> >::deallocate
$LN3@Alloc_cons:

; 1054 :         }
; 1055 :     }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1046 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1047 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1048 :         _Ptr = _Al.allocate(1);

  00016	6a 01		 push	 1
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ; std::allocator<std::_List_node<EVENT_TIME,void *> >::allocate
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1049 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >, COMDAT
; _this$ = ecx

; 1040 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<EVENT_TIME,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<EVENT_TIME,void *>::_Freenode<std::allocator<std::_List_node<EVENT_TIME,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	83 c0 08	 add	 eax, 8
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$addressof@UEVENT_TIME@@@std@@YAPAUEVENT_TIME@@AAU1@@Z ; std::addressof<EVENT_TIME>
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$destroy@UEVENT_TIME@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@QAUEVENT_TIME@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::destroy<EVENT_TIME>
  00041	83 c4 08	 add	 esp, 8

; 318  :         _Freenode0(_Al, _Ptr);

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00047	50		 push	 eax
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ; std::_List_node<EVENT_TIME,void *>::_Freenode0<std::allocator<std::_List_node<EVENT_TIME,void *> > >
  00051	83 c4 08	 add	 esp, 8

; 319  :     }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<EVENT_TIME,void *>::_Freenode<std::allocator<std::_List_node<EVENT_TIME,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0M@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0M@@std@@YAII@Z PROC			; std::_Get_size_of_n<12>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 55 55
	55 15		 cmp	 DWORD PTR __Count$[ebp], 357913941 ; 15555555H
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	6b 45 08 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
$LN3@Get_size_o:

; 66   : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Get_size_of_n@$0M@@std@@YAII@Z ENDP			; std::_Get_size_of_n<12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CA@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0CA@@std@@YAII@Z PROC		; std::_Get_size_of_n<32>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 ff ff
	ff 07		 mov	 DWORD PTR __Max_possible$1[ebp], 134217727 ; 07ffffffH

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 ff ff
	ff 07		 cmp	 DWORD PTR __Count$[ebp], 134217727 ; 07ffffffH
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	c1 e0 05	 shl	 eax, 5
$LN3@Get_size_o:

; 66   : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$_Get_size_of_n@$0CA@@std@@YAII@Z ENDP		; std::_Get_size_of_n<32>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BA@@std@@YAII@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 ff ff
	ff 0f		 mov	 DWORD PTR __Max_possible$1[ebp], 268435455 ; 0fffffffH

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 ff ff
	ff 0f		 cmp	 DWORD PTR __Count$[ebp], 268435455 ; 0fffffffH
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	c1 e0 04	 shl	 eax, 4
$LN3@Get_size_o:

; 66   : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$_Get_size_of_n@$0BA@@std@@YAII@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@H@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@H@std@@@0@ABV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<int> > const >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@H@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<int> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<int,void *>::_Freenode0<std::allocator<std::_List_node<int,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@HPAX@std@@@std@@YAXAAPAU?$_List_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_List_node<int,void *> *>
  00031	83 c4 04	 add	 esp, 4

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@HPAX@std@@@std@@YAXAAPAU?$_List_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_List_node<int,void *> *>
  00040	83 c4 04	 add	 esp, 4

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

  00043	6a 01		 push	 1
  00045	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@2@QAU?$_List_node@HPAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::deallocate
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  :     }

  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<int,void *>::_Freenode0<std::allocator<std::_List_node<int,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@0@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<int,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@AAPAU?$_List_node@HPAX@std@@@std@@YAAAPAU?$_List_node@HPAX@0@AAPAU10@@Z ; std::forward<std::_List_node<int,void *> * &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<REWARD_ITEM,void *>::_Freenode0<std::allocator<std::_List_node<REWARD_ITEM,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<REWARD_ITEM,void *> *>
  00031	83 c4 04	 add	 esp, 4

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<REWARD_ITEM,void *> *>
  00040	83 c4 04	 add	 esp, 4

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

  00043	6a 01		 push	 1
  00045	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@QAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::deallocate
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  :     }

  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<REWARD_ITEM,void *>::_Freenode0<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAPAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<REWARD_ITEM,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@AAPAU?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@YAAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<REWARD_ITEM,void *> * &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<EVENT_TIME,void *>::_Freenode0<std::allocator<std::_List_node<EVENT_TIME,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<EVENT_TIME,void *> *>
  00031	83 c4 04	 add	 esp, 4

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<EVENT_TIME,void *> *>
  00040	83 c4 04	 add	 esp, 4

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

  00043	6a 01		 push	 1
  00045	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@QAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::deallocate
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  :     }

  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<EVENT_TIME,void *>::_Freenode0<std::allocator<std::_List_node<EVENT_TIME,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAPAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<EVENT_TIME,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@AAPAU?$_List_node@UEVENT_TIME@@PAX@std@@@std@@YAAAPAU?$_List_node@UEVENT_TIME@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<EVENT_TIME,void *> * &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$_List_node@HPAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<int,void *> >::allocator<std::_List_node<int,void *> >
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_val@U?$_List_simple_types@H@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<int> >::_List_val<std::_List_simple_types<int> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<int> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Emplace@ABH@?$list@HV?$allocator@H@std@@@std@@QAEPAU?$_List_node@HPAX@1@QAU21@ABH@Z
_TEXT	SEGMENT
tv82 = -92						; size = 4
tv80 = -88						; size = 4
$T1 = -84						; size = 4
__Op$ = -16						; size = 8
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABH@?$list@HV?$allocator@H@std@@@std@@QAEPAU?$_List_node@HPAX@1@QAU21@ABH@Z PROC ; std::list<int,std::allocator<int> >::_Emplace<int const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::max_size
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  00020	39 01		 cmp	 DWORD PTR [ecx], eax
  00022	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  00029	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1016 :         }
; 1017 : 
; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
  00036	89 45 a8	 mov	 DWORD PTR tv80[ebp], eax
  00039	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 a4	 mov	 DWORD PTR tv82[ebp], eax
  00048	8b 4d a4	 mov	 ecx, DWORD PTR tv82[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 a8	 mov	 edx, DWORD PTR tv80[ebp]
  0004f	52		 push	 edx
  00050	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  00053	e8 00 00 00 00	 call	 ??$?0ABH@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@ABH@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > ><int const &>

; 1019 :         ++_Mysize;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	83 c1 01	 add	 ecx, 1
  00060	8b 55 f8	 mov	 edx, DWORD PTR __Mysize$[ebp]
  00063	89 0a		 mov	 DWORD PTR [edx], ecx

; 1020 :         return _Op._Transfer_before(_Where);

  00065	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00068	50		 push	 eax
  00069	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEPAU?$_List_node@HPAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::_Transfer_before
  00071	89 45 ac	 mov	 DWORD PTR $T1[ebp], eax
  00074	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  00077	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<int,void *> > >
  0007c	8b 45 ac	 mov	 eax, DWORD PTR $T1[ebp]
$LN3@Emplace:

; 1021 :     }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
??$_Emplace@ABH@?$list@HV?$allocator@H@std@@@std@@QAEPAU?$_List_node@HPAX@1@QAU21@ABH@Z ENDP ; std::list<int,std::allocator<int> >::_Emplace<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<int,void *>::_Freenode<std::allocator<std::_List_node<int,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	83 c0 08	 add	 eax, 8
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$addressof@H@std@@YAPAHAAH@Z ; std::addressof<int>
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<int>
  00041	83 c4 08	 add	 esp, 8

; 318  :         _Freenode0(_Al, _Ptr);

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00047	50		 push	 eax
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Freenode0<std::allocator<std::_List_node<int,void *> > >
  00051	83 c4 08	 add	 esp, 8

; 319  :     }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<int,void *>::_Freenode<std::allocator<std::_List_node<int,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Pnext$1 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<int,void *>::_Free_non_head<std::allocator<std::_List_node<int,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 324  :         _Head->_Prev->_Next = nullptr;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0001d	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00022	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  00025	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00029	74 1a		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	89 4d f8	 mov	 DWORD PTR __Pnext$1[ebp], ecx

; 329  :             _Freenode(_Al, _Pnode);

  00033	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Freenode<std::allocator<std::_List_node<int,void *> > >
  00040	83 c4 08	 add	 esp, 8

; 330  :         }

  00043	eb da		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<int,void *>::_Free_non_head<std::allocator<std::_List_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::allocator<std::_List_node<REWARD_ITEM,void *> >
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<REWARD_ITEM> >::_List_val<std::_List_simple_types<REWARD_ITEM> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Emplace@ABUREWARD_ITEM@@@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@1@QAU21@ABUREWARD_ITEM@@@Z
_TEXT	SEGMENT
tv82 = -92						; size = 4
tv80 = -88						; size = 4
$T1 = -84						; size = 4
__Op$ = -16						; size = 8
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABUREWARD_ITEM@@@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@1@QAU21@ABUREWARD_ITEM@@@Z PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Emplace<REWARD_ITEM const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QBEIXZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::max_size
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  00020	39 01		 cmp	 DWORD PTR [ecx], eax
  00022	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  00029	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1016 :         }
; 1017 : 
; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal
  00036	89 45 a8	 mov	 DWORD PTR tv80[ebp], eax
  00039	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??$forward@ABUREWARD_ITEM@@@std@@YAABUREWARD_ITEM@@ABU1@@Z ; std::forward<REWARD_ITEM const &>
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 a4	 mov	 DWORD PTR tv82[ebp], eax
  00048	8b 4d a4	 mov	 ecx, DWORD PTR tv82[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 a8	 mov	 edx, DWORD PTR tv80[ebp]
  0004f	52		 push	 edx
  00050	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  00053	e8 00 00 00 00	 call	 ??$?0ABUREWARD_ITEM@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@ABUREWARD_ITEM@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > ><REWARD_ITEM const &>

; 1019 :         ++_Mysize;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	83 c1 01	 add	 ecx, 1
  00060	8b 55 f8	 mov	 edx, DWORD PTR __Mysize$[ebp]
  00063	89 0a		 mov	 DWORD PTR [edx], ecx

; 1020 :         return _Op._Transfer_before(_Where);

  00065	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00068	50		 push	 eax
  00069	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::_Transfer_before
  00071	89 45 ac	 mov	 DWORD PTR $T1[ebp], eax
  00074	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  00077	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
  0007c	8b 45 ac	 mov	 eax, DWORD PTR $T1[ebp]
$LN3@Emplace:

; 1021 :     }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
??$_Emplace@ABUREWARD_ITEM@@@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@1@QAU21@ABUREWARD_ITEM@@@Z ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Emplace<REWARD_ITEM const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Pnext$1 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<REWARD_ITEM,void *>::_Free_non_head<std::allocator<std::_List_node<REWARD_ITEM,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 324  :         _Head->_Prev->_Next = nullptr;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0001d	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00022	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  00025	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00029	74 1a		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	89 4d f8	 mov	 DWORD PTR __Pnext$1[ebp], ecx

; 329  :             _Freenode(_Al, _Pnode);

  00033	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ; std::_List_node<REWARD_ITEM,void *>::_Freenode<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
  00040	83 c4 08	 add	 esp, 8

; 330  :         }

  00043	eb da		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<REWARD_ITEM,void *>::_Free_non_head<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<EVENT_TIME,void *> >::allocator<std::_List_node<EVENT_TIME,void *> >
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<EVENT_TIME> >::_List_val<std::_List_simple_types<EVENT_TIME> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<EVENT_TIME> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Emplace@ABUEVENT_TIME@@@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@1@QAU21@ABUEVENT_TIME@@@Z
_TEXT	SEGMENT
tv82 = -92						; size = 4
tv80 = -88						; size = 4
$T1 = -84						; size = 4
__Op$ = -16						; size = 8
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABUEVENT_TIME@@@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@1@QAU21@ABUEVENT_TIME@@@Z PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Emplace<EVENT_TIME const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QBEIXZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::max_size
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  00020	39 01		 cmp	 DWORD PTR [ecx], eax
  00022	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  00029	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1016 :         }
; 1017 : 
; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal
  00036	89 45 a8	 mov	 DWORD PTR tv80[ebp], eax
  00039	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??$forward@ABUEVENT_TIME@@@std@@YAABUEVENT_TIME@@ABU1@@Z ; std::forward<EVENT_TIME const &>
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 a4	 mov	 DWORD PTR tv82[ebp], eax
  00048	8b 4d a4	 mov	 ecx, DWORD PTR tv82[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 a8	 mov	 edx, DWORD PTR tv80[ebp]
  0004f	52		 push	 edx
  00050	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  00053	e8 00 00 00 00	 call	 ??$?0ABUEVENT_TIME@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@ABUEVENT_TIME@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > ><EVENT_TIME const &>

; 1019 :         ++_Mysize;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	83 c1 01	 add	 ecx, 1
  00060	8b 55 f8	 mov	 edx, DWORD PTR __Mysize$[ebp]
  00063	89 0a		 mov	 DWORD PTR [edx], ecx

; 1020 :         return _Op._Transfer_before(_Where);

  00065	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00068	50		 push	 eax
  00069	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::_Transfer_before
  00071	89 45 ac	 mov	 DWORD PTR $T1[ebp], eax
  00074	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  00077	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<EVENT_TIME,void *> > >
  0007c	8b 45 ac	 mov	 eax, DWORD PTR $T1[ebp]
$LN3@Emplace:

; 1021 :     }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
??$_Emplace@ABUEVENT_TIME@@@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@1@QAU21@ABUEVENT_TIME@@@Z ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Emplace<EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Pnext$1 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<EVENT_TIME,void *>::_Free_non_head<std::allocator<std::_List_node<EVENT_TIME,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 324  :         _Head->_Prev->_Next = nullptr;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0001d	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00022	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  00025	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00029	74 1a		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	89 4d f8	 mov	 DWORD PTR __Pnext$1[ebp], ecx

; 329  :             _Freenode(_Al, _Pnode);

  00033	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ; std::_List_node<EVENT_TIME,void *>::_Freenode<std::allocator<std::_List_node<EVENT_TIME,void *> > >
  00040	83 c4 08	 add	 esp, 8

; 330  :         }

  00043	eb da		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<EVENT_TIME,void *>::_Free_non_head<std::allocator<std::_List_node<EVENT_TIME,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator++, COMDAT
; _this$ = ecx

; 246  :     _List_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 247  :         _Mybase::operator++();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator++

; 248  :         return *this;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 249  :     }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEAAUREWARD_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEAAUREWARD_ITEM@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator*, COMDAT
; _this$ = ecx

; 238  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEABUREWARD_ITEM@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator*

; 240  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEAAUREWARD_ITEM@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> >,std::_Iterator_base0>
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator!=, COMDAT
; _this$ = ecx

; 202  :     _NODISCARD bool operator!=(const _List_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 203  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 204  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv75 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator==, COMDAT
; _this$ = ecx

; 194  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 195  : #if _ITERATOR_DEBUG_LEVEL == 2
; 196  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         return this->_Ptr == _Right._Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00016	75 09		 jne	 SHORT $LN3@operator
  00018	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN4@operator:
  00028	8a 45 b8	 mov	 al, BYTE PTR tv75[ebp]

; 200  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator++, COMDAT
; _this$ = ecx

; 159  :     _List_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : #if _ITERATOR_DEBUG_LEVEL == 2
; 161  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 162  :         _STL_ASSERT(_Mycont, "cannot increment value-initialized list iterator");
; 163  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot increment end list iterator");
; 164  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 165  : 
; 166  :         this->_Ptr = this->_Ptr->_Next;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 01		 mov	 eax, DWORD PTR [ecx]
  00016	89 02		 mov	 DWORD PTR [edx], eax

; 167  :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 168  :     }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEABUREWARD_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEABUREWARD_ITEM@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator*, COMDAT
; _this$ = ecx

; 145  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : #if _ITERATOR_DEBUG_LEVEL == 2
; 147  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 148  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 149  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 150  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 151  : 
; 152  :         return this->_Ptr->_Myval;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	83 c0 08	 add	 eax, 8

; 153  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEABUREWARD_ITEM@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 41   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 246  :     _List_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 247  :         _Mybase::operator++();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator++

; 248  :         return *this;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 249  :     }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEAAUEVENT_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEAAUEVENT_TIME@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 238  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEABUEVENT_TIME@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator*

; 240  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEAAUEVENT_TIME@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> >,std::_Iterator_base0>
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 202  :     _NODISCARD bool operator!=(const _List_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 203  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 204  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv75 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 194  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 195  : #if _ITERATOR_DEBUG_LEVEL == 2
; 196  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         return this->_Ptr == _Right._Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00016	75 09		 jne	 SHORT $LN3@operator
  00018	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN4@operator:
  00028	8a 45 b8	 mov	 al, BYTE PTR tv75[ebp]

; 200  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 159  :     _List_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : #if _ITERATOR_DEBUG_LEVEL == 2
; 161  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 162  :         _STL_ASSERT(_Mycont, "cannot increment value-initialized list iterator");
; 163  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot increment end list iterator");
; 164  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 165  : 
; 166  :         this->_Ptr = this->_Ptr->_Next;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 01		 mov	 eax, DWORD PTR [ecx]
  00016	89 02		 mov	 DWORD PTR [edx], eax

; 167  :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 168  :     }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEABUEVENT_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEABUEVENT_TIME@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 145  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : #if _ITERATOR_DEBUG_LEVEL == 2
; 147  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 148  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 149  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 150  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 151  : 
; 152  :         return this->_Ptr->_Myval;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	83 c0 08	 add	 eax, 8

; 153  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEABUEVENT_TIME@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 41   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_iterator<std::_List_val<std::_List_simple_types<int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_iterator<std::_List_val<std::_List_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++, COMDAT
; _this$ = ecx

; 246  :     _List_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 247  :         _Mybase::operator++();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++

; 248  :         return *this;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 249  :     }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*, COMDAT
; _this$ = ecx

; 238  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEABHXZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*

; 240  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=, COMDAT
; _this$ = ecx

; 202  :     _NODISCARD bool operator!=(const _List_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 203  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 204  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv75 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator==, COMDAT
; _this$ = ecx

; 194  :     _NODISCARD bool operator==(const _List_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 195  : #if _ITERATOR_DEBUG_LEVEL == 2
; 196  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         return this->_Ptr == _Right._Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00016	75 09		 jne	 SHORT $LN3@operator
  00018	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN4@operator:
  00028	8a 45 b8	 mov	 al, BYTE PTR tv75[ebp]

; 200  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++, COMDAT
; _this$ = ecx

; 159  :     _List_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 160  : #if _ITERATOR_DEBUG_LEVEL == 2
; 161  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 162  :         _STL_ASSERT(_Mycont, "cannot increment value-initialized list iterator");
; 163  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot increment end list iterator");
; 164  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 165  : 
; 166  :         this->_Ptr = this->_Ptr->_Next;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 01		 mov	 eax, DWORD PTR [ecx]
  00016	89 02		 mov	 DWORD PTR [edx], eax

; 167  :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 168  :     }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEABHXZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*, COMDAT
; _this$ = ecx

; 145  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : #if _ITERATOR_DEBUG_LEVEL == 2
; 147  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 148  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 149  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 150  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 151  : 
; 152  :         return this->_Ptr->_Myval;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	83 c0 08	 add	 eax, 8

; 153  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEABHXZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 41   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fg_PvpEvent@@YAXXZ
text$yd	SEGMENT
??__Fg_PvpEvent@@YAXXZ PROC				; `dynamic atexit destructor for 'g_PvpEvent'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PvpEvent@@3VCEngagePVP@@A ; g_PvpEvent
  0000e	e8 00 00 00 00	 call	 ??1CEngagePVP@@QAE@XZ	; CEngagePVP::~CEngagePVP
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_PvpEvent@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_PvpEvent''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ??__Eg_PvpEvent@@YAXXZ
text$di	SEGMENT
??__Eg_PvpEvent@@YAXXZ PROC				; `dynamic initializer for 'g_PvpEvent'', COMDAT

; 23   : CEngagePVP g_PvpEvent;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PvpEvent@@3VCEngagePVP@@A ; g_PvpEvent
  0000e	e8 00 00 00 00	 call	 ??0CEngagePVP@@QAE@XZ	; CEngagePVP::CEngagePVP
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_PvpEvent@@YAXXZ ; `dynamic atexit destructor for 'g_PvpEvent''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_PvpEvent@@YAXXZ ENDP				; `dynamic initializer for 'g_PvpEvent''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1  - 

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1  - 

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2  - 

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2  - 

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3  - 

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3  - 

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4  - 

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4  - 

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5  - 

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5  - 

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6  - 

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6  - 

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\include\readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	83 c0 23	 add	 eax, 35			; 00000023H
  0000f	89 45 fc	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  00012	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00015	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00018	77 05		 ja	 SHORT $LN8@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  0001a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001f	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002e	83 7d f8 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00032	74 02		 je	 SHORT $LN7@Allocate_m
  00034	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00036	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0003b	33 c0		 xor	 eax, eax
  0003d	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  0003f	33 c0		 xor	 eax, eax
  00041	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00046	83 c0 23	 add	 eax, 35			; 00000023H
  00049	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0004c	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	6b c8 ff	 imul	 ecx, eax, -1
  00057	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00060	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00009	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00010	72 0e		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00012	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0001b	83 c4 04	 add	 esp, 4
  0001e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00020	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00024	74 0e		 je	 SHORT $LN3@Allocate

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002f	83 c4 04	 add	 esp, 4
  00032	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00034	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00028	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0002f	72 10		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00031	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  00034	50		 push	 eax
  00035	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0003e	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8

; 222  : }

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
$T1 = -68						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 67   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 68   :     // return smaller of _Left and _Right
; 69   :     return _Right < _Left ? _Right : _Left;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	73 08		 jae	 SHORT $LN3@min
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00018	89 45 b8	 mov	 DWORD PTR tv65[ebp], eax
  0001b	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00020	89 4d b8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00023	8b 55 b8	 mov	 edx, DWORD PTR tv65[ebp]
  00026	89 55 bc	 mov	 DWORD PTR $T1[ebp], edx
  00029	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]

; 70   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAEXXZ PROC ; std::_List_val<std::_List_simple_types<EVENT_TIME> >::_Orphan_non_end, COMDAT
; _this$ = ecx

; 377  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 378  : #if _ITERATOR_DEBUG_LEVEL == 2
; 379  :         _Lockit _Lock(_LOCK_DEBUG);
; 380  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 381  :         const auto _Head          = _Myhead;
; 382  :         while (*_Pnext) {
; 383  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 384  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 385  :                 _Pnext = _Pnextnext;
; 386  :             } else { // orphan the iterator
; 387  :                 (*_Pnext)->_Myproxy = nullptr;
; 388  :                 *_Pnext             = *_Pnextnext;
; 389  :             }
; 390  :         }
; 391  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 392  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAEXXZ ENDP ; std::_List_val<std::_List_simple_types<EVENT_TIME> >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<EVENT_TIME> >::_List_val<std::_List_simple_types<EVENT_TIME> >, COMDAT
; _this$ = ecx

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<EVENT_TIME> >::_List_val<std::_List_simple_types<EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal, COMDAT
; _this$ = ecx

; 1790 :     const _Alnode& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1791 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Get_first

; 1792 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal, COMDAT
; _this$ = ecx

; 1786 :     _Alnode& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Get_first

; 1788 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Newhead$ = -20					; size = 4
__Al$ = -16						; size = 4
__Proxy$ = -10						; size = 1
_$S23$ = -9						; size = 1
__Alproxy$ = -8						; size = 4
_this$ = -4						; size = 4
?_Alloc_sentinel_and_proxy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  0000c	8d 45 f7	 lea	 eax, DWORD PTR _$S23$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1773 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	50		 push	 eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  00019	51		 push	 ecx
  0001a	8d 4d f6	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1774 :         auto& _Al     = _Getal();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal
  0002a	89 45 f0	 mov	 DWORD PTR __Al$[ebp], eax

; 1775 :         auto _Newhead = _Al.allocate(1);

  0002d	6a 01		 push	 1
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ; std::allocator<std::_List_node<EVENT_TIME,void *> >::allocate
  00037	89 45 ec	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  0003a	8d 45 ec	 lea	 eax, DWORD PTR __Newhead$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * &>
  00047	83 c4 08	 add	 esp, 8

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0004a	8d 45 ec	 lea	 eax, DWORD PTR __Newhead$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00051	83 c1 04	 add	 ecx, 4
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UEVENT_TIME@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UEVENT_TIME@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<EVENT_TIME,void *> *,std::_List_node<EVENT_TIME,void *> * &>
  0005a	83 c4 08	 add	 esp, 8

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00063	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 :         _Proxy._Release();

  00065	8d 4d f6	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 1780 :     }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Tidy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__My_data$ = -12					; size = 4
__Al$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1437 :         auto& _Al      = _Getal();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal
  00014	89 45 f8	 mov	 DWORD PTR __Al$[ebp], eax

; 1438 :         auto& _My_data = _Mypair._Myval2;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00025	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	8b 55 f8	 mov	 edx, DWORD PTR __Al$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ; std::_List_node<EVENT_TIME,void *>::_Free_non_head<std::allocator<std::_List_node<EVENT_TIME,void *> > >
  00034	83 c4 08	 add	 esp, 8

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  00037	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	51		 push	 ecx
  0003d	8b 55 f8	 mov	 edx, DWORD PTR __Al$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ; std::_List_node<EVENT_TIME,void *>::_Freenode0<std::allocator<std::_List_node<EVENT_TIME,void *> > >
  00046	83 c4 08	 add	 esp, 8

; 1442 :     }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?_Tidy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?clear@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXXZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1428 :         _My_data._Orphan_non_end();

  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<EVENT_TIME> >::_Orphan_non_end

; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	51		 push	 ecx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@?$_List_node@UEVENT_TIME@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@1@PAU01@@Z ; std::_List_node<EVENT_TIME,void *>::_Free_non_head<std::allocator<std::_List_node<EVENT_TIME,void *> > >
  0002e	83 c4 08	 add	 esp, 8

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00031	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00039	8b 02		 mov	 eax, DWORD PTR [edx]
  0003b	89 01		 mov	 DWORD PTR [ecx], eax

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1432 :         _My_data._Mysize        = 0;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1433 :     }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?clear@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXXZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?push_back@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXABUEVENT_TIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXABUEVENT_TIME@@@Z PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::push_back, COMDAT
; _this$ = ecx

; 1251 :     void push_back(const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$_Emplace@ABUEVENT_TIME@@@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@1@QAU21@ABUEVENT_TIME@@@Z ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Emplace<EVENT_TIME const &>

; 1253 :     }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?push_back@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXABUEVENT_TIME@@@Z ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?max_size@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QBEIXZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::max_size, COMDAT
; _this$ = ecx

; 1194 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1195 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1196 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1197 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QBEIXZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?end@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::end, COMDAT
; _this$ = ecx

; 1099 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<EVENT_TIME> > >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	52		 push	 edx
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1101 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?end@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?begin@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::begin, COMDAT
; _this$ = ecx

; 1091 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<EVENT_TIME> > >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	8b 02		 mov	 eax, DWORD PTR [edx]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAE@PAU?$_List_node@UEVENT_TIME@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@1@@Z
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1093 :     }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?begin@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??1?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::~list<EVENT_TIME,std::allocator<EVENT_TIME> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::~list<EVENT_TIME,std::allocator<EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
??0?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::list<EVENT_TIME,std::allocator<EVENT_TIME> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T1[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1>::_Compressed_pair<std::allocator<std::_List_node<EVENT_TIME,void *> >,std::_List_val<std::_List_simple_types<EVENT_TIME> >,1><>

; 805  :         _Alloc_sentinel_and_proxy();

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@AAEXXZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::_Alloc_sentinel_and_proxy

; 806  :     }

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::list<EVENT_TIME,std::allocator<EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@QAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@QAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::deallocate, COMDAT

; 687  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 688  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 689  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	c1 e0 04	 shl	 eax, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00019	83 c4 08	 add	 esp, 8

; 690  :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@2@QAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<EVENT_TIME,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<EVENT_TIME,void *> >::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BA@@std@@YAII@Z ; std::_Get_size_of_n<16>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEPAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<EVENT_TIME,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEXQAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEXQAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<EVENT_TIME,void *> >::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	c1 e0 04	 shl	 eax, 4
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001c	83 c4 08	 add	 esp, 8

; 804  :     }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAEXQAU?$_List_node@UEVENT_TIME@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<EVENT_TIME,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<EVENT_TIME,void *> >::allocator<std::_List_node<EVENT_TIME,void *> >, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$_List_node@UEVENT_TIME@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<EVENT_TIME,void *> >::allocator<std::_List_node<EVENT_TIME,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAEXXZ PROC ; std::_List_val<std::_List_simple_types<REWARD_ITEM> >::_Orphan_non_end, COMDAT
; _this$ = ecx

; 377  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 378  : #if _ITERATOR_DEBUG_LEVEL == 2
; 379  :         _Lockit _Lock(_LOCK_DEBUG);
; 380  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 381  :         const auto _Head          = _Myhead;
; 382  :         while (*_Pnext) {
; 383  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 384  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 385  :                 _Pnext = _Pnextnext;
; 386  :             } else { // orphan the iterator
; 387  :                 (*_Pnext)->_Myproxy = nullptr;
; 388  :                 *_Pnext             = *_Pnextnext;
; 389  :             }
; 390  :         }
; 391  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 392  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAEXXZ ENDP ; std::_List_val<std::_List_simple_types<REWARD_ITEM> >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<REWARD_ITEM> >::_List_val<std::_List_simple_types<REWARD_ITEM> >, COMDAT
; _this$ = ecx

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<REWARD_ITEM> >::_List_val<std::_List_simple_types<REWARD_ITEM> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal, COMDAT
; _this$ = ecx

; 1790 :     const _Alnode& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1791 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Get_first

; 1792 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal, COMDAT
; _this$ = ecx

; 1786 :     _Alnode& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Get_first

; 1788 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Newhead$ = -20					; size = 4
__Al$ = -16						; size = 4
__Proxy$ = -10						; size = 1
_$S24$ = -9						; size = 1
__Alproxy$ = -8						; size = 4
_this$ = -4						; size = 4
?_Alloc_sentinel_and_proxy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  0000c	8d 45 f7	 lea	 eax, DWORD PTR _$S24$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1773 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	50		 push	 eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  00019	51		 push	 ecx
  0001a	8d 4d f6	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1774 :         auto& _Al     = _Getal();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal
  0002a	89 45 f0	 mov	 DWORD PTR __Al$[ebp], eax

; 1775 :         auto _Newhead = _Al.allocate(1);

  0002d	6a 01		 push	 1
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::allocate
  00037	89 45 ec	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  0003a	8d 45 ec	 lea	 eax, DWORD PTR __Newhead$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * &>
  00047	83 c4 08	 add	 esp, 8

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0004a	8d 45 ec	 lea	 eax, DWORD PTR __Newhead$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00051	83 c1 04	 add	 ecx, 4
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UREWARD_ITEM@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UREWARD_ITEM@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<REWARD_ITEM,void *> *,std::_List_node<REWARD_ITEM,void *> * &>
  0005a	83 c4 08	 add	 esp, 8

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00063	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 :         _Proxy._Release();

  00065	8d 4d f6	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 1780 :     }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Tidy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__My_data$ = -12					; size = 4
__Al$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1437 :         auto& _Al      = _Getal();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal
  00014	89 45 f8	 mov	 DWORD PTR __Al$[ebp], eax

; 1438 :         auto& _My_data = _Mypair._Myval2;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00025	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	8b 55 f8	 mov	 edx, DWORD PTR __Al$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ; std::_List_node<REWARD_ITEM,void *>::_Free_non_head<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
  00034	83 c4 08	 add	 esp, 8

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  00037	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	51		 push	 ecx
  0003d	8b 55 f8	 mov	 edx, DWORD PTR __Al$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ; std::_List_node<REWARD_ITEM,void *>::_Freenode0<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
  00046	83 c4 08	 add	 esp, 8

; 1442 :     }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?_Tidy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?clear@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXXZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1428 :         _My_data._Orphan_non_end();

  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<REWARD_ITEM> >::_Orphan_non_end

; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	51		 push	 ecx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@?$_List_node@UREWARD_ITEM@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@1@PAU01@@Z ; std::_List_node<REWARD_ITEM,void *>::_Free_non_head<std::allocator<std::_List_node<REWARD_ITEM,void *> > >
  0002e	83 c4 08	 add	 esp, 8

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00031	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00039	8b 02		 mov	 eax, DWORD PTR [edx]
  0003b	89 01		 mov	 DWORD PTR [ecx], eax

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1432 :         _My_data._Mysize        = 0;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1433 :     }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?clear@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXXZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?push_back@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXABUREWARD_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXABUREWARD_ITEM@@@Z PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::push_back, COMDAT
; _this$ = ecx

; 1251 :     void push_back(const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$_Emplace@ABUREWARD_ITEM@@@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@1@QAU21@ABUREWARD_ITEM@@@Z ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Emplace<REWARD_ITEM const &>

; 1253 :     }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?push_back@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXABUREWARD_ITEM@@@Z ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?max_size@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QBEIXZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::max_size, COMDAT
; _this$ = ecx

; 1194 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1195 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1196 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1197 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?end@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::end, COMDAT
; _this$ = ecx

; 1099 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	52		 push	 edx
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1101 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?end@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?begin@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::begin, COMDAT
; _this$ = ecx

; 1091 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	8b 02		 mov	 eax, DWORD PTR [edx]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAE@PAU?$_List_node@UREWARD_ITEM@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@1@@Z
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1093 :     }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?begin@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??1?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::~list<REWARD_ITEM,std::allocator<REWARD_ITEM> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::~list<REWARD_ITEM,std::allocator<REWARD_ITEM> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
??0?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ PROC ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T1[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1>::_Compressed_pair<std::allocator<std::_List_node<REWARD_ITEM,void *> >,std::_List_val<std::_List_simple_types<REWARD_ITEM> >,1><>

; 805  :         _Alloc_sentinel_and_proxy();

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@AAEXXZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::_Alloc_sentinel_and_proxy

; 806  :     }

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@QAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@QAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::deallocate, COMDAT

; 687  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 688  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 689  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	c1 e0 05	 shl	 eax, 5
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00019	83 c4 08	 add	 esp, 8

; 690  :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@2@QAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<REWARD_ITEM,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0CA@@std@@YAII@Z ; std::_Get_size_of_n<32>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEPAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEXQAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEXQAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	c1 e0 05	 shl	 eax, 5
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001c	83 c4 08	 add	 esp, 8

; 804  :     }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAEXQAU?$_List_node@UREWARD_ITEM@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::allocator<std::_List_node<REWARD_ITEM,void *> >, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$_List_node@UREWARD_ITEM@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<REWARD_ITEM,void *> >::allocator<std::_List_node<REWARD_ITEM,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Unlinknode@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEPAU?$_List_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
?_Unlinknode@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEPAU?$_List_node@HPAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<int> >::_Unlinknode, COMDAT
; _this$ = ecx

; 394  :     _Nodeptr _Unlinknode(_Nodeptr _Pnode) noexcept { // unlink node at _Where from the list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 395  :         _Orphan_ptr2(_Pnode);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXPAU?$_List_node@HPAX@2@@Z ; std::_List_val<std::_List_simple_types<int> >::_Orphan_ptr2

; 396  :         _Pnode->_Prev->_Next = _Pnode->_Next;

  00018	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	8b 55 08	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	89 01		 mov	 DWORD PTR [ecx], eax

; 397  :         _Pnode->_Next->_Prev = _Pnode->_Prev;

  00025	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	8b 55 08	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 398  :         --_Mysize;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	83 e9 01	 sub	 ecx, 1
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 399  :         return _Pnode;

  00042	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 400  :     }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?_Unlinknode@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEPAU?$_List_node@HPAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<int> >::_Unlinknode
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXXZ PROC ; std::_List_val<std::_List_simple_types<int> >::_Orphan_non_end, COMDAT
; _this$ = ecx

; 377  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 378  : #if _ITERATOR_DEBUG_LEVEL == 2
; 379  :         _Lockit _Lock(_LOCK_DEBUG);
; 380  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 381  :         const auto _Head          = _Myhead;
; 382  :         while (*_Pnext) {
; 383  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 384  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 385  :                 _Pnext = _Pnextnext;
; 386  :             } else { // orphan the iterator
; 387  :                 (*_Pnext)->_Myproxy = nullptr;
; 388  :                 *_Pnext             = *_Pnextnext;
; 389  :             }
; 390  :         }
; 391  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 392  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXXZ ENDP ; std::_List_val<std::_List_simple_types<int> >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXPAU?$_List_node@HPAX@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXPAU?$_List_node@HPAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<int> >::_Orphan_ptr2, COMDAT
; _this$ = ecx

; 356  :     void _Orphan_ptr2(_Nodeptr _Ptr) noexcept { // orphan iterators with specified node pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 357  : #if _ITERATOR_DEBUG_LEVEL == 2
; 358  :         _Lockit _Lock(_LOCK_DEBUG);
; 359  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 360  :         const auto _Head          = _Myhead;
; 361  :         while (*_Pnext) {
; 362  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 363  :             const auto _Pnextptr          = static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr;
; 364  :             if (_Pnextptr == _Head || _Pnextptr != _Ptr) {
; 365  :                 // iterator is end() or doesn't point at the one we are orphaning, move on
; 366  :                 _Pnext = _Pnextnext;
; 367  :             } else { // orphan the iterator
; 368  :                 (*_Pnext)->_Myproxy = nullptr;
; 369  :                 *_Pnext             = *_Pnextnext;
; 370  :             }
; 371  :         }
; 372  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 373  :         (void) _Ptr;
; 374  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 375  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXPAU?$_List_node@HPAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<int> >::_Orphan_ptr2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_val@U?$_List_simple_types@H@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<int> >::_List_val<std::_List_simple_types<int> >, COMDAT
; _this$ = ecx

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<int> >::_List_val<std::_List_simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Getal@?$list@HV?$allocator@H@std@@@std@@ABEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$list@HV?$allocator@H@std@@@std@@ABEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1790 :     const _Alnode& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1791 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first

; 1792 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$list@HV?$allocator@H@std@@@std@@ABEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1786 :     _Alnode& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first

; 1788 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Newhead$ = -20					; size = 4
__Al$ = -16						; size = 4
__Proxy$ = -10						; size = 1
_$S25$ = -9						; size = 1
__Alproxy$ = -8						; size = 4
_this$ = -4						; size = 4
?_Alloc_sentinel_and_proxy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ PROC ; std::list<int,std::allocator<int> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  0000c	8d 45 f7	 lea	 eax, DWORD PTR _$S25$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1773 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	50		 push	 eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  00019	51		 push	 ecx
  0001a	8d 4d f6	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1774 :         auto& _Al     = _Getal();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
  0002a	89 45 f0	 mov	 DWORD PTR __Al$[ebp], eax

; 1775 :         auto _Newhead = _Al.allocate(1);

  0002d	6a 01		 push	 1
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z ; std::allocator<std::_List_node<int,void *> >::allocate
  00037	89 45 ec	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  0003a	8d 45 ec	 lea	 eax, DWORD PTR __Newhead$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@0@Z ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * &>
  00047	83 c4 08	 add	 esp, 8

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0004a	8d 45 ec	 lea	 eax, DWORD PTR __Newhead$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00051	83 c1 04	 add	 ecx, 4
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@HPAX@0@0@Z ; std::_Construct_in_place<std::_List_node<int,void *> *,std::_List_node<int,void *> * &>
  0005a	83 c4 08	 add	 esp, 8

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00063	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 :         _Proxy._Release();

  00065	8d 4d f6	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 1780 :     }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ ENDP ; std::list<int,std::allocator<int> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Tidy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__My_data$ = -12					; size = 4
__Al$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::list<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1437 :         auto& _Al      = _Getal();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
  00014	89 45 f8	 mov	 DWORD PTR __Al$[ebp], eax

; 1438 :         auto& _My_data = _Mypair._Myval2;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00025	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	8b 55 f8	 mov	 edx, DWORD PTR __Al$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Free_non_head<std::allocator<std::_List_node<int,void *> > >
  00034	83 c4 08	 add	 esp, 8

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  00037	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	51		 push	 ecx
  0003d	8b 55 f8	 mov	 edx, DWORD PTR __Al$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Freenode0<std::allocator<std::_List_node<int,void *> > >
  00046	83 c4 08	 add	 esp, 8

; 1442 :     }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?_Tidy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::list<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::list<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1428 :         _My_data._Orphan_non_end();

  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<int> >::_Orphan_non_end

; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	51		 push	 ecx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Free_non_head<std::allocator<std::_List_node<int,void *> > >
  0002e	83 c4 08	 add	 esp, 8

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00031	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00039	8b 02		 mov	 eax, DWORD PTR [edx]
  0003b	89 01		 mov	 DWORD PTR [ecx], eax

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1432 :         _My_data._Mysize        = 0;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1433 :     }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::list<int,std::allocator<int> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z PROC ; std::list<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1349 :     iterator erase(const const_iterator _Where) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1350 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1351 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "list erase iterator outside range");
; 1352 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1353 :         const auto _Result = _Where._Ptr->_Next;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Result$[ebp], ecx

; 1354 :         _Node::_Freenode(_Getal(), _Mypair._Myval2._Unlinknode(_Where._Ptr));

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Unlinknode@?$_List_val@U?$_List_simple_types@H@std@@@std@@QAEPAU?$_List_node@HPAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<int> >::_Unlinknode
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Freenode<std::allocator<std::_List_node<int,void *> > >
  0002f	83 c4 08	 add	 esp, 8

; 1355 :         return _Make_iter(_Result);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	51		 push	 ecx
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@PAU?$_List_node@HPAX@2@@Z ; std::list<int,std::allocator<int> >::_Make_iter
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1356 :     }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ENDP ; std::list<int,std::allocator<int> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::list<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 1251 :     void push_back(const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$_Emplace@ABH@?$list@HV?$allocator@H@std@@@std@@QAEPAU?$_List_node@HPAX@1@QAU21@ABH@Z ; std::list<int,std::allocator<int> >::_Emplace<int const &>

; 1253 :     }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::list<int,std::allocator<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::list<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1194 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1195 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$list@HV?$allocator@H@std@@@std@@ABEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@HPAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1196 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1197 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::list<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::list<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 1190 :     _NODISCARD size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 :         return _Mypair._Myval2._Mysize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1192 :     }

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::list<int,std::allocator<int> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@PAU?$_List_node@HPAX@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@PAU?$_List_node@HPAX@2@@Z PROC ; std::list<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 1123 :     iterator _Make_iter(_Nodeptr _Where) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1124 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@H@std@@@0@ABV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<int> > const >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1125 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@PAU?$_List_node@HPAX@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 1099 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<int> > >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	52		 push	 edx
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1101 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 1091 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<int> > >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	8b 02		 mov	 eax, DWORD PTR [edx]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1093 :     }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ ; std::list<int,std::allocator<int> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T1[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1><>

; 805  :         _Alloc_sentinel_and_proxy();

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ ; std::list<int,std::allocator<int> >::_Alloc_sentinel_and_proxy

; 806  :     }

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@HPAX@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@HPAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@HPAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@2@QAU?$_List_node@HPAX@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@2@QAU?$_List_node@HPAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::deallocate, COMDAT

; 687  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 688  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 689  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00009	6b 45 10 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  0000d	50		 push	 eax
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00017	83 c4 08	 add	 esp, 8

; 690  :     }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@2@QAU?$_List_node@HPAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z PROC ; std::allocator<std::_List_node<int,void *> >::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0M@@std@@YAII@Z ; std::_Get_size_of_n<12>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z ENDP ; std::allocator<std::_List_node<int,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEXQAU?$_List_node@HPAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEXQAU?$_List_node@HPAX@2@I@Z PROC ; std::allocator<std::_List_node<int,void *> >::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	6b 45 0c 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8

; 804  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEXQAU?$_List_node@HPAX@2@I@Z ENDP ; std::allocator<std::_List_node<int,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@U?$_List_node@HPAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_List_node@HPAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<int,void *> >::allocator<std::_List_node<int,void *> >, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$_List_node@HPAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<int,void *> >::allocator<std::_List_node<int,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?ProcessFinish@CEngagePVP@@AAEXXZ
_TEXT	SEGMENT
$T1 = -392						; size = 4
$T2 = -388						; size = 4
$T3 = -384						; size = 4
$T4 = -380						; size = 4
$T5 = -376						; size = 4
$T6 = -372						; size = 4
$T7 = -368						; size = 4
_it$8 = -300						; size = 4
_dwTickCount$9 = -296					; size = 4
_lpObj$10 = -292					; size = 4
_it$11 = -288						; size = 4
_it$12 = -284						; size = 4
_notice$ = -280						; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcessFinish@CEngagePVP@@AAEXXZ PROC			; CEngagePVP::ProcessFinish, COMDAT
; _this$ = ecx

; 563  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 01 00
	00		 sub	 esp, 392		; 00000188H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 564  : 	if(this->m_userList.size() == 0)

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::size
  00021	85 c0		 test	 eax, eax
  00023	75 37		 jne	 SHORT $LN11@ProcessFin

; 565  : 	{
; 566  : 		this->m_eventState = EVENT_CLOSED;

  00025	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [eax+72], 1

; 567  : 		this->m_nextTime = NULL;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 568  : 		this->m_tickCount = 0;

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0

; 569  : 		this->m_minToAdd = 0;

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 570  : 		this->m_secToAdd = 0;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0

; 571  : 		return;

  00057	e9 4d 02 00 00	 jmp	 $LN1@ProcessFin
$LN11@ProcessFin:

; 572  : 	}
; 573  : 
; 574  : 	TNotice notice;

  0005c	6a 00		 push	 0
  0005e	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  00064	e8 00 00 00 00	 call	 ??0TNotice@@QAE@E@Z	; TNotice::TNotice

; 575  : 
; 576  : 	if(this->m_secToAdd == 60)

  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	83 78 74 3c	 cmp	 DWORD PTR [eax+116], 60	; 0000003cH
  00070	75 7a		 jne	 SHORT $LN12@ProcessFin

; 577  : 	{
; 578  : 		for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();it = this->m_userList.erase(it))

  00072	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _it$12[ebp]
  00078	50		 push	 eax
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
  00081	eb 2a		 jmp	 SHORT $LN4@ProcessFin
$LN2@ProcessFin:
  00083	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _it$12[ebp]
  00089	89 85 90 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  0008f	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  00095	51		 push	 ecx
  00096	8d 95 8c fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  0009c	52		 push	 edx
  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	e8 00 00 00 00	 call	 ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ; std::list<int,std::allocator<int> >::erase
  000a5	8b 00		 mov	 eax, DWORD PTR [eax]
  000a7	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _it$12[ebp], eax
$LN4@ProcessFin:
  000ad	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  000bc	50		 push	 eax
  000bd	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$12[ebp]
  000c3	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  000c8	0f b6 c8	 movzx	 ecx, al
  000cb	85 c9		 test	 ecx, ecx
  000cd	74 18		 je	 SHORT $LN3@ProcessFin

; 579  : 		{
; 580  : 			this->ClearUser(*it);

  000cf	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$12[ebp]
  000d5	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  000da	8b 00		 mov	 eax, DWORD PTR [eax]
  000dc	50		 push	 eax
  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	e8 00 00 00 00	 call	 ?ClearUser@CEngagePVP@@AAEXH@Z ; CEngagePVP::ClearUser

; 581  : 		}

  000e5	eb 9c		 jmp	 SHORT $LN2@ProcessFin
$LN3@ProcessFin:

; 582  : 	}

  000e7	e9 bd 01 00 00	 jmp	 $LN1@ProcessFin
$LN12@ProcessFin:

; 583  : 	else
; 584  : 	{
; 585  : 		for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();)

  000ec	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _it$11[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
$LN7@ProcessFin:
  000fb	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00101	50		 push	 eax
  00102	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  0010a	50		 push	 eax
  0010b	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$11[ebp]
  00111	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  00116	0f b6 c8	 movzx	 ecx, al
  00119	85 c9		 test	 ecx, ecx
  0011b	0f 84 9b 00 00
	00		 je	 $LN6@ProcessFin

; 586  : 		{
; 587  : 			LPOBJECTSTRUCT lpObj = &gObj[*it];

  00121	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$11[ebp]
  00127	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  0012c	69 00 a0 1b 00
	00		 imul	 eax, DWORD PTR [eax], 7072
  00132	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00138	89 85 dc fe ff
	ff		 mov	 DWORD PTR _lpObj$10[ebp], eax

; 588  : 
; 589  : 			if(gObjIsConnected(*it) == FALSE || lpObj->MapNumber != PVP_EVENT_MAP)

  0013e	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$11[ebp]
  00144	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00149	8b 00		 mov	 eax, DWORD PTR [eax]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00151	83 c4 04	 add	 esp, 4
  00154	85 c0		 test	 eax, eax
  00156	74 12		 je	 SHORT $LN16@ProcessFin
  00158	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$10[ebp]
  0015e	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00165	83 f9 09	 cmp	 ecx, 9
  00168	74 42		 je	 SHORT $LN14@ProcessFin
$LN16@ProcessFin:

; 590  : 			{
; 591  : 				this->ClearUser(*it);

  0016a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$11[ebp]
  00170	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00175	8b 00		 mov	 eax, DWORD PTR [eax]
  00177	50		 push	 eax
  00178	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017b	e8 00 00 00 00	 call	 ?ClearUser@CEngagePVP@@AAEXH@Z ; CEngagePVP::ClearUser

; 592  : 				it = this->m_userList.erase(it);

  00180	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _it$11[ebp]
  00186	89 85 80 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0018c	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00192	51		 push	 ecx
  00193	8d 95 7c fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  00199	52		 push	 edx
  0019a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	e8 00 00 00 00	 call	 ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ; std::list<int,std::allocator<int> >::erase
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _it$11[ebp], eax

; 593  : 			}

  001aa	eb 0b		 jmp	 SHORT $LN15@ProcessFin
$LN14@ProcessFin:

; 594  : 			else
; 595  : 				++it;

  001ac	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$11[ebp]
  001b2	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
$LN15@ProcessFin:

; 596  : 		}

  001b7	e9 3f ff ff ff	 jmp	 $LN7@ProcessFin
$LN6@ProcessFin:

; 597  : 
; 598  : 		DWORD dwTickCount = GetTickCount();

  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001c2	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _dwTickCount$9[ebp], eax

; 599  : 
; 600  : 		if(this->m_userList.size() > 0)

  001c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	e8 00 00 00 00	 call	 ?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::size
  001d0	85 c0		 test	 eax, eax
  001d2	0f 86 d1 00 00
	00		 jbe	 $LN1@ProcessFin

; 601  : 		{
; 602  : 			if(this->m_tickCount+(this->m_secToAdd*1000) <= dwTickCount)

  001d8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001db	69 48 74 e8 03
	00 00		 imul	 ecx, DWORD PTR [eax+116], 1000
  001e2	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001e5	03 4a 6c	 add	 ecx, DWORD PTR [edx+108]
  001e8	3b 8d d8 fe ff
	ff		 cmp	 ecx, DWORD PTR _dwTickCount$9[ebp]
  001ee	0f 87 b5 00 00
	00		 ja	 $LN1@ProcessFin

; 603  : 			{
; 604  : 				for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();++it)

  001f4	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _it$8[ebp]
  001fa	50		 push	 eax
  001fb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fe	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
  00203	eb 0b		 jmp	 SHORT $LN10@ProcessFin
$LN8@ProcessFin:
  00205	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$8[ebp]
  0020b	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
$LN10@ProcessFin:
  00210	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00216	50		 push	 eax
  00217	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0021a	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  0021f	50		 push	 eax
  00220	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$8[ebp]
  00226	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  0022b	0f b6 c8	 movzx	 ecx, al
  0022e	85 c9		 test	 ecx, ecx
  00230	74 68		 je	 SHORT $LN9@ProcessFin

; 605  : 				{
; 606  : 					cManager.ManagementProc(&gObj[*it], "/fire", *it);

  00232	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$8[ebp]
  00238	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  0023d	8b 00		 mov	 eax, DWORD PTR [eax]
  0023f	50		 push	 eax
  00240	68 00 00 00 00	 push	 OFFSET ??_C@_05KHGEPAAH@?1fire@
  00245	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$8[ebp]
  0024b	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00250	69 08 a0 1b 00
	00		 imul	 ecx, DWORD PTR [eax], 7072
  00256	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0025c	51		 push	 ecx
  0025d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  00262	e8 00 00 00 00	 call	 ?ManagementProc@CGMMng@@QAEHPAVOBJECTSTRUCT@@PADH@Z ; CGMMng::ManagementProc

; 607  : 					notice.SendToUser(*it, "[PVP Event] La arena se cerrara en %d segundos", 60-this->m_secToAdd);

  00267	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0026a	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0026f	2b 48 74	 sub	 ecx, DWORD PTR [eax+116]
  00272	51		 push	 ecx
  00273	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@OIEOHOKH@?$FLPVP?5Event?$FN?5La?5arena?5se?5cerrara@
  00278	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$8[ebp]
  0027e	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00283	8b 10		 mov	 edx, DWORD PTR [eax]
  00285	52		 push	 edx
  00286	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _notice$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 ?SendToUser@TNotice@@QAAXHPADZZ ; TNotice::SendToUser
  00292	83 c4 10	 add	 esp, 16			; 00000010H

; 608  : 				}

  00295	e9 6b ff ff ff	 jmp	 $LN8@ProcessFin
$LN9@ProcessFin:

; 609  : 
; 610  : 				this->m_secToAdd += 15;

  0029a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0029d	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  002a0	83 c1 0f	 add	 ecx, 15			; 0000000fH
  002a3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  002a6	89 4a 74	 mov	 DWORD PTR [edx+116], ecx
$LN1@ProcessFin:

; 611  : 			}
; 612  : 		}
; 613  : 	}
; 614  : }

  002a9	5f		 pop	 edi
  002aa	5e		 pop	 esi
  002ab	5b		 pop	 ebx
  002ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002af	33 cd		 xor	 ecx, ebp
  002b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b6	8b e5		 mov	 esp, ebp
  002b8	5d		 pop	 ebp
  002b9	c3		 ret	 0
?ProcessFinish@CEngagePVP@@AAEXXZ ENDP			; CEngagePVP::ProcessFinish
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?ProcessRunning@CEngagePVP@@AAEXXZ
_TEXT	SEGMENT
$T1 = -432						; size = 4
$T2 = -428						; size = 4
$T3 = -424						; size = 4
$T4 = -420						; size = 4
$T5 = -416						; size = 4
$T6 = -412						; size = 4
$T7 = -408						; size = 4
$T8 = -404						; size = 4
$T9 = -400						; size = 4
$T10 = -396						; size = 4
_it$11 = -328						; size = 4
_it$12 = -324						; size = 4
_it$13 = -320						; size = 4
_i$14 = -316						; size = 4
_NewOption$15 = -309					; size = 1
_item$16 = -308						; size = 4
_it$17 = -304						; size = 4
_lpObj$18 = -300					; size = 4
_it$19 = -296						; size = 4
_dwTickCount$ = -292					; size = 4
_notice$ = -288						; size = 272
_lpObj$20 = -16						; size = 4
_it$21 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcessRunning@CEngagePVP@@AAEXXZ PROC			; CEngagePVP::ProcessRunning, COMDAT
; _this$ = ecx

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 01 00
	00		 sub	 esp, 432		; 000001b0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  : 	for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();)

  00019	8d 45 f4	 lea	 eax, DWORD PTR _it$21[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
$LN4@ProcessRun:
  00025	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  00034	50		 push	 eax
  00035	8d 4d f4	 lea	 ecx, DWORD PTR _it$21[ebp]
  00038	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  0003d	0f b6 c8	 movzx	 ecx, al
  00040	85 c9		 test	 ecx, ecx
  00042	74 6c		 je	 SHORT $LN3@ProcessRun

; 460  : 	{
; 461  : 		LPOBJECTSTRUCT lpObj = &gObj[*it];

  00044	8d 4d f4	 lea	 ecx, DWORD PTR _it$21[ebp]
  00047	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  0004c	69 00 a0 1b 00
	00		 imul	 eax, DWORD PTR [eax], 7072
  00052	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00058	89 45 f0	 mov	 DWORD PTR _lpObj$20[ebp], eax

; 462  : 
; 463  : 		if(lpObj->MapNumber != PVP_EVENT_MAP)

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$20[ebp]
  0005e	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00065	83 f9 09	 cmp	 ecx, 9
  00068	74 39		 je	 SHORT $LN20@ProcessRun

; 464  : 		{
; 465  : 			this->ClearUser(*it);

  0006a	8d 4d f4	 lea	 ecx, DWORD PTR _it$21[ebp]
  0006d	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	50		 push	 eax
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?ClearUser@CEngagePVP@@AAEXH@Z ; CEngagePVP::ClearUser

; 466  : 
; 467  : 			it = this->m_userList.erase(it);

  0007d	8b 45 f4	 mov	 eax, DWORD PTR _it$21[ebp]
  00080	89 85 70 fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  00086	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  0008c	51		 push	 ecx
  0008d	8d 95 6c fe ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  00093	52		 push	 edx
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ; std::list<int,std::allocator<int> >::erase
  0009c	8b 00		 mov	 eax, DWORD PTR [eax]
  0009e	89 45 f4	 mov	 DWORD PTR _it$21[ebp], eax

; 468  : 		}

  000a1	eb 08		 jmp	 SHORT $LN21@ProcessRun
$LN20@ProcessRun:

; 469  : 		else
; 470  : 		{
; 471  : 			++it;

  000a3	8d 4d f4	 lea	 ecx, DWORD PTR _it$21[ebp]
  000a6	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
$LN21@ProcessRun:

; 472  : 		}
; 473  : 	}

  000ab	e9 75 ff ff ff	 jmp	 $LN4@ProcessRun
$LN3@ProcessRun:

; 474  : 
; 475  : 	TNotice notice;

  000b0	6a 00		 push	 0
  000b2	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  000b8	e8 00 00 00 00	 call	 ??0TNotice@@QAE@E@Z	; TNotice::TNotice

; 476  : 
; 477  : 	DWORD dwTickCount = GetTickCount();

  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000c3	89 85 dc fe ff
	ff		 mov	 DWORD PTR _dwTickCount$[ebp], eax

; 478  : 
; 479  : 	if(this->m_userList.size() <= 1)

  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::size
  000d1	83 f8 01	 cmp	 eax, 1
  000d4	0f 87 35 02 00
	00		 ja	 $LN22@ProcessRun

; 480  : 	{
; 481  : 		USER_INDEX_LIST::iterator it = this->m_userList.begin();

  000da	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _it$19[ebp]
  000e0	50		 push	 eax
  000e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin

; 482  : 
; 483  : 		this->m_minToAdd = 0;

  000e9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 484  : 		this->m_secToAdd = 0;

  000f3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0

; 485  : 		this->m_tickCount = dwTickCount;

  000fd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00100	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _dwTickCount$[ebp]
  00106	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 486  : 
; 487  : 		this->m_eventState = EVENT_FINISH;

  00109	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010c	c7 40 48 03 00
	00 00		 mov	 DWORD PTR [eax+72], 3

; 488  : 
; 489  : 		if(it != this->m_userList.end())

  00113	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00119	50		 push	 eax
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  00122	50		 push	 eax
  00123	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _it$19[ebp]
  00129	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  0012e	0f b6 c8	 movzx	 ecx, al
  00131	85 c9		 test	 ecx, ecx
  00133	0f 84 bd 01 00
	00		 je	 $LN24@ProcessRun

; 490  : 		{
; 491  : 			LPOBJECTSTRUCT lpObj = &gObj[*it];

  00139	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _it$19[ebp]
  0013f	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00144	69 00 a0 1b 00
	00		 imul	 eax, DWORD PTR [eax], 7072
  0014a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00150	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _lpObj$18[ebp], eax

; 492  : 
; 493  : 			for(REWARD_ITEM_LIST::iterator it = this->m_rewardList.begin();it != this->m_rewardList.end();++it)

  00156	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _it$17[ebp]
  0015c	50		 push	 eax
  0015d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00160	83 c1 08	 add	 ecx, 8
  00163	e8 00 00 00 00	 call	 ?begin@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::begin
  00168	eb 0b		 jmp	 SHORT $LN7@ProcessRun
$LN5@ProcessRun:
  0016a	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$17[ebp]
  00170	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator++
$LN7@ProcessRun:
  00175	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0017b	50		 push	 eax
  0017c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	83 c1 08	 add	 ecx, 8
  00182	e8 00 00 00 00	 call	 ?end@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@2@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::end
  00187	50		 push	 eax
  00188	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$17[ebp]
  0018e	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator!=
  00193	0f b6 c8	 movzx	 ecx, al
  00196	85 c9		 test	 ecx, ecx
  00198	0f 84 38 01 00
	00		 je	 $LN6@ProcessRun

; 494  : 			{
; 495  : 				REWARD_ITEM &item = *it;

  0019e	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$17[ebp]
  001a4	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UREWARD_ITEM@@@std@@@std@@@std@@QBEAAUREWARD_ITEM@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<REWARD_ITEM> > >::operator*
  001a9	89 85 cc fe ff
	ff		 mov	 DWORD PTR _item$16[ebp], eax

; 496  : 
; 497  : 				if(rand()%1000 < item.m_iMaxRate)

  001af	e8 00 00 00 00	 call	 _rand
  001b4	99		 cdq
  001b5	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  001ba	f7 f9		 idiv	 ecx
  001bc	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _item$16[ebp]
  001c2	3b 50 14	 cmp	 edx, DWORD PTR [eax+20]
  001c5	0f 8d 06 01 00
	00		 jge	 $LN26@ProcessRun

; 498  : 				{
; 499  : 					BYTE NewOption = 0;

  001cb	c6 85 cb fe ff
	ff 00		 mov	 BYTE PTR _NewOption$15[ebp], 0

; 500  : 
; 501  : 					for(int i = 0;i < item.m_btExcOption;i++)

  001d2	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$14[ebp], 0
  001dc	eb 0f		 jmp	 SHORT $LN10@ProcessRun
$LN8@ProcessRun:
  001de	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _i$14[ebp]
  001e4	83 c0 01	 add	 eax, 1
  001e7	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _i$14[ebp], eax
$LN10@ProcessRun:
  001ed	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _item$16[ebp]
  001f3	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  001f7	39 8d c4 fe ff
	ff		 cmp	 DWORD PTR _i$14[ebp], ecx
  001fd	7d 1e		 jge	 SHORT $LN9@ProcessRun

; 502  : 						NewOption |= 1 << i;

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$14[ebp]
  0020a	d3 e0		 shl	 eax, cl
  0020c	0f b6 8d cb fe
	ff ff		 movzx	 ecx, BYTE PTR _NewOption$15[ebp]
  00213	0b c8		 or	 ecx, eax
  00215	88 8d cb fe ff
	ff		 mov	 BYTE PTR _NewOption$15[ebp], cl
  0021b	eb c1		 jmp	 SHORT $LN8@ProcessRun
$LN9@ProcessRun:

; 503  : 
; 504  : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)lpObj->X+rand()%5, (BYTE)lpObj->Y+rand()%5, item.m_dwType, item.m_btLevel, (BYTE)ItemAttribute[item.m_dwType].Durability, item.m_bSkill, item.m_bLuck, item.m_btOption, lpObj->m_Index, NewOption, 0, TRUE);

  0021d	6a 01		 push	 1
  0021f	6a 00		 push	 0
  00221	0f b6 85 cb fe
	ff ff		 movzx	 eax, BYTE PTR _NewOption$15[ebp]
  00228	50		 push	 eax
  00229	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$18[ebp]
  0022f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00231	52		 push	 edx
  00232	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _item$16[ebp]
  00238	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0023c	51		 push	 ecx
  0023d	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _item$16[ebp]
  00243	0f b6 42 0c	 movzx	 eax, BYTE PTR [edx+12]
  00247	50		 push	 eax
  00248	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _item$16[ebp]
  0024e	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00252	52		 push	 edx
  00253	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _item$16[ebp]
  00259	6b 08 6c	 imul	 ecx, DWORD PTR [eax], 108
  0025c	0f b6 91 30 00
	00 00		 movzx	 edx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[ecx+48]
  00263	52		 push	 edx
  00264	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _item$16[ebp]
  0026a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0026e	51		 push	 ecx
  0026f	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _item$16[ebp]
  00275	8b 02		 mov	 eax, DWORD PTR [edx]
  00277	50		 push	 eax
  00278	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$18[ebp]
  0027e	0f b6 b1 06 01
	00 00		 movzx	 esi, BYTE PTR [ecx+262]
  00285	e8 00 00 00 00	 call	 _rand
  0028a	99		 cdq
  0028b	b9 05 00 00 00	 mov	 ecx, 5
  00290	f7 f9		 idiv	 ecx
  00292	03 f2		 add	 esi, edx
  00294	56		 push	 esi
  00295	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$18[ebp]
  0029b	0f b6 b2 04 01
	00 00		 movzx	 esi, BYTE PTR [edx+260]
  002a2	e8 00 00 00 00	 call	 _rand
  002a7	99		 cdq
  002a8	b9 05 00 00 00	 mov	 ecx, 5
  002ad	f7 f9		 idiv	 ecx
  002af	03 f2		 add	 esi, edx
  002b1	56		 push	 esi
  002b2	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$18[ebp]
  002b8	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  002bf	50		 push	 eax
  002c0	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$18[ebp]
  002c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  002c8	52		 push	 edx
  002c9	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  002ce	83 c4 38	 add	 esp, 56			; 00000038H
$LN26@ProcessRun:

; 505  : 				}
; 506  : 			}

  002d1	e9 94 fe ff ff	 jmp	 $LN5@ProcessRun
$LN6@ProcessRun:

; 507  : 
; 508  : 			notice.SendToAllUser("[PVP Event] El ganador del evento es %s - Felicidades!", lpObj->Name);

  002d6	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$18[ebp]
  002dc	83 c0 73	 add	 eax, 115		; 00000073H
  002df	50		 push	 eax
  002e0	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NHBJFALI@?$FLPVP?5Event?$FN?5El?5ganador?5del?5even@
  002e5	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  002eb	51		 push	 ecx
  002ec	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  002f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 509  : 		}

  002f4	eb 14		 jmp	 SHORT $LN25@ProcessRun
$LN24@ProcessRun:

; 510  : 		else
; 511  : 		{
; 512  : 			notice.SendToAllUser("[PVP Event] No hubo ganador!");

  002f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FFOEKPGN@?$FLPVP?5Event?$FN?5No?5hubo?5ganador?$CB@
  002fb	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _notice$[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  00307	83 c4 08	 add	 esp, 8
$LN25@ProcessRun:

; 513  : 		}
; 514  : 	}

  0030a	e9 27 02 00 00	 jmp	 $LN1@ProcessRun
$LN22@ProcessRun:

; 515  : 	else
; 516  : 	{
; 517  : 		if(this->m_minToAdd == 60 && this->m_secToAdd == 60)

  0030f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00312	83 78 70 3c	 cmp	 DWORD PTR [eax+112], 60	; 0000003cH
  00316	0f 85 c5 00 00
	00		 jne	 $LN27@ProcessRun
  0031c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0031f	83 78 74 3c	 cmp	 DWORD PTR [eax+116], 60	; 0000003cH
  00323	0f 85 b8 00 00
	00		 jne	 $LN27@ProcessRun

; 518  : 		{
; 519  : 			this->m_minToAdd = 0;

  00329	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0032c	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 520  : 			this->m_secToAdd = 0;

  00333	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00336	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0

; 521  : 			this->m_tickCount = dwTickCount;

  0033d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00340	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _dwTickCount$[ebp]
  00346	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 522  : 
; 523  : 			this->m_eventState = EVENT_FINISH;

  00349	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0034c	c7 40 48 03 00
	00 00		 mov	 DWORD PTR [eax+72], 3

; 524  : 
; 525  : 			notice.SendToAllUser("[PVP Event] Se termino el tiempo, no hubo ganador!");

  00353	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@OCPAALGN@?$FLPVP?5Event?$FN?5Se?5termino?5el?5tiemp@
  00358	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _notice$[ebp]
  0035e	50		 push	 eax
  0035f	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  00364	83 c4 08	 add	 esp, 8

; 526  : 
; 527  : 			for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();it = this->m_userList.erase(it))

  00367	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _it$13[ebp]
  0036d	50		 push	 eax
  0036e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00371	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
  00376	eb 2a		 jmp	 SHORT $LN13@ProcessRun
$LN11@ProcessRun:
  00378	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _it$13[ebp]
  0037e	89 85 60 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  00384	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  0038a	51		 push	 ecx
  0038b	8d 95 5c fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00391	52		 push	 edx
  00392	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00395	e8 00 00 00 00	 call	 ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ; std::list<int,std::allocator<int> >::erase
  0039a	8b 00		 mov	 eax, DWORD PTR [eax]
  0039c	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _it$13[ebp], eax
$LN13@ProcessRun:
  003a2	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  003a8	50		 push	 eax
  003a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ac	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  003b1	50		 push	 eax
  003b2	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$13[ebp]
  003b8	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  003bd	0f b6 c8	 movzx	 ecx, al
  003c0	85 c9		 test	 ecx, ecx
  003c2	74 18		 je	 SHORT $LN12@ProcessRun

; 528  : 			{
; 529  : 				this->ClearUser(*it);

  003c4	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$13[ebp]
  003ca	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  003cf	8b 00		 mov	 eax, DWORD PTR [eax]
  003d1	50		 push	 eax
  003d2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003d5	e8 00 00 00 00	 call	 ?ClearUser@CEngagePVP@@AAEXH@Z ; CEngagePVP::ClearUser

; 530  : 			}

  003da	eb 9c		 jmp	 SHORT $LN11@ProcessRun
$LN12@ProcessRun:

; 531  : 		}

  003dc	e9 55 01 00 00	 jmp	 $LN1@ProcessRun
$LN27@ProcessRun:

; 532  : 		else
; 533  : 		{
; 534  : 			if(this->m_minToAdd < 60)

  003e1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003e4	83 78 70 3c	 cmp	 DWORD PTR [eax+112], 60	; 0000003cH
  003e8	0f 83 9d 00 00
	00		 jae	 $LN29@ProcessRun

; 535  : 			{
; 536  : 				if(this->m_tickCount+(this->m_minToAdd*60*1000) <= dwTickCount)

  003ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003f1	6b 48 70 3c	 imul	 ecx, DWORD PTR [eax+112], 60
  003f5	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  003fb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003fe	03 50 6c	 add	 edx, DWORD PTR [eax+108]
  00401	3b 95 dc fe ff
	ff		 cmp	 edx, DWORD PTR _dwTickCount$[ebp]
  00407	77 7d		 ja	 SHORT $LN31@ProcessRun

; 537  : 				{
; 538  : 					for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();++it)

  00409	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _it$12[ebp]
  0040f	50		 push	 eax
  00410	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00413	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
  00418	eb 0b		 jmp	 SHORT $LN16@ProcessRun
$LN14@ProcessRun:
  0041a	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _it$12[ebp]
  00420	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
$LN16@ProcessRun:
  00425	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0042b	50		 push	 eax
  0042c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0042f	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  00434	50		 push	 eax
  00435	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _it$12[ebp]
  0043b	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  00440	0f b6 c8	 movzx	 ecx, al
  00443	85 c9		 test	 ecx, ecx
  00445	74 30		 je	 SHORT $LN15@ProcessRun

; 539  : 					{
; 540  : 						notice.SendToUser(*it, "[PVP Event] quedan %d minutos", 60-this->m_minToAdd);

  00447	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0044a	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0044f	2b 48 70	 sub	 ecx, DWORD PTR [eax+112]
  00452	51		 push	 ecx
  00453	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BLGPGPMM@?$FLPVP?5Event?$FN?5quedan?5?$CFd?5minutos@
  00458	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _it$12[ebp]
  0045e	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00463	8b 10		 mov	 edx, DWORD PTR [eax]
  00465	52		 push	 edx
  00466	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _notice$[ebp]
  0046c	50		 push	 eax
  0046d	e8 00 00 00 00	 call	 ?SendToUser@TNotice@@QAAXHPADZZ ; TNotice::SendToUser
  00472	83 c4 10	 add	 esp, 16			; 00000010H

; 541  : 					}

  00475	eb a3		 jmp	 SHORT $LN14@ProcessRun
$LN15@ProcessRun:

; 542  : 
; 543  : 					this->m_minToAdd += 15;

  00477	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0047a	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0047d	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00480	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00483	89 4a 70	 mov	 DWORD PTR [edx+112], ecx
$LN31@ProcessRun:

; 544  : 				}
; 545  : 			}

  00486	e9 ab 00 00 00	 jmp	 $LN1@ProcessRun
$LN29@ProcessRun:

; 546  : 			else
; 547  : 			{
; 548  : 				if(this->m_tickCount+((this->m_minToAdd-1)*60*1000)+(this->m_secToAdd*1000) <= dwTickCount)

  0048b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0048e	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00491	83 e9 01	 sub	 ecx, 1
  00494	6b d1 3c	 imul	 edx, ecx, 60
  00497	69 c2 e8 03 00
	00		 imul	 eax, edx, 1000
  0049d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004a0	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  004a3	03 d0		 add	 edx, eax
  004a5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004a8	69 48 74 e8 03
	00 00		 imul	 ecx, DWORD PTR [eax+116], 1000
  004af	03 d1		 add	 edx, ecx
  004b1	3b 95 dc fe ff
	ff		 cmp	 edx, DWORD PTR _dwTickCount$[ebp]
  004b7	77 7d		 ja	 SHORT $LN1@ProcessRun

; 549  : 				{
; 550  : 					for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();++it)

  004b9	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _it$11[ebp]
  004bf	50		 push	 eax
  004c0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004c3	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
  004c8	eb 0b		 jmp	 SHORT $LN19@ProcessRun
$LN17@ProcessRun:
  004ca	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _it$11[ebp]
  004d0	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
$LN19@ProcessRun:
  004d5	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  004db	50		 push	 eax
  004dc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004df	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  004e4	50		 push	 eax
  004e5	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _it$11[ebp]
  004eb	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  004f0	0f b6 c8	 movzx	 ecx, al
  004f3	85 c9		 test	 ecx, ecx
  004f5	74 30		 je	 SHORT $LN18@ProcessRun

; 551  : 					{
; 552  : 						notice.SendToUser(*it, "[PVP Event] quedan %d segundos", 60-this->m_secToAdd);

  004f7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  004fa	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  004ff	2b 48 74	 sub	 ecx, DWORD PTR [eax+116]
  00502	51		 push	 ecx
  00503	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@NIIDFAII@?$FLPVP?5Event?$FN?5quedan?5?$CFd?5segundos@
  00508	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _it$11[ebp]
  0050e	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00513	8b 10		 mov	 edx, DWORD PTR [eax]
  00515	52		 push	 edx
  00516	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _notice$[ebp]
  0051c	50		 push	 eax
  0051d	e8 00 00 00 00	 call	 ?SendToUser@TNotice@@QAAXHPADZZ ; TNotice::SendToUser
  00522	83 c4 10	 add	 esp, 16			; 00000010H

; 553  : 					}

  00525	eb a3		 jmp	 SHORT $LN17@ProcessRun
$LN18@ProcessRun:

; 554  : 
; 555  : 					this->m_secToAdd += 15;

  00527	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0052a	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  0052d	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00530	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00533	89 4a 74	 mov	 DWORD PTR [edx+116], ecx
$LN1@ProcessRun:

; 556  : 				}
; 557  : 			}
; 558  : 		}
; 559  : 	}
; 560  : }

  00536	5f		 pop	 edi
  00537	5e		 pop	 esi
  00538	5b		 pop	 ebx
  00539	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0053c	33 cd		 xor	 ecx, ebp
  0053e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00543	8b e5		 mov	 esp, ebp
  00545	5d		 pop	 ebp
  00546	c3		 ret	 0
?ProcessRunning@CEngagePVP@@AAEXXZ ENDP			; CEngagePVP::ProcessRunning
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?ProcessClosed@CEngagePVP@@AAEXXZ
_TEXT	SEGMENT
$T1 = -408						; size = 4
$T2 = -404						; size = 4
$T3 = -400						; size = 4
$T4 = -396						; size = 4
$T5 = -392						; size = 4
$T6 = -388						; size = 4
_it$7 = -320						; size = 4
_lpObj$8 = -316						; size = 4
_it$9 = -312						; size = 4
_it$10 = -308						; size = 4
_notice$ = -304						; size = 272
_dwTickCount$ = -32					; size = 4
_eventTime$11 = -28					; size = 4
_it$12 = -24						; size = 4
_ltime$ = -20						; size = 8
_today$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcessClosed@CEngagePVP@@AAEXXZ PROC			; CEngagePVP::ProcessClosed, COMDAT
; _this$ = ecx

; 346  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 01 00
	00		 sub	 esp, 408		; 00000198H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 347  : 	tm * today;
; 348  : 	time_t ltime;
; 349  : 
; 350  : 	time( &ltime );

  00019	8d 45 ec	 lea	 eax, DWORD PTR _ltime$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _time
  00022	83 c4 04	 add	 esp, 4

; 351  : 	today = localtime( &ltime );

  00025	8d 45 ec	 lea	 eax, DWORD PTR _ltime$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _localtime
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f4	 mov	 DWORD PTR _today$[ebp], eax

; 352  : 
; 353  : 	if(this->m_nextTime == NULL)

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  0003b	0f 85 dc 00 00
	00		 jne	 $LN14@ProcessClo

; 354  : 	{
; 355  : 		for(EVENT_TIME_LIST::iterator it = this->m_timeList[today->tm_wday].begin();it != this->m_timeList[today->tm_wday].end();++it)

  00041	8d 45 e8	 lea	 eax, DWORD PTR _it$12[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _today$[ebp]
  00048	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  00052	e8 00 00 00 00	 call	 ?begin@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::begin
  00057	eb 08		 jmp	 SHORT $LN4@ProcessClo
$LN2@ProcessClo:
  00059	8d 4d e8	 lea	 ecx, DWORD PTR _it$12[ebp]
  0005c	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator++
$LN4@ProcessClo:
  00061	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00067	50		 push	 eax
  00068	8b 4d f4	 mov	 ecx, DWORD PTR _today$[ebp]
  0006b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0006e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8d 4c d0 10	 lea	 ecx, DWORD PTR [eax+edx*8+16]
  00075	e8 00 00 00 00	 call	 ?end@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@2@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::end
  0007a	50		 push	 eax
  0007b	8d 4d e8	 lea	 ecx, DWORD PTR _it$12[ebp]
  0007e	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator!=
  00083	0f b6 c8	 movzx	 ecx, al
  00086	85 c9		 test	 ecx, ecx
  00088	0f 84 8f 00 00
	00		 je	 $LN14@ProcessClo

; 356  : 		{
; 357  : 			EVENT_TIME &eventTime = *it;

  0008e	8d 4d e8	 lea	 ecx, DWORD PTR _it$12[ebp]
  00091	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UEVENT_TIME@@@std@@@std@@@std@@QBEAAUEVENT_TIME@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<EVENT_TIME> > >::operator*
  00096	89 45 e4	 mov	 DWORD PTR _eventTime$11[ebp], eax

; 358  : 
; 359  : 			if(this->m_nextTime == NULL)

  00099	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  000a0	75 26		 jne	 SHORT $LN15@ProcessClo

; 360  : 			{
; 361  : 				if(eventTime.iHour >= today->tm_hour && eventTime.iMin >= today->tm_min)

  000a2	8b 45 e4	 mov	 eax, DWORD PTR _eventTime$11[ebp]
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR _today$[ebp]
  000a8	8b 10		 mov	 edx, DWORD PTR [eax]
  000aa	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000ad	7c 17		 jl	 SHORT $LN17@ProcessClo
  000af	8b 45 e4	 mov	 eax, DWORD PTR _eventTime$11[ebp]
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR _today$[ebp]
  000b5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b8	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000bb	7c 09		 jl	 SHORT $LN17@ProcessClo

; 362  : 					this->m_nextTime = &eventTime;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 4d e4	 mov	 ecx, DWORD PTR _eventTime$11[ebp]
  000c3	89 48 68	 mov	 DWORD PTR [eax+104], ecx
$LN17@ProcessClo:

; 363  : 			}

  000c6	eb 50		 jmp	 SHORT $LN16@ProcessClo
$LN15@ProcessClo:

; 364  : 			else
; 365  : 			{
; 366  : 				if(eventTime.iHour >= today->tm_hour && eventTime.iMin >= today->tm_min && (eventTime.iHour < this->m_nextTime->iHour || (eventTime.iHour < this->m_nextTime->iHour && eventTime.iMin < today->tm_min)))

  000c8	8b 45 e4	 mov	 eax, DWORD PTR _eventTime$11[ebp]
  000cb	8b 4d f4	 mov	 ecx, DWORD PTR _today$[ebp]
  000ce	8b 10		 mov	 edx, DWORD PTR [eax]
  000d0	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000d3	7c 43		 jl	 SHORT $LN16@ProcessClo
  000d5	8b 45 e4	 mov	 eax, DWORD PTR _eventTime$11[ebp]
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR _today$[ebp]
  000db	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000de	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000e1	7c 35		 jl	 SHORT $LN16@ProcessClo
  000e3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  000e9	8b 55 e4	 mov	 edx, DWORD PTR _eventTime$11[ebp]
  000ec	8b 02		 mov	 eax, DWORD PTR [edx]
  000ee	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000f0	7c 1d		 jl	 SHORT $LN19@ProcessClo
  000f2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  000f8	8b 55 e4	 mov	 edx, DWORD PTR _eventTime$11[ebp]
  000fb	8b 02		 mov	 eax, DWORD PTR [edx]
  000fd	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000ff	7d 17		 jge	 SHORT $LN16@ProcessClo
  00101	8b 45 e4	 mov	 eax, DWORD PTR _eventTime$11[ebp]
  00104	8b 4d f4	 mov	 ecx, DWORD PTR _today$[ebp]
  00107	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0010a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0010d	7d 09		 jge	 SHORT $LN16@ProcessClo
$LN19@ProcessClo:

; 367  : 					this->m_nextTime = &eventTime;

  0010f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00112	8b 4d e4	 mov	 ecx, DWORD PTR _eventTime$11[ebp]
  00115	89 48 68	 mov	 DWORD PTR [eax+104], ecx
$LN16@ProcessClo:

; 368  : 			}
; 369  : 		}

  00118	e9 3c ff ff ff	 jmp	 $LN2@ProcessClo
$LN14@ProcessClo:

; 370  : 	}
; 371  : 
; 372  : 	DWORD dwTickCount = GetTickCount();

  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00123	89 45 e0	 mov	 DWORD PTR _dwTickCount$[ebp], eax

; 373  : 
; 374  : 	TNotice notice;

  00126	6a 00		 push	 0
  00128	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  0012e	e8 00 00 00 00	 call	 ??0TNotice@@QAE@E@Z	; TNotice::TNotice

; 375  : 
; 376  : 	if(this->m_tickCount != 0 && this->m_tickCount+(5*60*1000) <= dwTickCount)

  00133	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00136	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  0013a	0f 84 35 02 00
	00		 je	 $LN20@ProcessClo
  00140	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00143	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00146	81 c1 e0 93 04
	00		 add	 ecx, 300000		; 000493e0H
  0014c	3b 4d e0	 cmp	 ecx, DWORD PTR _dwTickCount$[ebp]
  0014f	0f 87 20 02 00
	00		 ja	 $LN20@ProcessClo

; 377  : 	{
; 378  : 		for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();)

  00155	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _it$10[ebp]
  0015b	50		 push	 eax
  0015c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
$LN7@ProcessClo:
  00164	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0016a	50		 push	 eax
  0016b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  00173	50		 push	 eax
  00174	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  0017a	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  0017f	0f b6 c8	 movzx	 ecx, al
  00182	85 c9		 test	 ecx, ecx
  00184	74 77		 je	 SHORT $LN6@ProcessClo

; 379  : 		{
; 380  : 			if(gObjIsConnected(*it) == FALSE || gObj[*it].m_stateEngagePVP == PVP_USER_NONE)

  00186	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  0018c	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00191	8b 00		 mov	 eax, DWORD PTR [eax]
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00199	83 c4 04	 add	 esp, 4
  0019c	85 c0		 test	 eax, eax
  0019e	74 21		 je	 SHORT $LN24@ProcessClo
  001a0	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  001a6	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  001ab	69 00 a0 1b 00
	00		 imul	 eax, DWORD PTR [eax], 7072
  001b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b7	83 bc 01 80 1a
	00 00 00	 cmp	 DWORD PTR [ecx+eax+6784], 0
  001bf	75 2c		 jne	 SHORT $LN22@ProcessClo
$LN24@ProcessClo:

; 381  : 			{
; 382  : 				it = this->m_userList.erase(it);

  001c1	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _it$10[ebp]
  001c7	89 85 74 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  001cd	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  001d3	51		 push	 ecx
  001d4	8d 95 70 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001da	52		 push	 edx
  001db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001de	e8 00 00 00 00	 call	 ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ; std::list<int,std::allocator<int> >::erase
  001e3	8b 00		 mov	 eax, DWORD PTR [eax]
  001e5	89 85 cc fe ff
	ff		 mov	 DWORD PTR _it$10[ebp], eax

; 383  : 			}

  001eb	eb 0b		 jmp	 SHORT $LN23@ProcessClo
$LN22@ProcessClo:

; 384  : 			else
; 385  : 				++it;

  001ed	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  001f3	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
$LN23@ProcessClo:

; 386  : 		}

  001f8	e9 67 ff ff ff	 jmp	 $LN7@ProcessClo
$LN6@ProcessClo:

; 387  : 
; 388  : 		if(this->m_userList.size() >= 2)

  001fd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	e8 00 00 00 00	 call	 ?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::size
  00205	83 f8 02	 cmp	 eax, 2
  00208	0f 82 dc 00 00
	00		 jb	 $LN25@ProcessClo

; 389  : 		{
; 390  : 			LogAdd("[PVP System] Event Start");

  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HNNMMGEC@?$FLPVP?5System?$FN?5Event?5Start@
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00219	83 c4 04	 add	 esp, 4

; 391  : 
; 392  : 			notice.SendToAllUser("[PVP Event] Inicio el evento! - %d jugadores", this->m_userList.size());

  0021c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0021f	e8 00 00 00 00	 call	 ?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::size
  00224	50		 push	 eax
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FJOHLNMO@?$FLPVP?5Event?$FN?5Inicio?5el?5evento?$CB?5?9@
  0022a	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _notice$[ebp]
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  00236	83 c4 0c	 add	 esp, 12			; 0000000cH

; 393  : 
; 394  : 			for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();++it)

  00239	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _it$9[ebp]
  0023f	50		 push	 eax
  00240	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00243	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
  00248	eb 0b		 jmp	 SHORT $LN10@ProcessClo
$LN8@ProcessClo:
  0024a	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _it$9[ebp]
  00250	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
$LN10@ProcessClo:
  00255	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0025b	50		 push	 eax
  0025c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  00264	50		 push	 eax
  00265	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _it$9[ebp]
  0026b	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  00270	0f b6 c8	 movzx	 ecx, al
  00273	85 c9		 test	 ecx, ecx
  00275	74 47		 je	 SHORT $LN9@ProcessClo

; 395  : 			{
; 396  : 				LPOBJECTSTRUCT lpObj = &gObj[*it];

  00277	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _it$9[ebp]
  0027d	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00282	69 00 a0 1b 00
	00		 imul	 eax, DWORD PTR [eax], 7072
  00288	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0028e	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _lpObj$8[ebp], eax

; 397  : 
; 398  : 				lpObj->m_stateEngagePVP = PVP_USER_PLAYING;

  00294	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$8[ebp]
  0029a	c7 80 80 1a 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+6784], 2

; 399  : 
; 400  : 				//gObjMoveGate(*it, 58);
; 401  : 				gObjMoveGate(*it, 58);

  002a4	6a 3a		 push	 58			; 0000003aH
  002a6	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _it$9[ebp]
  002ac	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  002b1	8b 00		 mov	 eax, DWORD PTR [eax]
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  002b9	83 c4 08	 add	 esp, 8

; 402  : 
; 403  : 				//gObjTeleport(lpObj->m_Index, PVP_EVENT_MAP, 30+rand()%40, 30+rand()%40);
; 404  : 			}

  002bc	eb 8c		 jmp	 SHORT $LN8@ProcessClo
$LN9@ProcessClo:

; 405  : 
; 406  : 			this->m_minToAdd = 0;

  002be	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002c1	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 407  : 			this->m_secToAdd = 0;

  002c8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002cb	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0

; 408  : 			this->m_tickCount = dwTickCount;

  002d2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002d5	8b 4d e0	 mov	 ecx, DWORD PTR _dwTickCount$[ebp]
  002d8	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 409  : 
; 410  : 			this->m_eventState = EVENT_RUNNING;

  002db	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002de	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [eax+72], 2

; 411  : 		}

  002e5	e9 86 00 00 00	 jmp	 $LN26@ProcessClo
$LN25@ProcessClo:

; 412  : 		else
; 413  : 		{
; 414  : 			for(USER_INDEX_LIST::iterator it = this->m_userList.begin();it != this->m_userList.end();++it)

  002ea	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _it$7[ebp]
  002f0	50		 push	 eax
  002f1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002f4	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
  002f9	eb 0b		 jmp	 SHORT $LN13@ProcessClo
$LN11@ProcessClo:
  002fb	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00301	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
$LN13@ProcessClo:
  00306	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0030c	50		 push	 eax
  0030d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00310	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  00315	50		 push	 eax
  00316	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  0031c	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  00321	0f b6 c8	 movzx	 ecx, al
  00324	85 c9		 test	 ecx, ecx
  00326	74 18		 je	 SHORT $LN12@ProcessClo

; 415  : 			{
; 416  : 				this->ClearUser(*it);

  00328	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  0032e	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00333	8b 00		 mov	 eax, DWORD PTR [eax]
  00335	50		 push	 eax
  00336	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00339	e8 00 00 00 00	 call	 ?ClearUser@CEngagePVP@@AAEXH@Z ; CEngagePVP::ClearUser

; 417  : 			}

  0033e	eb bb		 jmp	 SHORT $LN11@ProcessClo
$LN12@ProcessClo:

; 418  : 
; 419  : 			this->m_userList.clear();

  00340	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00343	e8 00 00 00 00	 call	 ?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ ; std::list<int,std::allocator<int> >::clear

; 420  : 
; 421  : 			this->m_nextTime = NULL;

  00348	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0034b	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 422  : 			this->m_tickCount = 0;

  00352	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00355	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0

; 423  : 			this->m_minToAdd = 0;

  0035c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0035f	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 424  : 			this->m_secToAdd = 0;

  00366	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00369	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0
$LN26@ProcessClo:

; 425  : 		}
; 426  : 	}

  00370	e9 0f 01 00 00	 jmp	 $LN1@ProcessClo
$LN20@ProcessClo:

; 427  : 	else if(this->m_tickCount != 0 || (this->m_nextTime != NULL && (today->tm_hour == this->m_nextTime->iHour && today->tm_min >= this->m_nextTime->iMin-5)))

  00375	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00378	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  0037c	75 39		 jne	 SHORT $LN28@ProcessClo
  0037e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00381	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00385	0f 84 f9 00 00
	00		 je	 $LN1@ProcessClo
  0038b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0038e	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00391	8b 55 f4	 mov	 edx, DWORD PTR _today$[ebp]
  00394	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00397	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00399	0f 85 e5 00 00
	00		 jne	 $LN1@ProcessClo
  0039f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003a2	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  003a5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  003a8	83 ea 05	 sub	 edx, 5
  003ab	8b 45 f4	 mov	 eax, DWORD PTR _today$[ebp]
  003ae	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  003b1	0f 8c cd 00 00
	00		 jl	 $LN1@ProcessClo
$LN28@ProcessClo:

; 428  : 	{
; 429  : 		if(this->m_tickCount == 0)

  003b7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003ba	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  003be	75 1d		 jne	 SHORT $LN29@ProcessClo

; 430  : 		{
; 431  : 			this->m_tickCount = dwTickCount;

  003c0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003c3	8b 4d e0	 mov	 ecx, DWORD PTR _dwTickCount$[ebp]
  003c6	89 48 6c	 mov	 DWORD PTR [eax+108], ecx

; 432  : 			this->m_minToAdd = 0;

  003c9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003cc	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 433  : 			this->m_secToAdd = 0;

  003d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003d6	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0
$LN29@ProcessClo:

; 434  : 		}
; 435  : 
; 436  : 		if(this->m_minToAdd < 4)

  003dd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003e0	83 78 70 04	 cmp	 DWORD PTR [eax+112], 4
  003e4	73 49		 jae	 SHORT $LN30@ProcessClo

; 437  : 		{
; 438  : 			if(this->m_tickCount+(this->m_minToAdd*60*1000) <= dwTickCount)

  003e6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003e9	6b 48 70 3c	 imul	 ecx, DWORD PTR [eax+112], 60
  003ed	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  003f3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003f6	03 50 6c	 add	 edx, DWORD PTR [eax+108]
  003f9	3b 55 e0	 cmp	 edx, DWORD PTR _dwTickCount$[ebp]
  003fc	77 2f		 ja	 SHORT $LN32@ProcessClo

; 439  : 			{
; 440  : 				notice.SendToAllUser("[PVP Event] Faltan %d minutos para el inicio", 5-this->m_minToAdd);

  003fe	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00401	b9 05 00 00 00	 mov	 ecx, 5
  00406	2b 48 70	 sub	 ecx, DWORD PTR [eax+112]
  00409	51		 push	 ecx
  0040a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@LEEAJCJL@?$FLPVP?5Event?$FN?5Faltan?5?$CFd?5minutos?5p@
  0040f	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _notice$[ebp]
  00415	52		 push	 edx
  00416	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  0041b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 441  : 
; 442  : 				this->m_minToAdd++;

  0041e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00421	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00424	83 c1 01	 add	 ecx, 1
  00427	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0042a	89 4a 70	 mov	 DWORD PTR [edx+112], ecx
$LN32@ProcessClo:

; 443  : 			}
; 444  : 		}

  0042d	eb 55		 jmp	 SHORT $LN1@ProcessClo
$LN30@ProcessClo:

; 445  : 		else
; 446  : 		{
; 447  : 			if(this->m_tickCount+(this->m_minToAdd*60*1000)+(this->m_secToAdd*1000) <= dwTickCount)

  0042f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00432	6b 48 70 3c	 imul	 ecx, DWORD PTR [eax+112], 60
  00436	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  0043c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0043f	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00442	03 ca		 add	 ecx, edx
  00444	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00447	69 42 74 e8 03
	00 00		 imul	 eax, DWORD PTR [edx+116], 1000
  0044e	03 c8		 add	 ecx, eax
  00450	3b 4d e0	 cmp	 ecx, DWORD PTR _dwTickCount$[ebp]
  00453	77 2f		 ja	 SHORT $LN1@ProcessClo

; 448  : 			{
; 449  : 				notice.SendToAllUser("[PVP Event] Faltan %d segundos para el inicio", 60-this->m_secToAdd);

  00455	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00458	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0045d	2b 48 74	 sub	 ecx, DWORD PTR [eax+116]
  00460	51		 push	 ecx
  00461	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@CBGOEHLE@?$FLPVP?5Event?$FN?5Faltan?5?$CFd?5segundos?5@
  00466	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR _notice$[ebp]
  0046c	52		 push	 edx
  0046d	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  00472	83 c4 0c	 add	 esp, 12			; 0000000cH

; 450  : 
; 451  : 				this->m_secToAdd += 15;

  00475	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00478	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  0047b	83 c1 0f	 add	 ecx, 15			; 0000000fH
  0047e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00481	89 4a 74	 mov	 DWORD PTR [edx+116], ecx
$LN1@ProcessClo:

; 452  : 			}
; 453  : 		}
; 454  : 	}
; 455  : }

  00484	5f		 pop	 edi
  00485	5e		 pop	 esi
  00486	5b		 pop	 ebx
  00487	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0048a	33 cd		 xor	 ecx, ebp
  0048c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00491	8b e5		 mov	 esp, ebp
  00493	5d		 pop	 ebp
  00494	c3		 ret	 0
?ProcessClosed@CEngagePVP@@AAEXXZ ENDP			; CEngagePVP::ProcessClosed
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?ClearUser@CEngagePVP@@AAEXH@Z
_TEXT	SEGMENT
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?ClearUser@CEngagePVP@@AAEXH@Z PROC			; CEngagePVP::ClearUser, COMDAT
; _this$ = ecx

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 61   : 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  0000c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00013	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00019	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 62   : 
; 63   : 	if(lpObj->m_stateEngagePVP != PVP_USER_NONE)

  0001c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001f	83 b8 80 1a 00
	00 00		 cmp	 DWORD PTR [eax+6784], 0
  00026	74 2c		 je	 SHORT $LN1@ClearUser

; 64   : 	{
; 65   : 		lpObj->m_stateEngagePVP = PVP_USER_NONE;

  00028	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002b	c7 80 80 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6784], 0

; 66   : 
; 67   : 		if(lpObj->MapNumber == PVP_EVENT_MAP)

  00035	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00038	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0003f	83 f9 09	 cmp	 ecx, 9
  00042	75 10		 jne	 SHORT $LN1@ClearUser

; 68   : 			gObjMoveGate(lpObj->m_Index, 22);

  00044	6a 16		 push	 22			; 00000016H
  00046	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00051	83 c4 08	 add	 esp, 8
$LN1@ClearUser:

; 69   : 	}
; 70   : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
?ClearUser@CEngagePVP@@AAEXH@Z ENDP			; CEngagePVP::ClearUser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?Clear@CEngagePVP@@AAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?Clear@CEngagePVP@@AAEXXZ PROC				; CEngagePVP::Clear, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 	if(this->m_eventState != EVENT_RUNNING && this->m_eventState != EVENT_FINISH)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 48 02	 cmp	 DWORD PTR [eax+72], 2
  00013	74 70		 je	 SHORT $LN1@Clear
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 48 03	 cmp	 DWORD PTR [eax+72], 3
  0001c	74 67		 je	 SHORT $LN1@Clear

; 44   : 	{
; 45   : 		for(int i = 0;i < DAYS_OF_WEEK;++i)

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@Clear
$LN2@Clear:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Clear:
  00030	83 7d f8 07	 cmp	 DWORD PTR _i$1[ebp], 7
  00034	7d 11		 jge	 SHORT $LN3@Clear

; 46   : 			this->m_timeList[i].clear();

  00036	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	8d 4c c1 10	 lea	 ecx, DWORD PTR [ecx+eax*8+16]
  00040	e8 00 00 00 00	 call	 ?clear@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXXZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::clear
  00045	eb e0		 jmp	 SHORT $LN2@Clear
$LN3@Clear:

; 47   : 
; 48   : 		this->m_rewardList.clear();

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	83 c1 08	 add	 ecx, 8
  0004d	e8 00 00 00 00	 call	 ?clear@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXXZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::clear

; 49   : 		this->m_rewardList.clear();

  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	83 c1 08	 add	 ecx, 8
  00058	e8 00 00 00 00	 call	 ?clear@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXXZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::clear

; 50   : 
; 51   : 		this->m_nextTime = NULL;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 52   : 
; 53   : 		this->m_tickCount = 0;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0

; 54   : 		this->m_minToAdd = 0;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0

; 55   : 		this->m_secToAdd = 0;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	c7 40 74 00 00
	00 00		 mov	 DWORD PTR [eax+116], 0
$LN1@Clear:

; 56   : 	}
; 57   : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?Clear@CEngagePVP@@AAEXXZ ENDP				; CEngagePVP::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?DeleteUser@CEngagePVP@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
_it$ = -12						; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?DeleteUser@CEngagePVP@@QAEXH@Z PROC			; CEngagePVP::DeleteUser, COMDAT
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  0000c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00013	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00019	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 75   : 
; 76   : 	EnterCriticalSection(&this->m_criticalSection);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 c0 50	 add	 eax, 80			; 00000050H
  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 77   : 
; 78   : 	USER_INDEX_LIST::iterator it = this->m_userList.begin();

  00029	8d 45 f4	 lea	 eax, DWORD PTR _it$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
  00035	eb 08		 jmp	 SHORT $LN4@DeleteUser
$LN2@DeleteUser:

; 79   : 
; 80   : 	for(;it != this->m_userList.end();++it)

  00037	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  0003a	e8 00 00 00 00	 call	 ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
$LN4@DeleteUser:
  0003f	8d 45 b0	 lea	 eax, DWORD PTR $T4[ebp]
  00042	50		 push	 eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  0004b	50		 push	 eax
  0004c	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  0004f	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  00054	0f b6 c8	 movzx	 ecx, al
  00057	85 c9		 test	 ecx, ecx
  00059	74 13		 je	 SHORT $LN3@DeleteUser

; 81   : 	{
; 82   : 		if(*it == aIndex)

  0005b	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  0005e	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	3b 45 08	 cmp	 eax, DWORD PTR _aIndex$[ebp]
  00068	75 02		 jne	 SHORT $LN5@DeleteUser

; 83   : 		{
; 84   : 			break;

  0006a	eb 02		 jmp	 SHORT $LN3@DeleteUser
$LN5@DeleteUser:

; 85   : 		}
; 86   : 	}

  0006c	eb c9		 jmp	 SHORT $LN2@DeleteUser
$LN3@DeleteUser:

; 87   : 
; 88   : 	if(it != this->m_userList.end())

  0006e	8d 45 ac	 lea	 eax, DWORD PTR $T3[ebp]
  00071	50		 push	 eax
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
  0007a	50		 push	 eax
  0007b	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  0007e	e8 00 00 00 00	 call	 ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
  00083	0f b6 c8	 movzx	 ecx, al
  00086	85 c9		 test	 ecx, ecx
  00088	74 16		 je	 SHORT $LN6@DeleteUser

; 89   : 	{
; 90   : 		this->m_userList.erase(it);

  0008a	8b 45 f4	 mov	 eax, DWORD PTR _it$[ebp]
  0008d	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
  00090	8b 4d a8	 mov	 ecx, DWORD PTR $T2[ebp]
  00093	51		 push	 ecx
  00094	8d 55 a4	 lea	 edx, DWORD PTR $T1[ebp]
  00097	52		 push	 edx
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ; std::list<int,std::allocator<int> >::erase
$LN6@DeleteUser:

; 91   : 	}
; 92   : 
; 93   : 	if(lpObj->m_stateEngagePVP != PVP_USER_NONE)

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a3	83 b8 80 1a 00
	00 00		 cmp	 DWORD PTR [eax+6784], 0
  000aa	74 0c		 je	 SHORT $LN7@DeleteUser

; 94   : 	{
; 95   : 		this->ClearUser(aIndex);

  000ac	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000af	50		 push	 eax
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?ClearUser@CEngagePVP@@AAEXH@Z ; CEngagePVP::ClearUser
$LN7@DeleteUser:

; 96   : 	}
; 97   : 
; 98   : 	LeaveCriticalSection(&this->m_criticalSection);

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	83 c0 50	 add	 eax, 80			; 00000050H
  000be	50		 push	 eax
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 99   : }

  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 04 00	 ret	 4
?DeleteUser@CEngagePVP@@QAEXH@Z ENDP			; CEngagePVP::DeleteUser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?ProcessUserRequest@CEngagePVP@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv87 = -352						; size = 4
tv78 = -352						; size = 4
tv88 = -348						; size = 4
tv79 = -348						; size = 4
_notice$1 = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?ProcessUserRequest@CEngagePVP@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CEngagePVP::ProcessUserRequest, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 	EnterCriticalSection(&this->m_criticalSection);

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 c0 50	 add	 eax, 80			; 00000050H
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 104  : 	if(this->m_eventState == EVENT_CLOSED && this->m_tickCount != 0)

  00026	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 78 48 01	 cmp	 DWORD PTR [eax+72], 1
  0002d	0f 85 1a 01 00
	00		 jne	 $LN2@ProcessUse
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  0003a	0f 84 0d 01 00
	00		 je	 $LN2@ProcessUse

; 105  : 	{
; 106  : 		if(lpObj->m_stateEngagePVP == PVP_USER_NONE && !CHECK_BLOODCASTLE(lpObj->MapNumber)
; 107  : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 108  : 			&& !CHECK_CHAOSCASTLE(lpObj->MapNumber) 
; 109  : #endif
; 110  : #ifdef DEVILSQUARE_EXTEND_20050221
; 111  : 			&& !CHECK_DEVILSQUARE(lpObj->MapNumber)
; 112  : #else
; 113  : 			&& lpObj->MapNumber != 9

  00040	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00043	83 b8 80 1a 00
	00 00		 cmp	 DWORD PTR [eax+6784], 0
  0004a	0f 85 fd 00 00
	00		 jne	 $LN2@ProcessUse
  00050	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0005a	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0005d	7d 0c		 jge	 SHORT $LN7@ProcessUse
  0005f	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv79[ebp], 0
  00069	eb 31		 jmp	 SHORT $LN8@ProcessUse
$LN7@ProcessUse:
  0006b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0006e	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00075	83 f8 11	 cmp	 eax, 17			; 00000011H
  00078	7e 0c		 jle	 SHORT $LN5@ProcessUse
  0007a	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
  00084	eb 0a		 jmp	 SHORT $LN6@ProcessUse
$LN5@ProcessUse:
  00086	c7 85 a0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv78[ebp], 1
$LN6@ProcessUse:
  00090	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR tv78[ebp]
  00096	89 8d a4 fe ff
	ff		 mov	 DWORD PTR tv79[ebp], ecx
$LN8@ProcessUse:
  0009c	83 bd a4 fe ff
	ff 00		 cmp	 DWORD PTR tv79[ebp], 0
  000a3	0f 85 a4 00 00
	00		 jne	 $LN2@ProcessUse
  000a9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ac	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000b3	83 f9 12	 cmp	 ecx, 18			; 00000012H
  000b6	7d 0c		 jge	 SHORT $LN11@ProcessUse
  000b8	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv88[ebp], 0
  000c2	eb 31		 jmp	 SHORT $LN12@ProcessUse
$LN11@ProcessUse:
  000c4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c7	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000ce	83 f8 17	 cmp	 eax, 23			; 00000017H
  000d1	7e 0c		 jle	 SHORT $LN9@ProcessUse
  000d3	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv87[ebp], 0
  000dd	eb 0a		 jmp	 SHORT $LN10@ProcessUse
$LN9@ProcessUse:
  000df	c7 85 a0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv87[ebp], 1
$LN10@ProcessUse:
  000e9	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR tv87[ebp]
  000ef	89 8d a4 fe ff
	ff		 mov	 DWORD PTR tv88[ebp], ecx
$LN12@ProcessUse:
  000f5	83 bd a4 fe ff
	ff 00		 cmp	 DWORD PTR tv88[ebp], 0
  000fc	75 4f		 jne	 SHORT $LN2@ProcessUse
  000fe	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00101	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00108	83 f9 09	 cmp	 ecx, 9
  0010b	74 40		 je	 SHORT $LN2@ProcessUse

; 114  : #endif
; 115  : #ifdef MODIFY_ILLUSION_TEMPLE_20070629
; 116  : 			&& !CHECK_ILLUSION_TEMPLE(lpObj->MapNumber)
; 117  : #endif
; 118  : 			)
; 119  : 		{
; 120  : 			lpObj->m_stateEngagePVP = PVP_USER_REGISTERED;

  0010d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00110	c7 80 80 1a 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+6784], 1

; 121  : 			this->m_userList.push_back(lpObj->m_Index);

  0011a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	e8 00 00 00 00	 call	 ?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::push_back

; 122  : 
; 123  : 			TNotice notice;

  00126	6a 00		 push	 0
  00128	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _notice$1[ebp]
  0012e	e8 00 00 00 00	 call	 ??0TNotice@@QAE@E@Z	; TNotice::TNotice

; 124  : 
; 125  : 			notice.SendToUser(lpObj->m_Index,"[PVP Event] Registrado en el evento");

  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@DKMGGMNL@?$FLPVP?5Event?$FN?5Registrado?5en?5el?5ev@
  00138	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	51		 push	 ecx
  0013e	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _notice$1[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ?SendToUser@TNotice@@QAAXHPADZZ ; TNotice::SendToUser
  0014a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@ProcessUse:

; 126  : 		}
; 127  : 	}
; 128  : 	LeaveCriticalSection(&this->m_criticalSection);

  0014d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00150	83 c0 50	 add	 eax, 80			; 00000050H
  00153	50		 push	 eax
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 129  : }

  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx
  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c2 04 00	 ret	 4
?ProcessUserRequest@CEngagePVP@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CEngagePVP::ProcessUserRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?Run@CEngagePVP@@QAEXXZ
_TEXT	SEGMENT
tv67 = -72						; size = 4
_this$ = -4						; size = 4
?Run@CEngagePVP@@QAEXXZ PROC				; CEngagePVP::Run, COMDAT
; _this$ = ecx

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 305  : 	EnterCriticalSection(&this->m_criticalSection);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 50	 add	 eax, 80			; 00000050H
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 306  : 
; 307  : 	switch(this->m_eventState)

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0001f	89 4d b8	 mov	 DWORD PTR tv67[ebp], ecx
  00022	83 7d b8 01	 cmp	 DWORD PTR tv67[ebp], 1
  00026	74 10		 je	 SHORT $LN5@Run
  00028	83 7d b8 02	 cmp	 DWORD PTR tv67[ebp], 2
  0002c	74 45		 je	 SHORT $LN7@Run
  0002e	83 7d b8 03	 cmp	 DWORD PTR tv67[ebp], 3
  00032	74 49		 je	 SHORT $LN8@Run
  00034	eb 4f		 jmp	 SHORT $LN2@Run

; 308  : 	{
; 309  : 	case EVENT_NONE:
; 310  : 		break;

  00036	eb 4d		 jmp	 SHORT $LN2@Run
$LN5@Run:

; 311  : 
; 312  : 	case EVENT_CLOSED:
; 313  : 		{
; 314  : 			if(this->m_reloadConfig)

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	0f b6 48 4c	 movzx	 ecx, BYTE PTR [eax+76]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 26		 je	 SHORT $LN6@Run

; 315  : 			{
; 316  : 				this->m_eventState = EVENT_NONE;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 317  : 
; 318  : 				this->Load();

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BJNKEBMD@?4?4?2data?2PVPEvent?4cfg@
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?Load@CEngagePVP@@QAEXPBD@Z ; CEngagePVP::Load

; 319  : 
; 320  : 				LeaveCriticalSection(&this->m_criticalSection);

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	83 c0 50	 add	 eax, 80			; 00000050H
  00060	50		 push	 eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 321  : 
; 322  : 				return;

  00067	eb 29		 jmp	 SHORT $LN1@Run
$LN6@Run:

; 323  : 			}
; 324  : 
; 325  : 			this->ProcessClosed();

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?ProcessClosed@CEngagePVP@@AAEXXZ ; CEngagePVP::ProcessClosed

; 326  : 		}
; 327  : 		break;

  00071	eb 12		 jmp	 SHORT $LN2@Run
$LN7@Run:

; 328  : 
; 329  : 	case EVENT_RUNNING:
; 330  : 		{
; 331  : 			this->ProcessRunning();

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?ProcessRunning@CEngagePVP@@AAEXXZ ; CEngagePVP::ProcessRunning

; 332  : 		}
; 333  : 		break;

  0007b	eb 08		 jmp	 SHORT $LN2@Run
$LN8@Run:

; 334  : 
; 335  : 	case EVENT_FINISH:
; 336  : 		{
; 337  : 			this->ProcessFinish();

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?ProcessFinish@CEngagePVP@@AAEXXZ ; CEngagePVP::ProcessFinish
$LN2@Run:

; 338  : 		}
; 339  : 		break;
; 340  : 	};
; 341  : 
; 342  : 	LeaveCriticalSection(&this->m_criticalSection);

  00085	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00088	83 c0 50	 add	 eax, 80			; 00000050H
  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN1@Run:

; 343  : }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?Run@CEngagePVP@@QAEXXZ ENDP				; CEngagePVP::Run
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?Load@CEngagePVP@@QAEXPBD@Z
_TEXT	SEGMENT
tv233 = -156						; size = 4
tv232 = -156						; size = 4
tv231 = -156						; size = 4
tv230 = -156						; size = 4
tv229 = -156						; size = 4
tv228 = -156						; size = 4
tv227 = -156						; size = 4
tv226 = -156						; size = 4
tv225 = -156						; size = 4
tv224 = -156						; size = 4
tv223 = -156						; size = 4
tv222 = -156						; size = 4
tv221 = -156						; size = 4
tv220 = -156						; size = 4
tv195 = -156						; size = 4
tv192 = -156						; size = 4
tv136 = -156						; size = 4
$T2 = -152						; size = 4
$T3 = -148						; size = 4
_exception$4 = -80					; size = 4
_rewardItem$5 = -76					; size = 24
_i$6 = -52						; size = 4
_eventTime$7 = -48					; size = 8
_dayOfWeek$8 = -40					; size = 4
_eventEnabled$9 = -33					; size = 1
_type$10 = -32						; size = 4
_Token$11 = -28						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_filename$ = 8						; size = 4
?Load@CEngagePVP@@QAEXPBD@Z PROC			; CEngagePVP::Load, COMDAT
; _this$ = ecx

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@CEngagePVP@@QAEXPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	50		 push	 eax
  00026	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00029	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00032	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 133  : 	EnterCriticalSection(&this->m_criticalSection);

  00035	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	83 c0 50	 add	 eax, 80			; 00000050H
  0003b	50		 push	 eax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 134  : 
; 135  : 	if(this->m_eventState == EVENT_RUNNING || this->m_eventState == EVENT_FINISH)

  00042	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	83 78 48 02	 cmp	 DWORD PTR [eax+72], 2
  00049	74 09		 je	 SHORT $LN12@Load
  0004b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 78 48 03	 cmp	 DWORD PTR [eax+72], 3
  00052	75 19		 jne	 SHORT $LN11@Load
$LN12@Load:

; 136  : 	{
; 137  : 		this->m_reloadConfig = true;

  00054	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	c6 40 4c 01	 mov	 BYTE PTR [eax+76], 1

; 138  : 
; 139  : 		LeaveCriticalSection(&this->m_criticalSection);

  0005b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	83 c0 50	 add	 eax, 80			; 00000050H
  00061	50		 push	 eax
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 140  : 
; 141  : 		return;

  00068	e9 d6 04 00 00	 jmp	 $LN1@Load
$LN11@Load:

; 142  : 	}
; 143  : 
; 144  : 	this->Clear();

  0006d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?Clear@CEngagePVP@@AAEXXZ ; CEngagePVP::Clear

; 145  : 
; 146  : 	if ( !filename || !strcmp(filename , "") )

  00075	83 7d 08 00	 cmp	 DWORD PTR _filename$[ebp], 0
  00079	74 15		 je	 SHORT $LN14@Load
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00080	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _strcmp
  00089	83 c4 08	 add	 esp, 8
  0008c	85 c0		 test	 eax, eax
  0008e	75 1f		 jne	 SHORT $LN13@Load
$LN14@Load:

; 147  : 	{
; 148  : 		MsgBox("[PVP System] - File load error : File Name Error");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@KKDKFAML@?$FLPVP?5System?$FN?5?9?5File?5load?5error?5@
  00095	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0009a	83 c4 04	 add	 esp, 4

; 149  : 
; 150  : 		LeaveCriticalSection(&this->m_criticalSection);

  0009d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	83 c0 50	 add	 eax, 80			; 00000050H
  000a3	50		 push	 eax
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 151  : 
; 152  : 		return;

  000aa	e9 94 04 00 00	 jmp	 $LN1@Load
$LN13@Load:

; 153  : 	}
; 154  : 
; 155  : 	try

  000af	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 156  : 	{
; 157  : 		SMDFile = fopen(filename, "r");

  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  000bb	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _fopen
  000c4	83 c4 08	 add	 esp, 8
  000c7	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax

; 158  : 
; 159  : 		if ( SMDFile == NULL )

  000cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  000d3	75 23		 jne	 SHORT $LN16@Load

; 160  : 		{
; 161  : 			MsgBox("[PVP System] Info file Load Fail [%s]", filename);

  000d5	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  000d8	50		 push	 eax
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@FELFEBKG@?$FLPVP?5System?$FN?5Info?5file?5Load?5Fai@
  000de	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000e3	83 c4 08	 add	 esp, 8

; 162  : 
; 163  : 			LeaveCriticalSection(&this->m_criticalSection);

  000e6	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	83 c0 50	 add	 eax, 80			; 00000050H
  000ec	50		 push	 eax
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 164  : 
; 165  : 			return;

  000f3	e9 4b 04 00 00	 jmp	 $LN1@Load
$LN16@Load:

; 166  : 		}
; 167  : 
; 168  : 		int Token;
; 169  : 		int type = -1;

  000f8	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _type$10[ebp], -1

; 170  : 
; 171  : 		bool eventEnabled = true;

  000ff	c6 45 df 01	 mov	 BYTE PTR _eventEnabled$9[ebp], 1
$LN2@Load:

; 172  : 
; 173  : 		while ( true )

  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	85 c0		 test	 eax, eax
  0010a	0f 84 9f 03 00
	00		 je	 $LN3@Load

; 174  : 		{
; 175  : 			Token = GetToken();

  00110	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00115	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv220[ebp], eax
  0011b	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv220[ebp]
  00121	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 176  : 
; 177  : 			if ( Token == END || eventEnabled == false )

  00124	83 7d e4 02	 cmp	 DWORD PTR _Token$11[ebp], 2
  00128	74 08		 je	 SHORT $LN18@Load
  0012a	0f b6 45 df	 movzx	 eax, BYTE PTR _eventEnabled$9[ebp]
  0012e	85 c0		 test	 eax, eax
  00130	75 05		 jne	 SHORT $LN17@Load
$LN18@Load:

; 178  : 			{
; 179  : 				break;

  00132	e9 78 03 00 00	 jmp	 $LN3@Load
$LN17@Load:

; 180  : 			}
; 181  : 
; 182  : 			type = TokenNumber;

  00137	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0013f	89 45 e0	 mov	 DWORD PTR _type$10[ebp], eax
$LN4@Load:

; 183  : 
; 184  : 			while ( true )

  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	85 c0		 test	 eax, eax
  00149	0f 84 5b 03 00
	00		 je	 $LN5@Load

; 185  : 			{
; 186  : 				if ( type == 0 ) //Settings

  0014f	83 7d e0 00	 cmp	 DWORD PTR _type$10[ebp], 0
  00153	75 64		 jne	 SHORT $LN19@Load

; 187  : 				{
; 188  : 					Token = GetToken();

  00155	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0015a	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv221[ebp], eax
  00160	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv221[ebp]
  00166	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 189  : 
; 190  : 					if ( strcmp("end", TokenString) == 0 )

  00169	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00173	e8 00 00 00 00	 call	 _strcmp
  00178	83 c4 08	 add	 esp, 8
  0017b	85 c0		 test	 eax, eax
  0017d	75 05		 jne	 SHORT $LN21@Load

; 191  : 					{
; 192  : 						break;

  0017f	e9 26 03 00 00	 jmp	 $LN5@Load
$LN21@Load:

; 193  : 					}
; 194  : 
; 195  : 					eventEnabled = TokenNumber > 0;

  00184	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  0018c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00193	76 0c		 jbe	 SHORT $LN37@Load
  00195	c7 85 64 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv136[ebp], 1
  0019f	eb 0a		 jmp	 SHORT $LN38@Load
$LN37@Load:
  001a1	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
$LN38@Load:
  001ab	8a 85 64 ff ff
	ff		 mov	 al, BYTE PTR tv136[ebp]
  001b1	88 45 df	 mov	 BYTE PTR _eventEnabled$9[ebp], al

; 196  : 				}

  001b4	e9 ec 02 00 00	 jmp	 $LN28@Load
$LN19@Load:

; 197  : 
; 198  : 				else if ( type == 1 ) //Time

  001b9	83 7d e0 01	 cmp	 DWORD PTR _type$10[ebp], 1
  001bd	0f 85 ef 00 00
	00		 jne	 $LN22@Load

; 199  : 				{
; 200  : 					Token = GetToken();

  001c3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001c8	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv222[ebp], eax
  001ce	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv222[ebp]
  001d4	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 201  : 
; 202  : 					if ( strcmp("end", TokenString) == 0 )

  001d7	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  001dc	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  001e1	e8 00 00 00 00	 call	 _strcmp
  001e6	83 c4 08	 add	 esp, 8
  001e9	85 c0		 test	 eax, eax
  001eb	75 05		 jne	 SHORT $LN24@Load

; 203  : 					{
; 204  : 						break;

  001ed	e9 b8 02 00 00	 jmp	 $LN5@Load
$LN24@Load:

; 205  : 					}
; 206  : 
; 207  : 					int dayOfWeek = TokenNumber;

  001f2	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001fa	89 45 d8	 mov	 DWORD PTR _dayOfWeek$8[ebp], eax
$LN6@Load:

; 208  : 
; 209  : 					while(true)

  001fd	b8 01 00 00 00	 mov	 eax, 1
  00202	85 c0		 test	 eax, eax
  00204	0f 84 a3 00 00
	00		 je	 $LN7@Load

; 210  : 					{
; 211  : 						Token = GetToken();

  0020a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0020f	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv223[ebp], eax
  00215	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv223[ebp]
  0021b	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 212  : 
; 213  : 						if ( strcmp("end", TokenString) == 0 )

  0021e	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00223	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00228	e8 00 00 00 00	 call	 _strcmp
  0022d	83 c4 08	 add	 esp, 8
  00230	85 c0		 test	 eax, eax
  00232	75 02		 jne	 SHORT $LN25@Load

; 214  : 						{
; 215  : 							break;

  00234	eb 77		 jmp	 SHORT $LN7@Load
$LN25@Load:

; 216  : 						}
; 217  : 
; 218  : 						EVENT_TIME eventTime;
; 219  : 
; 220  : 						eventTime.iHour = TokenNumber;

  00236	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0023e	89 45 d0	 mov	 DWORD PTR _eventTime$7[ebp], eax

; 221  : 
; 222  : 						Token = GetToken();

  00241	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00246	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv224[ebp], eax
  0024c	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv224[ebp]
  00252	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 223  : 						eventTime.iMin = TokenNumber;

  00255	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0025d	89 45 d4	 mov	 DWORD PTR _eventTime$7[ebp+4], eax

; 224  : 
; 225  : 						if(dayOfWeek == 0)

  00260	83 7d d8 00	 cmp	 DWORD PTR _dayOfWeek$8[ebp], 0
  00264	75 2f		 jne	 SHORT $LN26@Load

; 226  : 						{
; 227  : 							for(int i = 0;i < DAYS_OF_WEEK;++i)

  00266	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  0026d	eb 09		 jmp	 SHORT $LN10@Load
$LN8@Load:
  0026f	8b 45 cc	 mov	 eax, DWORD PTR _i$6[ebp]
  00272	83 c0 01	 add	 eax, 1
  00275	89 45 cc	 mov	 DWORD PTR _i$6[ebp], eax
$LN10@Load:
  00278	83 7d cc 07	 cmp	 DWORD PTR _i$6[ebp], 7
  0027c	7d 15		 jge	 SHORT $LN9@Load

; 228  : 								this->m_timeList[i].push_back(eventTime);

  0027e	8d 45 d0	 lea	 eax, DWORD PTR _eventTime$7[ebp]
  00281	50		 push	 eax
  00282	8b 4d cc	 mov	 ecx, DWORD PTR _i$6[ebp]
  00285	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00288	8d 4c ca 10	 lea	 ecx, DWORD PTR [edx+ecx*8+16]
  0028c	e8 00 00 00 00	 call	 ?push_back@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXABUEVENT_TIME@@@Z ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::push_back
  00291	eb dc		 jmp	 SHORT $LN8@Load
$LN9@Load:

; 229  : 						}

  00293	eb 13		 jmp	 SHORT $LN27@Load
$LN26@Load:

; 230  : 						else
; 231  : 							this->m_timeList[dayOfWeek-1].push_back(eventTime);

  00295	8d 45 d0	 lea	 eax, DWORD PTR _eventTime$7[ebp]
  00298	50		 push	 eax
  00299	8b 4d d8	 mov	 ecx, DWORD PTR _dayOfWeek$8[ebp]
  0029c	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0029f	8d 4c ca 08	 lea	 ecx, DWORD PTR [edx+ecx*8+8]
  002a3	e8 00 00 00 00	 call	 ?push_back@?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAEXABUEVENT_TIME@@@Z ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::push_back
$LN27@Load:

; 232  : 					};

  002a8	e9 50 ff ff ff	 jmp	 $LN6@Load
$LN7@Load:

; 233  : 				}

  002ad	e9 f3 01 00 00	 jmp	 $LN28@Load
$LN22@Load:

; 234  : 
; 235  : 				else if ( type == 2 ) //Reward List

  002b2	83 7d e0 02	 cmp	 DWORD PTR _type$10[ebp], 2
  002b6	0f 85 e9 01 00
	00		 jne	 $LN28@Load

; 236  : 				{
; 237  : 					Token = GetToken();

  002bc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002c1	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv225[ebp], eax
  002c7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv225[ebp]
  002cd	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 238  : 
; 239  : 					if ( strcmp("end", TokenString) == 0 )

  002d0	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  002d5	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  002da	e8 00 00 00 00	 call	 _strcmp
  002df	83 c4 08	 add	 esp, 8
  002e2	85 c0		 test	 eax, eax
  002e4	75 05		 jne	 SHORT $LN29@Load

; 240  : 					{
; 241  : 						break;

  002e6	e9 bf 01 00 00	 jmp	 $LN5@Load
$LN29@Load:

; 242  : 					}
; 243  : 
; 244  : 					REWARD_ITEM rewardItem;
; 245  : 
; 246  : 					rewardItem.m_dwType = TokenNumber;

  002eb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  002f3	e8 00 00 00 00	 call	 __ftoui3
  002f8	89 45 b4	 mov	 DWORD PTR _rewardItem$5[ebp], eax

; 247  : 
; 248  : 					if(rewardItem.m_dwType < 0 || rewardItem.m_dwType > MAX_ITEM_TYPE-1)

  002fb	83 7d b4 00	 cmp	 DWORD PTR _rewardItem$5[ebp], 0
  002ff	72 06		 jb	 SHORT $LN31@Load
  00301	83 7d b4 0f	 cmp	 DWORD PTR _rewardItem$5[ebp], 15 ; 0000000fH
  00305	76 1b		 jbe	 SHORT $LN30@Load
$LN31@Load:

; 249  : 						throw "Item type out of range";

  00307	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_C@_0BH@PDAGGAGG@Item?5type?5out?5of?5range@
  00311	68 00 00 00 00	 push	 OFFSET __TI2PAD
  00316	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0031c	50		 push	 eax
  0031d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN30@Load:

; 250  : 
; 251  : 					Token = GetToken();

  00322	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00327	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], eax
  0032d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv226[ebp]
  00333	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 252  : 
; 253  : 					if(TokenNumber < 0 || TokenNumber > MAX_ITEM_INDEX-1)

  00336	0f 57 c0	 xorps	 xmm0, xmm0
  00339	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  00340	77 11		 ja	 SHORT $LN33@Load
  00342	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  0034a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@41f80000
  00351	76 1b		 jbe	 SHORT $LN32@Load
$LN33@Load:

; 254  : 						throw "Item index out of range";

  00353	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_C@_0BI@FJIGPCBB@Item?5index?5out?5of?5range@
  0035d	68 00 00 00 00	 push	 OFFSET __TI2PAD
  00362	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00368	50		 push	 eax
  00369	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN32@Load:

; 255  : 
; 256  : 					rewardItem.m_dwType = ItemGetNumberMake(rewardItem.m_dwType,TokenNumber);

  0036e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00376	50		 push	 eax
  00377	8b 4d b4	 mov	 ecx, DWORD PTR _rewardItem$5[ebp]
  0037a	51		 push	 ecx
  0037b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00380	83 c4 08	 add	 esp, 8
  00383	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv227[ebp], eax
  00389	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv227[ebp]
  0038f	89 55 b4	 mov	 DWORD PTR _rewardItem$5[ebp], edx

; 257  : 
; 258  : 					Token = GetToken();

  00392	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00397	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv228[ebp], eax
  0039d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv228[ebp]
  003a3	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 259  : 					rewardItem.m_btLevel = TokenNumber;

  003a6	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003ae	88 45 b8	 mov	 BYTE PTR _rewardItem$5[ebp+4], al

; 260  : 
; 261  : 					Token = GetToken();

  003b1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003b6	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv229[ebp], eax
  003bc	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv229[ebp]
  003c2	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 262  : 					rewardItem.m_bSkill = TokenNumber > 0;

  003c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  003cd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  003d4	76 0c		 jbe	 SHORT $LN39@Load
  003d6	c7 85 64 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv192[ebp], 1
  003e0	eb 0a		 jmp	 SHORT $LN40@Load
$LN39@Load:
  003e2	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv192[ebp], 0
$LN40@Load:
  003ec	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv192[ebp]
  003f2	89 45 bc	 mov	 DWORD PTR _rewardItem$5[ebp+8], eax

; 263  : 
; 264  : 					Token = GetToken();

  003f5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003fa	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv230[ebp], eax
  00400	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv230[ebp]
  00406	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 265  : 					rewardItem.m_bLuck = TokenNumber > 0;

  00409	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  00411	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00418	76 0c		 jbe	 SHORT $LN41@Load
  0041a	c7 85 64 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv195[ebp], 1
  00424	eb 0a		 jmp	 SHORT $LN42@Load
$LN41@Load:
  00426	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv195[ebp], 0
$LN42@Load:
  00430	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv195[ebp]
  00436	89 45 c0	 mov	 DWORD PTR _rewardItem$5[ebp+12], eax

; 266  : 
; 267  : 					Token = GetToken();

  00439	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0043e	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv231[ebp], eax
  00444	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv231[ebp]
  0044a	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 268  : 					rewardItem.m_btOption = TokenNumber;

  0044d	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00455	88 45 c4	 mov	 BYTE PTR _rewardItem$5[ebp+16], al

; 269  : 
; 270  : 					Token = GetToken();

  00458	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0045d	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv232[ebp], eax
  00463	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv232[ebp]
  00469	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 271  : 					rewardItem.m_btExcOption = TokenNumber;

  0046c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00474	88 45 c5	 mov	 BYTE PTR _rewardItem$5[ebp+17], al

; 272  : 
; 273  : 					Token = GetToken();

  00477	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0047c	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv233[ebp], eax
  00482	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv233[ebp]
  00488	89 45 e4	 mov	 DWORD PTR _Token$11[ebp], eax

; 274  : 					rewardItem.m_iMaxRate = TokenNumber;

  0048b	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00493	89 45 c8	 mov	 DWORD PTR _rewardItem$5[ebp+20], eax

; 275  : 
; 276  : 					this->m_rewardList.push_back(rewardItem);

  00496	8d 45 b4	 lea	 eax, DWORD PTR _rewardItem$5[ebp]
  00499	50		 push	 eax
  0049a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0049d	83 c1 08	 add	 ecx, 8
  004a0	e8 00 00 00 00	 call	 ?push_back@?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAEXABUREWARD_ITEM@@@Z ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::push_back
$LN28@Load:

; 277  : 				}
; 278  : 			}

  004a5	e9 98 fc ff ff	 jmp	 $LN4@Load
$LN5@Load:

; 279  : 		}

  004aa	e9 54 fc ff ff	 jmp	 $LN2@Load
$LN3@Load:

; 280  : 
; 281  : 		fclose(SMDFile);

  004af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  004b4	50		 push	 eax
  004b5	e8 00 00 00 00	 call	 _fclose
  004ba	83 c4 04	 add	 esp, 4

; 282  : 		LogAdd("[PVP System] %s file load!", filename);

  004bd	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  004c0	50		 push	 eax
  004c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MNBPNGAL@?$FLPVP?5System?$FN?5?$CFs?5file?5load?$CB@
  004c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004cc	83 c4 08	 add	 esp, 8

; 283  : 
; 284  : 		if(eventEnabled)

  004cf	0f b6 45 df	 movzx	 eax, BYTE PTR _eventEnabled$9[ebp]
  004d3	85 c0		 test	 eax, eax
  004d5	74 1a		 je	 SHORT $LN34@Load

; 285  : 		{
; 286  : 			LogAdd("[PVP System] Event Enabled");

  004d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HDPCIDGI@?$FLPVP?5System?$FN?5Event?5Enabled@
  004dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004e2	83 c4 04	 add	 esp, 4

; 287  : 			this->m_eventState = EVENT_CLOSED;

  004e5	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  004e8	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [eax+72], 1

; 288  : 		}

  004ef	eb 18		 jmp	 SHORT $LN35@Load
$LN34@Load:

; 289  : 		else
; 290  : 		{
; 291  : 			LogAdd("[PVP System] Event Disabled");

  004f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OKBKMMIF@?$FLPVP?5System?$FN?5Event?5Disabled@
  004f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004fc	83 c4 04	 add	 esp, 4

; 292  : 			this->m_eventState = EVENT_NONE;

  004ff	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00502	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0
$LN35@Load:

; 293  : 		}
; 294  : 	}	// __try

  00509	eb 1b		 jmp	 SHORT $LN43@Load
__catch$?Load@CEngagePVP@@QAEXPBD@Z$0:

; 295  : 	catch ( const char *exception )
; 296  : 	{
; 297  : 		MsgBox("[PVP System] - Loading Exception Error (%s) - (%s) File. ", filename, exception);

  0050b	8b 45 b0	 mov	 eax, DWORD PTR _exception$4[ebp]
  0050e	50		 push	 eax
  0050f	8b 4d 08	 mov	 ecx, DWORD PTR _filename$[ebp]
  00512	51		 push	 ecx
  00513	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@IJLLDIOM@?$FLPVP?5System?$FN?5?9?5Loading?5Exceptio@
  00518	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0051d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 298  : 	}

  00520	b8 00 00 00 00	 mov	 eax, $LN46@Load
  00525	c3		 ret	 0
$LN43@Load:
  00526	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0052d	eb 07		 jmp	 SHORT $LN45@Load
$LN46@Load:
  0052f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN45@Load:

; 299  : 
; 300  : 	LeaveCriticalSection(&this->m_criticalSection);

  00536	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00539	83 c0 50	 add	 eax, 80			; 00000050H
  0053c	50		 push	 eax
  0053d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN1@Load:

; 301  : }

  00543	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00546	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0054d	59		 pop	 ecx
  0054e	5f		 pop	 edi
  0054f	5e		 pop	 esi
  00550	5b		 pop	 ebx
  00551	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00554	33 cd		 xor	 ecx, ebp
  00556	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0055b	8b e5		 mov	 esp, ebp
  0055d	5d		 pop	 ebp
  0055e	c2 04 00	 ret	 4
  00561	cc		 int	 3
  00562	cc		 int	 3
  00563	cc		 int	 3
  00564	cc		 int	 3
  00565	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Load@CEngagePVP@@QAEXPBD@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 60 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-160]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CEngagePVP@@QAEXPBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CEngagePVP@@QAEXPBD@Z ENDP			; CEngagePVP::Load
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ??1CEngagePVP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CEngagePVP@@QAE@XZ PROC				; CEngagePVP::~CEngagePVP, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CEngagePVP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 	DeleteCriticalSection(&this->m_criticalSection);

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 50	 add	 eax, 80			; 00000050H
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 39   : }

  00038	68 00 00 00 00	 push	 OFFSET ??1?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::~list<EVENT_TIME,std::allocator<EVENT_TIME> >
  0003d	6a 07		 push	 7
  0003f	6a 08		 push	 8
  00041	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 08	 add	 ecx, 8
  00053	e8 00 00 00 00	 call	 ??1?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::~list<REWARD_ITEM,std::allocator<REWARD_ITEM> >
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
  00072	cc		 int	 3
  00073	cc		 int	 3
  00074	cc		 int	 3
  00075	cc		 int	 3
  00076	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CEngagePVP@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CEngagePVP@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CEngagePVP@@QAE@XZ ENDP				; CEngagePVP::~CEngagePVP
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ??0CEngagePVP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CEngagePVP@@QAE@XZ PROC				; CEngagePVP::CEngagePVP, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CEngagePVP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 08	 add	 ecx, 8
  00040	e8 00 00 00 00	 call	 ??0?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >
  00045	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00049	68 00 00 00 00	 push	 OFFSET ??1?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::~list<EVENT_TIME,std::allocator<EVENT_TIME> >
  0004e	68 00 00 00 00	 push	 OFFSET ??0?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::list<EVENT_TIME,std::allocator<EVENT_TIME> >
  00053	6a 07		 push	 7
  00055	6a 08		 push	 8
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	83 c0 10	 add	 eax, 16			; 00000010H
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00063	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 27   : 	InitializeCriticalSection(&this->m_criticalSection);

  00067	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	83 c0 50	 add	 eax, 80			; 00000050H
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 28   : 
; 29   : 	this->Clear();

  00074	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?Clear@CEngagePVP@@AAEXXZ ; CEngagePVP::Clear

; 30   : 
; 31   : 	this->m_reloadConfig = false;

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	c6 40 4c 00	 mov	 BYTE PTR [eax+76], 0

; 32   : 
; 33   : 	this->m_eventState = EVENT_NONE;

  00083	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00086	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0

; 34   : }

  0008d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00094	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CEngagePVP@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
__unwindfunclet$??0CEngagePVP@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$list@UREWARD_ITEM@@V?$allocator@UREWARD_ITEM@@@std@@@std@@QAE@XZ ; std::list<REWARD_ITEM,std::allocator<REWARD_ITEM> >::~list<REWARD_ITEM,std::allocator<REWARD_ITEM> >
__unwindfunclet$??0CEngagePVP@@QAE@XZ$2:
  00013	68 00 00 00 00	 push	 OFFSET ??1?$list@UEVENT_TIME@@V?$allocator@UEVENT_TIME@@@std@@@std@@QAE@XZ ; std::list<EVENT_TIME,std::allocator<EVENT_TIME> >::~list<EVENT_TIME,std::allocator<EVENT_TIME> >
  00018	6a 07		 push	 7
  0001a	6a 08		 push	 8
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 c0 10	 add	 eax, 16			; 00000010H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00028	c3		 ret	 0
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
  0002d	cc		 int	 3
__ehhandler$??0CEngagePVP@@QAE@XZ:
  0002e	90		 npad	 1
  0002f	90		 npad	 1
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CEngagePVP@@QAE@XZ
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CEngagePVP@@QAE@XZ ENDP				; CEngagePVP::CEngagePVP
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$ = ecx

; 1259 :     void _Release() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1256 :     _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 1072 :     void _Adopt(const void*) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1065 :     void _Orphan_all() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -16					; size = 4
__Min_back_shift$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 c1 23	 add	 ecx, 35			; 00000023H
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00014	89 0a		 mov	 DWORD PTR [edx], ecx

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00016	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 4d fc	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001e	b8 04 00 00 00	 mov	 eax, 4
  00023	6b c8 ff	 imul	 ecx, eax, -1
  00026	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00029	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002c	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002f	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00036	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  0003e	89 4d f0	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00041	83 7d f0 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00045	72 08		 jb	 SHORT $LN7@Adjust_man
  00047	83 7d f0 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  0004b	77 02		 ja	 SHORT $LN7@Adjust_man
  0004d	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00054	33 c0		 xor	 eax, eax
  00056	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00058	33 c0		 xor	 eax, eax
  0005a	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  00062	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 76   :     __declspec(allocator) static void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 77   :         return ::operator new(_Bytes);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00012	83 c4 04	 add	 esp, 4

; 78   :     }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 554  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 555  :         return INT_MAX;

  00009	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 556  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -76						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 321  :     _THROW(bad_array_new_length{});

  00009	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  00011	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00016	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :         : bad_alloc("bad array new length")

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :         : exception(_Message, 1)

  0000c	6a 01		 push	 1
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	74 0b		 je	 SHORT $LN3@what
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 b8	 mov	 DWORD PTR tv69[ebp], edx
  0001e	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  00020	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00027	8b 45 b8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ___std_exception_destroy
  00021	83 c4 04	 add	 esp, 4

; 91   :     }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c0 04	 add	 eax, 4
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0002c	83 c1 04	 add	 ecx, 4
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ___std_exception_copy
  00035	83 c4 08	 add	 esp, 8

; 74   :     }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00028	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 68   :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 535  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 536  :             return _time64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __time64
  00012	83 c4 04	 add	 esp, 4

; 537  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 509  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 510  :             #pragma warning(push)
; 511  :             #pragma warning(disable: 4996)
; 512  :             return _localtime64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __localtime64
  00012	83 c4 04	 add	 esp, 4

; 513  :             #pragma warning(pop)
; 514  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 168  :         (void)_Size;
; 169  :         return _Where;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\EngagePVP.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
