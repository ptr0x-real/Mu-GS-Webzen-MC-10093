; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?set@PBMSG_HEAD@@QAEXPAEEE@Z			; PBMSG_HEAD::set
PUBLIC	??0CDarkSpirit@@QAE@XZ				; CDarkSpirit::CDarkSpirit
PUBLIC	??1CDarkSpirit@@UAE@XZ				; CDarkSpirit::~CDarkSpirit
PUBLIC	?Init@CDarkSpirit@@QAEXXZ			; CDarkSpirit::Init
PUBLIC	?Run@CDarkSpirit@@QAEXXZ			; CDarkSpirit::Run
PUBLIC	?ModeNormal@CDarkSpirit@@QAEXXZ			; CDarkSpirit::ModeNormal
PUBLIC	?ModeAttackRandom@CDarkSpirit@@QAEXXZ		; CDarkSpirit::ModeAttackRandom
PUBLIC	?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ	; CDarkSpirit::ModeAttackWithMaster
PUBLIC	?ModeAttakTarget@CDarkSpirit@@QAEXXZ		; CDarkSpirit::ModeAttakTarget
PUBLIC	?SetTarget@CDarkSpirit@@QAEXH@Z			; CDarkSpirit::SetTarget
PUBLIC	?ReSetTarget@CDarkSpirit@@QAEXH@Z		; CDarkSpirit::ReSetTarget
PUBLIC	?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z		; CDarkSpirit::Set
PUBLIC	?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z	; CDarkSpirit::SetMode
PUBLIC	?Attack@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z ; CDarkSpirit::Attack
PUBLIC	?GetAttackDamage@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@HHH@Z ; CDarkSpirit::GetAttackDamage
PUBLIC	?MissCheck@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0HHAAH@Z ; CDarkSpirit::MissCheck
PUBLIC	?ChangeCommand@CDarkSpirit@@QAEXHH@Z		; CDarkSpirit::ChangeCommand
PUBLIC	?RangeAttack@CDarkSpirit@@QAEXHH@Z		; CDarkSpirit::RangeAttack
PUBLIC	?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z		; CDarkSpirit::SendAttackMsg
PUBLIC	?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z		; CDarkSpirit::SendLevelmsg
PUBLIC	??_GCDarkSpirit@@UAEPAXI@Z			; CDarkSpirit::`scalar deleting destructor'
PUBLIC	??_7CDarkSpirit@@6B@				; CDarkSpirit::`vftable'
PUBLIC	?gDarkSpirit@@3PAVCDarkSpirit@@A		; gDarkSpirit
PUBLIC	??_C@_06NDNCHIBI@?$FL?$MA?O?$LJ?$NN?$FN@	; `string'
PUBLIC	??_C@_0L@NMEJHKFH@?$FL?$LH?$KD?$LE?$PN?$LA?x?$LA?$NN?$FN@ ; `string'
PUBLIC	??_C@_0BB@IPPKFAED@?$FL?A?V?$MA?N?$LA?z?$LA?$LA?$MA?L?$LA?x?$LA?$NN?$FN@ ; `string'
PUBLIC	??_C@_0N@KFGEJJPF@?$FL?$LL?g?$LP?k?$MA?Z?A?v?A?$KE?$FN@ ; `string'
PUBLIC	??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5L@ ; `string'
PUBLIC	??_R4CDarkSpirit@@6B@				; CDarkSpirit::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDarkSpirit@@@8				; CDarkSpirit `RTTI Type Descriptor'
PUBLIC	??_R3CDarkSpirit@@8				; CDarkSpirit::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDarkSpirit@@8				; CDarkSpirit::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDarkSpirit@@8			; CDarkSpirit::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CObjBaseAttack@@8			; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCObjBaseAttack@@@8			; CObjBaseAttack `RTTI Type Descriptor'
PUBLIC	??_R3CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@41200000
PUBLIC	__real@42c80000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	_rand:PROC
EXTRN	?DecPetItemExp@CItem@@QAEHH@Z:PROC		; CItem::DecPetItemExp
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?IsDinorantReduceAttackDamaege@CItem@@QAEHXZ:PROC ; CItem::IsDinorantReduceAttackDamaege
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObjAddAttackProcMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHHH@Z:PROC ; gObjAddAttackProcMsgSendDelay
EXTRN	?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
EXTRN	?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z:PROC	; gObjDuelCheck
EXTRN	?gObjArmorRandomDurDown@@YAXPAVOBJECTSTRUCT@@0@Z:PROC ; gObjArmorRandomDurDown
EXTRN	?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z:PROC ; gObjTargetGuildWarCheck
EXTRN	?gObjCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@H@Z:PROC ; gObjCheckSelfDefense
EXTRN	?gObjAttackQ@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjAttackQ
EXTRN	?gObjLifeCheck@@YAXPAVOBJECTSTRUCT@@0HHHHE@Z:PROC ; gObjLifeCheck
EXTRN	?gObjAngelSprite@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjAngelSprite
EXTRN	?gObjWingSprite@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjWingSprite
EXTRN	?gObjUniriaSprite@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjUniriaSprite
EXTRN	?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?GCReFillSend@@YAXHGEE@Z:PROC			; GCReFillSend
EXTRN	?GCManaSend@@YAXHFEEG@Z:PROC			; GCManaSend
EXTRN	?GCDamageSend@@YAXHHHHH@Z:PROC			; GCDamageSend
EXTRN	?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z:PROC ; GCMagicCancelSend
EXTRN	?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z:PROC ; GCMagicAttackNumberSend
EXTRN	?GCItemDurSend@@YAXHEEE@Z:PROC			; GCItemDurSend
EXTRN	??0CObjBaseAttack@@QAE@XZ:PROC			; CObjBaseAttack::CObjBaseAttack
EXTRN	??1CObjBaseAttack@@UAE@XZ:PROC			; CObjBaseAttack::~CObjBaseAttack
EXTRN	?CheckAttackArea@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z:PROC ; CObjBaseAttack::CheckAttackArea
EXTRN	?PkCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z:PROC ; CObjBaseAttack::PkCheck
EXTRN	?MissCheck@CObjBaseAttack@@UAEHPAVOBJECTSTRUCT@@0HHHAAH@Z:PROC ; CObjBaseAttack::MissCheck
EXTRN	??_ECDarkSpirit@@UAEPAXI@Z:PROC			; CDarkSpirit::`vector deleting destructor'
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?gObjMonsterStateProc@@YAXPAVOBJECTSTRUCT@@HH@Z:PROC ; gObjMonsterStateProc
EXTRN	?GetBattleSoccerGoalMove@@YAHH@Z:PROC		; GetBattleSoccerGoalMove
EXTRN	?gObjDenorantSprite@@YAHPAVOBJECTSTRUCT@@@Z:PROC ; gObjDenorantSprite
EXTRN	?gObjDarkHorse@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjDarkHorse
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_GlobalConfig@@3VCGlobalConfig@@A:BYTE	; g_GlobalConfig
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?gDarkSpirit@@3PAVCDarkSpirit@@A DB 048440H DUP (?)	; gDarkSpirit
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2CObjBaseAttack@@8
rdata$r	SEGMENT
??_R2CObjBaseAttack@@8 DD FLAT:??_R1A@?0A@EA@CObjBaseAttack@@8 ; CObjBaseAttack::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObjBaseAttack@@8
rdata$r	SEGMENT
??_R3CObjBaseAttack@@8 DD 00H				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObjBaseAttack@@@8
data$r	SEGMENT
??_R0?AVCObjBaseAttack@@@8 DD FLAT:??_7type_info@@6B@	; CObjBaseAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObjBaseAttack@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CObjBaseAttack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObjBaseAttack@@8 DD FLAT:??_R0?AVCObjBaseAttack@@@8 ; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CDarkSpirit@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDarkSpirit@@8 DD FLAT:??_R0?AVCDarkSpirit@@@8 ; CDarkSpirit::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDarkSpirit@@8
rdata$r	ENDS
;	COMDAT ??_R2CDarkSpirit@@8
rdata$r	SEGMENT
??_R2CDarkSpirit@@8 DD FLAT:??_R1A@?0A@EA@CDarkSpirit@@8 ; CDarkSpirit::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R3CDarkSpirit@@8
rdata$r	SEGMENT
??_R3CDarkSpirit@@8 DD 00H				; CDarkSpirit::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CDarkSpirit@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDarkSpirit@@@8
data$r	SEGMENT
??_R0?AVCDarkSpirit@@@8 DD FLAT:??_7type_info@@6B@	; CDarkSpirit `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDarkSpirit@@', 00H
data$r	ENDS
;	COMDAT ??_R4CDarkSpirit@@6B@
rdata$r	SEGMENT
??_R4CDarkSpirit@@6B@ DD 00H				; CDarkSpirit::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDarkSpirit@@@8
	DD	FLAT:??_R3CDarkSpirit@@8
rdata$r	ENDS
;	COMDAT ??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5L@
CONST	SEGMENT
??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5L@ DB '['
	DB	'%s][%s][PetItemExpDown] [%s] Level:[%d]Exp:[%d]DecExp[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFGEJJPF@?$FL?$LL?g?$LP?k?$MA?Z?A?v?A?$KE?$FN@
CONST	SEGMENT
??_C@_0N@KFGEJJPF@?$FL?$LL?g?$LP?k?$MA?Z?A?v?A?$KE?$FN@ DB '[', 0bbH, 0e7H
	DB	0bfH, 0ebH, 0c0H, 0daH, 0c1H, 0f6H, 0c1H, 0a4H, ']', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IPPKFAED@?$FL?A?V?$MA?N?$LA?z?$LA?$LA?$MA?L?$LA?x?$LA?$NN?$FN@
CONST	SEGMENT
??_C@_0BB@IPPKFAED@?$FL?A?V?$MA?N?$LA?z?$LA?$LA?$MA?L?$LA?x?$LA?$NN?$FN@ DB '['
	DB	0c1H, 0d6H, 0c0H, 0ceH, 0b0H, 0faH, 0b0H, 0b0H, 0c0H, 0ccH, 0b0H
	DB	0f8H, 0b0H, 0ddH, ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMEJHKFH@?$FL?$LH?$KD?$LE?$PN?$LA?x?$LA?$NN?$FN@
CONST	SEGMENT
??_C@_0L@NMEJHKFH@?$FL?$LH?$KD?$LE?$PN?$LA?x?$LA?$NN?$FN@ DB '[', 0b7H, 0a3H
	DB	0b4H, 0fdH, 0b0H, 0f8H, 0b0H, 0ddH, ']', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDNCHIBI@?$FL?$MA?O?$LJ?$NN?$FN@
CONST	SEGMENT
??_C@_06NDNCHIBI@?$FL?$MA?O?$LJ?$NN?$FN@ DB '[', 0c0H, 0cfH, 0b9H, 0ddH, ']'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7CDarkSpirit@@6B@
CONST	SEGMENT
??_7CDarkSpirit@@6B@ DD FLAT:??_R4CDarkSpirit@@6B@	; CDarkSpirit::`vftable'
	DD	FLAT:??_ECDarkSpirit@@UAEPAXI@Z
	DD	FLAT:?MissCheck@CObjBaseAttack@@UAEHPAVOBJECTSTRUCT@@0HHHAAH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CDarkSpirit@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CDarkSpirit@@QAE@XZ$0
__ehfuncinfo$??0CDarkSpirit@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CDarkSpirit@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?gDarkSpirit$initializer$@@3P6AXXZA DD FLAT:??__EgDarkSpirit@@YAXXZ ; gDarkSpirit$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FgDarkSpirit@@YAXXZ
text$yd	SEGMENT
??__FgDarkSpirit@@YAXXZ PROC				; `dynamic atexit destructor for 'gDarkSpirit'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1CDarkSpirit@@UAE@XZ ; CDarkSpirit::~CDarkSpirit
  0000e	68 e8 1c 00 00	 push	 7400			; 00001ce8H
  00013	6a 28		 push	 40			; 00000028H
  00015	68 00 00 00 00	 push	 OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  0001a	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??__FgDarkSpirit@@YAXXZ ENDP				; `dynamic atexit destructor for 'gDarkSpirit''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ??__EgDarkSpirit@@YAXXZ
text$di	SEGMENT
??__EgDarkSpirit@@YAXXZ PROC				; `dynamic initializer for 'gDarkSpirit'', COMDAT

; 57   : CDarkSpirit	gDarkSpirit[MAX_OBJECT];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1CDarkSpirit@@UAE@XZ ; CDarkSpirit::~CDarkSpirit
  0000e	68 00 00 00 00	 push	 OFFSET ??0CDarkSpirit@@QAE@XZ ; CDarkSpirit::CDarkSpirit
  00013	68 e8 1c 00 00	 push	 7400			; 00001ce8H
  00018	6a 28		 push	 40			; 00000028H
  0001a	68 00 00 00 00	 push	 OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  0001f	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00024	68 00 00 00 00	 push	 OFFSET ??__FgDarkSpirit@@YAXXZ ; `dynamic atexit destructor for 'gDarkSpirit''
  00029	e8 00 00 00 00	 call	 _atexit
  0002e	83 c4 04	 add	 esp, 4
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??__EgDarkSpirit@@YAXXZ ENDP				; `dynamic initializer for 'gDarkSpirit''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1번 캐슬 - 축석

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1번 캐슬 - 영석

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2번 캐슬 - 축석

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2번 캐슬 - 영석

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3번 캐슬 - 축석

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3번 캐슬 - 영석

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4번 캐슬 - 축석

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4번 캐슬 - 영석

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5번 캐슬 - 축석

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5번 캐슬 - 영석

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6번 캐슬 - 축석

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6번 캐슬 - 영석

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCDarkSpirit@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDarkSpirit@@UAEPAXI@Z PROC				; CDarkSpirit::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CDarkSpirit@@UAE@XZ	; CDarkSpirit::~CDarkSpirit
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 28		 push	 40			; 00000028H
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_GCDarkSpirit@@UAEPAXI@Z ENDP				; CDarkSpirit::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_nPos$ = 12						; size = 4
_PetType$ = 16						; size = 4
_InvenType$ = 20					; size = 4
?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z PROC		; CDarkSpirit::SendLevelmsg, COMDAT

; 2099 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2100 : 	PMSG_SEND_PET_ITEMINFO pMsg;
; 2101 : 
; 2102 : 	pMsg.h.set((LPBYTE)&pMsg, 0xA9, sizeof(pMsg));

  00013	6a 0c		 push	 12			; 0000000cH
  00015	68 a9 00 00 00	 push	 169			; 000000a9H
  0001a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	50		 push	 eax
  0001e	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00021	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 2103 : 
; 2104 : 	pMsg.PetType = PetType;

  00026	8a 45 10	 mov	 al, BYTE PTR _PetType$[ebp]
  00029	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2105 : 	pMsg.InvenType = 254;

  0002c	c6 45 f4 fe	 mov	 BYTE PTR _pMsg$[ebp+4], 254 ; 000000feH

; 2106 : 	pMsg.nPos = nPos;

  00030	8a 45 0c	 mov	 al, BYTE PTR _nPos$[ebp]
  00033	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 2107 : 
; 2108 : 	pMsg.Level = gObj[aIndex].pInventory[nPos].m_PetItem_Level;

  00036	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003d	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _nPos$[ebp], 168
  00044	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004a	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00051	8a 8c 08 a0 00
	00 00		 mov	 cl, BYTE PTR [eax+ecx+160]
  00058	88 4d f6	 mov	 BYTE PTR _pMsg$[ebp+6], cl

; 2109 : 	pMsg.Exp = gObj[aIndex].pInventory[nPos].m_PetItem_Exp;

  0005b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00062	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _nPos$[ebp], 168
  00069	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006f	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00076	8b 8c 08 a4 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+164]
  0007d	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+8], ecx

; 2110 : 	
; 2111 : #ifdef MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 2112 : 	pMsg.Life = (BYTE)(gObj[aIndex].pInventory[nPos].m_Durability);
; 2113 : #endif // MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 2114 : 
; 2115 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00080	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00084	50		 push	 eax
  00085	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2116 : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ENDP		; CDarkSpirit::SendLevelmsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z
_TEXT	SEGMENT
tv66 = -85						; size = 1
_pMsg$ = -20						; size = 9
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_criticaldamage$ = 16					; size = 4
_iActionType$ = 20					; size = 4
?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z PROC		; CDarkSpirit::SendAttackMsg, COMDAT
; _this$ = ecx

; 499  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 500  : 	PMSG_PET_ITEM_ATTACK_COMMAND pMsg;
; 501  : 
; 502  : #ifdef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 503  : 	if( criticaldamage != 3 )
; 504  : #else
; 505  : 	if( criticaldamage != 2 )

  00016	83 7d 10 02	 cmp	 DWORD PTR _criticaldamage$[ebp], 2
  0001a	0f 84 bb 00 00
	00		 je	 $LN2@SendAttack

; 506  : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 507  : 	{
; 508  : 		pMsg.PetType = 0;

  00020	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 509  : 		pMsg.SkillType = !criticaldamage;

  00024	83 7d 10 00	 cmp	 DWORD PTR _criticaldamage$[ebp], 0
  00028	75 06		 jne	 SHORT $LN7@SendAttack
  0002a	c6 45 ab 01	 mov	 BYTE PTR tv66[ebp], 1
  0002e	eb 04		 jmp	 SHORT $LN8@SendAttack
$LN7@SendAttack:
  00030	c6 45 ab 00	 mov	 BYTE PTR tv66[ebp], 0
$LN8@SendAttack:
  00034	8a 45 ab	 mov	 al, BYTE PTR tv66[ebp]
  00037	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 510  : 
; 511  : #ifdef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 512  : 		if( iActionType == 1 )		// 액션 번호가 1일경우엔 무조건 돌격모션
; 513  : 			pMsg.SkillType = 0;
; 514  : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 515  : 
; 516  : 		pMsg.NumberH = HIBYTE(aIndex);

  0003a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003d	c1 e8 08	 shr	 eax, 8
  00040	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00045	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 517  : 		pMsg.NumberL = LOBYTE(aIndex);

  00048	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0004b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00050	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 518  : 
; 519  : 		pMsg.TargetNumberH = HIBYTE(aTargetIndex);

  00053	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00056	c1 e8 08	 shr	 eax, 8
  00059	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005e	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+7], al

; 520  : 		pMsg.TargetNumberL = LOBYTE(aTargetIndex);

  00061	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00064	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00069	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 521  : 
; 522  : 		pMsg.h.set((LPBYTE)&pMsg, 0xa8, sizeof(pMsg));

  0006c	6a 09		 push	 9
  0006e	68 a8 00 00 00	 push	 168			; 000000a8H
  00073	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00076	50		 push	 eax
  00077	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007a	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 523  : 
; 524  : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0007f	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00083	50		 push	 eax
  00084	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00087	51		 push	 ecx
  00088	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 525  : 		MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  00094	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00098	50		 push	 eax
  00099	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0009c	51		 push	 ecx
  0009d	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000a4	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 526  : 
; 527  : #ifndef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 528  : #ifdef MODIFY_DARKSPIRIT_TAGET_ATTACK_01_20040906
; 529  : 		// 0. 공격 방식에 따라 데미지 적용을 틀리게 한다.
; 530  : 		// ActionType 이 1이면 스피릿이 직접 대쉬 공격을 한다.
; 531  : 		if( iActionType == 1 )

  000b3	83 7d 14 01	 cmp	 DWORD PTR _iActionType$[ebp], 1
  000b7	75 20		 jne	 SHORT $LN4@SendAttack

; 532  : 		{
; 533  : 			criticaldamage = 0;

  000b9	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _criticaldamage$[ebp], 0

; 534  : 			if( (rand()%10) < 3 )

  000c0	e8 00 00 00 00	 call	 _rand
  000c5	99		 cdq
  000c6	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000cb	f7 f9		 idiv	 ecx
  000cd	83 fa 03	 cmp	 edx, 3
  000d0	7d 07		 jge	 SHORT $LN4@SendAttack

; 535  : 			{	// 가끔식 크리티컬 데이지 들어간다
; 536  : 				criticaldamage = 1;

  000d2	c7 45 10 01 00
	00 00		 mov	 DWORD PTR _criticaldamage$[ebp], 1
$LN4@SendAttack:

; 537  : 			}
; 538  : 		}
; 539  : #endif
; 540  : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 541  : 	}

  000d9	eb 07		 jmp	 SHORT $LN3@SendAttack
$LN2@SendAttack:

; 542  : 	else
; 543  : 	{
; 544  : 		criticaldamage = 0;

  000db	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _criticaldamage$[ebp], 0
$LN3@SendAttack:

; 545  : 	}
; 546  : 	
; 547  : #ifdef MODIFY_DARKSPIRIT_TAGET_ATTACK_01_20040906
; 548  : 	gObjAddAttackProcMsgSendDelay(&gObj[aIndex], 

  000e2	8b 45 14	 mov	 eax, DWORD PTR _iActionType$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d 10	 mov	 ecx, DWORD PTR _criticaldamage$[ebp]
  000e9	51		 push	 ecx
  000ea	68 58 02 00 00	 push	 600			; 00000258H
  000ef	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  000f2	52		 push	 edx
  000f3	6a 33		 push	 51			; 00000033H
  000f5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000fc	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?gObjAddAttackProcMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
  00108	83 c4 18	 add	 esp, 24			; 00000018H

; 549  : 								  MSG_ATTACKPROC_DARKSPRITATTACK, 
; 550  : 								  aTargetIndex,
; 551  : 								  600, criticaldamage, iActionType);
; 552  : #else
; 553  : 	gObjAddAttackProcMsgSendDelay(&gObj[aIndex], 
; 554  : 								  MSG_ATTACKPROC_DARKSPRITATTACK, 
; 555  : 								  aTargetIndex,
; 556  : 								  600, criticaldamage, 0);
; 557  : #endif
; 558  : 
; 559  : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	33 cd		 xor	 ecx, ebp
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 10 00	 ret	 16			; 00000010H
?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ENDP		; CDarkSpirit::SendAttackMsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?RangeAttack@CDarkSpirit@@QAEXHH@Z
_TEXT	SEGMENT
_CallMonIndex$1 = -40					; size = 4
_HitCount$ = -36					; size = 4
_EnableAttack$ = -32					; size = 4
_attackcheck$ = -28					; size = 4
_loopcount$ = -24					; size = 4
_count$ = -20						; size = 4
_tObjNum$ = -16						; size = 4
_StartDis$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
?RangeAttack@CDarkSpirit@@QAEXHH@Z PROC			; CDarkSpirit::RangeAttack, COMDAT
; _this$ = ecx

; 402  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 403  : 	LPOBJECTSTRUCT lpObj= &gObj[aIndex];

  0000c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00013	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00019	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 404  : 
; 405  : 	int StartDis = 1;

  0001c	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _StartDis$[ebp], 1

; 406  : 	int tObjNum;
; 407  : 
; 408  : 	int count = 0;

  00023	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 409  : 	int loopcount = 0;

  0002a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _loopcount$[ebp], 0

; 410  : 	BOOL attackcheck;	
; 411  : 
; 412  : 	BOOL	EnableAttack;	
; 413  : 	int		HitCount = 0;

  00031	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _HitCount$[ebp], 0

; 414  : 
; 415  : 	SendAttackMsg(lpObj->m_Index, aTargetIndex, 0);

  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00043	8b 11		 mov	 edx, DWORD PTR [ecx]
  00045	52		 push	 edx
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ; CDarkSpirit::SendAttackMsg
$LN2@RangeAttac:

; 416  : 
; 417  : 	while(1)

  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	85 c0		 test	 eax, eax
  00055	0f 84 bf 01 00
	00		 je	 $LN1@RangeAttac

; 418  : 	{
; 419  : 		if( lpObj->VpPlayer2[count].state )

  0005b	6b 45 ec 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00062	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  0006a	85 d2		 test	 edx, edx
  0006c	0f 84 92 01 00
	00		 je	 $LN4@RangeAttac

; 420  : 		{
; 421  : 			tObjNum = lpObj->VpPlayer2[count].number;

  00072	6b 45 ec 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00079	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  00081	89 55 f0	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 422  : 
; 423  : 			if( tObjNum >= 0 && aTargetIndex != tObjNum )

  00084	83 7d f0 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00088	0f 8c 76 01 00
	00		 jl	 $LN4@RangeAttac
  0008e	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00091	3b 45 f0	 cmp	 eax, DWORD PTR _tObjNum$[ebp]
  00094	0f 84 6a 01 00
	00		 je	 $LN4@RangeAttac

; 424  : 			{
; 425  : 				EnableAttack = FALSE;

  0009a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _EnableAttack$[ebp], 0

; 426  : 
; 427  : 				if( ((lpObj->VpPlayer2[count].type == OBJTYPE_MONSTER) && (gObj[tObjNum].m_RecallMon < 0)) )

  000a1	6b 45 ec 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a8	0f b6 94 01 ec
	06 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1772]
  000b0	83 fa 02	 cmp	 edx, 2
  000b3	75 23		 jne	 SHORT $LN6@RangeAttac
  000b5	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c2	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  000ca	7d 0c		 jge	 SHORT $LN6@RangeAttac

; 428  : 				{	// 대상이 몬스터이고, 소환몹이 아니면 공격가능
; 429  : 					EnableAttack = TRUE;

  000cc	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _EnableAttack$[ebp], 1

; 430  : 				}	

  000d3	e9 9e 00 00 00	 jmp	 $LN7@RangeAttac
$LN6@RangeAttac:

; 431  : 				else if( tObjNum == aTargetIndex )

  000d8	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  000db	3b 45 0c	 cmp	 eax, DWORD PTR _aTargetIndex$[ebp]
  000de	75 0c		 jne	 SHORT $LN8@RangeAttac

; 432  : 				{	// 클라이언트에서 대상을 강제 공격했을때와 결투 대상일때는 공격가능
; 433  : 					EnableAttack = TRUE;

  000e0	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _EnableAttack$[ebp], 1

; 434  : 				}	

  000e7	e9 8a 00 00 00	 jmp	 $LN7@RangeAttac
$LN8@RangeAttac:

; 435  : 				else
; 436  : 				{	// 길드전 체크
; 437  : 					int CallMonIndex = gObj[tObjNum].m_Index;

  000ec	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f9	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000fc	89 55 d8	 mov	 DWORD PTR _CallMonIndex$1[ebp], edx

; 438  : 					if( gObj[tObjNum].Type == OBJTYPE_MONSTER )

  000ff	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010c	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00111	83 fa 02	 cmp	 edx, 2
  00114	75 3a		 jne	 SHORT $LN10@RangeAttac

; 439  : 					{
; 440  : 						if( gObj[tObjNum].m_RecallMon >= 0 ) 

  00116	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00123	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  0012b	7c 23		 jl	 SHORT $LN10@RangeAttac

; 441  : 						{
; 442  : 							CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  0012d	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013a	69 94 01 a4 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+676], 7072
  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014a	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0014d	89 4d d8	 mov	 DWORD PTR _CallMonIndex$1[ebp], ecx
$LN10@RangeAttac:

; 443  : 						}
; 444  : 					}
; 445  : 					if( gObjTargetGuildWarCheck(lpObj, &gObj[CallMonIndex]) == TRUE )

  00150	69 45 d8 a0 1b
	00 00		 imul	 eax, DWORD PTR _CallMonIndex$1[ebp], 7072
  00157	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015d	50		 push	 eax
  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00167	83 c4 08	 add	 esp, 8
  0016a	83 f8 01	 cmp	 eax, 1
  0016d	75 07		 jne	 SHORT $LN7@RangeAttac

; 446  : 					{	// 대상이 길전상대이면 공격가능
; 447  : 						EnableAttack = TRUE;

  0016f	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _EnableAttack$[ebp], 1
$LN7@RangeAttac:

; 448  : 					}
; 449  : 				}
; 450  : 
; 451  : 				if( EnableAttack )

  00176	83 7d e0 00	 cmp	 DWORD PTR _EnableAttack$[ebp], 0
  0017a	0f 84 84 00 00
	00		 je	 $LN4@RangeAttac

; 452  : 				{	
; 453  : 					attackcheck = FALSE;

  00180	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _attackcheck$[ebp], 0

; 454  : 
; 455  : 					if( loopcount == 0 )

  00187	83 7d e8 00	 cmp	 DWORD PTR _loopcount$[ebp], 0
  0018b	75 09		 jne	 SHORT $LN14@RangeAttac

; 456  : 					{
; 457  : 						attackcheck = TRUE;

  0018d	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _attackcheck$[ebp], 1

; 458  : 					}

  00194	eb 18		 jmp	 SHORT $LN15@RangeAttac
$LN14@RangeAttac:

; 459  : 					else
; 460  : 					{
; 461  : 						if( !(rand()%3) )

  00196	e8 00 00 00 00	 call	 _rand
  0019b	99		 cdq
  0019c	b9 03 00 00 00	 mov	 ecx, 3
  001a1	f7 f9		 idiv	 ecx
  001a3	85 d2		 test	 edx, edx
  001a5	75 07		 jne	 SHORT $LN15@RangeAttac

; 462  : 						{
; 463  : 							attackcheck = TRUE;

  001a7	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _attackcheck$[ebp], 1
$LN15@RangeAttac:

; 464  : 						}
; 465  : 					}
; 466  : 					
; 467  : 					if( attackcheck )

  001ae	83 7d e4 00	 cmp	 DWORD PTR _attackcheck$[ebp], 0
  001b2	74 50		 je	 SHORT $LN4@RangeAttac

; 468  : 					{
; 469  : 						if( gObjCalDistance(&gObj[aTargetIndex], &gObj[tObjNum]) < 4)

  001b4	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  001bb	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c1	50		 push	 eax
  001c2	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aTargetIndex$[ebp], 7072
  001c9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cf	51		 push	 ecx
  001d0	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  001d5	83 c4 08	 add	 esp, 8
  001d8	83 f8 04	 cmp	 eax, 4
  001db	7d 27		 jge	 SHORT $LN4@RangeAttac

; 470  : 						{	
; 471  : #ifdef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 472  : 							SendAttackMsg(lpObj->m_Index, tObjNum, 3);
; 473  : #else
; 474  : 							SendAttackMsg(lpObj->m_Index, tObjNum, 2);

  001dd	6a 00		 push	 0
  001df	6a 02		 push	 2
  001e1	8b 45 f0	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  001e4	50		 push	 eax
  001e5	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ea	52		 push	 edx
  001eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ee	e8 00 00 00 00	 call	 ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ; CDarkSpirit::SendAttackMsg

; 475  : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 476  : 							HitCount++;

  001f3	8b 45 dc	 mov	 eax, DWORD PTR _HitCount$[ebp]
  001f6	83 c0 01	 add	 eax, 1
  001f9	89 45 dc	 mov	 DWORD PTR _HitCount$[ebp], eax

; 477  : 
; 478  : 							if( HitCount > 3)

  001fc	83 7d dc 03	 cmp	 DWORD PTR _HitCount$[ebp], 3
  00200	7e 02		 jle	 SHORT $LN4@RangeAttac

; 479  : 								break;

  00202	eb 16		 jmp	 SHORT $LN1@RangeAttac
$LN4@RangeAttac:

; 480  : 							//gObjAttack(lpObj, &gObj[tObjNum], lpMagic, 0, 1, 0);
; 481  : 						}
; 482  : 					}
; 483  : 				}
; 484  : 			}
; 485  : 		}	
; 486  : 		count++;

  00204	8b 45 ec	 mov	 eax, DWORD PTR _count$[ebp]
  00207	83 c0 01	 add	 eax, 1
  0020a	89 45 ec	 mov	 DWORD PTR _count$[ebp], eax

; 487  : 		if( count > MAXVIEWPORTOBJECT-1 )

  0020d	83 7d ec 4a	 cmp	 DWORD PTR _count$[ebp], 74 ; 0000004aH
  00211	7e 02		 jle	 SHORT $LN20@RangeAttac

; 488  : 		{	
; 489  : 			break;

  00213	eb 05		 jmp	 SHORT $LN1@RangeAttac
$LN20@RangeAttac:

; 490  : 		}
; 491  : 	}

  00215	e9 34 fe ff ff	 jmp	 $LN2@RangeAttac
$LN1@RangeAttac:

; 492  : }

  0021a	5f		 pop	 edi
  0021b	5e		 pop	 esi
  0021c	5b		 pop	 ebx
  0021d	8b e5		 mov	 esp, ebp
  0021f	5d		 pop	 ebp
  00220	c2 08 00	 ret	 8
?RangeAttack@CDarkSpirit@@QAEXHH@Z ENDP			; CDarkSpirit::RangeAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?ChangeCommand@CDarkSpirit@@QAEXHH@Z
_TEXT	SEGMENT
_setmode$ = -8						; size = 4
_this$ = -4						; size = 4
_command$ = 8						; size = 4
_targetindex$ = 12					; size = 4
?ChangeCommand@CDarkSpirit@@QAEXHH@Z PROC		; CDarkSpirit::ChangeCommand, COMDAT
; _this$ = ecx

; 2083 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2084 : 	CDarkSpirit::ePetItem_Mode setmode = CDarkSpirit::PetItem_Mode_Normal;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _setmode$[ebp], 0

; 2085 : 	
; 2086 : 	if( command == CDarkSpirit::PetItem_Mode_Normal )			

  00013	83 7d 08 00	 cmp	 DWORD PTR _command$[ebp], 0
  00017	75 09		 jne	 SHORT $LN2@ChangeComm

; 2087 : 		setmode = CDarkSpirit::PetItem_Mode_Normal;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _setmode$[ebp], 0
  00020	eb 2b		 jmp	 SHORT $LN3@ChangeComm
$LN2@ChangeComm:

; 2088 : 	else if( command == CDarkSpirit::PetItem_Mode_Attack_Random )

  00022	83 7d 08 01	 cmp	 DWORD PTR _command$[ebp], 1
  00026	75 09		 jne	 SHORT $LN4@ChangeComm

; 2089 : 		setmode = CDarkSpirit::PetItem_Mode_Attack_Random;

  00028	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _setmode$[ebp], 1
  0002f	eb 1c		 jmp	 SHORT $LN3@ChangeComm
$LN4@ChangeComm:

; 2090 : 	else if( command == CDarkSpirit::PetItem_Mode_Attack_WithMaster )

  00031	83 7d 08 02	 cmp	 DWORD PTR _command$[ebp], 2
  00035	75 09		 jne	 SHORT $LN6@ChangeComm

; 2091 : 		setmode = CDarkSpirit::PetItem_Mode_Attack_WithMaster;

  00037	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _setmode$[ebp], 2
  0003e	eb 0d		 jmp	 SHORT $LN3@ChangeComm
$LN6@ChangeComm:

; 2092 : 	else if( command == CDarkSpirit::PetItem_Mode_Attack_Target )

  00040	83 7d 08 03	 cmp	 DWORD PTR _command$[ebp], 3
  00044	75 07		 jne	 SHORT $LN3@ChangeComm

; 2093 : 		setmode = CDarkSpirit::PetItem_Mode_Attack_Target;

  00046	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _setmode$[ebp], 3
$LN3@ChangeComm:

; 2094 : 
; 2095 : 	CDarkSpirit::SetMode(setmode, targetindex);

  0004d	8b 45 0c	 mov	 eax, DWORD PTR _targetindex$[ebp]
  00050	50		 push	 eax
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _setmode$[ebp]
  00054	51		 push	 ecx
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode

; 2096 : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
?ChangeCommand@CDarkSpirit@@QAEXHH@Z ENDP		; CDarkSpirit::ChangeCommand
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?MissCheck@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0HHAAH@Z
_TEXT	SEGMENT
_MsgDamage$ = -16					; size = 4
_TargetSuccessfulBlocking$ = -12			; size = 4
_SuccessAttackRate$ = -8				; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_skill$ = 16						; size = 4
_skillSuccess$ = 20					; size = 4
_bAllMiss$ = 24						; size = 4
?MissCheck@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0HHAAH@Z PROC ; CDarkSpirit::MissCheck, COMDAT
; _this$ = ecx

; 1757 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1758 : 	int SuccessAttackRate = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _SuccessAttackRate$[ebp], 0

; 1759 : 	int TargetSuccessfulBlocking = lpTargetObj->m_SuccessfulBlocking;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00016	8b 88 f0 02 00
	00		 mov	 ecx, DWORD PTR [eax+752]
  0001c	89 4d f4	 mov	 DWORD PTR _TargetSuccessfulBlocking$[ebp], ecx

; 1760 : 	int	MsgDamage = 0;

  0001f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _MsgDamage$[ebp], 0

; 1761 : 	
; 1762 : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// 패시브 1차 - 공격성공률 상승(다크스피릿)
; 1763 : 	SuccessAttackRate += lpObj->m_MPSkillOpt.iMpsAttackSuccessRate;		
; 1764 : #endif
; 1765 : 
; 1766 : 	if(TargetSuccessfulBlocking > g_GlobalConfig.m_iMaxMissRate)

  00026	8b 45 f4	 mov	 eax, DWORD PTR _TargetSuccessfulBlocking$[ebp]
  00029	3b 05 e4 00 00
	00		 cmp	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+228
  0002f	7e 08		 jle	 SHORT $LN2@MissCheck

; 1767 : 		TargetSuccessfulBlocking = g_GlobalConfig.m_iMaxMissRate;

  00031	a1 e4 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+228
  00036	89 45 f4	 mov	 DWORD PTR _TargetSuccessfulBlocking$[ebp], eax
$LN2@MissCheck:

; 1768 : 
; 1769 : #ifdef NEW_FORSKYLAND3
; 1770 : 	if( m_SuccessAttackRate < TargetSuccessfulBlocking )

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003f	3b 4d f4	 cmp	 ecx, DWORD PTR _TargetSuccessfulBlocking$[ebp]
  00042	7d 09		 jge	 SHORT $LN3@MissCheck

; 1771 : 	{
; 1772 : 		bAllMiss = TRUE;

  00044	8b 45 18	 mov	 eax, DWORD PTR _bAllMiss$[ebp]
  00047	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$LN3@MissCheck:

; 1773 : 	}
; 1774 : #endif
; 1775 : 
; 1776 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		// 환영 사원 전용스킬 보호의 주문 적용
; 1777 : 	if(CHECK_ILLUSION_TEMPLE(lpTargetObj->MapNumber) 
; 1778 : 		&& g_IllusionTempleEvent.GetIllusionTempleState(lpTargetObj->MapNumber) == ILLUSION_TEMPLE_STATE_PLAYING)
; 1779 : 	{
; 1780 : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_4_20070802
; 1781 : 		if(lpTargetObj->Type == OBJTYPE_CHARACTER 
; 1782 : 			&& g_IllusionTempleEvent.CheckSkillProdection(lpTargetObj->m_iIllusionTempleIndex, lpTargetObj->MapNumber))
; 1783 : #else
; 1784 : 		if((lpTargetObj->m_ViewSkillState & STATE_ILLUSION_TEMPLE_PRODECTION) == STATE_ILLUSION_TEMPLE_PRODECTION)
; 1785 : #endif
; 1786 : 		{
; 1787 : 			GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, 0, 0);
; 1788 : 			return FALSE;
; 1789 : 		}
; 1790 : 
; 1791 : 		// 같은 파티원끼리는 데미지 없게
; 1792 : 		if(lpObj->PartyNumber == lpTargetObj->PartyNumber)
; 1793 : 		{
; 1794 : 			GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, 0, 0);
; 1795 : 			return FALSE;
; 1796 : 		}
; 1797 : 	}
; 1798 : #endif
; 1799 : 
; 1800 : #ifdef NEW_FORSKYLAND3
; 1801 : 	if( bAllMiss )

  0004d	8b 45 18	 mov	 eax, DWORD PTR _bAllMiss$[ebp]
  00050	83 38 00	 cmp	 DWORD PTR [eax], 0
  00053	74 34		 je	 SHORT $LN4@MissCheck

; 1802 : 	{	
; 1803 : #ifdef MODIFY_SUCCESSBLOCKING_ALLMISS_20040408
; 1804 : 		if( rand()%100 >= 5 )

  00055	e8 00 00 00 00	 call	 _rand
  0005a	99		 cdq
  0005b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00060	f7 f9		 idiv	 ecx
  00062	83 fa 05	 cmp	 edx, 5
  00065	7c 20		 jl	 SHORT $LN6@MissCheck

; 1805 : #else
; 1806 : 		if( rand()%100 >= 3 )
; 1807 : #endif
; 1808 : 		{	// all 미스는 3%의 확률로 데미지가 들어 온다
; 1809 : 
; 1810 : #ifdef ADD_SKILL_WITH_COMBO
; 1811 : #else
; 1812 : 			MsgDamage = 0x20;
; 1813 : #endif
; 1814 : 			GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, MsgDamage);				

  00067	8b 45 f0	 mov	 eax, DWORD PTR _MsgDamage$[ebp]
  0006a	50		 push	 eax
  0006b	6a 00		 push	 0
  0006d	6a 00		 push	 0
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00072	8b 11		 mov	 edx, DWORD PTR [ecx]
  00074	52		 push	 edx
  00075	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  00080	83 c4 14	 add	 esp, 20			; 00000014H

; 1815 : 			return FALSE;

  00083	33 c0		 xor	 eax, eax
  00085	eb 41		 jmp	 SHORT $LN1@MissCheck
$LN6@MissCheck:

; 1816 : 		}
; 1817 : 	}

  00087	eb 3a		 jmp	 SHORT $LN5@MissCheck
$LN4@MissCheck:

; 1818 : 	else 
; 1819 : #endif
; 1820 : 
; 1821 : 	if( m_SuccessAttackRate )

  00089	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00090	74 31		 je	 SHORT $LN5@MissCheck

; 1822 : 	{
; 1823 : 		if( (rand()%m_SuccessAttackRate) < TargetSuccessfulBlocking) 

  00092	e8 00 00 00 00	 call	 _rand
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	99		 cdq
  0009b	f7 79 10	 idiv	 DWORD PTR [ecx+16]
  0009e	3b 55 f4	 cmp	 edx, DWORD PTR _TargetSuccessfulBlocking$[ebp]
  000a1	7d 20		 jge	 SHORT $LN5@MissCheck

; 1824 : 		{
; 1825 : 
; 1826 : 	#ifdef ADD_SKILL_WITH_COMBO
; 1827 : 	#else
; 1828 : 			int MsgDamage = 0x20;
; 1829 : 	#endif
; 1830 : 			GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, MsgDamage);			

  000a3	8b 45 f0	 mov	 eax, DWORD PTR _MsgDamage$[ebp]
  000a6	50		 push	 eax
  000a7	6a 00		 push	 0
  000a9	6a 00		 push	 0
  000ab	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  000ae	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b0	52		 push	 edx
  000b1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b6	51		 push	 ecx
  000b7	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  000bc	83 c4 14	 add	 esp, 20			; 00000014H

; 1831 : 			return FALSE;

  000bf	33 c0		 xor	 eax, eax
  000c1	eb 05		 jmp	 SHORT $LN1@MissCheck
$LN5@MissCheck:

; 1832 : 		}
; 1833 : 	}
; 1834 : 	return TRUE;

  000c3	b8 01 00 00 00	 mov	 eax, 1
$LN1@MissCheck:

; 1835 : }

  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 14 00	 ret	 20			; 00000014H
?MissCheck@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0HHAAH@Z ENDP ; CDarkSpirit::MissCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?GetAttackDamage@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_addpetdamage$1 = -20					; size = 4
_AttackDamage$ = -16					; size = 4
_sub$ = -12						; size = 4
_ad$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_targetDefense$ = 12					; size = 4
_bIsOnDuel$ = 16					; size = 4
_criticaldamage$ = 20					; size = 4
?GetAttackDamage@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@HHH@Z PROC ; CDarkSpirit::GetAttackDamage, COMDAT
; _this$ = ecx

; 1676 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1677 : #ifdef DUEL_SYSTEM_20031028
; 1678 : 	#ifdef ADD_SHIELD_POINT_01_20060403
; 1679 : 		if ( g_ShieldSystemOn == TRUE )
; 1680 : 		{
; 1681 : 			if( bIsOnDuel == TRUE )
; 1682 : 			{
; 1683 : 				bIsOnDuel = FALSE;
; 1684 : 			}
; 1685 : 		}
; 1686 : 	#endif
; 1687 : #endif
; 1688 : 		
; 1689 : 	int ad;
; 1690 : 	int sub;
; 1691 : 	int AttackDamage;
; 1692 : 
; 1693 : 	sub = (m_AttackDamageMax)-(m_AttackDamageMin);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00018	89 55 f4	 mov	 DWORD PTR _sub$[ebp], edx

; 1694 : 
; 1695 : #ifdef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 1696 : 	if( criticaldamage == 1 )	// 크리티컬(행운) 데미지
; 1697 : 	{
; 1698 : 		AttackDamage = m_AttackDamageMin+sub;
; 1699 : 	}
; 1700 : 	else if( criticaldamage == 2 )	// 엑설런트 데미지
; 1701 : 	{
; 1702 : 		AttackDamage = m_AttackDamageMin+sub;
; 1703 : 		AttackDamage += AttackDamage*20/100;
; 1704 : 	}
; 1705 : 	else						// 일반 데미지
; 1706 : 	{		
; 1707 : 		AttackDamage = m_AttackDamageMin+(rand()%(sub+1));
; 1708 : 	}
; 1709 : #else
; 1710 : 	if( criticaldamage )

  0001b	83 7d 14 00	 cmp	 DWORD PTR _criticaldamage$[ebp], 0
  0001f	74 0e		 je	 SHORT $LN2@GetAttackD

; 1711 : 	{
; 1712 : 		AttackDamage = m_AttackDamageMin+sub;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00027	03 4d f4	 add	 ecx, DWORD PTR _sub$[ebp]
  0002a	89 4d f0	 mov	 DWORD PTR _AttackDamage$[ebp], ecx

; 1713 : 	}

  0002d	eb 17		 jmp	 SHORT $LN3@GetAttackD
$LN2@GetAttackD:

; 1714 : 	else
; 1715 : 	{		
; 1716 : 		AttackDamage = m_AttackDamageMin+(rand()%(sub+1));

  0002f	e8 00 00 00 00	 call	 _rand
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _sub$[ebp]
  00037	83 c1 01	 add	 ecx, 1
  0003a	99		 cdq
  0003b	f7 f9		 idiv	 ecx
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00043	89 55 f0	 mov	 DWORD PTR _AttackDamage$[ebp], edx
$LN3@GetAttackD:

; 1717 : 	}
; 1718 : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 1719 : 
; 1720 : 	if( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Type >= MAKE_ITEMNUM(2,8) && 
; 1721 : 		lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Type <= MAKE_ITEMNUM(2,12)
; 1722 : #ifdef ADD_WEAPON_OF_ARCHANGEL_SCEPTER_20050706
; 1723 : 		|| ( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Type == MAKE_ITEMNUM(2,13) )
; 1724 : #endif
; 1725 : #ifdef ADD_NEW_ITEM_01_20050823
; 1726 : 		|| ( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Type == MAKE_ITEMNUM(2,14) )
; 1727 : #endif	
; 1728 : #ifdef MODIFY_350ITEM_BUGFIX2_20060823
; 1729 : 		|| ( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Type == MAKE_ITEMNUM(2,15) )	// 350아이템.샤이닝셉터

  00046	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0004b	6b c8 00	 imul	 ecx, eax, 0
  0004e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00051	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00057	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0005c	6a 08		 push	 8
  0005e	6a 02		 push	 2
  00060	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00065	83 c4 08	 add	 esp, 8
  00068	3b f0		 cmp	 esi, eax
  0006a	7c 26		 jl	 SHORT $LN6@GetAttackD
  0006c	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00071	6b c8 00	 imul	 ecx, eax, 0
  00074	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00077	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0007d	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00082	6a 0c		 push	 12			; 0000000cH
  00084	6a 02		 push	 2
  00086	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0008b	83 c4 08	 add	 esp, 8
  0008e	3b f0		 cmp	 esi, eax
  00090	7e 26		 jle	 SHORT $LN5@GetAttackD
$LN6@GetAttackD:
  00092	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00097	6b c8 00	 imul	 ecx, eax, 0
  0009a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009d	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000a3	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  000a8	6a 0f		 push	 15			; 0000000fH
  000aa	6a 02		 push	 2
  000ac	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b1	83 c4 08	 add	 esp, 8
  000b4	3b f0		 cmp	 esi, eax
  000b6	75 68		 jne	 SHORT $LN4@GetAttackD
$LN5@GetAttackD:

; 1730 : #endif
; 1731 : #ifdef MODIFY_SEASON4_UPDATE_BUGFIX_01_20080722
; 1732 : 		|| ( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Type == MAKE_ITEMNUM(2,17) )	// 엡솔루트셉터 추가
; 1733 : #endif // MODIFY_SEASON4_UPDATE_BUGFIX_01_20080722
; 1734 : #ifdef ADD_STRIKER_SCEPTER_20090317
; 1735 : 		|| ( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Type == MAKE_ITEMNUM(2,18) )	// 스트라이커셉터 추가
; 1736 : #endif // ADD_STRIKER_SCEPTER_20090317
; 1737 : 	  )
; 1738 : 	{	//셉터만 적용
; 1739 : 		int addpetdamage = lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Magic/2;

  000b8	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000bd	6b c8 00	 imul	 ecx, eax, 0
  000c0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c3	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000c9	0f b7 44 08 20	 movzx	 eax, WORD PTR [eax+ecx+32]
  000ce	99		 cdq
  000cf	2b c2		 sub	 eax, edx
  000d1	d1 f8		 sar	 eax, 1
  000d3	89 45 ec	 mov	 DWORD PTR _addpetdamage$1[ebp], eax

; 1740 : 		// 내구력 감소에 대한 패널티가 적용된다
; 1741 : 		addpetdamage -= (addpetdamage*lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_CurrentDurabilityState);	

  000d6	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _addpetdamage$1[ebp]
  000db	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000e0	6b c8 00	 imul	 ecx, eax, 0
  000e3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e6	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000ec	f3 0f 59 84 08
	8c 00 00 00	 mulss	 xmm0, DWORD PTR [eax+ecx+140]
  000f5	f3 0f 2a 4d ec	 cvtsi2ss xmm1, DWORD PTR _addpetdamage$1[ebp]
  000fa	f3 0f 5c c8	 subss	 xmm1, xmm0
  000fe	f3 0f 2c c9	 cvttss2si ecx, xmm1
  00102	89 4d ec	 mov	 DWORD PTR _addpetdamage$1[ebp], ecx

; 1742 : 		addpetdamage = AttackDamage*addpetdamage/100;

  00105	8b 45 f0	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00108	0f af 45 ec	 imul	 eax, DWORD PTR _addpetdamage$1[ebp]
  0010c	99		 cdq
  0010d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00112	f7 f9		 idiv	 ecx
  00114	89 45 ec	 mov	 DWORD PTR _addpetdamage$1[ebp], eax

; 1743 : 		AttackDamage += addpetdamage;

  00117	8b 45 f0	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  0011a	03 45 ec	 add	 eax, DWORD PTR _addpetdamage$1[ebp]
  0011d	89 45 f0	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN4@GetAttackD:

; 1744 : 	}
; 1745 : 	
; 1746 : #ifdef DUEL_SYSTEM_20031028
; 1747 : // 	if (bIsOnDuel)
; 1748 : // 		ad = (AttackDamage) * 60 /100 - targetDefense;
; 1749 : // 	else
; 1750 : #endif
; 1751 : 		ad = (AttackDamage)-targetDefense;	

  00120	8b 45 f0	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00123	2b 45 0c	 sub	 eax, DWORD PTR _targetDefense$[ebp]
  00126	89 45 f8	 mov	 DWORD PTR _ad$[ebp], eax

; 1752 : 
; 1753 : 	return ad;

  00129	8b 45 f8	 mov	 eax, DWORD PTR _ad$[ebp]

; 1754 : }

  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 10 00	 ret	 16			; 00000010H
?GetAttackDamage@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@HHH@Z ENDP ; CDarkSpirit::GetAttackDamage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?Attack@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z
_TEXT	SEGMENT
tv592 = -200						; size = 4
tv583 = -200						; size = 4
tv535 = -200						; size = 4
tv526 = -200						; size = 4
tv593 = -196						; size = 4
tv584 = -196						; size = 4
tv536 = -196						; size = 4
tv527 = -196						; size = 4
_atd_reflect$1 = -128					; size = 4
_selfdefense$ = -124					; size = 4
_decattackdamage$2 = -120				; size = 4
_replacemana$3 = -116					; size = 4
_decdamage$4 = -112					; size = 4
_Darkhorse$5 = -108					; size = 4
_dinorantdecdamage$6 = -104				; size = 4
_Dinorant$7 = -100					; size = 4
_damage$8 = -96						; size = 4
_damage$9 = -92						; size = 4
_Wing$10 = -88						; size = 4
_damage$11 = -84					; size = 4
_exp$12 = -80						; size = 4
_tlevel$ = -76						; size = 4
_beforeDamage$13 = -72					; size = 4
_targetdefense$ = -68					; size = 4
_skilldefense$ = -64					; size = 4
_AttackDamage$ = -60					; size = 4
_bAllMiss$ = -56					; size = 4
_MSBFlag$ = -52						; size = 4
_bIsOnDuel$ = -48					; size = 4
_Energy$ = -44						; size = 4
_Vitality$ = -40					; size = 4
_Dexterity$ = -36					; size = 4
_Strength$ = -32					; size = 4
_skill$ = -28						; size = 4
_ManaChange$ = -24					; size = 4
_MsgDamage$ = -17					; size = 1
_lpCallTargetObj$ = -16					; size = 4
_lpCallObj$ = -12					; size = 4
_skillSuccess$ = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_criticaldamage$ = 20					; size = 4
_iActionType$ = 24					; size = 4
?Attack@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z PROC ; CDarkSpirit::Attack, COMDAT
; _this$ = ecx

; 699  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 700  : 	int				skillSuccess=0;

  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _skillSuccess$[ebp], 0

; 701  : 
; 702  : 	LPOBJECTSTRUCT	lpCallObj;
; 703  : 	LPOBJECTSTRUCT	lpCallTargetObj;
; 704  : 	BYTE			MsgDamage = 0;

  00016	c6 45 ef 00	 mov	 BYTE PTR _MsgDamage$[ebp], 0

; 705  : 
; 706  : 	int				ManaChange = FALSE;		

  0001a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ManaChange$[ebp], 0

; 707  : 
; 708  : #ifdef ADD_SHIELD_POINT_01_20060403
; 709  : 	int iTempShieldDamage = 0;
; 710  : 	int iTotalShieldDamage = 0;
; 711  : #endif
; 712  : 
; 713  : 	if( (lpTargetObj->Authority&AUTHORITY_ADMIN) == AUTHORITY_ADMIN ) 

  00021	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00024	8b 88 a4 01 00
	00		 mov	 ecx, DWORD PTR [eax+420]
  0002a	83 e1 02	 and	 ecx, 2
  0002d	74 07		 je	 SHORT $LN2@Attack

; 714  : 	{	// 운영자 캐릭은 공격을 받지 않는다
; 715  : 		return FALSE;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 7b 0e 00 00	 jmp	 $LN1@Attack
$LN2@Attack:

; 716  : 	}
; 717  : 
; 718  : 	if( lpObj->MapNumber != lpTargetObj->MapNumber )

  00036	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00039	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00040	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00043	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0004a	3b c8		 cmp	 ecx, eax
  0004c	74 07		 je	 SHORT $LN3@Attack

; 719  : 	{	// 같은 맵이 아니면, 
; 720  : 		return FALSE;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 5c 0e 00 00	 jmp	 $LN1@Attack
$LN3@Attack:

; 721  : 	}
; 722  : 	
; 723  : 
; 724  : #ifdef CRYWOLF_MAIN_SCHEDULER_20050505
; 725  : 	// 크라이울프 준비, 종료 시간에는 몬스터에게 피해를 입힐 수 없다.
; 726  : 	if( g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_READY 
; 727  : 		|| g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_END )
; 728  : 	{
; 729  : 		if( CHECK_CRYWOLF_FIRSTZONE(lpTargetObj->MapNumber) )
; 730  : 		{
; 731  : 			if( lpTargetObj->Type == OBJTYPE_MONSTER )
; 732  : 				return FALSE;
; 733  : 		}	
; 734  : 	}
; 735  : #endif
; 736  : 
; 737  : 	int skill=0;

  00055	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _skill$[ebp], 0

; 738  : 	if( lpMagic != NULL )

  0005c	83 7d 10 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00060	74 0a		 je	 SHORT $LN4@Attack

; 739  : 	{
; 740  : 		skill = lpMagic->m_Skill;

  00062	8b 45 10	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00065	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00069	89 4d e4	 mov	 DWORD PTR _skill$[ebp], ecx
$LN4@Attack:

; 741  : 	}
; 742  : 
; 743  : 	skillSuccess = 1;

  0006c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _skillSuccess$[ebp], 1

; 744  : 
; 745  : 	if( lpObj->GuildNumber > 0 )

  00073	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00076	83 b8 90 02 00
	00 00		 cmp	 DWORD PTR [eax+656], 0
  0007d	7e 4d		 jle	 SHORT $LN8@Attack

; 746  : 	{
; 747  : 		if( lpObj->lpGuild != NULL )

  0007f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00082	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  00089	74 41		 je	 SHORT $LN8@Attack

; 748  : 		{
; 749  : 			if( lpObj->lpGuild->WarState && lpObj->lpGuild->WarType == BT_SOCCER )

  0008b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008e	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00094	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  0009b	85 d2		 test	 edx, edx
  0009d	74 2d		 je	 SHORT $LN8@Attack
  0009f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a2	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  000a8	0f b6 91 92 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1426]
  000af	83 fa 01	 cmp	 edx, 1
  000b2	75 18		 jne	 SHORT $LN8@Attack

; 750  : 			{
; 751  : 				if( GetBattleSoccerGoalMove(0) == 0 )

  000b4	6a 00		 push	 0
  000b6	e8 00 00 00 00	 call	 ?GetBattleSoccerGoalMove@@YAHH@Z ; GetBattleSoccerGoalMove
  000bb	83 c4 04	 add	 esp, 4
  000be	85 c0		 test	 eax, eax
  000c0	75 0a		 jne	 SHORT $LN8@Attack

; 752  : 				{
; 753  : 					return TRUE;

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	e9 e5 0d 00 00	 jmp	 $LN1@Attack
$LN8@Attack:

; 754  : 				}				
; 755  : 			}
; 756  : 		}
; 757  : 	}
; 758  : 
; 759  : 	// 축구공 일 경우엔 튕기게 한다.
; 760  : 	if( lpTargetObj->Type == OBJTYPE_MONSTER )

  000cc	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000cf	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000d3	83 f9 02	 cmp	 ecx, 2
  000d6	75 4c		 jne	 SHORT $LN10@Attack

; 761  : 	{
; 762  : 		if( lpTargetObj->Class == 200 )	

  000d8	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000db	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000e2	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  000e8	75 3a		 jne	 SHORT $LN10@Attack

; 763  : 		{
; 764  : #ifdef FOR_ONAIR
; 765  : 			return TRUE;
; 766  : #else
; 767  : 			if( skill )

  000ea	83 7d e4 00	 cmp	 DWORD PTR _skill$[ebp], 0
  000ee	74 16		 je	 SHORT $LN11@Attack

; 768  : 			{
; 769  : 				gObjMonsterStateProc(lpTargetObj, 7, lpObj->m_Index);

  000f0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f5	51		 push	 ecx
  000f6	6a 07		 push	 7
  000f8	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000fb	52		 push	 edx
  000fc	e8 00 00 00 00	 call	 ?gObjMonsterStateProc@@YAXPAVOBJECTSTRUCT@@HH@Z ; gObjMonsterStateProc
  00101	83 c4 0c	 add	 esp, 12			; 0000000cH

; 770  : 			}

  00104	eb 14		 jmp	 SHORT $LN12@Attack
$LN11@Attack:

; 771  : 			else gObjMonsterStateProc(lpTargetObj, 6, lpObj->m_Index);			

  00106	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00109	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010b	51		 push	 ecx
  0010c	6a 06		 push	 6
  0010e	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 ?gObjMonsterStateProc@@YAXPAVOBJECTSTRUCT@@HH@Z ; gObjMonsterStateProc
  00117	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@Attack:

; 772  : 			return TRUE;

  0011a	b8 01 00 00 00	 mov	 eax, 1
  0011f	e9 8d 0d 00 00	 jmp	 $LN1@Attack
$LN10@Attack:

; 773  : #endif
; 774  : 		}
; 775  : 	}
; 776  : 		
; 777  : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00124	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00127	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0012b	83 f9 01	 cmp	 ecx, 1
  0012e	75 17		 jne	 SHORT $LN14@Attack

; 778  : 	{
; 779  : 		if( gObjIsConnected(lpObj) == FALSE ) return FALSE;		

  00130	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsConnected
  00139	83 c4 04	 add	 esp, 4
  0013c	85 c0		 test	 eax, eax
  0013e	75 07		 jne	 SHORT $LN14@Attack
  00140	33 c0		 xor	 eax, eax
  00142	e9 6a 0d 00 00	 jmp	 $LN1@Attack
$LN14@Attack:

; 780  : 	}
; 781  : 	
; 782  : 	if( lpTargetObj->Type == OBJTYPE_CHARACTER )

  00147	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0014a	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0014e	83 f9 01	 cmp	 ecx, 1
  00151	75 17		 jne	 SHORT $LN16@Attack

; 783  : 	{
; 784  : 		if( gObjIsConnected(lpTargetObj) == FALSE ) return FALSE;

  00153	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsConnected
  0015c	83 c4 04	 add	 esp, 4
  0015f	85 c0		 test	 eax, eax
  00161	75 07		 jne	 SHORT $LN16@Attack
  00163	33 c0		 xor	 eax, eax
  00165	e9 47 0d 00 00	 jmp	 $LN1@Attack
$LN16@Attack:

; 785  : 	}
; 786  : 	
; 787  : 	if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_MONSTER)

  0016a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00171	83 f9 01	 cmp	 ecx, 1
  00174	75 2f		 jne	 SHORT $LN19@Attack
  00176	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00179	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0017d	83 f9 02	 cmp	 ecx, 2
  00180	75 23		 jne	 SHORT $LN19@Attack

; 788  : 	{
; 789  : 		// 공격자가 플레이어고 상대가 몬스터라면 소환수인지 체크한다.
; 790  : 		// 이때 자신이 소환한 몬스터일경우 공격이 안된다.
; 791  : 		if( lpObj->m_RecallMon >= 0 )

  00182	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00185	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  0018c	7c 17		 jl	 SHORT $LN19@Attack

; 792  : 		{
; 793  : 			if( lpObj->m_RecallMon == lpTargetObj->m_Index ) return FALSE;

  0018e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00191	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00194	8b 90 a4 02 00
	00		 mov	 edx, DWORD PTR [eax+676]
  0019a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0019c	75 07		 jne	 SHORT $LN19@Attack
  0019e	33 c0		 xor	 eax, eax
  001a0	e9 0c 0d 00 00	 jmp	 $LN1@Attack
$LN19@Attack:

; 794  : 		}
; 795  : 	}
; 796  : 	
; 797  : 	// 공격해도 되는지 물어본다.
; 798  : 	if( gObjAttackQ(lpTargetObj) == FALSE ) return FALSE;

  001a5	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001a8	50		 push	 eax
  001a9	e8 00 00 00 00	 call	 ?gObjAttackQ@@YAHPAVOBJECTSTRUCT@@@Z ; gObjAttackQ
  001ae	83 c4 04	 add	 esp, 4
  001b1	85 c0		 test	 eax, eax
  001b3	75 07		 jne	 SHORT $LN20@Attack
  001b5	33 c0		 xor	 eax, eax
  001b7	e9 f5 0c 00 00	 jmp	 $LN1@Attack
$LN20@Attack:

; 799  : 	
; 800  : #ifdef CASTLE_MAIN_SCHEDULER_20041111		// 공성관련 사람의 공격당함 여부 -> 공성전 중에 같은 편은 공격받으면 않된다.
; 801  : 	if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 802  : 		if ((lpObj->m_btCsJoinSide > CS_SIEGESIDE_NONE) &&
; 803  : 			(lpObj->m_btCsJoinSide == lpTargetObj->m_btCsJoinSide)
; 804  : 			) 
; 805  : 		{
; 806  : 			return FALSE;
; 807  : 		}
; 808  : 	}
; 809  : #endif
; 810  : 
; 811  : 	lpObj->m_TotalAttackCount++;

  001bc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bf	8b 88 f4 01 00
	00		 mov	 ecx, DWORD PTR [eax+500]
  001c5	83 c1 01	 add	 ecx, 1
  001c8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001cb	89 8a f4 01 00
	00		 mov	 DWORD PTR [edx+500], ecx

; 812  : 
; 813  : 
; 814  : 	// 공격 지역을 체크 한다
; 815  : 	if( !CheckAttackArea(lpObj, lpTargetObj) )

  001d1	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001d4	50		 push	 eax
  001d5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d8	51		 push	 ecx
  001d9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dc	e8 00 00 00 00	 call	 ?CheckAttackArea@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z ; CObjBaseAttack::CheckAttackArea
  001e1	85 c0		 test	 eax, eax
  001e3	75 07		 jne	 SHORT $LN21@Attack

; 816  : 		return FALSE;

  001e5	33 c0		 xor	 eax, eax
  001e7	e9 c5 0c 00 00	 jmp	 $LN1@Attack
$LN21@Attack:

; 817  : 	
; 818  : 	
; 819  : 	lpCallObj = lpObj;

  001ec	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ef	89 45 f4	 mov	 DWORD PTR _lpCallObj$[ebp], eax

; 820  : 	
; 821  : 	// 소환몬스터일 경우 주인설정
; 822  : 	lpCallTargetObj = lpTargetObj;

  001f2	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001f5	89 45 f0	 mov	 DWORD PTR _lpCallTargetObj$[ebp], eax

; 823  : 	if( lpTargetObj->Type == OBJTYPE_MONSTER )

  001f8	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001fb	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  001ff	83 f9 02	 cmp	 ecx, 2
  00202	75 22		 jne	 SHORT $LN23@Attack

; 824  : 	{
; 825  : 		if( lpTargetObj->m_RecallMon >= 0 ) 

  00204	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00207	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  0020e	7c 16		 jl	 SHORT $LN23@Attack

; 826  : 		{
; 827  : 			lpCallTargetObj = &gObj[lpTargetObj->m_RecallMon];

  00210	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00213	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  0021d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00223	89 4d f0	 mov	 DWORD PTR _lpCallTargetObj$[ebp], ecx
$LN23@Attack:

; 828  : 		}
; 829  : 	}
; 830  : 
; 831  : 	// 피케이 체크
; 832  : 	if( !PkCheck(lpCallObj, lpTargetObj) )

  00226	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00229	50		 push	 eax
  0022a	8b 4d f4	 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  0022d	51		 push	 ecx
  0022e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	e8 00 00 00 00	 call	 ?PkCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z ; CObjBaseAttack::PkCheck
  00236	85 c0		 test	 eax, eax
  00238	75 07		 jne	 SHORT $LN24@Attack

; 833  : 		return FALSE;

  0023a	33 c0		 xor	 eax, eax
  0023c	e9 70 0c 00 00	 jmp	 $LN1@Attack
$LN24@Attack:

; 834  : 
; 835  : 	int	Strength	= lpObj->Strength+lpObj->AddStrength;

  00241	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00244	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  0024b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0024e	0f b7 82 e0 00
	00 00		 movzx	 eax, WORD PTR [edx+224]
  00255	03 c8		 add	 ecx, eax
  00257	89 4d e0	 mov	 DWORD PTR _Strength$[ebp], ecx

; 836  : 	int	Dexterity	= lpObj->Dexterity+lpObj->AddDexterity;

  0025a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025d	0f b7 88 b6 00
	00 00		 movzx	 ecx, WORD PTR [eax+182]
  00264	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00267	0f b7 82 e2 00
	00 00		 movzx	 eax, WORD PTR [edx+226]
  0026e	03 c8		 add	 ecx, eax
  00270	89 4d dc	 mov	 DWORD PTR _Dexterity$[ebp], ecx

; 837  : 	int	Vitality	= lpObj->Vitality+lpObj->AddVitality;

  00273	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00276	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0027d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00280	0f b7 82 e4 00
	00 00		 movzx	 eax, WORD PTR [edx+228]
  00287	03 c8		 add	 ecx, eax
  00289	89 4d d8	 mov	 DWORD PTR _Vitality$[ebp], ecx

; 838  : 	int	Energy		= lpObj->Energy+lpObj->AddEnergy;

  0028c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028f	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR [eax+186]
  00296	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00299	0f b7 82 e6 00
	00 00		 movzx	 eax, WORD PTR [edx+230]
  002a0	03 c8		 add	 ecx, eax
  002a2	89 4d d4	 mov	 DWORD PTR _Energy$[ebp], ecx

; 839  : 
; 840  : #ifdef DUEL_SYSTEM_20031028
; 841  : 	BOOL bIsOnDuel = gObjDuelCheck(lpObj, lpTargetObj);

  002a5	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002a8	50		 push	 eax
  002a9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ac	51		 push	 ecx
  002ad	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  002b2	83 c4 08	 add	 esp, 8
  002b5	89 45 d0	 mov	 DWORD PTR _bIsOnDuel$[ebp], eax

; 842  : 
; 843  : #ifdef DUEL_SYSTEM_FIX_20031224		// 싸우는 양쪽이 서로 결투 중이라면 결투카운트를 갱신한다.
; 844  : 	if (bIsOnDuel) {

  002b8	83 7d d0 00	 cmp	 DWORD PTR _bIsOnDuel$[ebp], 0
  002bc	74 1e		 je	 SHORT $LN25@Attack

; 845  : 		lpObj->m_iDuelTickCount = GetTickCount();

  002be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  002c4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c7	89 81 f4 0c 00
	00		 mov	 DWORD PTR [ecx+3316], eax

; 846  : 		lpTargetObj->m_iDuelTickCount = GetTickCount();

  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  002d3	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  002d6	89 81 f4 0c 00
	00		 mov	 DWORD PTR [ecx+3316], eax
$LN25@Attack:

; 847  : 	}
; 848  : #endif
; 849  : #endif
; 850  : 
; 851  : 	int MSBFlag = 0;

  002dc	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _MSBFlag$[ebp], 0

; 852  : 	
; 853  : #ifdef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 854  : 	if( criticaldamage == 1 )
; 855  : 		MsgDamage = DT_CRITICAL;
; 856  : 	else if( criticaldamage == 2 )
; 857  : 		MsgDamage = DT_EXCELLENT;
; 858  : #else
; 859  : 	if( criticaldamage )

  002e3	83 7d 14 00	 cmp	 DWORD PTR _criticaldamage$[ebp], 0
  002e7	74 06		 je	 SHORT $LN26@Attack

; 860  : 		MsgDamage = DT_CRITICAL;

  002e9	c6 45 ef 03	 mov	 BYTE PTR _MsgDamage$[ebp], 3
  002ed	eb 04		 jmp	 SHORT $LN27@Attack
$LN26@Attack:

; 861  : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 862  : 	else
; 863  : 		MsgDamage = 0;

  002ef	c6 45 ef 00	 mov	 BYTE PTR _MsgDamage$[ebp], 0
$LN27@Attack:

; 864  : 	
; 865  : 	// 공격자의 공격데미지 값을 얻는다.
; 866  : #ifdef NEW_FORSKYLAND3
; 867  : 	int bAllMiss = FALSE;

  002f3	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _bAllMiss$[ebp], 0

; 868  : #endif	
; 869  : 
; 870  : 	int AttackDamage = 0;

  002fa	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _AttackDamage$[ebp], 0

; 871  : 
; 872  : 	// 미스 체크
; 873  : #ifdef ADD_SHIELD_POINT_01_20060403
; 874  : 	// CODEREVIEW_SHIELD : 쉴드 시스템 ON/OFF 체크 추가
; 875  : 	// CODEREVIEW_SHIELD2 : 
; 876  : 	if( g_ShieldSystemOn == TRUE )
; 877  : 	{
; 878  : 		if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER )
; 879  : 		{
; 880  : 			if( !MissCheckPvP( lpObj, lpTargetObj, skill, skillSuccess, bAllMiss ) )
; 881  : 			{
; 882  : 				return FALSE;
; 883  : 			}
; 884  : 		}
; 885  : 		else
; 886  : 		{
; 887  : 			if( !MissCheck( lpObj, lpTargetObj, skill, skillSuccess, bAllMiss ) )
; 888  : 			{
; 889  : 				return FALSE;
; 890  : 			}
; 891  : 		}
; 892  : 	}
; 893  : 	else
; 894  : 	{
; 895  : 		if( !MissCheck( lpObj, lpTargetObj, skill, skillSuccess, bAllMiss ) )
; 896  : 		{
; 897  : 			return FALSE;
; 898  : 		}
; 899  : 	}
; 900  : #else
; 901  : 	if( !MissCheck(lpObj, lpTargetObj, skill, skillSuccess, bAllMiss) )

  00301	8d 45 c8	 lea	 eax, DWORD PTR _bAllMiss$[ebp]
  00304	50		 push	 eax
  00305	8b 4d f8	 mov	 ecx, DWORD PTR _skillSuccess$[ebp]
  00308	51		 push	 ecx
  00309	8b 55 e4	 mov	 edx, DWORD PTR _skill$[ebp]
  0030c	52		 push	 edx
  0030d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00310	50		 push	 eax
  00311	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00314	51		 push	 ecx
  00315	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00318	e8 00 00 00 00	 call	 ?MissCheck@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0HHAAH@Z ; CDarkSpirit::MissCheck
  0031d	85 c0		 test	 eax, eax
  0031f	75 07		 jne	 SHORT $LN28@Attack

; 902  : 		return FALSE;

  00321	33 c0		 xor	 eax, eax
  00323	e9 89 0b 00 00	 jmp	 $LN1@Attack
$LN28@Attack:

; 903  : #endif
; 904  : 
; 905  : 	// 대상의 방어력을 얻는다
; 906  : #ifdef ADD_380ITEM_NEWOPTION_20060711	
; 907  : 	int targetdefense = GetTargetDefense(lpObj, lpTargetObj, MsgDamage);
; 908  : #else
; 909  : 	int skilldefense = lpTargetObj->m_SkillDefense;

  00328	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0032b	8b 88 1c 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6684]
  00331	89 4d c0	 mov	 DWORD PTR _skilldefense$[ebp], ecx

; 910  : 	int targetdefense = lpTargetObj->m_Defense+skilldefense;

  00334	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00337	8b 88 e8 02 00
	00		 mov	 ecx, DWORD PTR [eax+744]
  0033d	03 4d c0	 add	 ecx, DWORD PTR _skilldefense$[ebp]
  00340	89 4d bc	 mov	 DWORD PTR _targetdefense$[ebp], ecx

; 911  : 	targetdefense -= targetdefense*lpTargetObj->m_SkillMagumReduceDefense/100;

  00343	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00346	8b 4d bc	 mov	 ecx, DWORD PTR _targetdefense$[ebp]
  00349	0f af 88 04 1a
	00 00		 imul	 ecx, DWORD PTR [eax+6660]
  00350	8b c1		 mov	 eax, ecx
  00352	99		 cdq
  00353	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00358	f7 f9		 idiv	 ecx
  0035a	8b 55 bc	 mov	 edx, DWORD PTR _targetdefense$[ebp]
  0035d	2b d0		 sub	 edx, eax
  0035f	89 55 bc	 mov	 DWORD PTR _targetdefense$[ebp], edx

; 912  : #endif // ADD_380ITEM_NEWOPTION_20060711
; 913  : 	
; 914  : 
; 915  : 	//int targetdefense = GetTargetDefense(lpObj, lpTargetObj, MsgDamage);		
; 916  : 	
; 917  : #ifdef DUEL_SYSTEM_20031028		
; 918  : 	AttackDamage = GetAttackDamage(lpObj, targetdefense, bIsOnDuel, criticaldamage);

  00362	8b 45 14	 mov	 eax, DWORD PTR _criticaldamage$[ebp]
  00365	50		 push	 eax
  00366	8b 4d d0	 mov	 ecx, DWORD PTR _bIsOnDuel$[ebp]
  00369	51		 push	 ecx
  0036a	8b 55 bc	 mov	 edx, DWORD PTR _targetdefense$[ebp]
  0036d	52		 push	 edx
  0036e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00371	50		 push	 eax
  00372	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00375	e8 00 00 00 00	 call	 ?GetAttackDamage@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@HHH@Z ; CDarkSpirit::GetAttackDamage
  0037a	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax

; 919  : #else		
; 920  : 	AttackDamage = GetAttackDamage(lpObj, targetdefense, criticaldamage);	
; 921  : #endif	
; 922  : 
; 923  : 	//- 다크 스피릿 전체 공격일 때 나누어 준다.(apple)
; 924  : 	// ActionType == 0 : 전체공격
; 925  : 	// ActionType == 1 : 
; 926  : 
; 927  : #ifdef MODIFY_DARKSPIRIT_TAGET_ATTACK_01_20040906
; 928  : 	if( !criticaldamage && !iActionType )

  0037d	83 7d 14 00	 cmp	 DWORD PTR _criticaldamage$[ebp], 0
  00381	75 1a		 jne	 SHORT $LN29@Attack
  00383	83 7d 18 00	 cmp	 DWORD PTR _iActionType$[ebp], 0
  00387	75 14		 jne	 SHORT $LN29@Attack

; 929  : 		AttackDamage = AttackDamage/(1.5);	

  00389	f2 0f 2a 45 c4	 cvtsi2sd xmm0, DWORD PTR _AttackDamage$[ebp]
  0038e	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@3ff8000000000000
  00396	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0039a	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN29@Attack:

; 930  : #else
; 931  : 	if( !criticaldamage )
; 932  : 		AttackDamage = AttackDamage/(1.5);	
; 933  : #endif
; 934  : 	
; 935  : 
; 936  : #ifdef NEW_FORSKYLAND3
; 937  : 	if( bAllMiss )

  0039d	83 7d c8 00	 cmp	 DWORD PTR _bAllMiss$[ebp], 0
  003a1	74 0f		 je	 SHORT $LN30@Attack

; 938  : 	{
; 939  : #ifdef MODIFY_SUCCESSBLOCKING_ALLMISS_20040408
; 940  : 		AttackDamage =  AttackDamage*30/100;

  003a3	6b 45 c4 1e	 imul	 eax, DWORD PTR _AttackDamage$[ebp], 30
  003a7	99		 cdq
  003a8	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  003ad	f7 f9		 idiv	 ecx
  003af	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN30@Attack:

; 941  : #else
; 942  : 		AttackDamage =  AttackDamage*20/100;
; 943  : #endif
; 944  : 	}
; 945  : #endif
; 946  : 
; 947  : 	// 데미지를 감소 시킨다.
; 948  : 	if( lpTargetObj->DamageMinus )

  003b2	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003b5	0f b6 88 14 01
	00 00		 movzx	 ecx, BYTE PTR [eax+276]
  003bc	85 c9		 test	 ecx, ecx
  003be	74 26		 je	 SHORT $LN31@Attack

; 949  : 	{
; 950  : 		int beforeDamage=AttackDamage;

  003c0	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  003c3	89 45 b8	 mov	 DWORD PTR _beforeDamage$13[ebp], eax

; 951  : 		AttackDamage -=  AttackDamage*lpTargetObj->DamageMinus/100;

  003c6	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003c9	0f b6 88 14 01
	00 00		 movzx	 ecx, BYTE PTR [eax+276]
  003d0	8b c1		 mov	 eax, ecx
  003d2	0f af 45 c4	 imul	 eax, DWORD PTR _AttackDamage$[ebp]
  003d6	99		 cdq
  003d7	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  003dc	f7 f9		 idiv	 ecx
  003de	8b 55 c4	 mov	 edx, DWORD PTR _AttackDamage$[ebp]
  003e1	2b d0		 sub	 edx, eax
  003e3	89 55 c4	 mov	 DWORD PTR _AttackDamage$[ebp], edx
$LN31@Attack:

; 952  : 		//if( AttackDamage < 0 ) AttackDamage = 0;
; 953  : 		//LogAdd("데미지 감소 : %d -> %d (%d)",beforeDamage, AttackDamage,lpTargetObj->DamageMinus);
; 954  : 	}
; 955  : 
; 956  : 	// 때린녀석의레벨/10 보다 작을 경우 AttackDamage 수정 
; 957  : 	int tlevel = lpObj->Level/10;

  003e6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e9	0f bf 80 a0 00
	00 00		 movsx	 eax, WORD PTR [eax+160]
  003f0	99		 cdq
  003f1	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  003f6	f7 f9		 idiv	 ecx
  003f8	89 45 b4	 mov	 DWORD PTR _tlevel$[ebp], eax

; 958  : 	if( AttackDamage < tlevel )

  003fb	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  003fe	3b 45 b4	 cmp	 eax, DWORD PTR _tlevel$[ebp]
  00401	7d 13		 jge	 SHORT $LN32@Attack

; 959  : 	{
; 960  : 		if( tlevel < 1 ) tlevel = 1;

  00403	83 7d b4 01	 cmp	 DWORD PTR _tlevel$[ebp], 1
  00407	7d 07		 jge	 SHORT $LN33@Attack
  00409	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _tlevel$[ebp], 1
$LN33@Attack:

; 961  : 		AttackDamage = tlevel;

  00410	8b 45 b4	 mov	 eax, DWORD PTR _tlevel$[ebp]
  00413	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN32@Attack:

; 962  : 	}
; 963  : 
; 964  : 	// 방어스킬 사용시
; 965  : 	if( lpTargetObj->m_SkillNumber == AT_SKILL_BLOCKING )

  00416	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00419	0f bf 88 34 02
	00 00		 movsx	 ecx, WORD PTR [eax+564]
  00420	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00423	75 0e		 jne	 SHORT $LN35@Attack

; 966  : 		if( AttackDamage > 1 ) AttackDamage >>= 1;

  00425	83 7d c4 01	 cmp	 DWORD PTR _AttackDamage$[ebp], 1
  00429	7e 08		 jle	 SHORT $LN35@Attack
  0042b	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  0042e	d1 f8		 sar	 eax, 1
  00430	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN35@Attack:

; 967  : 
; 968  : 	// 다크스피릿 내구력 감소
; 969  : 	lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_DurabilitySmall += (AttackDamage*2)/100;

  00433	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00438	c1 e1 00	 shl	 ecx, 0
  0043b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0043e	8b b2 5c 0c 00
	00		 mov	 esi, DWORD PTR [edx+3164]
  00444	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00447	d1 e0		 shl	 eax, 1
  00449	99		 cdq
  0044a	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
  0044f	f7 ff		 idiv	 edi
  00451	0f b7 4c 0e 28	 movzx	 ecx, WORD PTR [esi+ecx+40]
  00456	03 c8		 add	 ecx, eax
  00458	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0045d	c1 e2 00	 shl	 edx, 0
  00460	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00463	8b 80 5c 0c 00
	00		 mov	 eax, DWORD PTR [eax+3164]
  00469	66 89 4c 10 28	 mov	 WORD PTR [eax+edx+40], cx

; 970  : 
; 971  : #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428	// 펫 내구 소모 속도 감소 (다크스피릿)
; 972  : 	if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_DurabilitySmall >= 800 + lpObj->m_MPSkillOpt.iMpsPetDurDownSpeed)
; 973  : #else // UPDATE_MASTER_LEVEL_4RANK_20080428
; 974  : 	if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_DurabilitySmall >= 800 )

  0046e	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00473	c1 e0 00	 shl	 eax, 0
  00476	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00479	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0047f	0f b7 44 02 28	 movzx	 eax, WORD PTR [edx+eax+40]
  00484	3d 20 03 00 00	 cmp	 eax, 800		; 00000320H
  00489	0f 8c ac 01 00
	00		 jl	 $LN36@Attack

; 975  : #endif // UPDATE_MASTER_LEVEL_4RANK_20080428
; 976  : 	{
; 977  : 		lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_DurabilitySmall = 0;

  0048f	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00494	c1 e0 00	 shl	 eax, 0
  00497	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0049a	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  004a0	33 c9		 xor	 ecx, ecx
  004a2	66 89 4c 02 28	 mov	 WORD PTR [edx+eax+40], cx

; 978  : 		lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Durability--;

  004a7	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  004ac	c1 e0 00	 shl	 eax, 0
  004af	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004b2	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  004b8	f3 0f 10 44 02
	24		 movss	 xmm0, DWORD PTR [edx+eax+36]
  004be	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  004c6	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  004cb	c1 e0 00	 shl	 eax, 0
  004ce	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004d1	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  004d7	f3 0f 11 44 02
	24		 movss	 DWORD PTR [edx+eax+36], xmm0

; 979  : 		if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Durability < 1 )	

  004dd	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  004e2	c1 e0 00	 shl	 eax, 0
  004e5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004e8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  004ee	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004f6	0f 2f 44 02 24	 comiss	 xmm0, DWORD PTR [edx+eax+36]
  004fb	0f 86 0d 01 00
	00		 jbe	 $LN38@Attack

; 980  : 		{
; 981  : 			lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Durability = 0.f;			

  00501	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00506	c1 e0 00	 shl	 eax, 0
  00509	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0050c	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00512	0f 57 c0	 xorps	 xmm0, xmm0
  00515	f3 0f 11 44 02
	24		 movss	 DWORD PTR [edx+eax+36], xmm0

; 982  : 			int	exp = lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp;

  0051b	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00520	c1 e0 00	 shl	 eax, 0
  00523	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00526	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0052c	8b 84 02 a4 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+164]
  00533	89 45 b0	 mov	 DWORD PTR _exp$12[ebp], eax

; 983  : 			if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].DecPetItemExp(10) )	// 경험치 10% 감소

  00536	6a 0a		 push	 10			; 0000000aH
  00538	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0053d	c1 e1 00	 shl	 ecx, 0
  00540	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00543	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00549	e8 00 00 00 00	 call	 ?DecPetItemExp@CItem@@QAEHH@Z ; CItem::DecPetItemExp
  0054e	85 c0		 test	 eax, eax
  00550	0f 84 b8 00 00
	00		 je	 $LN38@Attack

; 984  : 			{	// 경험치 감소에 의해 레벨 다운이 생겼다
; 985  : 				LogAddTD("[%s][%s][PetItemExpDown] [%s] Level:[%d]Exp:[%d]DecExp[%d]", 

  00556	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0055b	c1 e0 00	 shl	 eax, 0
  0055e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00561	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00567	8b 4d b0	 mov	 ecx, DWORD PTR _exp$12[ebp]
  0056a	2b 8c 02 a4 00
	00 00		 sub	 ecx, DWORD PTR [edx+eax+164]
  00571	51		 push	 ecx
  00572	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  00577	c1 e2 00	 shl	 edx, 0
  0057a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057d	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00583	8b 94 11 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+164]
  0058a	52		 push	 edx
  0058b	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00590	c1 e0 00	 shl	 eax, 0
  00593	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00596	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0059c	8b 84 02 a0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+160]
  005a3	50		 push	 eax
  005a4	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  005a9	c1 e1 00	 shl	 ecx, 0
  005ac	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005af	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  005b5	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  005ba	50		 push	 eax
  005bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005be	83 c0 73	 add	 eax, 115		; 00000073H
  005c1	50		 push	 eax
  005c2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005c5	83 c1 68	 add	 ecx, 104		; 00000068H
  005c8	51		 push	 ecx
  005c9	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5L@
  005ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005d4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 986  : 						lpObj->AccountID, lpObj->Name,
; 987  : 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].GetName(),
; 988  : 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Level,
; 989  : 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp,
; 990  : 						exp-lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp);
; 991  : 				
; 992  : 				Set(lpObj->m_Index, &lpObj->pInventory[EQUIPMENT_WEAPON_LEFT]);		

  005d7	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  005dc	c1 e0 00	 shl	 eax, 0
  005df	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005e2	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  005e8	50		 push	 eax
  005e9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005ec	8b 02		 mov	 eax, DWORD PTR [edx]
  005ee	50		 push	 eax
  005ef	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005f2	e8 00 00 00 00	 call	 ?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z ; CDarkSpirit::Set

; 993  : 				CDarkSpirit::SendLevelmsg(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, 0, 255);

  005f7	68 ff 00 00 00	 push	 255			; 000000ffH
  005fc	6a 00		 push	 0
  005fe	6a 01		 push	 1
  00600	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00603	8b 08		 mov	 ecx, DWORD PTR [eax]
  00605	51		 push	 ecx
  00606	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  0060b	83 c4 10	 add	 esp, 16			; 00000010H
$LN38@Attack:

; 994  : 			}
; 995  : 
; 996  : #if TESTSERVER == 1
; 997  : 			DebugOutput(lpObj->m_Index, "[%s] LevelDown Lv:%d Exp:%d", 
; 998  : 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].GetName(),				
; 999  : 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Level, 
; 1000 : 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp);
; 1001 : #endif
; 1002 : 
; 1003 : #ifdef MODIFY_LOG_SYSTEM_2_3_20060828
; 1004 : 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 1005 : 				LogAddTD("[%s][%s] 다크스피릿의발톱 Item is Broken because durability is exhausted [%u]",
; 1006 : 	#else
; 1007 : 				LogAddTD("[%s][%s] 다크스피릿의발톱 Item is Broken because durability is exhausted [%d]",
; 1008 : 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 1009 : 					lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Number );
; 1010 : #else
; 1011 : 	#ifdef EXTEND_LOG_SYSTEM_03_20060816
; 1012 : 				LogAddTD("다크스피릿의발톱 Item is Broken because durability is exhausted");
; 1013 : 	#endif // EXTEND_LOG_SYSTEM_03_20060816
; 1014 : #endif // MODIFY_LOG_SYSTEM_2_3_20060828
; 1015 : 		}
; 1016 : 		GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, (BYTE)lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Durability, 0);		

  0060e	6a 00		 push	 0
  00610	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00615	c1 e0 00	 shl	 eax, 0
  00618	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0061b	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00621	f3 0f 2c 44 02
	24		 cvttss2si eax, DWORD PTR [edx+eax+36]
  00627	0f b6 c8	 movzx	 ecx, al
  0062a	51		 push	 ecx
  0062b	6a 01		 push	 1
  0062d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00630	8b 02		 mov	 eax, DWORD PTR [edx]
  00632	50		 push	 eax
  00633	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00638	83 c4 10	 add	 esp, 16			; 00000010H
$LN36@Attack:

; 1017 : 	}
; 1018 : 	
; 1019 : 	// 상대가 천사정령을 가지고 있다면.. 
; 1020 : 	if( gObjAngelSprite(lpTargetObj) == TRUE )

  0063b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0063e	50		 push	 eax
  0063f	e8 00 00 00 00	 call	 ?gObjAngelSprite@@YAHPAVOBJECTSTRUCT@@@Z ; gObjAngelSprite
  00644	83 c4 04	 add	 esp, 4
  00647	83 f8 01	 cmp	 eax, 1
  0064a	75 25		 jne	 SHORT $LN40@Attack

; 1021 : 	{
; 1022 : 		if( AttackDamage > 1 ) 

  0064c	83 7d c4 01	 cmp	 DWORD PTR _AttackDamage$[ebp], 1
  00650	7e 1f		 jle	 SHORT $LN40@Attack

; 1023 : 		{
; 1024 : #ifdef NEW_FORSKYLAND3	// 수로천사 데미지 흡수 30%에서 20%로 조정
; 1025 : 			float damage = (float)(AttackDamage*8)/10;

  00652	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00655	c1 e0 03	 shl	 eax, 3
  00658	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0065c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00664	f3 0f 11 45 ac	 movss	 DWORD PTR _damage$11[ebp], xmm0

; 1026 : #else
; 1027 : 			float damage = (float)(AttackDamage*7)/10;
; 1028 : #endif
; 1029 : 			AttackDamage = (int)damage;// 10분의 7은 사용자가..  

  00669	f3 0f 2c 45 ac	 cvttss2si eax, DWORD PTR _damage$11[ebp]
  0066e	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN40@Attack:

; 1030 : 		}
; 1031 : 	}
; 1032 : 
; 1033 : 	if( gObjWingSprite(lpTargetObj) == TRUE )

  00671	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00674	50		 push	 eax
  00675	e8 00 00 00 00	 call	 ?gObjWingSprite@@YAHPAVOBJECTSTRUCT@@@Z ; gObjWingSprite
  0067a	83 c4 04	 add	 esp, 4
  0067d	83 f8 01	 cmp	 eax, 1
  00680	0f 85 8d 00 00
	00		 jne	 $LN44@Attack

; 1034 : 	{
; 1035 : 		CItem	*Wing = &lpTargetObj->pInventory[EQUIPMENT_WING];

  00686	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0068b	6b c8 07	 imul	 ecx, eax, 7
  0068e	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00691	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00697	89 4d a8	 mov	 DWORD PTR _Wing$10[ebp], ecx

; 1036 : 		if( AttackDamage > 1 ) 

  0069a	83 7d c4 01	 cmp	 DWORD PTR _AttackDamage$[ebp], 1
  0069e	7e 73		 jle	 SHORT $LN44@Attack

; 1037 : 		{
; 1038 : #ifdef ADD_THIRD_WING_20070525	// 3차날개 데미지 흡수 적용
; 1039 : 				if( Wing->m_Type == MAKE_ITEMNUM( 12, 36 )		// 폭풍의날개
; 1040 : 					|| Wing->m_Type == MAKE_ITEMNUM( 12, 37 )	// 시공의날개  
; 1041 : 					|| Wing->m_Type == MAKE_ITEMNUM( 12, 38 )	// 환영의날개
; 1042 : 					|| Wing->m_Type == MAKE_ITEMNUM( 12, 39 )	// 파멸의날개
; 1043 : 					)
; 1044 : 				{
; 1045 : 					// 39% + ( level * 2 )
; 1046 : 					float damage = ( float )( AttackDamage * ( 61 - ( Wing->m_Level * 2 )) ) / 100;
; 1047 : 					AttackDamage = ( int )damage;
; 1048 : 				}
; 1049 : 				else if( Wing->m_Type == MAKE_ITEMNUM( 12, 40 ) )	// 제왕의망토
; 1050 : 				{
; 1051 : 					// 24% + ( level * 2 )
; 1052 : 					float damage = ( float )( AttackDamage * ( 76 - ( Wing->m_Level * 2 )) ) / 100;
; 1053 : 					AttackDamage = ( int )damage;
; 1054 : 				}
; 1055 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 신규캐릭터 1차날개(재앙의 날개) 데미지흡수 12% + level*2
; 1056 : 				else if( Wing->m_Type == MAKE_ITEMNUM( 12, 41 ) )	// 신규캐릭터 1차 날개(재앙의 날개)
; 1057 : 				{
; 1058 : 					float damage = (float)(AttackDamage*(88-(Wing->m_Level*2)))/100;
; 1059 : 					AttackDamage = (int)damage;	
; 1060 : 				}
; 1061 : #endif // ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 1062 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 절망의 날개 데미지 흡수
; 1063 : 				else if( Wing->m_Type == MAKE_ITEMNUM( 12, 42 ) )	// 신규캐릭터 2차 날개(절망의 날개)
; 1064 : 				{
; 1065 : 					float damage = (float)(AttackDamage*(75-(Wing->m_Level*2)))/100;
; 1066 : 					AttackDamage = (int)damage;	
; 1067 : 				}
; 1068 : 				else if( Wing->m_Type == MAKE_ITEMNUM( 12, 43 ) )	// 신규캐릭터 3차 날개(차원의 날개)
; 1069 : 				{
; 1070 : 					float damage = (float)(AttackDamage*(61-(Wing->m_Level*2)))/100;
; 1071 : 					AttackDamage = (int)damage;	
; 1072 : 				}
; 1073 : #endif				
; 1074 : 				else
; 1075 : #endif	// ADD_THIRD_WING_20070525			
; 1076 : #ifdef NEW_FORSKYLAND3
; 1077 : 				if( Wing->m_Type > MAKE_ITEMNUM(12,2) )

  006a0	8b 45 a8	 mov	 eax, DWORD PTR _Wing$10[ebp]
  006a3	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  006a7	6a 02		 push	 2
  006a9	6a 0c		 push	 12			; 0000000cH
  006ab	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  006b0	83 c4 08	 add	 esp, 8
  006b3	3b f0		 cmp	 esi, eax
  006b5	7e 2f		 jle	 SHORT $LN43@Attack

; 1078 : 				{	// 날개 데미지 흡수 추가 날개는 25% + level
; 1079 : 					float damage = (float)(AttackDamage*(75-(Wing->m_Level*2)))/100;

  006b7	8b 45 a8	 mov	 eax, DWORD PTR _Wing$10[ebp]
  006ba	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  006be	d1 e1		 shl	 ecx, 1
  006c0	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  006c5	2b d1		 sub	 edx, ecx
  006c7	0f af 55 c4	 imul	 edx, DWORD PTR _AttackDamage$[ebp]
  006cb	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  006cf	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  006d7	f3 0f 11 45 a4	 movss	 DWORD PTR _damage$9[ebp], xmm0

; 1080 : 					AttackDamage = (int)damage;

  006dc	f3 0f 2c 45 a4	 cvttss2si eax, DWORD PTR _damage$9[ebp]
  006e1	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax

; 1081 : 				}

  006e4	eb 2d		 jmp	 SHORT $LN44@Attack
$LN43@Attack:

; 1082 : 				else
; 1083 : #endif			
; 1084 : 				{	// 날개 데미지 흡수 날개 12% + level*2
; 1085 : 					float damage = (float)(AttackDamage*(88-(Wing->m_Level*2)))/100;

  006e6	8b 45 a8	 mov	 eax, DWORD PTR _Wing$10[ebp]
  006e9	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  006ed	d1 e1		 shl	 ecx, 1
  006ef	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  006f4	2b d1		 sub	 edx, ecx
  006f6	0f af 55 c4	 imul	 edx, DWORD PTR _AttackDamage$[ebp]
  006fa	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  006fe	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00706	f3 0f 11 45 a0	 movss	 DWORD PTR _damage$8[ebp], xmm0

; 1086 : 					AttackDamage = (int)damage;	

  0070b	f3 0f 2c 45 a0	 cvttss2si eax, DWORD PTR _damage$8[ebp]
  00710	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN44@Attack:

; 1087 : 				}
; 1088 : 			//LogAdd("[%s][%s] 날개 착용 효과2 %d", lpObj->AccountID, lpObj->Name, AttackDamage);
; 1089 : 		}		
; 1090 : 	}
; 1091 : 
; 1092 : #ifdef NEW_FORSKYLAND3
; 1093 : 	if( gObjDenorantSprite(lpTargetObj) )

  00713	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00716	50		 push	 eax
  00717	e8 00 00 00 00	 call	 ?gObjDenorantSprite@@YAHPAVOBJECTSTRUCT@@@Z ; gObjDenorantSprite
  0071c	83 c4 04	 add	 esp, 4
  0071f	85 c0		 test	 eax, eax
  00721	0f 84 99 00 00
	00		 je	 $LN45@Attack

; 1094 : 	{	// 디노란트 데미지 흡수 10%
; 1095 : 		CItem	*Dinorant = &lpTargetObj->pInventory[EQUIPMENT_HELPER];

  00727	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0072c	c1 e0 03	 shl	 eax, 3
  0072f	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00732	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00738	89 45 9c	 mov	 DWORD PTR _Dinorant$7[ebp], eax

; 1096 : 
; 1097 : 		// 5%추가 데미지 흡수 옵션 적용
; 1098 : 		int	dinorantdecdamage = 90-Dinorant->IsDinorantReduceAttackDamaege();			

  0073b	8b 4d 9c	 mov	 ecx, DWORD PTR _Dinorant$7[ebp]
  0073e	e8 00 00 00 00	 call	 ?IsDinorantReduceAttackDamaege@CItem@@QAEHXZ ; CItem::IsDinorantReduceAttackDamaege
  00743	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00748	2b c8		 sub	 ecx, eax
  0074a	89 4d 98	 mov	 DWORD PTR _dinorantdecdamage$6[ebp], ecx

; 1099 : 		lpObj->Life -= 1;

  0074d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00750	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  00758	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00760	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00763	f3 0f 11 81 bc
	00 00 00	 movss	 DWORD PTR [ecx+188], xmm0

; 1100 : 		
; 1101 : 		if( lpObj->Life < 0 ) 

  0076b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0076e	0f 57 c0	 xorps	 xmm0, xmm0
  00771	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00778	76 10		 jbe	 SHORT $LN46@Attack

; 1102 : 		{
; 1103 : 			lpObj->Life = 0;

  0077a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0077d	0f 57 c0	 xorps	 xmm0, xmm0
  00780	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0

; 1104 : 		}

  00788	eb 12		 jmp	 SHORT $LN47@Attack
$LN46@Attack:

; 1105 : 		else
; 1106 : 		{
; 1107 : 			AttackDamage = AttackDamage*dinorantdecdamage/100;

  0078a	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  0078d	0f af 45 98	 imul	 eax, DWORD PTR _dinorantdecdamage$6[ebp]
  00791	99		 cdq
  00792	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00797	f7 f9		 idiv	 ecx
  00799	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN47@Attack:

; 1108 : 		}
; 1109 : 		
; 1110 : #ifdef ADD_SHIELD_POINT_01_20060403
; 1111 : 		GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0, (WORD)lpObj->iShield);
; 1112 : #else
; 1113 : 		GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0);

  0079c	6a 00		 push	 0
  0079e	68 ff 00 00 00	 push	 255			; 000000ffH
  007a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007a6	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  007ae	0f b7 d1	 movzx	 edx, cx
  007b1	52		 push	 edx
  007b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  007b7	51		 push	 ecx
  007b8	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  007bd	83 c4 10	 add	 esp, 16			; 00000010H
$LN45@Attack:

; 1114 : #endif
; 1115 : 		
; 1116 : 	}
; 1117 : #endif
; 1118 : 
; 1119 : #ifdef DARKLORD_WORK
; 1120 : 	if( gObjDarkHorse(lpTargetObj) )

  007c0	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  007c3	50		 push	 eax
  007c4	e8 00 00 00 00	 call	 ?gObjDarkHorse@@YAHPAVOBJECTSTRUCT@@@Z ; gObjDarkHorse
  007c9	83 c4 04	 add	 esp, 4
  007cc	85 c0		 test	 eax, eax
  007ce	0f 84 a2 00 00
	00		 je	 $LN48@Attack

; 1121 : 	{	// 다크호스 데미지 흡수 (10+(통솔/100))
; 1122 : 		CItem	*Darkhorse = &lpTargetObj->pInventory[EQUIPMENT_HELPER];	

  007d4	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  007d9	c1 e0 03	 shl	 eax, 3
  007dc	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  007df	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  007e5	89 45 94	 mov	 DWORD PTR _Darkhorse$5[ebp], eax

; 1123 : 
; 1124 : 		int	decdamage = 100-((30+Darkhorse->m_PetItem_Level)/2);

  007e8	8b 45 94	 mov	 eax, DWORD PTR _Darkhorse$5[ebp]
  007eb	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]
  007f1	83 c0 1e	 add	 eax, 30			; 0000001eH
  007f4	99		 cdq
  007f5	2b c2		 sub	 eax, edx
  007f7	d1 f8		 sar	 eax, 1
  007f9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  007fe	2b c8		 sub	 ecx, eax
  00800	89 4d 90	 mov	 DWORD PTR _decdamage$4[ebp], ecx

; 1125 : 		
; 1126 : 
; 1127 : 		//int	decdamage = (90-(lpTargetObj->Leadership+lpTargetObj->AddLeadership)/200);
; 1128 : 		lpTargetObj->Life -= 1;

  00803	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00806	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  0080e	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00816	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00819	f3 0f 11 81 bc
	00 00 00	 movss	 DWORD PTR [ecx+188], xmm0

; 1129 : 		
; 1130 : 		if( lpTargetObj->Life < 0 ) 

  00821	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00824	0f 57 c0	 xorps	 xmm0, xmm0
  00827	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  0082e	76 10		 jbe	 SHORT $LN49@Attack

; 1131 : 		{
; 1132 : 			lpTargetObj->Life = 0;

  00830	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00833	0f 57 c0	 xorps	 xmm0, xmm0
  00836	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0

; 1133 : 		}

  0083e	eb 12		 jmp	 SHORT $LN50@Attack
$LN49@Attack:

; 1134 : 		else
; 1135 : 		{
; 1136 : 			AttackDamage = AttackDamage*decdamage/100;

  00840	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00843	0f af 45 90	 imul	 eax, DWORD PTR _decdamage$4[ebp]
  00847	99		 cdq
  00848	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0084d	f7 f9		 idiv	 ecx
  0084f	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN50@Attack:

; 1137 : 		}
; 1138 : 
; 1139 : #ifdef ADD_SHIELD_POINT_01_20060403
; 1140 : 		GCReFillSend(lpTargetObj->m_Index, (WORD)lpTargetObj->Life, 0xFF, 0, (WORD)lpTargetObj->iShield);
; 1141 : #else
; 1142 : 		GCReFillSend(lpTargetObj->m_Index, (WORD)lpTargetObj->Life, 0xFF, 0);

  00852	6a 00		 push	 0
  00854	68 ff 00 00 00	 push	 255			; 000000ffH
  00859	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0085c	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  00864	0f b7 d1	 movzx	 edx, cx
  00867	52		 push	 edx
  00868	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0086b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0086d	51		 push	 ecx
  0086e	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00873	83 c4 10	 add	 esp, 16			; 00000010H
$LN48@Attack:

; 1143 : #endif // ADD_SHIELD_POINT_01_20060403
; 1144 : 
; 1145 : 	}
; 1146 : #endif
; 1147 : 	
; 1148 : 	if( lpTargetObj->Live ) 

  00876	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00879	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  0087d	85 c9		 test	 ecx, ecx
  0087f	0f 84 a0 01 00
	00		 je	 $LN56@Attack

; 1149 : 	{			
; 1150 : 		//#BUGFIX_DARKSPRITE_DINORANT_DAMAGE_20041005
; 1151 : //		if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,3) )
; 1152 : //		{	// 디노란트 일반 공격도 데미지 추가
; 1153 : //			AttackDamage = AttackDamage*130/100;
; 1154 : //		}
; 1155 : 
; 1156 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1157 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 소울바리어 : 데미지를 마나로 흡수(CDarkSpirit)
; 1158 : 		if( ( gObjCheckUsedBuffEffect( lpTargetObj, BUFFTYPE_MELEE_DEFENSE_INC ) == true ) && AttackDamage > 0 )
; 1159 : 		{	// 법사 소울바리어(데미지를 마나로 흡수 시킨다)
; 1160 : 			// 데미지를 마나로
; 1161 : 			int iWizardSkillDefense = 0;
; 1162 : 			int iManaRate			= 0;
; 1163 : 			gObjGetValueOfBuffIndex( lpTargetObj, BUFFTYPE_MELEE_DEFENSE_INC, &iWizardSkillDefense, &iManaRate );
; 1164 : 			// 마나 감소			
; 1165 : 			int iReplacementMana = 0;
; 1166 : 			if( iManaRate > 0 )
; 1167 : 				iReplacementMana = (WORD)lpTargetObj->Mana * iManaRate / 1000;	
; 1168 : 			else
; 1169 : 				iReplacementMana = (WORD)lpTargetObj->Mana * 2 / 100;	
; 1170 : 
; 1171 : 			if( lpTargetObj->Mana > iReplacementMana )
; 1172 : 			{	
; 1173 : 				// 사용가능한 마나가 있어야 된다
; 1174 : 				lpTargetObj->Mana -= iReplacementMana;				
; 1175 : 
; 1176 : 				int decattackdamage = 0;
; 1177 : 				if( iWizardSkillDefense > 0 )
; 1178 : 					decattackdamage = AttackDamage * iWizardSkillDefense / 100;	
; 1179 : 
; 1180 : 				// 데미지 감소
; 1181 : 				AttackDamage -= decattackdamage;
; 1182 : 				ManaChange = TRUE;
; 1183 : 			}
; 1184 : 		}
; 1185 : 
; 1186 : #else
; 1187 : 		if( ( gObjCheckUsedBuffEffect( lpTargetObj, BUFFTYPE_MELEE_DEFENSE_INC ) == true ) && AttackDamage > 0 )
; 1188 : 		{	// 법사 소울바리어(데미지를 마나로 흡수 시킨다)
; 1189 : 			int replacemana = (WORD)lpTargetObj->Mana*2/100;		// 마나 2%감소
; 1190 : 			if( lpTargetObj->Mana > replacemana )
; 1191 : 			{	// 사용가능한 마나가 있어야 된다
; 1192 : 				lpTargetObj->Mana -= replacemana;				// 데미지를 마나로
; 1193 : 				int iWizardSkillDefense = 0;
; 1194 : 				gObjGetValueOfBuffIndex( lpTargetObj, BUFFTYPE_MELEE_DEFENSE_INC, &iWizardSkillDefense );
; 1195 : 				int decattackdamage = AttackDamage * iWizardSkillDefense / 100;	// 데미지 감소
; 1196 : 
; 1197 : 				AttackDamage -= decattackdamage;
; 1198 : 				ManaChange = TRUE;
; 1199 : 			}
; 1200 : 		}
; 1201 : #endif	// ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107
; 1202 : #else
; 1203 : 		if( lpTargetObj->m_WizardSkillDefense && AttackDamage > 0 )

  00885	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00888	83 b8 0c 1a 00
	00 00		 cmp	 DWORD PTR [eax+6668], 0
  0088f	74 7f		 je	 SHORT $LN53@Attack
  00891	83 7d c4 00	 cmp	 DWORD PTR _AttackDamage$[ebp], 0
  00895	7e 79		 jle	 SHORT $LN53@Attack

; 1204 : 		{	// 법사 소울바리어(데미지를 마나로 흡수 시킨다)
; 1205 : 			int replacemana = (WORD)lpTargetObj->Mana*2/100;		// 마나 2%감소

  00897	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0089a	f3 0f 2c 88 d0
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+208]
  008a2	0f b7 c1	 movzx	 eax, cx
  008a5	d1 e0		 shl	 eax, 1
  008a7	99		 cdq
  008a8	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  008ad	f7 f9		 idiv	 ecx
  008af	89 45 8c	 mov	 DWORD PTR _replacemana$3[ebp], eax

; 1206 : 			if( lpTargetObj->Mana > replacemana )

  008b2	f3 0f 2a 45 8c	 cvtsi2ss xmm0, DWORD PTR _replacemana$3[ebp]
  008b7	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  008ba	f3 0f 10 88 d0
	00 00 00	 movss	 xmm1, DWORD PTR [eax+208]
  008c2	0f 2f c8	 comiss	 xmm1, xmm0
  008c5	76 49		 jbe	 SHORT $LN53@Attack

; 1207 : 			{	// 사용가능한 마나가 있어야 된다
; 1208 : 				lpTargetObj->Mana -= replacemana;				// 데미지를 마나로

  008c7	f3 0f 2a 45 8c	 cvtsi2ss xmm0, DWORD PTR _replacemana$3[ebp]
  008cc	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  008cf	f3 0f 10 88 d0
	00 00 00	 movss	 xmm1, DWORD PTR [eax+208]
  008d7	f3 0f 5c c8	 subss	 xmm1, xmm0
  008db	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  008de	f3 0f 11 89 d0
	00 00 00	 movss	 DWORD PTR [ecx+208], xmm1

; 1209 : 					int decattackdamage = AttackDamage*lpTargetObj->m_WizardSkillDefense/100;	// 데미지 감소

  008e6	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  008e9	8b 4d c4	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  008ec	0f af 88 0c 1a
	00 00		 imul	 ecx, DWORD PTR [eax+6668]
  008f3	8b c1		 mov	 eax, ecx
  008f5	99		 cdq
  008f6	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  008fb	f7 f9		 idiv	 ecx
  008fd	89 45 88	 mov	 DWORD PTR _decattackdamage$2[ebp], eax

; 1210 : 
; 1211 : 				AttackDamage -= decattackdamage;

  00900	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00903	2b 45 88	 sub	 eax, DWORD PTR _decattackdamage$2[ebp]
  00906	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax

; 1212 : 				ManaChange = TRUE;

  00909	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _ManaChange$[ebp], 1
$LN53@Attack:

; 1213 : 			}
; 1214 : 		}
; 1215 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1216 : 
; 1217 : #ifdef CHAOSCASTLE_SYSTEM_20040408		// 카오스 캐슬 안에서 사용자 끼리 공격 시 데미지 절반
; 1218 : 	#ifdef ADD_SHIELD_POINT_01_20060403
; 1219 : 		if( g_ShieldSystemOn == FALSE )
; 1220 : 	#endif // ADD_SHIELD_POINT_01_20060403
; 1221 : 		{
; 1222 : 			if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER )

  00910	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00913	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00917	83 f9 01	 cmp	 ecx, 1
  0091a	0f 85 c9 00 00
	00		 jne	 $LN55@Attack
  00920	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00923	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00927	83 f9 01	 cmp	 ecx, 1
  0092a	0f 85 b9 00 00
	00		 jne	 $LN55@Attack

; 1223 : 			{
; 1224 : 				if (CHECK_CHAOSCASTLE(lpObj->MapNumber) && CHECK_CHAOSCASTLE(lpTargetObj->MapNumber)) {

  00930	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00933	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0093a	83 f9 12	 cmp	 ecx, 18			; 00000012H
  0093d	7d 0c		 jge	 SHORT $LN96@Attack
  0093f	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv527[ebp], 0
  00949	eb 31		 jmp	 SHORT $LN97@Attack
$LN96@Attack:
  0094b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0094e	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00955	83 f8 17	 cmp	 eax, 23			; 00000017H
  00958	7e 0c		 jle	 SHORT $LN94@Attack
  0095a	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv526[ebp], 0
  00964	eb 0a		 jmp	 SHORT $LN95@Attack
$LN94@Attack:
  00966	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv526[ebp], 1
$LN95@Attack:
  00970	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv526[ebp]
  00976	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv527[ebp], ecx
$LN97@Attack:
  0097c	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv527[ebp], 0
  00983	74 64		 je	 SHORT $LN55@Attack
  00985	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00988	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0098f	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00992	7d 0c		 jge	 SHORT $LN100@Attack
  00994	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv536[ebp], 0
  0099e	eb 31		 jmp	 SHORT $LN101@Attack
$LN100@Attack:
  009a0	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  009a3	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  009aa	83 f8 17	 cmp	 eax, 23			; 00000017H
  009ad	7e 0c		 jle	 SHORT $LN98@Attack
  009af	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv535[ebp], 0
  009b9	eb 0a		 jmp	 SHORT $LN99@Attack
$LN98@Attack:
  009bb	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv535[ebp], 1
$LN99@Attack:
  009c5	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv535[ebp]
  009cb	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv536[ebp], ecx
$LN101@Attack:
  009d1	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv536[ebp], 0
  009d8	74 0f		 je	 SHORT $LN55@Attack

; 1225 : 					AttackDamage = AttackDamage * 50 / 100;

  009da	6b 45 c4 32	 imul	 eax, DWORD PTR _AttackDamage$[ebp], 50
  009de	99		 cdq
  009df	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  009e4	f7 f9		 idiv	 ecx
  009e6	89 45 c4	 mov	 DWORD PTR _AttackDamage$[ebp], eax
$LN55@Attack:

; 1226 : 				}
; 1227 : 			}
; 1228 : 		}
; 1229 : #endif
; 1230 : 		
; 1231 : #ifdef CASTLE_MAIN_SCHEDULER_20041111	// 공성전 중에 공성맵 안에서는 사용자 끼리 공격 시 데미지 같은편 80% 감소, 다른편 60% 감소
; 1232 : 		if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 1233 : 			if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER )
; 1234 : 			{
; 1235 : 				if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE && lpTargetObj->MapNumber == MAP_INDEX_CASTLESIEGE) {
; 1236 : 					if (lpObj->m_btCsJoinSide == lpTargetObj->m_btCsJoinSide) {
; 1237 : 						AttackDamage = AttackDamage * 20 / 100;
; 1238 : 					}
; 1239 : 					else 
; 1240 : 					{
; 1241 : 	#ifdef ADD_SHIELD_POINT_01_20060403
; 1242 : 						if( g_ShieldSystemOn == FALSE )
; 1243 : 	#endif	// ADD_SHIELD_POINT_01_20060403
; 1244 : 						{
; 1245 : 							AttackDamage = AttackDamage * 40 / 100;
; 1246 : 						}
; 1247 : 					}
; 1248 : 				}
; 1249 : 			}
; 1250 : 		}
; 1251 : #endif
; 1252 : 
; 1253 : #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116 // 축복의 물약 사용 효과!
; 1254 : 		if( lpObj->Type == OBJTYPE_CHARACTER 
; 1255 : 			&& lpTargetObj->Type == OBJTYPE_MONSTER )
; 1256 : 		{
; 1257 : 			// 수호 석상 때릴 때
; 1258 : 			if( lpTargetObj->Class == 283 )
; 1259 : 			{
; 1260 : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1261 : 				if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_BLESS_POTION )
; 1262 : 					|| gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SOUL_POTION )
; 1263 : 				  )
; 1264 : 	#else
; 1265 : 				if( lpObj->m_iPotionBlessTime > 0 
; 1266 : 					|| lpObj->m_iPotionSoulTime > 0 )
; 1267 : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1268 : 				{
; 1269 : 					// 추가 내구력 저하 없음.
; 1270 : 					AttackDamage = AttackDamage + AttackDamage * 20 / 100;
; 1271 : 				}
; 1272 : 				else
; 1273 : 				{
; 1274 : 					if( lpObj->m_iAccumulatedDamage > 100 )
; 1275 : 					{
; 1276 : 						gObjWeaponDurDownInCastle( lpObj, lpTargetObj, 1 );	
; 1277 : 						lpObj->m_iAccumulatedDamage = 0;
; 1278 : 					}
; 1279 : 					else
; 1280 : 					{
; 1281 : 						lpObj->m_iAccumulatedDamage += AttackDamage;
; 1282 : 					}
; 1283 : 
; 1284 : 					// 데미지 20%만 적용
; 1285 : 					AttackDamage = AttackDamage * 20 / 100;
; 1286 : 
; 1287 : 				}
; 1288 : 
; 1289 : 			}
; 1290 : 
; 1291 : 			// 성문 때릴 때
; 1292 : 			if( lpTargetObj->Class == 277 )
; 1293 : 			{
; 1294 : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1295 : 				if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_BLESS_POTION )
; 1296 : 					|| gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SOUL_POTION )
; 1297 : 				  )
; 1298 : 	#else
; 1299 : 				if( lpObj->m_iPotionBlessTime > 0 
; 1300 : 					|| lpObj->m_iPotionSoulTime > 0 )
; 1301 : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1302 : 				{
; 1303 : 					// 추가 내구력 저하 없음.
; 1304 : 					AttackDamage = AttackDamage + AttackDamage * 20 / 100;
; 1305 : 				}
; 1306 : 				else
; 1307 : 				{
; 1308 : 					if( lpObj->m_iAccumulatedDamage > 100 )
; 1309 : 					{
; 1310 : 						gObjWeaponDurDownInCastle( lpObj, lpTargetObj, 1 );	
; 1311 : 						lpObj->m_iAccumulatedDamage = 0;
; 1312 : 					}
; 1313 : 					else
; 1314 : 					{
; 1315 : 						lpObj->m_iAccumulatedDamage += AttackDamage;
; 1316 : 					}
; 1317 : 
; 1318 : 					// 데미지 20%만 적용
; 1319 : 					AttackDamage = AttackDamage * 20 / 100;
; 1320 : 
; 1321 : 				}
; 1322 : 			}
; 1323 : 
; 1324 : 		}
; 1325 : #endif
; 1326 : 					
; 1327 : #ifdef ADD_SHIELD_POINT_01_20060403
; 1328 : 		if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER )
; 1329 : 		{
; 1330 : 			iTempShieldDamage		= GetShieldDamage( lpObj, lpTargetObj, AttackDamage );
; 1331 : 			lpTargetObj->iShield	= lpTargetObj->iShield - iTempShieldDamage;
; 1332 : 			lpTargetObj->Life		= lpTargetObj->Life - (AttackDamage - iTempShieldDamage);
; 1333 : 			iTotalShieldDamage		= iTotalShieldDamage + iTempShieldDamage;
; 1334 : 
; 1335 : 			if( lpTargetObj->Life < 0 )
; 1336 : 			{
; 1337 : 				lpTargetObj->Life = 0;
; 1338 : 			}
; 1339 : 		}
; 1340 : 		else
; 1341 : 		{
; 1342 : 			lpTargetObj->Life = lpTargetObj->Life - AttackDamage;
; 1343 : 
; 1344 : 			if( lpTargetObj->Life < 0 )
; 1345 : 				lpTargetObj->Life = 0;
; 1346 : 		}
; 1347 : #else
; 1348 : 		lpTargetObj->Life -= AttackDamage;

  009e9	f3 0f 2a 45 c4	 cvtsi2ss xmm0, DWORD PTR _AttackDamage$[ebp]
  009ee	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  009f1	f3 0f 10 88 bc
	00 00 00	 movss	 xmm1, DWORD PTR [eax+188]
  009f9	f3 0f 5c c8	 subss	 xmm1, xmm0
  009fd	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00a00	f3 0f 11 89 bc
	00 00 00	 movss	 DWORD PTR [ecx+188], xmm1

; 1349 : 
; 1350 : 		if( lpTargetObj->Life < 0 ) lpTargetObj->Life = 0;

  00a08	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a0b	0f 57 c0	 xorps	 xmm0, xmm0
  00a0e	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00a15	76 0e		 jbe	 SHORT $LN56@Attack
  00a17	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a1a	0f 57 c0	 xorps	 xmm0, xmm0
  00a1d	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0
$LN56@Attack:

; 1351 : #endif
; 1352 : 	}	
; 1353 : 	
; 1354 : 	// 당하는게 몬스터일때..
; 1355 : 	if( lpTargetObj->Type == OBJTYPE_MONSTER )

  00a25	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a28	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00a2c	83 f9 02	 cmp	 ecx, 2
  00a2f	75 28		 jne	 SHORT $LN57@Attack

; 1356 : 	{
; 1357 : 		// 공격당했다..
; 1358 : 		gObjAddMsgSendDelay(lpTargetObj, 0, lpObj->m_Index, 100);

  00a31	6a 00		 push	 0
  00a33	6a 64		 push	 100			; 00000064H
  00a35	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a38	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a3a	51		 push	 ecx
  00a3b	6a 00		 push	 0
  00a3d	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00a40	52		 push	 edx
  00a41	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00a46	83 c4 14	 add	 esp, 20			; 00000014H

; 1359 : 		
; 1360 : #ifdef FOR_BLOODCASTLE
; 1361 : 		lpTargetObj->LastAttackerID = lpObj->m_Index;	// 마지막 공격한 사람의 인덱스를 저장

  00a49	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a4c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a4f	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00a52	66 89 90 b2 02
	00 00		 mov	 WORD PTR [eax+690], dx
$LN57@Attack:

; 1362 : #endif
; 1363 : 
; 1364 : #ifdef ADD_NEW_MONSTER_SYSTEM_02_20050725
; 1365 : 		// 여기서 Agro를 증가 시켜준다.
; 1366 : 		if( lpTargetObj->m_iCurrentAI )
; 1367 : 		{
; 1368 : 			lpTargetObj->m_Agro.IncAgro(lpObj->m_Index, AttackDamage/100);
; 1369 : 		}
; 1370 : #endif
; 1371 : 		
; 1372 : 	}
; 1373 : 	
; 1374 : 	BOOL			selfdefense=FALSE;

  00a59	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 0

; 1375 : 
; 1376 : 	lpCallObj = lpTargetObj;

  00a60	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a63	89 45 f4	 mov	 DWORD PTR _lpCallObj$[ebp], eax

; 1377 : 
; 1378 : 	if( lpTargetObj->Type == OBJTYPE_MONSTER )

  00a66	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a69	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00a6d	83 f9 02	 cmp	 ecx, 2
  00a70	75 22		 jne	 SHORT $LN59@Attack

; 1379 : 	{
; 1380 : 		if( lpTargetObj->m_RecallMon >= 0 ) 

  00a72	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a75	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00a7c	7c 16		 jl	 SHORT $LN59@Attack

; 1381 : 		{
; 1382 : 			lpCallObj = &gObj[lpTargetObj->m_RecallMon];

  00a7e	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a81	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  00a8b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a91	89 4d f4	 mov	 DWORD PTR _lpCallObj$[ebp], ecx
$LN59@Attack:

; 1383 : 		}
; 1384 : 	}
; 1385 : 
; 1386 : 	if( AttackDamage >= 1 )

  00a94	83 7d c4 01	 cmp	 DWORD PTR _AttackDamage$[ebp], 1
  00a98	0f 8c af 01 00
	00		 jl	 $LN72@Attack

; 1387 : 	{	
; 1388 : 		// 플레이어들끼리..
; 1389 : 		// 공격을 하여 성공하면 정당방위를 설정한다.
; 1390 : 		if( lpObj->Type	== OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER )

  00a9e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aa1	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00aa5	83 f9 01	 cmp	 ecx, 1
  00aa8	0f 85 ec 00 00
	00		 jne	 $LN61@Attack
  00aae	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00ab1	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00ab5	83 f9 01	 cmp	 ecx, 1
  00ab8	0f 85 dc 00 00
	00		 jne	 $LN61@Attack

; 1391 : 		{
; 1392 : #ifdef DUEL_SYSTEM_20031028
; 1393 : 			if (gObjDuelCheck(lpObj, lpTargetObj)) {	// 서로 결투 중이라면 정당방위 성립않됨

  00abe	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00ac1	50		 push	 eax
  00ac2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ac5	51		 push	 ecx
  00ac6	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  00acb	83 c4 08	 add	 esp, 8
  00ace	85 c0		 test	 eax, eax
  00ad0	74 0c		 je	 SHORT $LN63@Attack

; 1394 : 				selfdefense = FALSE;

  00ad2	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 0

; 1395 : 			}

  00ad9	e9 ba 00 00 00	 jmp	 $LN66@Attack
$LN63@Attack:

; 1396 : 	#ifdef CHAOSCASTLE_SYSTEM_20040408						// 카오스 캐슬 안에서는 정당방위가 성립되지 않는다.
; 1397 : 			else if (CHECK_CHAOSCASTLE(lpObj->MapNumber) || CHECK_CHAOSCASTLE(lpTargetObj->MapNumber)) {

  00ade	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ae1	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00ae8	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00aeb	7d 0c		 jge	 SHORT $LN104@Attack
  00aed	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv584[ebp], 0
  00af7	eb 31		 jmp	 SHORT $LN105@Attack
$LN104@Attack:
  00af9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00afc	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00b03	83 f8 17	 cmp	 eax, 23			; 00000017H
  00b06	7e 0c		 jle	 SHORT $LN102@Attack
  00b08	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv583[ebp], 0
  00b12	eb 0a		 jmp	 SHORT $LN103@Attack
$LN102@Attack:
  00b14	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv583[ebp], 1
$LN103@Attack:
  00b1e	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv583[ebp]
  00b24	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv584[ebp], ecx
$LN105@Attack:
  00b2a	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv584[ebp], 0
  00b31	75 55		 jne	 SHORT $LN67@Attack
  00b33	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b36	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00b3d	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00b40	7d 0c		 jge	 SHORT $LN108@Attack
  00b42	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv593[ebp], 0
  00b4c	eb 31		 jmp	 SHORT $LN109@Attack
$LN108@Attack:
  00b4e	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00b51	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00b58	83 f8 17	 cmp	 eax, 23			; 00000017H
  00b5b	7e 0c		 jle	 SHORT $LN106@Attack
  00b5d	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv592[ebp], 0
  00b67	eb 0a		 jmp	 SHORT $LN107@Attack
$LN106@Attack:
  00b69	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv592[ebp], 1
$LN107@Attack:
  00b73	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv592[ebp]
  00b79	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv593[ebp], ecx
$LN109@Attack:
  00b7f	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv593[ebp], 0
  00b86	74 09		 je	 SHORT $LN65@Attack
$LN67@Attack:

; 1398 : 				selfdefense = FALSE;

  00b88	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 0

; 1399 : 			}

  00b8f	eb 07		 jmp	 SHORT $LN66@Attack
$LN65@Attack:

; 1400 : 	#endif
; 1401 : 			else {
; 1402 : 				selfdefense = TRUE;

  00b91	c7 45 84 01 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 1
$LN66@Attack:

; 1403 : 			}
; 1404 : #else
; 1405 : 			selfdefense = TRUE;
; 1406 : #endif
; 1407 : 
; 1408 : 
; 1409 : #ifdef ADD_NEW_UNION_01_20041006
; 1410 : 			// 적대 길드 이면 정당 방위 설정이 되지 않는다.
; 1411 : 			// 아무때나 난입 가능. (결투 상태 일때도..)
; 1412 : 			if( gObjGetRelationShip( lpObj, lpTargetObj ) == G_RELATIONSHIP_RIVAL )
; 1413 : 			{
; 1414 : 				selfdefense = FALSE;
; 1415 : 			}
; 1416 : #endif
; 1417 : 			
; 1418 : #ifdef CASTLE_MAIN_SCHEDULER_20041111					// 공성전 시 공성전 참여길드는 정당방위 성립않됨
; 1419 : 			if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 1420 : 				if (lpObj->m_btCsJoinSide > CS_SIEGESIDE_NONE) {
; 1421 : 					selfdefense	= FALSE;
; 1422 : 				}
; 1423 : 			}
; 1424 : #endif
; 1425 : 
; 1426 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	// 사원 안에서는 정당방위가 성립되지 않는다.
; 1427 : 			else if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) || CHECK_ILLUSION_TEMPLE(lpTargetObj->MapNumber) )
; 1428 : 			{
; 1429 : 				selfdefense = FALSE;
; 1430 : 			}
; 1431 : #endif
; 1432 : 		}

  00b98	eb 2b		 jmp	 SHORT $LN69@Attack
$LN61@Attack:

; 1433 : 		else if( lpTargetObj->Type == OBJTYPE_MONSTER && lpObj->Type == OBJTYPE_CHARACTER)

  00b9a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b9d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00ba1	83 f9 02	 cmp	 ecx, 2
  00ba4	75 1f		 jne	 SHORT $LN69@Attack
  00ba6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ba9	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00bad	83 f9 01	 cmp	 ecx, 1
  00bb0	75 13		 jne	 SHORT $LN69@Attack

; 1434 : 		{
; 1435 : 			if( lpTargetObj->m_RecallMon >= 0 ) selfdefense = TRUE;

  00bb2	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00bb5	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00bbc	7c 07		 jl	 SHORT $LN69@Attack
  00bbe	c7 45 84 01 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 1
$LN69@Attack:

; 1436 : 		}
; 1437 : 		if( lpTargetObj->Type == OBJTYPE_CHARACTER )

  00bc5	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00bc8	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00bcc	83 f9 01	 cmp	 ecx, 1
  00bcf	75 10		 jne	 SHORT $LN70@Attack

; 1438 : 		{	// 공격이 성공하면 내구도를 감소 시킨다			
; 1439 : 			gObjArmorRandomDurDown(lpTargetObj, lpObj);

  00bd1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bd4	50		 push	 eax
  00bd5	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00bd8	51		 push	 ecx
  00bd9	e8 00 00 00 00	 call	 ?gObjArmorRandomDurDown@@YAXPAVOBJECTSTRUCT@@0@Z ; gObjArmorRandomDurDown
  00bde	83 c4 08	 add	 esp, 8
$LN70@Attack:

; 1440 : 		}
; 1441 : 
; 1442 : #ifdef NEW_FORSKYLAND2						
; 1443 : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1444 : 		if( gObjCheckUsedBuffEffect( lpTargetObj, BUFFTYPE_STONE ) == true )
; 1445 : 		{
; 1446 : 			gObjRemoveBuffEffect( lpTargetObj, BUFFTYPE_STONE );
; 1447 : 			GCMagicCancelSend(lpTargetObj, AT_SKILL_ELFHARDEN);
; 1448 : 		}
; 1449 : 	#else
; 1450 : 		if( lpTargetObj->m_SkillHarden != 0 )

  00be1	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00be4	83 b8 fc 19 00
	00 00		 cmp	 DWORD PTR [eax+6652], 0
  00beb	74 60		 je	 SHORT $LN72@Attack

; 1451 : 		{	// 공격을 당했을때 석화에 걸려 있으면, 공격을 풀어 준다
; 1452 : 
; 1453 : 			lpTargetObj->m_SkillHarden--;

  00bed	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00bf0	8b 88 fc 19 00
	00		 mov	 ecx, DWORD PTR [eax+6652]
  00bf6	83 e9 01	 sub	 ecx, 1
  00bf9	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00bfc	89 8a fc 19 00
	00		 mov	 DWORD PTR [edx+6652], ecx

; 1454 : 
; 1455 : 			if( lpTargetObj->m_SkillHarden <= 0 )

  00c02	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c05	83 b8 fc 19 00
	00 00		 cmp	 DWORD PTR [eax+6652], 0
  00c0c	7f 3f		 jg	 SHORT $LN72@Attack

; 1456 : 			{
; 1457 : 				lpTargetObj->m_SkillHardenTime = 0;

  00c0e	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c11	c7 80 00 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6656], 0

; 1458 : 				lpTargetObj->m_SkillHarden = 0;			 

  00c1b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c1e	c7 80 fc 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6652], 0

; 1459 : 				lpTargetObj->m_ViewSkillState &= ~STATE_HARDEN;

  00c28	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c2b	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00c32	83 e1 df	 and	 ecx, -33		; ffffffdfH
  00c35	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00c38	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 1460 : 				GCMagicCancelSend(lpTargetObj, AT_SKILL_ELFHARDEN);

  00c3f	6a 33		 push	 51			; 00000033H
  00c41	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c44	50		 push	 eax
  00c45	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00c4a	83 c4 08	 add	 esp, 8
$LN72@Attack:

; 1461 : 			}			
; 1462 : 		}
; 1463 : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1464 : #endif
; 1465 : 	}	
; 1466 : 
; 1467 : #ifdef CHINA_GM_EVENT
; 1468 : 		if( lpTargetObj->Authority&AUTHORITY_EVENT_GM )
; 1469 : 		{
; 1470 : 			selfdefense = FALSE;
; 1471 : 		}
; 1472 : #endif
; 1473 : 
; 1474 : #ifdef MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906
; 1475 : 		if( lpTargetObj->Authority&AUTHORITY_EVENT_GM )
; 1476 : 		{
; 1477 : 			selfdefense = FALSE;
; 1478 : 		}
; 1479 : #endif // MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906		
; 1480 : 
; 1481 : #ifdef MODIFY_0708_BUFFIX_20070820	// 같은 파티원끼리는 정당방위 설정 안함
; 1482 : #ifdef MODIFY_SELFDEFENSE_20070904
; 1483 : 	if( lpObj->PartyNumber >= 0 
; 1484 : 		&& lpCallObj->PartyNumber >= 0
; 1485 : 		&& lpObj->PartyNumber == lpCallObj->PartyNumber )

  00c4d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c50	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  00c57	7c 27		 jl	 SHORT $LN73@Attack
  00c59	8b 45 f4	 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  00c5c	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  00c63	7c 1b		 jl	 SHORT $LN73@Attack
  00c65	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c68	8b 4d f4	 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  00c6b	8b 90 88 02 00
	00		 mov	 edx, DWORD PTR [eax+648]
  00c71	3b 91 88 02 00
	00		 cmp	 edx, DWORD PTR [ecx+648]
  00c77	75 07		 jne	 SHORT $LN73@Attack

; 1486 : #else
; 1487 : 	if( lpObj->PartyNumber == lpCallObj->PartyNumber)
; 1488 : #endif	// MODIFY_SELFDEFENSE_20070904
; 1489 : 	{
; 1490 : 		selfdefense = FALSE;

  00c79	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _selfdefense$[ebp], 0
$LN73@Attack:

; 1491 : 	}
; 1492 : #endif
; 1493 : 	
; 1494 : 	if( selfdefense == TRUE  )

  00c80	83 7d 84 01	 cmp	 DWORD PTR _selfdefense$[ebp], 1
  00c84	75 26		 jne	 SHORT $LN75@Attack

; 1495 : 	{
; 1496 : 		if( gObjTargetGuildWarCheck(lpObj, lpCallObj) == FALSE )

  00c86	8b 45 f4	 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  00c89	50		 push	 eax
  00c8a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c8d	51		 push	 ecx
  00c8e	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00c93	83 c4 08	 add	 esp, 8
  00c96	85 c0		 test	 eax, eax
  00c98	75 12		 jne	 SHORT $LN75@Attack

; 1497 : 		{
; 1498 : #ifdef UPDATE_PK_SYSTEM_20070302	// 파티시 파티원 전체에 정당방위 설정
; 1499 : #ifdef MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022	// 정방에 걸린 유저만 SelfDefense에 넣는다
; 1500 : 			if( lpCallObj->PartyNumber >= 0 )
; 1501 : 			{
; 1502 : 				int number = 0;
; 1503 : 				int partynum = lpCallObj->PartyNumber;
; 1504 : 				
; 1505 : 				if( gParty.GetPKPartyPenalty(partynum) < PK_LEVEL_DEFAULT+2)		// PK 패널티 적용시 제외
; 1506 : 				{
; 1507 : 					gObjCheckSelfDefense(lpObj, lpCallObj->m_Index);
; 1508 : 				}
; 1509 : 			}
; 1510 : 			else
; 1511 : 			{
; 1512 : 				gObjCheckSelfDefense(lpObj, lpCallObj->m_Index);
; 1513 : 			}
; 1514 : #else	// MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022
; 1515 : 			if( lpCallObj->PartyNumber >= 0 )
; 1516 : 			{
; 1517 : 				int number = 0;
; 1518 : 				int partynum = lpCallObj->PartyNumber;
; 1519 : 				
; 1520 : 				if( gParty.GetPKPartyPenalty(partynum) < PK_LEVEL_DEFAULT+2)		// PK 패널티 적용시 제외
; 1521 : 				{
; 1522 : 					for(int n = 0; n < MAX_PARTYUSER; n++)
; 1523 : 					{
; 1524 : 						number = gParty.m_PartyS[partynum].Number[n];
; 1525 : 						if( number >= 0 )
; 1526 : 						{
; 1527 : 							gObjCheckSelfDefense(lpObj, number);
; 1528 : 						}
; 1529 : 					}
; 1530 : 				}
; 1531 : 			}
; 1532 : 			else
; 1533 : 			{
; 1534 : 				gObjCheckSelfDefense(lpObj, lpCallObj->m_Index);
; 1535 : 			}
; 1536 : #endif	// MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022
; 1537 : #else	// UPDATE_PK_SYSTEM_20070302
; 1538 : 			gObjCheckSelfDefense(lpObj, lpCallObj->m_Index);

  00c9a	8b 45 f4	 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  00c9d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c9f	51		 push	 ecx
  00ca0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ca3	52		 push	 edx
  00ca4	e8 00 00 00 00	 call	 ?gObjCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjCheckSelfDefense
  00ca9	83 c4 08	 add	 esp, 8
$LN75@Attack:

; 1539 : #endif	// UPDATE_PK_SYSTEM_20070302
; 1540 : 		}
; 1541 : 	}
; 1542 : 
; 1543 : 	if( AttackDamage >= 5 )

  00cac	83 7d c4 05	 cmp	 DWORD PTR _AttackDamage$[ebp], 5
  00cb0	7c 63		 jl	 SHORT $LN81@Attack

; 1544 : 	{		
; 1545 : 		if( lpTargetObj->Type == OBJTYPE_MONSTER ) // 대상자가 몬스터

  00cb2	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00cb5	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00cb9	83 f9 02	 cmp	 ecx, 2
  00cbc	75 2b		 jne	 SHORT $LN77@Attack

; 1546 : 		{
; 1547 : 			if( (rand()%26) == 0 )	

  00cbe	e8 00 00 00 00	 call	 _rand
  00cc3	99		 cdq
  00cc4	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00cc9	f7 f9		 idiv	 ecx
  00ccb	85 d2		 test	 edx, edx
  00ccd	75 18		 jne	 SHORT $LN79@Attack

; 1548 : 			{
; 1549 : 				gObjAddMsgSendDelay(lpTargetObj, 4, lpObj->m_Index, 100);

  00ccf	6a 00		 push	 0
  00cd1	6a 64		 push	 100			; 00000064H
  00cd3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cd6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cd8	51		 push	 ecx
  00cd9	6a 04		 push	 4
  00cdb	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00cde	52		 push	 edx
  00cdf	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00ce4	83 c4 14	 add	 esp, 20			; 00000014H
$LN79@Attack:

; 1550 : 			}
; 1551 : 		}

  00ce7	eb 2c		 jmp	 SHORT $LN81@Attack
$LN77@Attack:

; 1552 : 		else 
; 1553 : 		{
; 1554 : 			if( (rand()%4) == 0 )	

  00ce9	e8 00 00 00 00	 call	 _rand
  00cee	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00cf3	79 05		 jns	 SHORT $LN110@Attack
  00cf5	48		 dec	 eax
  00cf6	83 c8 fc	 or	 eax, -4			; fffffffcH
  00cf9	40		 inc	 eax
$LN110@Attack:
  00cfa	85 c0		 test	 eax, eax
  00cfc	75 17		 jne	 SHORT $LN81@Attack

; 1555 : 			{
; 1556 : 				if( gObjUniriaSprite(lpTargetObj) == FALSE )

  00cfe	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d01	50		 push	 eax
  00d02	e8 00 00 00 00	 call	 ?gObjUniriaSprite@@YAHPAVOBJECTSTRUCT@@@Z ; gObjUniriaSprite
  00d07	83 c4 04	 add	 esp, 4
  00d0a	85 c0		 test	 eax, eax
  00d0c	75 07		 jne	 SHORT $LN81@Attack

; 1557 : 				{
; 1558 : 					MSBFlag = 1;

  00d0e	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _MSBFlag$[ebp], 1
$LN81@Attack:

; 1559 : 				}
; 1560 : 			}
; 1561 : 		}
; 1562 : 	}
; 1563 : 
; 1564 : #ifdef NEW_FORSKYLAND2
; 1565 : 	if( ManaChange )

  00d15	83 7d e8 00	 cmp	 DWORD PTR _ManaChange$[ebp], 0
  00d19	74 2f		 je	 SHORT $LN82@Attack

; 1566 : 	{
; 1567 : 		GCManaSend(lpTargetObj->m_Index, (short)lpTargetObj->Mana, 0xFF, 0, lpTargetObj->BP);				

  00d1b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d1e	0f b7 88 e8 00
	00 00		 movzx	 ecx, WORD PTR [eax+232]
  00d25	51		 push	 ecx
  00d26	6a 00		 push	 0
  00d28	68 ff 00 00 00	 push	 255			; 000000ffH
  00d2d	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00d30	f3 0f 2c 82 d0
	00 00 00	 cvttss2si eax, DWORD PTR [edx+208]
  00d38	0f b7 c8	 movzx	 ecx, ax
  00d3b	51		 push	 ecx
  00d3c	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00d3f	8b 02		 mov	 eax, DWORD PTR [edx]
  00d41	50		 push	 eax
  00d42	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  00d47	83 c4 14	 add	 esp, 20			; 00000014H
$LN82@Attack:

; 1568 : 	}
; 1569 : #endif	
; 1570 : 
; 1571 : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00d4a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d4d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00d51	83 f9 01	 cmp	 ecx, 1
  00d54	75 22		 jne	 SHORT $LN84@Attack

; 1572 : 	{
; 1573 : 		if( lpObj->m_Change == 9 )

  00d56	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d59	83 b8 a8 02 00
	00 09		 cmp	 DWORD PTR [eax+680], 9
  00d60	75 16		 jne	 SHORT $LN84@Attack

; 1574 : 		{
; 1575 : 			GCMagicAttackNumberSend(lpObj, 3, lpTargetObj->m_Index, 1);	

  00d62	6a 01		 push	 1
  00d64	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d67	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d69	51		 push	 ecx
  00d6a	6a 03		 push	 3
  00d6c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d6f	52		 push	 edx
  00d70	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00d75	83 c4 10	 add	 esp, 16			; 00000010H
$LN84@Attack:

; 1576 : 		}
; 1577 : 	}
; 1578 : 	
; 1579 : 	lpObj->m_Rest = 0;

  00d78	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d7b	c6 80 bd 01 00
	00 00		 mov	 BYTE PTR [eax+445], 0

; 1580 : 	if( AttackDamage > 0 )

  00d82	83 7d c4 00	 cmp	 DWORD PTR _AttackDamage$[ebp], 0
  00d86	0f 8e a1 00 00
	00		 jle	 $LN85@Attack

; 1581 : 	{
; 1582 : #ifdef FOR_ANTI_HACK
; 1583 : 		if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_MONSTER )
; 1584 : 		{
; 1585 : 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 1586 : 			gObjSetPosition(lpTargetObj->m_Index, lpTargetObj->X, lpTargetObj->Y);
; 1587 : 		}		
; 1588 : #endif
; 1589 : 
; 1590 : 		int atd_reflect;
; 1591 : 		atd_reflect = (int)((float)AttackDamage*lpTargetObj->DamageReflect/100);

  00d8c	f3 0f 2a 45 c4	 cvtsi2ss xmm0, DWORD PTR _AttackDamage$[ebp]
  00d91	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d94	0f b6 88 15 01
	00 00		 movzx	 ecx, BYTE PTR [eax+277]
  00d9b	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00d9f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00da3	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00dab	f3 0f 2c d0	 cvttss2si edx, xmm0
  00daf	89 55 80	 mov	 DWORD PTR _atd_reflect$1[ebp], edx

; 1592 : 
; 1593 : 		if( atd_reflect )

  00db2	83 7d 80 00	 cmp	 DWORD PTR _atd_reflect$1[ebp], 0
  00db6	74 1a		 je	 SHORT $LN87@Attack

; 1594 : 		{
; 1595 : 			//LogAdd("데미지 반사 %x ", atd_reflect);
; 1596 : 			// 공격을 받는 대상(데미지반사능력이있는대상)의 메세지큐로 보낸다.
; 1597 : 			gObjAddMsgSendDelay(lpTargetObj, MSG_REFLECT, lpObj->m_Index, 10, atd_reflect);

  00db8	8b 45 80	 mov	 eax, DWORD PTR _atd_reflect$1[ebp]
  00dbb	50		 push	 eax
  00dbc	6a 0a		 push	 10			; 0000000aH
  00dbe	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00dc1	8b 11		 mov	 edx, DWORD PTR [ecx]
  00dc3	52		 push	 edx
  00dc4	6a 0a		 push	 10			; 0000000aH
  00dc6	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00dc9	50		 push	 eax
  00dca	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00dcf	83 c4 14	 add	 esp, 20			; 00000014H
$LN87@Attack:

; 1598 : 		}
; 1599 : 
; 1600 : 		if( rand()%100 < lpObj->SetOpReflectionDamage )

  00dd2	e8 00 00 00 00	 call	 _rand
  00dd7	99		 cdq
  00dd8	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00ddd	f7 f9		 idiv	 ecx
  00ddf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00de2	0f b6 88 4a 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3914]
  00de9	3b d1		 cmp	 edx, ecx
  00deb	7d 1a		 jge	 SHORT $LN88@Attack

; 1601 : 		{	// 세트 옵션 100% 데미지 반사 
; 1602 : 			gObjAddMsgSendDelay(lpTargetObj, MSG_REFLECT, lpObj->m_Index, 10, AttackDamage);

  00ded	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00df0	50		 push	 eax
  00df1	6a 0a		 push	 10			; 0000000aH
  00df3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00df6	8b 11		 mov	 edx, DWORD PTR [ecx]
  00df8	52		 push	 edx
  00df9	6a 0a		 push	 10			; 0000000aH
  00dfb	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00dfe	50		 push	 eax
  00dff	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00e04	83 c4 14	 add	 esp, 20			; 00000014H
$LN88@Attack:

; 1603 : 		}
; 1604 : 
; 1605 : #ifdef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826	// 더블 데미지 추가
; 1606 : 		if( rand()%100 < lpObj->SetOpDoubleDamage )
; 1607 : 		{
; 1608 : 			AttackDamage *= 2;
; 1609 : 			MsgDamage |= DT_DOUBLEDAMAGE;
; 1610 : 		}
; 1611 : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 1612 : 
; 1613 : #ifdef ADD_SHIELD_POINT_01_20060403
; 1614 : 		AttackDamage = AttackDamage - iTotalShieldDamage;
; 1615 : 
; 1616 : 	#ifdef ADD_SKILL_WITH_COMBO
; 1617 : 		gObjLifeCheck(lpTargetObj, lpObj, AttackDamage, 0, MSBFlag, MsgDamage, skill, iTotalShieldDamage);
; 1618 : 	#else
; 1619 : 		gObjLifeCheck(lpTargetObj, lpObj, AttackDamage, 0, MSBFlag, MsgDamage, iTotalShieldDamage);
; 1620 : 	#endif
; 1621 : 
; 1622 : #else
; 1623 : 
; 1624 : 	#ifdef ADD_SKILL_WITH_COMBO
; 1625 : 			gObjLifeCheck(lpTargetObj, lpObj, AttackDamage, 0, MSBFlag, MsgDamage, skill);

  00e07	0f b6 45 e4	 movzx	 eax, BYTE PTR _skill$[ebp]
  00e0b	50		 push	 eax
  00e0c	0f b6 4d ef	 movzx	 ecx, BYTE PTR _MsgDamage$[ebp]
  00e10	51		 push	 ecx
  00e11	8b 55 cc	 mov	 edx, DWORD PTR _MSBFlag$[ebp]
  00e14	52		 push	 edx
  00e15	6a 00		 push	 0
  00e17	8b 45 c4	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00e1a	50		 push	 eax
  00e1b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e1e	51		 push	 ecx
  00e1f	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00e22	52		 push	 edx
  00e23	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAVOBJECTSTRUCT@@0HHHHE@Z ; gObjLifeCheck
  00e28	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1626 : 	#else
; 1627 : 			gObjLifeCheck(lpTargetObj, lpObj, AttackDamage, 0, MSBFlag, MsgDamage);
; 1628 : 	#endif
; 1629 : 
; 1630 : #endif // ADD_SHIELD_POINT_01_20060403
; 1631 : 			
; 1632 : 	}	

  00e2b	eb 1d		 jmp	 SHORT $LN86@Attack
$LN85@Attack:

; 1633 : 	else 
; 1634 : 	{
; 1635 : 
; 1636 : #ifdef ADD_SHIELD_POINT_01_20060403
; 1637 : 		GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, MsgDamage, 0);
; 1638 : #else
; 1639 : 		GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, MsgDamage);

  00e2d	0f b6 45 ef	 movzx	 eax, BYTE PTR _MsgDamage$[ebp]
  00e31	50		 push	 eax
  00e32	6a 00		 push	 0
  00e34	6a 00		 push	 0
  00e36	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00e39	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e3b	52		 push	 edx
  00e3c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e3f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e41	51		 push	 ecx
  00e42	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  00e47	83 c4 14	 add	 esp, 20			; 00000014H
$LN86@Attack:

; 1640 : #endif
; 1641 : 
; 1642 : 	}
; 1643 : 
; 1644 : #ifdef NEW_FORSKYLAND3
; 1645 : 	if( lpObj->Life <= 0 && lpObj->Type == OBJTYPE_CHARACTER )

  00e4a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e4d	0f 57 c0	 xorps	 xmm0, xmm0
  00e50	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00e57	72 53		 jb	 SHORT $LN90@Attack
  00e59	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e5c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00e60	83 f9 01	 cmp	 ecx, 1
  00e63	75 47		 jne	 SHORT $LN90@Attack

; 1646 : 	{	// 데미지 증가 옵션에 따라서 캐릭터 체력이 깍이면 3초후에 다시 생명 체크를 해서 죽인다
; 1647 : 		if( lpObj->m_CheckLifeTime <= 0 )

  00e65	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e68	83 b8 d8 0e 00
	00 00		 cmp	 DWORD PTR [eax+3800], 0
  00e6f	7f 3b		 jg	 SHORT $LN90@Attack

; 1648 : 		{
; 1649 : #ifdef USER_DIE_MAKE_OPPOSIT_PK_20040329
; 1650 : 			lpObj->lpAttackObj = lpTargetObj;

  00e71	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e74	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00e77	89 88 30 02 00
	00		 mov	 DWORD PTR [eax+560], ecx

; 1651 : 
; 1652 : 			if (lpTargetObj->Type == OBJTYPE_CHARACTER) {

  00e7d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00e80	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00e84	83 f9 01	 cmp	 ecx, 1
  00e87	75 0c		 jne	 SHORT $LN91@Attack

; 1653 : 				lpObj->m_bAttackerKilled = true;		// 내가 상대방을 공격하다 죽었으므로 상대방이 직접 나를 죽인자는 아니다.

  00e89	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e8c	c6 80 3c 02 00
	00 01		 mov	 BYTE PTR [eax+572], 1

; 1654 : 			}

  00e93	eb 0a		 jmp	 SHORT $LN92@Attack
$LN91@Attack:

; 1655 : 			else {
; 1656 : 				lpObj->m_bAttackerKilled = false;

  00e95	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e98	c6 80 3c 02 00
	00 00		 mov	 BYTE PTR [eax+572], 0
$LN92@Attack:

; 1657 : 			}
; 1658 : #else
; 1659 : 			lpObj->lpAttackObj = lpTargetObj;
; 1660 : #endif			
; 1661 : 			lpObj->m_CheckLifeTime = 3;

  00e9f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ea2	c7 80 d8 0e 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+3800], 3
$LN90@Attack:

; 1662 : 		}
; 1663 : 	}
; 1664 : #endif
; 1665 : 	
; 1666 : 	return TRUE;

  00eac	b8 01 00 00 00	 mov	 eax, 1
$LN1@Attack:

; 1667 : }

  00eb1	5f		 pop	 edi
  00eb2	5e		 pop	 esi
  00eb3	5b		 pop	 ebx
  00eb4	8b e5		 mov	 esp, ebp
  00eb6	5d		 pop	 ebp
  00eb7	c2 14 00	 ret	 20			; 00000014H
?Attack@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z ENDP ; CDarkSpirit::Attack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z
_TEXT	SEGMENT
tv79 = -1240						; size = 4
tv80 = -1236						; size = 4
_strMode$1 = -1040					; size = 1020
_pMsg$2 = -20						; size = 7
_lpObj$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_iTargetindex$ = 12					; size = 4
?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z PROC	; CDarkSpirit::SetMode, COMDAT
; _this$ = ecx

; 591  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 04 00
	00		 sub	 esp, 1240		; 000004d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 592  : 	if( m_iMasterIndex == -1 )

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00020	75 05		 jne	 SHORT $LN2@SetMode

; 593  : 		return;	// 마스터가 없으면 처리 없음

  00022	e9 09 02 00 00	 jmp	 $LN1@SetMode
$LN2@SetMode:

; 594  : 
; 595  : 	LPOBJECTSTRUCT lpObj = &gObj[m_iMasterIndex];

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  00031	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00037	89 4d f4	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 596  : 	if(lpObj->Class != CLASS_DARKLORD )

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00044	83 f9 04	 cmp	 ecx, 4
  00047	74 05		 je	 SHORT $LN3@SetMode

; 597  : 		return;

  00049	e9 e2 01 00 00	 jmp	 $LN1@SetMode
$LN3@SetMode:

; 598  : 
; 599  : 	if( mode == CDarkSpirit::PetItem_Mode_Attack_Target || m_ActionMode != mode  )

  0004e	83 7d 08 03	 cmp	 DWORD PTR _mode$[ebp], 3
  00052	74 0f		 je	 SHORT $LN5@SetMode
  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0005a	3b 4d 08	 cmp	 ecx, DWORD PTR _mode$[ebp]
  0005d	0f 84 cd 01 00
	00		 je	 $LN1@SetMode
$LN5@SetMode:

; 600  : 	{	// 이미 같은 모드다.
; 601  : 		if( mode == CDarkSpirit::PetItem_Mode_Attack_Target )

  00063	83 7d 08 03	 cmp	 DWORD PTR _mode$[ebp], 3
  00067	75 56		 jne	 SHORT $LN6@SetMode

; 602  : 		{
; 603  : 			if(CHECK_LIMIT(iTargetindex, MAX_OBJECT)) 

  00069	83 7d 0c 00	 cmp	 DWORD PTR _iTargetindex$[ebp], 0
  0006d	7d 0c		 jge	 SHORT $LN12@SetMode
  0006f	c7 85 2c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv80[ebp], 0
  00079	eb 2b		 jmp	 SHORT $LN13@SetMode
$LN12@SetMode:
  0007b	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _iTargetindex$[ebp], 7399 ; 00001ce7H
  00082	7e 0c		 jle	 SHORT $LN10@SetMode
  00084	c7 85 28 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR tv79[ebp], 0
  0008e	eb 0a		 jmp	 SHORT $LN11@SetMode
$LN10@SetMode:
  00090	c7 85 28 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR tv79[ebp], 1
$LN11@SetMode:
  0009a	8b 85 28 fb ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  000a0	89 85 2c fb ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
$LN13@SetMode:
  000a6	83 bd 2c fb ff
	ff 00		 cmp	 DWORD PTR tv80[ebp], 0
  000ad	74 0b		 je	 SHORT $LN7@SetMode

; 604  : 			{
; 605  : 				m_iTargetIndex = iTargetindex;

  000af	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _iTargetindex$[ebp]
  000b5	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 606  : 			}

  000b8	eb 05		 jmp	 SHORT $LN6@SetMode
$LN7@SetMode:

; 607  : 			else
; 608  : 			{
; 609  : 				return;

  000ba	e9 71 01 00 00	 jmp	 $LN1@SetMode
$LN6@SetMode:

; 610  : 			}
; 611  : 		}
; 612  : 
; 613  : 		m_ActionMode = mode;

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR _mode$[ebp]
  000c5	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 614  : 
; 615  : 		PMSG_SEND_PET_ITEM_COMMAND pMsg;
; 616  : 		pMsg.h.set((LPBYTE)&pMsg, 0xa7, sizeof(pMsg));

  000c8	6a 07		 push	 7
  000ca	68 a7 00 00 00	 push	 167			; 000000a7H
  000cf	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$2[ebp]
  000d2	50		 push	 eax
  000d3	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$2[ebp]
  000d6	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 617  : 
; 618  : 		pMsg.PetType = 0;

  000db	c6 45 ef 00	 mov	 BYTE PTR _pMsg$2[ebp+3], 0

; 619  : 		pMsg.Command = mode;

  000df	8a 45 08	 mov	 al, BYTE PTR _mode$[ebp]
  000e2	88 45 f0	 mov	 BYTE PTR _pMsg$2[ebp+4], al

; 620  : 
; 621  : 		pMsg.NumberH = HIBYTE(m_iTargetIndex);

  000e5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000eb	c1 e9 08	 shr	 ecx, 8
  000ee	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000f4	88 4d f1	 mov	 BYTE PTR _pMsg$2[ebp+5], cl

; 622  : 		pMsg.NumberL = LOBYTE(m_iTargetIndex);

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000fd	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00103	88 4d f2	 mov	 BYTE PTR _pMsg$2[ebp+6], cl

; 623  : 
; 624  : 		DataSend(m_iMasterIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00106	6a 07		 push	 7
  00108	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$2[ebp]
  0010b	50		 push	 eax
  0010c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00112	52		 push	 edx
  00113	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH

; 625  : 
; 626  : 		char strMode[][255] = 

  0011b	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_06NDNCHIBI@?$FL?$MA?O?$LJ?$NN?$FN@
  00120	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _strMode$1[ebp], eax
  00126	66 8b 0d 04 00
	00 00		 mov	 cx, WORD PTR ??_C@_06NDNCHIBI@?$FL?$MA?O?$LJ?$NN?$FN@+4
  0012d	66 89 8d f4 fb
	ff ff		 mov	 WORD PTR _strMode$1[ebp+4], cx
  00134	8a 15 06 00 00
	00		 mov	 dl, BYTE PTR ??_C@_06NDNCHIBI@?$FL?$MA?O?$LJ?$NN?$FN@+6
  0013a	88 95 f6 fb ff
	ff		 mov	 BYTE PTR _strMode$1[ebp+6], dl
  00140	68 f8 00 00 00	 push	 248			; 000000f8H
  00145	6a 00		 push	 0
  00147	8d 85 f7 fb ff
	ff		 lea	 eax, DWORD PTR _strMode$1[ebp+7]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _memset
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH
  00156	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@NMEJHKFH@?$FL?$LH?$KD?$LE?$PN?$LA?x?$LA?$NN?$FN@
  0015b	89 85 ef fc ff
	ff		 mov	 DWORD PTR _strMode$1[ebp+255], eax
  00161	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0L@NMEJHKFH@?$FL?$LH?$KD?$LE?$PN?$LA?x?$LA?$NN?$FN@+4
  00167	89 8d f3 fc ff
	ff		 mov	 DWORD PTR _strMode$1[ebp+259], ecx
  0016d	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR ??_C@_0L@NMEJHKFH@?$FL?$LH?$KD?$LE?$PN?$LA?x?$LA?$NN?$FN@+8
  00174	66 89 95 f7 fc
	ff ff		 mov	 WORD PTR _strMode$1[ebp+263], dx
  0017b	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0L@NMEJHKFH@?$FL?$LH?$KD?$LE?$PN?$LA?x?$LA?$NN?$FN@+10
  00180	88 85 f9 fc ff
	ff		 mov	 BYTE PTR _strMode$1[ebp+265], al
  00186	68 f4 00 00 00	 push	 244			; 000000f4H
  0018b	6a 00		 push	 0
  0018d	8d 85 fa fc ff
	ff		 lea	 eax, DWORD PTR _strMode$1[ebp+266]
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 _memset
  00199	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019c	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BB@IPPKFAED@?$FL?A?V?$MA?N?$LA?z?$LA?$LA?$MA?L?$LA?x?$LA?$NN?$FN@
  001a1	89 85 ee fd ff
	ff		 mov	 DWORD PTR _strMode$1[ebp+510], eax
  001a7	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0BB@IPPKFAED@?$FL?A?V?$MA?N?$LA?z?$LA?$LA?$MA?L?$LA?x?$LA?$NN?$FN@+4
  001ad	89 8d f2 fd ff
	ff		 mov	 DWORD PTR _strMode$1[ebp+514], ecx
  001b3	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0BB@IPPKFAED@?$FL?A?V?$MA?N?$LA?z?$LA?$LA?$MA?L?$LA?x?$LA?$NN?$FN@+8
  001b9	89 95 f6 fd ff
	ff		 mov	 DWORD PTR _strMode$1[ebp+518], edx
  001bf	a1 0c 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BB@IPPKFAED@?$FL?A?V?$MA?N?$LA?z?$LA?$LA?$MA?L?$LA?x?$LA?$NN?$FN@+12
  001c4	89 85 fa fd ff
	ff		 mov	 DWORD PTR _strMode$1[ebp+522], eax
  001ca	8a 0d 10 00 00
	00		 mov	 cl, BYTE PTR ??_C@_0BB@IPPKFAED@?$FL?A?V?$MA?N?$LA?z?$LA?$LA?$MA?L?$LA?x?$LA?$NN?$FN@+16
  001d0	88 8d fe fd ff
	ff		 mov	 BYTE PTR _strMode$1[ebp+526], cl
  001d6	68 ee 00 00 00	 push	 238			; 000000eeH
  001db	6a 00		 push	 0
  001dd	8d 85 ff fd ff
	ff		 lea	 eax, DWORD PTR _strMode$1[ebp+527]
  001e3	50		 push	 eax
  001e4	e8 00 00 00 00	 call	 _memset
  001e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0N@KFGEJJPF@?$FL?$LL?g?$LP?k?$MA?Z?A?v?A?$KE?$FN@
  001f1	89 85 ed fe ff
	ff		 mov	 DWORD PTR _strMode$1[ebp+765], eax
  001f7	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_0N@KFGEJJPF@?$FL?$LL?g?$LP?k?$MA?Z?A?v?A?$KE?$FN@+4
  001fd	89 8d f1 fe ff
	ff		 mov	 DWORD PTR _strMode$1[ebp+769], ecx
  00203	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ??_C@_0N@KFGEJJPF@?$FL?$LL?g?$LP?k?$MA?Z?A?v?A?$KE?$FN@+8
  00209	89 95 f5 fe ff
	ff		 mov	 DWORD PTR _strMode$1[ebp+773], edx
  0020f	a0 0c 00 00 00	 mov	 al, BYTE PTR ??_C@_0N@KFGEJJPF@?$FL?$LL?g?$LP?k?$MA?Z?A?v?A?$KE?$FN@+12
  00214	88 85 f9 fe ff
	ff		 mov	 BYTE PTR _strMode$1[ebp+777], al
  0021a	68 f2 00 00 00	 push	 242			; 000000f2H
  0021f	6a 00		 push	 0
  00221	8d 85 fa fe ff
	ff		 lea	 eax, DWORD PTR _strMode$1[ebp+778]
  00227	50		 push	 eax
  00228	e8 00 00 00 00	 call	 _memset
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SetMode:

; 627  : 		{
; 628  : 			"[일반]", 
; 629  : 			"[랜덤공격]",
; 630  : 			"[주인과같이공격]",
; 631  : 			"[사용자지정]"
; 632  : 		};
; 633  : #if TESTSERVER == 1
; 634  : 		DebugOutput(lpObj->m_Index, "[다크스피릿] 모드 전환 %s", strMode[m_ActionMode]);
; 635  : #endif
; 636  : 	}
; 637  : }

  00230	5f		 pop	 edi
  00231	5e		 pop	 esi
  00232	5b		 pop	 ebx
  00233	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00236	33 cd		 xor	 ecx, ebp
  00238	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023d	8b e5		 mov	 esp, ebp
  0023f	5d		 pop	 ebp
  00240	c2 08 00	 ret	 8
?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ENDP	; CDarkSpirit::SetMode
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z
_TEXT	SEGMENT
_leadership$ = -20					; size = 4
_petitemlevel$ = -16					; size = 4
_bChange$ = -12						; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_pPetItem$ = 12						; size = 4
?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z PROC		; CDarkSpirit::Set, COMDAT
; _this$ = ecx

; 641  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 642  : 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  0000c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00013	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00019	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 643  : 	if(lpObj->Class != CLASS_DARKLORD )

  0001c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00026	83 f9 04	 cmp	 ecx, 4
  00029	74 05		 je	 SHORT $LN2@Set

; 644  : 		return;

  0002b	e9 0f 01 00 00	 jmp	 $LN1@Set
$LN2@Set:

; 645  : 
; 646  : 	BOOL	bChange = FALSE;

  00030	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bChange$[ebp], 0

; 647  : 
; 648  : 	if( m_iMasterIndex == -1 )	// 계속 장착하고 있던 아이템이 아니면

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  0003e	75 07		 jne	 SHORT $LN3@Set

; 649  : 	{
; 650  : 		//CDarkSpirit::m_ActionMode = PetItem_Mode_Normal;	
; 651  : 		bChange = TRUE;

  00040	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bChange$[ebp], 1
$LN3@Set:

; 652  : 	}
; 653  : 
; 654  : 	Init();

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?Init@CDarkSpirit@@QAEXXZ ; CDarkSpirit::Init

; 655  : 
; 656  :  	if( pPetItem->m_Type != MAKE_ITEMNUM(13,5) )	

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _pPetItem$[ebp]
  00052	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00056	6a 05		 push	 5
  00058	6a 0d		 push	 13			; 0000000dH
  0005a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0005f	83 c4 08	 add	 esp, 8
  00062	3b f0		 cmp	 esi, eax
  00064	74 05		 je	 SHORT $LN4@Set

; 657  : 		return;

  00066	e9 d4 00 00 00	 jmp	 $LN1@Set
$LN4@Set:

; 658  : 
; 659  : 	if( pPetItem->m_Durability <= 0.f )

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _pPetItem$[ebp]
  0006e	0f 57 c0	 xorps	 xmm0, xmm0
  00071	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00075	72 05		 jb	 SHORT $LN5@Set

; 660  : 		return;	// 다크스피릿 죽었다	

  00077	e9 c3 00 00 00	 jmp	 $LN1@Set
$LN5@Set:

; 661  : 
; 662  : 	int petitemlevel = pPetItem->m_PetItem_Level;

  0007c	8b 45 0c	 mov	 eax, DWORD PTR _pPetItem$[ebp]
  0007f	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00085	89 4d f0	 mov	 DWORD PTR _petitemlevel$[ebp], ecx

; 663  : 
; 664  : 	int leadership = lpObj->Leadership+lpObj->AddLeadership;

  00088	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008b	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR [eax+216]
  00092	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00095	0f b7 82 da 00
	00 00		 movzx	 eax, WORD PTR [edx+218]
  0009c	03 c8		 add	 ecx, eax
  0009e	89 4d ec	 mov	 DWORD PTR _leadership$[ebp], ecx

; 665  : 
; 666  : 	m_AttackDamageMin = 180+petitemlevel*15+leadership/8;

  000a1	6b 4d f0 0f	 imul	 ecx, DWORD PTR _petitemlevel$[ebp], 15
  000a5	8b 45 ec	 mov	 eax, DWORD PTR _leadership$[ebp]
  000a8	99		 cdq
  000a9	83 e2 07	 and	 edx, 7
  000ac	03 c2		 add	 eax, edx
  000ae	c1 f8 03	 sar	 eax, 3
  000b1	8d 94 01 b4 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+180]
  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 667  : 	m_AttackDamageMax = 200+petitemlevel*15+leadership/4;

  000be	6b 4d f0 0f	 imul	 ecx, DWORD PTR _petitemlevel$[ebp], 15
  000c2	8b 45 ec	 mov	 eax, DWORD PTR _leadership$[ebp]
  000c5	99		 cdq
  000c6	83 e2 03	 and	 edx, 3
  000c9	03 c2		 add	 eax, edx
  000cb	c1 f8 02	 sar	 eax, 2
  000ce	8d 94 01 c8 00
	00 00		 lea	 edx, DWORD PTR [ecx+eax+200]
  000d5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 668  : 
; 669  : 	m_AttackSpeed = 20+petitemlevel*4/5+leadership/50;

  000db	8b 45 f0	 mov	 eax, DWORD PTR _petitemlevel$[ebp]
  000de	c1 e0 02	 shl	 eax, 2
  000e1	99		 cdq
  000e2	b9 05 00 00 00	 mov	 ecx, 5
  000e7	f7 f9		 idiv	 ecx
  000e9	8b c8		 mov	 ecx, eax
  000eb	8b 45 ec	 mov	 eax, DWORD PTR _leadership$[ebp]
  000ee	99		 cdq
  000ef	be 32 00 00 00	 mov	 esi, 50			; 00000032H
  000f4	f7 fe		 idiv	 esi
  000f6	8d 54 01 14	 lea	 edx, DWORD PTR [ecx+eax+20]
  000fa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 670  : 	
; 671  : 	m_SuccessAttackRate = 1000+petitemlevel+(petitemlevel/15);

  00100	8b 45 f0	 mov	 eax, DWORD PTR _petitemlevel$[ebp]
  00103	99		 cdq
  00104	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00109	f7 f9		 idiv	 ecx
  0010b	8b 55 f0	 mov	 edx, DWORD PTR _petitemlevel$[ebp]
  0010e	8d 84 02 e8 03
	00 00		 lea	 eax, DWORD PTR [edx+eax+1000]
  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 672  : 
; 673  : 	m_iMasterIndex = aIndex;

  0011b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00121	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 674  : 	m_pPetItem = pPetItem;

  00124	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00127	8b 4d 0c	 mov	 ecx, DWORD PTR _pPetItem$[ebp]
  0012a	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 675  : 
; 676  : 	if( bChange )

  0012d	83 7d f4 00	 cmp	 DWORD PTR _bChange$[ebp], 0
  00131	74 0c		 je	 SHORT $LN6@Set

; 677  : 		SetMode(CDarkSpirit::PetItem_Mode_Normal);

  00133	6a ff		 push	 -1
  00135	6a 00		 push	 0
  00137	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode
$LN6@Set:
$LN1@Set:

; 678  : 
; 679  : #if TESTSERVER == 1
; 680  : 	DebugOutput(aIndex, "[%s]장착 Lv:%d Mi:%d Ma:%d Sp:%d R:%d M:%d", 
; 681  : 						pPetItem->GetName(),				
; 682  : 						pPetItem->m_PetItem_Level, 						
; 683  : 						m_AttackDamageMin,
; 684  : 						m_AttackDamageMax,
; 685  : 						m_AttackSpeed,
; 686  : 						m_SuccessAttackRate,
; 687  : 						m_iMasterIndex);
; 688  : #endif
; 689  : }

  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 08 00	 ret	 8
?Set@CDarkSpirit@@QAEXHPAVCItem@@@Z ENDP		; CDarkSpirit::Set
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?ReSetTarget@CDarkSpirit@@QAEXH@Z
_TEXT	SEGMENT
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aTargetIndex$ = 8					; size = 4
?ReSetTarget@CDarkSpirit@@QAEXH@Z PROC			; CDarkSpirit::ReSetTarget, COMDAT
; _this$ = ecx

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 575  : 	if( m_iMasterIndex == -1 )

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00013	75 02		 jne	 SHORT $LN2@ReSetTarge

; 576  : 		return;	// 마스터가 없으면 처리 없음

  00015	eb 4e		 jmp	 SHORT $LN1@ReSetTarge
$LN2@ReSetTarge:

; 577  : 
; 578  : 	LPOBJECTSTRUCT lpObj = &gObj[m_iMasterIndex];

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  00021	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00027	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 579  : 	if(lpObj->Class != CLASS_DARKLORD )

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00034	83 f9 04	 cmp	 ecx, 4
  00037	74 02		 je	 SHORT $LN3@ReSetTarge

; 580  : 		return;

  00039	eb 2a		 jmp	 SHORT $LN1@ReSetTarge
$LN3@ReSetTarge:

; 581  : 
; 582  : 	if( aTargetIndex == m_iTargetIndex )

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _aTargetIndex$[ebp]
  00041	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00044	75 1f		 jne	 SHORT $LN1@ReSetTarge

; 583  : 	{
; 584  : 		m_iTargetIndex = -1;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [eax+24], -1

; 585  : 		if( m_ActionMode == CDarkSpirit::PetItem_Mode_Attack_Target )

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 78 20 03	 cmp	 DWORD PTR [eax+32], 3
  00057	75 0c		 jne	 SHORT $LN1@ReSetTarge

; 586  : 			SetMode(CDarkSpirit::PetItem_Mode_Normal);

  00059	6a ff		 push	 -1
  0005b	6a 00		 push	 0
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode
$LN1@ReSetTarge:

; 587  : 	}
; 588  : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?ReSetTarget@CDarkSpirit@@QAEXH@Z ENDP			; CDarkSpirit::ReSetTarget
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?SetTarget@CDarkSpirit@@QAEXH@Z
_TEXT	SEGMENT
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_aTargetIndex$ = 8					; size = 4
?SetTarget@CDarkSpirit@@QAEXH@Z PROC			; CDarkSpirit::SetTarget, COMDAT
; _this$ = ecx

; 562  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 563  : 	if( m_iMasterIndex == -1 )

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00013	75 02		 jne	 SHORT $LN2@SetTarget

; 564  : 		return;	// 마스터가 없으면 처리 없음

  00015	eb 2d		 jmp	 SHORT $LN1@SetTarget
$LN2@SetTarget:

; 565  : 
; 566  : 	LPOBJECTSTRUCT lpObj = &gObj[m_iMasterIndex];

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  00021	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00027	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 567  : 	if(lpObj->Class != CLASS_DARKLORD )

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00034	83 f9 04	 cmp	 ecx, 4
  00037	74 02		 je	 SHORT $LN3@SetTarget

; 568  : 		return;

  00039	eb 09		 jmp	 SHORT $LN1@SetTarget
$LN3@SetTarget:

; 569  : 
; 570  : 	m_iTargetIndex = aTargetIndex;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _aTargetIndex$[ebp]
  00041	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN1@SetTarget:

; 571  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?SetTarget@CDarkSpirit@@QAEXH@Z ENDP			; CDarkSpirit::SetTarget
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?ModeAttakTarget@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
_iActionType$1 = -24					; size = 4
_criticaldamage$2 = -20					; size = 4
_dis$ = -16						; size = 4
_count$ = -12						; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
?ModeAttakTarget@CDarkSpirit@@QAEXXZ PROC		; CDarkSpirit::ModeAttakTarget, COMDAT
; _this$ = ecx

; 327  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 328  : 	LPOBJECTSTRUCT lpObj = &gObj[m_iMasterIndex];	

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  00016	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001c	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 329  : 	int count = 0;		

  0001f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 330  : 	int dis;
; 331  : 
; 332  : 	if( m_iTargetIndex == -1 )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  0002d	75 05		 jne	 SHORT $LN2@ModeAttakT

; 333  : 		return;

  0002f	e9 cb 00 00 00	 jmp	 $LN1@ModeAttakT
$LN2@ModeAttakT:

; 334  : 	
; 335  : 	if( lpObj->MapNumber == gObj[m_iTargetIndex].MapNumber) 

  00034	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00037	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	69 42 18 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+24], 7072
  00048	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	0f b6 84 02 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+eax+265]
  00056	3b c8		 cmp	 ecx, eax
  00058	0f 85 a1 00 00
	00		 jne	 $LN5@ModeAttakT

; 336  : 	{
; 337  : 		if( gObj[m_iTargetIndex].Life > 0 )

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	69 48 18 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+24], 7072
  00068	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006e	f3 0f 10 84 0a
	bc 00 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+188]
  00077	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0007e	76 70		 jbe	 SHORT $LN4@ModeAttakT

; 338  : 		{
; 339  : 			dis = gObjCalDistance(lpObj, &gObj[m_iTargetIndex]);

  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	69 48 18 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+24], 7072
  0008a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00090	51		 push	 ecx
  00091	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0009a	83 c4 08	 add	 esp, 8
  0009d	89 45 f0	 mov	 DWORD PTR _dis$[ebp], eax

; 340  : 			if( dis < MAX_DARKSPIRIT_ATTACK_RANGE+2 )

  000a0	83 7d f0 07	 cmp	 DWORD PTR _dis$[ebp], 7
  000a4	7d 48		 jge	 SHORT $LN8@ModeAttakT

; 341  : 			{	
; 342  : 				
; 343  : #ifdef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 344  : 				// 타겟 지정 공격은 항상 직접 공격으로 처리한다.
; 345  : 				int	criticaldamage = 0;
; 346  : 				int iActionType = 1;
; 347  : 				
; 348  : 				if( (rand()%100) < lpObj->m_CriticalDamage )	// 크리티컬(행운) 데미지
; 349  : 					criticaldamage = 1;
; 350  : 				
; 351  : 				if( (rand()%100) < lpObj->m_ExcelentDamage )	// 엑설런트 데미지
; 352  : 					criticaldamage = 2;
; 353  : #else
; 354  : 	#ifdef MODIFY_DARKSPIRIT_TAGET_ATTACK_01_20040906
; 355  : 				// 타겟 지정 공격은 항상 직접 공격으로 처리한다.
; 356  : 				int	criticaldamage = 1;

  000a6	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _criticaldamage$2[ebp], 1

; 357  : 				int iActionType = 1;

  000ad	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _iActionType$1[ebp], 1

; 358  : 				
; 359  : 	#else
; 360  : 				int criticaldamage = 0;
; 361  : 				if( (rand()%10) < 3 )
; 362  : 				{	// 가끔식 크리티컬 데이지 들어간다
; 363  : 					criticaldamage = 1;
; 364  : 				}
; 365  : 	#endif
; 366  : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 367  : 
; 368  : 				if( criticaldamage )

  000b4	83 7d ec 00	 cmp	 DWORD PTR _criticaldamage$2[ebp], 0
  000b8	74 1f		 je	 SHORT $LN7@ModeAttakT

; 369  : 				{			
; 370  : 
; 371  : #ifdef MODIFY_DARKSPIRIT_TAGET_ATTACK_01_20040906
; 372  : 					SendAttackMsg(lpObj->m_Index, m_iTargetIndex, criticaldamage, iActionType);

  000ba	8b 45 e8	 mov	 eax, DWORD PTR _iActionType$1[ebp]
  000bd	50		 push	 eax
  000be	8b 4d ec	 mov	 ecx, DWORD PTR _criticaldamage$2[ebp]
  000c1	51		 push	 ecx
  000c2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000c8	50		 push	 eax
  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000cc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ce	52		 push	 edx
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	e8 00 00 00 00	 call	 ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ; CDarkSpirit::SendAttackMsg

; 373  : #else
; 374  : 					SendAttackMsg(lpObj->m_Index, m_iTargetIndex, criticaldamage);
; 375  : #endif
; 376  : 
; 377  : #if TESTSERVER == 1
; 378  : 					DebugOutput(lpObj->m_Index, "[다크스피릿] %s 타켓(지정)공격", gObj[m_iTargetIndex].Name);
; 379  : #endif	
; 380  : 				}

  000d7	eb 15		 jmp	 SHORT $LN8@ModeAttakT
$LN7@ModeAttakT:

; 381  : 				else
; 382  : 				{
; 383  : 					RangeAttack(lpObj->m_Index, m_iTargetIndex);

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000df	51		 push	 ecx
  000e0	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e3	8b 02		 mov	 eax, DWORD PTR [edx]
  000e5	50		 push	 eax
  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	e8 00 00 00 00	 call	 ?RangeAttack@CDarkSpirit@@QAEXHH@Z ; CDarkSpirit::RangeAttack
$LN8@ModeAttakT:

; 384  : #if TESTSERVER == 1
; 385  : 					DebugOutput(lpObj->m_Index, "[다크스피릿] %s 타켓(지정)공격", gObj[m_iTargetIndex].Name);
; 386  : #endif				
; 387  : 				}
; 388  : 				//CDarkSpirit::Attack(lpObj, &gObj[m_iTargetIndex], NULL, 1);			
; 389  : #if TESTSERVER == 1
; 390  : 				DebugOutput(lpObj->m_Index, "[다크스피릿] %s 타켓(지정)공격", gObj[m_iTargetIndex].Name);
; 391  : #endif
; 392  : 			}
; 393  : 		}

  000ee	eb 0f		 jmp	 SHORT $LN5@ModeAttakT
$LN4@ModeAttakT:

; 394  : 		else
; 395  : 		{	// 대상이 죽어 있으면 타켓을 없앤다
; 396  : 			ReSetTarget(m_iTargetIndex);

  000f0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000f6	51		 push	 ecx
  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget
$LN5@ModeAttakT:
$LN1@ModeAttakT:

; 397  : 		}
; 398  : 	}
; 399  : }

  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
?ModeAttakTarget@CDarkSpirit@@QAEXXZ ENDP		; CDarkSpirit::ModeAttakTarget
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
_criticaldamage$1 = -20					; size = 4
_dis$ = -16						; size = 4
_count$ = -12						; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ PROC		; CDarkSpirit::ModeAttackWithMaster, COMDAT
; _this$ = ecx

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 	LPOBJECTSTRUCT lpObj = &gObj[m_iMasterIndex];	

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  00016	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001c	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 276  : 	int count = 0;		

  0001f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 277  : 	int dis;
; 278  : 
; 279  : 	if( m_iTargetIndex == -1 )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  0002d	75 05		 jne	 SHORT $LN2@ModeAttack

; 280  : 		return;

  0002f	e9 df 00 00 00	 jmp	 $LN1@ModeAttack
$LN2@ModeAttack:

; 281  : 	
; 282  : 	if( lpObj->MapNumber == gObj[m_iTargetIndex].MapNumber) 

  00034	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00037	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	69 42 18 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+24], 7072
  00048	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	0f b6 84 02 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+eax+265]
  00056	3b c8		 cmp	 ecx, eax
  00058	0f 85 b5 00 00
	00		 jne	 $LN5@ModeAttack

; 283  : 	{
; 284  : 		if( gObj[m_iTargetIndex].Life > 0 )

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	69 48 18 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+24], 7072
  00068	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006e	f3 0f 10 84 0a
	bc 00 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+188]
  00077	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0007e	0f 86 80 00 00
	00		 jbe	 $LN4@ModeAttack

; 285  : 		{
; 286  : 			dis = gObjCalDistance(lpObj, &gObj[m_iTargetIndex]);

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	69 48 18 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+24], 7072
  0008e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00094	51		 push	 ecx
  00095	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0009e	83 c4 08	 add	 esp, 8
  000a1	89 45 f0	 mov	 DWORD PTR _dis$[ebp], eax

; 287  : 			if( dis < MAX_DARKSPIRIT_ATTACK_RANGE+2 )

  000a4	83 7d f0 07	 cmp	 DWORD PTR _dis$[ebp], 7
  000a8	7d 58		 jge	 SHORT $LN9@ModeAttack

; 288  : 			{	
; 289  : 				int criticaldamage = 0;

  000aa	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _criticaldamage$1[ebp], 0

; 290  : #ifdef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 291  : 				if( (rand()%100) < lpObj->m_CriticalDamage )	// 크리티컬(행운) 데미지
; 292  : 					criticaldamage = 1;
; 293  : 				
; 294  : 				if( (rand()%100) < lpObj->m_ExcelentDamage )	// 엑설런트 데미지
; 295  : 					criticaldamage = 2;
; 296  : #else
; 297  : 				if( (rand()%10) < 3 )

  000b1	e8 00 00 00 00	 call	 _rand
  000b6	99		 cdq
  000b7	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000bc	f7 f9		 idiv	 ecx
  000be	83 fa 03	 cmp	 edx, 3
  000c1	7d 07		 jge	 SHORT $LN7@ModeAttack

; 298  : 				{	// 가끔식 크리티컬 데이지 들어간다
; 299  : 					criticaldamage = 0;

  000c3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _criticaldamage$1[ebp], 0
$LN7@ModeAttack:

; 300  : 				}
; 301  : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 302  : 
; 303  : 				if( criticaldamage )

  000ca	83 7d ec 00	 cmp	 DWORD PTR _criticaldamage$1[ebp], 0
  000ce	74 1d		 je	 SHORT $LN8@ModeAttack

; 304  : 				{					
; 305  : 					SendAttackMsg(lpObj->m_Index, m_iTargetIndex, criticaldamage);

  000d0	6a 00		 push	 0
  000d2	8b 45 ec	 mov	 eax, DWORD PTR _criticaldamage$1[ebp]
  000d5	50		 push	 eax
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000dc	52		 push	 edx
  000dd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e2	51		 push	 ecx
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	e8 00 00 00 00	 call	 ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ; CDarkSpirit::SendAttackMsg

; 306  : 
; 307  : #if TESTSERVER == 1
; 308  : 					DebugOutput(lpObj->m_Index, "[다크스피릿] %s 타켓(캐릭)공격", gObj[m_iTargetIndex].Name);
; 309  : #endif	
; 310  : 				}

  000eb	eb 15		 jmp	 SHORT $LN9@ModeAttack
$LN8@ModeAttack:

; 311  : 				else
; 312  : 				{
; 313  : 					RangeAttack(lpObj->m_Index, m_iTargetIndex);

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000f3	51		 push	 ecx
  000f4	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f7	8b 02		 mov	 eax, DWORD PTR [edx]
  000f9	50		 push	 eax
  000fa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	e8 00 00 00 00	 call	 ?RangeAttack@CDarkSpirit@@QAEXHH@Z ; CDarkSpirit::RangeAttack
$LN9@ModeAttack:

; 314  : #if TESTSERVER == 1
; 315  : 					DebugOutput(lpObj->m_Index, "[다크스피릿] %s 타켓(캐릭)공격", gObj[m_iTargetIndex].Name);
; 316  : #endif				
; 317  : 				}				
; 318  : 				//CDarkSpirit::Attack(lpObj, &gObj[m_iTargetIndex], NULL, 1);
; 319  : 			}
; 320  : 		}

  00102	eb 0f		 jmp	 SHORT $LN5@ModeAttack
$LN4@ModeAttack:

; 321  : 		else	// 죽으면 타켓을 없앤다
; 322  : 			ReSetTarget(m_iTargetIndex);

  00104	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00107	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0010a	51		 push	 ecx
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget
$LN5@ModeAttack:
$LN1@ModeAttack:

; 323  : 	}
; 324  : }

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ ENDP		; CDarkSpirit::ModeAttackWithMaster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?ModeAttackRandom@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
_targetindex$1 = -352					; size = 4
_targetindex$2 = -348					; size = 4
_CallMonIndex$3 = -344					; size = 4
_criticaldamage$ = -340					; size = 4
_EnableAttack$ = -336					; size = 4
_DuelIndex$ = -332					; size = 4
_dis$ = -328						; size = 4
_FindObjCount$ = -324					; size = 4
_FindObj$ = -320					; size = 300
_count$ = -20						; size = 4
_tObjNum$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ModeAttackRandom@CDarkSpirit@@QAEXXZ PROC		; CDarkSpirit::ModeAttackRandom, COMDAT
; _this$ = ecx

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 	LPOBJECTSTRUCT lpObj = &gObj[m_iMasterIndex];

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  00023	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00029	89 4d f4	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 158  : 
; 159  : 	int tObjNum;
; 160  : 	int count = 0;	

  0002c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 161  : 	int	FindObj[MAXVIEWPORTOBJECT];
; 162  : 	int FindObjCount = 0;

  00033	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _FindObjCount$[ebp], 0

; 163  : 	int dis;
; 164  : 
; 165  : #ifdef DUEL_SYSTEM_20031028
; 166  : 	int DuelIndex = lpObj->m_iDuelUser;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00040	8b 88 ec 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3308]
  00046	89 8d b4 fe ff
	ff		 mov	 DWORD PTR _DuelIndex$[ebp], ecx

; 167  : #endif
; 168  : 	
; 169  : 	BOOL	EnableAttack;
; 170  : 
; 171  : 	int criticaldamage = 0;

  0004c	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _criticaldamage$[ebp], 0

; 172  : 	
; 173  : #ifdef MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 174  : 	if( (rand()%100) < lpObj->m_CriticalDamage )	// 크리티컬(행운) 데미지
; 175  : 		criticaldamage = 1;
; 176  : 	
; 177  : 	if( (rand()%100) < lpObj->m_ExcelentDamage )	// 엑설런트 데미지
; 178  : 		criticaldamage = 2;
; 179  : #else
; 180  : 	if( (rand()%10) < 3 )

  00056	e8 00 00 00 00	 call	 _rand
  0005b	99		 cdq
  0005c	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00061	f7 f9		 idiv	 ecx
  00063	83 fa 03	 cmp	 edx, 3
  00066	7d 0a		 jge	 SHORT $LN4@ModeAttack

; 181  : 	{	// 가끔식 크리티컬 데이지 들어간다
; 182  : 		criticaldamage = 1;

  00068	c7 85 ac fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _criticaldamage$[ebp], 1
$LN4@ModeAttack:

; 183  : 	}
; 184  : #endif // MODIFY_EX_DAMAGE_DARKSPRIT_BUGFIX_20080826
; 185  : 
; 186  : 	while(1)

  00072	b8 01 00 00 00	 mov	 eax, 1
  00077	85 c0		 test	 eax, eax
  00079	0f 84 23 02 00
	00		 je	 $LN3@ModeAttack

; 187  : 	{
; 188  : 		if( lpObj->VpPlayer2[count].state )

  0007f	6b 45 ec 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  00083	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00086	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  0008e	85 d2		 test	 edx, edx
  00090	0f 84 f6 01 00
	00		 je	 $LN19@ModeAttack

; 189  : 		{
; 190  : 			if( lpObj->VpPlayer2[count].type == OBJTYPE_MONSTER )

  00096	6b 45 ec 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009d	0f b6 94 01 ec
	06 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1772]
  000a5	83 fa 02	 cmp	 edx, 2
  000a8	0f 85 de 01 00
	00		 jne	 $LN19@ModeAttack

; 191  : 			{
; 192  : 				tObjNum = lpObj->VpPlayer2[count].number;

  000ae	6b 45 ec 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b5	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  000bd	89 55 f0	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 193  : 				if( tObjNum >= 0 )

  000c0	83 7d f0 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  000c4	0f 8c c2 01 00
	00		 jl	 $LN19@ModeAttack

; 194  : 				{	
; 195  : 					EnableAttack = FALSE;

  000ca	c7 85 b0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _EnableAttack$[ebp], 0

; 196  : 
; 197  : 					if( gObj[tObjNum].Life > 0 &&  

  000d4	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e1	f3 0f 10 84 01
	bc 00 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+188]
  000ea	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000f1	0f 86 95 01 00
	00		 jbe	 $LN19@ModeAttack
  000f7	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00104	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  0010c	83 fa 64	 cmp	 edx, 100		; 00000064H
  0010f	7c 1e		 jl	 SHORT $LN9@ModeAttack
  00111	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011e	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00126	83 fa 6e	 cmp	 edx, 110		; 0000006eH
  00129	0f 8e 5d 01 00
	00		 jle	 $LN19@ModeAttack
$LN9@ModeAttack:

; 198  : 						(gObj[tObjNum].Class < 100 || gObj[tObjNum].Class > 110) ) 
; 199  : 					{	// 살아 있어야 된다
; 200  : 						if( ((lpObj->VpPlayer2[count].type == OBJTYPE_MONSTER) && (gObj[tObjNum].m_RecallMon < 0)) )

  0012f	6b 45 ec 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  00133	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00136	0f b6 94 01 ec
	06 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1772]
  0013e	83 fa 02	 cmp	 edx, 2
  00141	75 26		 jne	 SHORT $LN10@ModeAttack
  00143	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00150	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  00158	7d 0f		 jge	 SHORT $LN10@ModeAttack

; 201  : 						{	// 대상이 몬스터이고, 소환몹이 아니면 공격가능
; 202  : 							EnableAttack = TRUE;

  0015a	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _EnableAttack$[ebp], 1

; 203  : 						}

  00164	e9 b0 00 00 00	 jmp	 $LN16@ModeAttack
$LN10@ModeAttack:

; 204  : 	#ifdef DUEL_SYSTEM_20031028
; 205  : 						else if( DuelIndex == tObjNum )

  00169	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _DuelIndex$[ebp]
  0016f	3b 45 f0	 cmp	 eax, DWORD PTR _tObjNum$[ebp]
  00172	75 0f		 jne	 SHORT $LN12@ModeAttack

; 206  : 						{	// 클라이언트에서 대상을 강제 공격했을때와 결투 대상일때는 공격가능
; 207  : 							EnableAttack = TRUE;

  00174	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _EnableAttack$[ebp], 1

; 208  : 						}

  0017e	e9 96 00 00 00	 jmp	 $LN16@ModeAttack
$LN12@ModeAttack:

; 209  : 	#endif
; 210  : 						else
; 211  : 						{	// 길드전 체크
; 212  : 							int CallMonIndex = gObj[tObjNum].m_Index;

  00183	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  0018a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00190	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00193	89 95 a8 fe ff
	ff		 mov	 DWORD PTR _CallMonIndex$3[ebp], edx

; 213  : 							if( gObj[tObjNum].Type == OBJTYPE_MONSTER )

  00199	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a6	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  001ab	83 fa 02	 cmp	 edx, 2
  001ae	75 3d		 jne	 SHORT $LN15@ModeAttack

; 214  : 							{
; 215  : 								if( gObj[tObjNum].m_RecallMon >= 0 ) 

  001b0	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  001b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bd	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  001c5	7c 26		 jl	 SHORT $LN15@ModeAttack

; 216  : 								{
; 217  : 									CallMonIndex = gObj[gObj[tObjNum].m_RecallMon].m_Index;

  001c7	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  001ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d4	69 94 01 a4 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+676], 7072
  001df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e4	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  001e7	89 8d a8 fe ff
	ff		 mov	 DWORD PTR _CallMonIndex$3[ebp], ecx
$LN15@ModeAttack:

; 218  : 								}
; 219  : 							}
; 220  : 							if( gObjTargetGuildWarCheck(lpObj, &gObj[CallMonIndex]) == TRUE )

  001ed	69 85 a8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _CallMonIndex$3[ebp], 7072
  001f7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001fd	50		 push	 eax
  001fe	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00207	83 c4 08	 add	 esp, 8
  0020a	83 f8 01	 cmp	 eax, 1
  0020d	75 0a		 jne	 SHORT $LN16@ModeAttack

; 221  : 							{	// 대상이 길전상대이면 공격가능
; 222  : 								EnableAttack = TRUE;

  0020f	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _EnableAttack$[ebp], 1
$LN16@ModeAttack:

; 223  : 							}
; 224  : 						}
; 225  : 
; 226  : 						if( EnableAttack )

  00219	83 bd b0 fe ff
	ff 00		 cmp	 DWORD PTR _EnableAttack$[ebp], 0
  00220	74 6a		 je	 SHORT $LN19@ModeAttack

; 227  : 						{
; 228  : 							if( lpObj->MapNumber == gObj[tObjNum].MapNumber) 

  00222	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00225	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0022c	69 55 f0 a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  00233	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00238	0f b6 94 10 09
	01 00 00	 movzx	 edx, BYTE PTR [eax+edx+265]
  00240	3b ca		 cmp	 ecx, edx
  00242	75 48		 jne	 SHORT $LN19@ModeAttack

; 229  : 							{
; 230  : 								dis = gObjCalDistance(lpObj, &gObj[tObjNum]);

  00244	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  0024b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00251	50		 push	 eax
  00252	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00255	51		 push	 ecx
  00256	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0025b	83 c4 08	 add	 esp, 8
  0025e	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _dis$[ebp], eax

; 231  : 
; 232  : 								if( dis < MAX_DARKSPIRIT_ATTACK_RANGE )

  00264	83 bd b8 fe ff
	ff 05		 cmp	 DWORD PTR _dis$[ebp], 5
  0026b	7d 1f		 jge	 SHORT $LN19@ModeAttack

; 233  : 								{
; 234  : 									FindObj[FindObjCount] = tObjNum;

  0026d	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _FindObjCount$[ebp]
  00273	8b 4d f0	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  00276	89 8c 85 c0 fe
	ff ff		 mov	 DWORD PTR _FindObj$[ebp+eax*4], ecx

; 235  : 									FindObjCount++;

  0027d	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _FindObjCount$[ebp]
  00283	83 c0 01	 add	 eax, 1
  00286	89 85 bc fe ff
	ff		 mov	 DWORD PTR _FindObjCount$[ebp], eax
$LN19@ModeAttack:

; 236  : 								}
; 237  : 							}
; 238  : 						}
; 239  : 					}
; 240  : 				}
; 241  : 			}
; 242  : 		}
; 243  : 		count++;

  0028c	8b 45 ec	 mov	 eax, DWORD PTR _count$[ebp]
  0028f	83 c0 01	 add	 eax, 1
  00292	89 45 ec	 mov	 DWORD PTR _count$[ebp], eax

; 244  : 		if( count > MAXVIEWPORTOBJECT-1 )

  00295	83 7d ec 4a	 cmp	 DWORD PTR _count$[ebp], 74 ; 0000004aH
  00299	7e 02		 jle	 SHORT $LN20@ModeAttack

; 245  : 		{
; 246  : 			break;

  0029b	eb 05		 jmp	 SHORT $LN3@ModeAttack
$LN20@ModeAttack:

; 247  : 		}
; 248  : 	}

  0029d	e9 d0 fd ff ff	 jmp	 $LN4@ModeAttack
$LN3@ModeAttack:

; 249  : 
; 250  : 	if( FindObjCount )

  002a2	83 bd bc fe ff
	ff 00		 cmp	 DWORD PTR _FindObjCount$[ebp], 0
  002a9	74 70		 je	 SHORT $LN23@ModeAttack

; 251  : 	{
; 252  : 		if( criticaldamage )

  002ab	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR _criticaldamage$[ebp], 0
  002b2	74 39		 je	 SHORT $LN22@ModeAttack

; 253  : 		{
; 254  : 			int targetindex = FindObj[rand()%FindObjCount];

  002b4	e8 00 00 00 00	 call	 _rand
  002b9	99		 cdq
  002ba	f7 bd bc fe ff
	ff		 idiv	 DWORD PTR _FindObjCount$[ebp]
  002c0	8b 84 95 c0 fe
	ff ff		 mov	 eax, DWORD PTR _FindObj$[ebp+edx*4]
  002c7	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _targetindex$2[ebp], eax

; 255  : 			SendAttackMsg(lpObj->m_Index, targetindex, criticaldamage);

  002cd	6a 00		 push	 0
  002cf	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _criticaldamage$[ebp]
  002d5	50		 push	 eax
  002d6	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _targetindex$2[ebp]
  002dc	51		 push	 ecx
  002dd	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002e0	8b 02		 mov	 eax, DWORD PTR [edx]
  002e2	50		 push	 eax
  002e3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e6	e8 00 00 00 00	 call	 ?SendAttackMsg@CDarkSpirit@@QAEXHHHH@Z ; CDarkSpirit::SendAttackMsg

; 256  : #if TESTSERVER == 1
; 257  : 		DebugOutput(lpObj->m_Index, "[다크스피릿] %s 랜덤공격", gObj[targetindex].Name);
; 258  : #endif
; 259  : 		}

  002eb	eb 2e		 jmp	 SHORT $LN23@ModeAttack
$LN22@ModeAttack:

; 260  : 		else
; 261  : 		{
; 262  : 			int targetindex = FindObj[rand()%FindObjCount];

  002ed	e8 00 00 00 00	 call	 _rand
  002f2	99		 cdq
  002f3	f7 bd bc fe ff
	ff		 idiv	 DWORD PTR _FindObjCount$[ebp]
  002f9	8b 84 95 c0 fe
	ff ff		 mov	 eax, DWORD PTR _FindObj$[ebp+edx*4]
  00300	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _targetindex$1[ebp], eax

; 263  : 			RangeAttack(lpObj->m_Index, targetindex);

  00306	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _targetindex$1[ebp]
  0030c	50		 push	 eax
  0030d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00310	8b 11		 mov	 edx, DWORD PTR [ecx]
  00312	52		 push	 edx
  00313	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00316	e8 00 00 00 00	 call	 ?RangeAttack@CDarkSpirit@@QAEXHH@Z ; CDarkSpirit::RangeAttack
$LN23@ModeAttack:

; 264  : 			
; 265  : #if TESTSERVER == 1
; 266  : 			DebugOutput(lpObj->m_Index, "[다크스피릿] %s 랜덤공격", gObj[targetindex].Name);
; 267  : #endif
; 268  : 		}
; 269  : 		//CDarkSpirit::Attack(lpObj, &gObj[targetindex], NULL, 1);
; 270  : 	}
; 271  : }

  0031b	5f		 pop	 edi
  0031c	5e		 pop	 esi
  0031d	5b		 pop	 ebx
  0031e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00321	33 cd		 xor	 ecx, ebp
  00323	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00328	8b e5		 mov	 esp, ebp
  0032a	5d		 pop	 ebp
  0032b	c3		 ret	 0
?ModeAttackRandom@CDarkSpirit@@QAEXXZ ENDP		; CDarkSpirit::ModeAttackRandom
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?ModeNormal@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
?ModeNormal@CDarkSpirit@@QAEXXZ PROC			; CDarkSpirit::ModeNormal, COMDAT
; _this$ = ecx

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 	LPOBJECTSTRUCT lpObj = &gObj[m_iMasterIndex];

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  00016	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001c	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 153  : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?ModeNormal@CDarkSpirit@@QAEXXZ ENDP			; CDarkSpirit::ModeNormal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?Run@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
tv148 = -80						; size = 4
_attr$ = -9						; size = 1
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
?Run@CDarkSpirit@@QAEXXZ PROC				; CDarkSpirit::Run, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   : 	if( m_iMasterIndex == -1 )

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00013	75 05		 jne	 SHORT $LN4@Run

; 97   : 		return;	// 마스터가 없으면 처리 없음

  00015	e9 28 01 00 00	 jmp	 $LN1@Run
$LN4@Run:

; 98   : 
; 99   : 	LPOBJECTSTRUCT lpObj = &gObj[m_iMasterIndex];

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	69 48 14 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+20], 7072
  00024	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002a	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 100  : 	if(lpObj->Class != CLASS_DARKLORD )

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00030	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00037	83 f9 04	 cmp	 ecx, 4
  0003a	74 05		 je	 SHORT $LN5@Run

; 101  : 		return;

  0003c	e9 01 01 00 00	 jmp	 $LN1@Run
$LN5@Run:

; 102  : 
; 103  : 	if( !m_pPetItem )	// 펫아이템이 없다

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00048	75 05		 jne	 SHORT $LN6@Run

; 104  : 		return;

  0004a	e9 f3 00 00 00	 jmp	 $LN1@Run
$LN6@Run:

; 105  : 
; 106  : 	if( m_pPetItem->m_Durability <= 0.f )

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00055	0f 57 c0	 xorps	 xmm0, xmm0
  00058	0f 2f 41 24	 comiss	 xmm0, DWORD PTR [ecx+36]
  0005c	72 05		 jb	 SHORT $LN7@Run

; 107  : 		return;		// 죽었다.

  0005e	e9 df 00 00 00	 jmp	 $LN1@Run
$LN7@Run:

; 108  : 
; 109  : 	BYTE attr = MapC[lpObj->MapNumber].GetAttr(lpObj->X, lpObj->Y);

  00063	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00066	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0006d	51		 push	 ecx
  0006e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00071	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00078	50		 push	 eax
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007c	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00083	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00089	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0008f	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00094	88 45 f7	 mov	 BYTE PTR _attr$[ebp], al

; 110  : 
; 111  : 	if( (attr & MAP_ATTR_SAFTYZONE) )

  00097	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  0009b	83 e0 01	 and	 eax, 1
  0009e	74 05		 je	 SHORT $LN8@Run

; 112  : 	{	// 안전지대...
; 113  : 		return;

  000a0	e9 9d 00 00 00	 jmp	 $LN1@Run
$LN8@Run:

; 114  : 	}
; 115  : 
; 116  : #ifdef MODIFY_SETITEM_LEADERSHIP_BUGFIX
; 117  : 	//통솔 요구치 적용(다크스피릿만)
; 118  : 	if (m_pPetItem->m_RequireLeaderShip)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000ab	0f b7 51 4c	 movzx	 edx, WORD PTR [ecx+76]
  000af	85 d2		 test	 edx, edx
  000b1	74 26		 je	 SHORT $LN10@Run

; 119  : 	{
; 120  : 		if (lpObj->Leadership+lpObj->AddLeadership < m_pPetItem->m_RequireLeaderShip)

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b6	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR [eax+216]
  000bd	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c0	0f b7 82 da 00
	00 00		 movzx	 eax, WORD PTR [edx+218]
  000c7	03 c8		 add	 ecx, eax
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cc	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000cf	0f b7 50 4c	 movzx	 edx, WORD PTR [eax+76]
  000d3	3b ca		 cmp	 ecx, edx
  000d5	7d 02		 jge	 SHORT $LN10@Run

; 121  : 			return;

  000d7	eb 69		 jmp	 SHORT $LN1@Run
$LN10@Run:

; 122  : 	}
; 123  : #endif // MODIFY_SETITEM_LEADERSHIP_BUGFIX
; 124  : 
; 125  : 	if( m_dwLastAttackTime > GetTickCount() )

  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	39 41 1c	 cmp	 DWORD PTR [ecx+28], eax
  000e5	76 02		 jbe	 SHORT $LN11@Run

; 126  : 		return;

  000e7	eb 59		 jmp	 SHORT $LN1@Run
$LN11@Run:

; 127  : 	
; 128  : 	m_dwLastAttackTime = GetTickCount()+(1500)-(m_AttackSpeed*10);

  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000ef	05 dc 05 00 00	 add	 eax, 1500		; 000005dcH
  000f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	6b 51 0c 0a	 imul	 edx, DWORD PTR [ecx+12], 10
  000fb	2b c2		 sub	 eax, edx
  000fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 129  : 
; 130  : 	switch(m_ActionMode)

  00103	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00106	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00109	89 4d b0	 mov	 DWORD PTR tv148[ebp], ecx
  0010c	83 7d b0 03	 cmp	 DWORD PTR tv148[ebp], 3
  00110	77 30		 ja	 SHORT $LN2@Run
  00112	8b 55 b0	 mov	 edx, DWORD PTR tv148[ebp]
  00115	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN17@Run[edx*4]
$LN12@Run:

; 131  : 	{
; 132  : 		case CDarkSpirit::PetItem_Mode_Normal:			
; 133  : 			ModeNormal();

  0011c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	e8 00 00 00 00	 call	 ?ModeNormal@CDarkSpirit@@QAEXXZ ; CDarkSpirit::ModeNormal

; 134  : 		break;

  00124	eb 1c		 jmp	 SHORT $LN2@Run
$LN13@Run:

; 135  : 
; 136  : 		case CDarkSpirit::PetItem_Mode_Attack_Random:			
; 137  : 			ModeAttackRandom();

  00126	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?ModeAttackRandom@CDarkSpirit@@QAEXXZ ; CDarkSpirit::ModeAttackRandom

; 138  : 		break;

  0012e	eb 12		 jmp	 SHORT $LN2@Run
$LN14@Run:

; 139  : 
; 140  : 		case CDarkSpirit::PetItem_Mode_Attack_WithMaster:			
; 141  : 			ModeAttackWithMaster();

  00130	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	e8 00 00 00 00	 call	 ?ModeAttackWithMaster@CDarkSpirit@@QAEXXZ ; CDarkSpirit::ModeAttackWithMaster

; 142  : 		break;

  00138	eb 08		 jmp	 SHORT $LN2@Run
$LN15@Run:

; 143  : 
; 144  : 		case CDarkSpirit::PetItem_Mode_Attack_Target:			
; 145  : 			ModeAttakTarget();

  0013a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	e8 00 00 00 00	 call	 ?ModeAttakTarget@CDarkSpirit@@QAEXXZ ; CDarkSpirit::ModeAttakTarget
$LN2@Run:
$LN1@Run:

; 146  : 		break;
; 147  : 	}
; 148  : }

  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
  00149	0f 1f 00	 npad	 3
$LN17@Run:
  0014c	00 00 00 00	 DD	 $LN12@Run
  00150	00 00 00 00	 DD	 $LN13@Run
  00154	00 00 00 00	 DD	 $LN14@Run
  00158	00 00 00 00	 DD	 $LN15@Run
?Run@CDarkSpirit@@QAEXXZ ENDP				; CDarkSpirit::Run
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?Init@CDarkSpirit@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@CDarkSpirit@@QAEXXZ PROC				; CDarkSpirit::Init, COMDAT
; _this$ = ecx

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 82   : 	m_AttackDamageMin = 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 83   : 	m_AttackDamageMax = 0;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 84   : 	m_AttackSpeed = 0;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 85   : 	m_SuccessAttackRate = 0;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 86   : 
; 87   : 	m_dwLastAttackTime = 0;	

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 88   : 
; 89   : 	m_iMasterIndex = -1;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [eax+20], -1

; 90   : 	m_iTargetIndex = -1;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	c7 40 18 ff ff
	ff ff		 mov	 DWORD PTR [eax+24], -1

; 91   : 	m_pPetItem = NULL;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 92   : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?Init@CDarkSpirit@@QAEXXZ ENDP				; CDarkSpirit::Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ??1CDarkSpirit@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CDarkSpirit@@UAE@XZ PROC				; CDarkSpirit::~CDarkSpirit, COMDAT
; _this$ = ecx

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDarkSpirit@@6B@

; 77   : 	
; 78   : }

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1CObjBaseAttack@@UAE@XZ ; CObjBaseAttack::~CObjBaseAttack
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1CDarkSpirit@@UAE@XZ ENDP				; CDarkSpirit::~CDarkSpirit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ??0CDarkSpirit@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CDarkSpirit@@QAE@XZ PROC				; CDarkSpirit::CDarkSpirit, COMDAT
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CDarkSpirit@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0CObjBaseAttack@@QAE@XZ ; CObjBaseAttack::CObjBaseAttack
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDarkSpirit@@6B@

; 70   : CDarkSpirit::CDarkSpirit():m_ActionMode(CDarkSpirit::PetItem_Mode_Normal)

  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 72   : 	Init();

  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?Init@CDarkSpirit@@QAEXXZ ; CDarkSpirit::Init

; 73   : }

  00055	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CDarkSpirit@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CObjBaseAttack@@UAE@XZ ; CObjBaseAttack::~CObjBaseAttack
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0CDarkSpirit@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CDarkSpirit@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CDarkSpirit@@QAE@XZ ENDP				; CDarkSpirit::CDarkSpirit
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\ProDef.h
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 25   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 		lpBuf[0] = PMHC_BYTE;

  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	6b c8 00	 imul	 ecx, eax, 0
  00014	8b 55 08	 mov	 edx, DWORD PTR _lpBuf$[ebp]
  00017	c6 04 0a c1	 mov	 BYTE PTR [edx+ecx], 193	; 000000c1H

; 27   : 		lpBuf[1] = size;

  0001b	b8 01 00 00 00	 mov	 eax, 1
  00020	c1 e0 00	 shl	 eax, 0
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  00026	8a 55 10	 mov	 dl, BYTE PTR _size$[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 28   : 		lpBuf[2] = head;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	d1 e0		 shl	 eax, 1
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  00036	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  00039	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 29   : 	}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DarkSpirit.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
