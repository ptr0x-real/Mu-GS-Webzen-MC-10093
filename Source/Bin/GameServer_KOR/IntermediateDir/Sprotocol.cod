; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?SetBill@BILL_CLASS@@QAEHEKKPAD@Z		; BILL_CLASS::SetBill
PUBLIC	?GetDeductType@BILL_CLASS@@QAEEXZ		; BILL_CLASS::GetDeductType
PUBLIC	?_ARGB@@YAKEEEE@Z				; _ARGB
PUBLIC	?GetState@CDragonEvent@@QAEEXZ			; CDragonEvent::GetState
PUBLIC	?GJPAccountFail@@YAXFPADHH@Z			; GJPAccountFail
PUBLIC	?JGServerLoginResult@@YAXPAUSDHP_RESULT@@@Z	; JGServerLoginResult
PUBLIC	?JGPAccountRequest@@YAXPAUSDHP_IDPASSRESULT@@@Z	; JGPAccountRequest
PUBLIC	?GJPBillCeckRecv@@YAXPAUSDHP_BILLSEARCH_RESULT@@@Z ; GJPBillCeckRecv
PUBLIC	?GJPUserKillRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z	; GJPUserKillRecv
PUBLIC	?GJPUserDisconnectRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z ; GJPUserDisconnectRecv
PUBLIC	?JGPEventStart@@YAXPAUSDHP_EVENTSTART@@@Z	; JGPEventStart
PUBLIC	?JGPEventControl@@YAXPAUSDHP_EVENTCONTROL@@@Z	; JGPEventControl
PUBLIC	?JGPOptionControl@@YAXPAUSDHP_OPTIONCONTROL@@@Z	; JGPOptionControl
PUBLIC	?JGOtherJoin@@YAXPAUSDHP_OTHERJOINMSG@@@Z	; JGOtherJoin
PUBLIC	?JGPExitCodeRecv@@YAXPAUSDHP_EXITMSG@@@Z	; JGPExitCodeRecv
PUBLIC	?LoveHeartEventRecv@@YAXPAUSDHP_LOVEHEARTEVENT_RESULT@@@Z ; LoveHeartEventRecv
PUBLIC	?AllNoticeRecv@@YAXPAUSDHP_NOTICE@@@Z		; AllNoticeRecv
PUBLIC	?UserNoticeRecv@@YAXPAUSDHP_USER_NOTICE@@@Z	; UserNoticeRecv
PUBLIC	?JGPSendMail@@YAXPAUPMSG_JG_MEMO_SEND@@@Z	; JGPSendMail
PUBLIC	?SProtocolCore@@YAXEPAEH@Z			; SProtocolCore
PUBLIC	?GJServerLogin@@YAXXZ				; GJServerLogin
PUBLIC	?GJPUserClose@@YAXPAD@Z				; GJPUserClose
PUBLIC	?GJPUserClose2@@YAXPAD@Z			; GJPUserClose2
PUBLIC	?GJPUserClose@@YAXPAVOBJECTSTRUCT@@@Z		; GJPUserClose
PUBLIC	?GJPAccountBlock@@YAXFPADHHE@Z			; GJPAccountBlock
PUBLIC	?LoveHeartEventSend@@YAXHPAD0@Z			; LoveHeartEventSend
PUBLIC	?LoveHeartCreateSend@@YAXXZ			; LoveHeartCreateSend
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0DC@EDGCNACO@?0?5?$FLLogin?5Fail?$FN?0?5Account?5?$FL?$CFs?$FN?0?5I@ ; `string'
PUBLIC	??_C@_06KLIOLJEJ@Sucess@			; `string'
PUBLIC	??_C@_04ODLKOBGJ@Fail@				; `string'
PUBLIC	??_C@_0DB@FAFAGCMF@?0?5?$FLLogin?$FN?0?5Account?5?$FL?$CFs?$FN?0?5IP?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0DM@CNIHGDJD@?$FLWzUnificationBill?$FN?$FLDeducateTyp@ ; `string'
PUBLIC	??_C@_0CG@EHIHJKDO@?$FLMu?5Manager?$FN?$FLNotice?5Log?$FN?$FLType?3A@ ; `string'
PUBLIC	??_C@_0CM@EFINMDLC@?$FLMu?5Manager?$FN?$FLNotice?5Log?$FN?$FLType?3U@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?Add@CLoginCount@@QAEXXZ:PROC			; CLoginCount::Add
EXTRN	?Delete@CLoginCount@@QAEXXZ:PROC		; CLoginCount::Delete
EXTRN	?gObjUserKill@@YAXH@Z:PROC			; gObjUserKill
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
EXTRN	?gObjSetAccountLogin@@YAHHPADHH0@Z:PROC		; gObjSetAccountLogin
EXTRN	?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?GCJoinResult@@YAXEH@Z:PROC			; GCJoinResult
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
EXTRN	?SendNoticeToUser@TNotice@@SAXHPAX@Z:PROC	; TNotice::SendNoticeToUser
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?ShopDataLoad@@YAHXZ:PROC			; ShopDataLoad
EXTRN	?GameMonsterAllCloseAndReLoad@@YAXXZ:PROC	; GameMonsterAllCloseAndReLoad
EXTRN	?ReadCommonServerInfo@@YAXXZ:PROC		; ReadCommonServerInfo
EXTRN	?gJoomin15Check@@YAHPAD@Z:PROC			; gJoomin15Check
EXTRN	?gJoominCheck@@YAHPADH@Z:PROC			; gJoominCheck
EXTRN	?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z:PROC	; ReadGameEtcInfo
EXTRN	?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z:PROC	; ReadEventInfo
EXTRN	?Start@CDragonEvent@@QAEXXZ:PROC		; CDragonEvent::Start
EXTRN	?End@CDragonEvent@@QAEXXZ:PROC			; CDragonEvent::End
EXTRN	?MngFriendMemoSend@@YAXPAUPMSG_JG_MEMO_SEND@@@Z:PROC ; MngFriendMemoSend
EXTRN	?SetConnectUser@@YAXPAUUSER_CONNECT_TIME@@@Z:PROC ; SetConnectUser
EXTRN	?setBlockIP@@YAXPAUIP_BLOCK@@@Z:PROC		; setBlockIP
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?LogAddTD_TempLog@@3P6AXPADZZA:DWORD		; LogAddTD_TempLog
EXTRN	?gLCount@@3PAVCLoginCount@@A:BYTE		; gLCount
EXTRN	?m_ObjBill@@3PAVBILL_CLASS@@A:BYTE		; m_ObjBill
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?gServerReady@@3HA:DWORD			; gServerReady
EXTRN	?GameServerPort@@3HA:DWORD			; GameServerPort
EXTRN	?JoinServerConnected@@3HA:DWORD			; JoinServerConnected
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?szServerName@@3PADA:BYTE			; szServerName
EXTRN	?gLanguage@@3HA:DWORD				; gLanguage
EXTRN	?gNonPK@@3HA:DWORD				; gNonPK
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
EXTRN	?gXMasEvent@@3HA:DWORD				; gXMasEvent
EXTRN	?gFireCrackerEvent@@3HA:DWORD			; gFireCrackerEvent
EXTRN	?gHeartOfLoveEvent@@3HA:DWORD			; gHeartOfLoveEvent
EXTRN	?gMedalEvent@@3HA:DWORD				; gMedalEvent
EXTRN	?wsJServerCli@@3VwsJoinServerCli@@A:BYTE	; wsJServerCli
EXTRN	?DragonEvent@@3PAVCDragonEvent@@A:DWORD		; DragonEvent
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0CM@EFINMDLC@?$FLMu?5Manager?$FN?$FLNotice?5Log?$FN?$FLType?3U@
CONST	SEGMENT
??_C@_0CM@EFINMDLC@?$FLMu?5Manager?$FN?$FLNotice?5Log?$FN?$FLType?3U@ DB '['
	DB	'Mu Manager][Notice Log][Type:USER] (%s) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EHIHJKDO@?$FLMu?5Manager?$FN?$FLNotice?5Log?$FN?$FLType?3A@
CONST	SEGMENT
??_C@_0CG@EHIHJKDO@?$FLMu?5Manager?$FN?$FLNotice?5Log?$FN?$FLType?3A@ DB '['
	DB	'Mu Manager][Notice Log][Type:ALL] %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@CNIHGDJD@?$FLWzUnificationBill?$FN?$FLDeducateTyp@
CONST	SEGMENT
??_C@_0DM@CNIHGDJD@?$FLWzUnificationBill?$FN?$FLDeducateTyp@ DB '[WzUnifi'
	DB	'cationBill][DeducateType] - Change %d -> %d (ID:%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FAFAGCMF@?0?5?$FLLogin?$FN?0?5Account?5?$FL?$CFs?$FN?0?5IP?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DB@FAFAGCMF@?0?5?$FLLogin?$FN?0?5Account?5?$FL?$CFs?$FN?0?5IP?5?$FL?$CFs@ DB ','
	DB	' [Login], Account [%s], IP [%s], result[%d], %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODLKOBGJ@Fail@
CONST	SEGMENT
??_C@_04ODLKOBGJ@Fail@ DB 'Fail', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLIOLJEJ@Sucess@
CONST	SEGMENT
??_C@_06KLIOLJEJ@Sucess@ DB 'Sucess', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EDGCNACO@?0?5?$FLLogin?5Fail?$FN?0?5Account?5?$FL?$CFs?$FN?0?5I@
CONST	SEGMENT
??_C@_0DC@EDGCNACO@?0?5?$FLLogin?5Fail?$FN?0?5Account?5?$FL?$CFs?$FN?0?5I@ DB ','
	DB	' [Login Fail], Account [%s], IP [%s], result[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?LoveHeartCreateSend@@YAXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
?LoveHeartCreateSend@@YAXXZ PROC			; LoveHeartCreateSend, COMDAT

; 997  : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 998  : 	SDHP_LOVEHEARTCREATE	pMsg;
; 999  : 
; 1000 : 	pMsg.h.c		= PMHC_BYTE;

  00009	c6 45 f8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 1001 : 	pMsg.h.headcode	= 0x31;

  0000d	c6 45 fa 31	 mov	 BYTE PTR _pMsg$[ebp+2], 49 ; 00000031H

; 1002 : 	pMsg.h.size		= sizeof( pMsg );

  00011	c6 45 f9 06	 mov	 BYTE PTR _pMsg$[ebp+1], 6

; 1003 : 	wsJServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  00015	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00019	50		 push	 eax
  0001a	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0001d	51		 push	 ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00023	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 1004 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?LoveHeartCreateSend@@YAXXZ ENDP			; LoveHeartCreateSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?LoveHeartEventSend@@YAXHPAD0@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 23
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_AcountId$ = 12						; size = 4
_Name$ = 16						; size = 4
?LoveHeartEventSend@@YAXHPAD0@Z PROC			; LoveHeartEventSend, COMDAT

; 938  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 939  : 	SDHP_LOVEHEARTEVENT	pMsg;
; 940  : 
; 941  : 	pMsg.h.c		= PMHC_BYTE;

  00013	c6 45 e4 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 942  : 	pMsg.h.headcode	= 0x30;

  00017	c6 45 e6 30	 mov	 BYTE PTR _pMsg$[ebp+2], 48 ; 00000030H

; 943  : 	pMsg.h.size		= sizeof( pMsg );

  0001b	c6 45 e5 17	 mov	 BYTE PTR _pMsg$[ebp+1], 23 ; 00000017H

; 944  : 	memcpy(pMsg.Account, AcountId, MAX_IDSTRING);

  0001f	6a 0a		 push	 10			; 0000000aH
  00021	8b 45 0c	 mov	 eax, DWORD PTR _AcountId$[ebp]
  00024	50		 push	 eax
  00025	8d 4d e7	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _memcpy
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 945  : 	memcpy(pMsg.Name,	Name, MAX_IDSTRING);

  00031	6a 0a		 push	 10			; 0000000aH
  00033	8b 45 10	 mov	 eax, DWORD PTR _Name$[ebp]
  00036	50		 push	 eax
  00037	8d 4d f1	 lea	 ecx, DWORD PTR _pMsg$[ebp+13]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _memcpy
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 946  : 	
; 947  : 	wsJServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  00043	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00047	50		 push	 eax
  00048	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0004b	51		 push	 ecx
  0004c	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00051	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 948  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	33 cd		 xor	 ecx, ebp
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?LoveHeartEventSend@@YAXHPAD0@Z ENDP			; LoveHeartEventSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?GJPAccountBlock@@YAXFPADHHE@Z
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_number$ = 8						; size = 2
_Id$ = 12						; size = 4
_DBNumber$ = 16						; size = 4
_UserNumber$ = 20					; size = 4
_BlockCode$ = 24					; size = 1
?GJPAccountBlock@@YAXFPADHHE@Z PROC			; GJPAccountBlock, COMDAT

; 613  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 614  : 	SDHP_COMMAND_BLOCK	pMsg;
; 615  : 
; 616  : 	memset( &pMsg, 0, sizeof( pMsg ));

  00013	6a 20		 push	 32			; 00000020H
  00015	6a 00		 push	 0
  00017	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _memset
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 617  : 
; 618  : 	pMsg.h.c		= PMHC_BYTE;

  00023	c6 45 dc c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 619  : 	pMsg.h.headcode	= 0x04;

  00027	c6 45 de 04	 mov	 BYTE PTR _pMsg$[ebp+2], 4

; 620  : 	pMsg.h.size		= sizeof( pMsg );

  0002b	c6 45 dd 20	 mov	 BYTE PTR _pMsg$[ebp+1], 32 ; 00000020H

; 621  : 	pMsg.Number     = number;

  0002f	66 8b 45 08	 mov	 ax, WORD PTR _number$[ebp]
  00033	66 89 45 e0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 622  : 	pMsg.DBNumber	= DBNumber;

  00037	8b 45 10	 mov	 eax, DWORD PTR _DBNumber$[ebp]
  0003a	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 623  : 	pMsg.UserNumber = UserNumber;

  0003d	8b 45 14	 mov	 eax, DWORD PTR _UserNumber$[ebp]
  00040	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 624  : 	pMsg.BlockCode  = BlockCode;

  00043	8a 45 18	 mov	 al, BYTE PTR _BlockCode$[ebp]
  00046	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+28], al

; 625  : 	
; 626  : 	strcpy( pMsg.Id, Id );

  00049	8b 45 0c	 mov	 eax, DWORD PTR _Id$[ebp]
  0004c	50		 push	 eax
  0004d	8d 4d e2	 lea	 ecx, DWORD PTR _pMsg$[ebp+6]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 _strcpy
  00056	83 c4 08	 add	 esp, 8

; 627  : 
; 628  : 	wsJServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  00059	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0005d	50		 push	 eax
  0005e	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00061	51		 push	 ecx
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00067	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 629  : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00072	33 cd		 xor	 ecx, ebp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?GJPAccountBlock@@YAXFPADHHE@Z ENDP			; GJPAccountBlock
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?GJPUserClose@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pClose$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GJPUserClose@@YAXPAVOBJECTSTRUCT@@@Z PROC		; GJPUserClose, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 255  : 	SDHP_USERCLOSE_ID	pClose;
; 256  : 
; 257  : 	pClose.h.c			= PMHC_BYTE;

  00013	c6 45 e0 c1	 mov	 BYTE PTR _pClose$[ebp], 193 ; 000000c1H

; 258  : 	pClose.h.size		= sizeof( pClose );

  00017	c6 45 e1 1c	 mov	 BYTE PTR _pClose$[ebp+1], 28 ; 0000001cH

; 259  : 	pClose.h.headcode	= 0x05;

  0001b	c6 45 e2 05	 mov	 BYTE PTR _pClose$[ebp+2], 5

; 260  : 	memcpy(pClose.szId, lpObj->AccountID, MAX_IDSTRING);

  0001f	6a 0a		 push	 10			; 0000000aH
  00021	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00024	83 c0 68	 add	 eax, 104		; 00000068H
  00027	50		 push	 eax
  00028	8d 4d e3	 lea	 ecx, DWORD PTR _pClose$[ebp+3]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _memcpy
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 261  : 	memcpy(pClose.szName, lpObj->BackName, MAX_IDSTRING);

  00034	6a 0a		 push	 10			; 0000000aH
  00036	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00039	05 dc 0e 00 00	 add	 eax, 3804		; 00000edcH
  0003e	50		 push	 eax
  0003f	8d 4d ed	 lea	 ecx, DWORD PTR _pClose$[ebp+13]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 _memcpy
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 262  : 
; 263  : 	pClose.Level = lpObj->Level;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004e	66 8b 88 a0 00
	00 00		 mov	 cx, WORD PTR [eax+160]
  00055	66 89 4d f8	 mov	 WORD PTR _pClose$[ebp+24], cx

; 264  : 	pClose.DbClass = lpObj->DbClass;

  00059	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005c	8a 88 9e 00 00
	00		 mov	 cl, BYTE PTR [eax+158]
  00062	88 4d fa	 mov	 BYTE PTR _pClose$[ebp+26], cl

; 265  : #if defined(CHN_PLAYTIME_LIMIT_SYSTEM_20050818) || defined(VTM_PLAYTIME_LIMIT_SYSTEM_20060626)
; 266  : 	pClose.iAddPlayTime = lpObj->m_iPlayTimeLimit;
; 267  : #endif
; 268  : 
; 269  : 	wsJServerCli.DataSend((char*)&pClose, pClose.h.size);

  00065	0f b6 45 e1	 movzx	 eax, BYTE PTR _pClose$[ebp+1]
  00069	50		 push	 eax
  0006a	8d 4d e0	 lea	 ecx, DWORD PTR _pClose$[ebp]
  0006d	51		 push	 ecx
  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00073	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 270  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	33 cd		 xor	 ecx, ebp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?GJPUserClose@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; GJPUserClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?GJPUserClose2@@YAXPAD@Z
_TEXT	SEGMENT
_pClose$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_szAccountID$ = 8					; size = 4
?GJPUserClose2@@YAXPAD@Z PROC				; GJPUserClose2, COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 241  : 	SDHP_USERCLOSE_ID pClose;
; 242  : 
; 243  : 	pClose.h.c =0xC1;

  00013	c6 45 e0 c1	 mov	 BYTE PTR _pClose$[ebp], 193 ; 000000c1H

; 244  : 	pClose.h.size= sizeof(SDHP_USERCLOSE_ID);

  00017	c6 45 e1 1c	 mov	 BYTE PTR _pClose$[ebp+1], 28 ; 0000001cH

; 245  : 	pClose.h.headcode = 0x05;

  0001b	c6 45 e2 05	 mov	 BYTE PTR _pClose$[ebp+2], 5

; 246  : 	memcpy(pClose.szId , szAccountID, 10);

  0001f	6a 0a		 push	 10			; 0000000aH
  00021	8b 45 08	 mov	 eax, DWORD PTR _szAccountID$[ebp]
  00024	50		 push	 eax
  00025	8d 4d e3	 lea	 ecx, DWORD PTR _pClose$[ebp+3]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _memcpy
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 247  : 
; 248  : 	wsJServerCli.DataSend((char*)&pClose, pClose.h.size);

  00031	0f b6 45 e1	 movzx	 eax, BYTE PTR _pClose$[ebp+1]
  00035	50		 push	 eax
  00036	8d 4d e0	 lea	 ecx, DWORD PTR _pClose$[ebp]
  00039	51		 push	 ecx
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  0003f	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 249  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GJPUserClose2@@YAXPAD@Z ENDP				; GJPUserClose2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?GJPUserClose@@YAXPAD@Z
_TEXT	SEGMENT
_pClose$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_szAccountID$ = 8					; size = 4
?GJPUserClose@@YAXPAD@Z PROC				; GJPUserClose, COMDAT

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 226  : 	SDHP_USERCLOSE_ID	pClose;
; 227  : 
; 228  : 	pClose.h.c			= PMHC_BYTE;

  00013	c6 45 e0 c1	 mov	 BYTE PTR _pClose$[ebp], 193 ; 000000c1H

; 229  : 	pClose.h.size		= sizeof( pClose );

  00017	c6 45 e1 1c	 mov	 BYTE PTR _pClose$[ebp+1], 28 ; 0000001cH

; 230  : 	pClose.h.headcode	= 0x05;

  0001b	c6 45 e2 05	 mov	 BYTE PTR _pClose$[ebp+2], 5

; 231  : 	memcpy(pClose.szId, szAccountID, MAX_IDSTRING);

  0001f	6a 0a		 push	 10			; 0000000aH
  00021	8b 45 08	 mov	 eax, DWORD PTR _szAccountID$[ebp]
  00024	50		 push	 eax
  00025	8d 4d e3	 lea	 ecx, DWORD PTR _pClose$[ebp+3]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _memcpy
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  : #if defined(CHN_PLAYTIME_LIMIT_SYSTEM_20050818) || defined(VTM_PLAYTIME_LIMIT_SYSTEM_20060626)
; 233  : 	pClose.iAddPlayTime	= iPlayTimeLimit;
; 234  : #endif
; 235  : 
; 236  : 	wsJServerCli.DataSend((char*)&pClose, pClose.h.size);

  00031	0f b6 45 e1	 movzx	 eax, BYTE PTR _pClose$[ebp+1]
  00035	50		 push	 eax
  00036	8d 4d e0	 lea	 ecx, DWORD PTR _pClose$[ebp]
  00039	51		 push	 ecx
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  0003f	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 237  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GJPUserClose@@YAXPAD@Z ENDP				; GJPUserClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?GJServerLogin@@YAXXZ
_TEXT	SEGMENT
_pInfo$ = -64						; size = 58
__$ArrayPad$ = -4					; size = 4
?GJServerLogin@@YAXXZ PROC				; GJServerLogin, COMDAT

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 185  : 	SDHP_SERVERINFO	   pInfo;
; 186  : 
; 187  : 	pInfo.h.c		 = PMHC_BYTE;

  00016	c6 45 c0 c1	 mov	 BYTE PTR _pInfo$[ebp], 193 ; 000000c1H

; 188  : 	pInfo.h.size	 = sizeof(pInfo);

  0001a	c6 45 c1 3a	 mov	 BYTE PTR _pInfo$[ebp+1], 58 ; 0000003aH

; 189  : 	pInfo.h.headcode = 0x00;

  0001e	c6 45 c2 00	 mov	 BYTE PTR _pInfo$[ebp+2], 0

; 190  : 	pInfo.Port		 = GameServerPort;

  00022	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?GameServerPort@@3HA
  00028	66 89 45 c4	 mov	 WORD PTR _pInfo$[ebp+4], ax

; 191  : 	pInfo.Type		 = ST_GAMESERVER;

  0002c	c6 45 c3 01	 mov	 BYTE PTR _pInfo$[ebp+3], 1

; 192  : 	strcpy( pInfo.ServerName, szServerName);

  00030	68 00 00 00 00	 push	 OFFSET ?szServerName@@3PADA ; szServerName
  00035	8d 45 c6	 lea	 eax, DWORD PTR _pInfo$[ebp+6]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _strcpy
  0003e	83 c4 08	 add	 esp, 8

; 193  : 
; 194  : #ifdef JOINSERVER_USING_SERVERCODE
; 195  : 	pInfo.ServerCode = gGameServerCode;

  00041	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00047	66 89 45 f8	 mov	 WORD PTR _pInfo$[ebp+56], ax

; 196  : #endif
; 197  : 	wsJServerCli.DataSend((char*)&pInfo, pInfo.h.size);

  0004b	0f b6 45 c1	 movzx	 eax, BYTE PTR _pInfo$[ebp+1]
  0004f	50		 push	 eax
  00050	8d 4d c0	 lea	 ecx, DWORD PTR _pInfo$[ebp]
  00053	51		 push	 ecx
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00059	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 198  : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	33 cd		 xor	 ecx, ebp
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?GJServerLogin@@YAXXZ ENDP				; GJServerLogin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?SProtocolCore@@YAXEPAEH@Z
_TEXT	SEGMENT
tv65 = -68						; size = 4
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?SProtocolCore@@YAXEPAEH@Z PROC				; SProtocolCore, COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 111  : 	switch( protoNum )

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  0000d	89 45 bc	 mov	 DWORD PTR tv65[ebp], eax
  00010	83 7d bc 63	 cmp	 DWORD PTR tv65[ebp], 99	; 00000063H
  00014	0f 87 df 00 00
	00		 ja	 $LN1@SProtocolC
  0001a	8b 4d bc	 mov	 ecx, DWORD PTR tv65[ebp]
  0001d	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN19@SProtocolC[ecx]
  00024	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN20@SProtocolC[edx*4]
$LN4@SProtocolC:

; 112  : 	{
; 113  : 	case 0x00 :
; 114  : 		JGServerLoginResult((LPSDHP_RESULT)aRecv);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?JGServerLoginResult@@YAXPAUSDHP_RESULT@@@Z ; JGServerLoginResult
  00034	83 c4 04	 add	 esp, 4

; 115  : 		break;

  00037	e9 bd 00 00 00	 jmp	 $LN1@SProtocolC
$LN5@SProtocolC:

; 116  : 	case 0x01: // 인증요청 결과를 처리
; 117  : 		JGPAccountRequest((LPSDHP_IDPASSRESULT)aRecv);

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?JGPAccountRequest@@YAXPAUSDHP_IDPASSRESULT@@@Z ; JGPAccountRequest
  00045	83 c4 04	 add	 esp, 4

; 118  : 		break;

  00048	e9 ac 00 00 00	 jmp	 $LN1@SProtocolC
$LN6@SProtocolC:

; 119  : 	case 0x06 :	// 남은 시간 확인
; 120  : 		GJPBillCeckRecv((LPSDHP_SDHP_BILLSEARCH_RESULT)aRecv);

  0004d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?GJPBillCeckRecv@@YAXPAUSDHP_BILLSEARCH_RESULT@@@Z ; GJPBillCeckRecv
  00056	83 c4 04	 add	 esp, 4

; 121  : 		break;

  00059	e9 9b 00 00 00	 jmp	 $LN1@SProtocolC
$LN7@SProtocolC:

; 122  : 	case 0x07 :
; 123  : 		GJPUserKillRecv((LPSDHP_BILLKILLUSER)aRecv);

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?GJPUserKillRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z ; GJPUserKillRecv
  00067	83 c4 04	 add	 esp, 4

; 124  : 		break;

  0006a	e9 8a 00 00 00	 jmp	 $LN1@SProtocolC
$LN8@SProtocolC:

; 125  : 	case 0x08 :
; 126  : 		JGOtherJoin((LPSDHP_OTHERJOINMSG)aRecv);

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?JGOtherJoin@@YAXPAUSDHP_OTHERJOINMSG@@@Z ; JGOtherJoin
  00078	83 c4 04	 add	 esp, 4

; 127  : 		break;

  0007b	eb 7c		 jmp	 SHORT $LN1@SProtocolC
$LN9@SProtocolC:

; 128  : 	case 0x09 :	// 튕처리
; 129  : 		GJPUserDisconnectRecv((LPSDHP_BILLKILLUSER)aRecv);

  0007d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?GJPUserDisconnectRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z ; GJPUserDisconnectRecv
  00086	83 c4 04	 add	 esp, 4

; 130  : 		break;

  00089	eb 6e		 jmp	 SHORT $LN1@SProtocolC
$LN10@SProtocolC:

; 131  : 	case 0x20 :
; 132  : 		JGPExitCodeRecv((LPSDHP_EXITMSG)aRecv);

  0008b	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?JGPExitCodeRecv@@YAXPAUSDHP_EXITMSG@@@Z ; JGPExitCodeRecv
  00094	83 c4 04	 add	 esp, 4

; 133  : 		break;

  00097	eb 60		 jmp	 SHORT $LN1@SProtocolC
$LN11@SProtocolC:

; 134  : 	case 0x60 :
; 135  : 		JGPEventStart((LPSDHP_EVENTSTART)aRecv);

  00099	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?JGPEventStart@@YAXPAUSDHP_EVENTSTART@@@Z ; JGPEventStart
  000a2	83 c4 04	 add	 esp, 4

; 136  : 		break;

  000a5	eb 52		 jmp	 SHORT $LN1@SProtocolC
$LN12@SProtocolC:

; 137  : 	case 0x61 :
; 138  : 		JGPEventControl((LPSDHP_EVENTCONTROL)aRecv);

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?JGPEventControl@@YAXPAUSDHP_EVENTCONTROL@@@Z ; JGPEventControl
  000b0	83 c4 04	 add	 esp, 4

; 139  : 		break;

  000b3	eb 44		 jmp	 SHORT $LN1@SProtocolC
$LN13@SProtocolC:

; 140  : 	case 0x62 :
; 141  : 		JGPOptionControl((LPSDHP_OPTIONCONTROL)aRecv);

  000b5	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?JGPOptionControl@@YAXPAUSDHP_OPTIONCONTROL@@@Z ; JGPOptionControl
  000be	83 c4 04	 add	 esp, 4

; 142  : 		break;

  000c1	eb 36		 jmp	 SHORT $LN1@SProtocolC
$LN14@SProtocolC:

; 143  : 
; 144  : #ifdef ADD_MANAGER_SENDMAIL
; 145  : 	case 0x63 :
; 146  : 		JGPSendMail((LPPMSG_JG_MEMO_SEND)aRecv);

  000c3	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ?JGPSendMail@@YAXPAUPMSG_JG_MEMO_SEND@@@Z ; JGPSendMail
  000cc	83 c4 04	 add	 esp, 4

; 147  : 		break;

  000cf	eb 28		 jmp	 SHORT $LN1@SProtocolC
$LN15@SProtocolC:

; 148  : #endif
; 149  : 	case 0x30 :
; 150  : 		LoveHeartEventRecv((LPSDHP_LOVEHEARTEVENT_RESULT)aRecv);

  000d1	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?LoveHeartEventRecv@@YAXPAUSDHP_LOVEHEARTEVENT_RESULT@@@Z ; LoveHeartEventRecv
  000da	83 c4 04	 add	 esp, 4

; 151  : 		break;

  000dd	eb 1a		 jmp	 SHORT $LN1@SProtocolC
$LN16@SProtocolC:

; 152  : 	case 0x40 :
; 153  : 		AllNoticeRecv((LPSDHP_NOTICE)aRecv);

  000df	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ?AllNoticeRecv@@YAXPAUSDHP_NOTICE@@@Z ; AllNoticeRecv
  000e8	83 c4 04	 add	 esp, 4

; 154  : 		break;

  000eb	eb 0c		 jmp	 SHORT $LN1@SProtocolC
$LN17@SProtocolC:

; 155  : 	case 0x41 :
; 156  : 		UserNoticeRecv((LPSDHP_USER_NOTICE)aRecv);

  000ed	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?UserNoticeRecv@@YAXPAUSDHP_USER_NOTICE@@@Z ; UserNoticeRecv
  000f6	83 c4 04	 add	 esp, 4
$LN1@SProtocolC:

; 157  : 		break;
; 158  : 
; 159  : #ifdef MAP_SERVER_WORK_20041030		// 서버 맵분할 관련 패킷 - 게임서버 <-> 인증서버
; 160  : 	case 0x7A :
; 161  : 		JGAnsMapSvrMove		((LPPMSG_ANS_MAPSVRMOVE)aRecv);
; 162  : 		break;
; 163  : 	case 0x7B :
; 164  : 		JGAnsMapSvrAuth		((LPPMSG_ANS_MAPSVRAUTH)aRecv);
; 165  : 		break;
; 166  : #endif
; 167  : 
; 168  : #ifdef ADD_HACKING_TOOL_BLOCK_20090311
; 169  : 		// 해킹 툴 사용자 맵이동 차단에 대한 프로토콜
; 170  : 	case 0x8A:				// 인증서버의 해킹툴 통계 요청
; 171  : 		JGRequestAntiHackStatistics( (LPPMSG_HACKTOOL_USE_STATISTICS)aRecv );
; 172  : 		break;
; 173  : 	case 0x8B:				// 인증서버의 해킹툴 맵이동 차단 요청
; 174  : 		JGRequestHacktoolMapMoveBlock( (LPPMSG_RESERVE_HACKTOOL_MAP_MOVE)aRecv );
; 175  : 		break;
; 176  : #endif // ADD_HACKING_TOOL_BLOCK_20090311
; 177  : 	}
; 178  : }

  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
$LN20@SProtocolC:
  00100	00 00 00 00	 DD	 $LN4@SProtocolC
  00104	00 00 00 00	 DD	 $LN5@SProtocolC
  00108	00 00 00 00	 DD	 $LN6@SProtocolC
  0010c	00 00 00 00	 DD	 $LN7@SProtocolC
  00110	00 00 00 00	 DD	 $LN8@SProtocolC
  00114	00 00 00 00	 DD	 $LN9@SProtocolC
  00118	00 00 00 00	 DD	 $LN10@SProtocolC
  0011c	00 00 00 00	 DD	 $LN15@SProtocolC
  00120	00 00 00 00	 DD	 $LN16@SProtocolC
  00124	00 00 00 00	 DD	 $LN17@SProtocolC
  00128	00 00 00 00	 DD	 $LN11@SProtocolC
  0012c	00 00 00 00	 DD	 $LN12@SProtocolC
  00130	00 00 00 00	 DD	 $LN13@SProtocolC
  00134	00 00 00 00	 DD	 $LN14@SProtocolC
  00138	00 00 00 00	 DD	 $LN1@SProtocolC
$LN19@SProtocolC:
  0013c	00		 DB	 0
  0013d	01		 DB	 1
  0013e	0e		 DB	 14			; 0000000eH
  0013f	0e		 DB	 14			; 0000000eH
  00140	0e		 DB	 14			; 0000000eH
  00141	0e		 DB	 14			; 0000000eH
  00142	02		 DB	 2
  00143	03		 DB	 3
  00144	04		 DB	 4
  00145	05		 DB	 5
  00146	0e		 DB	 14			; 0000000eH
  00147	0e		 DB	 14			; 0000000eH
  00148	0e		 DB	 14			; 0000000eH
  00149	0e		 DB	 14			; 0000000eH
  0014a	0e		 DB	 14			; 0000000eH
  0014b	0e		 DB	 14			; 0000000eH
  0014c	0e		 DB	 14			; 0000000eH
  0014d	0e		 DB	 14			; 0000000eH
  0014e	0e		 DB	 14			; 0000000eH
  0014f	0e		 DB	 14			; 0000000eH
  00150	0e		 DB	 14			; 0000000eH
  00151	0e		 DB	 14			; 0000000eH
  00152	0e		 DB	 14			; 0000000eH
  00153	0e		 DB	 14			; 0000000eH
  00154	0e		 DB	 14			; 0000000eH
  00155	0e		 DB	 14			; 0000000eH
  00156	0e		 DB	 14			; 0000000eH
  00157	0e		 DB	 14			; 0000000eH
  00158	0e		 DB	 14			; 0000000eH
  00159	0e		 DB	 14			; 0000000eH
  0015a	0e		 DB	 14			; 0000000eH
  0015b	0e		 DB	 14			; 0000000eH
  0015c	06		 DB	 6
  0015d	0e		 DB	 14			; 0000000eH
  0015e	0e		 DB	 14			; 0000000eH
  0015f	0e		 DB	 14			; 0000000eH
  00160	0e		 DB	 14			; 0000000eH
  00161	0e		 DB	 14			; 0000000eH
  00162	0e		 DB	 14			; 0000000eH
  00163	0e		 DB	 14			; 0000000eH
  00164	0e		 DB	 14			; 0000000eH
  00165	0e		 DB	 14			; 0000000eH
  00166	0e		 DB	 14			; 0000000eH
  00167	0e		 DB	 14			; 0000000eH
  00168	0e		 DB	 14			; 0000000eH
  00169	0e		 DB	 14			; 0000000eH
  0016a	0e		 DB	 14			; 0000000eH
  0016b	0e		 DB	 14			; 0000000eH
  0016c	07		 DB	 7
  0016d	0e		 DB	 14			; 0000000eH
  0016e	0e		 DB	 14			; 0000000eH
  0016f	0e		 DB	 14			; 0000000eH
  00170	0e		 DB	 14			; 0000000eH
  00171	0e		 DB	 14			; 0000000eH
  00172	0e		 DB	 14			; 0000000eH
  00173	0e		 DB	 14			; 0000000eH
  00174	0e		 DB	 14			; 0000000eH
  00175	0e		 DB	 14			; 0000000eH
  00176	0e		 DB	 14			; 0000000eH
  00177	0e		 DB	 14			; 0000000eH
  00178	0e		 DB	 14			; 0000000eH
  00179	0e		 DB	 14			; 0000000eH
  0017a	0e		 DB	 14			; 0000000eH
  0017b	0e		 DB	 14			; 0000000eH
  0017c	08		 DB	 8
  0017d	09		 DB	 9
  0017e	0e		 DB	 14			; 0000000eH
  0017f	0e		 DB	 14			; 0000000eH
  00180	0e		 DB	 14			; 0000000eH
  00181	0e		 DB	 14			; 0000000eH
  00182	0e		 DB	 14			; 0000000eH
  00183	0e		 DB	 14			; 0000000eH
  00184	0e		 DB	 14			; 0000000eH
  00185	0e		 DB	 14			; 0000000eH
  00186	0e		 DB	 14			; 0000000eH
  00187	0e		 DB	 14			; 0000000eH
  00188	0e		 DB	 14			; 0000000eH
  00189	0e		 DB	 14			; 0000000eH
  0018a	0e		 DB	 14			; 0000000eH
  0018b	0e		 DB	 14			; 0000000eH
  0018c	0e		 DB	 14			; 0000000eH
  0018d	0e		 DB	 14			; 0000000eH
  0018e	0e		 DB	 14			; 0000000eH
  0018f	0e		 DB	 14			; 0000000eH
  00190	0e		 DB	 14			; 0000000eH
  00191	0e		 DB	 14			; 0000000eH
  00192	0e		 DB	 14			; 0000000eH
  00193	0e		 DB	 14			; 0000000eH
  00194	0e		 DB	 14			; 0000000eH
  00195	0e		 DB	 14			; 0000000eH
  00196	0e		 DB	 14			; 0000000eH
  00197	0e		 DB	 14			; 0000000eH
  00198	0e		 DB	 14			; 0000000eH
  00199	0e		 DB	 14			; 0000000eH
  0019a	0e		 DB	 14			; 0000000eH
  0019b	0e		 DB	 14			; 0000000eH
  0019c	0a		 DB	 10			; 0000000aH
  0019d	0b		 DB	 11			; 0000000bH
  0019e	0c		 DB	 12			; 0000000cH
  0019f	0d		 DB	 13			; 0000000dH
?SProtocolCore@@YAXEPAEH@Z ENDP				; SProtocolCore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?JGPSendMail@@YAXPAUPMSG_JG_MEMO_SEND@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?JGPSendMail@@YAXPAUPMSG_JG_MEMO_SEND@@@Z PROC		; JGPSendMail, COMDAT

; 1558 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1559 : 	MngFriendMemoSend(lpMsg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?MngFriendMemoSend@@YAXPAUPMSG_JG_MEMO_SEND@@@Z ; MngFriendMemoSend
  00012	83 c4 04	 add	 esp, 4

; 1560 : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?JGPSendMail@@YAXPAUPMSG_JG_MEMO_SEND@@@Z ENDP		; JGPSendMail
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?UserNoticeRecv@@YAXPAUSDHP_USER_NOTICE@@@Z
_TEXT	SEGMENT
$T1 = -428						; size = 4
$T2 = -424						; size = 4
_pNotice$3 = -356					; size = 272
_n$4 = -84						; size = 4
_szId$ = -80						; size = 11
_szNotice$ = -68					; size = 61
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?UserNoticeRecv@@YAXPAUSDHP_USER_NOTICE@@@Z PROC	; UserNoticeRecv, COMDAT

; 1039 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1040 : 	char szNotice[61];
; 1041 : 	char szId[MAX_IDSTRING+1];
; 1042 : 
; 1043 : 	szNotice[60] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 3c	 imul	 ecx, eax, 60
  0001e	89 8d 58 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00024	83 bd 58 fe ff
	ff 3d		 cmp	 DWORD PTR $T2[ebp], 61	; 0000003dH
  0002b	73 02		 jae	 SHORT $LN12@UserNotice
  0002d	eb 05		 jmp	 SHORT $LN13@UserNotice
$LN12@UserNotice:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN13@UserNotice:
  00034	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  0003a	c6 44 15 bc 00	 mov	 BYTE PTR _szNotice$[ebp+edx], 0

; 1044 : 	szId[MAX_IDSTRING] = '\0';

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	6b c8 0a	 imul	 ecx, eax, 10
  00047	89 8d 54 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0004d	83 bd 54 fe ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00054	73 02		 jae	 SHORT $LN14@UserNotice
  00056	eb 05		 jmp	 SHORT $LN15@UserNotice
$LN14@UserNotice:
  00058	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN15@UserNotice:
  0005d	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00063	c6 44 15 b0 00	 mov	 BYTE PTR _szId$[ebp+edx], 0

; 1045 : 	
; 1046 : 	memcpy(szNotice, lpMsg->Notice, 60);

  00068	6a 3c		 push	 60			; 0000003cH
  0006a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0006d	83 c0 0d	 add	 eax, 13			; 0000000dH
  00070	50		 push	 eax
  00071	8d 4d bc	 lea	 ecx, DWORD PTR _szNotice$[ebp]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _memcpy
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1047 : 	memcpy(szId, lpMsg->szId, MAX_IDSTRING);

  0007d	6a 0a		 push	 10			; 0000000aH
  0007f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00082	83 c0 03	 add	 eax, 3
  00085	50		 push	 eax
  00086	8d 4d b0	 lea	 ecx, DWORD PTR _szId$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 _memcpy
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1048 : 
; 1049 : #ifdef ADD_LOG_GM_TOOL_NOTICE_20051004
; 1050 : 	LogAddTD("[Mu Manager][Notice Log][Type:USER] (%s) %s", szId, szNotice );

  00092	8d 45 bc	 lea	 eax, DWORD PTR _szNotice$[ebp]
  00095	50		 push	 eax
  00096	8d 4d b0	 lea	 ecx, DWORD PTR _szId$[ebp]
  00099	51		 push	 ecx
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@EFINMDLC@?$FLMu?5Manager?$FN?$FLNotice?5Log?$FN?$FLType?3U@
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1051 : #endif
; 1052 : 
; 1053 : 	if( strlen( szNotice) > 1 )

  000a8	8d 45 bc	 lea	 eax, DWORD PTR _szNotice$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 _strlen
  000b1	83 c4 04	 add	 esp, 4
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	0f 86 25 01 00
	00		 jbe	 $LN11@UserNotice

; 1054 : 	{
; 1055 : 		if( strlen( szId ) > 1 )

  000bd	8d 45 b0	 lea	 eax, DWORD PTR _szId$[ebp]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 _strlen
  000c6	83 c4 04	 add	 esp, 4
  000c9	83 f8 01	 cmp	 eax, 1
  000cc	0f 86 10 01 00
	00		 jbe	 $LN11@UserNotice

; 1056 : 		{
; 1057 : 			for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  000d2	c7 45 ac 00 19
	00 00		 mov	 DWORD PTR _n$4[ebp], 6400 ; 00001900H
  000d9	eb 09		 jmp	 SHORT $LN4@UserNotice
$LN2@UserNotice:
  000db	8b 45 ac	 mov	 eax, DWORD PTR _n$4[ebp]
  000de	83 c0 01	 add	 eax, 1
  000e1	89 45 ac	 mov	 DWORD PTR _n$4[ebp], eax
$LN4@UserNotice:
  000e4	81 7d ac e8 1c
	00 00		 cmp	 DWORD PTR _n$4[ebp], 7400 ; 00001ce8H
  000eb	0f 8d f1 00 00
	00		 jge	 $LN11@UserNotice

; 1058 : 			{
; 1059 : 				if( gObj[n].Connected >= CSS_LOGINOK )

  000f1	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _n$4[ebp], 7072
  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fe	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00103	0f 8c d4 00 00
	00		 jl	 $LN7@UserNotice

; 1060 : 				{					
; 1061 : 					if( gObj[n].AccountID[0] == szId[0] )

  00109	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _n$4[ebp], 7072
  00110	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00116	b9 01 00 00 00	 mov	 ecx, 1
  0011b	6b d1 00	 imul	 edx, ecx, 0
  0011e	0f be 44 10 68	 movsx	 eax, BYTE PTR [eax+edx+104]
  00123	b9 01 00 00 00	 mov	 ecx, 1
  00128	6b d1 00	 imul	 edx, ecx, 0
  0012b	0f be 4c 15 b0	 movsx	 ecx, BYTE PTR _szId$[ebp+edx]
  00130	3b c1		 cmp	 eax, ecx
  00132	0f 85 a5 00 00
	00		 jne	 $LN7@UserNotice

; 1062 : 					{
; 1063 : 						if( gObj[n].AccountID[1] == szId[1] )

  00138	69 45 ac a0 1b
	00 00		 imul	 eax, DWORD PTR _n$4[ebp], 7072
  0013f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00145	b9 01 00 00 00	 mov	 ecx, 1
  0014a	c1 e1 00	 shl	 ecx, 0
  0014d	0f be 54 08 68	 movsx	 edx, BYTE PTR [eax+ecx+104]
  00152	b8 01 00 00 00	 mov	 eax, 1
  00157	c1 e0 00	 shl	 eax, 0
  0015a	0f be 4c 05 b0	 movsx	 ecx, BYTE PTR _szId$[ebp+eax]
  0015f	3b d1		 cmp	 edx, ecx
  00161	75 7a		 jne	 SHORT $LN7@UserNotice

; 1064 : 						{
; 1065 : 							if( strcmp( gObj[n].AccountID, szId) == 0 )

  00163	8d 45 b0	 lea	 eax, DWORD PTR _szId$[ebp]
  00166	50		 push	 eax
  00167	69 4d ac a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$4[ebp], 7072
  0016e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00174	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 _strcmp
  0017e	83 c4 08	 add	 esp, 8
  00181	85 c0		 test	 eax, eax
  00183	75 58		 jne	 SHORT $LN7@UserNotice

; 1066 : 							{
; 1067 : 
; 1068 : 						#ifdef MODIFY_NOTICE_20040325
; 1069 : 								PMSG_NOTICE	pNotice;
; 1070 : 								TNotice::MakeNoticeMsg( &pNotice, 0, szNotice );

  00185	8d 45 bc	 lea	 eax, DWORD PTR _szNotice$[ebp]
  00188	50		 push	 eax
  00189	6a 00		 push	 0
  0018b	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$3[ebp]
  00191	51		 push	 ecx
  00192	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00197	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1071 : 								TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);

  0019a	6a 14		 push	 20			; 00000014H
  0019c	6a 00		 push	 0
  0019e	6a 01		 push	 1
  001a0	6a 51		 push	 81			; 00000051H
  001a2	6a 51		 push	 81			; 00000051H
  001a4	68 fe 00 00 00	 push	 254			; 000000feH
  001a9	68 ff 00 00 00	 push	 255			; 000000ffH
  001ae	e8 00 00 00 00	 call	 ?_ARGB@@YAKEEEE@Z	; _ARGB
  001b3	83 c4 10	 add	 esp, 16			; 00000010H
  001b6	50		 push	 eax
  001b7	6a 0a		 push	 10			; 0000000aH
  001b9	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty
  001c5	83 c4 18	 add	 esp, 24			; 00000018H

; 1072 : 								TNotice::SendNoticeToUser( n, &pNotice );

  001c8	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  001ce	50		 push	 eax
  001cf	8b 4d ac	 mov	 ecx, DWORD PTR _n$4[ebp]
  001d2	51		 push	 ecx
  001d3	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser
  001d8	83 c4 08	 add	 esp, 8

; 1073 : 						#else
; 1074 : 								GCServerMsgStringSend(szNotice, n, 0);
; 1075 : 						#endif
; 1076 : 								
; 1077 : 								return;

  001db	eb 05		 jmp	 SHORT $LN11@UserNotice
$LN7@UserNotice:

; 1078 : 							}
; 1079 : 						}
; 1080 : 					}				
; 1081 : 				}
; 1082 : 			}

  001dd	e9 f9 fe ff ff	 jmp	 $LN2@UserNotice
$LN11@UserNotice:

; 1083 : 		}
; 1084 : 	}
; 1085 : }

  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e8	33 cd		 xor	 ecx, ebp
  001ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
?UserNoticeRecv@@YAXPAUSDHP_USER_NOTICE@@@Z ENDP	; UserNoticeRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?AllNoticeRecv@@YAXPAUSDHP_NOTICE@@@Z
_TEXT	SEGMENT
$T1 = -136						; size = 4
_szNotice$ = -68					; size = 61
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?AllNoticeRecv@@YAXPAUSDHP_NOTICE@@@Z PROC		; AllNoticeRecv, COMDAT

; 1008 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1009 : 	char szNotice[61];
; 1010 : 	szNotice[60] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 3c	 imul	 ecx, eax, 60
  0001e	89 8d 78 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 78 ff ff
	ff 3d		 cmp	 DWORD PTR $T1[ebp], 61	; 0000003dH
  0002b	73 02		 jae	 SHORT $LN4@AllNoticeR
  0002d	eb 05		 jmp	 SHORT $LN5@AllNoticeR
$LN4@AllNoticeR:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN5@AllNoticeR:
  00034	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 44 15 bc 00	 mov	 BYTE PTR _szNotice$[ebp+edx], 0

; 1011 : 	
; 1012 : 	memcpy(szNotice, lpMsg->Notice, 60);

  0003f	6a 3c		 push	 60			; 0000003cH
  00041	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00044	83 c0 03	 add	 eax, 3
  00047	50		 push	 eax
  00048	8d 4d bc	 lea	 ecx, DWORD PTR _szNotice$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _memcpy
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1013 : 	
; 1014 : #ifdef ADD_LOG_GM_TOOL_NOTICE_20051004
; 1015 : 	LogAddTD("[Mu Manager][Notice Log][Type:ALL] %s", szNotice );

  00054	8d 45 bc	 lea	 eax, DWORD PTR _szNotice$[ebp]
  00057	50		 push	 eax
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EHIHJKDO@?$FLMu?5Manager?$FN?$FLNotice?5Log?$FN?$FLType?3A@
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00063	83 c4 08	 add	 esp, 8

; 1016 : #endif
; 1017 : 
; 1018 : 	if( strlen( szNotice) > 1 )

  00066	8d 45 bc	 lea	 eax, DWORD PTR _szNotice$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _strlen
  0006f	83 c4 04	 add	 esp, 4
  00072	83 f8 01	 cmp	 eax, 1
  00075	76 0c		 jbe	 SHORT $LN3@AllNoticeR

; 1019 : 	{
; 1020 : #ifdef FOR_JAPAN	// 일본은 뮤매니저 전체공지를 기존 방식대로 중앙에 보여준다.
; 1021 : 		AllSendServerMsg(szNotice);
; 1022 : 		return;
; 1023 : #endif
; 1024 : 
; 1025 : // 20041116 기존 방식대로 중앙에 보여준다.
; 1026 : //#ifdef MODIFY_NOTICE_20040325
; 1027 : //		PMSG_NOTICE	pNotice;
; 1028 : //		TNotice::MakeNoticeMsg( &pNotice, 0, szNotice );
; 1029 : //		TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1030 : //		TNotice::SendNoticeToAllUser( &pNotice );
; 1031 : //#else
; 1032 : 		AllSendServerMsg(szNotice);

  00077	8d 45 bc	 lea	 eax, DWORD PTR _szNotice$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00080	83 c4 04	 add	 esp, 4
$LN3@AllNoticeR:

; 1033 : //#endif
; 1034 : 	}
; 1035 : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?AllNoticeRecv@@YAXPAUSDHP_NOTICE@@@Z ENDP		; AllNoticeRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?LoveHeartEventRecv@@YAXPAUSDHP_LOVEHEARTEVENT_RESULT@@@Z
_TEXT	SEGMENT
tv74 = -352						; size = 4
$T1 = -348						; size = 4
_n$2 = -280						; size = 4
_Msg$ = -276						; size = 256
_number$ = -20						; size = 4
_szName$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?LoveHeartEventRecv@@YAXPAUSDHP_LOVEHEARTEVENT_RESULT@@@Z PROC ; LoveHeartEventRecv, COMDAT

; 951  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 952  : 	char szName[MAX_IDSTRING+1];
; 953  : 	int  number;
; 954  : 	char Msg[256];
; 955  : 
; 956  : 	szName[MAX_IDSTRING] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 0a	 imul	 ecx, eax, 10
  0001e	89 8d a4 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd a4 fe ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  0002b	73 02		 jae	 SHORT $LN14@LoveHeartE
  0002d	eb 05		 jmp	 SHORT $LN15@LoveHeartE
$LN14@LoveHeartE:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN15@LoveHeartE:
  00034	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 44 15 f0 00	 mov	 BYTE PTR _szName$[ebp+edx], 0

; 957  : 
; 958  : 	memcpy(szName, lpMsg->Name, MAX_IDSTRING);

  0003f	6a 0a		 push	 10			; 0000000aH
  00041	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00044	83 c0 04	 add	 eax, 4
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR _szName$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _memcpy
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 959  : 	number = lpMsg->Number;

  00054	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00057	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0005a	89 4d ec	 mov	 DWORD PTR _number$[ebp], ecx

; 960  : 
; 961  : 	//LogAdd("러브 팡팡 이벤트 결과 받음 %s %d %x", szName, number, lpMsg->Result);
; 962  : 	// 이벤트 결과 타입
; 963  : 	switch( lpMsg->Result	)

  0005d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00060	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00063	88 8d a0 fe ff
	ff		 mov	 BYTE PTR tv74[ebp], cl
  00069	80 bd a0 fe ff
	ff 00		 cmp	 BYTE PTR tv74[ebp], 0
  00070	74 12		 je	 SHORT $LN7@LoveHeartE
  00072	80 bd a0 fe ff
	ff 01		 cmp	 BYTE PTR tv74[ebp], 1
  00079	0f 84 4f 01 00
	00		 je	 $LN12@LoveHeartE
  0007f	e9 82 01 00 00	 jmp	 $LN13@LoveHeartE
$LN7@LoveHeartE:

; 964  : 	{
; 965  : 	case 0 :
; 966  : 		wsprintf(Msg, lMsg.Get(1104), number);

  00084	8b 45 ec	 mov	 eax, DWORD PTR _number$[ebp]
  00087	50		 push	 eax
  00088	68 50 04 00 00	 push	 1104			; 00000450H
  0008d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00098	50		 push	 eax
  00099	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _Msg$[ebp]
  0009f	51		 push	 ecx
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 967  : 		{
; 968  : 		for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  000a9	c7 85 e8 fe ff
	ff 00 19 00 00	 mov	 DWORD PTR _n$2[ebp], 6400 ; 00001900H
  000b3	eb 0f		 jmp	 SHORT $LN6@LoveHeartE
$LN4@LoveHeartE:
  000b5	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _n$2[ebp]
  000bb	83 c0 01	 add	 eax, 1
  000be	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _n$2[ebp], eax
$LN6@LoveHeartE:
  000c4	81 bd e8 fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _n$2[ebp], 7400 ; 00001ce8H
  000ce	0f 8d f8 00 00
	00		 jge	 $LN5@LoveHeartE

; 969  : 		{
; 970  : 			if( gObj[n].Connected >= CSS_LOGINOK )

  000d4	69 85 e8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 7072
  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e4	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  000e9	0f 8c d8 00 00
	00		 jl	 $LN8@LoveHeartE

; 971  : 			{				
; 972  : 				if( gObj[n].Name[0] == szName[0] )

  000ef	69 85 e8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 7072
  000f9	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ff	b9 01 00 00 00	 mov	 ecx, 1
  00104	6b d1 00	 imul	 edx, ecx, 0
  00107	0f be 44 10 73	 movsx	 eax, BYTE PTR [eax+edx+115]
  0010c	b9 01 00 00 00	 mov	 ecx, 1
  00111	6b d1 00	 imul	 edx, ecx, 0
  00114	0f be 4c 15 f0	 movsx	 ecx, BYTE PTR _szName$[ebp+edx]
  00119	3b c1		 cmp	 eax, ecx
  0011b	0f 85 a6 00 00
	00		 jne	 $LN8@LoveHeartE

; 973  : 				{
; 974  : 					if( gObj[n].Name[1] == szName[1] )

  00121	69 85 e8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$2[ebp], 7072
  0012b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00131	b9 01 00 00 00	 mov	 ecx, 1
  00136	c1 e1 00	 shl	 ecx, 0
  00139	0f be 54 08 73	 movsx	 edx, BYTE PTR [eax+ecx+115]
  0013e	b8 01 00 00 00	 mov	 eax, 1
  00143	c1 e0 00	 shl	 eax, 0
  00146	0f be 4c 05 f0	 movsx	 ecx, BYTE PTR _szName$[ebp+eax]
  0014b	3b d1		 cmp	 edx, ecx
  0014d	75 78		 jne	 SHORT $LN8@LoveHeartE

; 975  : 					{
; 976  : 						if( strcmp( gObj[n].Name,szName) == 0 )

  0014f	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00152	50		 push	 eax
  00153	69 8d e8 fe ff
	ff a0 1b 00 00	 imul	 ecx, DWORD PTR _n$2[ebp], 7072
  0015d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00163	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _strcmp
  0016d	83 c4 08	 add	 esp, 8
  00170	85 c0		 test	 eax, eax
  00172	75 53		 jne	 SHORT $LN8@LoveHeartE

; 977  : 						{
; 978  : 							GCServerMsgStringSend(Msg, n, 1);

  00174	6a 01		 push	 1
  00176	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _n$2[ebp]
  0017c	50		 push	 eax
  0017d	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _Msg$[ebp]
  00183	51		 push	 ecx
  00184	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00189	83 c4 0c	 add	 esp, 12			; 0000000cH

; 979  : 							wsprintf(Msg, lMsg.Get(1105));

  0018c	68 51 04 00 00	 push	 1105			; 00000451H
  00191	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0019c	50		 push	 eax
  0019d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _Msg$[ebp]
  001a3	50		 push	 eax
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001aa	83 c4 08	 add	 esp, 8

; 980  : 							GCServerMsgStringSend(Msg, n, 1);

  001ad	6a 01		 push	 1
  001af	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _n$2[ebp]
  001b5	50		 push	 eax
  001b6	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _Msg$[ebp]
  001bc	51		 push	 ecx
  001bd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 981  : 							return;

  001c5	eb 3f		 jmp	 SHORT $LN13@LoveHeartE
$LN8@LoveHeartE:

; 982  : 						}
; 983  : 					}
; 984  : 				}			
; 985  : 			}
; 986  : 		}

  001c7	e9 e9 fe ff ff	 jmp	 $LN4@LoveHeartE
$LN5@LoveHeartE:

; 987  : 		}
; 988  : 		break;

  001cc	eb 38		 jmp	 SHORT $LN13@LoveHeartE
$LN12@LoveHeartE:

; 989  : 	case 1 :
; 990  : 		wsprintf(Msg, lMsg.Get(1106), szName, number);

  001ce	8b 45 ec	 mov	 eax, DWORD PTR _number$[ebp]
  001d1	50		 push	 eax
  001d2	8d 4d f0	 lea	 ecx, DWORD PTR _szName$[ebp]
  001d5	51		 push	 ecx
  001d6	68 52 04 00 00	 push	 1106			; 00000452H
  001db	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001e6	50		 push	 eax
  001e7	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _Msg$[ebp]
  001ed	52		 push	 edx
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001f4	83 c4 10	 add	 esp, 16			; 00000010H

; 991  : 		AllSendServerMsg(Msg);

  001f7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _Msg$[ebp]
  001fd	50		 push	 eax
  001fe	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00203	83 c4 04	 add	 esp, 4
$LN13@LoveHeartE:

; 992  : 		break;
; 993  : 	}
; 994  : }

  00206	5f		 pop	 edi
  00207	5e		 pop	 esi
  00208	5b		 pop	 ebx
  00209	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020c	33 cd		 xor	 ecx, ebp
  0020e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00213	8b e5		 mov	 esp, ebp
  00215	5d		 pop	 ebp
  00216	c3		 ret	 0
?LoveHeartEventRecv@@YAXPAUSDHP_LOVEHEARTEVENT_RESULT@@@Z ENDP ; LoveHeartEventRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?JGPExitCodeRecv@@YAXPAUSDHP_EXITMSG@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?JGPExitCodeRecv@@YAXPAUSDHP_EXITMSG@@@Z PROC		; JGPExitCodeRecv, COMDAT

; 819  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 820  : 	if( lpMsg->ExitCode[0] == 'F' &&
; 821  : 		lpMsg->ExitCode[1] == 'F' &&

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00014	0f b6 44 0a 03	 movzx	 eax, BYTE PTR [edx+ecx+3]
  00019	83 f8 46	 cmp	 eax, 70			; 00000046H
  0001c	75 41		 jne	 SHORT $LN1@JGPExitCod
  0001e	b8 01 00 00 00	 mov	 eax, 1
  00023	c1 e0 00	 shl	 eax, 0
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00029	0f b6 54 01 03	 movzx	 edx, BYTE PTR [ecx+eax+3]
  0002e	83 fa 46	 cmp	 edx, 70			; 00000046H
  00031	75 2c		 jne	 SHORT $LN1@JGPExitCod
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	d1 e0		 shl	 eax, 1
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0003d	0f b6 54 01 03	 movzx	 edx, BYTE PTR [ecx+eax+3]
  00042	83 fa 58	 cmp	 edx, 88			; 00000058H
  00045	75 18		 jne	 SHORT $LN1@JGPExitCod

; 822  : 		lpMsg->ExitCode[2] == 'X' )
; 823  : 	{
; 824  : 		SendMessage(ghWnd, WM_COMMAND, ID_MENU_THREECLOSE, NULL);

  00047	6a 00		 push	 0
  00049	68 12 80 00 00	 push	 32786			; 00008012H
  0004e	68 11 01 00 00	 push	 273			; 00000111H
  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00058	50		 push	 eax
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN1@JGPExitCod:

; 825  : 	}
; 826  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?JGPExitCodeRecv@@YAXPAUSDHP_EXITMSG@@@Z ENDP		; JGPExitCodeRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?JGOtherJoin@@YAXPAUSDHP_OTHERJOINMSG@@@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
_n$2 = -20						; size = 4
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGOtherJoin@@YAXPAUSDHP_OTHERJOINMSG@@@Z PROC		; JGOtherJoin, COMDAT

; 771  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 772  : 	char szId[MAX_IDSTRING+1];
; 773  : 
; 774  : 	szId[MAX_IDSTRING] = '\0';

  00013	b8 01 00 00 00	 mov	 eax, 1
  00018	6b c8 0a	 imul	 ecx, eax, 10
  0001b	89 4d a8	 mov	 DWORD PTR $T1[ebp], ecx
  0001e	83 7d a8 0b	 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00022	73 02		 jae	 SHORT $LN10@JGOtherJoi
  00024	eb 05		 jmp	 SHORT $LN11@JGOtherJoi
$LN10@JGOtherJoi:
  00026	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN11@JGOtherJoi:
  0002b	8b 55 a8	 mov	 edx, DWORD PTR $T1[ebp]
  0002e	c6 44 15 f0 00	 mov	 BYTE PTR _szId$[ebp+edx], 0

; 775  : 	memcpy(szId, lpMsg->AccountID, MAX_IDSTRING);

  00033	6a 0a		 push	 10			; 0000000aH
  00035	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00038	83 c0 03	 add	 eax, 3
  0003b	50		 push	 eax
  0003c	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _memcpy
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 776  : 	
; 777  : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00048	c7 45 ec 00 19
	00 00		 mov	 DWORD PTR _n$2[ebp], 6400 ; 00001900H
  0004f	eb 09		 jmp	 SHORT $LN4@JGOtherJoi
$LN2@JGOtherJoi:
  00051	8b 45 ec	 mov	 eax, DWORD PTR _n$2[ebp]
  00054	83 c0 01	 add	 eax, 1
  00057	89 45 ec	 mov	 DWORD PTR _n$2[ebp], eax
$LN4@JGOtherJoi:
  0005a	81 7d ec e8 1c
	00 00		 cmp	 DWORD PTR _n$2[ebp], 7400 ; 00001ce8H
  00061	0f 8d b6 00 00
	00		 jge	 $LN9@JGOtherJoi

; 778  : 	{
; 779  : 		if( gObj[n].Connected >= CSS_LOGINOK )

  00067	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00074	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00079	0f 8c 99 00 00
	00		 jl	 $LN5@JGOtherJoi

; 780  : 		{
; 781  : 			if( gObj[n].AccountID[0] == szId[0] )

  0007f	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  00086	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	6b d1 00	 imul	 edx, ecx, 0
  00094	0f be 44 10 68	 movsx	 eax, BYTE PTR [eax+edx+104]
  00099	b9 01 00 00 00	 mov	 ecx, 1
  0009e	6b d1 00	 imul	 edx, ecx, 0
  000a1	0f be 4c 15 f0	 movsx	 ecx, BYTE PTR _szId$[ebp+edx]
  000a6	3b c1		 cmp	 eax, ecx
  000a8	75 6e		 jne	 SHORT $LN5@JGOtherJoi

; 782  : 			{
; 783  : 				if( gObj[n].AccountID[1] == szId[1] )

  000aa	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  000b1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b7	b9 01 00 00 00	 mov	 ecx, 1
  000bc	c1 e1 00	 shl	 ecx, 0
  000bf	0f be 54 08 68	 movsx	 edx, BYTE PTR [eax+ecx+104]
  000c4	b8 01 00 00 00	 mov	 eax, 1
  000c9	c1 e0 00	 shl	 eax, 0
  000cc	0f be 4c 05 f0	 movsx	 ecx, BYTE PTR _szId$[ebp+eax]
  000d1	3b d1		 cmp	 edx, ecx
  000d3	75 43		 jne	 SHORT $LN5@JGOtherJoi

; 784  : 				{
; 785  : 					if( strcmp( gObj[n].AccountID,szId) == 0 )

  000d5	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  000d8	50		 push	 eax
  000d9	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$2[ebp], 7072
  000e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e6	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 _strcmp
  000f0	83 c4 08	 add	 esp, 8
  000f3	85 c0		 test	 eax, eax
  000f5	75 21		 jne	 SHORT $LN5@JGOtherJoi

; 786  : 					{
; 787  : 						GCServerMsgStringSend(lMsg.Get(1131), n, 1);

  000f7	6a 01		 push	 1
  000f9	8b 45 ec	 mov	 eax, DWORD PTR _n$2[ebp]
  000fc	50		 push	 eax
  000fd	68 6b 04 00 00	 push	 1131			; 0000046bH
  00102	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 						// 다른사용자가 접속을 시도하고 있습니다
; 789  : 						return;

  00116	eb 05		 jmp	 SHORT $LN9@JGOtherJoi
$LN5@JGOtherJoi:

; 790  : 					}
; 791  : 				}
; 792  : 			}		
; 793  : 		}
; 794  : 	}

  00118	e9 34 ff ff ff	 jmp	 $LN2@JGOtherJoi
$LN9@JGOtherJoi:

; 795  : }

  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	33 cd		 xor	 ecx, ebp
  00125	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
?JGOtherJoin@@YAXPAUSDHP_OTHERJOINMSG@@@Z ENDP		; JGOtherJoin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?JGPOptionControl@@YAXPAUSDHP_OPTIONCONTROL@@@Z
_TEXT	SEGMENT
tv66 = -68						; size = 4
_lpMsg$ = 8						; size = 4
?JGPOptionControl@@YAXPAUSDHP_OPTIONCONTROL@@@Z PROC	; JGPOptionControl, COMDAT

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 891  : 	switch( lpMsg->Option )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00010	89 4d bc	 mov	 DWORD PTR tv66[ebp], ecx
  00013	83 7d bc 05	 cmp	 DWORD PTR tv66[ebp], 5
  00017	77 46		 ja	 SHORT $LN1@JGPOptionC
  00019	8b 55 bc	 mov	 edx, DWORD PTR tv66[ebp]
  0001c	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN11@JGPOptionC[edx*4]
$LN4@JGPOptionC:

; 892  : 	{
; 893  : 		case 0:
; 894  : 			{	// Option reLoad
; 895  : 				ReadCommonServerInfo();

  00023	e8 00 00 00 00	 call	 ?ReadCommonServerInfo@@YAXXZ ; ReadCommonServerInfo

; 896  : 			}
; 897  : 		break;

  00028	eb 35		 jmp	 SHORT $LN1@JGPOptionC
$LN5@JGPOptionC:

; 898  : 
; 899  : 		case 1:
; 900  : 			{	// Monster reLoad
; 901  : 				GameMonsterAllCloseAndReLoad();

  0002a	e8 00 00 00 00	 call	 ?GameMonsterAllCloseAndReLoad@@YAXXZ ; GameMonsterAllCloseAndReLoad

; 902  : 			}
; 903  : 		break;

  0002f	eb 2e		 jmp	 SHORT $LN1@JGPOptionC
$LN6@JGPOptionC:

; 904  : 
; 905  : 		case 2:
; 906  : 			{	// Shop reLoad
; 907  : 				ShopDataLoad();

  00031	e8 00 00 00 00	 call	 ?ShopDataLoad@@YAHXZ	; ShopDataLoad

; 908  : 			}
; 909  : 		break;

  00036	eb 27		 jmp	 SHORT $LN1@JGPOptionC
$LN7@JGPOptionC:

; 910  : 
; 911  : 		case 3:
; 912  : 			{	// All reLoad
; 913  : 				ReadCommonServerInfo();

  00038	e8 00 00 00 00	 call	 ?ReadCommonServerInfo@@YAXXZ ; ReadCommonServerInfo

; 914  : 				GameMonsterAllCloseAndReLoad();

  0003d	e8 00 00 00 00	 call	 ?GameMonsterAllCloseAndReLoad@@YAXXZ ; GameMonsterAllCloseAndReLoad

; 915  : 				ShopDataLoad();

  00042	e8 00 00 00 00	 call	 ?ShopDataLoad@@YAHXZ	; ShopDataLoad

; 916  : 			}
; 917  : 		break;

  00047	eb 16		 jmp	 SHORT $LN1@JGPOptionC
$LN8@JGPOptionC:

; 918  : 
; 919  : #ifdef ADD_OPTION_RELOAD_ITEM_TO_JOINSERVER
; 920  : 		case 4:
; 921  : 			{	// All Event Reload
; 922  : 				ReadEventInfo(MU_EVENT_ALL);

  00049	6a 00		 push	 0
  0004b	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  00050	83 c4 04	 add	 esp, 4

; 923  : 			}
; 924  : 		break;

  00053	eb 0a		 jmp	 SHORT $LN1@JGPOptionC
$LN9@JGPOptionC:

; 925  : 
; 926  : 		case 5:
; 927  : 			{	// All ETC Reload
; 928  : 				ReadGameEtcInfo(MU_ETC_ALL);				

  00055	6a 00		 push	 0
  00057	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  0005c	83 c4 04	 add	 esp, 4
$LN1@JGPOptionC:

; 929  : 			}
; 930  : 		break;
; 931  : #endif
; 932  : 	}
; 933  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	66 90		 npad	 2
$LN11@JGPOptionC:
  00068	00 00 00 00	 DD	 $LN4@JGPOptionC
  0006c	00 00 00 00	 DD	 $LN5@JGPOptionC
  00070	00 00 00 00	 DD	 $LN6@JGPOptionC
  00074	00 00 00 00	 DD	 $LN7@JGPOptionC
  00078	00 00 00 00	 DD	 $LN8@JGPOptionC
  0007c	00 00 00 00	 DD	 $LN9@JGPOptionC
?JGPOptionControl@@YAXPAUSDHP_OPTIONCONTROL@@@Z ENDP	; JGPOptionControl
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?JGPEventControl@@YAXPAUSDHP_EVENTCONTROL@@@Z
_TEXT	SEGMENT
tv66 = -68						; size = 4
_lpMsg$ = 8						; size = 4
?JGPEventControl@@YAXPAUSDHP_EVENTCONTROL@@@Z PROC	; JGPEventControl, COMDAT

; 843  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 844  : 	switch(lpMsg->Event)

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00010	89 4d bc	 mov	 DWORD PTR tv66[ebp], ecx
  00013	83 7d bc 04	 cmp	 DWORD PTR tv66[ebp], 4
  00017	77 7b		 ja	 SHORT $LN1@JGPEventCo
  00019	8b 55 bc	 mov	 edx, DWORD PTR tv66[ebp]
  0001c	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN13@JGPEventCo[edx*4]
$LN4@JGPEventCo:

; 845  : 	{
; 846  : 		case 0:
; 847  : 			{	// 드래곤 이벤트 
; 848  : 				if( lpMsg->Stat )

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00026	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 1f		 je	 SHORT $LN5@JGPEventCo

; 849  : 				{
; 850  : 					if( !DragonEvent->GetState() )

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00034	e8 00 00 00 00	 call	 ?GetState@CDragonEvent@@QAEEXZ ; CDragonEvent::GetState
  00039	0f b6 c0	 movzx	 eax, al
  0003c	85 c0		 test	 eax, eax
  0003e	75 0b		 jne	 SHORT $LN7@JGPEventCo

; 851  : 					{
; 852  : 						DragonEvent->Start();

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00046	e8 00 00 00 00	 call	 ?Start@CDragonEvent@@QAEXXZ ; CDragonEvent::Start
$LN7@JGPEventCo:

; 853  : 					}					
; 854  : 				}

  0004b	eb 0b		 jmp	 SHORT $LN6@JGPEventCo
$LN5@JGPEventCo:

; 855  : 				else
; 856  : 				{
; 857  : 					DragonEvent->End();

  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00053	e8 00 00 00 00	 call	 ?End@CDragonEvent@@QAEXXZ ; CDragonEvent::End
$LN6@JGPEventCo:

; 858  : 				}
; 859  : 			}
; 860  : 		break;

  00058	eb 3a		 jmp	 SHORT $LN1@JGPEventCo
$LN8@JGPEventCo:

; 861  : 
; 862  : 		case 1:
; 863  : 			{	// 성탄의 별 이벤트
; 864  : 				gXMasEvent = lpMsg->Stat;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0005d	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00061	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gXMasEvent@@3HA, ecx ; gXMasEvent

; 865  : 			}
; 866  : 		break;

  00067	eb 2b		 jmp	 SHORT $LN1@JGPEventCo
$LN9@JGPEventCo:

; 867  : 
; 868  : 		case 2:
; 869  : 			{	// 폭죽(마법주머니) 이벤트
; 870  : 				gFireCrackerEvent = lpMsg->Stat;

  00069	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0006c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00070	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gFireCrackerEvent@@3HA, ecx ; gFireCrackerEvent

; 871  : 			}
; 872  : 		break;

  00076	eb 1c		 jmp	 SHORT $LN1@JGPEventCo
$LN10@JGPEventCo:

; 873  : 
; 874  : 		case 3:
; 875  : 			{	// 사랑의 하트 이벤트
; 876  : 				gHeartOfLoveEvent = lpMsg->Stat;

  00078	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0007b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0007f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gHeartOfLoveEvent@@3HA, ecx ; gHeartOfLoveEvent

; 877  : 			}
; 878  : 		break;

  00085	eb 0d		 jmp	 SHORT $LN1@JGPEventCo
$LN11@JGPEventCo:

; 879  : 
; 880  : 		case 4:
; 881  : 			{	// 메달 이벤트
; 882  : 				gMedalEvent = lpMsg->Stat;

  00087	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0008e	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gMedalEvent@@3HA, ecx ; gMedalEvent
$LN1@JGPEventCo:

; 883  : 			}
; 884  : 		break;
; 885  : 	}
; 886  : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
  0009b	90		 npad	 1
$LN13@JGPEventCo:
  0009c	00 00 00 00	 DD	 $LN4@JGPEventCo
  000a0	00 00 00 00	 DD	 $LN8@JGPEventCo
  000a4	00 00 00 00	 DD	 $LN9@JGPEventCo
  000a8	00 00 00 00	 DD	 $LN10@JGPEventCo
  000ac	00 00 00 00	 DD	 $LN11@JGPEventCo
?JGPEventControl@@YAXPAUSDHP_EVENTCONTROL@@@Z ENDP	; JGPEventControl
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?JGPEventStart@@YAXPAUSDHP_EVENTSTART@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?JGPEventStart@@YAXPAUSDHP_EVENTSTART@@@Z PROC		; JGPEventStart, COMDAT

; 830  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 831  : 	if ( lpMsg->Event == 1 )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	75 2a		 jne	 SHORT $LN1@JGPEventSt

; 832  : 	{
; 833  : 		if( DragonEvent->GetState() )

  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  0001b	e8 00 00 00 00	 call	 ?GetState@CDragonEvent@@QAEEXZ ; CDragonEvent::GetState
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 0d		 je	 SHORT $LN3@JGPEventSt

; 834  : 		{
; 835  : 			DragonEvent->End();

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  0002d	e8 00 00 00 00	 call	 ?End@CDragonEvent@@QAEXXZ ; CDragonEvent::End

; 836  : 		}

  00032	eb 0b		 jmp	 SHORT $LN1@JGPEventSt
$LN3@JGPEventSt:

; 837  : 		else DragonEvent->Start();

  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  0003a	e8 00 00 00 00	 call	 ?Start@CDragonEvent@@QAEXXZ ; CDragonEvent::Start
$LN1@JGPEventSt:

; 838  : 	}
; 839  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?JGPEventStart@@YAXPAUSDHP_EVENTSTART@@@Z ENDP		; JGPEventStart
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?GJPUserDisconnectRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
_number$ = -20						; size = 4
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?GJPUserDisconnectRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z PROC ; GJPUserDisconnectRecv, COMDAT

; 799  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 800  : 	char szId[MAX_IDSTRING+1];
; 801  : 	int number;
; 802  : 	szId[MAX_IDSTRING] = '\0';

  00013	b8 01 00 00 00	 mov	 eax, 1
  00018	6b c8 0a	 imul	 ecx, eax, 10
  0001b	89 4d a8	 mov	 DWORD PTR $T1[ebp], ecx
  0001e	83 7d a8 0b	 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00022	73 02		 jae	 SHORT $LN4@GJPUserDis
  00024	eb 05		 jmp	 SHORT $LN5@GJPUserDis
$LN4@GJPUserDis:
  00026	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN5@GJPUserDis:
  0002b	8b 55 a8	 mov	 edx, DWORD PTR $T1[ebp]
  0002e	c6 44 15 f0 00	 mov	 BYTE PTR _szId$[ebp+edx], 0

; 803  : 
; 804  : 	memcpy(szId, lpMsg->Id, MAX_IDSTRING);

  00033	6a 0a		 push	 10			; 0000000aH
  00035	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00038	83 c0 03	 add	 eax, 3
  0003b	50		 push	 eax
  0003c	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _memcpy
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 805  : 	number = lpMsg->Number;

  00048	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004b	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  0004f	89 4d ec	 mov	 DWORD PTR _number$[ebp], ecx

; 806  : 
; 807  : 	if( gObjIsAccontConnect(number, szId) == FALSE )

  00052	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00055	50		 push	 eax
  00056	8b 4d ec	 mov	 ecx, DWORD PTR _number$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0005f	83 c4 08	 add	 esp, 8
  00062	85 c0		 test	 eax, eax
  00064	75 02		 jne	 SHORT $LN2@GJPUserDis

; 808  : 	{
; 809  : 		return;

  00066	eb 2b		 jmp	 SHORT $LN3@GJPUserDis
$LN2@GJPUserDis:

; 810  : 	}
; 811  : 
; 812  : 	GCServerMsgStringSend(lMsg.Get(1603), number, 0);

  00068	6a 00		 push	 0
  0006a	8b 45 ec	 mov	 eax, DWORD PTR _number$[ebp]
  0006d	50		 push	 eax
  0006e	68 43 06 00 00	 push	 1603			; 00000643H
  00073	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 813  : 	gObjUserKill(number);

  00087	8b 45 ec	 mov	 eax, DWORD PTR _number$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  00090	83 c4 04	 add	 esp, 4
$LN3@GJPUserDis:

; 814  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00099	33 cd		 xor	 ecx, ebp
  0009b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?GJPUserDisconnectRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z ENDP ; GJPUserDisconnectRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?GJPUserKillRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
_number$ = -20						; size = 4
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?GJPUserKillRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z PROC	; GJPUserKillRecv, COMDAT

; 735  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 736  : 	char szId[MAX_IDSTRING+1];
; 737  : 	int number;
; 738  : 	szId[MAX_IDSTRING] = '\0';

  00013	b8 01 00 00 00	 mov	 eax, 1
  00018	6b c8 0a	 imul	 ecx, eax, 10
  0001b	89 4d a8	 mov	 DWORD PTR $T1[ebp], ecx
  0001e	83 7d a8 0b	 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00022	73 02		 jae	 SHORT $LN4@GJPUserKil
  00024	eb 05		 jmp	 SHORT $LN5@GJPUserKil
$LN4@GJPUserKil:
  00026	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN5@GJPUserKil:
  0002b	8b 55 a8	 mov	 edx, DWORD PTR $T1[ebp]
  0002e	c6 44 15 f0 00	 mov	 BYTE PTR _szId$[ebp+edx], 0

; 739  : 
; 740  : 	memcpy(szId, lpMsg->Id, MAX_IDSTRING);

  00033	6a 0a		 push	 10			; 0000000aH
  00035	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00038	83 c0 03	 add	 eax, 3
  0003b	50		 push	 eax
  0003c	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _memcpy
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 741  : 	number = lpMsg->Number;

  00048	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004b	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  0004f	89 4d ec	 mov	 DWORD PTR _number$[ebp], ecx

; 742  : 
; 743  : #ifdef MODIFY_DENY_USER_DISCONNNECT_HACK_20080323
; 744  : 	gObj[number].m_UserKillRecvCount++;
; 745  : 	
; 746  : 	// 사용자를 강제 종료 시키도록 한다.
; 747  : 	LogAddTD( "[TRACELOG][HACKING] User kill from JoinServer (%d) [%s][%s]", number, szId, gObj[number].Name );
; 748  : 	
; 749  : 	if( gObj[number].m_UserKillRecvCount > 10 )
; 750  : 	{
; 751  : 		// m_UserKillRecvCount 이 5회 이상이면 강제로 접속을 종료시킨다.
; 752  : 		gObjDel( number );
; 753  : 	}
; 754  : #endif // MODIFY_DENY_USER_DISCONNNECT_HACK_20080323
; 755  : 	
; 756  : 	if( gObjIsAccontConnect(number, szId) == FALSE )

  00052	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00055	50		 push	 eax
  00056	8b 4d ec	 mov	 ecx, DWORD PTR _number$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0005f	83 c4 08	 add	 esp, 8
  00062	85 c0		 test	 eax, eax
  00064	75 02		 jne	 SHORT $LN2@GJPUserKil

; 757  : 	{
; 758  : #ifdef MODIFY_DENY_USER_DISCONNNECT_HACK_20080323
; 759  : 		// 접속 종료 프로토콜을 처리 못하는 부분이 있는지 확인한다.
; 760  : 		LogAddTD( "[HACKING][USERKILL DENY] Can't find User (%d) [%s][%s]", number, szId, gObj[number].Name );
; 761  : #endif // MODIFY_DENY_USER_DISCONNNECT_HACK_20080323
; 762  : 		return;

  00066	eb 2b		 jmp	 SHORT $LN3@GJPUserKil
$LN2@GJPUserKil:

; 763  : 	}
; 764  : 
; 765  : 	GCServerMsgStringSend(lMsg.Get(1602), number, 0);

  00068	6a 00		 push	 0
  0006a	8b 45 ec	 mov	 eax, DWORD PTR _number$[ebp]
  0006d	50		 push	 eax
  0006e	68 42 06 00 00	 push	 1602			; 00000642H
  00073	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 766  : 	gObjUserKill(number);

  00087	8b 45 ec	 mov	 eax, DWORD PTR _number$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  00090	83 c4 04	 add	 esp, 4
$LN3@GJPUserKil:

; 767  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00099	33 cd		 xor	 ecx, ebp
  0009b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?GJPUserKillRecv@@YAXPAUSDHP_BILLKILLUSER@@@Z ENDP	; GJPUserKillRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?GJPBillCeckRecv@@YAXPAUSDHP_BILLSEARCH_RESULT@@@Z
_TEXT	SEGMENT
$T1 = -104						; size = 4
_EndsDays$ = -36					; size = 13
_szId$ = -20						; size = 11
_aIndex$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?GJPBillCeckRecv@@YAXPAUSDHP_BILLSEARCH_RESULT@@@Z PROC	; GJPBillCeckRecv, COMDAT

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 634  : 	int		aIndex = lpMsg->Number;

  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	0f bf 48 0e	 movsx	 ecx, WORD PTR [eax+14]
  0001a	89 4d f8	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 635  : 	char	szId[MAX_IDSTRING+1];
; 636  : 	char    EndsDays[13];
; 637  : 
; 638  : 
; 639  : 	szId[MAX_IDSTRING] = '\0';

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	6b c8 0a	 imul	 ecx, eax, 10
  00025	89 4d 98	 mov	 DWORD PTR $T1[ebp], ecx
  00028	83 7d 98 0b	 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  0002c	73 02		 jae	 SHORT $LN7@GJPBillCec
  0002e	eb 05		 jmp	 SHORT $LN8@GJPBillCec
$LN7@GJPBillCec:
  00030	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN8@GJPBillCec:
  00035	8b 55 98	 mov	 edx, DWORD PTR $T1[ebp]
  00038	c6 44 15 ec 00	 mov	 BYTE PTR _szId$[ebp+edx], 0

; 640  : 
; 641  : 	memcpy(szId, lpMsg->Id, MAX_IDSTRING);

  0003d	6a 0a		 push	 10			; 0000000aH
  0003f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00042	83 c0 03	 add	 eax, 3
  00045	50		 push	 eax
  00046	8d 4d ec	 lea	 ecx, DWORD PTR _szId$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _memcpy
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 642  : 	if( gObjIsAccontConnect(aIndex, szId) == FALSE )

  00052	8d 45 ec	 lea	 eax, DWORD PTR _szId$[ebp]
  00055	50		 push	 eax
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0005f	83 c4 08	 add	 esp, 8
  00062	85 c0		 test	 eax, eax
  00064	75 05		 jne	 SHORT $LN2@GJPBillCec

; 643  : 	{
; 644  : 		return;

  00066	e9 32 01 00 00	 jmp	 $LN6@GJPBillCec
$LN2@GJPBillCec:

; 645  : 	}
; 646  : 	memset(EndsDays, 0, 13);

  0006b	6a 0d		 push	 13			; 0000000dH
  0006d	6a 00		 push	 0
  0006f	8d 45 dc	 lea	 eax, DWORD PTR _EndsDays$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _memset
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  : 	memcpy(EndsDays, lpMsg->EndsDays, 12);

  0007b	6a 0c		 push	 12			; 0000000cH
  0007d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00080	83 c0 11	 add	 eax, 17			; 00000011H
  00083	50		 push	 eax
  00084	8d 4d dc	 lea	 ecx, DWORD PTR _EndsDays$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _memcpy
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 648  : 	
; 649  : #ifdef MODIFY_PCBANG_EXPIRE_USER_ADVANTAGE_REMOVE_20070120
; 650  : 	if( m_ObjBill[aIndex].GetCertify() == CERTIFYTYPE_IP && lpMsg->cCertifyType == CERTIFYTYPE_ACCOUNT )
; 651  : 	{
; 652  : 		// PC방 만료 유저는 PC방 해택 부분 적용을 삭제한다.
; 653  : 		gObj[aIndex].m_bPCBangUser = FALSE;
; 654  : 		gObj[aIndex].m_bPCBangCouponUser = FALSE;
; 655  : 		gObj[aIndex].m_bPCBangFreeChaosCastleUser = FALSE;
; 656  : 	}
; 657  : #endif // MODIFY_PCBANG_EXPIRE_USER_ADVANTAGE_REMOVE_20070120
; 658  : 
; 659  : #ifdef 	UPDATE_UNIFICATIONBILL_20090203
; 660  : 	if( m_ObjBill[aIndex].GetDeductType() != BILL_TYPE_NONE )

  00090	6b 4d f8 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  00094	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0009a	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  0009f	0f b6 c0	 movzx	 eax, al
  000a2	85 c0		 test	 eax, eax
  000a4	0f 84 a2 00 00
	00		 je	 $LN3@GJPBillCec

; 661  : 	{
; 662  : 		if(m_ObjBill[aIndex].GetDeductType() != lpMsg->btDeductType )

  000aa	6b 4d f8 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  000ae	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  000b4	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  000b9	0f b6 c0	 movzx	 eax, al
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000bf	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  000c3	3b c2		 cmp	 eax, edx
  000c5	0f 84 81 00 00
	00		 je	 $LN3@GJPBillCec

; 663  : 		{
; 664  : 			LogAddTD("[WzUnificationBill][DeducateType] - Change %d -> %d (ID:%s)",

  000cb	8d 45 ec	 lea	 eax, DWORD PTR _szId$[ebp]
  000ce	50		 push	 eax
  000cf	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000d2	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  000d6	52		 push	 edx
  000d7	6b 4d f8 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  000db	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  000e1	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  000e6	0f b6 c0	 movzx	 eax, al
  000e9	50		 push	 eax
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@CNIHGDJD@?$FLWzUnificationBill?$FN?$FLDeducateTyp@
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f5	83 c4 10	 add	 esp, 16			; 00000010H

; 665  : 				m_ObjBill[aIndex].GetDeductType(),
; 666  : 				lpMsg->btDeductType, szId );
; 667  : 			
; 668  : 			gLCount[m_ObjBill[aIndex].GetDeductType()].Delete();

  000f8	6b 4d f8 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  000fc	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00102	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  00107	0f b6 c0	 movzx	 eax, al
  0010a	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR ?gLCount@@3PAVCLoginCount@@A[eax*4]
  00111	e8 00 00 00 00	 call	 ?Delete@CLoginCount@@QAEXXZ ; CLoginCount::Delete

; 669  : 			gLCount[lpMsg->btDeductType].Add();

  00116	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00119	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0011d	8d 0c 8d 00 00
	00 00		 lea	 ecx, DWORD PTR ?gLCount@@3PAVCLoginCount@@A[ecx*4]
  00124	e8 00 00 00 00	 call	 ?Add@CLoginCount@@QAEXXZ ; CLoginCount::Add

; 670  : 			
; 671  : 			gObjAddMsgSendDelay(&gObj[aIndex], MSG_BILLSEND, aIndex, 100);

  00129	6a 00		 push	 0
  0012b	6a 64		 push	 100			; 00000064H
  0012d	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00130	50		 push	 eax
  00131	68 e8 03 00 00	 push	 1000			; 000003e8H
  00136	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0013d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00149	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@GJPBillCec:

; 672  : 		}			
; 673  : 	}
; 674  : 	
; 675  : 	if( m_ObjBill[aIndex].SetBill(lpMsg->btDeductType, lpMsg->dwRestPoint, lpMsg->dwRestTime, EndsDays) == TRUE )

  0014c	8d 45 dc	 lea	 eax, DWORD PTR _EndsDays$[ebp]
  0014f	50		 push	 eax
  00150	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00153	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00156	52		 push	 edx
  00157	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0015a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0015d	51		 push	 ecx
  0015e	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00161	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00165	50		 push	 eax
  00166	6b 4d f8 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  0016a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00170	e8 00 00 00 00	 call	 ?SetBill@BILL_CLASS@@QAEHEKKPAD@Z ; BILL_CLASS::SetBill
  00175	83 f8 01	 cmp	 eax, 1
  00178	75 23		 jne	 SHORT $LN6@GJPBillCec

; 676  : 	{
; 677  : #if TESTSERVER == 1
; 678  : 		gObjAddMsgSendDelay(&gObj[aIndex], MSG_BILLSEND, aIndex, 500);
; 679  : #else
; 680  : 		gObjAddMsgSendDelay(&gObj[aIndex], MSG_BILLSEND, aIndex, 100);

  0017a	6a 00		 push	 0
  0017c	6a 64		 push	 100			; 00000064H
  0017e	8b 45 f8	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00181	50		 push	 eax
  00182	68 e8 03 00 00	 push	 1000			; 000003e8H
  00187	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0018e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00194	51		 push	 ecx
  00195	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  0019a	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@GJPBillCec:

; 681  : #endif
; 682  : 	}
; 683  : #else	// UPDATE_UNIFICATIONBILL_20090203
; 684  : #ifdef PCBANG_UNIFICATION_BILLING_CONNECT_USER_COUNT_20070103
; 685  : 	if( m_ObjBill[aIndex].GetCertify() != -1 )
; 686  : 	{
; 687  : 		if( m_ObjBill[aIndex].GetCertify() != lpMsg->cCertifyType )
; 688  : 		{
; 689  : 			LogAddTD("[UnificationBill][CertifyType] - Change %d -> %d (ID:%s)",
; 690  : 				m_ObjBill[aIndex].GetCertify(),
; 691  : 				lpMsg->cCertifyType,
; 692  : 				szId );
; 693  : 			gLCount[m_ObjBill[aIndex].GetCertify()].Delete();
; 694  : 			gLCount[lpMsg->cCertifyType].Add();
; 695  : 			
; 696  : 	#ifdef MODIFY_BILLING_MESSAGE_BUGFIX_20070208
; 697  : 			gObjAddMsgSendDelay(&gObj[aIndex], MSG_BILLSEND, aIndex, 100);
; 698  : 	#endif // MODIFY_BILLING_MESSAGE_BUGFIX_20070208
; 699  : 		}
; 700  : 	}
; 701  : #endif // PCBANG_UNIFICATION_BILLING_CONNECT_USER_COUNT_20070103
; 702  : 
; 703  : 	if( m_ObjBill[aIndex].SetBill(lpMsg->cCertifyType, lpMsg->PayCode, lpMsg->EndTime, EndsDays) == TRUE )
; 704  : 	{
; 705  : 
; 706  : #ifndef MODIFY_BILLING_RESTTIME_BUGFIX_20070212			// !!NOT
; 707  : 	#ifdef PCBANG_UNIFICATION_BILLING_CONNECT_USER_COUNT_20070103
; 708  : 		if( lpMsg->cCertifyType == CERTIFYTYPE_IP )
; 709  : 		{
; 710  : 			return;
; 711  : 		}
; 712  : 	#endif // PCBANG_UNIFICATION_BILLING_CONNECT_USER_COUNT_20070103
; 713  : #endif // MODIFY_BILLING_RESTTIME_BUGFIX_20070212
; 714  : 
; 715  : #if TESTSERVER == 1
; 716  : 		gObjAddMsgSendDelay(&gObj[aIndex], MSG_BILLSEND, aIndex, 500);
; 717  : #else
; 718  : 		gObjAddMsgSendDelay(&gObj[aIndex], MSG_BILLSEND, aIndex, 100);
; 719  : #endif
; 720  : 	}
; 721  : #endif	// UPDATE_UNIFICATIONBILL_20090203
; 722  : 
; 723  : #ifndef MODIFY_BILLING_MESSAGE_BUGFIX_20070208
; 724  : 	#ifdef PCBANG_UNIFICATION_BILLING_CONNECT_USER_COUNT_20070103
; 725  : 	else
; 726  : 	{
; 727  : 		gObjAddMsgSendDelay(&gObj[aIndex], MSG_BILLSEND, aIndex, 100);
; 728  : 	}
; 729  : 	#endif // PCBANG_UNIFICATION_BILLING_CONNECT_USER_COUNT_20070103
; 730  : #endif // MODIFY_BILLING_MESSAGE_BUGFIX_20070208
; 731  : }

  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx
  001a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a3	33 cd		 xor	 ecx, ebp
  001a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
?GJPBillCeckRecv@@YAXPAUSDHP_BILLSEARCH_RESULT@@@Z ENDP	; GJPBillCeckRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?JGPAccountRequest@@YAXPAUSDHP_IDPASSRESULT@@@Z
_TEXT	SEGMENT
tv281 = -184						; size = 4
tv150 = -184						; size = 4
_temp$1 = -116						; size = 8
_itemp$2 = -108						; size = 4
_pIpBlock$3 = -104					; size = 32
_pUserConnectTime$4 = -72				; size = 36
_szJN$ = -36						; size = 14
_aIndex$ = -20						; size = 4
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGPAccountRequest@@YAXPAUSDHP_IDPASSRESULT@@@Z PROC	; JGPAccountRequest, COMDAT

; 277  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 278  : 	char				szId[MAX_IDSTRING+1];
; 279  : 	int					aIndex;
; 280  : #ifdef UPDATE_USERPASSWORD_LENGTH_20090424	
; 281  : 	char				szJN[MAX_JOOMINNUMBER_LENGTH+1]="";
; 282  : #else
; 283  : 	char				szJN[14]="";

  00016	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0001b	88 45 dc	 mov	 BYTE PTR _szJN$[ebp], al
  0001e	33 c0		 xor	 eax, eax
  00020	89 45 dd	 mov	 DWORD PTR _szJN$[ebp+1], eax
  00023	89 45 e1	 mov	 DWORD PTR _szJN$[ebp+5], eax
  00026	89 45 e5	 mov	 DWORD PTR _szJN$[ebp+9], eax
  00029	88 45 e9	 mov	 BYTE PTR _szJN$[ebp+13], al

; 284  : #endif
; 285  : 
; 286  : 	memset(szId, 0,         sizeof(szId));

  0002c	6a 0b		 push	 11			; 0000000bH
  0002e	6a 00		 push	 0
  00030	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _memset
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 287  : 	memcpy(szId, lpMsg->Id, MAX_IDSTRING);

  0003c	6a 0a		 push	 10			; 0000000aH
  0003e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00041	83 c0 06	 add	 eax, 6
  00044	50		 push	 eax
  00045	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _memcpy
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 288  : #ifdef UPDATE_USERPASSWORD_LENGTH_20090424	
; 289  : 	memcpy(szJN, lpMsg->JoominNumber, 13);//MAX_JOOMINNUMBER_LENGTH);
; 290  : #else	// UPDATE_USERPASSWORD_LENGTH_20090424
; 291  : 	memcpy(szJN, lpMsg->JoominNumber, 13);

  00051	6a 0d		 push	 13			; 0000000dH
  00053	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00056	83 c0 18	 add	 eax, 24			; 00000018H
  00059	50		 push	 eax
  0005a	8d 4d dc	 lea	 ecx, DWORD PTR _szJN$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _memcpy
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 292  : #endif	// UPDATE_USERPASSWORD_LENGTH_20090424
; 293  : 
; 294  : 	aIndex = (int)lpMsg->Number;

  00066	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00069	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  0006d	89 4d ec	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 295  : 
; 296  : #ifndef UPDATE_USERPASSWORD_LENGTH_20090424	
; 297  : 	// lpMsg->result == 0x0F 이면 계정캐릭터 블럭이다
; 298  : 	if( lpMsg->result == 0x01 || lpMsg->result == 0x0F )

  00070	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00073	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00077	83 f9 01	 cmp	 ecx, 1
  0007a	74 10		 je	 SHORT $LN5@JGPAccount
  0007c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0007f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00083	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00086	0f 85 92 00 00
	00		 jne	 $LN4@JGPAccount
$LN5@JGPAccount:

; 299  : 	{
; 300  : 		// non pk 서버면 다 들어오고 아닐경우엔 15세 미만 접속 불가능
; 301  : 		if( gNonPK == 0 && gLanguage == 0 )

  0008c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK
  00093	75 3f		 jne	 SHORT $LN6@JGPAccount
  00095	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLanguage@@3HA, 0 ; gLanguage
  0009c	75 36		 jne	 SHORT $LN6@JGPAccount

; 302  : 		{
; 303  : 			if( gJoomin15Check(szJN) == FALSE )

  0009e	8d 45 dc	 lea	 eax, DWORD PTR _szJN$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?gJoomin15Check@@YAHPAD@Z ; gJoomin15Check
  000a7	83 c4 04	 add	 esp, 4
  000aa	85 c0		 test	 eax, eax
  000ac	75 26		 jne	 SHORT $LN6@JGPAccount

; 304  : 			{
; 305  : 				GJPAccountFail(aIndex, szId, lpMsg->DBNumber,  lpMsg->UserNumber);

  000ae	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000b1	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000b4	51		 push	 ecx
  000b5	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000b8	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000bb	50		 push	 eax
  000bc	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  000bf	51		 push	 ecx
  000c0	0f b7 55 ec	 movzx	 edx, WORD PTR _aIndex$[ebp]
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 ?GJPAccountFail@@YAXFPADHH@Z ; GJPAccountFail
  000ca	83 c4 10	 add	 esp, 16			; 00000010H

; 306  : 				lpMsg->result = 0x11;	// 실패로 만들고..	사용자한테 실패라고 알린다.

  000cd	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000d0	c6 40 03 11	 mov	 BYTE PTR [eax+3], 17	; 00000011H
$LN6@JGPAccount:

; 307  : 			}
; 308  : 		}
; 309  : 		
; 310  : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324	// 18세 미만 접속 불가능
; 311  : 		if( gPkLimitFree == 1 && gLanguage == 0 )

  000d4	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 1 ; gPkLimitFree
  000db	75 41		 jne	 SHORT $LN4@JGPAccount
  000dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLanguage@@3HA, 0 ; gLanguage
  000e4	75 38		 jne	 SHORT $LN4@JGPAccount

; 312  : 		{
; 313  : 			if (gJoominCheck(szJN, 18) == FALSE) {

  000e6	6a 12		 push	 18			; 00000012H
  000e8	8d 45 dc	 lea	 eax, DWORD PTR _szJN$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?gJoominCheck@@YAHPADH@Z ; gJoominCheck
  000f1	83 c4 08	 add	 esp, 8
  000f4	85 c0		 test	 eax, eax
  000f6	75 26		 jne	 SHORT $LN4@JGPAccount

; 314  : 				GJPAccountFail(aIndex, szId, lpMsg->DBNumber,  lpMsg->UserNumber);

  000f8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000fb	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000fe	51		 push	 ecx
  000ff	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00102	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00105	50		 push	 eax
  00106	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  00109	51		 push	 ecx
  0010a	0f b7 55 ec	 movzx	 edx, WORD PTR _aIndex$[ebp]
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 ?GJPAccountFail@@YAXFPADHH@Z ; GJPAccountFail
  00114	83 c4 10	 add	 esp, 16			; 00000010H

; 315  : 				lpMsg->result = 0x11;	// 실패로 만들고..	사용자한테 실패라고 알린다.

  00117	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0011a	c6 40 03 11	 mov	 BYTE PTR [eax+3], 17	; 00000011H
$LN4@JGPAccount:

; 316  : 			}
; 317  : 		}
; 318  : #endif
; 319  : 	}
; 320  : #endif	// UPDATE_USERPASSWORD_LENGTH_20090424	
; 321  : 
; 322  : 	switch( lpMsg->result )

  0011e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00121	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00124	88 8d 48 ff ff
	ff		 mov	 BYTE PTR tv150[ebp], cl
  0012a	80 bd 48 ff ff
	ff 01		 cmp	 BYTE PTR tv150[ebp], 1
  00131	74 0e		 je	 SHORT $LN10@JGPAccount
  00133	80 bd 48 ff ff
	ff 0f		 cmp	 BYTE PTR tv150[ebp], 15	; 0000000fH
  0013a	74 05		 je	 SHORT $LN10@JGPAccount
  0013c	e9 c9 00 00 00	 jmp	 $LN2@JGPAccount
$LN10@JGPAccount:

; 323  : 	{
; 324  : 	case 0x01 :	// 인증 성공		
; 325  : 	case 0x0F :	// 인증 성공 - 계정 아이템 블럭 (MeMuOnline.MEMB_INFO.bloc_code 'F')
; 326  : #ifdef PCBANG_DEFAULTER	
; 327  : 	case 0x10 :	// 인증 성공 - PC방 미납자 (MeMuOnline.MEMB_INFO.bloc_code 'G')
; 328  : #endif
; 329  : #ifdef ADD_PROTOCOL_PCBANG_GUID
; 330  : 	#ifdef PCBANG_ADVANTAGE 
; 331  : 			if( gObjSetAccountLogin(aIndex, szId,	lpMsg->UserNumber, 
; 332  : 													lpMsg->DBNumber, 
; 333  : 													lpMsg->PcBangGuid,
; 334  : 													szJN, lpMsg->bUserInPCBang) == FALSE )
; 335  : 	#else
; 336  : 			if( gObjSetAccountLogin(aIndex, szId,	lpMsg->UserNumber, 
; 337  : 													lpMsg->DBNumber, 
; 338  : 													lpMsg->PcBangGuid,
; 339  : 													szJN) == FALSE )
; 340  : 	#endif //PCBANG_ADVANTAGE
; 341  : #else
; 342  : 	#if defined(PCBANG_ADVANTAGE) && defined(FOR_TAIWAN)
; 343  : 		if( gObjSetAccountLogin(aIndex, szId,	lpMsg->UserNumber, 
; 344  : 												lpMsg->DBNumber, 
; 345  : 												0,
; 346  : 												szJN, lpMsg->bUserInPCBang) == FALSE )
; 347  : 	#else
; 348  : 		if( gObjSetAccountLogin(aIndex, szId,	lpMsg->UserNumber, 
; 349  : 												lpMsg->DBNumber, 
; 350  : 												szJN) == FALSE )

  00141	8d 45 dc	 lea	 eax, DWORD PTR _szJN$[ebp]
  00144	50		 push	 eax
  00145	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00148	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0014b	52		 push	 edx
  0014c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0014f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00152	51		 push	 ecx
  00153	8d 55 f0	 lea	 edx, DWORD PTR _szId$[ebp]
  00156	52		 push	 edx
  00157	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ?gObjSetAccountLogin@@YAHHPADHH0@Z ; gObjSetAccountLogin
  00160	83 c4 14	 add	 esp, 20			; 00000014H
  00163	85 c0		 test	 eax, eax
  00165	75 28		 jne	 SHORT $LN11@JGPAccount

; 351  : 	#endif
; 352  : #endif
; 353  : 		{	// 인증 실패일경우.. (인증에도 알리고..)
; 354  : 			GJPAccountFail(aIndex, szId, lpMsg->DBNumber,  lpMsg->UserNumber);

  00167	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0016a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0016d	51		 push	 ecx
  0016e	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00171	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00174	50		 push	 eax
  00175	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  00178	51		 push	 ecx
  00179	0f b7 55 ec	 movzx	 edx, WORD PTR _aIndex$[ebp]
  0017d	52		 push	 edx
  0017e	e8 00 00 00 00	 call	 ?GJPAccountFail@@YAXFPADHH@Z ; GJPAccountFail
  00183	83 c4 10	 add	 esp, 16			; 00000010H

; 355  : 			lpMsg->result = 0x04;	// 실패로 만들고..	사용자한테 실패라고 알린다.

  00186	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00189	c6 40 03 04	 mov	 BYTE PTR [eax+3], 4

; 356  : 		}

  0018d	eb 3d		 jmp	 SHORT $LN12@JGPAccount
$LN11@JGPAccount:

; 357  : 		else
; 358  : 		{
; 359  : 	#ifdef MODIFY_GAMEGUARD_NOT_AUTH_MAPSERVER_MOVE_20060513
; 360  : 			gObj[aIndex].m_bCheckGGAuth = true;
; 361  : 	#endif // MODIFY_GAMEGUARD_NOT_AUTH_MAPSERVER_MOVE_20060513
; 362  : 			LogAddTD(lMsg.Get(467), gObj[aIndex].Ip_addr, szId, lpMsg->UserNumber, lpMsg->DBNumber);

  0018f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00192	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00195	51		 push	 ecx
  00196	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00199	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0019c	50		 push	 eax
  0019d	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  001a0	51		 push	 ecx
  001a1	69 55 ec a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  001a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ad	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  001b1	51		 push	 ecx
  001b2	68 d3 01 00 00	 push	 467			; 000001d3H
  001b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001c2	50		 push	 eax
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c9	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@JGPAccount:

; 363  : 		}		
; 364  : 		if( lpMsg->UserNumber == 0 && lpMsg->DBNumber == 0 )

  001cc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001cf	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  001d3	75 35		 jne	 SHORT $LN2@JGPAccount
  001d5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001d8	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  001dc	75 2c		 jne	 SHORT $LN2@JGPAccount

; 365  : 		{
; 366  : 			LogAddTD(lMsg.Get(468), szId, lpMsg->UserNumber, lpMsg->DBNumber);

  001de	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001e1	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001e4	51		 push	 ecx
  001e5	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  001e8	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001eb	50		 push	 eax
  001ec	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  001ef	51		 push	 ecx
  001f0	68 d4 01 00 00	 push	 468			; 000001d4H
  001f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00200	50		 push	 eax
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00207	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@JGPAccount:

; 367  : 		}
; 368  : 		break;
; 369  : 	}
; 370  : 
; 371  : #ifdef FOR_JAPAN
; 372  : 	if( lpMsg->result == 0 )
; 373  : 		lpMsg->result = 2;	//  일본의 경우 비밀번호가 틀리면 무조건 계정없음으로 한다.
; 374  : #endif
; 375  : 
; 376  : #ifdef FOR_THAILAND
; 377  : 	if( lpMsg->result == 0x12 )
; 378  : 	{
; 379  : 		lpMsg->result = 0x0E;
; 380  : 		GCServerMsgStringSend(lMsg.Get(1609), aIndex, 1);		
; 381  : 	}
; 382  : 	gObj[aIndex].m_AuthAdult = lpMsg->AuthAdult;
; 383  : #endif
; 384  : 
; 385  : #ifdef CHN_PLAYTIME_LIMIT_SYSTEM_20050818
; 386  : 	#ifdef MODIFY_PLAYTIME_LIMIT_MESSAGE_ONOFF_20060427
; 387  : 		if( g_bChnPlayTimeLimitOn == TRUE )
; 388  : 	#endif
; 389  : 		{
; 390  : 	#ifdef MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 391  : 			gObj[aIndex].m_iVerifyType = lpMsg->iVerifiedType; 
; 392  : 			gObj[aIndex].m_iPlayTimeLimit = lpMsg->iAddPlayTime;
; 393  : 			gObj[aIndex].m_dwPlayTick = GetTickCount();
; 394  : 			gObj[aIndex].m_iPlayNoticeTick = 0;
; 395  : 
; 396  : 			// 중국추가> . 로그인한 사용자에게 남은 시간에 대한 공지를 한다.
; 397  : 			if( gObj[aIndex].m_iVerifyType != PLAYTIME_LIMIT_VERIFY_ADULT )
; 398  : 			{
; 399  : 				INT iCalcRestTime = (5*60*60)-lpMsg->iAddRestTime;
; 400  : 				if (iCalcRestTime < 0)	iCalcRestTime = 0;
; 401  : 				PMSG_NOTICE	pNotice;
; 402  : 				CHAR szNotice[256] = {0,};
; 403  : 				TNotice::SetNoticeProperty(&pNotice, TNOTICE_TYPE_BOTTOM, TNOTICE_COLOR_DEFAULT);
; 404  : 				wsprintf(szNotice, lMsg.Get(1259),					// "플레이시간:%02d시%02d분, 정상 플레이까지 남은 휴식시간:%02d시%02d분"
; 405  : 					gObj[aIndex].m_iPlayTimeLimit/(60*60),	
; 406  : 					(gObj[aIndex].m_iPlayTimeLimit%(60*60))/60,
; 407  : 					iCalcRestTime/(60*60),
; 408  : 					(iCalcRestTime%(60*60))/60
; 409  : 					);
; 410  : 				TNotice::MakeNoticeMsg( &pNotice, TNOTICE_TYPE_BOTTOM, szNotice);
; 411  : 				TNotice::SendNoticeToUser( aIndex, &pNotice );
; 412  : 			}
; 413  : 	#else
; 414  : 			gObj[aIndex].m_iPlayTimeLimit = lpMsg->iAddPlayTime;
; 415  : 			gObj[aIndex].m_dwPlayTick = GetTickCount();
; 416  : 			gObj[aIndex].m_iPlayNoticeTick = 0;
; 417  : 
; 418  : 			// 중국추가> . 로그인한 사용자에게 남은 시간에 대한 공지를 한다.
; 419  : 			INT iCalcRestTime = (5*60*60)-lpMsg->iAddRestTime;
; 420  : 			if (iCalcRestTime < 0)	iCalcRestTime = 0;
; 421  : 			PMSG_NOTICE	pNotice;
; 422  : 			CHAR szNotice[256] = {0,};
; 423  : 			TNotice::SetNoticeProperty(&pNotice, TNOTICE_TYPE_BOTTOM, TNOTICE_COLOR_DEFAULT);
; 424  : 			wsprintf(szNotice, lMsg.Get(1259),					// "플레이시간:%02d시%02d분, 정상 플레이까지 남은 휴식시간:%02d시%02d분"
; 425  : 				gObj[aIndex].m_iPlayTimeLimit/(60*60),	
; 426  : 				(gObj[aIndex].m_iPlayTimeLimit%(60*60))/60,
; 427  : 				iCalcRestTime/(60*60),
; 428  : 				(iCalcRestTime%(60*60))/60
; 429  : 				);
; 430  : 			TNotice::MakeNoticeMsg( &pNotice, TNOTICE_TYPE_BOTTOM, szNotice);
; 431  : 			TNotice::SendNoticeToUser( aIndex, &pNotice );
; 432  : 	#endif // MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 433  : 		}
; 434  : #endif
; 435  : 
; 436  : #ifdef VTM_PLAYTIME_LIMIT_SYSTEM_20060626
; 437  : 		if( g_bVtmPlayTimeLimitOn == TRUE && lpMsg->result == 0x01 )
; 438  : 		{
; 439  : 			gObj[aIndex].m_iPlayTimeLimit	= lpMsg->iAddPlayTime;
; 440  : 			gObj[aIndex].m_iPlayRestTime	= lpMsg->iAddRestTime;
; 441  : 			gObj[aIndex].m_dwPlayTick		= GetTickCount();
; 442  : 			gObj[aIndex].m_iPlayNoticeTick	= 0;
; 443  : 
; 444  : 			INT iCalcRestTime = (g_iVtmPlayTimeLimitLevel2Time*60)-lpMsg->iAddRestTime;
; 445  : 
; 446  : 			if (iCalcRestTime < 0)	
; 447  : 			{
; 448  : 				iCalcRestTime = 0;
; 449  : 			}
; 450  : 
; 451  : 			PMSG_NOTICE	pNotice;
; 452  : 			CHAR szNotice[256] = {0,};
; 453  : 			TNotice::SetNoticeProperty(&pNotice, TNOTICE_TYPE_BOTTOM, TNOTICE_COLOR_DEFAULT);
; 454  : 
; 455  : 			// "현재 플레이 시간은 %d시 %d분이며, 초기화까지 %d시 %d분의 휴식이 필요합니다."
; 456  : 			TNotice::MakeNoticeMsgEx( &pNotice, TNOTICE_TYPE_BOTTOM, lMsg.Get(1270), 
; 457  : 				gObj[aIndex].m_iPlayTimeLimit/(60*60),	
; 458  : 				(gObj[aIndex].m_iPlayTimeLimit%(60*60))/60,
; 459  : 				iCalcRestTime/(60*60), 
; 460  : 				(iCalcRestTime%(60*60))/60 );
; 461  : 			TNotice::SendNoticeToUser( aIndex, &pNotice );
; 462  : 
; 463  : 		}
; 464  : #endif
; 465  : 
; 466  : #ifdef PCBANG_DEFAULTER	
; 467  : 	if( lpMsg->result == 0x10 )
; 468  : 	{
; 469  : 		// 결과코드를 기존과 다른 코드로 설정하여 전달한다.
; 470  : 	#ifdef MODIFY_PCBANG_DEFAULTER_MESSAGE_20061011
; 471  : 		lpMsg->result = 0x20;
; 472  : 	#else
; 473  : 		lpMsg->result = 0x01;
; 474  : 	#endif // MODIFY_PCBANG_DEFAULTER_MESSAGE_20061011
; 475  : 		
; 476  : 	#ifdef MODIFY_NOTICE_20040325
; 477  : 		PMSG_NOTICE	pNotice;
; 478  : 		TNotice::SetNoticeProperty(&pNotice, TNOTICE_TYPE_BOTTOM, TNOTICE_COLOR_RED);
; 479  : 		
; 480  : 		TNotice::MakeNoticeMsg( &pNotice, TNOTICE_TYPE_BOTTOM, "PC방 사용 요금 미지불에 대한 신고가 접수되었습니다" );
; 481  : 		TNotice::SendNoticeToUser( aIndex, &pNotice );
; 482  : 
; 483  : 		TNotice::MakeNoticeMsg( &pNotice, TNOTICE_TYPE_BOTTOM, "자세한 사항은 PC방 홈페이지를 참고하시기 바랍니다" );
; 484  : 		TNotice::SendNoticeToUser( aIndex, &pNotice );
; 485  : 	#else
; 486  : 		GCServerMsgStringSend("PC방 사용 요금 미지불에 대한 신고가 접수되었습니다", aIndex, 0);
; 487  : 		GCServerMsgStringSend("자세한 사항은 PC방 홈페이지를 참고하시기 바랍니다", aIndex, 0);		
; 488  : 	#endif
; 489  : 		
; 490  : 	}
; 491  : #endif
; 492  : 
; 493  : 	if( lpMsg->result == 0x0F )

  0020a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0020d	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00211	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00214	75 1c		 jne	 SHORT $LN14@JGPAccount

; 494  : 	{
; 495  : 		lpMsg->result = 0x01;

  00216	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00219	c6 40 03 01	 mov	 BYTE PTR [eax+3], 1

; 496  : 		gObj[aIndex].m_cAccountItemBlock = TRUE;

  0021d	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0022a	c6 84 01 ac 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+428], 1
$LN14@JGPAccount:

; 497  : 	}
; 498  : 		
; 499  : 
; 500  : 	gObj[aIndex].LoginMsgSnd = 0;

  00232	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00239	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023f	c6 44 01 08 00	 mov	 BYTE PTR [ecx+eax+8], 0

; 501  : 	if( gObj[aIndex].LoginMsgCount >= 3 )

  00244	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0024b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00251	0f be 54 01 09	 movsx	 edx, BYTE PTR [ecx+eax+9]
  00256	83 fa 03	 cmp	 edx, 3
  00259	7c 07		 jl	 SHORT $LN15@JGPAccount

; 502  : 	{
; 503  : 		lpMsg->result = 0x08;

  0025b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0025e	c6 40 03 08	 mov	 BYTE PTR [eax+3], 8
$LN15@JGPAccount:

; 504  : 	}
; 505  : 	
; 506  : #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 507  : 	if( lpMsg->result == 0x06 )

  00262	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00265	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00269	83 f9 06	 cmp	 ecx, 6
  0026c	75 15		 jne	 SHORT $LN16@JGPAccount

; 508  : 	{
; 509  : 		// 접속오류 입니다.
; 510  : 		gObj[aIndex].Connected = CSS_LOGINWAIT;

  0026e	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00275	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027b	c7 44 01 04 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+4], -1
$LN16@JGPAccount:

; 511  : 	}
; 512  : #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 513  : 
; 514  : #ifdef SMS_BLOCK
; 515  : 	if( lpMsg->result == 0x11 )
; 516  : 	{	// SMS 블럭
; 517  : 		lpMsg->result = 0x0E;
; 518  : 		GCServerMsgStringSend(lMsg.Get(1607), aIndex, 1);
; 519  : 	}
; 520  : #endif
; 521  : 
; 522  : #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 523  : 	if( lpMsg->result != 0x06 )

  00283	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00286	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0028a	83 f9 06	 cmp	 ecx, 6
  0028d	74 14		 je	 SHORT $LN17@JGPAccount

; 524  : 	{
; 525  : 		GCJoinResult(lpMsg->result, aIndex);

  0028f	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00292	50		 push	 eax
  00293	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00296	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0029a	52		 push	 edx
  0029b	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult
  002a0	83 c4 08	 add	 esp, 8
$LN17@JGPAccount:

; 526  : 	}
; 527  : #else
; 528  : 	GCJoinResult(lpMsg->result, aIndex);
; 529  : #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 530  : 
; 531  : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 532  : 	
; 533  : 	if( lpMsg->result == 0x01 )

  002a3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002a6	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  002aa	83 f9 01	 cmp	 ecx, 1
  002ad	75 60		 jne	 SHORT $LN18@JGPAccount

; 534  : 	{
; 535  : 		USER_CONNECT_TIME pUserConnectTime;
; 536  : 		
; 537  : 		memset(&pUserConnectTime, 0, sizeof(USER_CONNECT_TIME));

  002af	6a 24		 push	 36			; 00000024H
  002b1	6a 00		 push	 0
  002b3	8d 45 b8	 lea	 eax, DWORD PTR _pUserConnectTime$4[ebp]
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 _memset
  002bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 538  : 		
; 539  : 		pUserConnectTime.dwConnectTime = GetTickCount();

  002bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  002c5	89 45 b8	 mov	 DWORD PTR _pUserConnectTime$4[ebp], eax

; 540  : 		pUserConnectTime.iIndex = aIndex;

  002c8	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002cb	89 45 bc	 mov	 DWORD PTR _pUserConnectTime$4[ebp+4], eax

; 541  : 		memcpy(pUserConnectTime.szAccount, lpMsg->Id, MAX_IDSTRING);

  002ce	6a 0a		 push	 10			; 0000000aH
  002d0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002d3	83 c0 06	 add	 eax, 6
  002d6	50		 push	 eax
  002d7	8d 4d c0	 lea	 ecx, DWORD PTR _pUserConnectTime$4[ebp+8]
  002da	51		 push	 ecx
  002db	e8 00 00 00 00	 call	 _memcpy
  002e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 542  : 		memcpy(pUserConnectTime.Ip_addr, gObj[aIndex].Ip_addr, 15);

  002e3	6a 0f		 push	 15			; 0000000fH
  002e5	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f2	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  002f6	52		 push	 edx
  002f7	8d 45 cb	 lea	 eax, DWORD PTR _pUserConnectTime$4[ebp+19]
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 _memcpy
  00300	83 c4 0c	 add	 esp, 12			; 0000000cH

; 543  : 		
; 544  : 		SetConnectUser(&pUserConnectTime);

  00303	8d 45 b8	 lea	 eax, DWORD PTR _pUserConnectTime$4[ebp]
  00306	50		 push	 eax
  00307	e8 00 00 00 00	 call	 ?SetConnectUser@@YAXPAUUSER_CONNECT_TIME@@@Z ; SetConnectUser
  0030c	83 c4 04	 add	 esp, 4
$LN18@JGPAccount:

; 545  : 	}
; 546  : 	
; 547  : 	// 3번 이상 실패하면..
; 548  : 	if( lpMsg->result != 0x01 )

  0030f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00312	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00316	83 f9 01	 cmp	 ecx, 1
  00319	0f 84 9f 00 00
	00		 je	 $LN19@JGPAccount

; 549  : 	{
; 550  : 		if( gObj[aIndex].LoginMsgCount > 3 )

  0031f	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00326	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0032c	0f be 54 01 09	 movsx	 edx, BYTE PTR [ecx+eax+9]
  00331	83 fa 03	 cmp	 edx, 3
  00334	0f 8e 84 00 00
	00		 jle	 $LN19@JGPAccount

; 551  : 		{	
; 552  : 			IP_BLOCK pIpBlock;
; 553  : 			
; 554  : 			pIpBlock.dwBlockTime = GetTickCount();

  0033a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00340	89 45 b4	 mov	 DWORD PTR _pIpBlock$3[ebp+28], eax

; 555  : 			memcpy(pIpBlock.szAccount, lpMsg->Id, MAX_IDSTRING);

  00343	6a 0a		 push	 10			; 0000000aH
  00345	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00348	83 c0 06	 add	 eax, 6
  0034b	50		 push	 eax
  0034c	8d 4d 98	 lea	 ecx, DWORD PTR _pIpBlock$3[ebp]
  0034f	51		 push	 ecx
  00350	e8 00 00 00 00	 call	 _memcpy
  00355	83 c4 0c	 add	 esp, 12			; 0000000cH

; 556  : 			memcpy(pIpBlock.Ip_addr, gObj[aIndex].Ip_addr, 15);

  00358	6a 0f		 push	 15			; 0000000fH
  0035a	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00361	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00367	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0036b	52		 push	 edx
  0036c	8d 45 a3	 lea	 eax, DWORD PTR _pIpBlock$3[ebp+11]
  0036f	50		 push	 eax
  00370	e8 00 00 00 00	 call	 _memcpy
  00375	83 c4 0c	 add	 esp, 12			; 0000000cH

; 557  : 			
; 558  : 			setBlockIP(&pIpBlock);

  00378	8d 45 98	 lea	 eax, DWORD PTR _pIpBlock$3[ebp]
  0037b	50		 push	 eax
  0037c	e8 00 00 00 00	 call	 ?setBlockIP@@YAXPAUIP_BLOCK@@@Z ; setBlockIP
  00381	83 c4 04	 add	 esp, 4

; 559  : 			
; 560  : 			LogAddTD_TempLog(", [Login Fail], Account [%s], IP [%s], result[%d]",lpMsg->Id, gObj[aIndex].Ip_addr, lpMsg->result);

  00384	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00387	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0038b	51		 push	 ecx
  0038c	69 55 ec a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00393	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00398	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  0039c	51		 push	 ecx
  0039d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  003a0	83 c2 06	 add	 edx, 6
  003a3	52		 push	 edx
  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EDGCNACO@?0?5?$FLLogin?5Fail?$FN?0?5Account?5?$FL?$CFs?$FN?0?5I@
  003a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  003af	83 c4 10	 add	 esp, 16			; 00000010H

; 561  : 			
; 562  : 			CloseClient ( aIndex );

  003b2	8b 45 ec	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003b5	50		 push	 eax
  003b6	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  003bb	83 c4 04	 add	 esp, 4
$LN19@JGPAccount:

; 563  : 		}
; 564  : 		
; 565  : 		//LogAddTD_TempLog(", [TempLog - Login] Account [%s], IP [%s], Fail",lpMsg->Id, gObj[aIndex].Ip_addr);
; 566  : 	}
; 567  : #else // MODIFY_CONNNECT_HACK_ATTACK_20090409
; 568  : 	
; 569  : 	// 3번 이상 실패하면..
; 570  : 	if( lpMsg->result != 0x01 )
; 571  : 	{
; 572  : 		if( gObj[aIndex].LoginMsgCount > 3 )
; 573  : 		{
; 574  : 			//wsGServer.Close(gObj[aIndex].m_socket);
; 575  : 			CloseClient ( aIndex );
; 576  : 		}
; 577  : 	}
; 578  : 
; 579  : #endif // MODIFY_CONNNECT_HACK_ATTACK_20090409
; 580  : 	
; 581  : 	if(gObj[aIndex].Connected == 1)

  003be	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003cb	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  003d0	75 7b		 jne	 SHORT $LN1@JGPAccount

; 582  : 	{
; 583  : 		int itemp = (lpMsg->result == 0x01 ?  0 : 1 );

  003d2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003d5	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  003d9	83 f9 01	 cmp	 ecx, 1
  003dc	75 0c		 jne	 SHORT $LN23@JGPAccount
  003de	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv281[ebp], 0
  003e8	eb 0a		 jmp	 SHORT $LN24@JGPAccount
$LN23@JGPAccount:
  003ea	c7 85 48 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv281[ebp], 1
$LN24@JGPAccount:
  003f4	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv281[ebp]
  003fa	89 55 94	 mov	 DWORD PTR _itemp$2[ebp], edx

; 584  : 		char *temp[2] = { "Sucess", "Fail" };

  003fd	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _temp$1[ebp], OFFSET ??_C@_06KLIOLJEJ@Sucess@
  00404	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _temp$1[ebp+4], OFFSET ??_C@_04ODLKOBGJ@Fail@

; 585  : 		
; 586  : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 587  : 		LogAddTD_TempLog(", [Login], Account [%s], IP [%s], result[%d], %s",gObj[aIndex].AccountID, gObj[aIndex].Ip_addr, lpMsg->result, temp[itemp]);

  0040b	8b 45 94	 mov	 eax, DWORD PTR _itemp$2[ebp]
  0040e	8b 4c 85 8c	 mov	 ecx, DWORD PTR _temp$1[ebp+eax*4]
  00412	51		 push	 ecx
  00413	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00416	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  0041a	50		 push	 eax
  0041b	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00422	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00428	8d 44 0a 18	 lea	 eax, DWORD PTR [edx+ecx+24]
  0042c	50		 push	 eax
  0042d	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00434	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0043a	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0043e	50		 push	 eax
  0043f	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@FAFAGCMF@?0?5?$FLLogin?$FN?0?5Account?5?$FL?$CFs?$FN?0?5IP?5?$FL?$CFs@
  00444	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  0044a	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@JGPAccount:

; 588  : #endif
; 589  : 	}
; 590  : }

  0044d	5f		 pop	 edi
  0044e	5e		 pop	 esi
  0044f	5b		 pop	 ebx
  00450	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00453	33 cd		 xor	 ecx, ebp
  00455	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045a	8b e5		 mov	 esp, ebp
  0045c	5d		 pop	 ebp
  0045d	c3		 ret	 0
?JGPAccountRequest@@YAXPAUSDHP_IDPASSRESULT@@@Z ENDP	; JGPAccountRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?JGServerLoginResult@@YAXPAUSDHP_RESULT@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?JGServerLoginResult@@YAXPAUSDHP_RESULT@@@Z PROC	; JGServerLoginResult, COMDAT

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 205  : 	if( lpMsg->Result == FALSE )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00010	85 c9		 test	 ecx, ecx
  00012	75 1c		 jne	 SHORT $LN2@JGServerLo

; 206  : 	{
; 207  : 		LogAdd(lMsg.Get(466));

  00014	68 d2 01 00 00	 push	 466			; 000001d2H
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002b	83 c4 04	 add	 esp, 4

; 208  : 	}

  0002e	eb 2c		 jmp	 SHORT $LN1@JGServerLo
$LN2@JGServerLo:

; 209  : 	else 
; 210  : 	{
; 211  : 		JoinServerConnected = 1;

  00030	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?JoinServerConnected@@3HA, 1 ; JoinServerConnected

; 212  : 		gServerReady++;

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gServerReady@@3HA ; gServerReady
  0003f	83 c0 01	 add	 eax, 1
  00042	a3 00 00 00 00	 mov	 DWORD PTR ?gServerReady@@3HA, eax ; gServerReady

; 213  : 		SendMessage(ghWnd, WM_ASS_CREATEGAMESERVER, 0, 0);

  00047	6a 00		 push	 0
  00049	6a 00		 push	 0
  0004b	68 05 04 00 00	 push	 1029			; 00000405H
  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00055	50		 push	 eax
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
$LN1@JGServerLo:

; 214  : 	}
; 215  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?JGServerLoginResult@@YAXPAUSDHP_RESULT@@@Z ENDP	; JGServerLoginResult
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?GJPAccountFail@@YAXFPADHH@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_number$ = 8						; size = 2
_Id$ = 12						; size = 4
_DBNumber$ = 16						; size = 4
_UserNumber$ = 20					; size = 4
?GJPAccountFail@@YAXFPADHH@Z PROC			; GJPAccountFail, COMDAT

; 594  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 595  : 	SDHP_JOINFAIL		pMsg;
; 596  : 
; 597  : 	memset( &pMsg, 0, sizeof( pMsg ));

  00013	6a 1c		 push	 28			; 0000001cH
  00015	6a 00		 push	 0
  00017	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _memset
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 598  : 
; 599  : 	pMsg.h.c		= PMHC_BYTE;

  00023	c6 45 e0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 600  : 	pMsg.h.headcode	= 0x02;

  00027	c6 45 e2 02	 mov	 BYTE PTR _pMsg$[ebp+2], 2

; 601  : 	pMsg.h.size		= sizeof( pMsg );

  0002b	c6 45 e1 1c	 mov	 BYTE PTR _pMsg$[ebp+1], 28 ; 0000001cH

; 602  : 	pMsg.Number     = number;

  0002f	66 8b 45 08	 mov	 ax, WORD PTR _number$[ebp]
  00033	66 89 45 e4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 603  : 	pMsg.DBNumber	= DBNumber;

  00037	8b 45 10	 mov	 eax, DWORD PTR _DBNumber$[ebp]
  0003a	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 604  : 	pMsg.UserNumber = UserNumber;

  0003d	8b 45 14	 mov	 eax, DWORD PTR _UserNumber$[ebp]
  00040	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 605  : 	
; 606  : 	strcpy( pMsg.Id, Id );

  00043	8b 45 0c	 mov	 eax, DWORD PTR _Id$[ebp]
  00046	50		 push	 eax
  00047	8d 4d e6	 lea	 ecx, DWORD PTR _pMsg$[ebp+6]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 _strcpy
  00050	83 c4 08	 add	 esp, 8

; 607  : 
; 608  : 	wsJServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  00053	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00057	50		 push	 eax
  00058	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005b	51		 push	 ecx
  0005c	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00061	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 609  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006c	33 cd		 xor	 ecx, ebp
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?GJPAccountFail@@YAXFPADHH@Z ENDP			; GJPAccountFail
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DragonEvent.h
;	COMDAT ?GetState@CDragonEvent@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetState@CDragonEvent@@QAEEXZ PROC			; CDragonEvent::GetState, COMDAT
; _this$ = ecx

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 31   : 		return EventState;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 32   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetState@CDragonEvent@@QAEEXZ ENDP			; CDragonEvent::GetState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TNotice.h
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 8    : inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b) { return (a << 24) + (b << 16) + (g << 8) + (r); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  0000d	c1 e0 18	 shl	 eax, 24			; 00000018H
  00010	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  00014	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00017	03 c1		 add	 eax, ecx
  00019	0f b6 55 10	 movzx	 edx, BYTE PTR _g$[ebp]
  0001d	c1 e2 08	 shl	 edx, 8
  00020	03 c2		 add	 eax, edx
  00022	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  00026	03 c1		 add	 eax, ecx
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ?GetDeductType@BILL_CLASS@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDeductType@BILL_CLASS@@QAEEXZ PROC			; BILL_CLASS::GetDeductType, COMDAT
; _this$ = ecx

; 417  : 	BYTE	GetDeductType()	{ return btDeductType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 00		 mov	 al, BYTE PTR [eax]
  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetDeductType@BILL_CLASS@@QAEEXZ ENDP			; BILL_CLASS::GetDeductType
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ?SetBill@BILL_CLASS@@QAEHEKKPAD@Z
_TEXT	SEGMENT
_bRet$ = -8						; size = 4
_this$ = -4						; size = 4
_deductType$ = 8					; size = 1
_rest_point$ = 12					; size = 4
_rest_time$ = 16					; size = 4
_ends_days$ = 20					; size = 4
?SetBill@BILL_CLASS@@QAEHEKKPAD@Z PROC			; BILL_CLASS::SetBill, COMDAT
; _this$ = ecx

; 360  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 361  : 		BOOL bRet=FALSE;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0

; 362  : 		
; 363  : 		if( btDeductType == BILL_TYPE_NONE ) bRet = TRUE;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00019	85 c9		 test	 ecx, ecx
  0001b	75 07		 jne	 SHORT $LN2@SetBill
  0001d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1
$LN2@SetBill:

; 364  : 		btDeductType		= deductType;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8a 4d 08	 mov	 cl, BYTE PTR _deductType$[ebp]
  0002a	88 08		 mov	 BYTE PTR [eax], cl

; 365  : 		
; 366  : 		dwRestPoint			= rest_point;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _rest_point$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 367  : 		dwRestTime			= rest_time;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 10	 mov	 ecx, DWORD PTR _rest_time$[ebp]
  0003b	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 368  : 		strcpy(EndsDays, ends_days);

  0003e	8b 45 14	 mov	 eax, DWORD PTR _ends_days$[ebp]
  00041	50		 push	 eax
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 _strcpy
  0004e	83 c4 08	 add	 esp, 8

; 369  : 		
; 370  : 		return bRet;

  00051	8b 45 f8	 mov	 eax, DWORD PTR _bRet$[ebp]

; 371  : 	};

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 10 00	 ret	 16			; 00000010H
?SetBill@BILL_CLASS@@QAEHEKKPAD@Z ENDP			; BILL_CLASS::SetBill
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Sprotocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
