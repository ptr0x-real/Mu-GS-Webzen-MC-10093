; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_MaxItemIndexOfEachItemType@@3PAHA		; g_MaxItemIndexOfEachItemType
PUBLIC	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A		; ItemAttribute
_BSS	SEGMENT
?g_MaxItemIndexOfEachItemType@@3PAHA DD 010H DUP (?)	; g_MaxItemIndexOfEachItemType
?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A DB 0d800H DUP (?)	; ItemAttribute
_BSS	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CItem@@QAE@XZ				; CItem::CItem
PUBLIC	?Convert@CItem@@QAEXHEEEEEE@Z			; CItem::Convert
PUBLIC	?Value@CItem@@QAEXXZ				; CItem::Value
PUBLIC	?OldValue@CItem@@QAEXXZ				; CItem::OldValue
PUBLIC	?GetSize@CItem@@QAEHAAH0@Z			; CItem::GetSize
PUBLIC	?Clear@CItem@@QAEXXZ				; CItem::Clear
PUBLIC	?IsItem@CItem@@QAEHXZ				; CItem::IsItem
PUBLIC	?IsSetItem@CItem@@QAEHXZ			; CItem::IsSetItem
PUBLIC	?GetAddStatType@CItem@@QAEHXZ			; CItem::GetAddStatType
PUBLIC	?SetPetItemInfo@CItem@@QAEXHH@Z			; CItem::SetPetItemInfo
PUBLIC	?AddPetItemExp@CItem@@QAEHH@Z			; CItem::AddPetItemExp
PUBLIC	?DecPetItemExp@CItem@@QAEHH@Z			; CItem::DecPetItemExp
PUBLIC	?PetValue@CItem@@QAEXXZ				; CItem::PetValue
PUBLIC	?PetItemLevelDown@CItem@@QAEHH@Z		; CItem::PetItemLevelDown
PUBLIC	?ItemDamageMin@CItem@@QAEHXZ			; CItem::ItemDamageMin
PUBLIC	?ItemDefense@CItem@@QAEHXZ			; CItem::ItemDefense
PUBLIC	?IsClass@CItem@@QAEHDH@Z			; CItem::IsClass
PUBLIC	?GetName@CItem@@QAEPADXZ			; CItem::GetName
PUBLIC	?GetLevel@CItem@@QAEHXZ				; CItem::GetLevel
PUBLIC	?PlusSpecial@CItem@@QAEXPAHH@Z			; CItem::PlusSpecial
PUBLIC	?PlusSpecialPercent@CItem@@QAEXPAHHG@Z		; CItem::PlusSpecialPercent
PUBLIC	?PlusSpecialPercentEx@CItem@@QAEXPAHHH@Z	; CItem::PlusSpecialPercentEx
PUBLIC	?SetItemPlusSpecialStat@CItem@@QAEXPAGH@Z	; CItem::SetItemPlusSpecialStat
PUBLIC	?GetWeaponType@CItem@@QAEHXZ			; CItem::GetWeaponType
PUBLIC	?PlusSpecialSetRing@CItem@@QAEXPAE@Z		; CItem::PlusSpecialSetRing
PUBLIC	?GetNumber@CItem@@QAEKXZ			; CItem::GetNumber
PUBLIC	?IsExtItem@CItem@@QAEHXZ			; CItem::IsExtItem
PUBLIC	?IsExtLifeAdd@CItem@@QAEHXZ			; CItem::IsExtLifeAdd
PUBLIC	?IsExtManaAdd@CItem@@QAEHXZ			; CItem::IsExtManaAdd
PUBLIC	?IsExtDamageMinus@CItem@@QAEHXZ			; CItem::IsExtDamageMinus
PUBLIC	?IsExtDamageReflect@CItem@@QAEHXZ		; CItem::IsExtDamageReflect
PUBLIC	?IsExtDefenseSuccessfull@CItem@@QAEHXZ		; CItem::IsExtDefenseSuccessfull
PUBLIC	?IsExtMonsterMoney@CItem@@QAEHXZ		; CItem::IsExtMonsterMoney
PUBLIC	?IsExtExcellentDamage@CItem@@QAEHXZ		; CItem::IsExtExcellentDamage
PUBLIC	?IsExtAttackRate@CItem@@QAEHXZ			; CItem::IsExtAttackRate
PUBLIC	?IsExtAttackRate2@CItem@@QAEHXZ			; CItem::IsExtAttackRate2
PUBLIC	?IsExtAttackSpeed@CItem@@QAEHXZ			; CItem::IsExtAttackSpeed
PUBLIC	?IsExtMonsterDieLife@CItem@@QAEHXZ		; CItem::IsExtMonsterDieLife
PUBLIC	?IsExtMonsterDieMana@CItem@@QAEHXZ		; CItem::IsExtMonsterDieMana
PUBLIC	?IsWingOpGetOnePercentDamage@CItem@@QAEHXZ	; CItem::IsWingOpGetOnePercentDamage
PUBLIC	?IsWingOpGetManaToMoster@CItem@@QAEHXZ		; CItem::IsWingOpGetManaToMoster
PUBLIC	?IsDinorantReduceAttackDamaege@CItem@@QAEHXZ	; CItem::IsDinorantReduceAttackDamaege
PUBLIC	?DurabilityDown@CItem@@QAEHHH@Z			; CItem::DurabilityDown
PUBLIC	?DurabilityDown2@CItem@@QAEHHH@Z		; CItem::DurabilityDown2
PUBLIC	?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z	; CItem::NormalWeaponDurabilityDown
PUBLIC	?BowWeaponDurabilityDown@CItem@@QAEHHH@Z	; CItem::BowWeaponDurabilityDown
PUBLIC	?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z	; CItem::StaffWeaponDurabilityDown
PUBLIC	?ArmorDurabilityDown@CItem@@QAEHHH@Z		; CItem::ArmorDurabilityDown
PUBLIC	?CheckDurabilityState@CItem@@QAEHXZ		; CItem::CheckDurabilityState
PUBLIC	?CheckExcOption@CItem@@QAEHH@Z			; CItem::CheckExcOption
PUBLIC	?OpenItemScript@@YAHPAD@Z			; OpenItemScript
PUBLIC	?OpenItemNameScript@@YAHPAD@Z			; OpenItemNameScript
PUBLIC	?ItemGetNumberMake@@YAHHH@Z			; ItemGetNumberMake
PUBLIC	?ItemGetSize@@YAXHAAH0@Z			; ItemGetSize
PUBLIC	?ItemByteConvert7@@YAXPAEQAVCItem@@H@Z		; ItemByteConvert7
PUBLIC	?ItemByteConvert10@@YAXPAEQAVCItem@@H@Z		; ItemByteConvert10
PUBLIC	?ItemByteConvert@@YAXPAEVCItem@@@Z		; ItemByteConvert
PUBLIC	?ItemByteConvert@@YAXPAEHEEEEEEE@Z		; ItemByteConvert
PUBLIC	?GetLevelItem@@YAHHHH@Z				; GetLevelItem
PUBLIC	?zzzItemLevel@@YAHHHH@Z				; zzzItemLevel
PUBLIC	?GetSerialItem@@YAHH@Z				; GetSerialItem
PUBLIC	?BufferItemtoConvert3@@YAXPAEAAHAAE2222@Z	; BufferItemtoConvert3
PUBLIC	?IsItem@@YAHH@Z					; IsItem
PUBLIC	?HasItemDurability@@YAHH@Z			; HasItemDurability
PUBLIC	?ItemGetDurability@@YAHHHHH@Z			; ItemGetDurability
PUBLIC	?ItemGetAttackDurability@@YAHH@Z		; ItemGetAttackDurability
PUBLIC	?ItemGetDefenseDurability@@YAHH@Z		; ItemGetDefenseDurability
PUBLIC	?CalRepairRate@@YAXHHPAUITEM_ATTRIBUTE@@@Z	; CalRepairRate
PUBLIC	?GetRepairItemRate@@YAMH@Z			; GetRepairItemRate
PUBLIC	?GetAllRepairItemRate@@YAMH@Z			; GetAllRepairItemRate
PUBLIC	?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z		; GetItemAttr
PUBLIC	??0CPetItemExp@@QAE@XZ				; CPetItemExp::CPetItemExp
PUBLIC	?gPetItemExp@@3VCPetItemExp@@A			; gPetItemExp
PUBLIC	??_C@_0BO@NENAGJKH@error?9L1?5?3?5ItemIndex?5error?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??IsClass@CItem@@QAEHDH@Z@4JA	; `CItem::IsClass'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@PBALLACJ@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	??_C@_0BJ@IGGPIOPD@?E?$KM?$LH?$KB?$LN?$LK?5?$LP?$KB?$LH?$KP?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0BC@PKKGKBLO@damagemin?$MA?L?50?$MA?L?$LE?Y@ ; `string'
PUBLIC	??_C@_0M@ELCONOFE@def?$MA?L?50?$MA?L?$LE?Y@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_03JBJLGPFL@end@				; `string'
PUBLIC	??_C@_0DN@NLHNDLLL@Error?5?3?5Item?5Data?5fail?4?5?$CILoopCo@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe3333333333333
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@402c000000000000
PUBLIC	__real@4039000000000000
PUBLIC	__real@403c000000000000
PUBLIC	__real@40400000
PUBLIC	__real@404c000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@41200000
PUBLIC	__real@461c4000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	_pow:PROC
EXTRN	_sqrt:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?IsSetItem@CSetItemOption@@QAEHH@Z:PROC		; CSetItemOption::IsSetItem
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__dtol3:PROC
EXTRN	__dtoui3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__ftol3:PROC
EXTRN	__ftoui3:PROC
EXTRN	__ltod3:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?gSetItemOption@@3VCSetItemOption@@A:BYTE	; gSetItemOption
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
?gPetItemExp@@3VCPetItemExp@@A DB 01a0H DUP (?)		; gPetItemExp
_BSS	ENDS
CRT$XCU	SEGMENT
?gPetItemExp$initializer$@@3P6AXXZA DD FLAT:??__EgPetItemExp@@YAXXZ ; gPetItemExp$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@404c000000000000
CONST	SEGMENT
__real@404c000000000000 DQ 0404c000000000000r	; 56
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@403c000000000000
CONST	SEGMENT
__real@403c000000000000 DQ 0403c000000000000r	; 28
CONST	ENDS
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
CONST	ENDS
;	COMDAT __real@402c000000000000
CONST	SEGMENT
__real@402c000000000000 DQ 0402c000000000000r	; 14
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3fe3333333333333
CONST	SEGMENT
__real@3fe3333333333333 DQ 03fe3333333333333r	; 0.6
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DN@NLHNDLLL@Error?5?3?5Item?5Data?5fail?4?5?$CILoopCo@
CONST	SEGMENT
??_C@_0DN@NLHNDLLL@Error?5?3?5Item?5Data?5fail?4?5?$CILoopCo@ DB 'Error :'
	DB	' Item Data fail. (LoopCount:%d) Item Type:%d Index %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end@
CONST	SEGMENT
??_C@_03JBJLGPFL@end@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ELCONOFE@def?$MA?L?50?$MA?L?$LE?Y@
CONST	SEGMENT
??_C@_0M@ELCONOFE@def?$MA?L?50?$MA?L?$LE?Y@ DB 'def', 0c0H, 0ccH, ' 0', 0c0H
	DB	0ccH, 0b4H, 0d9H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PKKGKBLO@damagemin?$MA?L?50?$MA?L?$LE?Y@
CONST	SEGMENT
??_C@_0BC@PKKGKBLO@damagemin?$MA?L?50?$MA?L?$LE?Y@ DB 'damagemin', 0c0H, 0ccH
	DB	' 0', 0c0H, 0ccH, 0b4H, 0d9H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGGPIOPD@?E?$KM?$LH?$KB?$LN?$LK?5?$LP?$KB?$LH?$KP?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BJ@IGGPIOPD@?E?$KM?$LH?$KB?$LN?$LK?5?$LP?$KB?$LH?$KP?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ@ DB 0c5H
	DB	0acH, 0b7H, 0a1H, 0bdH, 0baH, ' ', 0bfH, 0a1H, 0b7H, 0afH, ' :'
	DB	' %d (%s %d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PBALLACJ@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0DG@PBALLACJ@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onl'
	DB	'ine\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??IsClass@CItem@@QAEHDH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??IsClass@CItem@@QAEHDH@Z@4JA DD 0b6dH	; `CItem::IsClass'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@NENAGJKH@error?9L1?5?3?5ItemIndex?5error?5?$CFd@
CONST	SEGMENT
??_C@_0BO@NENAGJKH@error?9L1?5?3?5ItemIndex?5error?5?$CFd@ DB 'error-L1 :'
	DB	' ItemIndex error %d', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ??__EgPetItemExp@@YAXXZ
text$di	SEGMENT
??__EgPetItemExp@@YAXXZ PROC				; `dynamic initializer for 'gPetItemExp'', COMDAT

; 28   : CPetItemExp	gPetItemExp;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gPetItemExp@@3VCPetItemExp@@A ; gPetItemExp
  0000e	e8 00 00 00 00	 call	 ??0CPetItemExp@@QAE@XZ	; CPetItemExp::CPetItemExp
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__EgPetItemExp@@YAXXZ ENDP				; `dynamic initializer for 'gPetItemExp''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\ReadScript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 수정

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzItem.h
;	COMDAT ??0CPetItemExp@@QAE@XZ
_TEXT	SEGMENT
_x$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
??0CPetItemExp@@QAE@XZ PROC				; CPetItemExp::CPetItemExp, COMDAT
; _this$ = ecx

; 354  : 	CPetItemExp()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 355  : 	{		
; 356  : 		m_DarkSpiritExpTable[0] = 0;

  0000c	b8 04 00 00 00	 mov	 eax, 4
  00011	6b c8 00	 imul	 ecx, eax, 0
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c7 04 0a 00 00
	00 00		 mov	 DWORD PTR [edx+ecx], 0

; 357  : 		m_DarkSpiritExpTable[1] = 0;

  0001e	b8 04 00 00 00	 mov	 eax, 4
  00023	c1 e0 00	 shl	 eax, 0
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [ecx+eax], 0

; 358  : 		for( int i = 2; i < MAX_DARK_SPIRIT_LEVEL+2; i++ )

  00030	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 2
  00037	eb 09		 jmp	 SHORT $LN4@CPetItemEx
$LN2@CPetItemEx:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@CPetItemEx:
  00042	83 7d f8 34	 cmp	 DWORD PTR _i$2[ebp], 52	; 00000034H
  00046	7d 20		 jge	 SHORT $LN3@CPetItemEx

; 359  : 		{	
; 360  : 			m_DarkSpiritExpTable[i] = ((10+i)*(i)*(i)*(i)*100);

  00048	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0004b	83 c0 0a	 add	 eax, 10			; 0000000aH
  0004e	0f af 45 f8	 imul	 eax, DWORD PTR _i$2[ebp]
  00052	0f af 45 f8	 imul	 eax, DWORD PTR _i$2[ebp]
  00056	0f af 45 f8	 imul	 eax, DWORD PTR _i$2[ebp]
  0005a	6b c8 64	 imul	 ecx, eax, 100
  0005d	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 361  : 		}

  00066	eb d1		 jmp	 SHORT $LN2@CPetItemEx
$LN3@CPetItemEx:

; 362  : 
; 363  : 		m_DarkHorseExpTable[0] = 0;

  00068	b8 04 00 00 00	 mov	 eax, 4
  0006d	6b c8 00	 imul	 ecx, eax, 0
  00070	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00073	c7 84 0a d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+208], 0

; 364  : 		m_DarkHorseExpTable[1] = 0;

  0007e	b8 04 00 00 00	 mov	 eax, 4
  00083	c1 e0 00	 shl	 eax, 0
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	c7 84 01 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+208], 0

; 365  : 		for( int x = 2; x < MAX_DARK_HORSE_LEVEL+2; x++ )

  00094	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 2
  0009b	eb 09		 jmp	 SHORT $LN7@CPetItemEx
$LN5@CPetItemEx:
  0009d	8b 45 f4	 mov	 eax, DWORD PTR _x$1[ebp]
  000a0	83 c0 01	 add	 eax, 1
  000a3	89 45 f4	 mov	 DWORD PTR _x$1[ebp], eax
$LN7@CPetItemEx:
  000a6	83 7d f4 34	 cmp	 DWORD PTR _x$1[ebp], 52	; 00000034H
  000aa	7d 24		 jge	 SHORT $LN1@CPetItemEx

; 366  : 		{				
; 367  : 			m_DarkHorseExpTable[x] = ((10+x)*(x)*(x)*(x)*100);

  000ac	8b 45 f4	 mov	 eax, DWORD PTR _x$1[ebp]
  000af	83 c0 0a	 add	 eax, 10			; 0000000aH
  000b2	0f af 45 f4	 imul	 eax, DWORD PTR _x$1[ebp]
  000b6	0f af 45 f4	 imul	 eax, DWORD PTR _x$1[ebp]
  000ba	0f af 45 f4	 imul	 eax, DWORD PTR _x$1[ebp]
  000be	6b c8 64	 imul	 ecx, eax, 100
  000c1	8b 55 f4	 mov	 edx, DWORD PTR _x$1[ebp]
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	89 8c 90 d0 00
	00 00		 mov	 DWORD PTR [eax+edx*4+208], ecx

; 368  : 		}

  000ce	eb cd		 jmp	 SHORT $LN5@CPetItemEx
$LN1@CPetItemEx:

; 369  : 	}

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
??0CPetItemExp@@QAE@XZ ENDP				; CPetItemExp::CPetItemExp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z
_TEXT	SEGMENT
_item_num$ = 8						; size = 4
?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z PROC		; GetItemAttr, COMDAT

; 6031 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6032 : 	if (item_num < 0 || item_num >= MAX_ITEM)

  00009	83 7d 08 00	 cmp	 DWORD PTR _item_num$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@GetItemAtt
  0000f	81 7d 08 00 02
	00 00		 cmp	 DWORD PTR _item_num$[ebp], 512 ; 00000200H
  00016	7c 04		 jl	 SHORT $LN2@GetItemAtt
$LN3@GetItemAtt:

; 6033 : 		return FALSE;

  00018	33 c0		 xor	 eax, eax
  0001a	eb 09		 jmp	 SHORT $LN1@GetItemAtt
$LN2@GetItemAtt:

; 6034 : 
; 6035 : 	return &ItemAttribute[item_num];

  0001c	6b 45 08 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  00020	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
$LN1@GetItemAtt:

; 6036 : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z ENDP		; GetItemAttr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetAllRepairItemRate@@YAMH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetAllRepairItemRate@@YAMH@Z PROC			; GetAllRepairItemRate, COMDAT

; 4976 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4977 : 	return ItemAttribute[index].AllRepaireMoneyRate;

  00009	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0000d	d9 80 58 00 00
	00		 fld	 DWORD PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+88]

; 4978 : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?GetAllRepairItemRate@@YAMH@Z ENDP			; GetAllRepairItemRate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetRepairItemRate@@YAMH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetRepairItemRate@@YAMH@Z PROC				; GetRepairItemRate, COMDAT

; 4971 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4972 : 	return ItemAttribute[index].RepaireMoneyRate;

  00009	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0000d	d9 80 54 00 00
	00		 fld	 DWORD PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+84]

; 4973 : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?GetRepairItemRate@@YAMH@Z ENDP				; GetRepairItemRate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?CalRepairRate@@YAXHHPAUITEM_ATTRIBUTE@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
_index$ = 12						; size = 4
_p$ = 16						; size = 4
?CalRepairRate@@YAXHHPAUITEM_ATTRIBUTE@@@Z PROC		; CalRepairRate, COMDAT

; 4981 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4982 : 	// 초기 설정시에는 아이템별로 다른 수리비용 비율을 가지고 있었지만 일괄적으로 적용되게 변했다
; 4983 : 	// 나중에 또 어떻게 될지 모르기 때문에 주석만 달아 뒀다
; 4984 : 	p->RepaireMoneyRate = 0.1f;

  00009	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00014	f3 0f 11 40 54	 movss	 DWORD PTR [eax+84], xmm0

; 4985 : #ifdef MODIFY_CALREPAIRRATE_20090528
; 4986 : 	p->AllRepaireMoneyRate = 1.4f;
; 4987 : #else
; 4988 : 	p->AllRepaireMoneyRate = 0.4f;

  00019	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  0001c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00024	f3 0f 11 40 58	 movss	 DWORD PTR [eax+88], xmm0

; 4989 : #endif
; 4990 : 	/*
; 4991 : 	if(type>=0 && type<=6)
; 4992 : 	{
; 4993 : 		if( type == 4 )
; 4994 : 		{	// 요정
; 4995 : 			p->RepaireMoneyRate = 0.8f;
; 4996 : 			p->AllRepaireMoneyRate = 0.4f;
; 4997 : 		}
; 4998 : 		else if( type == 5 )
; 4999 : 		{	// 흑마법사
; 5000 : 			p->RepaireMoneyRate = 0.8f;
; 5001 : 			p->AllRepaireMoneyRate = 0.5f;
; 5002 : 		}
; 5003 : 		else
; 5004 : 		{	// 나머지
; 5005 : 			p->RepaireMoneyRate = 0.7f;
; 5006 : 			p->AllRepaireMoneyRate = 0.3f;
; 5007 : 		}
; 5008 : 		return;
; 5009 : 	}
; 5010 : 
; 5011 : 	if(type>=7 && type<=11)
; 5012 : 	{
; 5013 : 		switch(index)
; 5014 : 		{
; 5015 : 			case 0:
; 5016 : 			case 1:
; 5017 : 			case 5:
; 5018 : 			case 6:
; 5019 : 			case 8:
; 5020 : 			case 9:
; 5021 : 			case 16:
; 5022 : 				p->RepaireMoneyRate = 0.7f;
; 5023 : 				p->AllRepaireMoneyRate = 0.4f;
; 5024 : 			break;
; 5025 : 
; 5026 : 			case 2:
; 5027 : 			case 3:
; 5028 : 			case 4:
; 5029 : 			case 7:
; 5030 : 				p->RepaireMoneyRate = 0.7f;
; 5031 : 				p->AllRepaireMoneyRate = 0.6f;
; 5032 : 				break;
; 5033 : 			case 10:
; 5034 : 			case 11:
; 5035 : 			case 12:
; 5036 : 			case 13:
; 5037 : 			case 14:
; 5038 : 				p->RepaireMoneyRate = 0.8f;
; 5039 : 				p->AllRepaireMoneyRate = 0.4f;
; 5040 : 				break;
; 5041 : 			case 15:
; 5042 : 				p->RepaireMoneyRate = 0.9f;
; 5043 : 				p->AllRepaireMoneyRate = 0.4f;
; 5044 : 				break;
; 5045 : 		}
; 5046 : 		return;
; 5047 : 	}
; 5048 : 	*/
; 5049 : }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?CalRepairRate@@YAXHHPAUITEM_ATTRIBUTE@@@Z ENDP		; CalRepairRate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemGetDefenseDurability@@YAHH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?ItemGetDefenseDurability@@YAHH@Z PROC			; ItemGetDefenseDurability, COMDAT

; 4966 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4967 : 	return ItemAttribute[index].DefenceDur;

  00009	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0000d	0f b6 80 33 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+51]

; 4968 : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?ItemGetDefenseDurability@@YAHH@Z ENDP			; ItemGetDefenseDurability
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemGetAttackDurability@@YAHH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?ItemGetAttackDurability@@YAHH@Z PROC			; ItemGetAttackDurability, COMDAT

; 4961 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4962 : 	return ItemAttribute[index].AttackDur;

  00009	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0000d	0f b6 80 32 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+50]

; 4963 : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?ItemGetAttackDurability@@YAHH@Z ENDP			; ItemGetAttackDurability
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemGetDurability@@YAHHHHH@Z
_TEXT	SEGMENT
_dur$ = -4						; size = 4
_index$ = 8						; size = 4
_itemLevel$ = 12					; size = 4
_ExcellentItem$ = 16					; size = 4
_SetItem$ = 20						; size = 4
?ItemGetDurability@@YAHHHHH@Z PROC			; ItemGetDurability, COMDAT

; 4851 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4852 : 
; 4853 : #ifdef MU_CASTLESIEGE_CS_MARKS_20041214	
; 4854 : 	if (index == MAKE_ITEMNUM(14, 21) && itemLevel == 3)
; 4855 : 	{
; 4856 : 		// 성주의 표식 (레나 +3) 은 내구력이 최소 1 임 -> 레벨 수정
; 4857 : 		itemLevel = 0;
; 4858 : 	}
; 4859 : #endif
; 4860 : 
; 4861 : #ifdef HIDDEN_KALIMA_20050706	// 쿤둔의 표식은 기본 내구력이 1 이다.
; 4862 : 	if (index == MAKE_ITEMNUM(14, 29))
; 4863 : 	{
; 4864 : 		return 1;
; 4865 : 	}
; 4866 : #endif
; 4867 : 
; 4868 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029	// 행운의 동전 기본 내구력은 1
; 4869 : 	if (index == MAKE_ITEMNUM(14, 100))
; 4870 : 	{
; 4871 : 		return 1;
; 4872 : 	}
; 4873 : #endif // UPDATE_LUCKY_COIN_EVENT_20081029
; 4874 : 
; 4875 : 	int dur = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dur$[ebp], 0

; 4876 : 
; 4877 : 	// 엑설런트 아이템 이면	
; 4878 : 	if (itemLevel < 5)

  00010	83 7d 0c 05	 cmp	 DWORD PTR _itemLevel$[ebp], 5
  00014	7d 16		 jge	 SHORT $LN2@ItemGetDur

; 4879 : 	{
; 4880 : 		dur = ItemAttribute[index].Durability + itemLevel;

  00016	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0001a	0f b6 88 30 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+48]
  00021	03 4d 0c	 add	 ecx, DWORD PTR _itemLevel$[ebp]
  00024	89 4d fc	 mov	 DWORD PTR _dur$[ebp], ecx

; 4881 : 	}

  00027	e9 93 00 00 00	 jmp	 $LN3@ItemGetDur
$LN2@ItemGetDur:

; 4882 : 	else if (itemLevel >= 5)

  0002c	83 7d 0c 05	 cmp	 DWORD PTR _itemLevel$[ebp], 5
  00030	0f 8c 89 00 00
	00		 jl	 $LN3@ItemGetDur

; 4883 : 	{
; 4884 : 		if (itemLevel == 10)

  00036	83 7d 0c 0a	 cmp	 DWORD PTR _itemLevel$[ebp], 10 ; 0000000aH
  0003a	75 17		 jne	 SHORT $LN5@ItemGetDur

; 4885 : 		{
; 4886 : 			dur = ItemAttribute[index].Durability + (itemLevel * 2) - 3;

  0003c	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  00040	0f b6 88 30 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+48]
  00047	8b 55 0c	 mov	 edx, DWORD PTR _itemLevel$[ebp]
  0004a	8d 44 51 fd	 lea	 eax, DWORD PTR [ecx+edx*2-3]
  0004e	89 45 fc	 mov	 DWORD PTR _dur$[ebp], eax

; 4887 : 		}

  00051	eb 6c		 jmp	 SHORT $LN3@ItemGetDur
$LN5@ItemGetDur:

; 4888 : 		else if (itemLevel == 11)

  00053	83 7d 0c 0b	 cmp	 DWORD PTR _itemLevel$[ebp], 11 ; 0000000bH
  00057	75 17		 jne	 SHORT $LN7@ItemGetDur

; 4889 : 		{
; 4890 : 			dur = ItemAttribute[index].Durability + (itemLevel * 2) - 1;

  00059	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0005d	0f b6 88 30 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+48]
  00064	8b 55 0c	 mov	 edx, DWORD PTR _itemLevel$[ebp]
  00067	8d 44 51 ff	 lea	 eax, DWORD PTR [ecx+edx*2-1]
  0006b	89 45 fc	 mov	 DWORD PTR _dur$[ebp], eax

; 4891 : 		}

  0006e	eb 4f		 jmp	 SHORT $LN3@ItemGetDur
$LN7@ItemGetDur:

; 4892 : #ifdef ITEM_12_13_20040401
; 4893 : 		else if (itemLevel == 12)

  00070	83 7d 0c 0c	 cmp	 DWORD PTR _itemLevel$[ebp], 12 ; 0000000cH
  00074	75 17		 jne	 SHORT $LN9@ItemGetDur

; 4894 : 		{
; 4895 : 			dur = ItemAttribute[index].Durability + (itemLevel * 2) - 4 + 1 + 2 + 3;

  00076	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0007a	0f b6 88 30 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+48]
  00081	8b 55 0c	 mov	 edx, DWORD PTR _itemLevel$[ebp]
  00084	8d 44 51 02	 lea	 eax, DWORD PTR [ecx+edx*2+2]
  00088	89 45 fc	 mov	 DWORD PTR _dur$[ebp], eax

; 4896 : 		}

  0008b	eb 32		 jmp	 SHORT $LN3@ItemGetDur
$LN9@ItemGetDur:

; 4897 : 		else if (itemLevel == 13)

  0008d	83 7d 0c 0d	 cmp	 DWORD PTR _itemLevel$[ebp], 13 ; 0000000dH
  00091	75 17		 jne	 SHORT $LN11@ItemGetDur

; 4898 : 		{
; 4899 : 			dur = ItemAttribute[index].Durability + (itemLevel * 2) - 4 + 1 + 2 + 3 + 4;

  00093	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  00097	0f b6 88 30 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+48]
  0009e	8b 55 0c	 mov	 edx, DWORD PTR _itemLevel$[ebp]
  000a1	8d 44 51 06	 lea	 eax, DWORD PTR [ecx+edx*2+6]
  000a5	89 45 fc	 mov	 DWORD PTR _dur$[ebp], eax

; 4900 : 		}

  000a8	eb 15		 jmp	 SHORT $LN3@ItemGetDur
$LN11@ItemGetDur:

; 4901 : #endif
; 4902 : 		else
; 4903 : 		{
; 4904 : 			dur = ItemAttribute[index].Durability + (itemLevel * 2) - 4;

  000aa	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  000ae	0f b6 88 30 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+48]
  000b5	8b 55 0c	 mov	 edx, DWORD PTR _itemLevel$[ebp]
  000b8	8d 44 51 fc	 lea	 eax, DWORD PTR [ecx+edx*2-4]
  000bc	89 45 fc	 mov	 DWORD PTR _dur$[ebp], eax
$LN3@ItemGetDur:

; 4905 : 		}
; 4906 : 	}
; 4907 : 
; 4908 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//피의 두루마리는 내구도 1
; 4909 : 	if (index == MAKE_ITEMNUM(13, 51))	//피의 두루마리는 내구도 1
; 4910 : 	{
; 4911 : 		dur = 1;
; 4912 : 	}
; 4913 : #endif
; 4914 : 
; 4915 : 	if ((index<ITEM_WING + 3 || index>ITEM_WING + 6) &&
; 4916 : 		index != MAKE_ITEMNUM(0, 19) &&
; 4917 : 		index != MAKE_ITEMNUM(4, 18) &&

  000bf	81 7d 08 83 01
	00 00		 cmp	 DWORD PTR _index$[ebp], 387 ; 00000183H
  000c6	7c 09		 jl	 SHORT $LN14@ItemGetDur
  000c8	81 7d 08 86 01
	00 00		 cmp	 DWORD PTR _index$[ebp], 390 ; 00000186H
  000cf	7e 53		 jle	 SHORT $LN13@ItemGetDur
$LN14@ItemGetDur:
  000d1	6a 13		 push	 19			; 00000013H
  000d3	6a 00		 push	 0
  000d5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000da	83 c4 08	 add	 esp, 8
  000dd	39 45 08	 cmp	 DWORD PTR _index$[ebp], eax
  000e0	74 42		 je	 SHORT $LN13@ItemGetDur
  000e2	6a 12		 push	 18			; 00000012H
  000e4	6a 04		 push	 4
  000e6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000eb	83 c4 08	 add	 esp, 8
  000ee	39 45 08	 cmp	 DWORD PTR _index$[ebp], eax
  000f1	74 31		 je	 SHORT $LN13@ItemGetDur
  000f3	6a 0a		 push	 10			; 0000000aH
  000f5	6a 05		 push	 5
  000f7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000fc	83 c4 08	 add	 esp, 8
  000ff	39 45 08	 cmp	 DWORD PTR _index$[ebp], eax
  00102	74 20		 je	 SHORT $LN13@ItemGetDur

; 4918 : 		index != MAKE_ITEMNUM(5, 10)
; 4919 : #ifdef ADD_WEAPON_OF_ARCHANGEL_SCEPTER_20050706
; 4920 : 		&& index != MAKE_ITEMNUM(2, 13)
; 4921 : #endif
; 4922 : #ifdef MODIFY_UPGRADE_DARKLORDMANTLE_20060515
; 4923 : 		&& index != MAKE_ITEMNUM(13, 30)	// 군주의 망토 : 엑설런트 처리 없음
; 4924 : #endif		
; 4925 : #ifdef ADD_THIRD_WING_20070525	// 3차날개는 엑설런트 처리 없음
; 4926 : 		&& index != MAKE_ITEMNUM(12, 36)
; 4927 : 		&& index != MAKE_ITEMNUM(12, 37)
; 4928 : 		&& index != MAKE_ITEMNUM(12, 38)
; 4929 : 		&& index != MAKE_ITEMNUM(12, 39)
; 4930 : 		&& index != MAKE_ITEMNUM(12, 40)
; 4931 : #endif
; 4932 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 신규캐릭터 재앙의 날개, 절망의 날개, 차원의 날개는 엑설런트 처리 없음
; 4933 : 		&& index != MAKE_ITEMNUM(12, 41)
; 4934 : 		&& index != MAKE_ITEMNUM(12, 42)
; 4935 : 		&& index != MAKE_ITEMNUM(12, 43)
; 4936 : #endif
; 4937 : 		) // 추가 날개 및 절대 아이템은 엑설런트 처리 없음
; 4938 : 	{
; 4939 : 
; 4940 : 		if (SetItem)

  00104	83 7d 14 00	 cmp	 DWORD PTR _SetItem$[ebp], 0
  00108	74 0b		 je	 SHORT $LN15@ItemGetDur

; 4941 : 		{
; 4942 : 			dur += 20;

  0010a	8b 45 fc	 mov	 eax, DWORD PTR _dur$[ebp]
  0010d	83 c0 14	 add	 eax, 20			; 00000014H
  00110	89 45 fc	 mov	 DWORD PTR _dur$[ebp], eax

; 4943 : 		}

  00113	eb 0f		 jmp	 SHORT $LN13@ItemGetDur
$LN15@ItemGetDur:

; 4944 : 		else
; 4945 : 			if (ExcellentItem)

  00115	83 7d 10 00	 cmp	 DWORD PTR _ExcellentItem$[ebp], 0
  00119	74 09		 je	 SHORT $LN13@ItemGetDur

; 4946 : 			{
; 4947 : 				dur += 15;

  0011b	8b 45 fc	 mov	 eax, DWORD PTR _dur$[ebp]
  0011e	83 c0 0f	 add	 eax, 15			; 0000000fH
  00121	89 45 fc	 mov	 DWORD PTR _dur$[ebp], eax
$LN13@ItemGetDur:

; 4948 : 			}
; 4949 : 	}
; 4950 : 
; 4951 : #ifdef MODIFY_EXCELLENT_DROP_DURATION_BUG_20060524
; 4952 : 	// Dur값은 BYTE형으로 255를 넘어갈 수 없다. OverFlow 방지.
; 4953 : 	if (dur > 255)

  00124	81 7d fc ff 00
	00 00		 cmp	 DWORD PTR _dur$[ebp], 255 ; 000000ffH
  0012b	7e 07		 jle	 SHORT $LN18@ItemGetDur

; 4954 : 		dur = 255;

  0012d	c7 45 fc ff 00
	00 00		 mov	 DWORD PTR _dur$[ebp], 255 ; 000000ffH
$LN18@ItemGetDur:

; 4955 : #endif // MODIFY_EXCELLENT_DROP_DURATION_BUG_20060524
; 4956 : 
; 4957 : 	return dur;

  00134	8b 45 fc	 mov	 eax, DWORD PTR _dur$[ebp]

; 4958 : }

  00137	5f		 pop	 edi
  00138	5e		 pop	 esi
  00139	5b		 pop	 ebx
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c3		 ret	 0
?ItemGetDurability@@YAHHHHH@Z ENDP			; ItemGetDurability
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?HasItemDurability@@YAHH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?HasItemDurability@@YAHH@Z PROC				; HasItemDurability, COMDAT

; 4842 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4843 : 	if (ItemAttribute[index].Durability == 0 && ItemAttribute[index].MagicDurability == 0)

  00009	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0000d	0f b6 88 30 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+48]
  00014	85 c9		 test	 ecx, ecx
  00016	75 13		 jne	 SHORT $LN2@HasItemDur
  00018	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0001c	0f b6 88 31 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+49]
  00023	85 c9		 test	 ecx, ecx
  00025	75 04		 jne	 SHORT $LN2@HasItemDur

; 4844 : 	{
; 4845 : 		return FALSE;

  00027	33 c0		 xor	 eax, eax
  00029	eb 05		 jmp	 SHORT $LN1@HasItemDur
$LN2@HasItemDur:

; 4846 : 	}
; 4847 : 	return TRUE;

  0002b	b8 01 00 00 00	 mov	 eax, 1
$LN1@HasItemDur:

; 4848 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?HasItemDurability@@YAHH@Z ENDP				; HasItemDurability
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsItem@@YAHH@Z
_TEXT	SEGMENT
_item_num$ = 8						; size = 4
?IsItem@@YAHH@Z PROC					; IsItem, COMDAT

; 6022 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6023 : 	if (item_num < 0 || item_num >= MAX_ITEM)

  00009	83 7d 08 00	 cmp	 DWORD PTR _item_num$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@IsItem
  0000f	81 7d 08 00 02
	00 00		 cmp	 DWORD PTR _item_num$[ebp], 512 ; 00000200H
  00016	7c 04		 jl	 SHORT $LN2@IsItem
$LN3@IsItem:

; 6024 : 		return FALSE;

  00018	33 c0		 xor	 eax, eax
  0001a	eb 0b		 jmp	 SHORT $LN1@IsItem
$LN2@IsItem:

; 6025 : 
; 6026 : 	return ItemAttribute[item_num].HaveItemInfo;

  0001c	6b 45 08 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  00020	0f b6 80 20 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+32]
$LN1@IsItem:

; 6027 : }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?IsItem@@YAHH@Z ENDP					; IsItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?BufferItemtoConvert3@@YAXPAEAAHAAE2222@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_type$ = 12						; size = 4
_level$ = 16						; size = 4
_op1$ = 20						; size = 4
_op2$ = 24						; size = 4
_op3$ = 28						; size = 4
_dur$ = 32						; size = 4
?BufferItemtoConvert3@@YAXPAEAAHAAE2222@Z PROC		; BufferItemtoConvert3, COMDAT

; 4240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4241 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4242 : 	type = buf[0] + ((buf[3] & 0x80) << 1) + ((buf[5] & 0xF0) << 5);
; 4243 : #else
; 4244 : 	type = buf[0] + (((buf[3] & 0x80) >> 7) * 256);

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	6b c8 00	 imul	 ecx, eax, 0
  00011	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00014	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00018	b9 01 00 00 00	 mov	 ecx, 1
  0001d	6b d1 03	 imul	 edx, ecx, 3
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00023	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00027	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  0002d	c1 fa 07	 sar	 edx, 7
  00030	c1 e2 08	 shl	 edx, 8
  00033	03 c2		 add	 eax, edx
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  00038	89 01		 mov	 DWORD PTR [ecx], eax

; 4245 : #endif	
; 4246 : 	level = (buf[1] >> 3) & 0xF;

  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	c1 e0 00	 shl	 eax, 0
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00045	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00049	c1 fa 03	 sar	 edx, 3
  0004c	83 e2 0f	 and	 edx, 15			; 0000000fH
  0004f	8b 45 10	 mov	 eax, DWORD PTR _level$[ebp]
  00052	88 10		 mov	 BYTE PTR [eax], dl

; 4247 : 	op1 = (buf[1] >> 7) & 0x01;

  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	c1 e0 00	 shl	 eax, 0
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0005f	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00063	c1 fa 07	 sar	 edx, 7
  00066	83 e2 01	 and	 edx, 1
  00069	8b 45 14	 mov	 eax, DWORD PTR _op1$[ebp]
  0006c	88 10		 mov	 BYTE PTR [eax], dl

; 4248 : 	op2 = (buf[1] >> 2) & 0x01;

  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	c1 e0 00	 shl	 eax, 0
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00079	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0007d	c1 fa 02	 sar	 edx, 2
  00080	83 e2 01	 and	 edx, 1
  00083	8b 45 18	 mov	 eax, DWORD PTR _op2$[ebp]
  00086	88 10		 mov	 BYTE PTR [eax], dl

; 4249 : 	op3 = (buf[1] & 0x03);

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	c1 e0 00	 shl	 eax, 0
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00093	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00097	83 e2 03	 and	 edx, 3
  0009a	8b 45 1c	 mov	 eax, DWORD PTR _op3$[ebp]
  0009d	88 10		 mov	 BYTE PTR [eax], dl

; 4250 : 	dur = buf[2];

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	d1 e0		 shl	 eax, 1
  000a6	8b 4d 20	 mov	 ecx, DWORD PTR _dur$[ebp]
  000a9	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000ac	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  000af	88 01		 mov	 BYTE PTR [ecx], al

; 4251 : 
; 4252 : 	if (type == MAKE_ITEMNUM(13, 3))

  000b1	6a 03		 push	 3
  000b3	6a 0d		 push	 13			; 0000000dH
  000b5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ba	83 c4 08	 add	 esp, 8
  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  000c0	39 01		 cmp	 DWORD PTR [ecx], eax
  000c2	75 24		 jne	 SHORT $LN2@BufferItem

; 4253 : 	{
; 4254 : 		op3 |= (buf[3] & 0x40) >> 4;

  000c4	b8 01 00 00 00	 mov	 eax, 1
  000c9	6b c8 03	 imul	 ecx, eax, 3
  000cc	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000cf	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000d3	83 e0 40	 and	 eax, 64			; 00000040H
  000d6	c1 f8 04	 sar	 eax, 4
  000d9	8b 4d 1c	 mov	 ecx, DWORD PTR _op3$[ebp]
  000dc	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000df	0b d0		 or	 edx, eax
  000e1	8b 45 1c	 mov	 eax, DWORD PTR _op3$[ebp]
  000e4	88 10		 mov	 BYTE PTR [eax], dl

; 4255 : 	}

  000e6	eb 22		 jmp	 SHORT $LN1@BufferItem
$LN2@BufferItem:

; 4256 : 	else
; 4257 : 	{
; 4258 : 		if ((buf[3] & 0x40) == 0x40)

  000e8	b8 01 00 00 00	 mov	 eax, 1
  000ed	6b c8 03	 imul	 ecx, eax, 3
  000f0	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000f3	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000f7	83 e0 40	 and	 eax, 64			; 00000040H
  000fa	74 0e		 je	 SHORT $LN1@BufferItem

; 4259 : 		{
; 4260 : 			op3 += 4;

  000fc	8b 45 1c	 mov	 eax, DWORD PTR _op3$[ebp]
  000ff	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00102	83 c1 04	 add	 ecx, 4
  00105	8b 55 1c	 mov	 edx, DWORD PTR _op3$[ebp]
  00108	88 0a		 mov	 BYTE PTR [edx], cl
$LN1@BufferItem:

; 4261 : 		}
; 4262 : 	}
; 4263 : }

  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
?BufferItemtoConvert3@@YAXPAEAAHAAE2222@Z ENDP		; BufferItemtoConvert3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetSerialItem@@YAHH@Z
_TEXT	SEGMENT
_item_num$ = -4						; size = 4
_type$ = 8						; size = 4
?GetSerialItem@@YAHH@Z PROC				; GetSerialItem, COMDAT

; 6010 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6011 : 	int item_num;
; 6012 : 
; 6013 : 	item_num = type;

  00009	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _item_num$[ebp], eax

; 6014 : 
; 6015 : 	if (ItemAttribute[item_num].Level == 0xFF) return -1;	// 레벨이존재하지 않다면.

  0000f	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  00013	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  0001a	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00020	75 05		 jne	 SHORT $LN2@GetSerialI
  00022	83 c8 ff	 or	 eax, -1
  00025	eb 18		 jmp	 SHORT $LN1@GetSerialI
$LN2@GetSerialI:

; 6016 : 
; 6017 : 	if (ItemAttribute[item_num].Serial == 0) return FALSE;

  00027	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  0002b	0f be 88 25 00
	00 00		 movsx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+37]
  00032	85 c9		 test	 ecx, ecx
  00034	75 04		 jne	 SHORT $LN3@GetSerialI
  00036	33 c0		 xor	 eax, eax
  00038	eb 05		 jmp	 SHORT $LN1@GetSerialI
$LN3@GetSerialI:

; 6018 : 	return TRUE;

  0003a	b8 01 00 00 00	 mov	 eax, 1
$LN1@GetSerialI:

; 6019 : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?GetSerialItem@@YAHH@Z ENDP				; GetSerialItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?zzzItemLevel@@YAHHHH@Z
_TEXT	SEGMENT
_item_num$ = -4						; size = 4
_type$ = 8						; size = 4
_index$ = 12						; size = 4
_level$ = 16						; size = 4
?zzzItemLevel@@YAHHHH@Z PROC				; zzzItemLevel, COMDAT

; 5889 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5890 : 	int item_num;
; 5891 : 	item_num = (type*MAX_ITEM_INDEX) + index;

  00009	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  0000c	c1 e0 05	 shl	 eax, 5
  0000f	03 45 0c	 add	 eax, DWORD PTR _index$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _item_num$[ebp], eax

; 5892 : 
; 5893 : 	if (level < 0) level = 0;

  00015	83 7d 10 00	 cmp	 DWORD PTR _level$[ebp], 0
  00019	7d 07		 jge	 SHORT $LN2@zzzItemLev
  0001b	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN2@zzzItemLev:

; 5894 : 
; 5895 : 	if (ItemAttribute[item_num].Level == 0xFF) return FALSE;	// 레벨이존재하지 않다면.

  00022	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  00026	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  0002d	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00033	75 04		 jne	 SHORT $LN3@zzzItemLev
  00035	33 c0		 xor	 eax, eax
  00037	eb 2c		 jmp	 SHORT $LN1@zzzItemLev
$LN3@zzzItemLev:

; 5896 : 	if (ItemAttribute[item_num].Level == 0) return FALSE;

  00039	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  0003d	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  00044	85 c9		 test	 ecx, ecx
  00046	75 04		 jne	 SHORT $LN4@zzzItemLev
  00048	33 c0		 xor	 eax, eax
  0004a	eb 19		 jmp	 SHORT $LN1@zzzItemLev
$LN4@zzzItemLev:

; 5897 : 	if (ItemAttribute[item_num].Level < level) return TRUE;

  0004c	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  00050	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  00057	3b 4d 10	 cmp	 ecx, DWORD PTR _level$[ebp]
  0005a	7d 07		 jge	 SHORT $LN5@zzzItemLev
  0005c	b8 01 00 00 00	 mov	 eax, 1
  00061	eb 02		 jmp	 SHORT $LN1@zzzItemLev
$LN5@zzzItemLev:

; 5898 : 	return FALSE;

  00063	33 c0		 xor	 eax, eax
$LN1@zzzItemLev:

; 5899 : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?zzzItemLevel@@YAHHHH@Z ENDP				; zzzItemLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetLevelItem@@YAHHHH@Z
_TEXT	SEGMENT
_callbead_level$1 = -16					; size = 4
_callbead_level$2 = -12					; size = 4
_itemlevel$ = -8					; size = 4
_item_num$ = -4						; size = 4
_type$ = 8						; size = 4
_index$ = 12						; size = 4
_level$ = 16						; size = 4
?GetLevelItem@@YAHHHH@Z PROC				; GetLevelItem, COMDAT

; 5903 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5904 : 	int item_num;
; 5905 : 	int itemlevel;
; 5906 : 
; 5907 : 	if (level < 0) level = 0;

  00009	83 7d 10 00	 cmp	 DWORD PTR _level$[ebp], 0
  0000d	7d 07		 jge	 SHORT $LN2@GetLevelIt
  0000f	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN2@GetLevelIt:

; 5908 : 	//	level = 65;
; 5909 : 		//item_num = (type*MAX_ITEM_INDEX)+index;
; 5910 : 	item_num = MAKE_ITEMNUM(type, index);

  00016	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00023	83 c4 08	 add	 esp, 8
  00026	89 45 fc	 mov	 DWORD PTR _item_num$[ebp], eax

; 5911 : 
; 5912 : 	if (ItemAttribute[item_num].MondownFlag == 0)

  00029	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  0002d	0f b6 88 27 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+39]
  00034	85 c9		 test	 ecx, ecx
  00036	75 08		 jne	 SHORT $LN3@GetLevelIt

; 5913 : 		return -1;

  00038	83 c8 ff	 or	 eax, -1
  0003b	e9 84 01 00 00	 jmp	 $LN1@GetLevelIt
$LN3@GetLevelIt:

; 5914 : 
; 5915 : 	if (ItemAttribute[item_num].Level == 0xFF) return -1;	// 레벨이존재하지 않다면.

  00040	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  00044	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  0004b	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00051	75 08		 jne	 SHORT $LN4@GetLevelIt
  00053	83 c8 ff	 or	 eax, -1
  00056	e9 69 01 00 00	 jmp	 $LN1@GetLevelIt
$LN4@GetLevelIt:

; 5916 : 	if (ItemAttribute[item_num].Level == 0) return -1;	// 레벨이존재하지 않다면.

  0005b	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  0005f	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  00066	85 c9		 test	 ecx, ecx
  00068	75 08		 jne	 SHORT $LN5@GetLevelIt
  0006a	83 c8 ff	 or	 eax, -1
  0006d	e9 52 01 00 00	 jmp	 $LN1@GetLevelIt
$LN5@GetLevelIt:

; 5917 : 
; 5918 : 	if (type == 14)	// 사과및 물약시리즈는 

  00072	83 7d 08 0e	 cmp	 DWORD PTR _type$[ebp], 14 ; 0000000eH
  00076	75 3e		 jne	 SHORT $LN6@GetLevelIt

; 5919 : 	{
; 5920 : 		itemlevel = ItemAttribute[item_num].Level;

  00078	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  0007c	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  00083	89 4d f8	 mov	 DWORD PTR _itemlevel$[ebp], ecx

; 5921 : 
; 5922 : 		if (index == 15) return -1;	// 금이면 리턴

  00086	83 7d 0c 0f	 cmp	 DWORD PTR _index$[ebp], 15 ; 0000000fH
  0008a	75 08		 jne	 SHORT $LN7@GetLevelIt
  0008c	83 c8 ff	 or	 eax, -1
  0008f	e9 30 01 00 00	 jmp	 $LN1@GetLevelIt
$LN7@GetLevelIt:

; 5923 : 		if (itemlevel >= (level - 8) && itemlevel <= level)

  00094	8b 45 10	 mov	 eax, DWORD PTR _level$[ebp]
  00097	83 e8 08	 sub	 eax, 8
  0009a	39 45 f8	 cmp	 DWORD PTR _itemlevel$[ebp], eax
  0009d	7c 0f		 jl	 SHORT $LN8@GetLevelIt
  0009f	8b 45 f8	 mov	 eax, DWORD PTR _itemlevel$[ebp]
  000a2	3b 45 10	 cmp	 eax, DWORD PTR _level$[ebp]
  000a5	7f 07		 jg	 SHORT $LN8@GetLevelIt

; 5924 : 		{
; 5925 : 			return 0;

  000a7	33 c0		 xor	 eax, eax
  000a9	e9 16 01 00 00	 jmp	 $LN1@GetLevelIt
$LN8@GetLevelIt:

; 5926 : 		}
; 5927 : 		return -1;

  000ae	83 c8 ff	 or	 eax, -1
  000b1	e9 0e 01 00 00	 jmp	 $LN1@GetLevelIt
$LN6@GetLevelIt:

; 5928 : 	}
; 5929 : 	// 변신 반지일때는..
; 5930 : 	if (type == 13 && index == 10)

  000b6	83 7d 08 0d	 cmp	 DWORD PTR _type$[ebp], 13 ; 0000000dH
  000ba	75 65		 jne	 SHORT $LN9@GetLevelIt
  000bc	83 7d 0c 0a	 cmp	 DWORD PTR _index$[ebp], 10 ; 0000000aH
  000c0	75 5f		 jne	 SHORT $LN9@GetLevelIt

; 5931 : 	{
; 5932 : 		if ((rand() % 10) == 0)

  000c2	e8 00 00 00 00	 call	 _rand
  000c7	99		 cdq
  000c8	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000cd	f7 f9		 idiv	 ecx
  000cf	85 d2		 test	 edx, edx
  000d1	75 46		 jne	 SHORT $LN10@GetLevelIt

; 5933 : 		{
; 5934 : 			int callbead_level = 0;

  000d3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _callbead_level$2[ebp], 0

; 5935 : 			if (level < 0) level = 0;

  000da	83 7d 10 00	 cmp	 DWORD PTR _level$[ebp], 0
  000de	7d 07		 jge	 SHORT $LN11@GetLevelIt
  000e0	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN11@GetLevelIt:

; 5936 : 			callbead_level = level / 10;

  000e7	8b 45 10	 mov	 eax, DWORD PTR _level$[ebp]
  000ea	99		 cdq
  000eb	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000f0	f7 f9		 idiv	 ecx
  000f2	89 45 f4	 mov	 DWORD PTR _callbead_level$2[ebp], eax

; 5937 : 			if (callbead_level > 0) callbead_level -= 1;

  000f5	83 7d f4 00	 cmp	 DWORD PTR _callbead_level$2[ebp], 0
  000f9	7e 09		 jle	 SHORT $LN12@GetLevelIt
  000fb	8b 45 f4	 mov	 eax, DWORD PTR _callbead_level$2[ebp]
  000fe	83 e8 01	 sub	 eax, 1
  00101	89 45 f4	 mov	 DWORD PTR _callbead_level$2[ebp], eax
$LN12@GetLevelIt:

; 5938 : 			if (callbead_level > 5) callbead_level = 5;

  00104	83 7d f4 05	 cmp	 DWORD PTR _callbead_level$2[ebp], 5
  00108	7e 07		 jle	 SHORT $LN13@GetLevelIt
  0010a	c7 45 f4 05 00
	00 00		 mov	 DWORD PTR _callbead_level$2[ebp], 5
$LN13@GetLevelIt:

; 5939 : 			return callbead_level;

  00111	8b 45 f4	 mov	 eax, DWORD PTR _callbead_level$2[ebp]
  00114	e9 ab 00 00 00	 jmp	 $LN1@GetLevelIt
$LN10@GetLevelIt:

; 5940 : 		}
; 5941 : 		return -1;

  00119	83 c8 ff	 or	 eax, -1
  0011c	e9 a3 00 00 00	 jmp	 $LN1@GetLevelIt
$LN9@GetLevelIt:

; 5942 : 	}
; 5943 : 	if (type == 12 && index == 11)

  00121	83 7d 08 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  00125	75 5f		 jne	 SHORT $LN14@GetLevelIt
  00127	83 7d 0c 0b	 cmp	 DWORD PTR _index$[ebp], 11 ; 0000000bH
  0012b	75 59		 jne	 SHORT $LN14@GetLevelIt

; 5944 : 	{
; 5945 : 		if ((rand() % 10) == 0)

  0012d	e8 00 00 00 00	 call	 _rand
  00132	99		 cdq
  00133	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00138	f7 f9		 idiv	 ecx
  0013a	85 d2		 test	 edx, edx
  0013c	75 43		 jne	 SHORT $LN15@GetLevelIt

; 5946 : 		{
; 5947 : 			int callbead_level = 0;

  0013e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _callbead_level$1[ebp], 0

; 5948 : 			if (level < 0) level = 0;

  00145	83 7d 10 00	 cmp	 DWORD PTR _level$[ebp], 0
  00149	7d 07		 jge	 SHORT $LN16@GetLevelIt
  0014b	c7 45 10 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN16@GetLevelIt:

; 5949 : 			callbead_level = level / 10;

  00152	8b 45 10	 mov	 eax, DWORD PTR _level$[ebp]
  00155	99		 cdq
  00156	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0015b	f7 f9		 idiv	 ecx
  0015d	89 45 f0	 mov	 DWORD PTR _callbead_level$1[ebp], eax

; 5950 : 			if (callbead_level > 0) callbead_level -= 1;

  00160	83 7d f0 00	 cmp	 DWORD PTR _callbead_level$1[ebp], 0
  00164	7e 09		 jle	 SHORT $LN17@GetLevelIt
  00166	8b 45 f0	 mov	 eax, DWORD PTR _callbead_level$1[ebp]
  00169	83 e8 01	 sub	 eax, 1
  0016c	89 45 f0	 mov	 DWORD PTR _callbead_level$1[ebp], eax
$LN17@GetLevelIt:

; 5951 : 			if (callbead_level > 6) callbead_level = 6;

  0016f	83 7d f0 06	 cmp	 DWORD PTR _callbead_level$1[ebp], 6
  00173	7e 07		 jle	 SHORT $LN18@GetLevelIt
  00175	c7 45 f0 06 00
	00 00		 mov	 DWORD PTR _callbead_level$1[ebp], 6
$LN18@GetLevelIt:

; 5952 : 			return callbead_level;

  0017c	8b 45 f0	 mov	 eax, DWORD PTR _callbead_level$1[ebp]
  0017f	eb 43		 jmp	 SHORT $LN1@GetLevelIt
$LN15@GetLevelIt:

; 5953 : 		}
; 5954 : 		// 이번 버젼엔 소환 구슬 안나가게..
; 5955 : 		return -1;

  00181	83 c8 ff	 or	 eax, -1
  00184	eb 3e		 jmp	 SHORT $LN1@GetLevelIt
$LN14@GetLevelIt:

; 5956 : 	}
; 5957 : 
; 5958 : 	itemlevel = ItemAttribute[item_num].Level;

  00186	6b 45 fc 6c	 imul	 eax, DWORD PTR _item_num$[ebp], 108
  0018a	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  00191	89 4d f8	 mov	 DWORD PTR _itemlevel$[ebp], ecx

; 5959 : 
; 5960 : 	// 몬스터의 드롭 아이템 최대 레벨을 수정시 MAX_MONSTER_ITEM_DROP_RANGE 값을 수정해 줘야 한다.
; 5961 : 	// MAX_MONSTER_ITEM_DROP_RANGE : 현재 몬스터 레벨과 현재 아이템 드롭의 최소 몬스터 레벨간의 범위
; 5962 : #ifdef MODIFY_DROP_MAX_ITEM_LEVEL_6_OF_MONSTER_20050624
; 5963 : #define MAX_MONSTER_ITEM_DROP_RANGE   18  
; 5964 : 	if (((itemlevel) >= (level - MAX_MONSTER_ITEM_DROP_RANGE)) && (itemlevel <= level))
; 5965 : 	{
; 5966 : #else
; 5967 : #define MAX_MONSTER_ITEM_DROP_RANGE   15
; 5968 : 	if (((itemlevel) >= (level - MAX_MONSTER_ITEM_DROP_RANGE)) && (itemlevel <= level))

  00194	8b 45 10	 mov	 eax, DWORD PTR _level$[ebp]
  00197	83 e8 0f	 sub	 eax, 15			; 0000000fH
  0019a	39 45 f8	 cmp	 DWORD PTR _itemlevel$[ebp], eax
  0019d	7c 22		 jl	 SHORT $LN19@GetLevelIt
  0019f	8b 45 f8	 mov	 eax, DWORD PTR _itemlevel$[ebp]
  001a2	3b 45 10	 cmp	 eax, DWORD PTR _level$[ebp]
  001a5	7f 1a		 jg	 SHORT $LN19@GetLevelIt

; 5969 : 	{
; 5970 : #endif
; 5971 : 		if (type == 15) return 0;	// 마법서이면 + 레벨은 없다..

  001a7	83 7d 08 0f	 cmp	 DWORD PTR _type$[ebp], 15 ; 0000000fH
  001ab	75 04		 jne	 SHORT $LN20@GetLevelIt
  001ad	33 c0		 xor	 eax, eax
  001af	eb 13		 jmp	 SHORT $LN1@GetLevelIt
$LN20@GetLevelIt:

; 5972 : 
; 5973 : #ifndef MODIFY_DROP_PREVENT_OF_RING_N_NECKLACE_LV_5_OVER_20050623
; 5974 : 		return (level - itemlevel) / 3;

  001b1	8b 45 10	 mov	 eax, DWORD PTR _level$[ebp]
  001b4	2b 45 f8	 sub	 eax, DWORD PTR _itemlevel$[ebp]
  001b7	99		 cdq
  001b8	b9 03 00 00 00	 mov	 ecx, 3
  001bd	f7 f9		 idiv	 ecx
  001bf	eb 03		 jmp	 SHORT $LN1@GetLevelIt
$LN19@GetLevelIt:

; 5975 : #endif
; 5976 : 
; 5977 : #ifdef MODIFY_DROP_PREVENT_OF_RING_N_NECKLACE_LV_5_OVER_20050623
; 5978 : 		itemlevel = (level - itemlevel) / 3;
; 5979 : 
; 5980 : 		// 모든 반지와 목걸이는 레벨 4이하만 생성
; 5981 : 		if (type == 13) {
; 5982 : 			if (index == 8 || // 얼음의반지
; 5983 : 				index == 9 || // 독의반지
; 5984 : 				index == 12 || // 번개의목걸이
; 5985 : 				index == 13 || // 불의목걸이
; 5986 : 				index == 20 || // 마법사의반지
; 5987 : 				index == 21 || // 불의반지
; 5988 : 				index == 22 || // 땅의반지
; 5989 : 				index == 23 || // 바람의반지
; 5990 : 				index == 24 || // 마법의반지
; 5991 : 				index == 25 || // 얼음의목걸이
; 5992 : 				index == 26 || // 바람의목걸이 
; 5993 : 				index == 27 || // 물의목걸이
; 5994 : 				index == 28    // 기술의목걸이
; 5995 : 				) {
; 5996 : 				if (itemlevel > 4) {
; 5997 : 					itemlevel = 4;
; 5998 : 				}
; 5999 : 			}
; 6000 : 		}
; 6001 : 
; 6002 : 		return itemlevel;
; 6003 : #endif
; 6004 : 
; 6005 : 	}
; 6006 : 	return -1;

  001c1	83 c8 ff	 or	 eax, -1
$LN1@GetLevelIt:

; 6007 : 	}

  001c4	5f		 pop	 edi
  001c5	5e		 pop	 esi
  001c6	5b		 pop	 ebx
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c3		 ret	 0
?GetLevelItem@@YAHHHH@Z ENDP				; GetLevelItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemByteConvert@@YAXPAEHEEEEEEE@Z
_TEXT	SEGMENT
_n$ = -4						; size = 4
_buf$ = 8						; size = 4
_type$ = 12						; size = 4
_Option1$ = 16						; size = 1
_Option2$ = 20						; size = 1
_Option3$ = 24						; size = 1
_level$ = 28						; size = 1
_dur$ = 32						; size = 1
_Noption$ = 36						; size = 1
_SetOption$ = 40					; size = 1
?ItemByteConvert@@YAXPAEHEEEEEEE@Z PROC			; ItemByteConvert, COMDAT

; 4512 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4513 : 
; 4514 : 	// 20051114 초기화코드 넣음.
; 4515 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4516 : 	memset(buf, 0, ITEM_BUFFER_SIZE);
; 4517 : #endif
; 4518 : 
; 4519 : 	int n = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 4520 : 
; 4521 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4522 : 	buf[n] = (BYTE)(type & 0x00FF);			// [0]	아이템 번호 : 1 ~ 8번째 bit까지
; 4523 : #else
; 4524 : 	buf[n] = (BYTE)type % 256;				// Type       : 4bit

  00010	0f b6 45 0c	 movzx	 eax, BYTE PTR _type$[ebp]
  00014	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00019	79 07		 jns	 SHORT $LN5@ItemByteCo
  0001b	48		 dec	 eax
  0001c	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00021	40		 inc	 eax
$LN5@ItemByteCo:
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00025	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00028	88 01		 mov	 BYTE PTR [ecx], al

; 4525 : #endif
; 4526 : 	n++;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0002d	83 c0 01	 add	 eax, 1
  00030	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4527 : 	buf[n] = 0;

  00033	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00036	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00039	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4528 : 	buf[n] |= level << 3;						// [1]	Level		: 5bit

  0003c	0f b6 45 1c	 movzx	 eax, BYTE PTR _level$[ebp]
  00040	c1 e0 03	 shl	 eax, 3
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00046	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00049	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0004c	0b d0		 or	 edx, eax
  0004e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00051	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00054	88 10		 mov	 BYTE PTR [eax], dl

; 4529 : 	buf[n] |= Option1 << 7;					// [1]	Option 1	: 1bit

  00056	0f b6 45 10	 movzx	 eax, BYTE PTR _Option1$[ebp]
  0005a	c1 e0 07	 shl	 eax, 7
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00060	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00063	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00066	0b d0		 or	 edx, eax
  00068	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0006b	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0006e	88 10		 mov	 BYTE PTR [eax], dl

; 4530 : 	buf[n] |= Option2 << 2;					// [1]	Option 2	: 1bit

  00070	0f b6 45 14	 movzx	 eax, BYTE PTR _Option2$[ebp]
  00074	c1 e0 02	 shl	 eax, 2
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0007a	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  0007d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00080	0b d0		 or	 edx, eax
  00082	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00085	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00088	88 10		 mov	 BYTE PTR [eax], dl

; 4531 : 	buf[n] |= Option3 & 0x03;					// [1]	Option 3	: 2bit

  0008a	0f b6 45 18	 movzx	 eax, BYTE PTR _Option3$[ebp]
  0008e	83 e0 03	 and	 eax, 3
  00091	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00094	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00097	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0009a	0b d0		 or	 edx, eax
  0009c	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0009f	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000a2	88 10		 mov	 BYTE PTR [eax], dl

; 4532 : 	n++;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000a7	83 c0 01	 add	 eax, 1
  000aa	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4533 : 	buf[n] = (BYTE)dur;						// [2]	Durability	: 8bit

  000ad	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000b0	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000b3	8a 4d 20	 mov	 cl, BYTE PTR _dur$[ebp]
  000b6	88 08		 mov	 BYTE PTR [eax], cl

; 4534 : 	n++;

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000bb	83 c0 01	 add	 eax, 1
  000be	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4535 : 	buf[n] = 0;

  000c1	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000c4	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000c7	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4536 : 
; 4537 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4538 : 	buf[n] |= (BYTE)((type & 0x0100) >> 1);		// [3]	아이템 번호 : 9번째 bit
; 4539 : #else
; 4540 : 	if (type > 255)

  000ca	81 7d 0c ff 00
	00 00		 cmp	 DWORD PTR _type$[ebp], 255 ; 000000ffH
  000d1	7e 09		 jle	 SHORT $LN2@ItemByteCo

; 4541 : 		buf[n] = 0x80;

  000d3	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000d6	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000d9	c6 00 80	 mov	 BYTE PTR [eax], 128	; 00000080H
$LN2@ItemByteCo:

; 4542 : #endif
; 4543 : 
; 4544 : 	if (Option3 > 3)

  000dc	0f b6 45 18	 movzx	 eax, BYTE PTR _Option3$[ebp]
  000e0	83 f8 03	 cmp	 eax, 3
  000e3	7e 14		 jle	 SHORT $LN3@ItemByteCo

; 4545 : 		buf[n] |= 64;						// [3]	Option 3 16옵 처리

  000e5	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000e8	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000eb	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000ee	83 c9 40	 or	 ecx, 64			; 00000040H
  000f1	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000f4	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  000f7	88 0a		 mov	 BYTE PTR [edx], cl
$LN3@ItemByteCo:

; 4546 : 	buf[n] |= Noption;						// [3]	액설런트 옵션

  000f9	0f b6 45 24	 movzx	 eax, BYTE PTR _Noption$[ebp]
  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00100	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00103	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00106	0b d0		 or	 edx, eax
  00108	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0010b	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0010e	88 10		 mov	 BYTE PTR [eax], dl

; 4547 : 
; 4548 : 	n++;

  00110	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00113	83 c0 01	 add	 eax, 1
  00116	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4549 : #if GAME_VERSION >= G_V_99B
; 4550 : 	buf[n] = SetOption;						// [4]	세트 옵션 

  00119	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0011c	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0011f	8a 4d 28	 mov	 cl, BYTE PTR _SetOption$[ebp]
  00122	88 08		 mov	 BYTE PTR [eax], cl

; 4551 : #endif
; 4552 : 
; 4553 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4554 : 	n++;
; 4555 : 	buf[n] |= (BYTE)((type & 0x1E00) >> 5);		// [5]	아이템 번호 : 10 ~ 13번째 bit까지
; 4556 : 
; 4557 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 4558 : 	BYTE btItemEffeftFor380 = 0;
; 4559 : 	// 380 아이템 추가 옵션 : m_ItemOptionEx의 상위 1 bit 값
; 4560 : 	// [5] 버퍼의 상위 5 번째 값에 설정
; 4561 : 	btItemEffeftFor380 = (ItemEffectEx & 0x80) >> 4;   // 값이 8이됨.
; 4562 : 	buf[n] |= btItemEffeftFor380;
; 4563 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 4564 : 
; 4565 : 	n++;
; 4566 : 
; 4567 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 4568 : 	buf[n] = JewelOfHarmonyOption;				// [6] 조화의보석 강화 옵션 : 1바이트
; 4569 : 												// 버퍼 모두 사용
; 4570 : #else
; 4571 : 	// 예비 바이트								// [6] 예비 바이트 
; 4572 : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530	
; 4573 : #endif	
; 4574 : 
; 4575 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4576 : 	if (SocketOption != NULL)
; 4577 : 	{
; 4578 : 		buf[n] = SocketBonusOption;				// [6] 보너스 소켓 옵션 : 1바이트
; 4579 : 												// 소켓 아이템일 경우 조화의 옵션 대신 보너스 소켓 옵션이 들어간다.
; 4580 : 		n++;
; 4581 : 		buf[n] = SocketOption[0];				// [7] 소켓 옵션 : 1바이트
; 4582 : 		n++;
; 4583 : 		buf[n] = SocketOption[1];				// [8] 소켓 옵션 : 1바이트
; 4584 : 		n++;
; 4585 : 		buf[n] = SocketOption[2];				// [9] 소켓 옵션 : 1바이트
; 4586 : 		n++;
; 4587 : 		buf[n] = SocketOption[3];				// [10] 소켓 옵션 : 1바이트
; 4588 : 		n++;
; 4589 : 		buf[n] = SocketOption[4];				// [11] 소켓 옵션 : 1바이트
; 4590 : 	}
; 4591 : 	else
; 4592 : 	{
; 4593 : 		n++;
; 4594 : 		buf[n] = SOCKETSLOT_NONE;
; 4595 : 		n++;
; 4596 : 		buf[n] = SOCKETSLOT_NONE;
; 4597 : 		n++;
; 4598 : 		buf[n] = SOCKETSLOT_NONE;
; 4599 : 		n++;
; 4600 : 		buf[n] = SOCKETSLOT_NONE;
; 4601 : 		n++;
; 4602 : 		buf[n] = SOCKETSLOT_NONE;
; 4603 : 	}
; 4604 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4605 : }

  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5b		 pop	 ebx
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
?ItemByteConvert@@YAXPAEHEEEEEEE@Z ENDP			; ItemByteConvert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemByteConvert@@YAXPAEVCItem@@@Z
_TEXT	SEGMENT
_n$ = -4						; size = 4
_buf$ = 8						; size = 4
_item$ = 12						; size = 168
?ItemByteConvert@@YAXPAEVCItem@@@Z PROC			; ItemByteConvert, COMDAT

; 4403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4404 : 	int n = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 4405 : 
; 4406 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4407 : 	memset(buf, 0, ITEM_BUFFER_SIZE);
; 4408 : #endif
; 4409 : 
; 4410 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4411 : 	buf[n] = (BYTE)(item.m_Type & 0x00FF);		// [0]	아이템 번호 : 1 ~ 8번째 bit까지
; 4412 : #else
; 4413 : 	buf[n] = (BYTE)item.m_Type % 256;

  00010	0f b6 45 12	 movzx	 eax, BYTE PTR _item$[ebp+6]
  00014	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00019	79 07		 jns	 SHORT $LN5@ItemByteCo
  0001b	48		 dec	 eax
  0001c	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00021	40		 inc	 eax
$LN5@ItemByteCo:
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00025	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00028	88 01		 mov	 BYTE PTR [ecx], al

; 4414 : #endif
; 4415 : 	n++;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0002d	83 c0 01	 add	 eax, 1
  00030	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4416 : 
; 4417 : 	buf[n] = 0;

  00033	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00036	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00039	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4418 : 	buf[n] |= item.m_Level << 3;					// [1]	Level		: 5bit

  0003c	0f bf 45 14	 movsx	 eax, WORD PTR _item$[ebp+8]
  00040	c1 e0 03	 shl	 eax, 3
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00046	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00049	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0004c	0b d0		 or	 edx, eax
  0004e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00051	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00054	88 10		 mov	 BYTE PTR [eax], dl

; 4419 : 	buf[n] |= item.m_Option1 << 7;				// [1]	Option 1	: 1bit

  00056	0f b6 85 84 00
	00 00		 movzx	 eax, BYTE PTR _item$[ebp+120]
  0005d	c1 e0 07	 shl	 eax, 7
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00063	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00066	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00069	0b d0		 or	 edx, eax
  0006b	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0006e	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00071	88 10		 mov	 BYTE PTR [eax], dl

; 4420 : 	buf[n] |= item.m_Option2 << 2;				// [1]	Option 2	: 1bit

  00073	0f b6 85 85 00
	00 00		 movzx	 eax, BYTE PTR _item$[ebp+121]
  0007a	c1 e0 02	 shl	 eax, 2
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00080	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00083	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00086	0b d0		 or	 edx, eax
  00088	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0008b	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0008e	88 10		 mov	 BYTE PTR [eax], dl

; 4421 : 	buf[n] |= item.m_Option3 & 0x03;				// [1]	Option 3	: 2bit

  00090	0f b6 85 86 00
	00 00		 movzx	 eax, BYTE PTR _item$[ebp+122]
  00097	83 e0 03	 and	 eax, 3
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0009d	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  000a0	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000a3	0b d0		 or	 edx, eax
  000a5	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000a8	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000ab	88 10		 mov	 BYTE PTR [eax], dl

; 4422 : 
; 4423 : 	n++;

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000b0	83 c0 01	 add	 eax, 1
  000b3	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4424 : 	buf[n] = (BYTE)item.m_Durability;			// [2]	Durability	: 8bit

  000b6	f3 0f 2c 45 30	 cvttss2si eax, DWORD PTR _item$[ebp+36]
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000be	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  000c1	88 01		 mov	 BYTE PTR [ecx], al

; 4425 : 	n++;

  000c3	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000c6	83 c0 01	 add	 eax, 1
  000c9	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4426 : 	buf[n] = 0;

  000cc	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000cf	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000d2	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4427 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4428 : 	buf[n] |= (BYTE)((item.m_Type & 0x0100) >> 1);	// [3]	아이템 번호 : 9번째 bit
; 4429 : #else
; 4430 : 	if (item.m_Type > 255)

  000d5	0f bf 45 12	 movsx	 eax, WORD PTR _item$[ebp+6]
  000d9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000de	7e 09		 jle	 SHORT $LN2@ItemByteCo

; 4431 : 		buf[n] = 0x80;

  000e0	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000e3	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000e6	c6 00 80	 mov	 BYTE PTR [eax], 128	; 00000080H
$LN2@ItemByteCo:

; 4432 : #endif
; 4433 : 	if (item.m_Option3 > 3)

  000e9	0f b6 85 86 00
	00 00		 movzx	 eax, BYTE PTR _item$[ebp+122]
  000f0	83 f8 03	 cmp	 eax, 3
  000f3	7e 14		 jle	 SHORT $LN3@ItemByteCo

; 4434 : 		buf[n] |= 0x40;							// [3]	Option 3 16옵 처리

  000f5	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000f8	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000fb	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000fe	83 c9 40	 or	 ecx, 64			; 00000040H
  00101	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00104	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  00107	88 0a		 mov	 BYTE PTR [edx], cl
$LN3@ItemByteCo:

; 4435 : 	buf[n] |= item.m_NewOption;					// [3]	액설런트 옵션

  00109	0f b6 85 87 00
	00 00		 movzx	 eax, BYTE PTR _item$[ebp+123]
  00110	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00113	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00116	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00119	0b d0		 or	 edx, eax
  0011b	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0011e	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00121	88 10		 mov	 BYTE PTR [eax], dl

; 4436 : 
; 4437 : 	n++;

  00123	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00126	83 c0 01	 add	 eax, 1
  00129	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4438 : #if GAME_VERSION >= G_V_99B
; 4439 : 	buf[n] = item.m_SetOption;					// [4]	세트 옵션 

  0012c	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0012f	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00132	8a 8d 9e 00 00
	00		 mov	 cl, BYTE PTR _item$[ebp+146]
  00138	88 08		 mov	 BYTE PTR [eax], cl

; 4440 : #endif
; 4441 : 
; 4442 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4443 : 	n++;
; 4444 : 	buf[n] |= (BYTE)((item.m_Type & 0x1E00) >> 5);	// [5]	아이템 번호 : 10 ~ 13번째 bit까지
; 4445 : 
; 4446 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 4447 : 	BYTE btItemEffeftFor380 = 0;
; 4448 : 	// 380 아이템 추가 옵션 : m_ItemOptionEx의 상위 1 bit 값
; 4449 : 	// [5] 버퍼의 상위 5 번째 값에 설정
; 4450 : 	btItemEffeftFor380 = (item.m_ItemOptionEx & 0x80) >> 4;   // 값이 8이됨.
; 4451 : 	buf[n] |= btItemEffeftFor380;
; 4452 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 4453 : 
; 4454 : 	n++;
; 4455 : 
; 4456 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 4457 : 	buf[n] = item.m_JewelOfHarmonyOption;		// [6] 조화의보석 강화 옵션 : 1바이트
; 4458 : 												// 버퍼 모두 사용
; 4459 : #else
; 4460 : 	// 예비 바이트								// [6] 예비 바이트 
; 4461 : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 4462 : #ifndef CHARACTERDB_SERVER
; 4463 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4464 : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_02_20080630
; 4465 : 	if (g_SocketOptionSystem.IsSocketItem(&item) == true)
; 4466 : #else
; 4467 : 	if (g_SocketOptionSystem.IsEnableSocketItem(&item) == true)
; 4468 : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_02_20080630
; 4469 : 	{
; 4470 : 		buf[n] = item.m_BonusSocketOption;		// [6] 보너스 소켓 옵션 : 1바이트
; 4471 : 												// 소켓 아이템 일 경우 조화의 보석 옵션을 사용하지 않는다.
; 4472 : 	}
; 4473 : 	// 소켓 아이템 데이터를 입력한다.			// [7] ~ [11] : 소켓 아이템 정보
; 4474 : 	n++;
; 4475 : 	buf[n] = item.m_SocketOption[0];
; 4476 : 	n++;
; 4477 : 	buf[n] = item.m_SocketOption[1];
; 4478 : 	n++;
; 4479 : 	buf[n] = item.m_SocketOption[2];
; 4480 : 	n++;
; 4481 : 	buf[n] = item.m_SocketOption[3];
; 4482 : 	n++;
; 4483 : 	buf[n] = item.m_SocketOption[4];
; 4484 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4485 : #endif
; 4486 : #endif	
; 4487 : }

  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
?ItemByteConvert@@YAXPAEVCItem@@@Z ENDP			; ItemByteConvert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemByteConvert10@@YAXPAEQAVCItem@@H@Z
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv85 = -84						; size = 4
_index$1 = -16						; size = 4
_loWord$ = -12						; size = 2
_hiWord$ = -8						; size = 2
_n$ = -4						; size = 4
_buf$ = 8						; size = 4
_item$ = 12						; size = 4
_maxitem$ = 16						; size = 4
?ItemByteConvert10@@YAXPAEQAVCItem@@H@Z PROC		; ItemByteConvert10, COMDAT

; 4311 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4312 : 	int n = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 4313 : 	WORD hiWord, loWord;
; 4314 : 
; 4315 : 
; 4316 : 	// type / index, Level, Dur, Special, Number, extension
; 4317 : 	//   4  ,   4  ,   5,   3,    8        4Byte,   3Byte
; 4318 : 	for (int index = 0; index < maxitem; index++)

  00010	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _index$1[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@ItemByteCo
$LN2@ItemByteCo:
  00019	8b 45 f0	 mov	 eax, DWORD PTR _index$1[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f0	 mov	 DWORD PTR _index$1[ebp], eax
$LN4@ItemByteCo:
  00022	8b 45 f0	 mov	 eax, DWORD PTR _index$1[ebp]
  00025	3b 45 10	 cmp	 eax, DWORD PTR _maxitem$[ebp]
  00028	0f 8d a6 03 00
	00		 jge	 $LN3@ItemByteCo

; 4319 : 	{
; 4320 : #ifdef FOR_BLOODCASTLE
; 4321 : 		if (item[index].m_Type == MAKE_ITEMNUM(13, 19))

  0002e	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00038	0f bf 74 01 06	 movsx	 esi, WORD PTR [ecx+eax+6]
  0003d	6a 13		 push	 19			; 00000013H
  0003f	6a 0d		 push	 13			; 0000000dH
  00041	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00046	83 c4 08	 add	 esp, 8
  00049	3b f0		 cmp	 esi, eax
  0004b	0f 85 bd 00 00
	00		 jne	 $LN6@ItemByteCo

; 4322 : 		{		// DB에 저장하기 전에 항상 대천사 시리즈를 확인하고 존재한다면 저장대상에서 재외함.
; 4323 : 			if (CHECK_LIMIT(item[index].m_Level, 3))

  00051	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  0005b	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  00060	85 d2		 test	 edx, edx
  00062	7d 09		 jge	 SHORT $LN14@ItemByteCo
  00064	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  0006b	eb 2a		 jmp	 SHORT $LN15@ItemByteCo
$LN14@ItemByteCo:
  0006d	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00077	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  0007c	83 fa 02	 cmp	 edx, 2
  0007f	7e 09		 jle	 SHORT $LN12@ItemByteCo
  00081	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
  00088	eb 07		 jmp	 SHORT $LN13@ItemByteCo
$LN12@ItemByteCo:
  0008a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
$LN13@ItemByteCo:
  00091	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  00094	89 45 ac	 mov	 DWORD PTR tv85[ebp], eax
$LN15@ItemByteCo:
  00097	83 7d ac 00	 cmp	 DWORD PTR tv85[ebp], 0
  0009b	74 71		 je	 SHORT $LN6@ItemByteCo

; 4324 : 			{
; 4325 : 				buf[n] = 255;

  0009d	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000a0	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000a3	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH

; 4326 : 				buf[n + 1] = 255;

  000a6	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000a9	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000ac	c6 40 01 ff	 mov	 BYTE PTR [eax+1], 255	; 000000ffH

; 4327 : 				buf[n + 2] = 255;

  000b0	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000b3	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000b6	c6 40 02 ff	 mov	 BYTE PTR [eax+2], 255	; 000000ffH

; 4328 : 				buf[n + 3] = 255;

  000ba	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000bd	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000c0	c6 40 03 ff	 mov	 BYTE PTR [eax+3], 255	; 000000ffH

; 4329 : 				buf[n + 4] = 255;

  000c4	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000c7	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000ca	c6 40 04 ff	 mov	 BYTE PTR [eax+4], 255	; 000000ffH

; 4330 : 				buf[n + 5] = 255;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000d1	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000d4	c6 40 05 ff	 mov	 BYTE PTR [eax+5], 255	; 000000ffH

; 4331 : 				buf[n + 6] = 255;

  000d8	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000db	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000de	c6 40 06 ff	 mov	 BYTE PTR [eax+6], 255	; 000000ffH

; 4332 : 				buf[n + 7] = 255;

  000e2	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000e5	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000e8	c6 40 07 ff	 mov	 BYTE PTR [eax+7], 255	; 000000ffH

; 4333 : 				buf[n + 8] = 255;

  000ec	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000ef	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000f2	c6 40 08 ff	 mov	 BYTE PTR [eax+8], 255	; 000000ffH

; 4334 : 				buf[n + 9] = 255;

  000f6	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000f9	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000fc	c6 40 09 ff	 mov	 BYTE PTR [eax+9], 255	; 000000ffH

; 4335 : 				n += MAX_ITEMDBBYTE;

  00100	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00103	83 c0 0a	 add	 eax, 10			; 0000000aH
  00106	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4336 : 				continue;

  00109	e9 0b ff ff ff	 jmp	 $LN2@ItemByteCo
$LN6@ItemByteCo:

; 4337 : 			}
; 4338 : 		}
; 4339 : #endif
; 4340 : 
; 4341 : 		if (item[index].m_Type < 0)

  0010e	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00115	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00118	0f bf 54 01 06	 movsx	 edx, WORD PTR [ecx+eax+6]
  0011d	85 d2		 test	 edx, edx
  0011f	7d 71		 jge	 SHORT $LN7@ItemByteCo

; 4342 : 		{
; 4343 : 			buf[n] = 255;

  00121	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00124	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00127	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH

; 4344 : 			buf[n + 1] = 255;

  0012a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0012d	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00130	c6 40 01 ff	 mov	 BYTE PTR [eax+1], 255	; 000000ffH

; 4345 : 			buf[n + 2] = 255;

  00134	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00137	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0013a	c6 40 02 ff	 mov	 BYTE PTR [eax+2], 255	; 000000ffH

; 4346 : 			buf[n + 3] = 255;

  0013e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00141	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00144	c6 40 03 ff	 mov	 BYTE PTR [eax+3], 255	; 000000ffH

; 4347 : 			buf[n + 4] = 255;

  00148	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0014b	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0014e	c6 40 04 ff	 mov	 BYTE PTR [eax+4], 255	; 000000ffH

; 4348 : 			buf[n + 5] = 255;

  00152	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00155	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00158	c6 40 05 ff	 mov	 BYTE PTR [eax+5], 255	; 000000ffH

; 4349 : 			buf[n + 6] = 255;

  0015c	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0015f	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00162	c6 40 06 ff	 mov	 BYTE PTR [eax+6], 255	; 000000ffH

; 4350 : 			buf[n + 7] = 255;

  00166	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00169	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0016c	c6 40 07 ff	 mov	 BYTE PTR [eax+7], 255	; 000000ffH

; 4351 : 			buf[n + 8] = 255;

  00170	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00173	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00176	c6 40 08 ff	 mov	 BYTE PTR [eax+8], 255	; 000000ffH

; 4352 : 			buf[n + 9] = 255;

  0017a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0017d	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00180	c6 40 09 ff	 mov	 BYTE PTR [eax+9], 255	; 000000ffH

; 4353 : 			n += MAX_ITEMDBBYTE;

  00184	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00187	83 c0 0a	 add	 eax, 10			; 0000000aH
  0018a	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4354 : 		}

  0018d	e9 3d 02 00 00	 jmp	 $LN8@ItemByteCo
$LN7@ItemByteCo:

; 4355 : 		else
; 4356 : 		{
; 4357 : 			buf[n] = (BYTE)item[index].m_Type % 256;				// Type       : 4bit

  00192	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00199	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  0019c	0f b6 54 01 06	 movzx	 edx, BYTE PTR [ecx+eax+6]
  001a1	81 e2 ff 00 00
	80		 and	 edx, -2147483393	; 800000ffH
  001a7	79 08		 jns	 SHORT $LN16@ItemByteCo
  001a9	4a		 dec	 edx
  001aa	81 ca 00 ff ff
	ff		 or	 edx, -256		; ffffff00H
  001b0	42		 inc	 edx
$LN16@ItemByteCo:
  001b1	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  001b4	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  001b7	88 10		 mov	 BYTE PTR [eax], dl

; 4358 : 
; 4359 : 			n++;

  001b9	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  001bc	83 c0 01	 add	 eax, 1
  001bf	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4360 : 
; 4361 : 			buf[n] = 0;

  001c2	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  001c5	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  001c8	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4362 : 			buf[n] |= item[index].m_Level << 3;		// Level	: 5bit

  001cb	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  001d2	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  001d5	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  001da	c1 e2 03	 shl	 edx, 3
  001dd	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  001e0	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  001e3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001e6	0b ca		 or	 ecx, edx
  001e8	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  001eb	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  001ee	88 0a		 mov	 BYTE PTR [edx], cl

; 4363 : 			buf[n] |= item[index].m_Option1 << 7;		// Option 1 : 1bit

  001f0	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  001f7	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  001fa	0f b6 54 01 78	 movzx	 edx, BYTE PTR [ecx+eax+120]
  001ff	c1 e2 07	 shl	 edx, 7
  00202	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00205	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00208	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0020b	0b ca		 or	 ecx, edx
  0020d	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00210	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  00213	88 0a		 mov	 BYTE PTR [edx], cl

; 4364 : 			buf[n] |= item[index].m_Option2 << 2;		// Option 2 : 1bit

  00215	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  0021c	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  0021f	0f b6 54 01 79	 movzx	 edx, BYTE PTR [ecx+eax+121]
  00224	c1 e2 02	 shl	 edx, 2
  00227	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0022a	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0022d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00230	0b ca		 or	 ecx, edx
  00232	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00235	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  00238	88 0a		 mov	 BYTE PTR [edx], cl

; 4365 : 			buf[n] |= (item[index].m_Option3 & 0x03);	// Option 3 : 2bit

  0023a	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00241	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00244	0f b6 54 01 7a	 movzx	 edx, BYTE PTR [ecx+eax+122]
  00249	83 e2 03	 and	 edx, 3
  0024c	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0024f	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00252	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00255	0b ca		 or	 ecx, edx
  00257	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  0025a	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  0025d	88 0a		 mov	 BYTE PTR [edx], cl

; 4366 : 
; 4367 : 			n++;

  0025f	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00262	83 c0 01	 add	 eax, 1
  00265	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4368 : 			buf[n] = (BYTE)item[index].m_Durability;			// Durability : 8bit

  00268	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  0026f	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00272	f3 0f 2c 54 01
	24		 cvttss2si edx, DWORD PTR [ecx+eax+36]
  00278	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0027b	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0027e	88 10		 mov	 BYTE PTR [eax], dl

; 4369 : 			n++;

  00280	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00283	83 c0 01	 add	 eax, 1
  00286	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4370 : 
; 4371 : 			hiWord = HIWORD(item[index].m_Number);

  00289	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00290	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00293	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00296	c1 ea 10	 shr	 edx, 16			; 00000010H
  00299	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0029f	66 89 55 f8	 mov	 WORD PTR _hiWord$[ebp], dx

; 4372 : 			loWord = LOWORD(item[index].m_Number);

  002a3	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  002aa	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  002ad	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  002b0	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  002b6	66 89 55 f4	 mov	 WORD PTR _loWord$[ebp], dx

; 4373 : 
; 4374 : 			buf[n] = HIBYTE(hiWord);

  002ba	0f b7 45 f8	 movzx	 eax, WORD PTR _hiWord$[ebp]
  002be	c1 e8 08	 shr	 eax, 8
  002c1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002c6	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  002c9	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  002cc	88 01		 mov	 BYTE PTR [ecx], al

; 4375 : 			n++;

  002ce	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  002d1	83 c0 01	 add	 eax, 1
  002d4	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4376 : 			buf[n] = LOBYTE(hiWord);

  002d7	0f b7 45 f8	 movzx	 eax, WORD PTR _hiWord$[ebp]
  002db	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002e0	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  002e3	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  002e6	88 01		 mov	 BYTE PTR [ecx], al

; 4377 : 			n++;

  002e8	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  002eb	83 c0 01	 add	 eax, 1
  002ee	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4378 : 			buf[n] = HIBYTE(loWord);

  002f1	0f b7 45 f4	 movzx	 eax, WORD PTR _loWord$[ebp]
  002f5	c1 e8 08	 shr	 eax, 8
  002f8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002fd	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00300	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00303	88 01		 mov	 BYTE PTR [ecx], al

; 4379 : 			n++;

  00305	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00308	83 c0 01	 add	 eax, 1
  0030b	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4380 : 			buf[n] = LOBYTE(loWord);

  0030e	0f b7 45 f4	 movzx	 eax, WORD PTR _loWord$[ebp]
  00312	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00317	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0031a	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  0031d	88 01		 mov	 BYTE PTR [ecx], al

; 4381 : 			n++;

  0031f	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00322	83 c0 01	 add	 eax, 1
  00325	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4382 : 
; 4383 : 			buf[n] = 0;

  00328	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0032b	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0032e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4384 : 			if (item[index].m_Type > 255) buf[n] = 128;

  00331	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00338	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  0033b	0f bf 54 01 06	 movsx	 edx, WORD PTR [ecx+eax+6]
  00340	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00346	7e 09		 jle	 SHORT $LN9@ItemByteCo
  00348	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0034b	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0034e	c6 00 80	 mov	 BYTE PTR [eax], 128	; 00000080H
$LN9@ItemByteCo:

; 4385 : 			if (item[index].m_Option3 > 3) buf[n] |= 64;

  00351	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00358	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  0035b	0f b6 54 01 7a	 movzx	 edx, BYTE PTR [ecx+eax+122]
  00360	83 fa 03	 cmp	 edx, 3
  00363	7e 14		 jle	 SHORT $LN10@ItemByteCo
  00365	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00368	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0036b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0036e	83 c9 40	 or	 ecx, 64			; 00000040H
  00371	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00374	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  00377	88 0a		 mov	 BYTE PTR [edx], cl
$LN10@ItemByteCo:

; 4386 : 			buf[n] |= item[index].m_NewOption;

  00379	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00380	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00383	0f b6 54 01 7b	 movzx	 edx, BYTE PTR [ecx+eax+123]
  00388	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0038b	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0038e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00391	0b ca		 or	 ecx, edx
  00393	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00396	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  00399	88 0a		 mov	 BYTE PTR [edx], cl

; 4387 : 			n++;

  0039b	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0039e	83 c0 01	 add	 eax, 1
  003a1	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4388 : #if GAME_VERSION >= G_V_99B
; 4389 : 			buf[n] = item[index].m_SetOption;

  003a4	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  003ab	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  003ae	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  003b1	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  003b4	8a 84 02 92 00
	00 00		 mov	 al, BYTE PTR [edx+eax+146]
  003bb	88 01		 mov	 BYTE PTR [ecx], al

; 4390 : #endif
; 4391 : 			n++;

  003bd	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  003c0	83 c0 01	 add	 eax, 1
  003c3	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4392 : 			n++;

  003c6	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  003c9	83 c0 01	 add	 eax, 1
  003cc	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN8@ItemByteCo:

; 4393 : 		}
; 4394 : 	}

  003cf	e9 45 fc ff ff	 jmp	 $LN2@ItemByteCo
$LN3@ItemByteCo:

; 4395 : }

  003d4	5f		 pop	 edi
  003d5	5e		 pop	 esi
  003d6	5b		 pop	 ebx
  003d7	8b e5		 mov	 esp, ebp
  003d9	5d		 pop	 ebp
  003da	c3		 ret	 0
?ItemByteConvert10@@YAXPAEQAVCItem@@H@Z ENDP		; ItemByteConvert10
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemByteConvert7@@YAXPAEQAVCItem@@H@Z
_TEXT	SEGMENT
_index$1 = -16						; size = 4
_loWord$ = -12						; size = 2
_hiWord$ = -8						; size = 2
_n$ = -4						; size = 4
_buf$ = 8						; size = 4
_item$ = 12						; size = 4
_maxitem$ = 16						; size = 4
?ItemByteConvert7@@YAXPAEQAVCItem@@H@Z PROC		; ItemByteConvert7, COMDAT

; 4269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4270 : 	int n = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 4271 : 	WORD hiWord, loWord;
; 4272 : 
; 4273 : 
; 4274 : 	// type / index, Level, Dur, Special, Number
; 4275 : 	//   4  ,   4  ,   5,   3,    8        4Byte
; 4276 : 	for (int index = 0; index < maxitem; index++)

  00010	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _index$1[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@ItemByteCo
$LN2@ItemByteCo:
  00019	8b 45 f0	 mov	 eax, DWORD PTR _index$1[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f0	 mov	 DWORD PTR _index$1[ebp], eax
$LN4@ItemByteCo:
  00022	8b 45 f0	 mov	 eax, DWORD PTR _index$1[ebp]
  00025	3b 45 10	 cmp	 eax, DWORD PTR _maxitem$[ebp]
  00028	0f 8d 87 01 00
	00		 jge	 $LN3@ItemByteCo

; 4277 : 	{
; 4278 : 		buf[n] = (BYTE)item[index].m_Type;				// Type       : 4bit

  0002e	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00038	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  0003e	8a 44 02 06	 mov	 al, BYTE PTR [edx+eax+6]
  00042	88 01		 mov	 BYTE PTR [ecx], al

; 4279 : 		n++;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4280 : 
; 4281 : 		buf[n] = 0;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00050	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00053	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4282 : 		buf[n] |= item[index].m_Level << 3;		// Level	: 5bit

  00056	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00060	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  00065	c1 e2 03	 shl	 edx, 3
  00068	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0006b	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0006e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00071	0b ca		 or	 ecx, edx
  00073	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00076	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  00079	88 0a		 mov	 BYTE PTR [edx], cl

; 4283 : 		buf[n] |= item[index].m_Option1 << 7;		// Option 1 : 1bit

  0007b	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00085	0f b6 54 01 78	 movzx	 edx, BYTE PTR [ecx+eax+120]
  0008a	c1 e2 07	 shl	 edx, 7
  0008d	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00090	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00093	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00096	0b ca		 or	 ecx, edx
  00098	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  0009b	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  0009e	88 0a		 mov	 BYTE PTR [edx], cl

; 4284 : 		buf[n] |= item[index].m_Option2 << 2;		// Option 2 : 1bit

  000a0	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  000a7	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  000aa	0f b6 54 01 79	 movzx	 edx, BYTE PTR [ecx+eax+121]
  000af	c1 e2 02	 shl	 edx, 2
  000b2	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000b5	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000b8	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000bb	0b ca		 or	 ecx, edx
  000bd	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000c0	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  000c3	88 0a		 mov	 BYTE PTR [edx], cl

; 4285 : 		buf[n] |= item[index].m_Option3;			// Option 3 : 2bit

  000c5	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  000cc	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  000cf	0f b6 54 01 7a	 movzx	 edx, BYTE PTR [ecx+eax+122]
  000d4	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000d7	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000da	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000dd	0b ca		 or	 ecx, edx
  000df	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000e2	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  000e5	88 0a		 mov	 BYTE PTR [edx], cl

; 4286 : 
; 4287 : 		n++;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000ea	83 c0 01	 add	 eax, 1
  000ed	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4288 : 		buf[n] = (BYTE)item[index].m_Durability;			// Durability : 8bit

  000f0	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  000f7	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  000fa	f3 0f 2c 54 01
	24		 cvttss2si edx, DWORD PTR [ecx+eax+36]
  00100	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00103	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  00106	88 10		 mov	 BYTE PTR [eax], dl

; 4289 : 		n++;

  00108	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0010b	83 c0 01	 add	 eax, 1
  0010e	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4290 : 
; 4291 : 		hiWord = HIWORD(item[index].m_Number);

  00111	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00118	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  0011b	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0011e	c1 ea 10	 shr	 edx, 16			; 00000010H
  00121	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00127	66 89 55 f8	 mov	 WORD PTR _hiWord$[ebp], dx

; 4292 : 		loWord = LOWORD(item[index].m_Number);

  0012b	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _index$1[ebp], 168
  00132	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00135	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00138	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0013e	66 89 55 f4	 mov	 WORD PTR _loWord$[ebp], dx

; 4293 : 
; 4294 : 		buf[n] = HIBYTE(hiWord);

  00142	0f b7 45 f8	 movzx	 eax, WORD PTR _hiWord$[ebp]
  00146	c1 e8 08	 shr	 eax, 8
  00149	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0014e	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00151	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00154	88 01		 mov	 BYTE PTR [ecx], al

; 4295 : 		n++;

  00156	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00159	83 c0 01	 add	 eax, 1
  0015c	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4296 : 		buf[n] = LOBYTE(hiWord);

  0015f	0f b7 45 f8	 movzx	 eax, WORD PTR _hiWord$[ebp]
  00163	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00168	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0016b	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  0016e	88 01		 mov	 BYTE PTR [ecx], al

; 4297 : 		n++;

  00170	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00173	83 c0 01	 add	 eax, 1
  00176	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4298 : 		buf[n] = HIBYTE(loWord);

  00179	0f b7 45 f4	 movzx	 eax, WORD PTR _loWord$[ebp]
  0017d	c1 e8 08	 shr	 eax, 8
  00180	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00185	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00188	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  0018b	88 01		 mov	 BYTE PTR [ecx], al

; 4299 : 		n++;

  0018d	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00190	83 c0 01	 add	 eax, 1
  00193	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4300 : 		buf[n] = LOBYTE(loWord);

  00196	0f b7 45 f4	 movzx	 eax, WORD PTR _loWord$[ebp]
  0019a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0019f	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  001a2	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  001a5	88 01		 mov	 BYTE PTR [ecx], al

; 4301 : 		n++;

  001a7	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  001aa	83 c0 01	 add	 eax, 1
  001ad	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 4302 : 	}

  001b0	e9 64 fe ff ff	 jmp	 $LN2@ItemByteCo
$LN3@ItemByteCo:

; 4303 : }

  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx
  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
?ItemByteConvert7@@YAXPAEQAVCItem@@H@Z ENDP		; ItemByteConvert7
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemGetSize@@YAXHAAH0@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
?ItemGetSize@@YAXHAAH0@Z PROC				; ItemGetSize, COMDAT

; 4835 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4836 : 	width = ItemAttribute[index].Width;

  00009	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0000d	0f b6 88 23 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+35]
  00014	8b 55 0c	 mov	 edx, DWORD PTR _width$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 4837 : 	height = ItemAttribute[index].Height;

  00019	6b 45 08 6c	 imul	 eax, DWORD PTR _index$[ebp], 108
  0001d	0f b6 88 24 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+36]
  00024	8b 55 10	 mov	 edx, DWORD PTR _height$[ebp]
  00027	89 0a		 mov	 DWORD PTR [edx], ecx

; 4838 : }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?ItemGetSize@@YAXHAAH0@Z ENDP				; ItemGetSize
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemGetNumberMake@@YAHHH@Z
_TEXT	SEGMENT
_make$ = -4						; size = 4
_type$ = 8						; size = 4
_index$ = 12						; size = 4
?ItemGetNumberMake@@YAHHH@Z PROC			; ItemGetNumberMake, COMDAT

; 4821 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4822 : 	int make;
; 4823 : 
; 4824 : 	make = (type*MAX_ITEM_INDEX) + index;

  00009	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  0000c	c1 e0 05	 shl	 eax, 5
  0000f	03 45 0c	 add	 eax, DWORD PTR _index$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _make$[ebp], eax

; 4825 : 	if (ItemAttribute[make].Width < 1 || ItemAttribute[make].Height < 1)

  00015	6b 45 fc 6c	 imul	 eax, DWORD PTR _make$[ebp], 108
  00019	0f b6 88 23 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+35]
  00020	83 f9 01	 cmp	 ecx, 1
  00023	7c 10		 jl	 SHORT $LN3@ItemGetNum
  00025	6b 45 fc 6c	 imul	 eax, DWORD PTR _make$[ebp], 108
  00029	0f b6 88 24 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+36]
  00030	83 f9 01	 cmp	 ecx, 1
  00033	7d 05		 jge	 SHORT $LN2@ItemGetNum
$LN3@ItemGetNum:

; 4826 : 	{
; 4827 : 		return -1;

  00035	83 c8 ff	 or	 eax, -1
  00038	eb 03		 jmp	 SHORT $LN1@ItemGetNum
$LN2@ItemGetNum:

; 4828 : 	}
; 4829 : 	return make;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _make$[ebp]
$LN1@ItemGetNum:

; 4830 : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?ItemGetNumberMake@@YAHHH@Z ENDP			; ItemGetNumberMake
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?OpenItemNameScript@@YAHPAD@Z
_TEXT	SEGMENT
_p$1 = -16						; size = 4
_Index$2 = -12						; size = 4
_Type$3 = -8						; size = 4
_Token$ = -4						; size = 4
_FileName$ = 8						; size = 4
?OpenItemNameScript@@YAHPAD@Z PROC			; OpenItemNameScript, COMDAT

; 5363 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5364 : 	if ((SMDFile = fopen(FileName, "r")) == NULL)

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  0000e	8b 45 08	 mov	 eax, DWORD PTR _FileName$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _fopen
  00017	83 c4 08	 add	 esp, 8
  0001a	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  00026	75 07		 jne	 SHORT $LN6@OpenItemNa

; 5365 : 		return FALSE;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 b3 00 00 00	 jmp	 $LN1@OpenItemNa
$LN6@OpenItemNa:

; 5366 : 
; 5367 : 	SMDToken Token;
; 5368 : 	while (true)

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	85 c0		 test	 eax, eax
  00036	0f 84 93 00 00
	00		 je	 $LN3@OpenItemNa

; 5369 : 	{
; 5370 : 		Token = (*GetToken)();

  0003c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00041	89 45 fc	 mov	 DWORD PTR _Token$[ebp], eax

; 5371 : 		if (Token == END) break;

  00044	83 7d fc 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00048	75 05		 jne	 SHORT $LN7@OpenItemNa
  0004a	e9 80 00 00 00	 jmp	 $LN3@OpenItemNa
$LN7@OpenItemNa:

; 5372 : 		if (Token == NUMBER)

  0004f	83 7d fc 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00053	75 75		 jne	 SHORT $LN5@OpenItemNa

; 5373 : 		{
; 5374 : 			int Type = (int)TokenNumber;

  00055	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0005d	89 45 f8	 mov	 DWORD PTR _Type$3[ebp], eax
$LN4@OpenItemNa:

; 5375 : 			while (true)

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	85 c0		 test	 eax, eax
  00067	74 61		 je	 SHORT $LN5@OpenItemNa

; 5376 : 			{
; 5377 : 				Token = (*GetToken)();

  00069	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0006e	89 45 fc	 mov	 DWORD PTR _Token$[ebp], eax

; 5378 : 				int Index = (int)TokenNumber;

  00071	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00079	89 45 f4	 mov	 DWORD PTR _Index$2[ebp], eax

; 5379 : 				if (Token == NAME && strcmp("end", TokenString) == NULL) break;

  0007c	83 7d fc 00	 cmp	 DWORD PTR _Token$[ebp], 0
  00080	75 18		 jne	 SHORT $LN9@OpenItemNa
  00082	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  0008c	e8 00 00 00 00	 call	 _strcmp
  00091	83 c4 08	 add	 esp, 8
  00094	85 c0		 test	 eax, eax
  00096	75 02		 jne	 SHORT $LN9@OpenItemNa
  00098	eb 30		 jmp	 SHORT $LN5@OpenItemNa
$LN9@OpenItemNa:

; 5380 : 				ITEM_ATTRIBUTE *p = &ItemAttribute[Type*MAX_ITEM_INDEX + Index];

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _Type$3[ebp]
  0009d	c1 e0 05	 shl	 eax, 5
  000a0	03 45 f4	 add	 eax, DWORD PTR _Index$2[ebp]
  000a3	6b c8 6c	 imul	 ecx, eax, 108
  000a6	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  000ac	89 4d f0	 mov	 DWORD PTR _p$1[ebp], ecx

; 5381 : 				Token = (*GetToken)(); strcpy(p->Name, TokenString);

  000af	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000b4	89 45 fc	 mov	 DWORD PTR _Token$[ebp], eax
  000b7	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  000bc	8b 45 f0	 mov	 eax, DWORD PTR _p$1[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _strcpy
  000c5	83 c4 08	 add	 esp, 8

; 5382 : 			}

  000c8	eb 96		 jmp	 SHORT $LN4@OpenItemNa
$LN5@OpenItemNa:

; 5383 : 		}
; 5384 : 	}

  000ca	e9 60 ff ff ff	 jmp	 $LN6@OpenItemNa
$LN3@OpenItemNa:

; 5385 : 	fclose(SMDFile);

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _fclose
  000da	83 c4 04	 add	 esp, 4

; 5386 : 	return TRUE;

  000dd	b8 01 00 00 00	 mov	 eax, 1
$LN1@OpenItemNa:

; 5387 : }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?OpenItemNameScript@@YAHPAD@Z ENDP			; OpenItemNameScript
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?OpenItemScript@@YAHPAD@Z
_TEXT	SEGMENT
_ResiIndex$1 = -28					; size = 4
_p$2 = -24						; size = 4
_Index$3 = -20						; size = 4
_Type$4 = -16						; size = 4
_Token$ = -12						; size = 4
_n$5 = -8						; size = 4
_loop_count$ = -4					; size = 4
_FileName$ = 8						; size = 4
?OpenItemScript@@YAHPAD@Z PROC				; OpenItemScript, COMDAT

; 5068 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5069 : 	int loop_count;
; 5070 : 	if ((SMDFile = fopen(FileName, "r")) == NULL)

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  0000e	8b 45 08	 mov	 eax, DWORD PTR _FileName$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _fopen
  00017	83 c4 08	 add	 esp, 8
  0001a	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  00026	75 07		 jne	 SHORT $LN12@OpenItemSc

; 5071 : 		return FALSE;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 fb 08 00 00	 jmp	 $LN1@OpenItemSc
$LN12@OpenItemSc:

; 5072 : 
; 5073 : 	memset(&ItemAttribute, 0, sizeof(ItemAttribute));

  0002f	68 00 d8 00 00	 push	 55296			; 0000d800H
  00034	6a 00		 push	 0
  00036	68 00 00 00 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0003b	e8 00 00 00 00	 call	 _memset
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5074 : 	for (int n = 0; n < MAX_ITEM; n++)

  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$5[ebp], 0
  0004a	eb 09		 jmp	 SHORT $LN4@OpenItemSc
$LN2@OpenItemSc:
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  0004f	83 c0 01	 add	 eax, 1
  00052	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax
$LN4@OpenItemSc:
  00055	81 7d f8 00 02
	00 00		 cmp	 DWORD PTR _n$5[ebp], 512 ; 00000200H
  0005c	7d 2b		 jge	 SHORT $LN3@OpenItemSc

; 5075 : 	{
; 5076 : 		ItemAttribute[n].Level = 0xFF;

  0005e	6b 45 f8 6c	 imul	 eax, DWORD PTR _n$5[ebp], 108
  00062	c6 80 22 00 00
	00 ff		 mov	 BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34], 255 ; 000000ffH

; 5077 : 		ItemAttribute[n].RepaireMoneyRate = 0;

  00069	6b 45 f8 6c	 imul	 eax, DWORD PTR _n$5[ebp], 108
  0006d	0f 57 c0	 xorps	 xmm0, xmm0
  00070	f3 0f 11 80 54
	00 00 00	 movss	 DWORD PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+84], xmm0

; 5078 : 		ItemAttribute[n].AllRepaireMoneyRate = 0;

  00078	6b 45 f8 6c	 imul	 eax, DWORD PTR _n$5[ebp], 108
  0007c	0f 57 c0	 xorps	 xmm0, xmm0
  0007f	f3 0f 11 80 58
	00 00 00	 movss	 DWORD PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+88], xmm0

; 5079 : 	}

  00087	eb c3		 jmp	 SHORT $LN2@OpenItemSc
$LN3@OpenItemSc:

; 5080 : 
; 5081 : 	SMDToken Token;
; 5082 : 	while (true)

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	85 c0		 test	 eax, eax
  00090	0f 84 81 08 00
	00		 je	 $LN6@OpenItemSc

; 5083 : 	{
; 5084 : 		Token = (*GetToken)();

  00096	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0009b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 5085 : 		if (Token == END) break;

  0009e	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  000a2	75 05		 jne	 SHORT $LN13@OpenItemSc
  000a4	e9 6e 08 00 00	 jmp	 $LN6@OpenItemSc
$LN13@OpenItemSc:

; 5086 : 		if (Token == NUMBER)

  000a9	83 7d f4 01	 cmp	 DWORD PTR _Token$[ebp], 1
  000ad	0f 85 5f 08 00
	00		 jne	 $LN38@OpenItemSc

; 5087 : 		{
; 5088 : 			int Type = (int)TokenNumber;

  000b3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000bb	89 45 f0	 mov	 DWORD PTR _Type$4[ebp], eax

; 5089 : 			loop_count = 0;

  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _loop_count$[ebp], 0
$LN7@OpenItemSc:

; 5090 : 			while (true)

  000c5	b8 01 00 00 00	 mov	 eax, 1
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 38 08 00
	00		 je	 $LN8@OpenItemSc

; 5091 : 			{
; 5092 : 				Token = (*GetToken)();

  000d2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000d7	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 5093 : 				int Index = (int)TokenNumber;

  000da	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000e2	89 45 ec	 mov	 DWORD PTR _Index$3[ebp], eax

; 5094 : 
; 5095 : #ifdef ADD_RANDOM_RANGE_OF_ITEMINDEX_20050808
; 5096 : 				if (Type >= 0 && Type < MAX_ITEM_TYPE)

  000e5	83 7d f0 00	 cmp	 DWORD PTR _Type$4[ebp], 0
  000e9	7c 22		 jl	 SHORT $LN16@OpenItemSc
  000eb	83 7d f0 10	 cmp	 DWORD PTR _Type$4[ebp], 16 ; 00000010H
  000ef	7d 1c		 jge	 SHORT $LN16@OpenItemSc

; 5097 : 				{
; 5098 : 					// 타입의 최대 인덱스를 기록한다.
; 5099 : 					if (g_MaxItemIndexOfEachItemType[Type] <= Index)

  000f1	8b 45 f0	 mov	 eax, DWORD PTR _Type$4[ebp]
  000f4	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_MaxItemIndexOfEachItemType@@3PAHA[eax*4]
  000fb	3b 4d ec	 cmp	 ecx, DWORD PTR _Index$3[ebp]
  000fe	7f 0d		 jg	 SHORT $LN16@OpenItemSc

; 5100 : 						g_MaxItemIndexOfEachItemType[Type] = Index;

  00100	8b 45 f0	 mov	 eax, DWORD PTR _Type$4[ebp]
  00103	8b 4d ec	 mov	 ecx, DWORD PTR _Index$3[ebp]
  00106	89 0c 85 00 00
	00 00		 mov	 DWORD PTR ?g_MaxItemIndexOfEachItemType@@3PAHA[eax*4], ecx
$LN16@OpenItemSc:

; 5101 : 				}
; 5102 : #endif // ADD_RANDOM_RANGE_OF_ITEMINDEX_20050808
; 5103 : 
; 5104 : 				if (Token == NAME && strcmp("end", TokenString) == NULL) break;

  0010d	83 7d f4 00	 cmp	 DWORD PTR _Token$[ebp], 0
  00111	75 1b		 jne	 SHORT $LN17@OpenItemSc
  00113	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  0011d	e8 00 00 00 00	 call	 _strcmp
  00122	83 c4 08	 add	 esp, 8
  00125	85 c0		 test	 eax, eax
  00127	75 05		 jne	 SHORT $LN17@OpenItemSc
  00129	e9 dc 07 00 00	 jmp	 $LN8@OpenItemSc
$LN17@OpenItemSc:

; 5105 : 				ITEM_ATTRIBUTE *p = &ItemAttribute[Type*MAX_ITEM_INDEX + Index];

  0012e	8b 45 f0	 mov	 eax, DWORD PTR _Type$4[ebp]
  00131	c1 e0 05	 shl	 eax, 5
  00134	03 45 ec	 add	 eax, DWORD PTR _Index$3[ebp]
  00137	6b c8 6c	 imul	 ecx, eax, 108
  0013a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00140	89 4d e8	 mov	 DWORD PTR _p$2[ebp], ecx

; 5106 : 
; 5107 : 				Token = (*GetToken)(); p->ItemSlot = (int)TokenNumber;

  00143	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00148	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0014b	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00153	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00156	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 5108 : 				Token = (*GetToken)(); p->SkillType = (int)TokenNumber;

  00159	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0015e	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00161	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00169	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0016c	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 5109 : 
; 5110 : 				Token = (*GetToken)(); p->Width = (int)TokenNumber;

  0016f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00174	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00177	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0017f	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00182	88 41 23	 mov	 BYTE PTR [ecx+35], al

; 5111 : 				Token = (*GetToken)(); p->Height = (int)TokenNumber;

  00185	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0018a	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0018d	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00195	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00198	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 5112 : 				Token = (*GetToken)(); p->Serial = (int)TokenNumber;

  0019b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001a0	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  001a3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001ab	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  001ae	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 5113 : 				Token = (*GetToken)(); p->OptionFlag = (int)TokenNumber;

  001b1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001b6	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  001b9	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001c1	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  001c4	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 5114 : 				Token = (*GetToken)(); p->MondownFlag = (int)TokenNumber;

  001c7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001cc	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  001cf	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001d7	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  001da	88 41 27	 mov	 BYTE PTR [ecx+39], al

; 5115 : 				Token = (*GetToken)(); strcpy(p->Name, TokenString);

  001dd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001e2	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  001e5	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  001ea	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 _strcpy
  001f3	83 c4 08	 add	 esp, 8

; 5116 : 
; 5117 : #if TESTSERVER == 1
; 5118 : 				char sztext[255];
; 5119 : 				wsprintf(sztext, "%d\t%s\n", MAKE_ITEMNUM(Type, Index), p->Name);
; 5120 : 				OutputDebugString(sztext);
; 5121 : #endif
; 5122 : 
; 5123 : 				// ★ 무기, 지팡이류 
; 5124 : 				if (Type >= 0 && Type <= 5)

  001f6	83 7d f0 00	 cmp	 DWORD PTR _Type$4[ebp], 0
  001fa	0f 8c 56 01 00
	00		 jl	 $LN18@OpenItemSc
  00200	83 7d f0 05	 cmp	 DWORD PTR _Type$4[ebp], 5
  00204	0f 8f 4c 01 00
	00		 jg	 $LN18@OpenItemSc

; 5125 : 				{
; 5126 : 
; 5127 : 					// 1. > 기본 정보
; 5128 : 					Token = (*GetToken)(); p->Level = (int)TokenNumber;

  0020a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0020f	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00212	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0021a	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0021d	88 41 22	 mov	 BYTE PTR [ecx+34], al

; 5129 : 					Token = (*GetToken)(); p->DamageMin = (int)TokenNumber;

  00220	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00225	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00228	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00230	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00233	88 41 2a	 mov	 BYTE PTR [ecx+42], al

; 5130 : 					Token = (*GetToken)(); p->DamageMax = (int)TokenNumber;

  00236	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0023b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0023e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00246	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00249	88 41 2b	 mov	 BYTE PTR [ecx+43], al

; 5131 : 					Token = (*GetToken)(); p->AttackSpeed = (int)TokenNumber;

  0024c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00251	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00254	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0025c	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0025f	88 41 28	 mov	 BYTE PTR [ecx+40], al

; 5132 : 					Token = (*GetToken)(); p->Durability = (int)TokenNumber;

  00262	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00267	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0026a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00272	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00275	88 41 30	 mov	 BYTE PTR [ecx+48], al

; 5133 : 
; 5134 : 
; 5135 : 					// 2. > 마법 정보 
; 5136 : 					Token = (*GetToken)(); p->MagicDurability = (int)TokenNumber;

  00278	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0027d	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00280	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00288	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0028b	88 41 31	 mov	 BYTE PTR [ecx+49], al

; 5137 : 					Token = (*GetToken)(); p->MagicPW = (int)TokenNumber;

  0028e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00293	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00296	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0029e	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  002a1	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 5138 : 
; 5139 : 					// 3. > 요구 레벨, 스탯 정보
; 5140 : #ifdef EXPAND_ITEMSCRIPT_01_20050808 
; 5141 : 					Token = (*GetToken)(); p->RequireLevel = (int)TokenNumber; // 요구 레벨

  002a4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002a9	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  002ac	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002b4	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  002b7	66 89 41 3a	 mov	 WORD PTR [ecx+58], ax

; 5142 : #else
; 5143 : 					Token = (*GetToken)();
; 5144 : #endif
; 5145 : 					Token = (*GetToken)(); p->RequireStrength = (int)TokenNumber;	// 요구 힘

  002bb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002c0	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  002c3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002cb	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  002ce	66 89 41 34	 mov	 WORD PTR [ecx+52], ax

; 5146 : 					Token = (*GetToken)(); p->RequireDexterity = (int)TokenNumber;	// 요구 민첩

  002d2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002d7	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  002da	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002e2	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  002e5	66 89 41 36	 mov	 WORD PTR [ecx+54], ax

; 5147 : 					Token = (*GetToken)(); p->RequireEnergy = (int)TokenNumber;	// 요구 에너지

  002e9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002ee	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  002f1	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002f9	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  002fc	66 89 41 38	 mov	 WORD PTR [ecx+56], ax

; 5148 : 
; 5149 : #ifdef EXPAND_ITEMSCRIPT_01_20050808 
; 5150 : 					Token = (*GetToken)(); p->RequireVitality = (int)TokenNumber;	// 요구 레벨

  00300	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00305	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00308	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00310	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00313	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax

; 5151 : 					Token = (*GetToken)(); p->RequireLeadership = (int)TokenNumber; // 요구 통솔

  00317	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0031c	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0031f	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00327	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0032a	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 5152 : #else
; 5153 : 					Token = (*GetToken)();
; 5154 : 					Token = (*GetToken)();
; 5155 : #endif
; 5156 : 
; 5157 : 					// 4. > 부가 정보 세팅
; 5158 : 					if (p->Width >= 2) p->TwoHand = true;

  0032d	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  00330	0f b6 48 23	 movzx	 ecx, BYTE PTR [eax+35]
  00334	83 f9 02	 cmp	 ecx, 2
  00337	7c 07		 jl	 SHORT $LN19@OpenItemSc
  00339	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  0033c	c6 40 21 01	 mov	 BYTE PTR [eax+33], 1
$LN19@OpenItemSc:

; 5159 : 
; 5160 : 					// 마법 내구도와 물리 내구도는 같이 사용된다
; 5161 : 					p->Durability += p->MagicDurability;

  00340	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  00343	0f b6 48 31	 movzx	 ecx, BYTE PTR [eax+49]
  00347	8b 55 e8	 mov	 edx, DWORD PTR _p$2[ebp]
  0034a	0f b6 42 30	 movzx	 eax, BYTE PTR [edx+48]
  0034e	03 c1		 add	 eax, ecx
  00350	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00353	88 41 30	 mov	 BYTE PTR [ecx+48], al
$LN18@OpenItemSc:

; 5162 : 
; 5163 : 				}
; 5164 : 
; 5165 : 				// ★ 방패, 방어구류
; 5166 : 				if (Type >= 6 && Type <= 11)

  00356	83 7d f0 06	 cmp	 DWORD PTR _Type$4[ebp], 6
  0035a	0f 8c 96 01 00
	00		 jl	 $LN20@OpenItemSc
  00360	83 7d f0 0b	 cmp	 DWORD PTR _Type$4[ebp], 11 ; 0000000bH
  00364	0f 8f 8c 01 00
	00		 jg	 $LN20@OpenItemSc

; 5167 : 				{
; 5168 : 					// 1. > 기본 정보
; 5169 : 					Token = (*GetToken)(); p->Level = (int)TokenNumber;

  0036a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0036f	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00372	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0037a	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0037d	88 41 22	 mov	 BYTE PTR [ecx+34], al

; 5170 : 
; 5171 : 					if (Type == 6)

  00380	83 7d f0 06	 cmp	 DWORD PTR _Type$4[ebp], 6
  00384	75 31		 jne	 SHORT $LN21@OpenItemSc

; 5172 : 					{
; 5173 : 						Token = (*GetToken)(); p->Defense = (int)TokenNumber;			// 방어

  00386	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0038b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0038e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00396	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00399	88 41 2d	 mov	 BYTE PTR [ecx+45], al

; 5174 : 						Token = (*GetToken)(); p->SuccessfulBlocking = (int)TokenNumber;		// 방어 성공률			

  0039c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003a1	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  003a4	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003ac	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  003af	88 41 2c	 mov	 BYTE PTR [ecx+44], al

; 5175 : 					}

  003b2	e9 a0 00 00 00	 jmp	 $LN27@OpenItemSc
$LN21@OpenItemSc:

; 5176 : 
; 5177 : 					else if (Type >= 7 && Type <= 9)

  003b7	83 7d f0 07	 cmp	 DWORD PTR _Type$4[ebp], 7
  003bb	7c 34		 jl	 SHORT $LN23@OpenItemSc
  003bd	83 7d f0 09	 cmp	 DWORD PTR _Type$4[ebp], 9
  003c1	7f 2e		 jg	 SHORT $LN23@OpenItemSc

; 5178 : 					{
; 5179 : 						Token = (*GetToken)(); p->Defense = (int)TokenNumber;

  003c3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003c8	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  003cb	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003d3	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  003d6	88 41 2d	 mov	 BYTE PTR [ecx+45], al

; 5180 : 						Token = (*GetToken)(); p->MagicDefense = (int)TokenNumber;

  003d9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003de	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  003e1	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003e9	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  003ec	88 41 2e	 mov	 BYTE PTR [ecx+46], al

; 5181 : 					}

  003ef	eb 66		 jmp	 SHORT $LN27@OpenItemSc
$LN23@OpenItemSc:

; 5182 : 					else if (Type == 10)

  003f1	83 7d f0 0a	 cmp	 DWORD PTR _Type$4[ebp], 10 ; 0000000aH
  003f5	75 2e		 jne	 SHORT $LN25@OpenItemSc

; 5183 : 					{
; 5184 : 						Token = (*GetToken)(); p->Defense = (int)TokenNumber;

  003f7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003fc	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  003ff	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00407	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0040a	88 41 2d	 mov	 BYTE PTR [ecx+45], al

; 5185 : 						Token = (*GetToken)(); p->AttackSpeed = (int)TokenNumber;

  0040d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00412	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00415	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0041d	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00420	88 41 28	 mov	 BYTE PTR [ecx+40], al

; 5186 : 					}

  00423	eb 32		 jmp	 SHORT $LN27@OpenItemSc
$LN25@OpenItemSc:

; 5187 : 					else if (Type == 11)

  00425	83 7d f0 0b	 cmp	 DWORD PTR _Type$4[ebp], 11 ; 0000000bH
  00429	75 2c		 jne	 SHORT $LN27@OpenItemSc

; 5188 : 					{
; 5189 : 						Token = (*GetToken)(); p->Defense = (int)TokenNumber;

  0042b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00430	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00433	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0043b	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0043e	88 41 2d	 mov	 BYTE PTR [ecx+45], al

; 5190 : 						Token = (*GetToken)(); p->WalkSpeed = (int)TokenNumber;

  00441	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00446	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00449	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00451	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00454	88 41 29	 mov	 BYTE PTR [ecx+41], al
$LN27@OpenItemSc:

; 5191 : 					}
; 5192 : 					Token = (*GetToken)(); p->Durability = (int)TokenNumber;

  00457	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0045c	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0045f	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00467	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0046a	88 41 30	 mov	 BYTE PTR [ecx+48], al

; 5193 : 
; 5194 : 
; 5195 : 					// 2. > 요구 레벨, 스탯 정보
; 5196 : 
; 5197 : #ifdef EXPAND_ITEMSCRIPT_01_20050808 
; 5198 : 					Token = (*GetToken)(); p->RequireLevel = (int)TokenNumber; // 요구 레벨

  0046d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00472	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00475	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0047d	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00480	66 89 41 3a	 mov	 WORD PTR [ecx+58], ax

; 5199 : #else
; 5200 : 					Token = (*GetToken)();
; 5201 : #endif
; 5202 : 
; 5203 : 					Token = (*GetToken)(); p->RequireStrength = (int)TokenNumber;	// 요구 힘

  00484	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00489	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0048c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00494	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00497	66 89 41 34	 mov	 WORD PTR [ecx+52], ax

; 5204 : 					Token = (*GetToken)(); p->RequireDexterity = (int)TokenNumber; // 요구 민첩

  0049b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004a0	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  004a3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004ab	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  004ae	66 89 41 36	 mov	 WORD PTR [ecx+54], ax

; 5205 : 
; 5206 : #ifdef EXPAND_ITEMSCRIPT_01_20050808
; 5207 : 					Token = (*GetToken)(); p->RequireEnergy = (int)TokenNumber;	// 요구 에너지

  004b2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004b7	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  004ba	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004c2	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  004c5	66 89 41 38	 mov	 WORD PTR [ecx+56], ax

; 5208 : 					Token = (*GetToken)(); p->RequireVitality = (int)TokenNumber;	// 요구 레벨

  004c9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004ce	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  004d1	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004d9	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  004dc	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax

; 5209 : 					Token = (*GetToken)(); p->RequireLeadership = (int)TokenNumber; // 요구 통솔

  004e0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004e5	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  004e8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004f0	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  004f3	89 41 68	 mov	 DWORD PTR [ecx+104], eax
$LN20@OpenItemSc:

; 5210 : #else
; 5211 : 					if (Type == 6)
; 5212 : 					{
; 5213 : 						Token = (*GetToken)(); p->RequireEnergy = (int)TokenNumber;
; 5214 : 						Token = (*GetToken)();
; 5215 : 						Token = (*GetToken)();
; 5216 : 					}
; 5217 : 					else
; 5218 : 					{
; 5219 : 						Token = (*GetToken)();
; 5220 : 						Token = (*GetToken)();
; 5221 : 						Token = (*GetToken)();
; 5222 : 					}
; 5223 : #endif
; 5224 : 
; 5225 : 				}
; 5226 : 
; 5227 : 				// ★ 헬퍼류, 목걸이, 반지, 뿔류, 깃털, 주문서 등
; 5228 : 				if (Type == 13)

  004f6	83 7d f0 0d	 cmp	 DWORD PTR _Type$4[ebp], 13 ; 0000000dH
  004fa	0f 85 4b 01 00
	00		 jne	 $LN28@OpenItemSc

; 5229 : 				{
; 5230 : 					Token = (*GetToken)(); p->Level = (int)TokenNumber;

  00500	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00505	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00508	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00510	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00513	88 41 22	 mov	 BYTE PTR [ecx+34], al

; 5231 : 					Token = (*GetToken)(); p->Durability = (int)TokenNumber;

  00516	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0051b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0051e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00526	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00529	88 41 30	 mov	 BYTE PTR [ecx+48], al

; 5232 : 					Token = (*GetToken)(); p->Resistance[0] = (int)TokenNumber;

  0052c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00531	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00534	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0053c	b9 01 00 00 00	 mov	 ecx, 1
  00541	6b d1 00	 imul	 edx, ecx, 0
  00544	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00547	88 44 11 43	 mov	 BYTE PTR [ecx+edx+67], al

; 5233 : 					Token = (*GetToken)(); p->Resistance[1] = (int)TokenNumber;

  0054b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00550	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00553	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0055b	b9 01 00 00 00	 mov	 ecx, 1
  00560	c1 e1 00	 shl	 ecx, 0
  00563	8b 55 e8	 mov	 edx, DWORD PTR _p$2[ebp]
  00566	88 44 0a 43	 mov	 BYTE PTR [edx+ecx+67], al

; 5234 : 					Token = (*GetToken)(); p->Resistance[2] = (int)TokenNumber;

  0056a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0056f	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00572	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0057a	b9 01 00 00 00	 mov	 ecx, 1
  0057f	d1 e1		 shl	 ecx, 1
  00581	8b 55 e8	 mov	 edx, DWORD PTR _p$2[ebp]
  00584	88 44 0a 43	 mov	 BYTE PTR [edx+ecx+67], al

; 5235 : 					Token = (*GetToken)(); p->Resistance[3] = (int)TokenNumber;

  00588	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0058d	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00590	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00598	b9 01 00 00 00	 mov	 ecx, 1
  0059d	6b d1 03	 imul	 edx, ecx, 3
  005a0	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  005a3	88 44 11 43	 mov	 BYTE PTR [ecx+edx+67], al

; 5236 : 
; 5237 : 					Token = (*GetToken)(); p->Resistance[4] = (int)TokenNumber;

  005a7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005ac	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  005af	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  005b7	b9 01 00 00 00	 mov	 ecx, 1
  005bc	c1 e1 02	 shl	 ecx, 2
  005bf	8b 55 e8	 mov	 edx, DWORD PTR _p$2[ebp]
  005c2	88 44 0a 43	 mov	 BYTE PTR [edx+ecx+67], al

; 5238 : 					Token = (*GetToken)(); p->Resistance[5] = (int)TokenNumber;

  005c6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005cb	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  005ce	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  005d6	b9 01 00 00 00	 mov	 ecx, 1
  005db	6b d1 05	 imul	 edx, ecx, 5
  005de	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  005e1	88 44 11 43	 mov	 BYTE PTR [ecx+edx+67], al

; 5239 : 					Token = (*GetToken)(); p->Resistance[6] = (int)TokenNumber;

  005e5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005ea	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  005ed	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  005f5	b9 01 00 00 00	 mov	 ecx, 1
  005fa	6b d1 06	 imul	 edx, ecx, 6
  005fd	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00600	88 44 11 43	 mov	 BYTE PTR [ecx+edx+67], al

; 5240 : 
; 5241 : 					p->ResistanceType = 0xFF;

  00604	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  00607	c6 40 5e ff	 mov	 BYTE PTR [eax+94], 255	; 000000ffH

; 5242 : 					for (int ResiIndex = 0; ResiIndex < 6; ResiIndex++)

  0060b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _ResiIndex$1[ebp], 0
  00612	eb 09		 jmp	 SHORT $LN11@OpenItemSc
$LN9@OpenItemSc:
  00614	8b 45 e4	 mov	 eax, DWORD PTR _ResiIndex$1[ebp]
  00617	83 c0 01	 add	 eax, 1
  0061a	89 45 e4	 mov	 DWORD PTR _ResiIndex$1[ebp], eax
$LN11@OpenItemSc:
  0061d	83 7d e4 06	 cmp	 DWORD PTR _ResiIndex$1[ebp], 6
  00621	7d 19		 jge	 SHORT $LN10@OpenItemSc

; 5243 : 					{
; 5244 : 						if (p->Resistance[ResiIndex])

  00623	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  00626	03 45 e4	 add	 eax, DWORD PTR _ResiIndex$1[ebp]
  00629	0f b6 48 43	 movzx	 ecx, BYTE PTR [eax+67]
  0062d	85 c9		 test	 ecx, ecx
  0062f	74 09		 je	 SHORT $LN29@OpenItemSc

; 5245 : 							p->ResistanceType = ResiIndex;

  00631	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  00634	8a 4d e4	 mov	 cl, BYTE PTR _ResiIndex$1[ebp]
  00637	88 48 5e	 mov	 BYTE PTR [eax+94], cl
$LN29@OpenItemSc:

; 5246 : 					}

  0063a	eb d8		 jmp	 SHORT $LN9@OpenItemSc
$LN10@OpenItemSc:

; 5247 : 
; 5248 : 					// 목걸이, 반지의 경우 요구레벨을 아이템레벨 자체로 할당 해놨음..이런..
; 5249 : 					p->RequireLevel = p->Level;

  0063c	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  0063f	66 0f b6 48 22	 movzx	 cx, BYTE PTR [eax+34]
  00644	8b 55 e8	 mov	 edx, DWORD PTR _p$2[ebp]
  00647	66 89 4a 3a	 mov	 WORD PTR [edx+58], cx
$LN28@OpenItemSc:

; 5250 : 				}
; 5251 : 
; 5252 : 				// ★ 물약, 보석, 징표, 젠, 퀘스트 아이템 등
; 5253 : 				if (Type == 14)

  0064b	83 7d f0 0e	 cmp	 DWORD PTR _Type$4[ebp], 14 ; 0000000eH
  0064f	75 34		 jne	 SHORT $LN30@OpenItemSc

; 5254 : 				{
; 5255 : 					Token = (*GetToken)(); p->Value = (int)TokenNumber;

  00651	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00656	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00659	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00661	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00664	66 89 41 3c	 mov	 WORD PTR [ecx+60], ax

; 5256 : 					Token = (*GetToken)(); p->Level = (int)TokenNumber;

  00668	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0066d	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00670	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00678	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0067b	88 41 22	 mov	 BYTE PTR [ecx+34], al

; 5257 : 					//if( Index == 17 || Index == 18 )
; 5258 : 					//{	// 아이템에 내구도를 강제로 넣어준다(TESTSERVER1에서 사용된 아이템을 강제로 없애기 위해서)
; 5259 : 						// 악마의 눈, 열쇠
; 5260 : 					p->Durability = 1;

  0067e	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  00681	c6 40 30 01	 mov	 BYTE PTR [eax+48], 1
$LN30@OpenItemSc:

; 5261 : 					//}
; 5262 : 				}
; 5263 : 
; 5264 : 				// ★ 날개, 혼돈의보석, 스크롤, 축/영석 조합
; 5265 : 				if (Type == 12)

  00685	83 7d f0 0c	 cmp	 DWORD PTR _Type$4[ebp], 12 ; 0000000cH
  00689	0f 85 ca 00 00
	00		 jne	 $LN31@OpenItemSc

; 5266 : 				{
; 5267 : 					Token = (*GetToken)(); p->Level = (int)TokenNumber;

  0068f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00694	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00697	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0069f	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  006a2	88 41 22	 mov	 BYTE PTR [ecx+34], al

; 5268 : 					Token = (*GetToken)(); p->Defense = (int)TokenNumber;

  006a5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006aa	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  006ad	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  006b5	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  006b8	88 41 2d	 mov	 BYTE PTR [ecx+45], al

; 5269 : 					Token = (*GetToken)(); p->Durability = (int)TokenNumber;

  006bb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006c0	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  006c3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  006cb	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  006ce	88 41 30	 mov	 BYTE PTR [ecx+48], al

; 5270 : 					Token = (*GetToken)(); p->RequireLevel = (int)TokenNumber;

  006d1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006d6	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  006d9	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  006e1	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  006e4	66 89 41 3a	 mov	 WORD PTR [ecx+58], ax

; 5271 : 					Token = (*GetToken)(); p->RequireEnergy = (int)TokenNumber;

  006e8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006ed	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  006f0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  006f8	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  006fb	66 89 41 38	 mov	 WORD PTR [ecx+56], ax

; 5272 : 
; 5273 : 					Token = (*GetToken)(); p->RequireStrength = (int)TokenNumber;

  006ff	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00704	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00707	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0070f	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00712	66 89 41 34	 mov	 WORD PTR [ecx+52], ax

; 5274 : #ifdef NEW_FORSKYLAND2	// 구슬 요구 민첩 추가(20030731)					
; 5275 : 					Token = (*GetToken)(); p->RequireDexterity = (int)TokenNumber;

  00716	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0071b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0071e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00726	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00729	66 89 41 36	 mov	 WORD PTR [ecx+54], ax

; 5276 : #else
; 5277 : 					Token = (*GetToken)();
; 5278 : #endif
; 5279 : 
; 5280 : #ifdef DARKLORD_WORK // 다크 스피릿으로 인해 추가 					
; 5281 : 					Token = (*GetToken)(); p->RequireLeadership = (int)TokenNumber;

  0072d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00732	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00735	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0073d	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00740	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 5282 : #else
; 5283 : 					Token = (*GetToken)();
; 5284 : #endif
; 5285 : 
; 5286 : 					Token = (*GetToken)(); p->BuyMoney = (int)TokenNumber;

  00743	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00748	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0074b	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00753	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00756	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN31@OpenItemSc:

; 5287 : 				}
; 5288 : 
; 5289 : 				// ★ 법서
; 5290 : 				if (Type == 15)

  00759	83 7d f0 0f	 cmp	 DWORD PTR _Type$4[ebp], 15 ; 0000000fH
  0075d	0f 85 81 00 00
	00		 jne	 $LN32@OpenItemSc

; 5291 : 				{
; 5292 : 					Token = (*GetToken)(); p->Level = (int)TokenNumber;

  00763	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00768	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0076b	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00773	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00776	88 41 22	 mov	 BYTE PTR [ecx+34], al

; 5293 : 
; 5294 : #ifdef NEW_FORSKYLAND2	// 법서 요구 레벨 추가(20030725)(foguy)
; 5295 : 					Token = (*GetToken)(); p->RequireLevel = (int)TokenNumber;

  00779	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0077e	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00781	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00789	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0078c	66 89 41 3a	 mov	 WORD PTR [ecx+58], ax

; 5296 : #else
; 5297 : 					Token = (*GetToken)();
; 5298 : #endif
; 5299 : 
; 5300 : 					Token = (*GetToken)(); p->RequireEnergy = (int)TokenNumber;

  00790	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00795	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00798	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  007a0	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  007a3	66 89 41 38	 mov	 WORD PTR [ecx+56], ax

; 5301 : 
; 5302 : 					Token = (*GetToken)(); p->BuyMoney = (int)TokenNumber;

  007a7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007ac	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  007af	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  007b7	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  007ba	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 5303 : 					p->DamageMin = p->Level;

  007bd	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  007c0	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  007c3	8a 51 22	 mov	 dl, BYTE PTR [ecx+34]
  007c6	88 50 2a	 mov	 BYTE PTR [eax+42], dl

; 5304 : 					p->DamageMax = p->Level + p->Level / 2;

  007c9	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  007cc	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  007d0	8b 55 e8	 mov	 edx, DWORD PTR _p$2[ebp]
  007d3	0f b6 42 22	 movzx	 eax, BYTE PTR [edx+34]
  007d7	99		 cdq
  007d8	2b c2		 sub	 eax, edx
  007da	d1 f8		 sar	 eax, 1
  007dc	03 c8		 add	 ecx, eax
  007de	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  007e1	88 48 2b	 mov	 BYTE PTR [eax+43], cl
$LN32@OpenItemSc:

; 5305 : 
; 5306 : 				}
; 5307 : 
; 5308 : 
; 5309 : 				// 세트 속성 추가
; 5310 : 				if (Type <= 11 || Type == 13)

  007e4	83 7d f0 0b	 cmp	 DWORD PTR _Type$4[ebp], 11 ; 0000000bH
  007e8	7e 06		 jle	 SHORT $LN34@OpenItemSc
  007ea	83 7d f0 0d	 cmp	 DWORD PTR _Type$4[ebp], 13 ; 0000000dH
  007ee	75 08		 jne	 SHORT $LN33@OpenItemSc
$LN34@OpenItemSc:

; 5311 : 					Token = (*GetToken)(); p->SetAttr = (int)TokenNumber;

  007f0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007f5	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
$LN33@OpenItemSc:
  007f8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00800	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00803	88 41 5d	 mov	 BYTE PTR [ecx+93], al

; 5312 : 
; 5313 : 				//사용 클래스
; 5314 : 				if (Type <= 13 || Type == 15)

  00806	83 7d f0 0d	 cmp	 DWORD PTR _Type$4[ebp], 13 ; 0000000dH
  0080a	7e 0a		 jle	 SHORT $LN36@OpenItemSc
  0080c	83 7d f0 0f	 cmp	 DWORD PTR _Type$4[ebp], 15 ; 0000000fH
  00810	0f 85 aa 00 00
	00		 jne	 $LN35@OpenItemSc
$LN36@OpenItemSc:

; 5315 : 				{
; 5316 : 					Token = (*GetToken)(); p->RequireClass[0] = (int)TokenNumber;

  00816	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0081b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0081e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00826	b9 01 00 00 00	 mov	 ecx, 1
  0082b	6b d1 00	 imul	 edx, ecx, 0
  0082e	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00831	88 44 11 3e	 mov	 BYTE PTR [ecx+edx+62], al

; 5317 : 					Token = (*GetToken)(); p->RequireClass[1] = (int)TokenNumber;

  00835	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0083a	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0083d	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00845	b9 01 00 00 00	 mov	 ecx, 1
  0084a	c1 e1 00	 shl	 ecx, 0
  0084d	8b 55 e8	 mov	 edx, DWORD PTR _p$2[ebp]
  00850	88 44 0a 3e	 mov	 BYTE PTR [edx+ecx+62], al

; 5318 : 					Token = (*GetToken)(); p->RequireClass[2] = (int)TokenNumber;

  00854	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00859	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0085c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00864	b9 01 00 00 00	 mov	 ecx, 1
  00869	d1 e1		 shl	 ecx, 1
  0086b	8b 55 e8	 mov	 edx, DWORD PTR _p$2[ebp]
  0086e	88 44 0a 3e	 mov	 BYTE PTR [edx+ecx+62], al

; 5319 : 					Token = (*GetToken)(); p->RequireClass[3] = (int)TokenNumber;

  00872	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00877	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0087a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00882	b9 01 00 00 00	 mov	 ecx, 1
  00887	6b d1 03	 imul	 edx, ecx, 3
  0088a	8b 4d e8	 mov	 ecx, DWORD PTR _p$2[ebp]
  0088d	88 44 11 3e	 mov	 BYTE PTR [ecx+edx+62], al

; 5320 : 
; 5321 : #ifdef DARKLORD_WORK	
; 5322 : 					// 다크로드
; 5323 : 					Token = (*GetToken)(); p->RequireClass[4] = (int)TokenNumber;

  00891	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00896	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00899	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  008a1	b9 01 00 00 00	 mov	 ecx, 1
  008a6	c1 e1 02	 shl	 ecx, 2
  008a9	8b 55 e8	 mov	 edx, DWORD PTR _p$2[ebp]
  008ac	88 44 0a 3e	 mov	 BYTE PTR [edx+ecx+62], al

; 5324 : #else
; 5325 : 					Token = (*GetToken)();
; 5326 : #endif
; 5327 : 
; 5328 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// item 사용 클래스 추가
; 5329 : 					Token = (*GetToken)(); p->RequireClass[5] = (int)TokenNumber;
; 5330 : #else
; 5331 : 					Token = (*GetToken)();

  008b0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  008b5	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 5332 : #endif
; 5333 : 
; 5334 : 					Token = (*GetToken)(); //Rage Fighter Bypass

  008b8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  008bd	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
$LN35@OpenItemSc:

; 5335 : 				}
; 5336 : 
; 5337 : 				// 아이템 수리비용 비율을 설정한다
; 5338 : 				CalRepairRate(Type, Index, p);

  008c0	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  008c3	50		 push	 eax
  008c4	8b 4d ec	 mov	 ecx, DWORD PTR _Index$3[ebp]
  008c7	51		 push	 ecx
  008c8	8b 55 f0	 mov	 edx, DWORD PTR _Type$4[ebp]
  008cb	52		 push	 edx
  008cc	e8 00 00 00 00	 call	 ?CalRepairRate@@YAXHHPAUITEM_ATTRIBUTE@@@Z ; CalRepairRate
  008d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5339 : 				p->HaveItemInfo = TRUE;

  008d4	8b 45 e8	 mov	 eax, DWORD PTR _p$2[ebp]
  008d7	c6 40 20 01	 mov	 BYTE PTR [eax+32], 1

; 5340 : 
; 5341 : 				loop_count++;

  008db	8b 45 fc	 mov	 eax, DWORD PTR _loop_count$[ebp]
  008de	83 c0 01	 add	 eax, 1
  008e1	89 45 fc	 mov	 DWORD PTR _loop_count$[ebp], eax

; 5342 : 				if (loop_count > MAX_ITEM_INDEX)

  008e4	83 7d fc 20	 cmp	 DWORD PTR _loop_count$[ebp], 32 ; 00000020H
  008e8	7e 1b		 jle	 SHORT $LN37@OpenItemSc

; 5343 : 				{
; 5344 : 					MsgBox("Error : Item Data fail. (LoopCount:%d) Item Type:%d Index %d", loop_count, Type, Index);

  008ea	8b 45 ec	 mov	 eax, DWORD PTR _Index$3[ebp]
  008ed	50		 push	 eax
  008ee	8b 4d f0	 mov	 ecx, DWORD PTR _Type$4[ebp]
  008f1	51		 push	 ecx
  008f2	8b 55 fc	 mov	 edx, DWORD PTR _loop_count$[ebp]
  008f5	52		 push	 edx
  008f6	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@NLHNDLLL@Error?5?3?5Item?5Data?5fail?4?5?$CILoopCo@
  008fb	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00900	83 c4 10	 add	 esp, 16			; 00000010H

; 5345 : 					break;

  00903	eb 05		 jmp	 SHORT $LN8@OpenItemSc
$LN37@OpenItemSc:

; 5346 : 				}
; 5347 : 			}

  00905	e9 bb f7 ff ff	 jmp	 $LN7@OpenItemSc
$LN8@OpenItemSc:

; 5348 : 			if (loop_count > MAX_ITEM_INDEX)

  0090a	83 7d fc 20	 cmp	 DWORD PTR _loop_count$[ebp], 32 ; 00000020H
  0090e	7e 02		 jle	 SHORT $LN38@OpenItemSc

; 5349 : 			{
; 5350 : 				break;

  00910	eb 05		 jmp	 SHORT $LN6@OpenItemSc
$LN38@OpenItemSc:

; 5351 : 			}
; 5352 : 		}
; 5353 : 	}

  00912	e9 72 f7 ff ff	 jmp	 $LN3@OpenItemSc
$LN6@OpenItemSc:

; 5354 : 	fclose(SMDFile);

  00917	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0091c	50		 push	 eax
  0091d	e8 00 00 00 00	 call	 _fclose
  00922	83 c4 04	 add	 esp, 4

; 5355 : 	return TRUE;

  00925	b8 01 00 00 00	 mov	 eax, 1
$LN1@OpenItemSc:

; 5356 : }

  0092a	5f		 pop	 edi
  0092b	5e		 pop	 esi
  0092c	5b		 pop	 ebx
  0092d	8b e5		 mov	 esp, ebp
  0092f	5d		 pop	 ebp
  00930	c3		 ret	 0
?OpenItemScript@@YAHPAD@Z ENDP				; OpenItemScript
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?CheckExcOption@CItem@@QAEHH@Z
_TEXT	SEGMENT
tv73 = -80						; size = 4
_i$1 = -12						; size = 4
_iCount$ = -8						; size = 4
_this$ = -4						; size = 4
_iMinExcOption$ = 8					; size = 4
?CheckExcOption@CItem@@QAEHH@Z PROC			; CItem::CheckExcOption, COMDAT
; _this$ = ecx

; 5052 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 5053 : 	int iCount = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0

; 5054 : 
; 5055 : 	for (int i = 0; i < 6; i++)

  00013	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@CheckExcOp
$LN2@CheckExcOp:
  0001c	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@CheckExcOp:
  00025	83 7d f4 06	 cmp	 DWORD PTR _i$1[ebp], 6
  00029	7d 20		 jge	 SHORT $LN3@CheckExcOp

; 5056 : 	{
; 5057 : 		if (this->m_NewOption & (1 << i))

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 50 7b	 movzx	 edx, BYTE PTR [eax+123]
  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	8b 4d f4	 mov	 ecx, DWORD PTR _i$1[ebp]
  0003a	d3 e0		 shl	 eax, cl
  0003c	23 d0		 and	 edx, eax
  0003e	74 09		 je	 SHORT $LN5@CheckExcOp

; 5058 : 			iCount++;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _iCount$[ebp]
  00043	83 c0 01	 add	 eax, 1
  00046	89 45 f8	 mov	 DWORD PTR _iCount$[ebp], eax
$LN5@CheckExcOp:

; 5059 : 	}

  00049	eb d1		 jmp	 SHORT $LN2@CheckExcOp
$LN3@CheckExcOp:

; 5060 : 
; 5061 : 	return (iCount >= iMinExcOption);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _iCount$[ebp]
  0004e	3b 45 08	 cmp	 eax, DWORD PTR _iMinExcOption$[ebp]
  00051	7c 09		 jl	 SHORT $LN7@CheckExcOp
  00053	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN8@CheckExcOp
$LN7@CheckExcOp:
  0005c	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN8@CheckExcOp:
  00063	8b 45 b0	 mov	 eax, DWORD PTR tv73[ebp]

; 5062 : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
?CheckExcOption@CItem@@QAEHH@Z ENDP			; CItem::CheckExcOption
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?CheckDurabilityState@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CheckDurabilityState@CItem@@QAEHXZ PROC		; CItem::CheckDurabilityState, COMDAT
; _this$ = ecx

; 4089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4090 : 	if (m_Durability == 0.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00014	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0001b	9f		 lahf
  0001c	f6 c4 44	 test	 ah, 68			; 00000044H
  0001f	7a 77		 jp	 SHORT $LN2@CheckDurab

; 4091 : 	{
; 4092 : 		if (m_CurrentDurabilityState != 1.f)

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	f3 0f 10 80 8c
	00 00 00	 movss	 xmm0, DWORD PTR [eax+140]
  0002c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f800000
  00033	9f		 lahf
  00034	f6 c4 44	 test	 ah, 68			; 00000044H
  00037	7b 5a		 jnp	 SHORT $LN4@CheckDurab

; 4093 : 		{
; 4094 : 			m_CurrentDurabilityState = 1.f;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00044	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0

; 4095 : 
; 4096 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 4097 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 4098 : #else
; 4099 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  0004c	6a 01		 push	 1
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00058	51		 push	 ecx
  00059	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  00060	50		 push	 eax
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00068	52		 push	 edx
  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00070	51		 push	 ecx
  00071	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00074	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00078	50		 push	 eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00080	52		 push	 edx
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 4100 : #endif
; 4101 : 			return TRUE;

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	e9 1d 02 00 00	 jmp	 $LN1@CheckDurab
$LN4@CheckDurab:

; 4102 : 		}
; 4103 : 	}

  00093	e9 16 02 00 00	 jmp	 $LN14@CheckDurab
$LN2@CheckDurab:

; 4104 : 	else if (m_Durability < m_DurabilityState[2])

  00098	b8 04 00 00 00	 mov	 eax, 4
  0009d	d1 e0		 shl	 eax, 1
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	f3 0f 10 44 01
	7c		 movss	 xmm0, DWORD PTR [ecx+eax+124]
  000ab	0f 2f 42 24	 comiss	 xmm0, DWORD PTR [edx+36]
  000af	76 77		 jbe	 SHORT $LN5@CheckDurab

; 4105 : 	{
; 4106 : 		if (m_CurrentDurabilityState != 0.5f)

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	f3 0f 10 80 8c
	00 00 00	 movss	 xmm0, DWORD PTR [eax+140]
  000bc	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3f000000
  000c3	9f		 lahf
  000c4	f6 c4 44	 test	 ah, 68			; 00000044H
  000c7	7b 5a		 jnp	 SHORT $LN7@CheckDurab

; 4107 : 		{
; 4108 : 			m_CurrentDurabilityState = 0.5f;

  000c9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000d4	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0

; 4109 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 4110 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 4111 : #else
; 4112 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  000dc	6a 01		 push	 1
  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  000e8	51		 push	 ecx
  000e9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ec	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  000f0	50		 push	 eax
  000f1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  000f8	52		 push	 edx
  000f9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00100	51		 push	 ecx
  00101	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00104	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00108	50		 push	 eax
  00109	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00110	52		 push	 edx
  00111	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 4113 : #endif
; 4114 : 			return TRUE;

  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	e9 8d 01 00 00	 jmp	 $LN1@CheckDurab
$LN7@CheckDurab:

; 4115 : 		}
; 4116 : 	}

  00123	e9 86 01 00 00	 jmp	 $LN14@CheckDurab
$LN5@CheckDurab:

; 4117 : 	else if (m_Durability < m_DurabilityState[1])

  00128	b8 04 00 00 00	 mov	 eax, 4
  0012d	c1 e0 00	 shl	 eax, 0
  00130	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00136	f3 0f 10 44 01
	7c		 movss	 xmm0, DWORD PTR [ecx+eax+124]
  0013c	0f 2f 42 24	 comiss	 xmm0, DWORD PTR [edx+36]
  00140	76 77		 jbe	 SHORT $LN8@CheckDurab

; 4118 : 	{
; 4119 : 		if (m_CurrentDurabilityState != 0.3f)

  00142	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00145	f3 0f 10 80 8c
	00 00 00	 movss	 xmm0, DWORD PTR [eax+140]
  0014d	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3e99999a
  00154	9f		 lahf
  00155	f6 c4 44	 test	 ah, 68			; 00000044H
  00158	7b 5a		 jnp	 SHORT $LN10@CheckDurab

; 4120 : 		{
; 4121 : 			m_CurrentDurabilityState = 0.3f;

  0015a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e99999a
  00165	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0

; 4122 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 4123 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 4124 : #else
; 4125 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  0016d	6a 01		 push	 1
  0016f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00172	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00179	51		 push	 ecx
  0017a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0017d	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  00181	50		 push	 eax
  00182	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00185	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00189	52		 push	 edx
  0018a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018d	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00191	51		 push	 ecx
  00192	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00195	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00199	50		 push	 eax
  0019a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  001a1	52		 push	 edx
  001a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 4126 : #endif
; 4127 : 			return TRUE;

  001aa	b8 01 00 00 00	 mov	 eax, 1
  001af	e9 fc 00 00 00	 jmp	 $LN1@CheckDurab
$LN10@CheckDurab:

; 4128 : 		}
; 4129 : 	}

  001b4	e9 f5 00 00 00	 jmp	 $LN14@CheckDurab
$LN8@CheckDurab:

; 4130 : 	else if (m_Durability < m_DurabilityState[0])

  001b9	b8 04 00 00 00	 mov	 eax, 4
  001be	6b c8 00	 imul	 ecx, eax, 0
  001c1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c7	f3 0f 10 44 0a
	7c		 movss	 xmm0, DWORD PTR [edx+ecx+124]
  001cd	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  001d1	76 71		 jbe	 SHORT $LN11@CheckDurab

; 4131 : 	{
; 4132 : 		if (m_CurrentDurabilityState != 0.2f)

  001d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d6	f3 0f 10 80 8c
	00 00 00	 movss	 xmm0, DWORD PTR [eax+140]
  001de	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@3e4ccccd
  001e5	9f		 lahf
  001e6	f6 c4 44	 test	 ah, 68			; 00000044H
  001e9	7b 57		 jnp	 SHORT $LN13@CheckDurab

; 4133 : 		{
; 4134 : 			m_CurrentDurabilityState = 0.2f;

  001eb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ee	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  001f6	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0

; 4135 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 4136 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 4137 : #else
; 4138 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  001fe	6a 01		 push	 1
  00200	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00203	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  0020a	51		 push	 ecx
  0020b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0020e	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  00212	50		 push	 eax
  00213	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00216	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  0021a	52		 push	 edx
  0021b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0021e	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00222	51		 push	 ecx
  00223	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00226	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  0022a	50		 push	 eax
  0022b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00232	52		 push	 edx
  00233	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00236	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 4139 : #endif
; 4140 : 			return TRUE;

  0023b	b8 01 00 00 00	 mov	 eax, 1
  00240	eb 6e		 jmp	 SHORT $LN1@CheckDurab
$LN13@CheckDurab:

; 4141 : 		}
; 4142 : 	}

  00242	eb 6a		 jmp	 SHORT $LN14@CheckDurab
$LN11@CheckDurab:

; 4143 : 	else
; 4144 : 	{
; 4145 : 		if (m_CurrentDurabilityState != 0)

  00244	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00247	f3 0f 10 80 8c
	00 00 00	 movss	 xmm0, DWORD PTR [eax+140]
  0024f	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00256	9f		 lahf
  00257	f6 c4 44	 test	 ah, 68			; 00000044H
  0025a	7b 52		 jnp	 SHORT $LN14@CheckDurab

; 4146 : 		{
; 4147 : 			m_CurrentDurabilityState = 0.f;

  0025c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025f	0f 57 c0	 xorps	 xmm0, xmm0
  00262	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0

; 4148 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 4149 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 4150 : #else
; 4151 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  0026a	6a 01		 push	 1
  0026c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0026f	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00276	51		 push	 ecx
  00277	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0027a	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  0027e	50		 push	 eax
  0027f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00282	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00286	52		 push	 edx
  00287	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0028a	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  0028e	51		 push	 ecx
  0028f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00292	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00296	50		 push	 eax
  00297	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029a	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0029e	52		 push	 edx
  0029f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002a2	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 4152 : #endif
; 4153 : 			return TRUE;

  002a7	b8 01 00 00 00	 mov	 eax, 1
  002ac	eb 02		 jmp	 SHORT $LN1@CheckDurab
$LN14@CheckDurab:

; 4154 : 		}
; 4155 : 	}
; 4156 : 	return FALSE;

  002ae	33 c0		 xor	 eax, eax
$LN1@CheckDurab:

; 4157 : }

  002b0	5f		 pop	 edi
  002b1	5e		 pop	 esi
  002b2	5b		 pop	 ebx
  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
?CheckDurabilityState@CItem@@QAEHXZ ENDP		; CItem::CheckDurabilityState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ArmorDurabilityDown@CItem@@QAEHHH@Z
_TEXT	SEGMENT
_DecreaseDur$ = -16					; size = 4
_plusdef$ = -12						; size = 4
_def$ = -8						; size = 4
_this$ = -4						; size = 4
_damagemin$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?ArmorDurabilityDown@CItem@@QAEHHH@Z PROC		; CItem::ArmorDurabilityDown, COMDAT
; _this$ = ecx

; 3996 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3997 : 	if (m_Durability <= 0.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f 57 c0	 xorps	 xmm0, xmm0
  00012	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00016	72 07		 jb	 SHORT $LN2@ArmorDurab

; 3998 : 	{
; 3999 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 01 02 00 00	 jmp	 $LN1@ArmorDurab
$LN2@ArmorDurab:

; 4000 : 	}
; 4001 : 
; 4002 : 	if (m_Type == -1)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00026	83 f9 ff	 cmp	 ecx, -1
  00029	75 07		 jne	 SHORT $LN3@ArmorDurab

; 4003 : 	{
; 4004 : 		return FALSE;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 ee 01 00 00	 jmp	 $LN1@ArmorDurab
$LN3@ArmorDurab:

; 4005 : 	}
; 4006 : 
; 4007 : 	int def = m_DefenseOrigin;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	0f b7 48 1e	 movzx	 ecx, WORD PTR [eax+30]
  00039	89 4d f8	 mov	 DWORD PTR _def$[ebp], ecx

; 4008 : 	int plusdef = 0;

  0003c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _plusdef$[ebp], 0

; 4009 : 
; 4010 : 	if (def == 0)

  00043	83 7d f8 00	 cmp	 DWORD PTR _def$[ebp], 0
  00047	75 15		 jne	 SHORT $LN4@ArmorDurab

; 4011 : 	{
; 4012 : 		LogAdd("def이 0이다");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0M@ELCONOFE@def?$MA?L?50?$MA?L?$LE?Y@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00054	83 c4 04	 add	 esp, 4

; 4013 : 		return 0;

  00057	33 c0		 xor	 eax, eax
  00059	e9 c2 01 00 00	 jmp	 $LN1@ArmorDurab
$LN4@ArmorDurab:

; 4014 : 	}
; 4015 : 
; 4016 : 	int DecreaseDur = 0;

  0005e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _DecreaseDur$[ebp], 0

; 4017 : 	if ((m_Type >= ITEM_SHIELD && m_Type < ITEM_HELM))

  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0006c	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  00072	7c 32		 jl	 SHORT $LN5@ArmorDurab
  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00077	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0007b	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  00081	7d 23		 jge	 SHORT $LN5@ArmorDurab

; 4018 : 	{	// 방패류
; 4019 : 		PlusSpecial(&plusdef, AT_IMPROVE_BLOCKING);

  00083	6a 52		 push	 82			; 00000052H
  00085	8d 45 f4	 lea	 eax, DWORD PTR _plusdef$[ebp]
  00088	50		 push	 eax
  00089	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 4020 : 		DecreaseDur = damagemin / (def * 5 + plusdef);

  00091	6b 4d f8 05	 imul	 ecx, DWORD PTR _def$[ebp], 5
  00095	03 4d f4	 add	 ecx, DWORD PTR _plusdef$[ebp]
  00098	8b 45 08	 mov	 eax, DWORD PTR _damagemin$[ebp]
  0009b	99		 cdq
  0009c	f7 f9		 idiv	 ecx
  0009e	89 45 f0	 mov	 DWORD PTR _DecreaseDur$[ebp], eax

; 4021 : 	}

  000a1	e9 09 01 00 00	 jmp	 $LN15@ArmorDurab
$LN5@ArmorDurab:

; 4022 : 	else if (m_RequireClass[CLASS_WIZARD])

  000a6	b8 01 00 00 00	 mov	 eax, 1
  000ab	6b c8 00	 imul	 ecx, eax, 0
  000ae	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b1	0f b6 44 0a 50	 movzx	 eax, BYTE PTR [edx+ecx+80]
  000b6	85 c0		 test	 eax, eax
  000b8	74 23		 je	 SHORT $LN7@ArmorDurab

; 4023 : 	{
; 4024 : 		PlusSpecial(&plusdef, AT_IMPROVE_DEFENSE);

  000ba	6a 53		 push	 83			; 00000053H
  000bc	8d 45 f4	 lea	 eax, DWORD PTR _plusdef$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 4025 : 		DecreaseDur = damagemin / (def * 3 + plusdef);

  000c8	6b 4d f8 03	 imul	 ecx, DWORD PTR _def$[ebp], 3
  000cc	03 4d f4	 add	 ecx, DWORD PTR _plusdef$[ebp]
  000cf	8b 45 08	 mov	 eax, DWORD PTR _damagemin$[ebp]
  000d2	99		 cdq
  000d3	f7 f9		 idiv	 ecx
  000d5	89 45 f0	 mov	 DWORD PTR _DecreaseDur$[ebp], eax

; 4026 : 	}

  000d8	e9 d2 00 00 00	 jmp	 $LN15@ArmorDurab
$LN7@ArmorDurab:

; 4027 : 	else if (m_RequireClass[CLASS_KNIGHT])

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	c1 e0 00	 shl	 eax, 0
  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	0f b6 54 01 50	 movzx	 edx, BYTE PTR [ecx+eax+80]
  000ed	85 d2		 test	 edx, edx
  000ef	74 23		 je	 SHORT $LN9@ArmorDurab

; 4028 : 	{
; 4029 : 		PlusSpecial(&plusdef, AT_IMPROVE_DEFENSE);

  000f1	6a 53		 push	 83			; 00000053H
  000f3	8d 45 f4	 lea	 eax, DWORD PTR _plusdef$[ebp]
  000f6	50		 push	 eax
  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 4030 : 		DecreaseDur = damagemin / (def * 3 + plusdef);

  000ff	6b 4d f8 03	 imul	 ecx, DWORD PTR _def$[ebp], 3
  00103	03 4d f4	 add	 ecx, DWORD PTR _plusdef$[ebp]
  00106	8b 45 08	 mov	 eax, DWORD PTR _damagemin$[ebp]
  00109	99		 cdq
  0010a	f7 f9		 idiv	 ecx
  0010c	89 45 f0	 mov	 DWORD PTR _DecreaseDur$[ebp], eax

; 4031 : 	}

  0010f	e9 9b 00 00 00	 jmp	 $LN15@ArmorDurab
$LN9@ArmorDurab:

; 4032 : 	else if (m_RequireClass[CLASS_ELF])

  00114	b8 01 00 00 00	 mov	 eax, 1
  00119	d1 e0		 shl	 eax, 1
  0011b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	0f b6 54 01 50	 movzx	 edx, BYTE PTR [ecx+eax+80]
  00123	85 d2		 test	 edx, edx
  00125	74 22		 je	 SHORT $LN11@ArmorDurab

; 4033 : 	{
; 4034 : 		PlusSpecial(&plusdef, AT_IMPROVE_DEFENSE);

  00127	6a 53		 push	 83			; 00000053H
  00129	8d 45 f4	 lea	 eax, DWORD PTR _plusdef$[ebp]
  0012c	50		 push	 eax
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 4035 : 		DecreaseDur = damagemin / (def * 2 + plusdef);

  00135	8b 45 f8	 mov	 eax, DWORD PTR _def$[ebp]
  00138	8b 4d f4	 mov	 ecx, DWORD PTR _plusdef$[ebp]
  0013b	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  0013e	8b 45 08	 mov	 eax, DWORD PTR _damagemin$[ebp]
  00141	99		 cdq
  00142	f7 f9		 idiv	 ecx
  00144	89 45 f0	 mov	 DWORD PTR _DecreaseDur$[ebp], eax

; 4036 : 	}

  00147	eb 66		 jmp	 SHORT $LN15@ArmorDurab
$LN11@ArmorDurab:

; 4037 : 	else if (m_RequireClass[CLASS_MAGUMSA])

  00149	b8 01 00 00 00	 mov	 eax, 1
  0014e	6b c8 03	 imul	 ecx, eax, 3
  00151	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00154	0f b6 44 0a 50	 movzx	 eax, BYTE PTR [edx+ecx+80]
  00159	85 c0		 test	 eax, eax
  0015b	74 20		 je	 SHORT $LN13@ArmorDurab

; 4038 : 	{
; 4039 : 		PlusSpecial(&plusdef, AT_IMPROVE_DEFENSE);

  0015d	6a 53		 push	 83			; 00000053H
  0015f	8d 45 f4	 lea	 eax, DWORD PTR _plusdef$[ebp]
  00162	50		 push	 eax
  00163	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 4040 : 		DecreaseDur = damagemin / (def * 7 + plusdef);

  0016b	6b 4d f8 07	 imul	 ecx, DWORD PTR _def$[ebp], 7
  0016f	03 4d f4	 add	 ecx, DWORD PTR _plusdef$[ebp]
  00172	8b 45 08	 mov	 eax, DWORD PTR _damagemin$[ebp]
  00175	99		 cdq
  00176	f7 f9		 idiv	 ecx
  00178	89 45 f0	 mov	 DWORD PTR _DecreaseDur$[ebp], eax

; 4041 : 	}

  0017b	eb 32		 jmp	 SHORT $LN15@ArmorDurab
$LN13@ArmorDurab:

; 4042 : #ifdef DARKLORD_WORK
; 4043 : 	else if (m_RequireClass[CLASS_DARKLORD])

  0017d	b8 01 00 00 00	 mov	 eax, 1
  00182	c1 e0 02	 shl	 eax, 2
  00185	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00188	0f b6 54 01 50	 movzx	 edx, BYTE PTR [ecx+eax+80]
  0018d	85 d2		 test	 edx, edx
  0018f	74 1e		 je	 SHORT $LN15@ArmorDurab

; 4044 : 	{
; 4045 : 		PlusSpecial(&plusdef, AT_IMPROVE_DEFENSE);

  00191	6a 53		 push	 83			; 00000053H
  00193	8d 45 f4	 lea	 eax, DWORD PTR _plusdef$[ebp]
  00196	50		 push	 eax
  00197	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019a	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 4046 : 		DecreaseDur = damagemin / (def * 6 + plusdef);

  0019f	6b 4d f8 06	 imul	 ecx, DWORD PTR _def$[ebp], 6
  001a3	03 4d f4	 add	 ecx, DWORD PTR _plusdef$[ebp]
  001a6	8b 45 08	 mov	 eax, DWORD PTR _damagemin$[ebp]
  001a9	99		 cdq
  001aa	f7 f9		 idiv	 ecx
  001ac	89 45 f0	 mov	 DWORD PTR _DecreaseDur$[ebp], eax
$LN15@ArmorDurab:

; 4047 : 	}
; 4048 : #endif
; 4049 : #ifdef MODIFY_SUMMONER_ITEM_DURABILITY_DOWN_BUGFIX_20071213
; 4050 : 	else if (m_RequireClass[CLASS_SUMMONER])
; 4051 : 	{
; 4052 : 		PlusSpecial(&plusdef, AT_IMPROVE_DEFENSE);
; 4053 : 		DecreaseDur = damagemin / (def * 3 + plusdef);
; 4054 : 	}
; 4055 : #endif	
; 4056 : 
; 4057 : 	m_DurabilitySmall += DecreaseDur;

  001af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  001b6	03 4d f0	 add	 ecx, DWORD PTR _DecreaseDur$[ebp]
  001b9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001bc	66 89 4a 28	 mov	 WORD PTR [edx+40], cx

; 4058 : 
; 4059 : #if defined(MASTER_LEVEL_SKILL_SYSTEM_20071122) && !defined(CHARACTERDB_SERVER)	// 패시브 1차 - 내구감소1 : 방어구 무기
; 4060 : 	int iBaseDurSmall = 69;
; 4061 : 	if (gObj[aIndex].m_MPSkillOpt.iMpsDownDur1 > 0)
; 4062 : 	{
; 4063 : 		iBaseDurSmall += (iBaseDurSmall * gObj[aIndex].m_MPSkillOpt.iMpsDownDur1) / 100;
; 4064 : 	}
; 4065 : 
; 4066 : 	if (m_DurabilitySmall > iBaseDurSmall)
; 4067 : #else
; 4068 : 	if (m_DurabilitySmall > 69)

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c3	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  001c7	83 f9 45	 cmp	 ecx, 69			; 00000045H
  001ca	7e 52		 jle	 SHORT $LN16@ArmorDurab

; 4069 : #endif
; 4070 : 	{
; 4071 : 		m_DurabilitySmall = 0;

  001cc	33 c0		 xor	 eax, eax
  001ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d1	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 4072 : 		m_Durability -= 1;

  001d5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d8	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  001dd	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  001e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e8	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 4073 : 
; 4074 : 		if (m_Durability < 0.f)

  001ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001f0	0f 57 c0	 xorps	 xmm0, xmm0
  001f3	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  001f7	76 0b		 jbe	 SHORT $LN17@ArmorDurab

; 4075 : 		{
; 4076 : 			m_Durability = 0.f;

  001f9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001fc	0f 57 c0	 xorps	 xmm0, xmm0
  001ff	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0
$LN17@ArmorDurab:

; 4077 : 		}
; 4078 : 
; 4079 : 		if (CheckDurabilityState())

  00204	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00207	e8 00 00 00 00	 call	 ?CheckDurabilityState@CItem@@QAEHXZ ; CItem::CheckDurabilityState
  0020c	85 c0		 test	 eax, eax
  0020e	74 07		 je	 SHORT $LN18@ArmorDurab

; 4080 : 		{	// 내구력 감소에 따른 패널티가 적용된다 
; 4081 : 			return 2;

  00210	b8 02 00 00 00	 mov	 eax, 2
  00215	eb 09		 jmp	 SHORT $LN1@ArmorDurab
$LN18@ArmorDurab:

; 4082 : 		}
; 4083 : 		return 1;

  00217	b8 01 00 00 00	 mov	 eax, 1
  0021c	eb 02		 jmp	 SHORT $LN1@ArmorDurab
$LN16@ArmorDurab:

; 4084 : 	}
; 4085 : 	return 0;

  0021e	33 c0		 xor	 eax, eax
$LN1@ArmorDurab:

; 4086 : }

  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	5b		 pop	 ebx
  00223	8b e5		 mov	 esp, ebp
  00225	5d		 pop	 ebp
  00226	c2 08 00	 ret	 8
?ArmorDurabilityDown@CItem@@QAEHHH@Z ENDP		; CItem::ArmorDurabilityDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z
_TEXT	SEGMENT
_DecreaseDur$ = -20					; size = 4
_div$ = -16						; size = 4
_plusmagic$ = -12					; size = 4
_magic$ = -8						; size = 4
_this$ = -4						; size = 4
_defence$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z PROC		; CItem::StaffWeaponDurabilityDown, COMDAT
; _this$ = ecx

; 3943 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3944 : 	if (m_Durability <= 0.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f 57 c0	 xorps	 xmm0, xmm0
  00012	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00016	72 07		 jb	 SHORT $LN2@StaffWeapo

; 3945 : 	{
; 3946 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 c6 00 00 00	 jmp	 $LN1@StaffWeapo
$LN2@StaffWeapo:

; 3947 : 	}
; 3948 : 
; 3949 : 	int magic = (m_Magic / 2) + (m_Level * 2);

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	0f b7 40 20	 movzx	 eax, WORD PTR [eax+32]
  00026	99		 cdq
  00027	2b c2		 sub	 eax, edx
  00029	d1 f8		 sar	 eax, 1
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00032	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00035	89 45 f8	 mov	 DWORD PTR _magic$[ebp], eax

; 3950 : 	int plusmagic = 0;

  00038	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _plusmagic$[ebp], 0

; 3951 : 
; 3952 : 	PlusSpecial(&plusmagic, AT_IMPROVE_MAGIC);

  0003f	6a 51		 push	 81			; 00000051H
  00041	8d 45 f4	 lea	 eax, DWORD PTR _plusmagic$[ebp]
  00044	50		 push	 eax
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 3953 : 
; 3954 : 	int div = magic + magic / 3 + plusmagic;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _magic$[ebp]
  00050	99		 cdq
  00051	b9 03 00 00 00	 mov	 ecx, 3
  00056	f7 f9		 idiv	 ecx
  00058	03 45 f8	 add	 eax, DWORD PTR _magic$[ebp]
  0005b	03 45 f4	 add	 eax, DWORD PTR _plusmagic$[ebp]
  0005e	89 45 f0	 mov	 DWORD PTR _div$[ebp], eax

; 3955 : 	if (div == 0)

  00061	75 04		 jne	 SHORT $LN3@StaffWeapo

; 3956 : 		return 0;

  00063	33 c0		 xor	 eax, eax
  00065	eb 7e		 jmp	 SHORT $LN1@StaffWeapo
$LN3@StaffWeapo:

; 3957 : 
; 3958 : 	int DecreaseDur = defence / div;

  00067	8b 45 08	 mov	 eax, DWORD PTR _defence$[ebp]
  0006a	99		 cdq
  0006b	f7 7d f0	 idiv	 DWORD PTR _div$[ebp]
  0006e	89 45 ec	 mov	 DWORD PTR _DecreaseDur$[ebp], eax

; 3959 : 
; 3960 : #ifdef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 3961 : 	DecreaseDur -= (DecreaseDur * m_ImproveDurabilityRate) / 100;
; 3962 : #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 3963 : 
; 3964 : 	m_DurabilitySmall += DecreaseDur;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  00078	03 4d ec	 add	 ecx, DWORD PTR _DecreaseDur$[ebp]
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	66 89 4a 28	 mov	 WORD PTR [edx+40], cx

; 3965 : #if defined(MASTER_LEVEL_SKILL_SYSTEM_20071122) && !defined(CHARACTERDB_SERVER)	// 패시브 1차 - 내구감소1 : 지팡이 무기
; 3966 : 	int iBaseDurSmall = 1050;
; 3967 : 	if (gObj[aIndex].m_MPSkillOpt.iMpsDownDur1 > 0)
; 3968 : 	{
; 3969 : 		iBaseDurSmall += (iBaseDurSmall * gObj[aIndex].m_MPSkillOpt.iMpsDownDur1) / 100;
; 3970 : 	}
; 3971 : 
; 3972 : 	if (m_DurabilitySmall > iBaseDurSmall)
; 3973 : #else
; 3974 : 	if (m_DurabilitySmall > 1050)

  00082	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00085	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  00089	81 f9 1a 04 00
	00		 cmp	 ecx, 1050		; 0000041aH
  0008f	7e 52		 jle	 SHORT $LN4@StaffWeapo

; 3975 : #endif
; 3976 : 	{
; 3977 : 		m_DurabilitySmall = 0;

  00091	33 c0		 xor	 eax, eax
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 3978 : 		m_Durability -= 1;

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  000a2	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 3979 : 
; 3980 : 		if (m_Durability < 0.f)

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	0f 57 c0	 xorps	 xmm0, xmm0
  000b8	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  000bc	76 0b		 jbe	 SHORT $LN5@StaffWeapo

; 3981 : 		{
; 3982 : 			m_Durability = 0.f;

  000be	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	0f 57 c0	 xorps	 xmm0, xmm0
  000c4	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0
$LN5@StaffWeapo:

; 3983 : 		}
; 3984 : 
; 3985 : 		if (CheckDurabilityState())

  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ?CheckDurabilityState@CItem@@QAEHXZ ; CItem::CheckDurabilityState
  000d1	85 c0		 test	 eax, eax
  000d3	74 07		 je	 SHORT $LN6@StaffWeapo

; 3986 : 		{	// 내구력 감소에 따른 패널티가 적용된다 
; 3987 : 			return 2;

  000d5	b8 02 00 00 00	 mov	 eax, 2
  000da	eb 09		 jmp	 SHORT $LN1@StaffWeapo
$LN6@StaffWeapo:

; 3988 : 		}
; 3989 : 		return 1;

  000dc	b8 01 00 00 00	 mov	 eax, 1
  000e1	eb 02		 jmp	 SHORT $LN1@StaffWeapo
$LN4@StaffWeapo:

; 3990 : 	}
; 3991 : 	return 0;

  000e3	33 c0		 xor	 eax, eax
$LN1@StaffWeapo:

; 3992 : }

  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z ENDP		; CItem::StaffWeaponDurabilityDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?BowWeaponDurabilityDown@CItem@@QAEHHH@Z
_TEXT	SEGMENT
_DecreaseDur$ = -20					; size = 4
_div$ = -16						; size = 4
_plusdamage$ = -12					; size = 4
_damagemin$ = -8					; size = 4
_this$ = -4						; size = 4
_defence$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?BowWeaponDurabilityDown@CItem@@QAEHHH@Z PROC		; CItem::BowWeaponDurabilityDown, COMDAT
; _this$ = ecx

; 3891 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3892 : 	if (m_Durability <= 0.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f 57 c0	 xorps	 xmm0, xmm0
  00012	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00016	72 07		 jb	 SHORT $LN2@BowWeaponD

; 3893 : 	{
; 3894 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 b9 00 00 00	 jmp	 $LN1@BowWeaponD
$LN2@BowWeaponD:

; 3895 : 	}
; 3896 : 
; 3897 : 	int damagemin = m_DamageMinOrigin;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	0f b7 48 1c	 movzx	 ecx, WORD PTR [eax+28]
  00026	89 4d f8	 mov	 DWORD PTR _damagemin$[ebp], ecx

; 3898 : 	int plusdamage = 0;

  00029	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _plusdamage$[ebp], 0

; 3899 : 	PlusSpecial(&plusdamage, AT_IMPROVE_DAMAGE);

  00030	6a 50		 push	 80			; 00000050H
  00032	8d 45 f4	 lea	 eax, DWORD PTR _plusdamage$[ebp]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 3900 : 
; 3901 : 	int div = damagemin + (damagemin / 2) + plusdamage;

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _damagemin$[ebp]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx
  00044	d1 f8		 sar	 eax, 1
  00046	03 45 f8	 add	 eax, DWORD PTR _damagemin$[ebp]
  00049	03 45 f4	 add	 eax, DWORD PTR _plusdamage$[ebp]
  0004c	89 45 f0	 mov	 DWORD PTR _div$[ebp], eax

; 3902 : 
; 3903 : 	if (div == 0)

  0004f	75 07		 jne	 SHORT $LN3@BowWeaponD

; 3904 : 		return 0;

  00051	33 c0		 xor	 eax, eax
  00053	e9 80 00 00 00	 jmp	 $LN1@BowWeaponD
$LN3@BowWeaponD:

; 3905 : 
; 3906 : 	int DecreaseDur = (defence * 2) / div;

  00058	8b 45 08	 mov	 eax, DWORD PTR _defence$[ebp]
  0005b	d1 e0		 shl	 eax, 1
  0005d	99		 cdq
  0005e	f7 7d f0	 idiv	 DWORD PTR _div$[ebp]
  00061	89 45 ec	 mov	 DWORD PTR _DecreaseDur$[ebp], eax

; 3907 : 
; 3908 : #ifdef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 3909 : 	DecreaseDur -= (DecreaseDur * m_ImproveDurabilityRate) / 100;
; 3910 : #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 3911 : 
; 3912 : 	m_DurabilitySmall += DecreaseDur;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  0006b	03 4d ec	 add	 ecx, DWORD PTR _DecreaseDur$[ebp]
  0006e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00071	66 89 4a 28	 mov	 WORD PTR [edx+40], cx

; 3913 : #if defined(MASTER_LEVEL_SKILL_SYSTEM_20071122) && !defined(CHARACTERDB_SERVER)	// 패시브 1차 - 내구감소1 : 활 무기
; 3914 : 	int iBaseDurSmall = 780;
; 3915 : 	if (gObj[aIndex].m_MPSkillOpt.iMpsDownDur1 > 0)
; 3916 : 	{
; 3917 : 		iBaseDurSmall += (iBaseDurSmall * gObj[aIndex].m_MPSkillOpt.iMpsDownDur1) / 100;
; 3918 : 	}
; 3919 : 
; 3920 : 	if (m_DurabilitySmall > iBaseDurSmall)
; 3921 : #else
; 3922 : 	if (m_DurabilitySmall > 780)

  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  0007c	81 f9 0c 03 00
	00		 cmp	 ecx, 780		; 0000030cH
  00082	7e 52		 jle	 SHORT $LN4@BowWeaponD

; 3923 : #endif
; 3924 : 	{
; 3925 : 		m_DurabilitySmall = 0;

  00084	33 c0		 xor	 eax, eax
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 3926 : 		m_Durability -= 1;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00090	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00095	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 3927 : 
; 3928 : 		if (m_Durability < 0.f)

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	0f 57 c0	 xorps	 xmm0, xmm0
  000ab	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  000af	76 0b		 jbe	 SHORT $LN5@BowWeaponD

; 3929 : 		{
; 3930 : 			m_Durability = 0.f;

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	0f 57 c0	 xorps	 xmm0, xmm0
  000b7	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0
$LN5@BowWeaponD:

; 3931 : 		}
; 3932 : 		if (CheckDurabilityState())

  000bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	e8 00 00 00 00	 call	 ?CheckDurabilityState@CItem@@QAEHXZ ; CItem::CheckDurabilityState
  000c4	85 c0		 test	 eax, eax
  000c6	74 07		 je	 SHORT $LN6@BowWeaponD

; 3933 : 		{	// 내구력 감소에 따른 패널티가 적용된다 
; 3934 : 			return 2;

  000c8	b8 02 00 00 00	 mov	 eax, 2
  000cd	eb 09		 jmp	 SHORT $LN1@BowWeaponD
$LN6@BowWeaponD:

; 3935 : 		}
; 3936 : 		return 1;

  000cf	b8 01 00 00 00	 mov	 eax, 1
  000d4	eb 02		 jmp	 SHORT $LN1@BowWeaponD
$LN4@BowWeaponD:

; 3937 : 	}
; 3938 : 	return 0;

  000d6	33 c0		 xor	 eax, eax
$LN1@BowWeaponD:

; 3939 : }

  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 08 00	 ret	 8
?BowWeaponDurabilityDown@CItem@@QAEHHH@Z ENDP		; CItem::BowWeaponDurabilityDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z
_TEXT	SEGMENT
_DecreaseDur$ = -20					; size = 4
_div$ = -16						; size = 4
_plusdamage$ = -12					; size = 4
_damagemin$ = -8					; size = 4
_this$ = -4						; size = 4
_defence$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z PROC	; CItem::NormalWeaponDurabilityDown, COMDAT
; _this$ = ecx

; 3832 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3833 : 	if (m_Durability <= 0.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f 57 c0	 xorps	 xmm0, xmm0
  00012	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00016	72 07		 jb	 SHORT $LN2@NormalWeap

; 3834 : 	{
; 3835 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 d4 00 00 00	 jmp	 $LN1@NormalWeap
$LN2@NormalWeap:

; 3836 : 	}
; 3837 : 
; 3838 : 	int damagemin = m_DamageMinOrigin;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	0f b7 48 1c	 movzx	 ecx, WORD PTR [eax+28]
  00026	89 4d f8	 mov	 DWORD PTR _damagemin$[ebp], ecx

; 3839 : 	int plusdamage = 0;

  00029	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _plusdamage$[ebp], 0

; 3840 : 	PlusSpecial(&plusdamage, AT_IMPROVE_DAMAGE);

  00030	6a 50		 push	 80			; 00000050H
  00032	8d 45 f4	 lea	 eax, DWORD PTR _plusdamage$[ebp]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 3841 : 
; 3842 : 	if (damagemin == 0)

  0003e	83 7d f8 00	 cmp	 DWORD PTR _damagemin$[ebp], 0
  00042	75 15		 jne	 SHORT $LN3@NormalWeap

; 3843 : 	{
; 3844 : 		LogAdd("damagemin이 0이다");

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PKKGKBLO@damagemin?$MA?L?50?$MA?L?$LE?Y@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0004f	83 c4 04	 add	 esp, 4

; 3845 : 		return 0;

  00052	33 c0		 xor	 eax, eax
  00054	e9 9a 00 00 00	 jmp	 $LN1@NormalWeap
$LN3@NormalWeap:

; 3846 : 	}
; 3847 : 
; 3848 : 	int div = damagemin + (damagemin / 2) + plusdamage;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _damagemin$[ebp]
  0005c	99		 cdq
  0005d	2b c2		 sub	 eax, edx
  0005f	d1 f8		 sar	 eax, 1
  00061	03 45 f8	 add	 eax, DWORD PTR _damagemin$[ebp]
  00064	03 45 f4	 add	 eax, DWORD PTR _plusdamage$[ebp]
  00067	89 45 f0	 mov	 DWORD PTR _div$[ebp], eax

; 3849 : 
; 3850 : 	if (div == 0)

  0006a	75 07		 jne	 SHORT $LN4@NormalWeap

; 3851 : 		return 0;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 80 00 00 00	 jmp	 $LN1@NormalWeap
$LN4@NormalWeap:

; 3852 : 
; 3853 : 	int DecreaseDur = (defence * 2) / div;

  00073	8b 45 08	 mov	 eax, DWORD PTR _defence$[ebp]
  00076	d1 e0		 shl	 eax, 1
  00078	99		 cdq
  00079	f7 7d f0	 idiv	 DWORD PTR _div$[ebp]
  0007c	89 45 ec	 mov	 DWORD PTR _DecreaseDur$[ebp], eax

; 3854 : 
; 3855 : #ifdef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 3856 : 	DecreaseDur -= (DecreaseDur * m_ImproveDurabilityRate) / 100;
; 3857 : #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 3858 : 
; 3859 : 	m_DurabilitySmall += DecreaseDur;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00082	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  00086	03 4d ec	 add	 ecx, DWORD PTR _DecreaseDur$[ebp]
  00089	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	66 89 4a 28	 mov	 WORD PTR [edx+40], cx

; 3860 : #if defined(MASTER_LEVEL_SKILL_SYSTEM_20071122) && !defined(CHARACTERDB_SERVER)	// 패시브 1차 - 내구감소1 : 기본 내구 감소
; 3861 : 	int iBaseDurSmall = 564;
; 3862 : 	if (gObj[aIndex].m_MPSkillOpt.iMpsDownDur1 > 0)
; 3863 : 	{
; 3864 : 		iBaseDurSmall += (iBaseDurSmall * gObj[aIndex].m_MPSkillOpt.iMpsDownDur1) / 100;
; 3865 : 	}
; 3866 : 
; 3867 : 	if (m_DurabilitySmall > iBaseDurSmall)
; 3868 : #else
; 3869 : 	if (m_DurabilitySmall > 564)

  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  00097	81 f9 34 02 00
	00		 cmp	 ecx, 564		; 00000234H
  0009d	7e 52		 jle	 SHORT $LN5@NormalWeap

; 3870 : #endif
; 3871 : 	{
; 3872 : 		m_DurabilitySmall = 0;

  0009f	33 c0		 xor	 eax, eax
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 3873 : 		m_Durability -= 1;

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  000b0	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 3874 : 
; 3875 : 		if (m_Durability < 0.f)

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	0f 57 c0	 xorps	 xmm0, xmm0
  000c6	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  000ca	76 0b		 jbe	 SHORT $LN6@NormalWeap

; 3876 : 		{
; 3877 : 			m_Durability = 0.f;

  000cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	0f 57 c0	 xorps	 xmm0, xmm0
  000d2	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0
$LN6@NormalWeap:

; 3878 : 		}
; 3879 : 
; 3880 : 		if (CheckDurabilityState())

  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	e8 00 00 00 00	 call	 ?CheckDurabilityState@CItem@@QAEHXZ ; CItem::CheckDurabilityState
  000df	85 c0		 test	 eax, eax
  000e1	74 07		 je	 SHORT $LN7@NormalWeap

; 3881 : 		{	// 내구력 감소에 따른 패널티가 적용된다 
; 3882 : 			return 2;

  000e3	b8 02 00 00 00	 mov	 eax, 2
  000e8	eb 09		 jmp	 SHORT $LN1@NormalWeap
$LN7@NormalWeap:

; 3883 : 		}
; 3884 : 		return 1;

  000ea	b8 01 00 00 00	 mov	 eax, 1
  000ef	eb 02		 jmp	 SHORT $LN1@NormalWeap
$LN5@NormalWeap:

; 3885 : 	}
; 3886 : 	return 0;

  000f1	33 c0		 xor	 eax, eax
$LN1@NormalWeap:

; 3887 : }

  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 08 00	 ret	 8
?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z ENDP	; CItem::NormalWeaponDurabilityDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?DurabilityDown2@CItem@@QAEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dur$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?DurabilityDown2@CItem@@QAEHHH@Z PROC			; CItem::DurabilityDown2, COMDAT
; _this$ = ecx

; 3786 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3787 : 	if (m_Durability <= 0.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f 57 c0	 xorps	 xmm0, xmm0
  00012	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00016	72 04		 jb	 SHORT $LN2@Durability

; 3788 : 	{
; 3789 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	eb 74		 jmp	 SHORT $LN1@Durability
$LN2@Durability:

; 3790 : 	}
; 3791 : 
; 3792 : 	m_DurabilitySmall += dur;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  00023	03 4d 08	 add	 ecx, DWORD PTR _dur$[ebp]
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	66 89 4a 28	 mov	 WORD PTR [edx+40], cx

; 3793 : 
; 3794 : #if defined(MASTER_LEVEL_SKILL_SYSTEM_20071122) && !defined(CHARACTERDB_SERVER)	// 패시브 1차 - 내구감소1 : 기본 내구 감소
; 3795 : 	int iBaseDurSmall = 1000;
; 3796 : 	if (gObj[aIndex].m_MPSkillOpt.iMpsDownDur1 > 0)
; 3797 : 	{
; 3798 : 		iBaseDurSmall += (iBaseDurSmall * gObj[aIndex].m_MPSkillOpt.iMpsDownDur1) / 100;
; 3799 : 	}
; 3800 : 
; 3801 : 	if (m_DurabilitySmall > iBaseDurSmall)
; 3802 : #else
; 3803 : 	if (m_DurabilitySmall > 1000)

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  00034	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  0003a	7e 52		 jle	 SHORT $LN3@Durability

; 3804 : #endif
; 3805 : 	{
; 3806 : 		m_DurabilitySmall = 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 3807 : 		m_Durability -= 1;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0004d	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 3808 : 
; 3809 : 		if (m_Durability < 0.f)

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	0f 57 c0	 xorps	 xmm0, xmm0
  00063	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00067	76 0b		 jbe	 SHORT $LN4@Durability

; 3810 : 		{
; 3811 : 			m_Durability = 0.f;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0
$LN4@Durability:

; 3812 : 		}
; 3813 : #if TESTSERVER == 1 
; 3814 : 
; 3815 : 		char msg[255];
; 3816 : 		wsprintf(msg, "%s:내구도감소 %d/%d", GetName(), (int)m_Durability, (int)m_BaseDurability);
; 3817 : 		//GCServerMsgStringSend(msg, aIndex, 1);	
; 3818 : 		LogAddTD(msg);
; 3819 : #endif
; 3820 : 
; 3821 : 		if (CheckDurabilityState())

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?CheckDurabilityState@CItem@@QAEHXZ ; CItem::CheckDurabilityState
  0007c	85 c0		 test	 eax, eax
  0007e	74 07		 je	 SHORT $LN5@Durability

; 3822 : 		{	// 내구력 감소에 따른 패널티가 적용된다 
; 3823 : 			return 2;

  00080	b8 02 00 00 00	 mov	 eax, 2
  00085	eb 09		 jmp	 SHORT $LN1@Durability
$LN5@Durability:

; 3824 : 		}
; 3825 : 		return 1;

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	eb 02		 jmp	 SHORT $LN1@Durability
$LN3@Durability:

; 3826 : 	}
; 3827 : 	return 0;

  0008e	33 c0		 xor	 eax, eax
$LN1@Durability:

; 3828 : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8
?DurabilityDown2@CItem@@QAEHHH@Z ENDP			; CItem::DurabilityDown2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?DurabilityDown@CItem@@QAEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dur$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?DurabilityDown@CItem@@QAEHHH@Z PROC			; CItem::DurabilityDown, COMDAT
; _this$ = ecx

; 3740 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3741 : 	if (m_Durability <= 0.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f 57 c0	 xorps	 xmm0, xmm0
  00012	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00016	72 04		 jb	 SHORT $LN2@Durability

; 3742 : 	{
; 3743 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	eb 7a		 jmp	 SHORT $LN1@Durability
$LN2@Durability:

; 3744 : 	}
; 3745 : 
; 3746 : 	m_DurabilitySmall += dur;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  00023	03 4d 08	 add	 ecx, DWORD PTR _dur$[ebp]
  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	66 89 4a 28	 mov	 WORD PTR [edx+40], cx

; 3747 : 
; 3748 : #if defined(MASTER_LEVEL_SKILL_SYSTEM_20071122) && !defined(CHARACTERDB_SERVER)	// 패시브 1차 - 내구감소2 : 날개/목걸이/반지 내구 감소
; 3749 : 	int iBaseDurSmall = 564;
; 3750 : 	if (gObj[aIndex].m_MPSkillOpt.iMpsDownDur2 > 0)
; 3751 : 	{
; 3752 : 		iBaseDurSmall += (iBaseDurSmall * gObj[aIndex].m_MPSkillOpt.iMpsDownDur2) / 100;
; 3753 : 	}
; 3754 : 
; 3755 : 	if (m_DurabilitySmall > iBaseDurSmall)
; 3756 : #else
; 3757 : 	if (m_DurabilitySmall > 564)

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  00034	81 f9 34 02 00
	00		 cmp	 ecx, 564		; 00000234H
  0003a	7e 52		 jle	 SHORT $LN3@Durability

; 3758 : #endif
; 3759 : 	{
; 3760 : 		m_DurabilitySmall = 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 3761 : 		m_Durability -= 1;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0004d	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 3762 : 
; 3763 : 		if (m_Durability < 0.f)

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	0f 57 c0	 xorps	 xmm0, xmm0
  00063	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00067	76 0b		 jbe	 SHORT $LN4@Durability

; 3764 : 		{
; 3765 : 			m_Durability = 0.f;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0
$LN4@Durability:

; 3766 : 		}
; 3767 : 
; 3768 : #if TESTSERVER == 1 
; 3769 : 
; 3770 : 		char msg[255];
; 3771 : 		wsprintf(msg, "%s:내구도감소 %d/%d", GetName(), (int)m_Durability, (int)m_BaseDurability);
; 3772 : 		//GCServerMsgStringSend(msg, aIndex, 1);	
; 3773 : 		LogAddTD(msg);
; 3774 : #endif
; 3775 : 
; 3776 : 		if (CheckDurabilityState())

  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?CheckDurabilityState@CItem@@QAEHXZ ; CItem::CheckDurabilityState
  0007c	85 c0		 test	 eax, eax
  0007e	74 07		 je	 SHORT $LN5@Durability

; 3777 : 		{	// 내구력 감소에 따른 패널티가 적용된다 
; 3778 : 			return 2;

  00080	b8 02 00 00 00	 mov	 eax, 2
  00085	eb 0f		 jmp	 SHORT $LN1@Durability
$LN5@Durability:

; 3779 : 		}
; 3780 : 		return 1;

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	eb 08		 jmp	 SHORT $LN1@Durability
$LN3@Durability:

; 3781 : 	}
; 3782 : 	return (int)m_Durability;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00091	f3 0f 2c 40 24	 cvttss2si eax, DWORD PTR [eax+36]
$LN1@Durability:

; 3783 : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 08 00	 ret	 8
?DurabilityDown@CItem@@QAEHHH@Z ENDP			; CItem::DurabilityDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsDinorantReduceAttackDamaege@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDinorantReduceAttackDamaege@CItem@@QAEHXZ PROC	; CItem::IsDinorantReduceAttackDamaege, COMDAT
; _this$ = ecx

; 3655 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3656 : 	if (m_Durability < 1.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00017	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  0001b	76 04		 jbe	 SHORT $LN2@IsDinorant

; 3657 : 		return 0;

  0001d	33 c0		 xor	 eax, eax
  0001f	eb 15		 jmp	 SHORT $LN1@IsDinorant
$LN2@IsDinorant:

; 3658 : 
; 3659 : 	if ((m_NewOption&PLUS_DINORANT_PLUS_REDUCE_DAMAGE) == 0x01) return 5;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00028	83 e1 01	 and	 ecx, 1
  0002b	74 07		 je	 SHORT $LN3@IsDinorant
  0002d	b8 05 00 00 00	 mov	 eax, 5
  00032	eb 02		 jmp	 SHORT $LN1@IsDinorant
$LN3@IsDinorant:

; 3660 : 	return 0;

  00034	33 c0		 xor	 eax, eax
$LN1@IsDinorant:

; 3661 : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?IsDinorantReduceAttackDamaege@CItem@@QAEHXZ ENDP	; CItem::IsDinorantReduceAttackDamaege
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsWingOpGetManaToMoster@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWingOpGetManaToMoster@CItem@@QAEHXZ PROC		; CItem::IsWingOpGetManaToMoster, COMDAT
; _this$ = ecx

; 3636 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3637 : 	if (m_Durability < 1.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00017	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  0001b	76 04		 jbe	 SHORT $LN2@IsWingOpGe

; 3638 : 		return 0;

  0001d	33 c0		 xor	 eax, eax
  0001f	eb 18		 jmp	 SHORT $LN1@IsWingOpGe
$LN2@IsWingOpGe:

; 3639 : 
; 3640 : #ifdef ADD_THIRD_WING_20070525	// MP 10%획득은 2차날개 옵션
; 3641 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130
; 3642 : 	if ((m_Type >= MAKE_ITEMNUM(12, 3) && m_Type <= MAKE_ITEMNUM(12, 6)) || m_Type == MAKE_ITEMNUM(13, 30)
; 3643 : 		|| m_Type == MAKE_ITEMNUM(12, 42))
; 3644 : #else
; 3645 : 	if ((m_Type >= MAKE_ITEMNUM(12, 3) && m_Type <= MAKE_ITEMNUM(12, 6)) || m_Type == MAKE_ITEMNUM(13, 30))
; 3646 : #endif
; 3647 : #endif
; 3648 : 		if ((m_NewOption&PLUS_WING_GETMANA_TO_MONSTER) == 0x01) return 10;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00028	83 e1 10	 and	 ecx, 16			; 00000010H
  0002b	83 f9 01	 cmp	 ecx, 1
  0002e	75 07		 jne	 SHORT $LN3@IsWingOpGe
  00030	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00035	eb 02		 jmp	 SHORT $LN1@IsWingOpGe
$LN3@IsWingOpGe:

; 3649 : 
; 3650 : 	return 0;

  00037	33 c0		 xor	 eax, eax
$LN1@IsWingOpGe:

; 3651 : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?IsWingOpGetManaToMoster@CItem@@QAEHXZ ENDP		; CItem::IsWingOpGetManaToMoster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsWingOpGetOnePercentDamage@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWingOpGetOnePercentDamage@CItem@@QAEHXZ PROC		; CItem::IsWingOpGetOnePercentDamage, COMDAT
; _this$ = ecx

; 3600 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3601 : 	if (m_Durability < 1.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00017	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  0001b	76 04		 jbe	 SHORT $LN2@IsWingOpGe

; 3602 : 		return 0;

  0001d	33 c0		 xor	 eax, eax
  0001f	eb 15		 jmp	 SHORT $LN1@IsWingOpGe
$LN2@IsWingOpGe:

; 3603 : 
; 3604 : #ifdef ADD_THIRD_WING_20070525 // 적방무시 3%는 2차날개 옵션
; 3605 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 절망의 날개 적방 무시
; 3606 : 	if ((m_Type >= MAKE_ITEMNUM(12, 3) && m_Type <= MAKE_ITEMNUM(12, 6)) || m_Type == MAKE_ITEMNUM(13, 30)
; 3607 : 		|| m_Type == MAKE_ITEMNUM(12, 42))
; 3608 : #else
; 3609 : 	if ((m_Type >= MAKE_ITEMNUM(12, 3) && m_Type <= MAKE_ITEMNUM(12, 6)) || m_Type == MAKE_ITEMNUM(13, 30))
; 3610 : #endif
; 3611 : 	{
; 3612 : 		if ((m_NewOption & PLUS_WING_ONE_PERCENT_DAMAGE))
; 3613 : 			return 3;
; 3614 : 	}
; 3615 : #else
; 3616 : 	if ((m_NewOption&PLUS_WING_ONE_PERCENT_DAMAGE)) return 3;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00028	83 e1 04	 and	 ecx, 4
  0002b	74 07		 je	 SHORT $LN3@IsWingOpGe
  0002d	b8 03 00 00 00	 mov	 eax, 3
  00032	eb 02		 jmp	 SHORT $LN1@IsWingOpGe
$LN3@IsWingOpGe:

; 3617 : #endif	
; 3618 : 
; 3619 : 	return 0;

  00034	33 c0		 xor	 eax, eax
$LN1@IsWingOpGe:

; 3620 : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?IsWingOpGetOnePercentDamage@CItem@@QAEHXZ ENDP		; CItem::IsWingOpGetOnePercentDamage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtMonsterDieMana@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtMonsterDieMana@CItem@@QAEHXZ PROC			; CItem::IsExtMonsterDieMana, COMDAT
; _this$ = ecx

; 3589 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3590 : 	// 방패면 엑설런트 데미지를 적용하지 않는다.
; 3591 : 	if (m_Type >= ITEM_SHIELD && m_Type < ITEM_HELM) return 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  00019	7c 13		 jl	 SHORT $LN2@IsExtMonst
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00022	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  00028	7d 04		 jge	 SHORT $LN2@IsExtMonst
  0002a	33 c0		 xor	 eax, eax
  0002c	eb 15		 jmp	 SHORT $LN1@IsExtMonst
$LN2@IsExtMonst:

; 3592 : 
; 3593 : 	if ((m_NewOption & 0x01) == 0x01) return 1;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00035	83 e1 01	 and	 ecx, 1
  00038	74 07		 je	 SHORT $LN3@IsExtMonst
  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	eb 02		 jmp	 SHORT $LN1@IsExtMonst
$LN3@IsExtMonst:

; 3594 : 	return 0;

  00041	33 c0		 xor	 eax, eax
$LN1@IsExtMonst:

; 3595 : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?IsExtMonsterDieMana@CItem@@QAEHXZ ENDP			; CItem::IsExtMonsterDieMana
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtMonsterDieLife@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtMonsterDieLife@CItem@@QAEHXZ PROC			; CItem::IsExtMonsterDieLife, COMDAT
; _this$ = ecx

; 3582 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3583 : 	if ((m_NewOption & 0x02) == 0x02) return 1;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 02	 and	 ecx, 2
  00016	74 07		 je	 SHORT $LN2@IsExtMonst
  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtMonst
$LN2@IsExtMonst:

; 3584 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtMonst:

; 3585 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtMonsterDieLife@CItem@@QAEHXZ ENDP			; CItem::IsExtMonsterDieLife
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtAttackSpeed@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtAttackSpeed@CItem@@QAEHXZ PROC			; CItem::IsExtAttackSpeed, COMDAT
; _this$ = ecx

; 3575 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3576 : 	if ((m_NewOption & 0x04) == 0x04) return 7;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 04	 and	 ecx, 4
  00016	74 07		 je	 SHORT $LN2@IsExtAttac
  00018	b8 07 00 00 00	 mov	 eax, 7
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtAttac
$LN2@IsExtAttac:

; 3577 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtAttac:

; 3578 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtAttackSpeed@CItem@@QAEHXZ ENDP			; CItem::IsExtAttackSpeed
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtAttackRate2@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtAttackRate2@CItem@@QAEHXZ PROC			; CItem::IsExtAttackRate2, COMDAT
; _this$ = ecx

; 3567 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3568 : 	if ((m_NewOption & 0x08) == 0x08) return 2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 08	 and	 ecx, 8
  00016	74 07		 je	 SHORT $LN2@IsExtAttac
  00018	b8 02 00 00 00	 mov	 eax, 2
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtAttac
$LN2@IsExtAttac:

; 3569 : 	//if( (m_NewOption&0x08) == 0x08 ) return 100;
; 3570 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtAttac:

; 3571 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtAttackRate2@CItem@@QAEHXZ ENDP			; CItem::IsExtAttackRate2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtAttackRate@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtAttackRate@CItem@@QAEHXZ PROC			; CItem::IsExtAttackRate, COMDAT
; _this$ = ecx

; 3559 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3560 : 	if ((m_NewOption & 0x10) == 0x10) return 1;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 10	 and	 ecx, 16			; 00000010H
  00016	74 07		 je	 SHORT $LN2@IsExtAttac
  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtAttac
$LN2@IsExtAttac:

; 3561 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtAttac:

; 3562 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtAttackRate@CItem@@QAEHXZ ENDP			; CItem::IsExtAttackRate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtExcellentDamage@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtExcellentDamage@CItem@@QAEHXZ PROC		; CItem::IsExtExcellentDamage, COMDAT
; _this$ = ecx

; 3548 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3549 : 	// 방패면 엑설런트 데미지를 적용하지 않는다.
; 3550 : 	if (m_Type >= ITEM_SHIELD && m_Type < ITEM_HELM) return 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  00019	7c 13		 jl	 SHORT $LN2@IsExtExcel
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00022	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  00028	7d 04		 jge	 SHORT $LN2@IsExtExcel
  0002a	33 c0		 xor	 eax, eax
  0002c	eb 15		 jmp	 SHORT $LN1@IsExtExcel
$LN2@IsExtExcel:

; 3551 : 
; 3552 : 	if ((m_NewOption & 0x20) == 0x20) return 10;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00035	83 e1 20	 and	 ecx, 32			; 00000020H
  00038	74 07		 je	 SHORT $LN3@IsExtExcel
  0003a	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0003f	eb 02		 jmp	 SHORT $LN1@IsExtExcel
$LN3@IsExtExcel:

; 3553 : 	return 0;

  00041	33 c0		 xor	 eax, eax
$LN1@IsExtExcel:

; 3554 : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?IsExtExcellentDamage@CItem@@QAEHXZ ENDP		; CItem::IsExtExcellentDamage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtMonsterMoney@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtMonsterMoney@CItem@@QAEHXZ PROC			; CItem::IsExtMonsterMoney, COMDAT
; _this$ = ecx

; 3536 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3537 : #ifdef UPDATE_ZEN_DROP_DOWN_20080806	// 젠 증가 30% 로 변경
; 3538 : 	if ((m_NewOption & 0x01) == 0x01) return 30;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 01	 and	 ecx, 1
  00016	74 07		 je	 SHORT $LN2@IsExtMonst
  00018	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtMonst
$LN2@IsExtMonst:

; 3539 : #else	// UPDATE_ZEN_DROP_DOWN_20080806
; 3540 : 	if ((m_NewOption & 0x01) == 0x01) return 40;
; 3541 : #endif	// UPDATE_ZEN_DROP_DOWN_20080806
; 3542 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtMonst:

; 3543 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtMonsterMoney@CItem@@QAEHXZ ENDP			; CItem::IsExtMonsterMoney
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtDefenseSuccessfull@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtDefenseSuccessfull@CItem@@QAEHXZ PROC		; CItem::IsExtDefenseSuccessfull, COMDAT
; _this$ = ecx

; 3529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3530 : 	if ((m_NewOption & 0x02) == 0x02) return 10;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 02	 and	 ecx, 2
  00016	74 07		 je	 SHORT $LN2@IsExtDefen
  00018	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtDefen
$LN2@IsExtDefen:

; 3531 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtDefen:

; 3532 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtDefenseSuccessfull@CItem@@QAEHXZ ENDP		; CItem::IsExtDefenseSuccessfull
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtDamageReflect@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtDamageReflect@CItem@@QAEHXZ PROC			; CItem::IsExtDamageReflect, COMDAT
; _this$ = ecx

; 3518 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3519 : #ifdef NEW_FORSKYLAND3
; 3520 : 	if ((m_NewOption & 0x04) == 0x04) return 5;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 04	 and	 ecx, 4
  00016	74 07		 je	 SHORT $LN2@IsExtDamag
  00018	b8 05 00 00 00	 mov	 eax, 5
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtDamag
$LN2@IsExtDamag:

; 3521 : #else
; 3522 : 	if ((m_NewOption & 0x04) == 0x04) return 4;
; 3523 : #endif
; 3524 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtDamag:

; 3525 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtDamageReflect@CItem@@QAEHXZ ENDP			; CItem::IsExtDamageReflect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtDamageMinus@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtDamageMinus@CItem@@QAEHXZ PROC			; CItem::IsExtDamageMinus, COMDAT
; _this$ = ecx

; 3511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3512 : 	if ((m_NewOption & 0x08) == 0x08) return 4;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 08	 and	 ecx, 8
  00016	74 07		 je	 SHORT $LN2@IsExtDamag
  00018	b8 04 00 00 00	 mov	 eax, 4
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtDamag
$LN2@IsExtDamag:

; 3513 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtDamag:

; 3514 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtDamageMinus@CItem@@QAEHXZ ENDP			; CItem::IsExtDamageMinus
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtManaAdd@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtManaAdd@CItem@@QAEHXZ PROC			; CItem::IsExtManaAdd, COMDAT
; _this$ = ecx

; 3504 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3505 : 	if ((m_NewOption & 0x10) == 0x10) return 4;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 10	 and	 ecx, 16			; 00000010H
  00016	74 07		 je	 SHORT $LN2@IsExtManaA
  00018	b8 04 00 00 00	 mov	 eax, 4
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtManaA
$LN2@IsExtManaA:

; 3506 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtManaA:

; 3507 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtManaAdd@CItem@@QAEHXZ ENDP			; CItem::IsExtManaAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtLifeAdd@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtLifeAdd@CItem@@QAEHXZ PROC			; CItem::IsExtLifeAdd, COMDAT
; _this$ = ecx

; 3497 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3498 : 	if ((m_NewOption & 0x20) == 0x20) return 4;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 20	 and	 ecx, 32			; 00000020H
  00016	74 07		 je	 SHORT $LN2@IsExtLifeA
  00018	b8 04 00 00 00	 mov	 eax, 4
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtLifeA
$LN2@IsExtLifeA:

; 3499 : 	return 0;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtLifeA:

; 3500 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtLifeAdd@CItem@@QAEHXZ ENDP			; CItem::IsExtLifeAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsExtItem@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtItem@CItem@@QAEHXZ PROC				; CItem::IsExtItem, COMDAT
; _this$ = ecx

; 3483 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3484 : #ifdef MODIFY_FENRIR_EXOPTION_BUG_20060522	
; 3485 : 	// 펜릴인 경우 : 파괴나 수호일지라도 엑설런트 아이템이 아니다
; 3486 : 	if (m_Type == MAKE_ITEMNUM(13, 37))
; 3487 : 		return FALSE;
; 3488 : #endif
; 3489 : 
; 3490 : 	if (m_NewOption & 0x7F) return TRUE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  00013	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00016	74 07		 je	 SHORT $LN2@IsExtItem
  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	eb 02		 jmp	 SHORT $LN1@IsExtItem
$LN2@IsExtItem:

; 3491 : 	return FALSE;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsExtItem:

; 3492 : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?IsExtItem@CItem@@QAEHXZ ENDP				; CItem::IsExtItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetNumber@CItem@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumber@CItem@@QAEKXZ PROC				; CItem::GetNumber, COMDAT
; _this$ = ecx

; 1624 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1625 : 	return m_Number;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 1626 : }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetNumber@CItem@@QAEKXZ ENDP				; CItem::GetNumber
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?PlusSpecialSetRing@CItem@@QAEXPAE@Z
_TEXT	SEGMENT
_iValue$ = -9						; size = 1
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_Value$ = 8						; size = 4
?PlusSpecialSetRing@CItem@@QAEXPAE@Z PROC		; CItem::PlusSpecialSetRing, COMDAT
; _this$ = ecx

; 2975 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2976 : 	if (m_Type < 0) return;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 05		 jge	 SHORT $LN2@PlusSpecia
  00017	e9 9a 00 00 00	 jmp	 $LN1@PlusSpecia
$LN2@PlusSpecia:

; 2977 : 
; 2978 : 	if (!IsSetItem())		// 반지 추가 스킬 데미지 적용

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00024	85 c0		 test	 eax, eax
  00026	75 05		 jne	 SHORT $LN3@PlusSpecia

; 2979 : 		return;

  00028	e9 89 00 00 00	 jmp	 $LN1@PlusSpecia
$LN3@PlusSpecia:

; 2980 : 
; 2981 : 	if (m_Durability == 0.f)

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00035	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0003c	9f		 lahf
  0003d	f6 c4 44	 test	 ah, 68			; 00000044H
  00040	7a 02		 jp	 SHORT $LN4@PlusSpecia

; 2982 : 	{	// 내구력이 0이면  추가 옵션 적용하지 않는다
; 2983 : 		return;

  00042	eb 72		 jmp	 SHORT $LN1@PlusSpecia
$LN4@PlusSpecia:

; 2984 : 	}
; 2985 : 
; 2986 : 	if (!m_IsValidItem)		// 장착 가능한 아이템이 아니면 적용하지 않는다

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	0f b6 88 94 00
	00 00		 movzx	 ecx, BYTE PTR [eax+148]
  0004e	85 c9		 test	 ecx, ecx
  00050	75 02		 jne	 SHORT $LN5@PlusSpecia

; 2987 : 		return;

  00052	eb 62		 jmp	 SHORT $LN1@PlusSpecia
$LN5@PlusSpecia:

; 2988 : 
; 2989 : 	ITEM_ATTRIBUTE *p = &ItemAttribute[m_Type];

  00054	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00057	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0005b	6b d1 6c	 imul	 edx, ecx, 108
  0005e	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00064	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx

; 2990 : 
; 2991 : 	if (p->ResistanceType == -1)

  00067	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0006a	0f b6 48 5e	 movzx	 ecx, BYTE PTR [eax+94]
  0006e	83 f9 ff	 cmp	 ecx, -1
  00071	75 02		 jne	 SHORT $LN6@PlusSpecia

; 2992 : 		return;

  00073	eb 41		 jmp	 SHORT $LN1@PlusSpecia
$LN6@PlusSpecia:

; 2993 : 
; 2994 : 	//BYTE iValue = m_Option3*5;
; 2995 : 	BYTE iValue = 5;

  00075	c6 45 f7 05	 mov	 BYTE PTR _iValue$[ebp], 5

; 2996 : 	Value[p->ResistanceType] += iValue - (BYTE)(iValue*m_CurrentDurabilityState);

  00079	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0007c	0f b6 48 5e	 movzx	 ecx, BYTE PTR [eax+94]
  00080	0f b6 55 f7	 movzx	 edx, BYTE PTR _iValue$[ebp]
  00084	0f b6 45 f7	 movzx	 eax, BYTE PTR _iValue$[ebp]
  00088	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	f3 0f 59 80 8c
	00 00 00	 mulss	 xmm0, DWORD PTR [eax+140]
  00097	f3 0f 2c c0	 cvttss2si eax, xmm0
  0009b	0f b6 c0	 movzx	 eax, al
  0009e	2b d0		 sub	 edx, eax
  000a0	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000a3	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  000a7	03 ca		 add	 ecx, edx
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  000ac	0f b6 42 5e	 movzx	 eax, BYTE PTR [edx+94]
  000b0	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  000b3	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
$LN1@PlusSpecia:

; 2997 : }

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
?PlusSpecialSetRing@CItem@@QAEXPAE@Z ENDP		; CItem::PlusSpecialSetRing
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetWeaponType@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWeaponType@CItem@@QAEHXZ PROC			; CItem::GetWeaponType, COMDAT
; _this$ = ecx

; 3152 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3153 : 	if (m_Type <= ITEM_STAFF)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	81 f9 a0 00 00
	00		 cmp	 ecx, 160		; 000000a0H
  00019	7f 09		 jg	 SHORT $LN2@GetWeaponT

; 3154 : 	{	// 검류
; 3155 : 		return 1;

  0001b	b8 01 00 00 00	 mov	 eax, 1
  00020	eb 1a		 jmp	 SHORT $LN1@GetWeaponT

; 3156 : 	}

  00022	eb 16		 jmp	 SHORT $LN3@GetWeaponT
$LN2@GetWeaponT:

; 3157 : 	else if (m_Type <= ITEM_SHIELD)

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0002b	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  00031	7f 07		 jg	 SHORT $LN3@GetWeaponT

; 3158 : 	{	// 지팡이류
; 3159 : 		return 2;

  00033	b8 02 00 00 00	 mov	 eax, 2
  00038	eb 02		 jmp	 SHORT $LN1@GetWeaponT
$LN3@GetWeaponT:

; 3160 : 	}
; 3161 : 	return 0;

  0003a	33 c0		 xor	 eax, eax
$LN1@GetWeaponT:

; 3162 : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?GetWeaponType@CItem@@QAEHXZ ENDP			; CItem::GetWeaponType
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?SetItemPlusSpecialStat@CItem@@QAEXPAGH@Z
_TEXT	SEGMENT
tv78 = -80						; size = 4
_iValue$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_Value$ = 8						; size = 4
_Special$ = 12						; size = 4
?SetItemPlusSpecialStat@CItem@@QAEXPAGH@Z PROC		; CItem::SetItemPlusSpecialStat, COMDAT
; _this$ = ecx

; 3113 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3114 : 	if (m_Type < 0) return;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 05		 jge	 SHORT $LN7@SetItemPlu
  00017	e9 b4 00 00 00	 jmp	 $LN1@SetItemPlu
$LN7@SetItemPlu:

; 3115 : 
; 3116 : 	if (m_Durability == 0.f)

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00024	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0002b	9f		 lahf
  0002c	f6 c4 44	 test	 ah, 68			; 00000044H
  0002f	7a 05		 jp	 SHORT $LN8@SetItemPlu

; 3117 : 	{	// 내구력이 0이면  추가 옵션 적용하지 않는다
; 3118 : 		return;

  00031	e9 9a 00 00 00	 jmp	 $LN1@SetItemPlu
$LN8@SetItemPlu:

; 3119 : 	}
; 3120 : 
; 3121 : 	for (int i = 0; i < m_SpecialNum; i++)

  00036	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN4@SetItemPlu
$LN2@SetItemPlu:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@SetItemPlu:
  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0004f	39 4d f8	 cmp	 DWORD PTR _i$2[ebp], ecx
  00052	7d 7c		 jge	 SHORT $LN3@SetItemPlu

; 3122 : 	{
; 3123 : 		if (m_Special[i] == Special)

  00054	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00057	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  0005a	0f b6 48 31	 movzx	 ecx, BYTE PTR [eax+49]
  0005e	3b 4d 0c	 cmp	 ecx, DWORD PTR _Special$[ebp]
  00061	75 68		 jne	 SHORT $LN5@SetItemPlu

; 3124 : 		{
; 3125 : 			switch (Special)

  00063	8b 45 0c	 mov	 eax, DWORD PTR _Special$[ebp]
  00066	89 45 b0	 mov	 DWORD PTR tv78[ebp], eax
  00069	81 7d b0 c4 00
	00 00		 cmp	 DWORD PTR tv78[ebp], 196 ; 000000c4H
  00070	7c 41		 jl	 SHORT $LN11@SetItemPlu
  00072	81 7d b0 c7 00
	00 00		 cmp	 DWORD PTR tv78[ebp], 199 ; 000000c7H
  00079	7e 02		 jle	 SHORT $LN10@SetItemPlu
  0007b	eb 36		 jmp	 SHORT $LN11@SetItemPlu
$LN10@SetItemPlu:

; 3126 : 			{
; 3127 : 			case AT_SET_IMPROVE_STRENGTH:
; 3128 : 			case AT_SET_IMPROVE_DEXTERITY:
; 3129 : 			case AT_SET_IMPROVE_VITALITY:
; 3130 : 			case AT_SET_IMPROVE_ENERGY:
; 3131 : 			{
; 3132 : 				int iValue = m_SetAddStat;

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00080	0f b6 88 93 00
	00 00		 movzx	 ecx, BYTE PTR [eax+147]
  00087	89 4d f4	 mov	 DWORD PTR _iValue$1[ebp], ecx

; 3133 : 				(*Value) += iValue - (int)(iValue*m_CurrentDurabilityState);	// 내구도 적용

  0008a	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _iValue$1[ebp]
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	f3 0f 59 80 8c
	00 00 00	 mulss	 xmm0, DWORD PTR [eax+140]
  0009a	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0009e	8b 55 f4	 mov	 edx, DWORD PTR _iValue$1[ebp]
  000a1	2b d1		 sub	 edx, ecx
  000a3	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000a6	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000a9	03 ca		 add	 ecx, edx
  000ab	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  000ae	66 89 0a	 mov	 WORD PTR [edx], cx

; 3134 : 			}
; 3135 : 			break;

  000b1	eb 18		 jmp	 SHORT $LN5@SetItemPlu
$LN11@SetItemPlu:

; 3136 : 
; 3137 : 			default:
; 3138 : 				*Value += m_Option3 * 3;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  000ba	6b d1 03	 imul	 edx, ecx, 3
  000bd	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000c0	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000c3	03 ca		 add	 ecx, edx
  000c5	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  000c8	66 89 0a	 mov	 WORD PTR [edx], cx
$LN5@SetItemPlu:

; 3139 : 				break;
; 3140 : 			}
; 3141 : 		}
; 3142 : 	}

  000cb	e9 6f ff ff ff	 jmp	 $LN2@SetItemPlu
$LN3@SetItemPlu:
$LN1@SetItemPlu:

; 3143 : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 08 00	 ret	 8
?SetItemPlusSpecialStat@CItem@@QAEXPAGH@Z ENDP		; CItem::SetItemPlusSpecialStat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?PlusSpecialPercentEx@CItem@@QAEXPAHHH@Z
_TEXT	SEGMENT
_iValue$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_Value$ = 8						; size = 4
_SourceValue$ = 12					; size = 4
_Special$ = 16						; size = 4
?PlusSpecialPercentEx@CItem@@QAEXPAHHH@Z PROC		; CItem::PlusSpecialPercentEx, COMDAT
; _this$ = ecx

; 3088 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3089 : 	if (m_Type < 0) return;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 05		 jge	 SHORT $LN5@PlusSpecia
  00017	e9 91 00 00 00	 jmp	 $LN1@PlusSpecia
$LN5@PlusSpecia:

; 3090 : 
; 3091 : 	if (m_Durability == 0.f)

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00024	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0002b	9f		 lahf
  0002c	f6 c4 44	 test	 ah, 68			; 00000044H
  0002f	7a 02		 jp	 SHORT $LN6@PlusSpecia

; 3092 : 	{	// 내구력이 0이면  추가 옵션 적용하지 않는다
; 3093 : 		return;

  00031	eb 7a		 jmp	 SHORT $LN1@PlusSpecia
$LN6@PlusSpecia:

; 3094 : 	}
; 3095 : 
; 3096 : 	if (!m_IsValidItem)		// 장착 가능한 아이템이 아니면 적용하지 않는다

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	0f b6 88 94 00
	00 00		 movzx	 ecx, BYTE PTR [eax+148]
  0003d	85 c9		 test	 ecx, ecx
  0003f	75 02		 jne	 SHORT $LN7@PlusSpecia

; 3097 : 		return;

  00041	eb 6a		 jmp	 SHORT $LN1@PlusSpecia
$LN7@PlusSpecia:

; 3098 : 
; 3099 : 
; 3100 : 	for (int i = 0; i < m_SpecialNum; i++)

  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0004a	eb 09		 jmp	 SHORT $LN4@PlusSpecia
$LN2@PlusSpecia:
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0004f	83 c0 01	 add	 eax, 1
  00052	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@PlusSpecia:
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0005c	39 4d f8	 cmp	 DWORD PTR _i$2[ebp], ecx
  0005f	7d 4c		 jge	 SHORT $LN3@PlusSpecia

; 3101 : 	{
; 3102 : 		if (m_Special[i] == Special)

  00061	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00064	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  00067	0f b6 48 31	 movzx	 ecx, BYTE PTR [eax+49]
  0006b	3b 4d 10	 cmp	 ecx, DWORD PTR _Special$[ebp]
  0006e	75 3b		 jne	 SHORT $LN8@PlusSpecia

; 3103 : 		{
; 3104 : 			int iValue = SourceValue * m_Option3 / 100;

  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  00077	8b c1		 mov	 eax, ecx
  00079	0f af 45 0c	 imul	 eax, DWORD PTR _SourceValue$[ebp]
  0007d	99		 cdq
  0007e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00083	f7 f9		 idiv	 ecx
  00085	89 45 f4	 mov	 DWORD PTR _iValue$1[ebp], eax

; 3105 : 			(*Value) += iValue - (int)(iValue*m_CurrentDurabilityState);

  00088	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _iValue$1[ebp]
  0008d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00090	f3 0f 59 80 8c
	00 00 00	 mulss	 xmm0, DWORD PTR [eax+140]
  00098	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0009c	8b 55 f4	 mov	 edx, DWORD PTR _iValue$1[ebp]
  0009f	2b d1		 sub	 edx, ecx
  000a1	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000a4	03 10		 add	 edx, DWORD PTR [eax]
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _Value$[ebp]
  000a9	89 11		 mov	 DWORD PTR [ecx], edx
$LN8@PlusSpecia:

; 3106 : 		}
; 3107 : 	}

  000ab	eb 9f		 jmp	 SHORT $LN2@PlusSpecia
$LN3@PlusSpecia:
$LN1@PlusSpecia:

; 3108 : }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?PlusSpecialPercentEx@CItem@@QAEXPAHHH@Z ENDP		; CItem::PlusSpecialPercentEx
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?PlusSpecialPercent@CItem@@QAEXPAHHG@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_Value$ = 8						; size = 4
_Special$ = 12						; size = 4
_Percent$ = 16						; size = 2
?PlusSpecialPercent@CItem@@QAEXPAHHG@Z PROC		; CItem::PlusSpecialPercent, COMDAT
; _this$ = ecx

; 3073 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3074 : 	if (m_Type < 0) return;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 02		 jge	 SHORT $LN5@PlusSpecia
  00017	eb 4b		 jmp	 SHORT $LN1@PlusSpecia
$LN5@PlusSpecia:

; 3075 : 
; 3076 : 
; 3077 : 	for (int i = 0; i < m_SpecialNum; i++)

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00020	eb 09		 jmp	 SHORT $LN4@PlusSpecia
$LN2@PlusSpecia:
  00022	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00025	83 c0 01	 add	 eax, 1
  00028	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@PlusSpecia:
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  00032	39 4d f8	 cmp	 DWORD PTR _i$1[ebp], ecx
  00035	7d 2d		 jge	 SHORT $LN1@PlusSpecia

; 3078 : 	{
; 3079 : 		if (m_Special[i] == Special)

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	03 45 f8	 add	 eax, DWORD PTR _i$1[ebp]
  0003d	0f b6 48 31	 movzx	 ecx, BYTE PTR [eax+49]
  00041	3b 4d 0c	 cmp	 ecx, DWORD PTR _Special$[ebp]
  00044	75 1c		 jne	 SHORT $LN6@PlusSpecia

; 3080 : 		{
; 3081 : 			*Value += *Value*Percent / 100;

  00046	0f b7 45 10	 movzx	 eax, WORD PTR _Percent$[ebp]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _Value$[ebp]
  0004d	0f af 01	 imul	 eax, DWORD PTR [ecx]
  00050	99		 cdq
  00051	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00056	f7 f9		 idiv	 ecx
  00058	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  0005b	03 02		 add	 eax, DWORD PTR [edx]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _Value$[ebp]
  00060	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@PlusSpecia:

; 3082 : 		}
; 3083 : 	}

  00062	eb be		 jmp	 SHORT $LN2@PlusSpecia
$LN1@PlusSpecia:

; 3084 : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
?PlusSpecialPercent@CItem@@QAEXPAHHG@Z ENDP		; CItem::PlusSpecialPercent
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?PlusSpecial@CItem@@QAEXPAHH@Z
_TEXT	SEGMENT
tv81 = -84						; size = 4
_iValue$1 = -16						; size = 4
_iValue$2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
_Value$ = 8						; size = 4
_Special$ = 12						; size = 4
?PlusSpecial@CItem@@QAEXPAHH@Z PROC			; CItem::PlusSpecial, COMDAT
; _this$ = ecx

; 3000 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3001 : 	if (m_Type < 0) return;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 05		 jge	 SHORT $LN7@PlusSpecia
  00017	e9 61 01 00 00	 jmp	 $LN1@PlusSpecia
$LN7@PlusSpecia:

; 3002 : 
; 3003 : 	if (m_Durability == 0.f)

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00024	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0002b	9f		 lahf
  0002c	f6 c4 44	 test	 ah, 68			; 00000044H
  0002f	7a 05		 jp	 SHORT $LN8@PlusSpecia

; 3004 : 	{	// 내구력이 0이면  추가 옵션 적용하지 않는다
; 3005 : 		return;

  00031	e9 47 01 00 00	 jmp	 $LN1@PlusSpecia
$LN8@PlusSpecia:

; 3006 : 	}
; 3007 : 
; 3008 : 	if (!m_IsValidItem)		// 장착 가능한 아이템이 아니면 적용하지 않는다

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	0f b6 88 94 00
	00 00		 movzx	 ecx, BYTE PTR [eax+148]
  00040	85 c9		 test	 ecx, ecx
  00042	75 05		 jne	 SHORT $LN9@PlusSpecia

; 3009 : 		return;

  00044	e9 34 01 00 00	 jmp	 $LN1@PlusSpecia
$LN9@PlusSpecia:

; 3010 : 
; 3011 : 	for (int i = 0; i < m_SpecialNum; i++)

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00050	eb 09		 jmp	 SHORT $LN4@PlusSpecia
$LN2@PlusSpecia:
  00052	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  00055	83 c0 01	 add	 eax, 1
  00058	89 45 f8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@PlusSpecia:
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  00062	39 4d f8	 cmp	 DWORD PTR _i$3[ebp], ecx
  00065	0f 8d 12 01 00
	00		 jge	 $LN3@PlusSpecia

; 3012 : 	{
; 3013 : 		if (m_Special[i] == Special)

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	03 45 f8	 add	 eax, DWORD PTR _i$3[ebp]
  00071	0f b6 48 31	 movzx	 ecx, BYTE PTR [eax+49]
  00075	3b 4d 0c	 cmp	 ecx, DWORD PTR _Special$[ebp]
  00078	0f 85 fa 00 00
	00		 jne	 $LN5@PlusSpecia

; 3014 : 		{
; 3015 : 			switch (Special)

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _Special$[ebp]
  00081	89 45 ac	 mov	 DWORD PTR tv81[ebp], eax
  00084	8b 4d ac	 mov	 ecx, DWORD PTR tv81[ebp]
  00087	83 e9 50	 sub	 ecx, 80			; 00000050H
  0008a	89 4d ac	 mov	 DWORD PTR tv81[ebp], ecx
  0008d	83 7d ac 19	 cmp	 DWORD PTR tv81[ebp], 25	; 00000019H
  00091	0f 87 cd 00 00
	00		 ja	 $LN17@PlusSpecia
  00097	8b 55 ac	 mov	 edx, DWORD PTR tv81[ebp]
  0009a	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN19@PlusSpecia[edx]
  000a1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN20@PlusSpecia[eax*4]
$LN11@PlusSpecia:

; 3016 : 			{
; 3017 : 			case AT_IMPROVE_BLOCKING:
; 3018 : 			{
; 3019 : 				int iValue = m_Option3 * 5;

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  000af	6b d1 05	 imul	 edx, ecx, 5
  000b2	89 55 f4	 mov	 DWORD PTR _iValue$2[ebp], edx

; 3020 : 				(*Value) += iValue - (int)(iValue*m_CurrentDurabilityState);

  000b5	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _iValue$2[ebp]
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	f3 0f 59 80 8c
	00 00 00	 mulss	 xmm0, DWORD PTR [eax+140]
  000c5	f3 0f 2c c8	 cvttss2si ecx, xmm0
  000c9	8b 55 f4	 mov	 edx, DWORD PTR _iValue$2[ebp]
  000cc	2b d1		 sub	 edx, ecx
  000ce	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000d1	03 10		 add	 edx, DWORD PTR [eax]
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _Value$[ebp]
  000d6	89 11		 mov	 DWORD PTR [ecx], edx

; 3021 : 			}
; 3022 : 			break;

  000d8	e9 9b 00 00 00	 jmp	 $LN5@PlusSpecia
$LN12@PlusSpecia:

; 3023 : 			case AT_LUCK:
; 3024 : 				*Value += 4;

  000dd	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e2	83 c1 04	 add	 ecx, 4
  000e5	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  000e8	89 0a		 mov	 DWORD PTR [edx], ecx

; 3025 : 				break;

  000ea	e9 89 00 00 00	 jmp	 $LN5@PlusSpecia
$LN13@PlusSpecia:

; 3026 : 			case AT_IMPROVE_MAGIC:
; 3027 : 			case AT_IMPROVE_DEFENSE:
; 3028 : 			case AT_IMPROVE_DAMAGE:
; 3029 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130
; 3030 : 			case AT_IMPROVE_CURSE:
; 3031 : #endif	
; 3032 : 			{
; 3033 : 				int iValue = m_Option3 * 4;

  000ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  000f6	c1 e1 02	 shl	 ecx, 2
  000f9	89 4d f0	 mov	 DWORD PTR _iValue$1[ebp], ecx

; 3034 : 				(*Value) += iValue - (int)(iValue*m_CurrentDurabilityState);

  000fc	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _iValue$1[ebp]
  00101	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00104	f3 0f 59 80 8c
	00 00 00	 mulss	 xmm0, DWORD PTR [eax+140]
  0010c	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00110	8b 55 f0	 mov	 edx, DWORD PTR _iValue$1[ebp]
  00113	2b d1		 sub	 edx, ecx
  00115	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  00118	03 10		 add	 edx, DWORD PTR [eax]
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _Value$[ebp]
  0011d	89 11		 mov	 DWORD PTR [ecx], edx

; 3035 : 			}
; 3036 : 			break;

  0011f	eb 57		 jmp	 SHORT $LN5@PlusSpecia
$LN14@PlusSpecia:

; 3037 : 
; 3038 : #ifdef NEW_FORSKYLAND2
; 3039 : 			case AT_PLUS_WING_MAXLIFE:		// 최대 HP+50증가			
; 3040 : 			case AT_PLUS_WING_MAXMANA:		// 최대 MP+50증가
; 3041 : 			{
; 3042 : 				(*Value) += 50 + m_Level * 5;

  00121	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00124	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00128	6b d1 05	 imul	 edx, ecx, 5
  0012b	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  0012e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00130	8d 54 0a 32	 lea	 edx, DWORD PTR [edx+ecx+50]
  00134	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  00137	89 10		 mov	 DWORD PTR [eax], edx

; 3043 : 			}
; 3044 : 			break;

  00139	eb 3d		 jmp	 SHORT $LN5@PlusSpecia
$LN15@PlusSpecia:

; 3045 : 
; 3046 : 			case AT_IMPROVE_AG_MAX:		// 최대 AG+50증가
; 3047 : 			{
; 3048 : 				(*Value) += 50;

  0013b	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  0013e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00140	83 c1 32	 add	 ecx, 50			; 00000032H
  00143	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  00146	89 0a		 mov	 DWORD PTR [edx], ecx

; 3049 : 			}
; 3050 : 			break;

  00148	eb 2e		 jmp	 SHORT $LN5@PlusSpecia
$LN16@PlusSpecia:

; 3051 : #endif
; 3052 : 
; 3053 : #ifdef DARKLORD_WORK		// 통솔 증가(망토)
; 3054 : 			case AT_PLUS_WING_ADD_LEADERSHIP:
; 3055 : 			{
; 3056 : 				(*Value) += 10 + m_Level * 5;

  0014a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014d	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00151	6b d1 05	 imul	 edx, ecx, 5
  00154	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  00157	8b 08		 mov	 ecx, DWORD PTR [eax]
  00159	8d 54 0a 0a	 lea	 edx, DWORD PTR [edx+ecx+10]
  0015d	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  00160	89 10		 mov	 DWORD PTR [eax], edx

; 3057 : 			}
; 3058 : 			break;

  00162	eb 14		 jmp	 SHORT $LN5@PlusSpecia
$LN17@PlusSpecia:

; 3059 : #endif
; 3060 : 
; 3061 : 			default:	// AT_IMPROVE_DAMAGE
; 3062 : 						// AT_IMPROVE_MAGIC 
; 3063 : 						// AT_IMPROVE_DEFENSE
; 3064 : 				*Value += m_Option3 * 4;

  00164	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00167	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  0016b	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  0016e	8b 02		 mov	 eax, DWORD PTR [edx]
  00170	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00173	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  00176	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@PlusSpecia:

; 3065 : 				//(*Value)
; 3066 : 				break;
; 3067 : 			}
; 3068 : 		}
; 3069 : 	}

  00178	e9 d5 fe ff ff	 jmp	 $LN2@PlusSpecia
$LN3@PlusSpecia:
$LN1@PlusSpecia:

; 3070 : }

  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 08 00	 ret	 8
  00186	66 90		 npad	 2
$LN20@PlusSpecia:
  00188	00 00 00 00	 DD	 $LN13@PlusSpecia
  0018c	00 00 00 00	 DD	 $LN11@PlusSpecia
  00190	00 00 00 00	 DD	 $LN12@PlusSpecia
  00194	00 00 00 00	 DD	 $LN14@PlusSpecia
  00198	00 00 00 00	 DD	 $LN15@PlusSpecia
  0019c	00 00 00 00	 DD	 $LN16@PlusSpecia
  001a0	00 00 00 00	 DD	 $LN17@PlusSpecia
$LN19@PlusSpecia:
  001a4	00		 DB	 0
  001a5	00		 DB	 0
  001a6	01		 DB	 1
  001a7	00		 DB	 0
  001a8	02		 DB	 2
  001a9	06		 DB	 6
  001aa	06		 DB	 6
  001ab	06		 DB	 6
  001ac	06		 DB	 6
  001ad	06		 DB	 6
  001ae	06		 DB	 6
  001af	06		 DB	 6
  001b0	06		 DB	 6
  001b1	06		 DB	 6
  001b2	06		 DB	 6
  001b3	06		 DB	 6
  001b4	06		 DB	 6
  001b5	06		 DB	 6
  001b6	06		 DB	 6
  001b7	06		 DB	 6
  001b8	03		 DB	 3
  001b9	03		 DB	 3
  001ba	06		 DB	 6
  001bb	04		 DB	 4
  001bc	06		 DB	 6
  001bd	05		 DB	 5
?PlusSpecial@CItem@@QAEXPAHH@Z ENDP			; CItem::PlusSpecial
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetLevel@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLevel@CItem@@QAEHXZ PROC				; CItem::GetLevel, COMDAT
; _this$ = ecx

; 1619 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1620 : 	return ItemAttribute[m_Type].Level;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	6b d1 6c	 imul	 edx, ecx, 108
  00016	0f b6 82 22 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[edx+34]

; 1621 : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?GetLevel@CItem@@QAEHXZ ENDP				; CItem::GetLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetName@CItem@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetName@CItem@@QAEPADXZ PROC				; CItem::GetName, COMDAT
; _this$ = ecx

; 2961 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2962 : #ifdef _DEBUG
; 2963 : 	if (m_Type < 0 || m_Type > MAX_ITEM - 1)
; 2964 : 	{
; 2965 : 		//LogAdd("error: %s %d (m_Type:%d)", __FILE__, __LINE__, m_Type);
; 2966 : 		return NULL;
; 2967 : 	}
; 2968 : #endif	
; 2969 : 	return ItemAttribute[m_Type].Name;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	6b c1 6c	 imul	 eax, ecx, 108
  00016	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute

; 2970 : 	//LogAdd("Item:%d %d", w, h);
; 2971 : }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?GetName@CItem@@QAEPADXZ ENDP				; CItem::GetName
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsClass@CItem@@QAEHDH@Z
_TEXT	SEGMENT
_requireclass$ = -8					; size = 4
_this$ = -4						; size = 4
_aClass$ = 8						; size = 1
_ChangeUP$ = 12						; size = 4
?IsClass@CItem@@QAEHDH@Z PROC				; CItem::IsClass, COMDAT
; _this$ = ecx

; 2925 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2926 : 	if (aClass < 0 || aClass >= MAX_CLASSTYPE)

  0000c	0f be 45 08	 movsx	 eax, BYTE PTR _aClass$[ebp]
  00010	85 c0		 test	 eax, eax
  00012	7c 09		 jl	 SHORT $LN3@IsClass
  00014	0f be 45 08	 movsx	 eax, BYTE PTR _aClass$[ebp]
  00018	83 f8 05	 cmp	 eax, 5
  0001b	7c 25		 jl	 SHORT $LN2@IsClass
$LN3@IsClass:

; 2927 : 	{
; 2928 : 		LogAdd("클래스 에러 : %d (%s %d)", aClass, __FILE__, __LINE__);

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??IsClass@CItem@@QAEHDH@Z@4JA
  00022	83 c0 03	 add	 eax, 3
  00025	50		 push	 eax
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@PBALLACJ@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002b	0f be 4d 08	 movsx	 ecx, BYTE PTR _aClass$[ebp]
  0002f	51		 push	 ecx
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IGGPIOPD@?E?$KM?$LH?$KB?$LN?$LK?5?$LP?$KB?$LH?$KP?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ@
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003b	83 c4 10	 add	 esp, 16			; 00000010H

; 2929 : 		return FALSE;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 33		 jmp	 SHORT $LN1@IsClass
$LN2@IsClass:

; 2930 : 	}
; 2931 : 
; 2932 : 	int requireclass = m_RequireClass[aClass];

  00042	0f be 45 08	 movsx	 eax, BYTE PTR _aClass$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	0f b6 54 01 50	 movzx	 edx, BYTE PTR [ecx+eax+80]
  0004e	89 55 f8	 mov	 DWORD PTR _requireclass$[ebp], edx

; 2933 : 
; 2934 : 	if (requireclass == 0) return FALSE;

  00051	83 7d f8 00	 cmp	 DWORD PTR _requireclass$[ebp], 0
  00055	75 04		 jne	 SHORT $LN4@IsClass
  00057	33 c0		 xor	 eax, eax
  00059	eb 1a		 jmp	 SHORT $LN1@IsClass
$LN4@IsClass:

; 2935 : 	if (requireclass > 1)

  0005b	83 7d f8 01	 cmp	 DWORD PTR _requireclass$[ebp], 1
  0005f	7e 0f		 jle	 SHORT $LN5@IsClass

; 2936 : 	{	// 전직전용이면
; 2937 : 		if (requireclass != ChangeUP + 1)

  00061	8b 45 0c	 mov	 eax, DWORD PTR _ChangeUP$[ebp]
  00064	83 c0 01	 add	 eax, 1
  00067	39 45 f8	 cmp	 DWORD PTR _requireclass$[ebp], eax
  0006a	74 04		 je	 SHORT $LN5@IsClass

; 2938 : 			return FALSE;

  0006c	33 c0		 xor	 eax, eax
  0006e	eb 05		 jmp	 SHORT $LN1@IsClass
$LN5@IsClass:

; 2939 : 	}
; 2940 : 	return TRUE;

  00070	b8 01 00 00 00	 mov	 eax, 1
$LN1@IsClass:

; 2941 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
?IsClass@CItem@@QAEHDH@Z ENDP				; CItem::IsClass
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemDefense@CItem@@QAEHXZ
_TEXT	SEGMENT
_Defense$ = -8						; size = 4
_this$ = -4						; size = 4
?ItemDefense@CItem@@QAEHXZ PROC				; CItem::ItemDefense, COMDAT
; _this$ = ecx

; 2872 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2873 : 	if (m_Type < 0) return 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 04		 jge	 SHORT $LN2@ItemDefens
  00017	33 c0		 xor	 eax, eax
  00019	eb 2d		 jmp	 SHORT $LN1@ItemDefens
$LN2@ItemDefens:

; 2874 : 
; 2875 : 	if (!m_IsValidItem)

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	0f b6 88 94 00
	00 00		 movzx	 ecx, BYTE PTR [eax+148]
  00025	85 c9		 test	 ecx, ecx
  00027	75 04		 jne	 SHORT $LN3@ItemDefens

; 2876 : 		return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 1b		 jmp	 SHORT $LN1@ItemDefens
$LN3@ItemDefens:

; 2877 : 
; 2878 : 	int Defense = m_Defense;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00034	89 4d f8	 mov	 DWORD PTR _Defense$[ebp], ecx

; 2879 : 	PlusSpecial(&Defense, AT_IMPROVE_DEFENSE);

  00037	6a 53		 push	 83			; 00000053H
  00039	8d 45 f8	 lea	 eax, DWORD PTR _Defense$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 2880 : 	return Defense;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _Defense$[ebp]
$LN1@ItemDefens:

; 2881 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?ItemDefense@CItem@@QAEHXZ ENDP				; CItem::ItemDefense
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?ItemDamageMin@CItem@@QAEHXZ
_TEXT	SEGMENT
_damagemin$ = -8					; size = 4
_this$ = -4						; size = 4
?ItemDamageMin@CItem@@QAEHXZ PROC			; CItem::ItemDamageMin, COMDAT
; _this$ = ecx

; 2863 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2864 : 	if (m_Type < 0) return 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 04		 jge	 SHORT $LN2@ItemDamage
  00017	33 c0		 xor	 eax, eax
  00019	eb 1b		 jmp	 SHORT $LN1@ItemDamage
$LN2@ItemDamage:

; 2865 : 
; 2866 : 	int damagemin = m_DamageMinOrigin;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	0f b7 48 1c	 movzx	 ecx, WORD PTR [eax+28]
  00022	89 4d f8	 mov	 DWORD PTR _damagemin$[ebp], ecx

; 2867 : 	PlusSpecial(&damagemin, AT_IMPROVE_DAMAGE);

  00025	6a 50		 push	 80			; 00000050H
  00027	8d 45 f8	 lea	 eax, DWORD PTR _damagemin$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?PlusSpecial@CItem@@QAEXPAHH@Z ; CItem::PlusSpecial

; 2868 : 	return damagemin;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _damagemin$[ebp]
$LN1@ItemDamage:

; 2869 : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?ItemDamageMin@CItem@@QAEHXZ ENDP			; CItem::ItemDamageMin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?PetItemLevelDown@CItem@@QAEHH@Z
_TEXT	SEGMENT
_iPrevExp$1 = -20					; size = 4
_iPrevPetItemLevel$2 = -16				; size = 4
_iPrevExp$3 = -12					; size = 4
_iPrevPetItemLevel$4 = -8				; size = 4
_this$ = -4						; size = 4
_exp$ = 8						; size = 4
?PetItemLevelDown@CItem@@QAEHH@Z PROC			; CItem::PetItemLevelDown, COMDAT
; _this$ = ecx

; 3386 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3387 : 	if (!m_IsLoadPetItemInfo)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00016	75 07		 jne	 SHORT $LN6@PetItemLev

; 3388 : 		return FALSE;	// 펫 아이템 정보를 못 얻어 왔기 때문에 경험치 변동 없다

  00018	33 c0		 xor	 eax, eax
  0001a	e9 5d 01 00 00	 jmp	 $LN1@PetItemLev
$LN6@PetItemLev:

; 3389 : 
; 3390 : 	// MODIFY_ACCUMULATED_BUG_DARKLORD_PET_EXP_01_20050603
; 3391 : 	// 문제 :	Exp에 대해 1 레벨 감소만 가능.
; 3392 : 	//			실제로 카오스캐슬, 광장, 블러드캐슬에서는 여러 펫레벨치의 경치 획득이 가능하다.
; 3393 : 	//
; 3394 : #ifdef MODIFY_ACCUMULATED_BUG_DARKLORD_PET_EXP_01_20050603
; 3395 : 	if (m_PetItem_Level < 2)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 b8 a0 00 00
	00 02		 cmp	 DWORD PTR [eax+160], 2
  00029	7d 07		 jge	 SHORT $LN7@PetItemLev

; 3396 : 		return FALSE;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 4a 01 00 00	 jmp	 $LN1@PetItemLev
$LN7@PetItemLev:

; 3397 : 
; 3398 : 	m_PetItem_Exp -= exp;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0003b	2b 4d 08	 sub	 ecx, DWORD PTR _exp$[ebp]
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx

; 3399 : 	m_PetItem_Level--;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00050	83 e9 01	 sub	 ecx, 1
  00053	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00056	89 8a a0 00 00
	00		 mov	 DWORD PTR [edx+160], ecx

; 3400 : 
; 3401 : 	// 다크 호스 
; 3402 : 	if (m_Type == MAKE_ITEMNUM(13, 4))

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00063	6a 04		 push	 4
  00065	6a 0d		 push	 13			; 0000000dH
  00067	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0006c	83 c4 08	 add	 esp, 8
  0006f	3b f0		 cmp	 esi, eax
  00071	75 55		 jne	 SHORT $LN8@PetItemLev

; 3403 : 	{
; 3404 : 		int iPrevPetItemLevel = m_PetItem_Level;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00076	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0007c	89 4d f8	 mov	 DWORD PTR _iPrevPetItemLevel$4[ebp], ecx

; 3405 : 		int iPrevExp = gPetItemExp.m_DarkHorseExpTable[iPrevPetItemLevel];

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _iPrevPetItemLevel$4[ebp]
  00082	8b 0c 85 d0 00
	00 00		 mov	 ecx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[eax*4+208]
  00089	89 4d f4	 mov	 DWORD PTR _iPrevExp$3[ebp], ecx
$LN2@PetItemLev:

; 3406 : 
; 3407 : 		while (m_PetItem_Exp <= iPrevExp)

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00095	3b 4d f4	 cmp	 ecx, DWORD PTR _iPrevExp$3[ebp]
  00098	7f 20		 jg	 SHORT $LN3@PetItemLev

; 3408 : 		{
; 3409 : 			if (iPrevPetItemLevel <= 1)

  0009a	83 7d f8 01	 cmp	 DWORD PTR _iPrevPetItemLevel$4[ebp], 1
  0009e	7f 02		 jg	 SHORT $LN10@PetItemLev

; 3410 : 				break;

  000a0	eb 18		 jmp	 SHORT $LN3@PetItemLev
$LN10@PetItemLev:

; 3411 : 
; 3412 : 			iPrevPetItemLevel--;

  000a2	8b 45 f8	 mov	 eax, DWORD PTR _iPrevPetItemLevel$4[ebp]
  000a5	83 e8 01	 sub	 eax, 1
  000a8	89 45 f8	 mov	 DWORD PTR _iPrevPetItemLevel$4[ebp], eax

; 3413 : 			iPrevExp = gPetItemExp.m_DarkHorseExpTable[iPrevPetItemLevel];

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _iPrevPetItemLevel$4[ebp]
  000ae	8b 0c 85 d0 00
	00 00		 mov	 ecx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[eax*4+208]
  000b5	89 4d f4	 mov	 DWORD PTR _iPrevExp$3[ebp], ecx

; 3414 : 		}

  000b8	eb d2		 jmp	 SHORT $LN2@PetItemLev
$LN3@PetItemLev:

; 3415 : 
; 3416 : 		m_PetItem_Level = iPrevPetItemLevel;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _iPrevPetItemLevel$4[ebp]
  000c0	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx

; 3417 : 	}

  000c6	eb 6a		 jmp	 SHORT $LN9@PetItemLev
$LN8@PetItemLev:

; 3418 : 	// 다크 스피릿
; 3419 : 	else if (m_Type == MAKE_ITEMNUM(13, 5))

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000cf	6a 05		 push	 5
  000d1	6a 0d		 push	 13			; 0000000dH
  000d3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d8	83 c4 08	 add	 esp, 8
  000db	3b f0		 cmp	 esi, eax
  000dd	75 53		 jne	 SHORT $LN9@PetItemLev

; 3420 : 	{
; 3421 : 		int iPrevPetItemLevel = m_PetItem_Level;

  000df	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  000e8	89 4d f0	 mov	 DWORD PTR _iPrevPetItemLevel$2[ebp], ecx

; 3422 : 		int iPrevExp = gPetItemExp.m_DarkSpiritExpTable[iPrevPetItemLevel];

  000eb	8b 45 f0	 mov	 eax, DWORD PTR _iPrevPetItemLevel$2[ebp]
  000ee	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[eax*4]
  000f5	89 4d ec	 mov	 DWORD PTR _iPrevExp$1[ebp], ecx
$LN4@PetItemLev:

; 3423 : 
; 3424 : 		while (m_PetItem_Exp <= iPrevExp)

  000f8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000fb	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00101	3b 4d ec	 cmp	 ecx, DWORD PTR _iPrevExp$1[ebp]
  00104	7f 20		 jg	 SHORT $LN5@PetItemLev

; 3425 : 		{
; 3426 : 			if (iPrevPetItemLevel <= 1)

  00106	83 7d f0 01	 cmp	 DWORD PTR _iPrevPetItemLevel$2[ebp], 1
  0010a	7f 02		 jg	 SHORT $LN12@PetItemLev

; 3427 : 				break;

  0010c	eb 18		 jmp	 SHORT $LN5@PetItemLev
$LN12@PetItemLev:

; 3428 : 
; 3429 : 			iPrevPetItemLevel--;

  0010e	8b 45 f0	 mov	 eax, DWORD PTR _iPrevPetItemLevel$2[ebp]
  00111	83 e8 01	 sub	 eax, 1
  00114	89 45 f0	 mov	 DWORD PTR _iPrevPetItemLevel$2[ebp], eax

; 3430 : 			iPrevExp = gPetItemExp.m_DarkSpiritExpTable[iPrevPetItemLevel];

  00117	8b 45 f0	 mov	 eax, DWORD PTR _iPrevPetItemLevel$2[ebp]
  0011a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[eax*4]
  00121	89 4d ec	 mov	 DWORD PTR _iPrevExp$1[ebp], ecx

; 3431 : 		}

  00124	eb d2		 jmp	 SHORT $LN4@PetItemLev
$LN5@PetItemLev:

; 3432 : 
; 3433 : 		m_PetItem_Level = iPrevPetItemLevel;

  00126	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00129	8b 4d f0	 mov	 ecx, DWORD PTR _iPrevPetItemLevel$2[ebp]
  0012c	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx
$LN9@PetItemLev:

; 3434 : 	}
; 3435 : #else
; 3436 : 
; 3437 : 	m_PetItem_Level--;
; 3438 : 	m_PetItem_Exp -= exp;
; 3439 : 
; 3440 : #endif
; 3441 : 
; 3442 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3443 : 	Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3444 : #else
; 3445 : 	Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  00132	6a 01		 push	 1
  00134	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00137	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  0013e	51		 push	 ecx
  0013f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00142	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  00146	50		 push	 eax
  00147	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  0014e	52		 push	 edx
  0014f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00152	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00156	51		 push	 ecx
  00157	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0015a	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  0015e	50		 push	 eax
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00166	52		 push	 edx
  00167	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3446 : #endif
; 3447 : 	PetValue();

  0016f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00172	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3448 : 	return TRUE;

  00177	b8 01 00 00 00	 mov	 eax, 1
$LN1@PetItemLev:

; 3449 : }

  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 04 00	 ret	 4
?PetItemLevelDown@CItem@@QAEHH@Z ENDP			; CItem::PetItemLevelDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?PetValue@CItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PetValue@CItem@@QAEXXZ PROC				; CItem::PetValue, COMDAT
; _this$ = ecx

; 3453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3454 : 	if (m_Type == MAKE_ITEMNUM(13, 4))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00013	6a 04		 push	 4
  00015	6a 0d		 push	 13			; 0000000dH
  00017	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0001c	83 c4 08	 add	 esp, 8
  0001f	3b f0		 cmp	 esi, eax
  00021	75 15		 jne	 SHORT $LN2@PetValue

; 3455 : 	{	//다크 호스
; 3456 : 		m_SellMoney = m_PetItem_Level * 2000000;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	69 88 a0 00 00
	00 80 84 1e 00	 imul	 ecx, DWORD PTR [eax+160], 2000000
  00030	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00033	89 4a 60	 mov	 DWORD PTR [edx+96], ecx

; 3457 : 	}

  00036	eb 2a		 jmp	 SHORT $LN3@PetValue
$LN2@PetValue:

; 3458 : 	else if (m_Type == MAKE_ITEMNUM(13, 5))

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0003f	6a 05		 push	 5
  00041	6a 0d		 push	 13			; 0000000dH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	3b f0		 cmp	 esi, eax
  0004d	75 13		 jne	 SHORT $LN3@PetValue

; 3459 : 	{	// 다크스피릿
; 3460 : 		m_SellMoney = m_PetItem_Level * 1000000;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	69 88 a0 00 00
	00 40 42 0f 00	 imul	 ecx, DWORD PTR [eax+160], 1000000
  0005c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	89 4a 60	 mov	 DWORD PTR [edx+96], ecx
$LN3@PetValue:

; 3461 : 	}
; 3462 : 
; 3463 : 
; 3464 : 	m_BuyMoney = m_SellMoney;

  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0006b	89 50 64	 mov	 DWORD PTR [eax+100], edx

; 3465 : 
; 3466 : #ifdef BUGFIX_SELL_PRICE_OF_DARKLOAD_PETS_20050310
; 3467 : 	m_SellMoney /= 3;
; 3468 : #endif
; 3469 : 
; 3470 : 	if (m_SellMoney >= 1000)

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00071	81 78 60 e8 03
	00 00		 cmp	 DWORD PTR [eax+96], 1000 ; 000003e8H
  00078	72 1a		 jb	 SHORT $LN5@PetValue

; 3471 : 		m_SellMoney = m_SellMoney / 100 * 100;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00080	33 d2		 xor	 edx, edx
  00082	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00087	f7 f1		 div	 ecx
  00089	6b d0 64	 imul	 edx, eax, 100
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	89 50 60	 mov	 DWORD PTR [eax+96], edx
  00092	eb 21		 jmp	 SHORT $LN6@PetValue
$LN5@PetValue:

; 3472 : 	else if (m_SellMoney >= 100)

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	83 78 60 64	 cmp	 DWORD PTR [eax+96], 100	; 00000064H
  0009b	72 18		 jb	 SHORT $LN6@PetValue

; 3473 : 		m_SellMoney = m_SellMoney / 10 * 10;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  000a3	33 d2		 xor	 edx, edx
  000a5	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000aa	f7 f1		 div	 ecx
  000ac	6b d0 0a	 imul	 edx, eax, 10
  000af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	89 50 60	 mov	 DWORD PTR [eax+96], edx
$LN6@PetValue:

; 3474 : 
; 3475 : 	if (m_BuyMoney >= 1000)

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	81 78 64 e8 03
	00 00		 cmp	 DWORD PTR [eax+100], 1000 ; 000003e8H
  000bf	72 1a		 jb	 SHORT $LN8@PetValue

; 3476 : 		m_BuyMoney = m_BuyMoney / 100 * 100;

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  000c7	33 d2		 xor	 edx, edx
  000c9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000ce	f7 f1		 div	 ecx
  000d0	6b d0 64	 imul	 edx, eax, 100
  000d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	89 50 64	 mov	 DWORD PTR [eax+100], edx
  000d9	eb 21		 jmp	 SHORT $LN1@PetValue
$LN8@PetValue:

; 3477 : 	else if (m_BuyMoney >= 100)

  000db	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000de	83 78 64 64	 cmp	 DWORD PTR [eax+100], 100 ; 00000064H
  000e2	72 18		 jb	 SHORT $LN1@PetValue

; 3478 : 		m_BuyMoney = m_BuyMoney / 10 * 10;

  000e4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  000ea	33 d2		 xor	 edx, edx
  000ec	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000f1	f7 f1		 div	 ecx
  000f3	6b d0 0a	 imul	 edx, eax, 10
  000f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN1@PetValue:

; 3479 : }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
?PetValue@CItem@@QAEXXZ ENDP				; CItem::PetValue
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?DecPetItemExp@CItem@@QAEHH@Z
_TEXT	SEGMENT
_decexp$1 = -12						; size = 4
_decexp$2 = -8						; size = 4
_this$ = -4						; size = 4
_percent$ = 8						; size = 4
?DecPetItemExp@CItem@@QAEHH@Z PROC			; CItem::DecPetItemExp, COMDAT
; _this$ = ecx

; 3299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3300 : 	if (!m_IsLoadPetItemInfo)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00016	75 07		 jne	 SHORT $LN2@DecPetItem

; 3301 : 		return FALSE;	// 펫 아이템 정보를 못 얻어 왔기 때문에 경험치 변동 없다

  00018	33 c0		 xor	 eax, eax
  0001a	e9 18 03 00 00	 jmp	 $LN1@DecPetItem
$LN2@DecPetItem:

; 3302 : 
; 3303 : 	if (m_PetItem_Level < 1)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 b8 a0 00 00
	00 01		 cmp	 DWORD PTR [eax+160], 1
  00029	7d 66		 jge	 SHORT $LN3@DecPetItem

; 3304 : 	{
; 3305 : 		m_PetItem_Level = 1;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 80 a0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+160], 1

; 3306 : 		m_PetItem_Exp = 0;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+164], 0

; 3307 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3308 : 		Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3309 : #else
; 3310 : 		Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  00045	6a 01		 push	 1
  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00051	51		 push	 ecx
  00052	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00055	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  00059	50		 push	 eax
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00061	52		 push	 edx
  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00069	51		 push	 ecx
  0006a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00071	50		 push	 eax
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00079	52		 push	 edx
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3311 : #endif
; 3312 : 
; 3313 : 		PetValue();

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3314 : 		return FALSE;

  0008a	33 c0		 xor	 eax, eax
  0008c	e9 a6 02 00 00	 jmp	 $LN1@DecPetItem
$LN3@DecPetItem:

; 3315 : 	}
; 3316 : 
; 3317 : 	if (m_Type == MAKE_ITEMNUM(13, 4))

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00098	6a 04		 push	 4
  0009a	6a 0d		 push	 13			; 0000000dH
  0009c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000a1	83 c4 08	 add	 esp, 8
  000a4	3b f0		 cmp	 esi, eax
  000a6	0f 85 3b 01 00
	00		 jne	 $LN4@DecPetItem

; 3318 : 	{	// 다크호스		
; 3319 : 		int decexp = gPetItemExp.m_DarkHorseExpTable[m_PetItem_Level + 1] - gPetItemExp.m_DarkHorseExpTable[m_PetItem_Level];

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  000b5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b8	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  000be	8b 0c 8d d4 00
	00 00		 mov	 ecx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+212]
  000c5	2b 0c 85 d0 00
	00 00		 sub	 ecx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[eax*4+208]
  000cc	89 4d f8	 mov	 DWORD PTR _decexp$2[ebp], ecx

; 3320 : 		decexp = decexp * percent / 100;

  000cf	8b 45 f8	 mov	 eax, DWORD PTR _decexp$2[ebp]
  000d2	0f af 45 08	 imul	 eax, DWORD PTR _percent$[ebp]
  000d6	99		 cdq
  000d7	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000dc	f7 f9		 idiv	 ecx
  000de	89 45 f8	 mov	 DWORD PTR _decexp$2[ebp], eax

; 3321 : 		m_PetItem_Exp -= decexp;

  000e1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000ea	2b 4d f8	 sub	 ecx, DWORD PTR _decexp$2[ebp]
  000ed	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f0	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx

; 3322 : 
; 3323 : 		if (m_PetItem_Exp < 0)

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00100	7d 61		 jge	 SHORT $LN6@DecPetItem

; 3324 : 		{
; 3325 : 			m_PetItem_Level = 1;

  00102	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00105	c7 80 a0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+160], 1

; 3326 : 			m_PetItem_Exp = 0;

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00112	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+164], 0

; 3327 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3328 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3329 : #else
; 3330 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  0011c	6a 01		 push	 1
  0011e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00121	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00128	51		 push	 ecx
  00129	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0012c	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  00130	50		 push	 eax
  00131	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00138	52		 push	 edx
  00139	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013c	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00140	51		 push	 ecx
  00141	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00144	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00148	50		 push	 eax
  00149	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00150	52		 push	 edx
  00151	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3331 : #endif
; 3332 : 			PetValue();

  00159	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3333 : 		}

  00161	eb 7f		 jmp	 SHORT $LN7@DecPetItem
$LN6@DecPetItem:

; 3334 : 		else
; 3335 : 		{	// 레벨 다운
; 3336 : 			if (m_PetItem_Exp < gPetItemExp.m_DarkHorseExpTable[m_PetItem_Level])

  00163	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00166	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0016c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0016f	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00175	3b 04 8d d0 00
	00 00		 cmp	 eax, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+208]
  0017c	7d 64		 jge	 SHORT $LN7@DecPetItem

; 3337 : 			{
; 3338 : 				m_PetItem_Level--;

  0017e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00181	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00187	83 e9 01	 sub	 ecx, 1
  0018a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0018d	89 8a a0 00 00
	00		 mov	 DWORD PTR [edx+160], ecx

; 3339 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3340 : 				Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3341 : #else
; 3342 : 				Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  00193	6a 01		 push	 1
  00195	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00198	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  0019f	51		 push	 ecx
  001a0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001a3	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  001a7	50		 push	 eax
  001a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  001af	52		 push	 edx
  001b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b3	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  001b7	51		 push	 ecx
  001b8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001bb	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  001bf	50		 push	 eax
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c3	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  001c7	52		 push	 edx
  001c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3343 : #endif
; 3344 : 				PetValue();

  001d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3345 : 				return TRUE;

  001d8	b8 01 00 00 00	 mov	 eax, 1
  001dd	e9 55 01 00 00	 jmp	 $LN1@DecPetItem
$LN7@DecPetItem:

; 3346 : 			}
; 3347 : 		}
; 3348 : 	}

  001e2	e9 4e 01 00 00	 jmp	 $LN5@DecPetItem
$LN4@DecPetItem:

; 3349 : 	else if (m_Type == MAKE_ITEMNUM(13, 5))

  001e7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ea	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  001ee	6a 05		 push	 5
  001f0	6a 0d		 push	 13			; 0000000dH
  001f2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f7	83 c4 08	 add	 esp, 8
  001fa	3b f0		 cmp	 esi, eax
  001fc	0f 85 33 01 00
	00		 jne	 $LN5@DecPetItem

; 3350 : 	{	// 다크스피릿
; 3351 : 		int decexp = gPetItemExp.m_DarkSpiritExpTable[m_PetItem_Level + 1] - gPetItemExp.m_DarkSpiritExpTable[m_PetItem_Level];

  00202	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00205	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0020b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0020e	8b 82 a0 00 00
	00		 mov	 eax, DWORD PTR [edx+160]
  00214	8b 0c 8d 04 00
	00 00		 mov	 ecx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+4]
  0021b	2b 0c 85 00 00
	00 00		 sub	 ecx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[eax*4]
  00222	89 4d f4	 mov	 DWORD PTR _decexp$1[ebp], ecx

; 3352 : 		decexp = decexp * percent / 100;

  00225	8b 45 f4	 mov	 eax, DWORD PTR _decexp$1[ebp]
  00228	0f af 45 08	 imul	 eax, DWORD PTR _percent$[ebp]
  0022c	99		 cdq
  0022d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00232	f7 f9		 idiv	 ecx
  00234	89 45 f4	 mov	 DWORD PTR _decexp$1[ebp], eax

; 3353 : 		m_PetItem_Exp -= decexp;

  00237	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0023a	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00240	2b 4d f4	 sub	 ecx, DWORD PTR _decexp$1[ebp]
  00243	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00246	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx

; 3354 : 
; 3355 : 		if (m_PetItem_Exp < 0)

  0024c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0024f	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00256	7d 61		 jge	 SHORT $LN10@DecPetItem

; 3356 : 		{
; 3357 : 			m_PetItem_Level = 1;

  00258	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025b	c7 80 a0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+160], 1

; 3358 : 			m_PetItem_Exp = 0;

  00265	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00268	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+164], 0

; 3359 : 
; 3360 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3361 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3362 : #else
; 3363 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  00272	6a 01		 push	 1
  00274	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00277	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  0027e	51		 push	 ecx
  0027f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00282	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  00286	50		 push	 eax
  00287	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0028a	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  0028e	52		 push	 edx
  0028f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00292	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00296	51		 push	 ecx
  00297	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0029a	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  0029e	50		 push	 eax
  0029f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002a2	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  002a6	52		 push	 edx
  002a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002aa	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3364 : #endif
; 3365 : 			PetValue();

  002af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b2	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3366 : 		}

  002b7	eb 7c		 jmp	 SHORT $LN5@DecPetItem
$LN10@DecPetItem:

; 3367 : 		else
; 3368 : 		{	// 레벨 다운
; 3369 : 			if (m_PetItem_Exp < gPetItemExp.m_DarkSpiritExpTable[m_PetItem_Level])

  002b9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002bc	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  002c2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002c5	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  002cb	3b 04 8d 00 00
	00 00		 cmp	 eax, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4]
  002d2	7d 61		 jge	 SHORT $LN5@DecPetItem

; 3370 : 			{
; 3371 : 				m_PetItem_Level--;

  002d4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002d7	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  002dd	83 e9 01	 sub	 ecx, 1
  002e0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002e3	89 8a a0 00 00
	00		 mov	 DWORD PTR [edx+160], ecx

; 3372 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3373 : 				Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3374 : #else
; 3375 : 				Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  002e9	6a 01		 push	 1
  002eb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002ee	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  002f5	51		 push	 ecx
  002f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002f9	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  002fd	50		 push	 eax
  002fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00301	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00305	52		 push	 edx
  00306	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00309	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  0030d	51		 push	 ecx
  0030e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00311	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00315	50		 push	 eax
  00316	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00319	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0031d	52		 push	 edx
  0031e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00321	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3376 : #endif
; 3377 : 				PetValue();

  00326	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00329	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3378 : 				return TRUE;

  0032e	b8 01 00 00 00	 mov	 eax, 1
  00333	eb 02		 jmp	 SHORT $LN1@DecPetItem
$LN5@DecPetItem:

; 3379 : 			}
; 3380 : 		}
; 3381 : 	}
; 3382 : 	return FALSE;

  00335	33 c0		 xor	 eax, eax
$LN1@DecPetItem:

; 3383 : }

  00337	5f		 pop	 edi
  00338	5e		 pop	 esi
  00339	5b		 pop	 ebx
  0033a	8b e5		 mov	 esp, ebp
  0033c	5d		 pop	 ebp
  0033d	c2 04 00	 ret	 4
?DecPetItemExp@CItem@@QAEHH@Z ENDP			; CItem::DecPetItemExp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?AddPetItemExp@CItem@@QAEHH@Z
_TEXT	SEGMENT
_nextexp$1 = -20					; size = 4
_IsLevelUp$2 = -16					; size = 4
_nextexp$3 = -12					; size = 4
_IsLevelUp$4 = -8					; size = 4
_this$ = -4						; size = 4
_petexp$ = 8						; size = 4
?AddPetItemExp@CItem@@QAEHH@Z PROC			; CItem::AddPetItemExp, COMDAT
; _this$ = ecx

; 3213 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3214 : 	if (m_Durability <= 0.f)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f 57 c0	 xorps	 xmm0, xmm0
  00012	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00016	72 07		 jb	 SHORT $LN6@AddPetItem

; 3215 : 		return FALSE;	// 내구도가 0이때는 경험치 상승 없다

  00018	33 c0		 xor	 eax, eax
  0001a	e9 6b 02 00 00	 jmp	 $LN1@AddPetItem
$LN6@AddPetItem:

; 3216 : 
; 3217 : 	if (!m_IsLoadPetItemInfo)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00029	75 07		 jne	 SHORT $LN7@AddPetItem

; 3218 : 		return FALSE;	// 펫 아이템 정보를 못 얻어 왔기 때문에 경험치 변동 없다

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 58 02 00 00	 jmp	 $LN1@AddPetItem
$LN7@AddPetItem:

; 3219 : 
; 3220 : 	if (m_PetItem_Level < 1)

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 b8 a0 00 00
	00 01		 cmp	 DWORD PTR [eax+160], 1
  0003c	7d 66		 jge	 SHORT $LN8@AddPetItem

; 3221 : 	{
; 3222 : 		m_PetItem_Level = 1;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c7 80 a0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+160], 1

; 3223 : 		m_PetItem_Exp = 0;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+164], 0

; 3224 : 
; 3225 : 
; 3226 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3227 : 		Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3228 : #else
; 3229 : 		Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  00058	6a 01		 push	 1
  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00064	51		 push	 ecx
  00065	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00068	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  0006c	50		 push	 eax
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00074	52		 push	 edx
  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  0007c	51		 push	 ecx
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00080	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00084	50		 push	 eax
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0008c	52		 push	 edx
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3230 : #endif
; 3231 : 
; 3232 : 		PetValue();

  00095	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3233 : 
; 3234 : 		return FALSE;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 e6 01 00 00	 jmp	 $LN1@AddPetItem
$LN8@AddPetItem:

; 3235 : 	}
; 3236 : 
; 3237 : 	if (m_Type == MAKE_ITEMNUM(13, 4))

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000ab	6a 04		 push	 4
  000ad	6a 0d		 push	 13			; 0000000dH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	3b f0		 cmp	 esi, eax
  000b9	0f 85 db 00 00
	00		 jne	 $LN9@AddPetItem

; 3238 : 	{	// 다크호스		
; 3239 : 		if (m_PetItem_Level >= MAX_DARK_HORSE_LEVEL)

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	83 b8 a0 00 00
	00 32		 cmp	 DWORD PTR [eax+160], 50	; 00000032H
  000c9	7c 07		 jl	 SHORT $LN11@AddPetItem

; 3240 : 			return FALSE;	// 최대 레벨이면 경험치 상승 없다

  000cb	33 c0		 xor	 eax, eax
  000cd	e9 b8 01 00 00	 jmp	 $LN1@AddPetItem
$LN11@AddPetItem:

; 3241 : 
; 3242 : 		BOOL	IsLevelUp = FALSE;

  000d2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _IsLevelUp$4[ebp], 0

; 3243 : 
; 3244 : 		int nextexp = gPetItemExp.m_DarkHorseExpTable[m_PetItem_Level + 1];

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  000e2	8b 14 8d d4 00
	00 00		 mov	 edx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+212]
  000e9	89 55 f4	 mov	 DWORD PTR _nextexp$3[ebp], edx

; 3245 : 		m_PetItem_Exp += petexp;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000f5	03 4d 08	 add	 ecx, DWORD PTR _petexp$[ebp]
  000f8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000fb	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx
$LN2@AddPetItem:

; 3246 : 
; 3247 : 		while (m_PetItem_Exp >= nextexp)

  00101	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00104	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0010a	3b 4d f4	 cmp	 ecx, DWORD PTR _nextexp$3[ebp]
  0010d	7c 31		 jl	 SHORT $LN3@AddPetItem

; 3248 : 		{
; 3249 : 			m_PetItem_Level++;

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00112	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00118	83 c1 01	 add	 ecx, 1
  0011b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0011e	89 8a a0 00 00
	00		 mov	 DWORD PTR [edx+160], ecx

; 3250 : 			nextexp = gPetItemExp.m_DarkHorseExpTable[m_PetItem_Level + 1];

  00124	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00127	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0012d	8b 14 8d d4 00
	00 00		 mov	 edx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+212]
  00134	89 55 f4	 mov	 DWORD PTR _nextexp$3[ebp], edx

; 3251 : 			IsLevelUp = TRUE;

  00137	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _IsLevelUp$4[ebp], 1

; 3252 : 		}

  0013e	eb c1		 jmp	 SHORT $LN2@AddPetItem
$LN3@AddPetItem:

; 3253 : 
; 3254 : 		if (IsLevelUp)

  00140	83 7d f8 00	 cmp	 DWORD PTR _IsLevelUp$4[ebp], 0
  00144	74 4f		 je	 SHORT $LN12@AddPetItem

; 3255 : 		{
; 3256 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3257 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3258 : #else
; 3259 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  00146	6a 01		 push	 1
  00148	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00152	51		 push	 ecx
  00153	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00156	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  0015a	50		 push	 eax
  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00162	52		 push	 edx
  00163	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00166	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  0016a	51		 push	 ecx
  0016b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0016e	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00172	50		 push	 eax
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0017a	52		 push	 edx
  0017b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3260 : #endif
; 3261 : 
; 3262 : 			PetValue();

  00183	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00186	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3263 : 			return TRUE;

  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	e9 f5 00 00 00	 jmp	 $LN1@AddPetItem
$LN12@AddPetItem:

; 3264 : 		}
; 3265 : 	}

  00195	e9 ee 00 00 00	 jmp	 $LN15@AddPetItem
$LN9@AddPetItem:

; 3266 : 	else if (m_Type == MAKE_ITEMNUM(13, 5))

  0019a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0019d	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  001a1	6a 05		 push	 5
  001a3	6a 0d		 push	 13			; 0000000dH
  001a5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001aa	83 c4 08	 add	 esp, 8
  001ad	3b f0		 cmp	 esi, eax
  001af	0f 85 d3 00 00
	00		 jne	 $LN15@AddPetItem

; 3267 : 	{	// 다크스피릿
; 3268 : 		if (m_PetItem_Level >= MAX_DARK_SPIRIT_LEVEL)

  001b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b8	83 b8 a0 00 00
	00 32		 cmp	 DWORD PTR [eax+160], 50	; 00000032H
  001bf	7c 07		 jl	 SHORT $LN14@AddPetItem

; 3269 : 			return FALSE;	// 최대 레벨이면 경험치 상승 없다

  001c1	33 c0		 xor	 eax, eax
  001c3	e9 c2 00 00 00	 jmp	 $LN1@AddPetItem
$LN14@AddPetItem:

; 3270 : 
; 3271 : 		BOOL	IsLevelUp = FALSE;

  001c8	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _IsLevelUp$2[ebp], 0

; 3272 : 
; 3273 : 		int nextexp = gPetItemExp.m_DarkSpiritExpTable[m_PetItem_Level + 1];

  001cf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d2	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  001d8	8b 14 8d 04 00
	00 00		 mov	 edx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+4]
  001df	89 55 ec	 mov	 DWORD PTR _nextexp$1[ebp], edx

; 3274 : 		m_PetItem_Exp += petexp;

  001e2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e5	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  001eb	03 4d 08	 add	 ecx, DWORD PTR _petexp$[ebp]
  001ee	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f1	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx
$LN4@AddPetItem:

; 3275 : 
; 3276 : 		while (m_PetItem_Exp >= nextexp)

  001f7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001fa	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00200	3b 4d ec	 cmp	 ecx, DWORD PTR _nextexp$1[ebp]
  00203	7c 31		 jl	 SHORT $LN5@AddPetItem

; 3277 : 		{
; 3278 : 			m_PetItem_Level++;

  00205	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00208	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0020e	83 c1 01	 add	 ecx, 1
  00211	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00214	89 8a a0 00 00
	00		 mov	 DWORD PTR [edx+160], ecx

; 3279 : 			nextexp = gPetItemExp.m_DarkSpiritExpTable[m_PetItem_Level + 1];

  0021a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0021d	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00223	8b 14 8d 04 00
	00 00		 mov	 edx, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+4]
  0022a	89 55 ec	 mov	 DWORD PTR _nextexp$1[ebp], edx

; 3280 : 			IsLevelUp = TRUE;

  0022d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _IsLevelUp$2[ebp], 1

; 3281 : 			//m_PetItem_Exp = gPetItemExp.m_DarkSpiritExpTable[m_PetItem_Level+1];			
; 3282 : 		}

  00234	eb c1		 jmp	 SHORT $LN4@AddPetItem
$LN5@AddPetItem:

; 3283 : 
; 3284 : 		if (IsLevelUp)

  00236	83 7d f0 00	 cmp	 DWORD PTR _IsLevelUp$2[ebp], 0
  0023a	74 4c		 je	 SHORT $LN15@AddPetItem

; 3285 : 		{
; 3286 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3287 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3288 : #else
; 3289 : 			Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  0023c	6a 01		 push	 1
  0023e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00241	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00248	51		 push	 ecx
  00249	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0024c	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  00250	50		 push	 eax
  00251	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00254	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00258	52		 push	 edx
  00259	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025c	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00260	51		 push	 ecx
  00261	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00264	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00268	50		 push	 eax
  00269	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0026c	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00270	52		 push	 edx
  00271	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00274	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3290 : #endif
; 3291 : 			PetValue();

  00279	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0027c	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3292 : 			return TRUE;

  00281	b8 01 00 00 00	 mov	 eax, 1
  00286	eb 02		 jmp	 SHORT $LN1@AddPetItem
$LN15@AddPetItem:

; 3293 : 		}
; 3294 : 	}
; 3295 : 	return FALSE;

  00288	33 c0		 xor	 eax, eax
$LN1@AddPetItem:

; 3296 : }

  0028a	5f		 pop	 edi
  0028b	5e		 pop	 esi
  0028c	5b		 pop	 ebx
  0028d	8b e5		 mov	 esp, ebp
  0028f	5d		 pop	 ebp
  00290	c2 04 00	 ret	 4
?AddPetItemExp@CItem@@QAEHH@Z ENDP			; CItem::AddPetItemExp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?SetPetItemInfo@CItem@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_petlevel$ = 8						; size = 4
_petexp$ = 12						; size = 4
?SetPetItemInfo@CItem@@QAEXHH@Z PROC			; CItem::SetPetItemInfo, COMDAT
; _this$ = ecx

; 3166 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3167 : 	//|| m_Type == MAKE_ITEMNUM(13,5) )
; 3168 : 	if (m_Type == MAKE_ITEMNUM(13, 4))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00013	6a 04		 push	 4
  00015	6a 0d		 push	 13			; 0000000dH
  00017	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0001c	83 c4 08	 add	 esp, 8
  0001f	3b f0		 cmp	 esi, eax
  00021	0f 85 be 00 00
	00		 jne	 $LN2@SetPetItem

; 3169 : 	{	// 다크호스
; 3170 : 		m_PetItem_Level = petlevel;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _petlevel$[ebp]
  0002d	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx

; 3171 : 		m_PetItem_Exp = petexp;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _petexp$[ebp]
  00039	89 88 a4 00 00
	00		 mov	 DWORD PTR [eax+164], ecx

; 3172 : 
; 3173 : 		if (m_PetItem_Exp < gPetItemExp.m_DarkHorseExpTable[m_PetItem_Level] ||

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00048	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00051	3b 04 8d d0 00
	00 00		 cmp	 eax, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+208]
  00058	7c 1b		 jl	 SHORT $LN5@SetPetItem
  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0006c	3b 04 8d d4 00
	00 00		 cmp	 eax, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+212]
  00073	7c 19		 jl	 SHORT $LN4@SetPetItem
$LN5@SetPetItem:

; 3174 : 			m_PetItem_Exp >= gPetItemExp.m_DarkHorseExpTable[m_PetItem_Level + 1])
; 3175 : 		{
; 3176 : 			m_PetItem_Exp = gPetItemExp.m_DarkHorseExpTable[m_PetItem_Level];

  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 04 8d d0 00
	00 00		 mov	 eax, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+208]
  00088	89 82 a4 00 00
	00		 mov	 DWORD PTR [edx+164], eax
$LN4@SetPetItem:

; 3177 : 		}
; 3178 : 
; 3179 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3180 : 		Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3181 : #else
; 3182 : 		Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  0008e	6a 01		 push	 1
  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  0009a	51		 push	 ecx
  0009b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  000a2	50		 push	 eax
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  000aa	52		 push	 edx
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  000b2	51		 push	 ecx
  000b3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  000ba	50		 push	 eax
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  000c2	52		 push	 edx
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3183 : #endif
; 3184 : 		PetValue();

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3185 : 
; 3186 : 		m_IsLoadPetItemInfo = TRUE;

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	c7 80 9c 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+156], 1

; 3187 : 	}

  000e0	e9 d4 00 00 00	 jmp	 $LN1@SetPetItem
$LN2@SetPetItem:

; 3188 : 	else if (m_Type == MAKE_ITEMNUM(13, 5))

  000e5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000ec	6a 05		 push	 5
  000ee	6a 0d		 push	 13			; 0000000dH
  000f0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000f5	83 c4 08	 add	 esp, 8
  000f8	3b f0		 cmp	 esi, eax
  000fa	0f 85 b9 00 00
	00		 jne	 $LN1@SetPetItem

; 3189 : 	{	// 다크스피릿
; 3190 : 		m_PetItem_Level = petlevel;

  00100	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00103	8b 4d 08	 mov	 ecx, DWORD PTR _petlevel$[ebp]
  00106	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx

; 3191 : 		m_PetItem_Exp = petexp;

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010f	8b 4d 0c	 mov	 ecx, DWORD PTR _petexp$[ebp]
  00112	89 88 a4 00 00
	00		 mov	 DWORD PTR [eax+164], ecx

; 3192 : 
; 3193 : 		if (m_PetItem_Exp < gPetItemExp.m_DarkSpiritExpTable[m_PetItem_Level] ||

  00118	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011b	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00121	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00124	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  0012a	3b 04 8d 00 00
	00 00		 cmp	 eax, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4]
  00131	7c 1b		 jl	 SHORT $LN8@SetPetItem
  00133	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00136	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0013c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0013f	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00145	3b 04 8d 04 00
	00 00		 cmp	 eax, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4+4]
  0014c	7c 19		 jl	 SHORT $LN7@SetPetItem
$LN8@SetPetItem:

; 3194 : 			m_PetItem_Exp >= gPetItemExp.m_DarkSpiritExpTable[m_PetItem_Level + 1])
; 3195 : 		{
; 3196 : 			m_PetItem_Exp = gPetItemExp.m_DarkSpiritExpTable[m_PetItem_Level];

  0014e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00151	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00157	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0015a	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR ?gPetItemExp@@3VCPetItemExp@@A[ecx*4]
  00161	89 82 a4 00 00
	00		 mov	 DWORD PTR [edx+164], eax
$LN7@SetPetItem:

; 3197 : 		}
; 3198 : 
; 3199 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 3200 : 		Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption, m_ItemOptionEx);
; 3201 : #else
; 3202 : 		Convert(m_Type, m_Option1, m_Option2, m_Option3, m_NewOption, m_SetOption);

  00167	6a 01		 push	 1
  00169	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0016c	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00173	51		 push	 ecx
  00174	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00177	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  0017b	50		 push	 eax
  0017c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  00183	52		 push	 edx
  00184	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00187	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  0018b	51		 push	 ecx
  0018c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0018f	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  00193	50		 push	 eax
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  0019b	52		 push	 edx
  0019c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 3203 : #endif
; 3204 : 
; 3205 : 
; 3206 : 		PetValue();

  001a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a7	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue

; 3207 : 
; 3208 : 		m_IsLoadPetItemInfo = TRUE;

  001ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001af	c7 80 9c 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+156], 1
$LN1@SetPetItem:

; 3209 : 	}
; 3210 : }

  001b9	5f		 pop	 edi
  001ba	5e		 pop	 esi
  001bb	5b		 pop	 ebx
  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 08 00	 ret	 8
?SetPetItemInfo@CItem@@QAEXHH@Z ENDP			; CItem::SetPetItemInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetAddStatType@CItem@@QAEHXZ
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
?GetAddStatType@CItem@@QAEHXZ PROC			; CItem::GetAddStatType, COMDAT
; _this$ = ecx

; 3146 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3147 : 	ITEM_ATTRIBUTE *p = &ItemAttribute[m_Type];

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	6b d1 6c	 imul	 edx, ecx, 108
  00016	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0001c	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx

; 3148 : 	return p->SetAttr;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00022	0f b6 40 5d	 movzx	 eax, BYTE PTR [eax+93]

; 3149 : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?GetAddStatType@CItem@@QAEHXZ ENDP			; CItem::GetAddStatType
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsSetItem@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSetItem@CItem@@QAEHXZ PROC				; CItem::IsSetItem, COMDAT
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 	if (m_Type < 0) return FALSE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 04		 jge	 SHORT $LN2@IsSetItem
  00017	33 c0		 xor	 eax, eax
  00019	eb 0d		 jmp	 SHORT $LN1@IsSetItem
$LN2@IsSetItem:

; 131  : 
; 132  : 	return m_SetOption & 0x03;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	0f b6 80 92 00
	00 00		 movzx	 eax, BYTE PTR [eax+146]
  00025	83 e0 03	 and	 eax, 3
$LN1@IsSetItem:

; 133  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?IsSetItem@CItem@@QAEHXZ ENDP				; CItem::IsSetItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?IsItem@CItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsItem@CItem@@QAEHXZ PROC				; CItem::IsItem, COMDAT
; _this$ = ecx

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  : 	if (m_Type < 0) return FALSE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 04		 jge	 SHORT $LN2@IsItem
  00017	33 c0		 xor	 eax, eax
  00019	eb 05		 jmp	 SHORT $LN1@IsItem
$LN2@IsItem:

; 123  : 
; 124  : 	return TRUE;

  0001b	b8 01 00 00 00	 mov	 eax, 1
$LN1@IsItem:

; 125  : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?IsItem@CItem@@QAEHXZ ENDP				; CItem::IsItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?Clear@CItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CItem@@QAEXXZ PROC				; CItem::Clear, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 	m_Type = -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 50   : 	m_Level = 0;

  00016	33 c0		 xor	 eax, eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 51   : 	m_Part = 0;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c6 40 0a 00	 mov	 BYTE PTR [eax+10], 0

; 52   : 	m_Class = 0;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c6 40 0b 00	 mov	 BYTE PTR [eax+11], 0

; 53   : 	m_TwoHand = 0;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 54   : 	m_AttackSpeed = 0;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 55   : 	m_DamageMin = 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 56   : 	m_DamageMax = 0;

  00044	33 c0		 xor	 eax, eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 57   : 	m_SuccessfulBlocking = 0;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0

; 58   : 	m_Defense = 0;

  00054	33 c0		 xor	 eax, eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 59   : 	m_MagicDefense = 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	66 89 41 18	 mov	 WORD PTR [ecx+24], ax

; 60   : 	m_Durability = 0;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 61   : 	m_SpecialNum = 0;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	c6 40 30 00	 mov	 BYTE PTR [eax+48], 0

; 62   : 	m_Value = 0;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [eax+92], 0

; 63   : 	m_Option1 = 0;

  00082	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00085	c6 40 78 00	 mov	 BYTE PTR [eax+120], 0

; 64   : 	m_Option2 = 0;

  00089	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	c6 40 79 00	 mov	 BYTE PTR [eax+121], 0

; 65   : 	m_Option3 = 0;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	c6 40 7a 00	 mov	 BYTE PTR [eax+122], 0

; 66   : 	m_NewOption = 0;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	c6 40 7b 00	 mov	 BYTE PTR [eax+123], 0

; 67   : 	m_Number = 0;

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 68   : 	m_DurabilitySmall = 0;

  000a7	33 c0		 xor	 eax, eax
  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 69   : 
; 70   : #ifdef PERSONAL_SHOP_20040113
; 71   : 	m_iPShopValue = -1;			// 이 값이 -1 이면 물건은 팔리지 않는다. (사용자가 아직 정의하지 않은 것이므로)

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	c7 40 68 ff ff
	ff ff		 mov	 DWORD PTR [eax+104], -1

; 72   : #endif
; 73   : 
; 74   : #ifdef ITEMDELETE_MODIFY_20040604	// 아이템 속성 중 아이템이 존재하는 아이템인가 아닌가에 대한 플래그 (초기화)
; 75   : 	m_bItemExist = true;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	c6 40 6c 01	 mov	 BYTE PTR [eax+108], 1

; 76   : #endif
; 77   : 
; 78   : 
; 79   : 	m_CurrentDurabilityState = -1.f;

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000cc	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0

; 80   : 
; 81   : 	m_SetOption = 0;

  000d4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	c6 80 92 00 00
	00 00		 mov	 BYTE PTR [eax+146], 0

; 82   : 
; 83   : #ifdef NEW_SKILL_FORSKYLAND
; 84   : 	m_QuestItem = 0;		// 퀘스트 아이템?

  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	c6 80 91 00 00
	00 00		 mov	 BYTE PTR [eax+145], 0

; 85   : #endif	
; 86   : 
; 87   : 
; 88   : 	memset(m_Special, 0, MAX_ITEM_SPECIAL);

  000e8	6a 08		 push	 8
  000ea	6a 00		 push	 0
  000ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	83 c0 31	 add	 eax, 49			; 00000031H
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _memset
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 89   : 	memset(m_SpecialValue, 0, MAX_ITEM_SPECIAL);

  000fb	6a 08		 push	 8
  000fd	6a 00		 push	 0
  000ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00102	83 c0 39	 add	 eax, 57			; 00000039H
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _memset
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 90   : 
; 91   : 	memset(m_Resistance, 0, MAX_RESISTANCE);

  0010e	6a 07		 push	 7
  00110	6a 00		 push	 0
  00112	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00115	83 c0 55	 add	 eax, 85			; 00000055H
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _memset
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 92   : 
; 93   : #ifdef DARKLORD_WORK	// 다크스피릿, 다크호스 등의 펫(레벨및경험치를 가지는) 아이템 정보 
; 94   : 	m_IsLoadPetItemInfo = FALSE;

  00121	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00124	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+156], 0

; 95   : 	m_PetItem_Level = 1;

  0012e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00131	c7 80 a0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+160], 1

; 96   : 	m_PetItem_Exp = 0;

  0013b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013e	c7 80 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+164], 0

; 97   : 	m_Leadership = 0;

  00148	33 c0		 xor	 eax, eax
  0014a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	66 89 41 4e	 mov	 WORD PTR [ecx+78], ax

; 98   : #endif
; 99   : 
; 100  : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 101  : 	m_JewelOfHarmonyOption = 0;		// 조화의보석에 의한 추가 옵션
; 102  : #endif
; 103  : 
; 104  : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 105  : 	m_ItemOptionEx = 0; // 아이템 추가 옵션 : 상위 1bit 380 아이템 추가옵션
; 106  : #endif
; 107  : 
; 108  : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 109  : 	m_BonusSocketOption = SOCKETSLOT_NONE;
; 110  : 	memset(m_SocketOption, SOCKETSLOT_NONE, MAX_SOCKET_SLOT);
; 111  : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 112  : 
; 113  : #ifdef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 114  : 	m_ImproveDurabilityRate = 0;
; 115  : #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 116  : }

  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	5b		 pop	 ebx
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
?Clear@CItem@@QAEXXZ ENDP				; CItem::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?GetSize@CItem@@QAEHAAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_w$ = 8							; size = 4
_h$ = 12						; size = 4
?GetSize@CItem@@QAEHAAH0@Z PROC				; CItem::GetSize, COMDAT
; _this$ = ecx

; 2847 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2848 : #ifdef _DEBUG
; 2849 : 	if (m_Type < 0 || m_Type > MAX_ITEM - 1)
; 2850 : 	{
; 2851 : 		LogAdd("error: %s %d (m_Type:%d)", __FILE__, __LINE__, m_Type);
; 2852 : 		return FALSE;
; 2853 : 	}
; 2854 : #endif
; 2855 : 	w = ItemAttribute[m_Type].Width;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	6b d1 6c	 imul	 edx, ecx, 108
  00016	0f b6 82 23 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[edx+35]
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _w$[ebp]
  00020	89 01		 mov	 DWORD PTR [ecx], eax

; 2856 : 	h = ItemAttribute[m_Type].Height;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00029	6b d1 6c	 imul	 edx, ecx, 108
  0002c	0f b6 82 24 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[edx+36]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _h$[ebp]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 2857 : 
; 2858 : 	return TRUE;

  00038	b8 01 00 00 00	 mov	 eax, 1

; 2859 : 	//LogAdd("Item:%d %d", w, h);
; 2860 : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?GetSize@CItem@@QAEHAAH0@Z ENDP				; CItem::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?OldValue@CItem@@QAEXXZ
_TEXT	SEGMENT
_Gold$ = -8						; size = 4
_this$ = -4						; size = 4
?OldValue@CItem@@QAEXXZ PROC				; CItem::OldValue, COMDAT
; _this$ = ecx

; 2775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2776 : 	if (m_Type == -1) return;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00013	83 f9 ff	 cmp	 ecx, -1
  00016	75 05		 jne	 SHORT $LN2@OldValue
  00018	e9 db 00 00 00	 jmp	 $LN1@OldValue
$LN2@OldValue:

; 2777 : 
; 2778 : 	int Gold = 0;

  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp], 0

; 2779 : 	/*ITEM_ATTRIBUTE *p = &ItemAttribute[m_Type];
; 2780 : 	int Level = (int)sqrt(m_Level);
; 2781 : 
; 2782 : 	int Type = m_Type/MAX_ITEM_INDEX;
; 2783 : 
; 2784 : 	int Level2 = p->Level+m_Level*3;
; 2785 : 	int excellent=FALSE;*/
; 2786 : 
; 2787 : 	if (m_Type == ITEM_POTION + 13)	// 축석

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0002b	81 f9 cd 01 00
	00		 cmp	 ecx, 461		; 000001cdH
  00031	75 09		 jne	 SHORT $LN3@OldValue

; 2788 : 	{
; 2789 : 		Gold = 100000;

  00033	c7 45 f8 a0 86
	01 00		 mov	 DWORD PTR _Gold$[ebp], 100000 ; 000186a0H

; 2790 : 	}

  0003a	eb 6e		 jmp	 SHORT $LN4@OldValue
$LN3@OldValue:

; 2791 : 	else if (m_Type == ITEM_POTION + 14)	// 영석

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00043	81 f9 ce 01 00
	00		 cmp	 ecx, 462		; 000001ceH
  00049	75 09		 jne	 SHORT $LN5@OldValue

; 2792 : 	{
; 2793 : 		Gold = 70000;

  0004b	c7 45 f8 70 11
	01 00		 mov	 DWORD PTR _Gold$[ebp], 70000 ; 00011170H

; 2794 : 	}

  00052	eb 56		 jmp	 SHORT $LN4@OldValue
$LN5@OldValue:

; 2795 : 	else if (m_Type == ITEM_WING + 15)	// 혼석

  00054	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00057	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0005b	81 f9 8f 01 00
	00		 cmp	 ecx, 399		; 0000018fH
  00061	75 09		 jne	 SHORT $LN7@OldValue

; 2796 : 	{
; 2797 : 		Gold = 40000;

  00063	c7 45 f8 40 9c
	00 00		 mov	 DWORD PTR _Gold$[ebp], 40000 ; 00009c40H

; 2798 : 	}

  0006a	eb 3e		 jmp	 SHORT $LN4@OldValue
$LN7@OldValue:

; 2799 : 	else if (m_Type == ITEM_POTION + 22)	// 창석

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00073	81 f9 d6 01 00
	00		 cmp	 ecx, 470		; 000001d6H
  00079	75 09		 jne	 SHORT $LN9@OldValue

; 2800 : 	{
; 2801 : 		Gold = 450000;

  0007b	c7 45 f8 d0 dd
	06 00		 mov	 DWORD PTR _Gold$[ebp], 450000 ; 0006ddd0H

; 2802 : 	}

  00082	eb 26		 jmp	 SHORT $LN4@OldValue
$LN9@OldValue:

; 2803 : 	else if (m_Type == ITEM_POTION + 16)	// 생석

  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0008b	81 f9 d0 01 00
	00		 cmp	 ecx, 464		; 000001d0H
  00091	75 09		 jne	 SHORT $LN11@OldValue

; 2804 : 	{
; 2805 : 		Gold = 450000;

  00093	c7 45 f8 d0 dd
	06 00		 mov	 DWORD PTR _Gold$[ebp], 450000 ; 0006ddd0H

; 2806 : 	}

  0009a	eb 0e		 jmp	 SHORT $LN4@OldValue
$LN11@OldValue:

; 2807 : 	else
; 2808 : 	{
; 2809 : 		//m_OldSellMoney = m_SellMoney;
; 2810 : 		m_OldBuyMoney = m_BuyMoney;

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000a5	89 50 74	 mov	 DWORD PTR [eax+116], edx

; 2811 : 		return;

  000a8	eb 4e		 jmp	 SHORT $LN1@OldValue
$LN4@OldValue:

; 2812 : 	}
; 2813 : 
; 2814 : 	//m_OldSellMoney = Gold;
; 2815 : 	m_OldBuyMoney = Gold;

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _Gold$[ebp]
  000b0	89 48 74	 mov	 DWORD PTR [eax+116], ecx

; 2816 : 
; 2817 : 	//m_OldSellMoney = m_OldSellMoney/3;		
; 2818 : 
; 2819 : 	/*if( m_Type < ITEM_POTION || m_Type > ITEM_POTION+8)
; 2820 : 	{
; 2821 : 		float  persent = 1.f - m_Durability/m_BaseDurability;
; 2822 : 		int	   repairGold = (int)(m_OldSellMoney * 0.6 * persent);
; 2823 : 		m_OldSellMoney -= repairGold;
; 2824 : 	}
; 2825 : 	*/
; 2826 : 
; 2827 : 	//if(p->Durability > 0)
; 2828 : 	//	m_OldSellMoney += m_SellMoney*m_Durability/p->Durability;
; 2829 : 
; 2830 : 	/*
; 2831 : 	if(m_OldSellMoney>= 1000)
; 2832 : 		m_OldSellMoney = m_OldSellMoney/100*100;
; 2833 : 	else if(m_OldSellMoney >= 100)
; 2834 : 		m_OldSellMoney = m_OldSellMoney/10*10;
; 2835 : 		*/
; 2836 : 
; 2837 : 	if (m_OldBuyMoney >= 1000)

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	81 78 74 e8 03
	00 00		 cmp	 DWORD PTR [eax+116], 1000 ; 000003e8H
  000bd	7c 19		 jl	 SHORT $LN13@OldValue

; 2838 : 		m_OldBuyMoney = m_OldBuyMoney / 100 * 100;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 40 74	 mov	 eax, DWORD PTR [eax+116]
  000c5	99		 cdq
  000c6	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000cb	f7 f9		 idiv	 ecx
  000cd	6b d0 64	 imul	 edx, eax, 100
  000d0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	89 50 74	 mov	 DWORD PTR [eax+116], edx
  000d6	eb 20		 jmp	 SHORT $LN1@OldValue
$LN13@OldValue:

; 2839 : 	else if (m_OldBuyMoney >= 100)

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000db	83 78 74 64	 cmp	 DWORD PTR [eax+116], 100 ; 00000064H
  000df	7c 17		 jl	 SHORT $LN1@OldValue

; 2840 : 		m_OldBuyMoney = m_OldBuyMoney / 10 * 10;

  000e1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	8b 40 74	 mov	 eax, DWORD PTR [eax+116]
  000e7	99		 cdq
  000e8	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000ed	f7 f9		 idiv	 ecx
  000ef	6b d0 0a	 imul	 edx, eax, 10
  000f2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	89 50 74	 mov	 DWORD PTR [eax+116], edx
$LN1@OldValue:

; 2841 : }

  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
?OldValue@CItem@@QAEXXZ ENDP				; CItem::OldValue
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?Value@CItem@@QAEXXZ
_TEXT	SEGMENT
tv1191 = -140						; size = 8
tv835 = -136						; size = 8
tv1218 = -132						; size = 4
tv1187 = -132						; size = 4
tv499 = -132						; size = 4
tv470 = -132						; size = 4
tv462 = -132						; size = 4
tv419 = -132						; size = 4
tv408 = -132						; size = 4
tv329 = -132						; size = 4
tv322 = -132						; size = 4
tv311 = -132						; size = 4
tv300 = -132						; size = 4
tv280 = -132						; size = 4
tv269 = -132						; size = 4
tv261 = -132						; size = 4
tv253 = -132						; size = 4
tv160 = -132						; size = 4
_repairGold$1 = -64					; size = 4
_persent$2 = -60					; size = 4
_i$3 = -56						; size = 4
_i$4 = -52						; size = 4
_i$5 = -48						; size = 4
_levelgold$6 = -44					; size = 4
_levelgold$7 = -40					; size = 4
_i$8 = -36						; size = 4
_excellent$ = -32					; size = 4
_Level2$ = -28						; size = 4
_Type$ = -24						; size = 4
_Gold$ = -20						; size = 8
_Level$ = -12						; size = 4
_p$ = -8						; size = 4
_this$ = -4						; size = 4
?Value@CItem@@QAEXXZ PROC				; CItem::Value, COMDAT
; _this$ = ecx

; 1631 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1632 : #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 1633 : 	m_SellMoney = 0;		// WT 이벤트 서버 아이템 가격은 0
; 1634 : 	m_BuyMoney = 0;
; 1635 : 	return;
; 1636 : #endif
; 1637 : 
; 1638 : 	if (m_Type == -1) return;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00016	83 f9 ff	 cmp	 ecx, -1
  00019	75 05		 jne	 SHORT $LN42@Value
  0001b	e9 ef 11 00 00	 jmp	 $LN1@Value
$LN42@Value:

; 1639 : 
; 1640 : 	ITEM_ATTRIBUTE *p = &ItemAttribute[m_Type];

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00027	6b d1 6c	 imul	 edx, ecx, 108
  0002a	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00030	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx

; 1641 : 
; 1642 : 	if (p->BuyMoney)

  00033	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00036	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0003a	0f 84 c0 00 00
	00		 je	 $LN43@Value

; 1643 : 	{
; 1644 : 		m_SellMoney = p->BuyMoney;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  00046	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00049	89 50 60	 mov	 DWORD PTR [eax+96], edx

; 1645 : 		m_BuyMoney = p->BuyMoney;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  00052	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00055	89 50 64	 mov	 DWORD PTR [eax+100], edx

; 1646 : 
; 1647 : 		m_SellMoney = m_SellMoney / 3;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0005e	33 d2		 xor	 edx, edx
  00060	b9 03 00 00 00	 mov	 ecx, 3
  00065	f7 f1		 div	 ecx
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	89 42 60	 mov	 DWORD PTR [edx+96], eax

; 1648 : 
; 1649 : 		if (m_SellMoney >= 1000)

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	81 78 60 e8 03
	00 00		 cmp	 DWORD PTR [eax+96], 1000 ; 000003e8H
  00077	72 1a		 jb	 SHORT $LN44@Value

; 1650 : 			m_SellMoney = m_SellMoney / 100 * 100;

  00079	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0007f	33 d2		 xor	 edx, edx
  00081	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00086	f7 f1		 div	 ecx
  00088	6b d0 64	 imul	 edx, eax, 100
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	89 50 60	 mov	 DWORD PTR [eax+96], edx
  00091	eb 21		 jmp	 SHORT $LN46@Value
$LN44@Value:

; 1651 : 		else if (m_SellMoney >= 100)

  00093	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00096	83 78 60 64	 cmp	 DWORD PTR [eax+96], 100	; 00000064H
  0009a	72 18		 jb	 SHORT $LN46@Value

; 1652 : 			m_SellMoney = m_SellMoney / 10 * 10;

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  000a2	33 d2		 xor	 edx, edx
  000a4	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000a9	f7 f1		 div	 ecx
  000ab	6b d0 0a	 imul	 edx, eax, 10
  000ae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	89 50 60	 mov	 DWORD PTR [eax+96], edx
$LN46@Value:

; 1653 : 
; 1654 : 		if (m_BuyMoney >= 1000)

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	81 78 64 e8 03
	00 00		 cmp	 DWORD PTR [eax+100], 1000 ; 000003e8H
  000be	72 1a		 jb	 SHORT $LN47@Value

; 1655 : 			m_BuyMoney = m_BuyMoney / 100 * 100;

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  000c6	33 d2		 xor	 edx, edx
  000c8	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000cd	f7 f1		 div	 ecx
  000cf	6b d0 64	 imul	 edx, eax, 100
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	89 50 64	 mov	 DWORD PTR [eax+100], edx
  000d8	eb 21		 jmp	 SHORT $LN49@Value
$LN47@Value:

; 1656 : 		else if (m_BuyMoney >= 100)

  000da	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	83 78 64 64	 cmp	 DWORD PTR [eax+100], 100 ; 00000064H
  000e1	72 18		 jb	 SHORT $LN49@Value

; 1657 : 			m_BuyMoney = m_BuyMoney / 10 * 10;

  000e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  000e9	33 d2		 xor	 edx, edx
  000eb	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000f0	f7 f1		 div	 ecx
  000f2	6b d0 0a	 imul	 edx, eax, 10
  000f5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN49@Value:

; 1658 : 
; 1659 : 		return;

  000fb	e9 0f 11 00 00	 jmp	 $LN1@Value
$LN43@Value:

; 1660 : 	}
; 1661 : 
; 1662 : 	int Level = (int)sqrt((double)m_Level);

  00100	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00103	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00107	f2 0f 2a c1	 cvtsi2sd xmm0, ecx
  0010b	83 ec 08	 sub	 esp, 8
  0010e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00113	e8 00 00 00 00	 call	 _sqrt
  00118	83 c4 08	 add	 esp, 8
  0011b	e8 00 00 00 00	 call	 __ftol2_sse
  00120	89 45 f4	 mov	 DWORD PTR _Level$[ebp], eax

; 1663 : 
; 1664 : 
; 1665 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 1666 : 	__int64 Gold = 0;

  00123	0f 57 c0	 xorps	 xmm0, xmm0
  00126	66 0f 13 45 ec	 movlpd	 QWORD PTR _Gold$[ebp], xmm0

; 1667 : #else
; 1668 : 	DWORD Gold = 0;
; 1669 : #endif
; 1670 : 
; 1671 : 	int Type = m_Type / MAX_ITEM_INDEX;

  0012b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0012e	0f bf 40 06	 movsx	 eax, WORD PTR [eax+6]
  00132	99		 cdq
  00133	83 e2 1f	 and	 edx, 31			; 0000001fH
  00136	03 c2		 add	 eax, edx
  00138	c1 f8 05	 sar	 eax, 5
  0013b	89 45 e8	 mov	 DWORD PTR _Type$[ebp], eax

; 1672 : 
; 1673 : 	int Level2 = p->Level + m_Level * 3;

  0013e	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00141	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  00145	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00148	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  0014c	6b d0 03	 imul	 edx, eax, 3
  0014f	03 ca		 add	 ecx, edx
  00151	89 4d e4	 mov	 DWORD PTR _Level2$[ebp], ecx

; 1674 : 	int excellent = FALSE;

  00154	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _excellent$[ebp], 0

; 1675 : 
; 1676 : 	for (int i = 0; i < m_SpecialNum; i++)

  0015b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  00162	eb 09		 jmp	 SHORT $LN4@Value
$LN2@Value:
  00164	8b 45 dc	 mov	 eax, DWORD PTR _i$8[ebp]
  00167	83 c0 01	 add	 eax, 1
  0016a	89 45 dc	 mov	 DWORD PTR _i$8[ebp], eax
$LN4@Value:
  0016d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00170	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  00174	39 4d dc	 cmp	 DWORD PTR _i$8[ebp], ecx
  00177	7d 2c		 jge	 SHORT $LN3@Value

; 1677 : 	{
; 1678 : 		switch (m_Special[i])

  00179	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0017c	03 45 dc	 add	 eax, DWORD PTR _i$8[ebp]
  0017f	8a 48 31	 mov	 cl, BYTE PTR [eax+49]
  00182	88 8d 7c ff ff
	ff		 mov	 BYTE PTR tv160[ebp], cl
  00188	80 bd 7c ff ff
	ff 56		 cmp	 BYTE PTR tv160[ebp], 86	; 00000056H
  0018f	72 12		 jb	 SHORT $LN5@Value
  00191	80 bd 7c ff ff
	ff 63		 cmp	 BYTE PTR tv160[ebp], 99	; 00000063H
  00198	76 02		 jbe	 SHORT $LN50@Value
  0019a	eb 07		 jmp	 SHORT $LN5@Value
$LN50@Value:

; 1679 : 		{
; 1680 : 		case AT_IMPROVE_LIFE:
; 1681 : 		case AT_IMPROVE_MANA:
; 1682 : 		case AT_DECREASE_DAMAGE:
; 1683 : 		case AT_REFLECTION_DAMAGE:
; 1684 : 		case AT_IMPROVE_BLOCKING_PERCENT:
; 1685 : 		case AT_IMPROVE_GAIN_GOLD:
; 1686 : 		case AT_EXCELLENT_DAMAGE:
; 1687 : 		case AT_IMPROVE_DAMAGE_LEVEL:
; 1688 : 		case AT_IMPROVE_DAMAGE_PERCENT:
; 1689 : 		case AT_IMPROVE_MAGIC_LEVEL:
; 1690 : 		case AT_IMPROVE_MAGIC_PERCENT:
; 1691 : 		case AT_IMPROVE_ATTACK_SPEED:
; 1692 : 		case AT_IMPROVE_GAIN_LIFE:
; 1693 : 		case AT_IMPROVE_GAIN_MANA:
; 1694 : 			excellent = TRUE;

  0019c	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _excellent$[ebp], 1
$LN5@Value:

; 1695 : 			break;
; 1696 : 		}
; 1697 : 	}

  001a3	eb bf		 jmp	 SHORT $LN2@Value
$LN3@Value:

; 1698 : 	if (excellent)

  001a5	83 7d e0 00	 cmp	 DWORD PTR _excellent$[ebp], 0
  001a9	74 09		 je	 SHORT $LN51@Value

; 1699 : 	{
; 1700 : 		Level2 += 25;

  001ab	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  001ae	83 c0 19	 add	 eax, 25			; 00000019H
  001b1	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
$LN51@Value:

; 1701 : 	}
; 1702 : 	if (m_Type == ITEM_BOW + 15)

  001b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b7	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  001bb	81 f9 8f 00 00
	00		 cmp	 ecx, 143		; 0000008fH
  001c1	0f 85 81 00 00
	00		 jne	 $LN52@Value

; 1703 : 	{	// 화살
; 1704 : 		int levelgold = 70;

  001c7	c7 45 d8 46 00
	00 00		 mov	 DWORD PTR _levelgold$7[ebp], 70 ; 00000046H

; 1705 : 		if (m_Level == 1)

  001ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  001d5	83 f9 01	 cmp	 ecx, 1
  001d8	75 09		 jne	 SHORT $LN54@Value

; 1706 : 		{
; 1707 : 			levelgold = 1200;

  001da	c7 45 d8 b0 04
	00 00		 mov	 DWORD PTR _levelgold$7[ebp], 1200 ; 000004b0H

; 1708 : 		}

  001e1	eb 28		 jmp	 SHORT $LN58@Value
$LN54@Value:

; 1709 : 		else if (m_Level == 2)

  001e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  001ea	83 f9 02	 cmp	 ecx, 2
  001ed	75 09		 jne	 SHORT $LN56@Value

; 1710 : 		{
; 1711 : 			levelgold = 2000;

  001ef	c7 45 d8 d0 07
	00 00		 mov	 DWORD PTR _levelgold$7[ebp], 2000 ; 000007d0H

; 1712 : 		}

  001f6	eb 13		 jmp	 SHORT $LN58@Value
$LN56@Value:

; 1713 : #ifdef UPDATE_ADD_ARROW_TYPE_PLUS_3_20081106
; 1714 : 		else if (m_Level == 3)

  001f8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001fb	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  001ff	83 f9 03	 cmp	 ecx, 3
  00202	75 07		 jne	 SHORT $LN58@Value

; 1715 : 		{
; 1716 : 			levelgold = 2800;

  00204	c7 45 d8 f0 0a
	00 00		 mov	 DWORD PTR _levelgold$7[ebp], 2800 ; 00000af0H
$LN58@Value:

; 1717 : 		}
; 1718 : #endif // UPDATE_ADD_ARROW_TYPE_PLUS_3_20081106
; 1719 : 
; 1720 : 		if (m_Durability > 0)

  0020b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0020e	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00213	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0021a	76 27		 jbe	 SHORT $LN59@Value

; 1721 : 		{
; 1722 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 1723 : 			Gold = (__int64)(levelgold * m_Durability / p->Durability);

  0021c	f3 0f 2a 45 d8	 cvtsi2ss xmm0, DWORD PTR _levelgold$7[ebp]
  00221	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00224	f3 0f 59 40 24	 mulss	 xmm0, DWORD PTR [eax+36]
  00229	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  0022c	0f b6 51 30	 movzx	 edx, BYTE PTR [ecx+48]
  00230	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00234	f3 0f 5e c1	 divss	 xmm0, xmm1
  00238	e8 00 00 00 00	 call	 __ftol3
  0023d	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00240	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN59@Value:

; 1724 : #else
; 1725 : 			Gold = (DWORD)(levelgold * m_Durability / p->Durability);
; 1726 : #endif
; 1727 : 		}
; 1728 : 		//  	Gold = (int)(70 * m_Durability / p->Durability)+(80*(m_Level*2));
; 1729 : 	}

  00243	e9 64 0d 00 00	 jmp	 $LN34@Value
$LN52@Value:

; 1730 : 	else if (m_Type == ITEM_BOW + 7)

  00248	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0024b	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0024f	81 f9 87 00 00
	00		 cmp	 ecx, 135		; 00000087H
  00255	0f 85 81 00 00
	00		 jne	 $LN60@Value

; 1731 : 	{
; 1732 : 		if (m_Durability > 0)

  0025b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025e	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00263	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0026a	76 6b		 jbe	 SHORT $LN62@Value

; 1733 : 		{
; 1734 : 			int levelgold = 100;

  0026c	c7 45 d4 64 00
	00 00		 mov	 DWORD PTR _levelgold$6[ebp], 100 ; 00000064H

; 1735 : 			if (m_Level == 1)

  00273	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00276	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0027a	83 f9 01	 cmp	 ecx, 1
  0027d	75 09		 jne	 SHORT $LN63@Value

; 1736 : 			{
; 1737 : 				levelgold = 1400;

  0027f	c7 45 d4 78 05
	00 00		 mov	 DWORD PTR _levelgold$6[ebp], 1400 ; 00000578H

; 1738 : 			}

  00286	eb 28		 jmp	 SHORT $LN67@Value
$LN63@Value:

; 1739 : 			else if (m_Level == 2)

  00288	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0028b	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0028f	83 f9 02	 cmp	 ecx, 2
  00292	75 09		 jne	 SHORT $LN65@Value

; 1740 : 			{
; 1741 : 				levelgold = 2200;

  00294	c7 45 d4 98 08
	00 00		 mov	 DWORD PTR _levelgold$6[ebp], 2200 ; 00000898H

; 1742 : 			}

  0029b	eb 13		 jmp	 SHORT $LN67@Value
$LN65@Value:

; 1743 : #ifdef UPDATE_ADD_ARROW_TYPE_PLUS_3_20081106
; 1744 : 			else if (m_Level == 3)

  0029d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002a0	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  002a4	83 f9 03	 cmp	 ecx, 3
  002a7	75 07		 jne	 SHORT $LN67@Value

; 1745 : 			{
; 1746 : 				levelgold = 3000;

  002a9	c7 45 d4 b8 0b
	00 00		 mov	 DWORD PTR _levelgold$6[ebp], 3000 ; 00000bb8H
$LN67@Value:

; 1747 : 			}
; 1748 : #endif // UPDATE_ADD_ARROW_TYPE_PLUS_3_20081106
; 1749 : 
; 1750 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 1751 : 			Gold = (__int64)(levelgold * m_Durability / p->Durability);

  002b0	f3 0f 2a 45 d4	 cvtsi2ss xmm0, DWORD PTR _levelgold$6[ebp]
  002b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002b8	f3 0f 59 40 24	 mulss	 xmm0, DWORD PTR [eax+36]
  002bd	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  002c0	0f b6 51 30	 movzx	 edx, BYTE PTR [ecx+48]
  002c4	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  002c8	f3 0f 5e c1	 divss	 xmm0, xmm1
  002cc	e8 00 00 00 00	 call	 __ftol3
  002d1	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  002d4	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN62@Value:

; 1752 : #else
; 1753 : 			Gold = (DWORD)(levelgold * m_Durability / p->Durability);
; 1754 : #endif
; 1755 : 		}
; 1756 : 		//Gold = (int)(100 * m_Durability / p->Durability)+(170*(m_Level*2));
; 1757 : 	}

  002d7	e9 d0 0c 00 00	 jmp	 $LN34@Value
$LN60@Value:

; 1758 : #ifdef FOR_TEMP_SERVER
; 1759 : 	//------------------------------------------>
; 1760 : 	//grooving SEASON4 20080728 : 보석 판매 가격 1000 으로 통일(시즌4 체험 서버 임시)
; 1761 : 	else if (m_Type == ITEM_POTION + 13)	// 축석
; 1762 : 	{
; 1763 : 		//Gold = 9000000;
; 1764 : 		Gold = 1000;
; 1765 : 	}
; 1766 : 	else if (m_Type == ITEM_POTION + 14)	// 영석
; 1767 : 	{
; 1768 : 		//Gold = 6000000;
; 1769 : 		Gold = 1000;
; 1770 : 	}
; 1771 : 	else if (m_Type == ITEM_WING + 15)	// 혼석
; 1772 : 	{
; 1773 : 		//Gold = 810000;
; 1774 : 		Gold = 1000;
; 1775 : 	}
; 1776 : 	else if (m_Type == ITEM_POTION + 16)	// 생석
; 1777 : 	{
; 1778 : 		//Gold = 45000000;
; 1779 : 		Gold = 1000;
; 1780 : 	}
; 1781 : 	else if (m_Type == ITEM_POTION + 22)	// 창석
; 1782 : 	{
; 1783 : 		//Gold = 36000000;
; 1784 : 		Gold = 1000;
; 1785 : 	}
; 1786 : #else
; 1787 : 	else if (m_Type == ITEM_POTION + 13)	// 축석

  002dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002df	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  002e3	81 f9 cd 01 00
	00		 cmp	 ecx, 461		; 000001cdH
  002e9	75 13		 jne	 SHORT $LN68@Value

; 1788 : 	{
; 1789 : 		Gold = 9000000;

  002eb	c7 45 ec 40 54
	89 00		 mov	 DWORD PTR _Gold$[ebp], 9000000 ; 00895440H
  002f2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1790 : 	}

  002f9	e9 ae 0c 00 00	 jmp	 $LN34@Value
$LN68@Value:

; 1791 : 	else if (m_Type == ITEM_POTION + 14)	// 영석

  002fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00301	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00305	81 f9 ce 01 00
	00		 cmp	 ecx, 462		; 000001ceH
  0030b	75 13		 jne	 SHORT $LN70@Value

; 1792 : 	{
; 1793 : 		Gold = 6000000;

  0030d	c7 45 ec 80 8d
	5b 00		 mov	 DWORD PTR _Gold$[ebp], 6000000 ; 005b8d80H
  00314	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1794 : 	}

  0031b	e9 8c 0c 00 00	 jmp	 $LN34@Value
$LN70@Value:

; 1795 : 	else if (m_Type == ITEM_WING + 15)	// 혼석

  00320	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00323	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00327	81 f9 8f 01 00
	00		 cmp	 ecx, 399		; 0000018fH
  0032d	75 13		 jne	 SHORT $LN72@Value

; 1796 : 	{
; 1797 : 		Gold = 810000;

  0032f	c7 45 ec 10 5c
	0c 00		 mov	 DWORD PTR _Gold$[ebp], 810000 ; 000c5c10H
  00336	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1798 : 	}

  0033d	e9 6a 0c 00 00	 jmp	 $LN34@Value
$LN72@Value:

; 1799 : 	else if (m_Type == ITEM_POTION + 16)	// 생석

  00342	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00345	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00349	81 f9 d0 01 00
	00		 cmp	 ecx, 464		; 000001d0H
  0034f	75 13		 jne	 SHORT $LN74@Value

; 1800 : 	{
; 1801 : 		Gold = 45000000;

  00351	c7 45 ec 40 a5
	ae 02		 mov	 DWORD PTR _Gold$[ebp], 45000000 ; 02aea540H
  00358	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1802 : 	}

  0035f	e9 48 0c 00 00	 jmp	 $LN34@Value
$LN74@Value:

; 1803 : 	else if (m_Type == ITEM_POTION + 22)	// 창석

  00364	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00367	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0036b	81 f9 d6 01 00
	00		 cmp	 ecx, 470		; 000001d6H
  00371	75 13		 jne	 SHORT $LN76@Value

; 1804 : 	{
; 1805 : 		Gold = 36000000;

  00373	c7 45 ec 00 51
	25 02		 mov	 DWORD PTR _Gold$[ebp], 36000000 ; 02255100H
  0037a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1806 : 	}

  00381	e9 26 0c 00 00	 jmp	 $LN34@Value
$LN76@Value:

; 1807 : #endif //FOR_TEMP_SERVER 
; 1808 : 	//<------------------------------------------
; 1809 : #ifdef JEWEL_MIX_SYSTEM_20050309	// 보석 조합아이템 판매가격
; 1810 : 	else if (m_Type == ITEM_WING + 30)	// 축석 조합
; 1811 : 	{
; 1812 : 		Gold = 9000000 * (m_Level + 1) * 10;
; 1813 : 	}
; 1814 : 	else if (m_Type == ITEM_WING + 31)	// 영석 조합
; 1815 : 	{
; 1816 : 		Gold = 6000000 * (m_Level + 1) * 10;
; 1817 : 	}
; 1818 : #endif
; 1819 : 	else if (m_Type == ITEM_HELPER + 15)	// 열매

  00386	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00389	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0038d	81 f9 af 01 00
	00		 cmp	 ecx, 431		; 000001afH
  00393	75 13		 jne	 SHORT $LN78@Value

; 1820 : 	{
; 1821 : 		Gold = 33000000;

  00395	c7 45 ec 40 8a
	f7 01		 mov	 DWORD PTR _Gold$[ebp], 33000000 ; 01f78a40H
  0039c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1822 : 	}

  003a3	e9 04 0c 00 00	 jmp	 $LN34@Value
$LN78@Value:

; 1823 : 	else if (m_Type == ITEM_HELPER + 14)	// 깃털

  003a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003ab	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  003af	81 f9 ae 01 00
	00		 cmp	 ecx, 430		; 000001aeH
  003b5	75 2f		 jne	 SHORT $LN80@Value

; 1824 : 	{
; 1825 : #ifdef DARKLORD_WORK
; 1826 : 		if (m_Level == 1)

  003b7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003ba	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  003be	83 f9 01	 cmp	 ecx, 1
  003c1	75 10		 jne	 SHORT $LN82@Value

; 1827 : 			Gold = 2500000 * 3;		// 군주의 소매

  003c3	c7 45 ec e0 70
	72 00		 mov	 DWORD PTR _Gold$[ebp], 7500000 ; 007270e0H
  003ca	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0
  003d1	eb 0e		 jmp	 SHORT $LN83@Value
$LN82@Value:

; 1828 : 
; 1829 : #ifdef MODIFY_PRICE_FEATHE_OF_LOCH_20041129		
; 1830 : 		else  Gold = 180000;

  003d3	c7 45 ec 20 bf
	02 00		 mov	 DWORD PTR _Gold$[ebp], 180000 ; 0002bf20H
  003da	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0
$LN83@Value:

; 1831 : #endif
; 1832 : 
; 1833 : #else
; 1834 : 		Gold = 180000;
; 1835 : #endif
; 1836 : 	}

  003e1	e9 c6 0b 00 00	 jmp	 $LN34@Value
$LN80@Value:

; 1837 : #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 1838 : 	else if (m_Type == ITEM_POTION + 31)	// 수호 보석
; 1839 : 	{
; 1840 : 		Gold = 60000000;
; 1841 : 	}
; 1842 : 	else if (m_Type == ITEM_POTION + 7)  // 공성 물약
; 1843 : 	{
; 1844 : 		if (m_Level == 0)	// 축복의 물약
; 1845 : 		{
; 1846 : #ifdef MODIFY_CASTLE_POTION_20051017
; 1847 : 			Gold = 900000 * (int)m_Durability;
; 1848 : #else
; 1849 : 			Gold = 2100000 * (int)m_Durability;
; 1850 : #endif
; 1851 : 		}
; 1852 : 		else if (m_Level == 1)	// 영혼의 물약
; 1853 : 		{
; 1854 : #ifdef MODIFY_CASTLE_POTION_20051017
; 1855 : 			Gold = 450000 * (int)m_Durability;
; 1856 : #else
; 1857 : 			Gold = 1500000 * (int)m_Durability;
; 1858 : #endif
; 1859 : 		}
; 1860 : 	}
; 1861 : 	else if (m_Type == ITEM_HELPER + 11) // 라이프스톤
; 1862 : 	{
; 1863 : 		if (m_Level == 1)	// 라이프스톤
; 1864 : 			Gold = 2400000;
; 1865 : 	}
; 1866 : 	else if (m_Type == ITEM_HELPER + 7)  // 용병
; 1867 : 	{
; 1868 : 		if (m_Level == 0) // 활용병
; 1869 : 			Gold = 1500000;
; 1870 : 		else if (m_Level == 1)// 창용병
; 1871 : 			Gold = 1200000;
; 1872 : 	}
; 1873 : #endif
; 1874 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 1875 : 	// 펜릴 관련 아이템 가격
; 1876 : 	else if (m_Type == ITEM_HELPER + 32)
; 1877 : 	{
; 1878 : 		Gold = 50 * 3 * (int)m_Durability;
; 1879 : 	}
; 1880 : 	else if (m_Type == ITEM_HELPER + 33)
; 1881 : 	{
; 1882 : 		Gold = 100 * 3 * (int)m_Durability;
; 1883 : 	}
; 1884 : 	else if (m_Type == ITEM_HELPER + 34)
; 1885 : 	{
; 1886 : 		Gold = 1000 * 3 * (int)m_Durability;
; 1887 : 	}
; 1888 : 	else if (m_Type == ITEM_HELPER + 35)
; 1889 : 	{
; 1890 : 		Gold = 10000 * 3;
; 1891 : 	}
; 1892 : 	else if (m_Type == ITEM_HELPER + 36)
; 1893 : 	{
; 1894 : 		Gold = 30000 * 3;
; 1895 : 	}
; 1896 : 	else if (m_Type == ITEM_HELPER + 37)
; 1897 : 	{
; 1898 : 		Gold = 50000 * 3;
; 1899 : 	}
; 1900 : #endif
; 1901 : 
; 1902 : 	// CODEREVIEW_SHIELD : 여기다가 상점 판매 가격 '비슷한' 형식으로 넣을것.
; 1903 : #ifdef ADD_SHIELD_POINT_01_20060403
; 1904 : 	else if (m_Type == MAKE_ITEMNUM(14, 35))
; 1905 : 	{
; 1906 : 		Gold = (2000 * (int)m_Durability);
; 1907 : 	}
; 1908 : 	else if (m_Type == MAKE_ITEMNUM(14, 36))
; 1909 : 	{
; 1910 : 		Gold = (4000 * (int)m_Durability);
; 1911 : 	}
; 1912 : 	else if (m_Type == MAKE_ITEMNUM(14, 37))
; 1913 : 	{
; 1914 : 		Gold = (6000 * (int)m_Durability);
; 1915 : 	}
; 1916 : 	else if (m_Type == MAKE_ITEMNUM(14, 38))
; 1917 : 	{
; 1918 : 		Gold = (2500 * (int)m_Durability);
; 1919 : 	}
; 1920 : 	else if (m_Type == MAKE_ITEMNUM(14, 39))
; 1921 : 	{
; 1922 : 		Gold = (5000 * (int)m_Durability);
; 1923 : 	}
; 1924 : 	else if (m_Type == MAKE_ITEMNUM(14, 40))
; 1925 : 	{
; 1926 : 		Gold = (7500 * (int)m_Durability);
; 1927 : 	}
; 1928 : #endif
; 1929 : 	//
; 1930 : 	else if (m_Type == ITEM_HELPER + 3)	// 디노란트

  003e6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003e9	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  003ed	81 f9 a3 01 00
	00		 cmp	 ecx, 419		; 000001a3H
  003f3	75 56		 jne	 SHORT $LN84@Value

; 1931 : 	{
; 1932 : 		Gold = 960000;

  003f5	c7 45 ec 00 a6
	0e 00		 mov	 DWORD PTR _Gold$[ebp], 960000 ; 000ea600H
  003fc	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1933 : 		for (int i = 0; i < 3; i++)

  00403	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  0040a	eb 09		 jmp	 SHORT $LN9@Value
$LN7@Value:
  0040c	8b 45 d0	 mov	 eax, DWORD PTR _i$5[ebp]
  0040f	83 c0 01	 add	 eax, 1
  00412	89 45 d0	 mov	 DWORD PTR _i$5[ebp], eax
$LN9@Value:
  00415	83 7d d0 03	 cmp	 DWORD PTR _i$5[ebp], 3
  00419	7d 2b		 jge	 SHORT $LN8@Value

; 1934 : 		{
; 1935 : 			if (m_Option3 & (1 << i))

  0041b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0041e	0f b6 50 7a	 movzx	 edx, BYTE PTR [eax+122]
  00422	b8 01 00 00 00	 mov	 eax, 1
  00427	8b 4d d0	 mov	 ecx, DWORD PTR _i$5[ebp]
  0042a	d3 e0		 shl	 eax, cl
  0042c	23 d0		 and	 edx, eax
  0042e	74 14		 je	 SHORT $LN86@Value

; 1936 : 			{	// 옵션 하나당 100000추가
; 1937 : 				Gold += 300000;

  00430	8b 45 ec	 mov	 eax, DWORD PTR _Gold$[ebp]
  00433	05 e0 93 04 00	 add	 eax, 300000		; 000493e0H
  00438	8b 4d f0	 mov	 ecx, DWORD PTR _Gold$[ebp+4]
  0043b	83 d1 00	 adc	 ecx, 0
  0043e	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00441	89 4d f0	 mov	 DWORD PTR _Gold$[ebp+4], ecx
$LN86@Value:

; 1938 : 			}
; 1939 : 		}

  00444	eb c6		 jmp	 SHORT $LN7@Value
$LN8@Value:

; 1940 : 	}

  00446	e9 61 0b 00 00	 jmp	 $LN34@Value
$LN84@Value:

; 1941 : 	else if (m_Type == ITEM_POTION + 17)	// 악마의 눈

  0044b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0044e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00452	81 f9 d1 01 00
	00		 cmp	 ecx, 465		; 000001d1H
  00458	0f 85 85 00 00
	00		 jne	 $LN87@Value

; 1942 : 	{
; 1943 : 		switch (m_Level)

  0045e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00461	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00465	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv253[ebp], ecx
  0046b	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv253[ebp]
  00471	83 ea 01	 sub	 edx, 1
  00474	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv253[ebp], edx
  0047a	83 bd 7c ff ff
	ff 03		 cmp	 DWORD PTR tv253[ebp], 3
  00481	77 4d		 ja	 SHORT $LN93@Value
  00483	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv253[ebp]
  00489	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN202@Value[eax*4]
$LN89@Value:

; 1944 : 		{
; 1945 : #ifdef UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808	// 악마의 눈 가격
; 1946 : 		case 1: Gold = 10000;	break;
; 1947 : 		case 2: Gold = 50000;	break;
; 1948 : 		case 3: Gold = 100000;	break;
; 1949 : 		case 4: Gold = 300000;	break;
; 1950 : 		case 5: Gold = 500000;	break;
; 1951 : 		case 6: Gold = 800000;	break;
; 1952 : 		case 7: Gold = 1000000;	break;
; 1953 : #else	// UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808			
; 1954 : 		case 1:
; 1955 : 			Gold = 15000;

  00490	c7 45 ec 98 3a
	00 00		 mov	 DWORD PTR _Gold$[ebp], 15000 ; 00003a98H
  00497	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1956 : 			break;

  0049e	eb 3e		 jmp	 SHORT $LN10@Value
$LN90@Value:

; 1957 : 
; 1958 : 		case 2:
; 1959 : 			Gold = 21000;

  004a0	c7 45 ec 08 52
	00 00		 mov	 DWORD PTR _Gold$[ebp], 21000 ; 00005208H
  004a7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1960 : 			break;

  004ae	eb 2e		 jmp	 SHORT $LN10@Value
$LN91@Value:

; 1961 : 
; 1962 : 		case 3:
; 1963 : 			Gold = 30000;

  004b0	c7 45 ec 30 75
	00 00		 mov	 DWORD PTR _Gold$[ebp], 30000 ; 00007530H
  004b7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1964 : 			break;

  004be	eb 1e		 jmp	 SHORT $LN10@Value
$LN92@Value:

; 1965 : 
; 1966 : 		case 4:
; 1967 : 			Gold = 45000;

  004c0	c7 45 ec c8 af
	00 00		 mov	 DWORD PTR _Gold$[ebp], 45000 ; 0000afc8H
  004c7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 1968 : 			break;

  004ce	eb 0e		 jmp	 SHORT $LN10@Value
$LN93@Value:

; 1969 : 
; 1970 : #ifdef DEVILSQUARE_EXTEND_20050221		// 악마의 눈 판매가격
; 1971 : 		case 5:
; 1972 : 			Gold = 60000;
; 1973 : 			break;
; 1974 : 
; 1975 : 		case 6:
; 1976 : 			Gold = 75000;
; 1977 : 			break;
; 1978 : #endif
; 1979 : #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010		// 악마의 눈 7 판매가격
; 1980 : 		case 7:
; 1981 : 			Gold = 30000 * 3;
; 1982 : 			break;
; 1983 : #endif	
; 1984 : #endif	// UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808	
; 1985 : 		default:
; 1986 : 			Gold = 30000;

  004d0	c7 45 ec 30 75
	00 00		 mov	 DWORD PTR _Gold$[ebp], 30000 ; 00007530H
  004d7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0
$LN10@Value:

; 1987 : 			break;
; 1988 : 
; 1989 : 		}
; 1990 : 	}

  004de	e9 c9 0a 00 00	 jmp	 $LN34@Value
$LN87@Value:

; 1991 : 	else if (m_Type == ITEM_POTION + 18)	// 악마의 열쇠

  004e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004e6	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  004ea	81 f9 d2 01 00
	00		 cmp	 ecx, 466		; 000001d2H
  004f0	0f 85 85 00 00
	00		 jne	 $LN94@Value

; 1992 : 	{
; 1993 : 		switch (m_Level)

  004f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004f9	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  004fd	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv261[ebp], ecx
  00503	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv261[ebp]
  00509	83 ea 01	 sub	 edx, 1
  0050c	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv261[ebp], edx
  00512	83 bd 7c ff ff
	ff 03		 cmp	 DWORD PTR tv261[ebp], 3
  00519	77 4d		 ja	 SHORT $LN100@Value
  0051b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv261[ebp]
  00521	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN203@Value[eax*4]
$LN96@Value:

; 1994 : 		{
; 1995 : #ifdef UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808	// 악마의 열쇠 가격
; 1996 : 		case 1: Gold = 15000;	break;
; 1997 : 		case 2: Gold = 75000;	break;
; 1998 : 		case 3: Gold = 150000;	break;
; 1999 : 		case 4: Gold = 450000;	break;
; 2000 : 		case 5: Gold = 750000;	break;
; 2001 : 		case 6: Gold = 1200000;	break;
; 2002 : 		case 7: Gold = 1500000;	break;
; 2003 : #else	// UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808
; 2004 : 		case 1:
; 2005 : 			Gold = 15000;

  00528	c7 45 ec 98 3a
	00 00		 mov	 DWORD PTR _Gold$[ebp], 15000 ; 00003a98H
  0052f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2006 : 			break;

  00536	eb 3e		 jmp	 SHORT $LN12@Value
$LN97@Value:

; 2007 : 
; 2008 : 		case 2:
; 2009 : 			Gold = 21000;

  00538	c7 45 ec 08 52
	00 00		 mov	 DWORD PTR _Gold$[ebp], 21000 ; 00005208H
  0053f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2010 : 			break;

  00546	eb 2e		 jmp	 SHORT $LN12@Value
$LN98@Value:

; 2011 : 
; 2012 : 		case 3:
; 2013 : 			Gold = 30000;

  00548	c7 45 ec 30 75
	00 00		 mov	 DWORD PTR _Gold$[ebp], 30000 ; 00007530H
  0054f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2014 : 			break;

  00556	eb 1e		 jmp	 SHORT $LN12@Value
$LN99@Value:

; 2015 : 
; 2016 : 		case 4:
; 2017 : 			Gold = 45000;

  00558	c7 45 ec c8 af
	00 00		 mov	 DWORD PTR _Gold$[ebp], 45000 ; 0000afc8H
  0055f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2018 : 			break;

  00566	eb 0e		 jmp	 SHORT $LN12@Value
$LN100@Value:

; 2019 : 
; 2020 : #ifdef DEVILSQUARE_EXTEND_20050221		// 악마의 열쇠 판매가격
; 2021 : 		case 5:
; 2022 : 			Gold = 60000;
; 2023 : 			break;
; 2024 : 
; 2025 : 		case 6:
; 2026 : 			Gold = 75000;
; 2027 : 			break;
; 2028 : #endif
; 2029 : #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010		// 악마의열쇠7 판매가격
; 2030 : 		case 7:
; 2031 : 			Gold = 30000 * 3;
; 2032 : 			break;
; 2033 : #endif			
; 2034 : #endif	// UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808
; 2035 : 		default:
; 2036 : 			Gold = 30000;

  00568	c7 45 ec 30 75
	00 00		 mov	 DWORD PTR _Gold$[ebp], 30000 ; 00007530H
  0056f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0
$LN12@Value:

; 2037 : 			break;
; 2038 : 		}
; 2039 : 	}

  00576	e9 31 0a 00 00	 jmp	 $LN34@Value
$LN94@Value:

; 2040 : 	else if (m_Type == ITEM_POTION + 19)	// 악마의 광장 초대권

  0057b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0057e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00582	81 f9 d3 01 00
	00		 cmp	 ecx, 467		; 000001d3H
  00588	0f 85 85 00 00
	00		 jne	 $LN101@Value

; 2041 : 	{
; 2042 : 		switch (m_Level)

  0058e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00591	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00595	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv269[ebp], ecx
  0059b	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv269[ebp]
  005a1	83 ea 01	 sub	 edx, 1
  005a4	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv269[ebp], edx
  005aa	83 bd 7c ff ff
	ff 03		 cmp	 DWORD PTR tv269[ebp], 3
  005b1	77 4d		 ja	 SHORT $LN107@Value
  005b3	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv269[ebp]
  005b9	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN204@Value[eax*4]
$LN103@Value:

; 2043 : 		{
; 2044 : 		case 1:
; 2045 : 			Gold = 60000;

  005c0	c7 45 ec 60 ea
	00 00		 mov	 DWORD PTR _Gold$[ebp], 60000 ; 0000ea60H
  005c7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2046 : 			break;

  005ce	eb 3e		 jmp	 SHORT $LN14@Value
$LN104@Value:

; 2047 : 
; 2048 : 		case 2:
; 2049 : 			Gold = 84000;

  005d0	c7 45 ec 20 48
	01 00		 mov	 DWORD PTR _Gold$[ebp], 84000 ; 00014820H
  005d7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2050 : 			break;

  005de	eb 2e		 jmp	 SHORT $LN14@Value
$LN105@Value:

; 2051 : 
; 2052 : 		case 3:
; 2053 : 			Gold = 120000;

  005e0	c7 45 ec c0 d4
	01 00		 mov	 DWORD PTR _Gold$[ebp], 120000 ; 0001d4c0H
  005e7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2054 : 			break;

  005ee	eb 1e		 jmp	 SHORT $LN14@Value
$LN106@Value:

; 2055 : 
; 2056 : 		case 4:
; 2057 : 			Gold = 180000;

  005f0	c7 45 ec 20 bf
	02 00		 mov	 DWORD PTR _Gold$[ebp], 180000 ; 0002bf20H
  005f7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2058 : 			break;

  005fe	eb 0e		 jmp	 SHORT $LN14@Value
$LN107@Value:

; 2059 : 
; 2060 : #ifdef DEVILSQUARE_EXTEND_20050221		// 악마의 광장 초대권 판매가격
; 2061 : 		case 5:
; 2062 : 			Gold = 240000;
; 2063 : 			break;
; 2064 : 
; 2065 : 		case 6:
; 2066 : 			Gold = 300000;
; 2067 : 			break;
; 2068 : #endif
; 2069 : #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010		// 광장7 초대권 판매가격
; 2070 : 		case 7:
; 2071 : 			Gold = 60000 * 3;
; 2072 : 			break;
; 2073 : #endif
; 2074 : 
; 2075 : 		default:
; 2076 : 			Gold = 120000;

  00600	c7 45 ec c0 d4
	01 00		 mov	 DWORD PTR _Gold$[ebp], 120000 ; 0001d4c0H
  00607	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0
$LN14@Value:

; 2077 : 			break;
; 2078 : 		}
; 2079 : 	}

  0060e	e9 99 09 00 00	 jmp	 $LN34@Value
$LN101@Value:

; 2080 : 	else if (m_Type == ITEM_POTION + 20)	// 사랑의 묘약

  00613	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00616	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0061a	81 f9 d4 01 00
	00		 cmp	 ecx, 468		; 000001d4H
  00620	75 13		 jne	 SHORT $LN108@Value

; 2081 : 	{
; 2082 : 		Gold = 900;

  00622	c7 45 ec 84 03
	00 00		 mov	 DWORD PTR _Gold$[ebp], 900 ; 00000384H
  00629	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2083 : 	}

  00630	e9 77 09 00 00	 jmp	 $LN34@Value
$LN108@Value:

; 2084 : 	else if (m_Type == ITEM_POTION + 21)	// 레나

  00635	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00638	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0063c	81 f9 d5 01 00
	00		 cmp	 ecx, 469		; 000001d5H
  00642	75 76		 jne	 SHORT $LN110@Value

; 2085 : 	{
; 2086 : #ifdef FOR_BLOODCASTLE3
; 2087 : 		switch (m_Level)

  00644	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00647	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0064b	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv280[ebp], ecx
  00651	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv280[ebp], 0
  00658	74 0b		 je	 SHORT $LN112@Value
  0065a	83 bd 7c ff ff
	ff 01		 cmp	 DWORD PTR tv280[ebp], 1
  00661	74 1c		 je	 SHORT $LN113@Value
  00663	eb 36		 jmp	 SHORT $LN114@Value
$LN112@Value:

; 2088 : 		{
; 2089 : 		case 0:						// 레나
; 2090 : 			Gold = 3000 * 3;

  00665	c7 45 ec 28 23
	00 00		 mov	 DWORD PTR _Gold$[ebp], 9000 ; 00002328H
  0066c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2091 : 			m_Durability = m_BaseDurability;

  00673	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00676	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00679	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0067c	89 50 24	 mov	 DWORD PTR [eax+36], edx
$LN113@Value:

; 2092 : 		case 1:						// 스톤
; 2093 : 			Gold = 3000 * 3;

  0067f	c7 45 ec 28 23
	00 00		 mov	 DWORD PTR _Gold$[ebp], 9000 ; 00002328H
  00686	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2094 : 			m_Durability = m_BaseDurability;

  0068d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00690	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00693	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00696	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 2095 : 			break;

  00699	eb 1a		 jmp	 SHORT $LN16@Value
$LN114@Value:

; 2096 : #ifdef EVENT_STONE_OF_FRIENDSHIP_20040206	// 우정의돌 상점판매 - 3000젠
; 2097 : 		case 2:						// 우정의돌
; 2098 : 			Gold = 3000 * 3;
; 2099 : 			m_Durability = m_BaseDurability;
; 2100 : 			break;
; 2101 : #endif
; 2102 : #ifdef MU_CASTLESIEGE_CS_MARKS_20041214
; 2103 : 		case 3:						// 성주의 표식
; 2104 : #ifdef MODIFY_ACCUMULATED_BUG_MARKOFLORD_SELL_VALUE_01_20050531
; 2105 : 			Gold = 1300 * 3 * (int)m_Durability;
; 2106 : #else
; 2107 : 			Gold = 3000 * 3;
; 2108 : #endif
; 2109 : 			break;
; 2110 : #endif
; 2111 : 		default:
; 2112 : 			Gold = 3000 * 3;

  0069b	c7 45 ec 28 23
	00 00		 mov	 DWORD PTR _Gold$[ebp], 9000 ; 00002328H
  006a2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2113 : 			m_Durability = m_BaseDurability;

  006a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006af	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  006b2	89 50 24	 mov	 DWORD PTR [eax+36], edx
$LN16@Value:

; 2114 : 			break;
; 2115 : 		}
; 2116 : #else
; 2117 : 		Gold = 3000 * 3;
; 2118 : 		m_Durability = m_BaseDurability;
; 2119 : #endif
; 2120 : 	}

  006b5	e9 f2 08 00 00	 jmp	 $LN34@Value
$LN110@Value:

; 2121 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029
; 2122 : 	else if (m_Type == ITEM_POTION + 100)	// 행운의 동전
; 2123 : 	{
; 2124 : 		Gold = 100 * 3 * (int)m_Durability;
; 2125 : 	}
; 2126 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029	
; 2127 : 	else  if (m_Type == ITEM_POTION + 9 && m_Level == 1)	// 술 

  006ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006bd	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  006c1	81 f9 c9 01 00
	00		 cmp	 ecx, 457		; 000001c9H
  006c7	75 1f		 jne	 SHORT $LN115@Value
  006c9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006cc	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  006d0	83 f9 01	 cmp	 ecx, 1
  006d3	75 13		 jne	 SHORT $LN115@Value

; 2128 : 	{	// 사랑의 열매(올리브)
; 2129 : 		Gold = 1000;

  006d5	c7 45 ec e8 03
	00 00		 mov	 DWORD PTR _Gold$[ebp], 1000 ; 000003e8H
  006dc	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2130 : 	}

  006e3	e9 c4 08 00 00	 jmp	 $LN34@Value
$LN115@Value:

; 2131 : #ifdef FOR_BLOODCASTLE
; 2132 : 	else if (m_Type == ITEM_HELPER + 18)	// 투명망토

  006e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006eb	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  006ef	81 f9 b2 01 00
	00		 cmp	 ecx, 434		; 000001b2H
  006f5	0f 85 b5 00 00
	00		 jne	 $LN117@Value

; 2133 : 	{
; 2134 : 		switch (m_Level)

  006fb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006fe	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00702	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv300[ebp], ecx
  00708	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv300[ebp]
  0070e	83 ea 01	 sub	 edx, 1
  00711	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv300[ebp], edx
  00717	83 bd 7c ff ff
	ff 06		 cmp	 DWORD PTR tv300[ebp], 6
  0071e	77 7d		 ja	 SHORT $LN126@Value
  00720	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv300[ebp]
  00726	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN205@Value[eax*4]
$LN119@Value:

; 2135 : 		{
; 2136 : 		case 1:
; 2137 : 			Gold = 50000 * 3;

  0072d	c7 45 ec f0 49
	02 00		 mov	 DWORD PTR _Gold$[ebp], 150000 ; 000249f0H
  00734	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2138 : 			break;

  0073b	eb 6e		 jmp	 SHORT $LN18@Value
$LN120@Value:

; 2139 : 
; 2140 : 		case 2:
; 2141 : 			Gold = 220000 * 3;

  0073d	c7 45 ec 20 12
	0a 00		 mov	 DWORD PTR _Gold$[ebp], 660000 ; 000a1220H
  00744	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2142 : 			break;

  0074b	eb 5e		 jmp	 SHORT $LN18@Value
$LN121@Value:

; 2143 : 
; 2144 : 		case 3:
; 2145 : 			Gold = 240000 * 3;

  0074d	c7 45 ec 80 fc
	0a 00		 mov	 DWORD PTR _Gold$[ebp], 720000 ; 000afc80H
  00754	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2146 : 			break;

  0075b	eb 4e		 jmp	 SHORT $LN18@Value
$LN122@Value:

; 2147 : 
; 2148 : 		case 4:
; 2149 : 			Gold = 260000 * 3;

  0075d	c7 45 ec e0 e6
	0b 00		 mov	 DWORD PTR _Gold$[ebp], 780000 ; 000be6e0H
  00764	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2150 : 			break;

  0076b	eb 3e		 jmp	 SHORT $LN18@Value
$LN123@Value:

; 2151 : 
; 2152 : 		case 5:
; 2153 : 			Gold = 280000 * 3;

  0076d	c7 45 ec 40 d1
	0c 00		 mov	 DWORD PTR _Gold$[ebp], 840000 ; 000cd140H
  00774	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2154 : 			break;

  0077b	eb 2e		 jmp	 SHORT $LN18@Value
$LN124@Value:

; 2155 : 
; 2156 : 		case 6:
; 2157 : 			Gold = 300000 * 3;

  0077d	c7 45 ec a0 bb
	0d 00		 mov	 DWORD PTR _Gold$[ebp], 900000 ; 000dbba0H
  00784	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2158 : 			break;

  0078b	eb 1e		 jmp	 SHORT $LN18@Value
$LN125@Value:

; 2159 : 
; 2160 : 		case 7:
; 2161 : 			Gold = 320000 * 3;

  0078d	c7 45 ec 00 a6
	0e 00		 mov	 DWORD PTR _Gold$[ebp], 960000 ; 000ea600H
  00794	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2162 : 			break;

  0079b	eb 0e		 jmp	 SHORT $LN18@Value
$LN126@Value:

; 2163 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 투명망토 +8 가격
; 2164 : 		case 8:
; 2165 : 			Gold = 340000 * 3;
; 2166 : 			break;
; 2167 : #endif			
; 2168 : 
; 2169 : 		default:
; 2170 : 			Gold = 200000 * 3;

  0079d	c7 45 ec c0 27
	09 00		 mov	 DWORD PTR _Gold$[ebp], 600000 ; 000927c0H
  007a4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0
$LN18@Value:

; 2171 : 			break;
; 2172 : 		}
; 2173 : 	}

  007ab	e9 fc 07 00 00	 jmp	 $LN34@Value
$LN117@Value:

; 2174 : 	else if ((m_Type == ITEM_HELPER + 16) || (m_Type == ITEM_HELPER + 17))	// 블러드본 이나 대천사의서

  007b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007b3	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  007b7	81 f9 b0 01 00
	00		 cmp	 ecx, 432		; 000001b0H
  007bd	74 13		 je	 SHORT $LN129@Value
  007bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007c2	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  007c6	81 f9 b1 01 00
	00		 cmp	 ecx, 433		; 000001b1H
  007cc	0f 85 b5 00 00
	00		 jne	 $LN127@Value
$LN129@Value:

; 2175 : 	{
; 2176 : 
; 2177 : 		switch (m_Level)

  007d2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007d5	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  007d9	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv311[ebp], ecx
  007df	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv311[ebp]
  007e5	83 ea 01	 sub	 edx, 1
  007e8	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv311[ebp], edx
  007ee	83 bd 7c ff ff
	ff 06		 cmp	 DWORD PTR tv311[ebp], 6
  007f5	77 7d		 ja	 SHORT $LN137@Value
  007f7	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv311[ebp]
  007fd	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN206@Value[eax*4]
$LN130@Value:

; 2178 : 		{
; 2179 : #ifdef UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808	// 블러드본, 대천사의서 가격
; 2180 : 		case 1: Gold = 10000;	break;
; 2181 : 		case 2: Gold = 50000;	break;
; 2182 : 		case 3: Gold = 100000;	break;
; 2183 : 		case 4: Gold = 300000;	break;
; 2184 : 		case 5: Gold = 500000;	break;
; 2185 : 		case 6: Gold = 800000;	break;
; 2186 : 		case 7: Gold = 1000000;	break;
; 2187 : 		case 8: Gold = 1200000;	break;
; 2188 : #else	// UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808
; 2189 : 		case 1:
; 2190 : 			Gold = 5000 * 3;

  00804	c7 45 ec 98 3a
	00 00		 mov	 DWORD PTR _Gold$[ebp], 15000 ; 00003a98H
  0080b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2191 : 			break;

  00812	eb 6e		 jmp	 SHORT $LN20@Value
$LN131@Value:

; 2192 : 
; 2193 : 		case 2:
; 2194 : 			Gold = 7000 * 3;

  00814	c7 45 ec 08 52
	00 00		 mov	 DWORD PTR _Gold$[ebp], 21000 ; 00005208H
  0081b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2195 : 			break;

  00822	eb 5e		 jmp	 SHORT $LN20@Value
$LN132@Value:

; 2196 : 
; 2197 : 		case 3:
; 2198 : 			Gold = 10000 * 3;

  00824	c7 45 ec 30 75
	00 00		 mov	 DWORD PTR _Gold$[ebp], 30000 ; 00007530H
  0082b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2199 : 			break;

  00832	eb 4e		 jmp	 SHORT $LN20@Value
$LN133@Value:

; 2200 : 
; 2201 : 		case 4:
; 2202 : 			Gold = 13000 * 3;

  00834	c7 45 ec 58 98
	00 00		 mov	 DWORD PTR _Gold$[ebp], 39000 ; 00009858H
  0083b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2203 : 			break;

  00842	eb 3e		 jmp	 SHORT $LN20@Value
$LN134@Value:

; 2204 : 
; 2205 : 		case 5:
; 2206 : 			Gold = 16000 * 3;

  00844	c7 45 ec 80 bb
	00 00		 mov	 DWORD PTR _Gold$[ebp], 48000 ; 0000bb80H
  0084b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2207 : 			break;

  00852	eb 2e		 jmp	 SHORT $LN20@Value
$LN135@Value:

; 2208 : 
; 2209 : 		case 6:
; 2210 : 			Gold = 20000 * 3;

  00854	c7 45 ec 60 ea
	00 00		 mov	 DWORD PTR _Gold$[ebp], 60000 ; 0000ea60H
  0085b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2211 : 			break;

  00862	eb 1e		 jmp	 SHORT $LN20@Value
$LN136@Value:

; 2212 : 
; 2213 : 		case 7:
; 2214 : 			Gold = 25000 * 3;

  00864	c7 45 ec f8 24
	01 00		 mov	 DWORD PTR _Gold$[ebp], 75000 ; 000124f8H
  0086b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2215 : 			break;

  00872	eb 0e		 jmp	 SHORT $LN20@Value
$LN137@Value:

; 2216 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 블러드본+8, 대천사의서+8 가격
; 2217 : 		case 8:
; 2218 : 			Gold = 30000 * 3;
; 2219 : 			break;
; 2220 : #endif
; 2221 : #endif	// UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808				
; 2222 : 		default:
; 2223 : 			Gold = 5000 * 3;

  00874	c7 45 ec 98 3a
	00 00		 mov	 DWORD PTR _Gold$[ebp], 15000 ; 00003a98H
  0087b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0
$LN20@Value:

; 2224 : 			break;
; 2225 : 		}
; 2226 : 	}

  00882	e9 25 07 00 00	 jmp	 $LN34@Value
$LN127@Value:

; 2227 : #endif
; 2228 : #ifdef CHAOSCASTLE_SYSTEM_20040408		// 근위병 갑옷세트 판매가격
; 2229 : 	else if (m_Type == ITEM_HELPER + 29)

  00887	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0088a	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0088e	81 f9 bd 01 00
	00		 cmp	 ecx, 445		; 000001bdH
  00894	75 13		 jne	 SHORT $LN138@Value

; 2230 : 	{
; 2231 : 		Gold = 5000;

  00896	c7 45 ec 88 13
	00 00		 mov	 DWORD PTR _Gold$[ebp], 5000 ; 00001388H
  0089d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2232 : 	}

  008a4	e9 03 07 00 00	 jmp	 $LN34@Value
$LN138@Value:

; 2233 : #endif	
; 2234 : #ifdef RING_EVENT_ITEMBOX_20031124		// 반지이벤트 - 마법사의 반지 판매가격
; 2235 : 	else if (m_Type == ITEM_HELPER + 20)

  008a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008ac	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  008b0	81 f9 b4 01 00
	00		 cmp	 ecx, 436		; 000001b4H
  008b6	75 35		 jne	 SHORT $LN140@Value

; 2236 : 	{
; 2237 : 		switch (m_Level)

  008b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008bb	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  008bf	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv322[ebp], ecx
  008c5	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv322[ebp], 0
  008cc	74 02		 je	 SHORT $LN142@Value
  008ce	eb 10		 jmp	 SHORT $LN143@Value
$LN142@Value:

; 2238 : 		{
; 2239 : 		case 0:						// 마법사의 반지
; 2240 : 			Gold = 10000 * 3;

  008d0	c7 45 ec 30 75
	00 00		 mov	 DWORD PTR _Gold$[ebp], 30000 ; 00007530H
  008d7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2241 : 			break;

  008de	eb 08		 jmp	 SHORT $LN22@Value
$LN143@Value:

; 2242 : #ifdef MU_CHN_THANKS_RING_EVENT_20040908	// 중국 이벤트 - 영예의 반지 
; 2243 : 		case 3:						// 영예의 반지
; 2244 : 			Gold = 10000 * 3;
; 2245 : 			break;
; 2246 : #endif
; 2247 : 		default:
; 2248 : 			Gold = 0 * 3;

  008e0	0f 57 c0	 xorps	 xmm0, xmm0
  008e3	66 0f 13 45 ec	 movlpd	 QWORD PTR _Gold$[ebp], xmm0
$LN22@Value:

; 2249 : 			break;
; 2250 : 		}
; 2251 : 	}

  008e8	e9 bf 06 00 00	 jmp	 $LN34@Value
$LN140@Value:

; 2252 : #endif
; 2253 : #ifdef DARKLORD_WORK
; 2254 : 	else if (m_Type == ITEM_HELPER + 31)

  008ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008f0	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  008f4	81 f9 bf 01 00
	00		 cmp	 ecx, 447		; 000001bfH
  008fa	75 44		 jne	 SHORT $LN144@Value

; 2255 : 	{
; 2256 : 		switch (m_Level)

  008fc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008ff	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00903	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv329[ebp], ecx
  00909	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv329[ebp], 0
  00910	74 0b		 je	 SHORT $LN146@Value
  00912	83 bd 7c ff ff
	ff 01		 cmp	 DWORD PTR tv329[ebp], 1
  00919	74 12		 je	 SHORT $LN147@Value
  0091b	eb 1e		 jmp	 SHORT $LN24@Value
$LN146@Value:

; 2257 : 		{
; 2258 : 		case 0:						// 다크호스의 영혼
; 2259 : 			Gold = 10000000 * 3;

  0091d	c7 45 ec 80 c3
	c9 01		 mov	 DWORD PTR _Gold$[ebp], 30000000 ; 01c9c380H
  00924	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2260 : 			break;

  0092b	eb 0e		 jmp	 SHORT $LN24@Value
$LN147@Value:

; 2261 : 
; 2262 : 		case 1:						// 다크스피릿의 영혼
; 2263 : 			Gold = 5000000 * 3;

  0092d	c7 45 ec c0 e1
	e4 00		 mov	 DWORD PTR _Gold$[ebp], 15000000 ; 00e4e1c0H
  00934	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0
$LN24@Value:

; 2264 : 			break;
; 2265 : 		}
; 2266 : 	}

  0093b	e9 6c 06 00 00	 jmp	 $LN34@Value
$LN144@Value:

; 2267 : #endif
; 2268 : #ifdef ADD_NEW_MAP_KALIMA_20040518
; 2269 : 	else if (m_Type == ITEM_POTION + 28)		// 잃어버린 지도

  00940	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00943	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00947	81 f9 dc 01 00
	00		 cmp	 ecx, 476		; 000001dcH
  0094d	75 13		 jne	 SHORT $LN148@Value

; 2270 : 	{
; 2271 : 		Gold = 200000 * 3;

  0094f	c7 45 ec c0 27
	09 00		 mov	 DWORD PTR _Gold$[ebp], 600000 ; 000927c0H
  00956	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0

; 2272 : 		//#ifdef FOR_NEW_TESTSERVER
; 2273 : 		//		Gold = 20000;
; 2274 : 		//#else
; 2275 : 		//		Gold = 20000 * 3;
; 2276 : 		//#endif
; 2277 : 	}

  0095d	e9 4a 06 00 00	 jmp	 $LN34@Value
$LN148@Value:

; 2278 : 	else if (m_Type == ITEM_POTION + 29)		// 쿤둔의표식

  00962	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00965	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00969	81 f9 dd 01 00
	00		 cmp	 ecx, 477		; 000001ddH
  0096f	75 28		 jne	 SHORT $LN150@Value

; 2279 : 	{
; 2280 : 		Gold = 10000 * m_Durability * 3;

  00971	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00974	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@461c4000
  0097c	f3 0f 59 40 24	 mulss	 xmm0, DWORD PTR [eax+36]
  00981	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  00989	e8 00 00 00 00	 call	 __ftol3
  0098e	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00991	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx

; 2281 : 		//#ifdef FOR_NEW_TESTSERVER
; 2282 : 		//		Gold = 1000 * m_Durability;
; 2283 : 		//#else
; 2284 : 		//		Gold = 1000 * m_Durability * 3;
; 2285 : 		//#endif
; 2286 : 	}

  00994	e9 13 06 00 00	 jmp	 $LN34@Value
$LN150@Value:

; 2287 : #endif
; 2288 : #ifdef HALLOWINDAY_JACK_O_LANTERN_EVENT_20061017
; 2289 : 	else if (m_Type == MAKE_ITEMNUM(14, 45)
; 2290 : 		|| m_Type == MAKE_ITEMNUM(14, 46)
; 2291 : 		|| m_Type == MAKE_ITEMNUM(14, 47)
; 2292 : 		|| m_Type == MAKE_ITEMNUM(14, 48)
; 2293 : 		|| m_Type == MAKE_ITEMNUM(14, 49)
; 2294 : 		|| m_Type == MAKE_ITEMNUM(14, 50)
; 2295 : 		)
; 2296 : 	{
; 2297 : 		Gold = 50 * m_Durability * 3;
; 2298 : 	}
; 2299 : 
; 2300 : #endif // HALLOWINDAY_JACK_O_LANTERN_EVENT_20061017
; 2301 : #ifdef HIDDEN_TREASUREBOX_EVENT_20050804
; 2302 : 	else if (m_Type == ITEM_WING + 26)
; 2303 : 	{
; 2304 : 		switch (m_Level) {
; 2305 : 		case 0:							// 신비의 구슬
; 2306 : 			Gold = 60000;
; 2307 : 			break;
; 2308 : 		}
; 2309 : 	}
; 2310 : #endif	
; 2311 : #ifdef CHRISTMAS_STAR_20061211
; 2312 : 	else if (m_Type == MAKE_ITEMNUM(14, 51))	// 크리스마스의 별
; 2313 : 	{
; 2314 : 		Gold = 200000;
; 2315 : 	}
; 2316 : #endif	
; 2317 : #ifdef PCBANG_POINT_SYSTEM_20070206		// 아이템 팔 때 가격 설정
; 2318 : 	else if (m_Type == MAKE_ITEMNUM(14, 55) 		// 혼돈의 상자
; 2319 : 		|| m_Type == MAKE_ITEMNUM(14, 56)
; 2320 : 		|| m_Type == MAKE_ITEMNUM(14, 57))
; 2321 : 	{
; 2322 : 		//#ifdef MODIFY_PCBANGPOINTSHOP_CLOSEWINDOWS_BUGFIX_20080218	// 혼돈의상자 가격 재설정
; 2323 : 		//		Gold = 30000000 * 3;
; 2324 : 		//#else
; 2325 : 		Gold = 3000 * 3;
; 2326 : 		//#endif	// MODIFY_PCBANGPOINTSHOP_CLOSEWINDOWS_BUGFIX_20080218
; 2327 : 	}
; 2328 : #endif
; 2329 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		// 아이템 팔때 가격
; 2330 : 	else if ((m_Type == MAKE_ITEMNUM(13, 49))		// 낡은 두루마리
; 2331 : 		|| (m_Type == MAKE_ITEMNUM(13, 50)) 		// 환영교단의 서약
; 2332 : 		|| (m_Type == MAKE_ITEMNUM(13, 51)))		// 피의 두루마리
; 2333 : 	{
; 2334 : 		switch (m_Level)
; 2335 : 		{
; 2336 : #ifdef UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808	// 피의두루마리, 환경교단의 서약 가격
; 2337 : 		case 1: Gold = 500000;	break;
; 2338 : 		case 2: Gold = 600000;	break;
; 2339 : 		case 3: Gold = 800000;	break;
; 2340 : 		case 4: Gold = 1000000;	break;
; 2341 : 		case 5: Gold = 1200000;	break;
; 2342 : 		case 6: Gold = 1400000;	break;
; 2343 : #else	// UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808
; 2344 : 		case 1:
; 2345 : 			Gold = 3000 * 3;
; 2346 : #endif	// UPDATE_EVENT_MAP_MIXiTEM_VALUE_200800808
; 2347 : 		default:
; 2348 : 			Gold = 3000 * 3;
; 2349 : 		}
; 2350 : 	}
; 2351 : #endif
; 2352 : #ifdef ADD_THIRD_WING_20070525	// 콘도르의 깃털, 불꽃 가격 설정
; 2353 : 	else if (m_Type == MAKE_ITEMNUM(13, 52)	// 콘도르의 깃털
; 2354 : 		|| m_Type == MAKE_ITEMNUM(13, 53)) 	// 콘도르의 불꽃	
; 2355 : 	{
; 2356 : 		Gold = 1000000 * 3;
; 2357 : 	}
; 2358 : #endif	
; 2359 : #ifdef MODIFY_QUEST_MONSTER_KILL_COUNT_BUGFIX_20070704	// 퀘스트 아이템 가격설정
; 2360 : 	else if (m_Type == MAKE_ITEMNUM(14, 23)	// 제왕의서
; 2361 : 		|| m_Type == MAKE_ITEMNUM(14, 24)		// 부러진검
; 2362 : 		|| m_Type == MAKE_ITEMNUM(14, 25)		// 엘프의눈물
; 2363 : 		|| m_Type == MAKE_ITEMNUM(14, 26)		// 마법사의혼
; 2364 : 		|| m_Type == MAKE_ITEMNUM(14, 65)		// 데쓰빔나이트의불꽃
; 2365 : 		|| m_Type == MAKE_ITEMNUM(14, 66)		// 헬마이네의뿔
; 2366 : 		|| m_Type == MAKE_ITEMNUM(14, 67)		// 어둠의불사조의깃털
; 2367 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912// 소환술사 퀘스트 아이템 가격
; 2368 : 		|| m_Type == MAKE_ITEMNUM(14, 68)		// 심연의눈동자
; 2369 : #endif
; 2370 : 		)
; 2371 : 	{
; 2372 : 		Gold = 3000 * 3;
; 2373 : 	}
; 2374 : #endif	
; 2375 : 
; 2376 : 	else if (p->Value > 0)

  00999	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0099c	0f b7 48 3c	 movzx	 ecx, WORD PTR [eax+60]
  009a0	85 c9		 test	 ecx, ecx
  009a2	0f 8e 62 01 00
	00		 jle	 $LN152@Value

; 2377 : 	{
; 2378 : 		Gold += p->Value*p->Value * 10 / 12;

  009a8	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  009ab	0f b7 48 3c	 movzx	 ecx, WORD PTR [eax+60]
  009af	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  009b2	0f b7 42 3c	 movzx	 eax, WORD PTR [edx+60]
  009b6	0f af c8	 imul	 ecx, eax
  009b9	6b c1 0a	 imul	 eax, ecx, 10
  009bc	99		 cdq
  009bd	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  009c2	f7 f9		 idiv	 ecx
  009c4	99		 cdq
  009c5	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  009c8	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  009cb	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  009ce	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx

; 2379 : 		if (m_Type >= ITEM_POTION && m_Type <= ITEM_POTION + 8)

  009d1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009d4	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  009d8	81 f9 c0 01 00
	00		 cmp	 ecx, 448		; 000001c0H
  009de	0f 8c 21 01 00
	00		 jl	 $LN154@Value
  009e4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009e7	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  009eb	81 f9 c8 01 00
	00		 cmp	 ecx, 456		; 000001c8H
  009f1	0f 8f 0e 01 00
	00		 jg	 $LN154@Value

; 2380 : 		{
; 2381 : #ifdef ITEM_12_13_20040401
; 2382 : #ifdef FOR_CHINA
; 2383 : 			if (m_Level > 0)
; 2384 : 			{
; 2385 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 2386 : 				Gold *= (__int64)(pow(3.0f, Level));
; 2387 : 				//Gold *= (__int64)pow(3, Level);
; 2388 : #else
; 2389 : 				Gold *= (DWORD)(pow(3.0f, Level));
; 2390 : 				//Gold *= (DWORD)pow(3, Level);
; 2391 : #endif	// MODIFY_ITEM_PRICE_MAXFIX				
; 2392 : 			}
; 2393 : #else
; 2394 : #ifdef UPDATE_ZEN_DROP_DOWN_20080806	// 큰 치료물약, 큰 마나물약 가격 2배
; 2395 : 			if (m_Type == ITEM_POTION + 3 || m_Type == ITEM_POTION + 6)

  009f7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009fa	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  009fe	81 f9 c3 01 00
	00		 cmp	 ecx, 451		; 000001c3H
  00a04	74 0f		 je	 SHORT $LN156@Value
  00a06	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a09	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00a0d	81 f9 c6 01 00
	00		 cmp	 ecx, 454		; 000001c6H
  00a13	75 17		 jne	 SHORT $LN155@Value
$LN156@Value:

; 2396 : 			{
; 2397 : 				Gold *= 2;

  00a15	6a 00		 push	 0
  00a17	6a 02		 push	 2
  00a19	8b 45 f0	 mov	 eax, DWORD PTR _Gold$[ebp+4]
  00a1c	50		 push	 eax
  00a1d	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00a20	51		 push	 ecx
  00a21	e8 00 00 00 00	 call	 __allmul
  00a26	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00a29	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN155@Value:

; 2398 : 			}
; 2399 : #endif	// UPDATE_ZEN_DROP_DOWN_20080806
; 2400 : 			if (m_Level > 0)

  00a2c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a2f	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00a33	85 c9		 test	 ecx, ecx
  00a35	7e 4d		 jle	 SHORT $LN157@Value

; 2401 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 2402 : 				Gold *= (__int64)pow((double)2, (double)Level);

  00a37	f2 0f 2a 45 f4	 cvtsi2sd xmm0, DWORD PTR _Level$[ebp]
  00a3c	83 ec 08	 sub	 esp, 8
  00a3f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00a44	83 ec 08	 sub	 esp, 8
  00a47	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  00a4f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00a54	e8 00 00 00 00	 call	 _pow
  00a59	83 c4 10	 add	 esp, 16			; 00000010H
  00a5c	dd 9d 78 ff ff
	ff		 fstp	 QWORD PTR tv835[ebp]
  00a62	f2 0f 10 85 78
	ff ff ff	 movsd	 xmm0, QWORD PTR tv835[ebp]
  00a6a	e8 00 00 00 00	 call	 __dtol3
  00a6f	52		 push	 edx
  00a70	50		 push	 eax
  00a71	8b 45 f0	 mov	 eax, DWORD PTR _Gold$[ebp+4]
  00a74	50		 push	 eax
  00a75	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00a78	51		 push	 ecx
  00a79	e8 00 00 00 00	 call	 __allmul
  00a7e	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00a81	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN157@Value:

; 2403 : #else
; 2404 : 				Gold *= (DWORD)pow((double)2, (double)Level);
; 2405 : #endif	// MODIFY_ITEM_PRICE_MAXFIX
; 2406 : #endif	// FOR_CHINA
; 2407 : #endif
; 2408 : 
; 2409 : #ifdef HP_POTION_VALUE_CHANGE_20040618		
; 2410 : 			Gold = Gold / 10 * 10;

  00a84	6a 00		 push	 0
  00a86	6a 0a		 push	 10			; 0000000aH
  00a88	8b 45 f0	 mov	 eax, DWORD PTR _Gold$[ebp+4]
  00a8b	50		 push	 eax
  00a8c	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00a8f	51		 push	 ecx
  00a90	e8 00 00 00 00	 call	 __alldiv
  00a95	6a 00		 push	 0
  00a97	6a 0a		 push	 10			; 0000000aH
  00a99	52		 push	 edx
  00a9a	50		 push	 eax
  00a9b	e8 00 00 00 00	 call	 __allmul
  00aa0	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00aa3	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx

; 2411 : #endif
; 2412 : 
; 2413 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 2414 : 			Gold *= (__int64)m_Durability;

  00aa6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00aa9	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00aae	e8 00 00 00 00	 call	 __ftol3
  00ab3	52		 push	 edx
  00ab4	50		 push	 eax
  00ab5	8b 4d f0	 mov	 ecx, DWORD PTR _Gold$[ebp+4]
  00ab8	51		 push	 ecx
  00ab9	8b 55 ec	 mov	 edx, DWORD PTR _Gold$[ebp]
  00abc	52		 push	 edx
  00abd	e8 00 00 00 00	 call	 __allmul
  00ac2	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00ac5	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx

; 2415 : #else
; 2416 : 			Gold *= (DWORD)m_Durability;
; 2417 : #endif
; 2418 : 
; 2419 : #ifdef HP_POTION_VALUE_CHANGE_20040618
; 2420 : 			m_BuyMoney = Gold;

  00ac8	8b 45 ec	 mov	 eax, DWORD PTR _Gold$[ebp]
  00acb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ace	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 2421 : 			m_SellMoney = Gold / 3;

  00ad1	6a 00		 push	 0
  00ad3	6a 03		 push	 3
  00ad5	8b 45 f0	 mov	 eax, DWORD PTR _Gold$[ebp+4]
  00ad8	50		 push	 eax
  00ad9	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00adc	51		 push	 ecx
  00add	e8 00 00 00 00	 call	 __alldiv
  00ae2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ae5	89 42 60	 mov	 DWORD PTR [edx+96], eax

; 2422 : 			m_SellMoney = m_SellMoney / 10 * 10;

  00ae8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00aeb	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00aee	33 d2		 xor	 edx, edx
  00af0	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00af5	f7 f1		 div	 ecx
  00af7	6b d0 0a	 imul	 edx, eax, 10
  00afa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00afd	89 50 60	 mov	 DWORD PTR [eax+96], edx

; 2423 : 			return;

  00b00	e9 0a 07 00 00	 jmp	 $LN1@Value
$LN154@Value:

; 2424 : #endif
; 2425 : 		}
; 2426 : 	}

  00b05	e9 a2 04 00 00	 jmp	 $LN34@Value
$LN152@Value:

; 2427 : #ifdef ADD_THIRD_WING_20070525	// 3차날개 계산 - type 12에서 3차날개 제외
; 2428 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 신규캐릭터 날개 type 12에서 제외
; 2429 : 	else if ((Type == 12 && ((m_Type > ITEM_WING + 6) && (m_Type < ITEM_WING + 36) && (m_Type > ITEM_WING + 43)))
; 2430 : #else
; 2431 : 	else if ((Type == 12 && ((m_Type > ITEM_WING + 6) && (m_Type < ITEM_WING + 36) && (m_Type > ITEM_WING + 40)))
; 2432 : #endif
; 2433 : 		|| Type == 13 || Type == 15)	//12(날개,구슬) 13(사탄,반지) 15(법서)
; 2434 : #else	
; 2435 : 	else if ((Type == 12 && m_Type > ITEM_WING + 6) || Type == 13 || Type == 15)//12(날개,구슬) 13(사탄,반지) 15(법서)

  00b0a	83 7d e8 0c	 cmp	 DWORD PTR _Type$[ebp], 12 ; 0000000cH
  00b0e	75 0f		 jne	 SHORT $LN161@Value
  00b10	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b13	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00b17	81 f9 86 01 00
	00		 cmp	 ecx, 390		; 00000186H
  00b1d	7f 0c		 jg	 SHORT $LN160@Value
$LN161@Value:
  00b1f	83 7d e8 0d	 cmp	 DWORD PTR _Type$[ebp], 13 ; 0000000dH
  00b23	74 06		 je	 SHORT $LN160@Value
  00b25	83 7d e8 0f	 cmp	 DWORD PTR _Type$[ebp], 15 ; 0000000fH
  00b29	75 77		 jne	 SHORT $LN158@Value
$LN160@Value:

; 2436 : #endif
; 2437 : 	{
; 2438 : 		//int Level2 = p->Level+m_Level*3;
; 2439 : 		Gold = 100 + Level2 * Level2*Level2;

  00b2b	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00b2e	0f af 45 e4	 imul	 eax, DWORD PTR _Level2$[ebp]
  00b32	0f af 45 e4	 imul	 eax, DWORD PTR _Level2$[ebp]
  00b36	83 c0 64	 add	 eax, 100		; 00000064H
  00b39	99		 cdq
  00b3a	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00b3d	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx

; 2440 : 			for (int i = 0; i < m_SpecialNum; i++)

  00b40	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  00b47	eb 09		 jmp	 SHORT $LN28@Value
$LN26@Value:
  00b49	8b 45 cc	 mov	 eax, DWORD PTR _i$4[ebp]
  00b4c	83 c0 01	 add	 eax, 1
  00b4f	89 45 cc	 mov	 DWORD PTR _i$4[ebp], eax
$LN28@Value:
  00b52	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b55	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  00b59	39 4d cc	 cmp	 DWORD PTR _i$4[ebp], ecx
  00b5c	7d 3f		 jge	 SHORT $LN27@Value

; 2441 : 			{
; 2442 : 				switch (m_Special[i])

  00b5e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b61	03 45 cc	 add	 eax, DWORD PTR _i$4[ebp]
  00b64	8a 48 31	 mov	 cl, BYTE PTR [eax+49]
  00b67	88 8d 7c ff ff
	ff		 mov	 BYTE PTR tv408[ebp], cl
  00b6d	80 bd 7c ff ff
	ff 55		 cmp	 BYTE PTR tv408[ebp], 85	; 00000055H
  00b74	74 02		 je	 SHORT $LN162@Value
  00b76	eb 23		 jmp	 SHORT $LN29@Value
$LN162@Value:

; 2443 : 				{
; 2444 : 				case AT_LIFE_REGENERATION:
; 2445 : 					Gold += Gold * m_Option3;

  00b78	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b7b	0f b6 40 7a	 movzx	 eax, BYTE PTR [eax+122]
  00b7f	99		 cdq
  00b80	52		 push	 edx
  00b81	50		 push	 eax
  00b82	8b 4d f0	 mov	 ecx, DWORD PTR _Gold$[ebp+4]
  00b85	51		 push	 ecx
  00b86	8b 55 ec	 mov	 edx, DWORD PTR _Gold$[ebp]
  00b89	52		 push	 edx
  00b8a	e8 00 00 00 00	 call	 __allmul
  00b8f	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00b92	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00b95	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00b98	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN29@Value:

; 2446 : 					break;
; 2447 : 				}
; 2448 : 			}

  00b9b	eb ac		 jmp	 SHORT $LN26@Value
$LN27@Value:

; 2449 : 	}

  00b9d	e9 0a 04 00 00	 jmp	 $LN34@Value
$LN158@Value:

; 2450 : #ifdef ADD_FIRECRACKER_NPC_20070306	// 폭죽가격 설정
; 2451 : 	else if (m_Type == MAKE_ITEMNUM(14, 63))	// 폭죽
; 2452 : 	{
; 2453 : 		Gold = 200000;
; 2454 : 	}
; 2455 : #endif
; 2456 : #ifdef MODIFY_CHERRYBLOSSOM_SELL_MONEY_BUGFIX_20090325
; 2457 : 	// 벚꽃 관련 아이템 가격
; 2458 : 	else if (m_Type == MAKE_ITEMNUM(14, 85)		// 벚꽃술
; 2459 : 		|| m_Type == MAKE_ITEMNUM(14, 86)		// 벚꽃놀이 경단
; 2460 : 		|| m_Type == MAKE_ITEMNUM(14, 87)		// 벚꽃 꽃잎
; 2461 : 		|| m_Type == MAKE_ITEMNUM(14, 90)		// 황금 벚꽃 가지
; 2462 : 		)
; 2463 : 	{
; 2464 : 		Gold = 100 * 3 * (int)m_Durability;
; 2465 : 	}
; 2466 : #endif // MODIFY_CHERRYBLOSSOM_SELL_MONEY_BUGFIX_20090325
; 2467 : 	else
; 2468 : 	{
; 2469 : 		//Level2 = p->Level+m_Level*3;
; 2470 : 		switch (m_Level)     //+무기일수록 가중치 붙음

  00ba2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ba5	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00ba9	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv419[ebp], ecx
  00baf	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv419[ebp]
  00bb5	83 ea 05	 sub	 edx, 5
  00bb8	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv419[ebp], edx
  00bbe	83 bd 7c ff ff
	ff 08		 cmp	 DWORD PTR tv419[ebp], 8
  00bc5	77 74		 ja	 SHORT $LN31@Value
  00bc7	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv419[ebp]
  00bcd	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN207@Value[eax*4]
$LN163@Value:

; 2471 : 		{
; 2472 : 		case 5:Level2 += 4; break;

  00bd4	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00bd7	83 c0 04	 add	 eax, 4
  00bda	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
  00bdd	eb 5c		 jmp	 SHORT $LN31@Value
$LN164@Value:

; 2473 : 		case 6:Level2 += 10; break;

  00bdf	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00be2	83 c0 0a	 add	 eax, 10			; 0000000aH
  00be5	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
  00be8	eb 51		 jmp	 SHORT $LN31@Value
$LN165@Value:

; 2474 : 		case 7:Level2 += 25; break;

  00bea	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00bed	83 c0 19	 add	 eax, 25			; 00000019H
  00bf0	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
  00bf3	eb 46		 jmp	 SHORT $LN31@Value
$LN166@Value:

; 2475 : 		case 8:Level2 += 45; break;

  00bf5	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00bf8	83 c0 2d	 add	 eax, 45			; 0000002dH
  00bfb	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
  00bfe	eb 3b		 jmp	 SHORT $LN31@Value
$LN167@Value:

; 2476 : 		case 9:Level2 += 65; break;

  00c00	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00c03	83 c0 41	 add	 eax, 65			; 00000041H
  00c06	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
  00c09	eb 30		 jmp	 SHORT $LN31@Value
$LN168@Value:

; 2477 : 		case 10:Level2 += 95; break;

  00c0b	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00c0e	83 c0 5f	 add	 eax, 95			; 0000005fH
  00c11	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
  00c14	eb 25		 jmp	 SHORT $LN31@Value
$LN169@Value:

; 2478 : 		case 11:Level2 += 135; break;

  00c16	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00c19	05 87 00 00 00	 add	 eax, 135		; 00000087H
  00c1e	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
  00c21	eb 18		 jmp	 SHORT $LN31@Value
$LN170@Value:

; 2479 : #ifdef ITEM_12_13_20040401
; 2480 : 		case 12:Level2 += 185; break;

  00c23	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00c26	05 b9 00 00 00	 add	 eax, 185		; 000000b9H
  00c2b	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
  00c2e	eb 0b		 jmp	 SHORT $LN31@Value
$LN171@Value:

; 2481 : 		case 13:Level2 += 245; break;

  00c30	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00c33	05 f5 00 00 00	 add	 eax, 245		; 000000f5H
  00c38	89 45 e4	 mov	 DWORD PTR _Level2$[ebp], eax
$LN31@Value:

; 2482 : #endif
; 2483 : 		}
; 2484 : 		if (Type == 12 && m_Type <= ITEM_WING + 6)

  00c3b	83 7d e8 0c	 cmp	 DWORD PTR _Type$[ebp], 12 ; 0000000cH
  00c3f	75 2e		 jne	 SHORT $LN172@Value
  00c41	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c44	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00c48	81 f9 86 01 00
	00		 cmp	 ecx, 390		; 00000186H
  00c4e	7f 1f		 jg	 SHORT $LN172@Value

; 2485 : 		{
; 2486 : 			Gold = 40000000 + ((40 + Level2)*Level2*Level2 * 11);

  00c50	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00c53	83 c0 28	 add	 eax, 40			; 00000028H
  00c56	0f af 45 e4	 imul	 eax, DWORD PTR _Level2$[ebp]
  00c5a	0f af 45 e4	 imul	 eax, DWORD PTR _Level2$[ebp]
  00c5e	6b c0 0b	 imul	 eax, eax, 11
  00c61	05 00 5a 62 02	 add	 eax, 40000000		; 02625a00H
  00c66	99		 cdq
  00c67	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00c6a	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx

; 2487 : 		}

  00c6d	eb 21		 jmp	 SHORT $LN173@Value
$LN172@Value:

; 2488 : #ifdef ADD_THIRD_WING_20070525	// 3차날개 기본가격 설정
; 2489 : 		else if (Type == 12 && (m_Type >= ITEM_WING + 36 && m_Type <= ITEM_WING + 40))
; 2490 : 		{
; 2491 : 			Gold = 40000000 + ((40 + Level2) * Level2 * Level2 * 11);
; 2492 : 		}
; 2493 : #endif
; 2494 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 신규캐릭터 날개 가격
; 2495 : 		else if (Type == 12 && (m_Type >= ITEM_WING + 41 && m_Type <= ITEM_WING + 43))
; 2496 : 		{
; 2497 : 			Gold = 40000000 + ((40 + Level2)*Level2*Level2 * 11);
; 2498 : 		}
; 2499 : #endif
; 2500 : 		else
; 2501 : 		{
; 2502 : 			Gold = 100 + (40 + Level2)*Level2*Level2 / 8;

  00c6f	8b 45 e4	 mov	 eax, DWORD PTR _Level2$[ebp]
  00c72	83 c0 28	 add	 eax, 40			; 00000028H
  00c75	0f af 45 e4	 imul	 eax, DWORD PTR _Level2$[ebp]
  00c79	0f af 45 e4	 imul	 eax, DWORD PTR _Level2$[ebp]
  00c7d	99		 cdq
  00c7e	83 e2 07	 and	 edx, 7
  00c81	03 c2		 add	 eax, edx
  00c83	c1 f8 03	 sar	 eax, 3
  00c86	83 c0 64	 add	 eax, 100		; 00000064H
  00c89	99		 cdq
  00c8a	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00c8d	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN173@Value:

; 2503 : 		}
; 2504 : 		if (Type >= 0 && Type <= 6) //무기일때

  00c90	83 7d e8 00	 cmp	 DWORD PTR _Type$[ebp], 0
  00c94	7c 33		 jl	 SHORT $LN175@Value
  00c96	83 7d e8 06	 cmp	 DWORD PTR _Type$[ebp], 6
  00c9a	7f 2d		 jg	 SHORT $LN175@Value

; 2505 : 		{
; 2506 : 			if (!p->TwoHand) //한손무기일때 80%

  00c9c	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00c9f	0f b6 48 21	 movzx	 ecx, BYTE PTR [eax+33]
  00ca3	85 c9		 test	 ecx, ecx
  00ca5	75 22		 jne	 SHORT $LN175@Value

; 2507 : 				Gold = Gold * 80 / 100;

  00ca7	6a 00		 push	 0
  00ca9	6a 50		 push	 80			; 00000050H
  00cab	8b 45 f0	 mov	 eax, DWORD PTR _Gold$[ebp+4]
  00cae	50		 push	 eax
  00caf	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00cb2	51		 push	 ecx
  00cb3	e8 00 00 00 00	 call	 __allmul
  00cb8	6a 00		 push	 0
  00cba	6a 64		 push	 100			; 00000064H
  00cbc	52		 push	 edx
  00cbd	50		 push	 eax
  00cbe	e8 00 00 00 00	 call	 __alldiv
  00cc3	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00cc6	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN175@Value:

; 2508 : 		}
; 2509 : 		for (int i = 0; i < m_SpecialNum; i++)

  00cc9	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00cd0	eb 09		 jmp	 SHORT $LN35@Value
$LN33@Value:
  00cd2	8b 45 c8	 mov	 eax, DWORD PTR _i$3[ebp]
  00cd5	83 c0 01	 add	 eax, 1
  00cd8	89 45 c8	 mov	 DWORD PTR _i$3[ebp], eax
$LN35@Value:
  00cdb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cde	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  00ce2	39 4d c8	 cmp	 DWORD PTR _i$3[ebp], ecx
  00ce5	0f 8d c1 02 00
	00		 jge	 $LN34@Value

; 2510 : 		{
; 2511 : 			switch (m_Special[i])

  00ceb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cee	03 45 c8	 add	 eax, DWORD PTR _i$3[ebp]
  00cf1	0f b6 48 31	 movzx	 ecx, BYTE PTR [eax+49]
  00cf5	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv462[ebp], ecx
  00cfb	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv462[ebp]
  00d01	83 ea 12	 sub	 edx, 18			; 00000012H
  00d04	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv462[ebp], edx
  00d0a	83 bd 7c ff ff
	ff 56		 cmp	 DWORD PTR tv462[ebp], 86 ; 00000056H
  00d11	0f 87 90 02 00
	00		 ja	 $LN36@Value
  00d17	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv462[ebp]
  00d1d	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN208@Value[eax]
  00d24	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN209@Value[ecx*4]
$LN176@Value:

; 2512 : 			{
; 2513 : 			case AT_SKILL_BLOCKING:
; 2514 : 			case AT_SKILL_SWORD1:
; 2515 : 			case AT_SKILL_SWORD2:
; 2516 : 			case AT_SKILL_SWORD3:
; 2517 : 			case AT_SKILL_SWORD4:
; 2518 : 			case AT_SKILL_SWORD5:
; 2519 : #ifdef ADD_SKILL_20031022
; 2520 : 			case AT_SKILL_SWORD6:
; 2521 : #endif
; 2522 : 			case AT_SKILL_CROSSBOW:
; 2523 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 2524 : 				Gold += (__int64)((double)Gold*1.5f);

  00d2b	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00d2e	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00d31	e8 00 00 00 00	 call	 __ltod3
  00d36	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff8000000000000
  00d3e	e8 00 00 00 00	 call	 __dtol3
  00d43	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00d46	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00d49	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00d4c	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx

; 2525 : #else
; 2526 : 				Gold += (DWORD)((float)Gold*1.5f);
; 2527 : #endif
; 2528 : 				break;

  00d4f	e9 53 02 00 00	 jmp	 $LN36@Value
$LN177@Value:

; 2529 : 			case AT_IMPROVE_DAMAGE:
; 2530 : 			case AT_IMPROVE_MAGIC:
; 2531 : 			case AT_IMPROVE_DEFENSE:
; 2532 : 			case AT_LIFE_REGENERATION:
; 2533 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130
; 2534 : 			case AT_IMPROVE_CURSE:
; 2535 : #endif				
; 2536 : 				switch (m_Option3)

  00d54	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00d57	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  00d5b	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv470[ebp], ecx
  00d61	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv470[ebp]
  00d67	83 ea 01	 sub	 edx, 1
  00d6a	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv470[ebp], edx
  00d70	83 bd 7c ff ff
	ff 03		 cmp	 DWORD PTR tv470[ebp], 3
  00d77	0f 87 c6 00 00
	00		 ja	 $LN38@Value
  00d7d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv470[ebp]
  00d83	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN210@Value[eax*4]
$LN178@Value:

; 2537 : 				{
; 2538 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 2539 : 				case 1:Gold += (__int64)((double)Gold * 6 / 10); break;

  00d8a	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00d8d	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00d90	e8 00 00 00 00	 call	 __ltod3
  00d95	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4018000000000000
  00d9d	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00da5	e8 00 00 00 00	 call	 __dtol3
  00daa	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00dad	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00db0	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00db3	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
  00db6	e9 88 00 00 00	 jmp	 $LN38@Value
$LN179@Value:

; 2540 : 				case 2:Gold += (__int64)((double)Gold * 14 / 10); break;

  00dbb	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00dbe	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00dc1	e8 00 00 00 00	 call	 __ltod3
  00dc6	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@402c000000000000
  00dce	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00dd6	e8 00 00 00 00	 call	 __dtol3
  00ddb	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00dde	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00de1	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00de4	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
  00de7	eb 5a		 jmp	 SHORT $LN38@Value
$LN180@Value:

; 2541 : 				case 3:Gold += (__int64)((double)Gold * 28 / 10); break;

  00de9	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00dec	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00def	e8 00 00 00 00	 call	 __ltod3
  00df4	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@403c000000000000
  00dfc	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00e04	e8 00 00 00 00	 call	 __dtol3
  00e09	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00e0c	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00e0f	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00e12	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
  00e15	eb 2c		 jmp	 SHORT $LN38@Value
$LN181@Value:

; 2542 : 				case 4:Gold += (__int64)((double)Gold * 56 / 10); break;

  00e17	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00e1a	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00e1d	e8 00 00 00 00	 call	 __ltod3
  00e22	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@404c000000000000
  00e2a	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00e32	e8 00 00 00 00	 call	 __dtol3
  00e37	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00e3a	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00e3d	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00e40	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN38@Value:

; 2543 : #else
; 2544 : 				case 1:Gold += (DWORD)((float)Gold * 6 / 10); break;
; 2545 : 				case 2:Gold += (DWORD)((float)Gold * 14 / 10); break;
; 2546 : 				case 3:Gold += (DWORD)((float)Gold * 28 / 10); break;
; 2547 : 				case 4:Gold += (DWORD)((float)Gold * 56 / 10); break;
; 2548 : #endif
; 2549 : 				}
; 2550 : 				break;

  00e43	e9 5f 01 00 00	 jmp	 $LN36@Value
$LN182@Value:

; 2551 : 			case AT_IMPROVE_BLOCKING:
; 2552 : 				switch (m_Option3)

  00e48	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e4b	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  00e4f	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv499[ebp], ecx
  00e55	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv499[ebp]
  00e5b	83 ea 01	 sub	 edx, 1
  00e5e	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv499[ebp], edx
  00e64	83 bd 7c ff ff
	ff 03		 cmp	 DWORD PTR tv499[ebp], 3
  00e6b	0f 87 c6 00 00
	00		 ja	 $LN40@Value
  00e71	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv499[ebp]
  00e77	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN211@Value[eax*4]
$LN183@Value:

; 2553 : 				{
; 2554 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 2555 : 				case 1: Gold += (__int64)((double)Gold * 6 / 10); break;

  00e7e	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00e81	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00e84	e8 00 00 00 00	 call	 __ltod3
  00e89	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4018000000000000
  00e91	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00e99	e8 00 00 00 00	 call	 __dtol3
  00e9e	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00ea1	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00ea4	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00ea7	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
  00eaa	e9 88 00 00 00	 jmp	 $LN40@Value
$LN184@Value:

; 2556 : 				case 2: Gold += (__int64)((double)Gold * 14 / 10); break;

  00eaf	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00eb2	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00eb5	e8 00 00 00 00	 call	 __ltod3
  00eba	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@402c000000000000
  00ec2	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00eca	e8 00 00 00 00	 call	 __dtol3
  00ecf	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00ed2	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00ed5	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00ed8	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
  00edb	eb 5a		 jmp	 SHORT $LN40@Value
$LN185@Value:

; 2557 : 				case 3: Gold += (__int64)((double)Gold * 28 / 10); break;

  00edd	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00ee0	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00ee3	e8 00 00 00 00	 call	 __ltod3
  00ee8	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@403c000000000000
  00ef0	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00ef8	e8 00 00 00 00	 call	 __dtol3
  00efd	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00f00	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00f03	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00f06	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
  00f09	eb 2c		 jmp	 SHORT $LN40@Value
$LN186@Value:

; 2558 : 				case 4: Gold += (__int64)((double)Gold * 56 / 10); break;

  00f0b	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00f0e	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00f11	e8 00 00 00 00	 call	 __ltod3
  00f16	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@404c000000000000
  00f1e	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4024000000000000
  00f26	e8 00 00 00 00	 call	 __dtol3
  00f2b	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00f2e	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00f31	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00f34	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN40@Value:

; 2559 : #else
; 2560 : 				case 1: Gold += (DWORD)((float)Gold * 6 / 10); break;
; 2561 : 				case 2: Gold += (DWORD)((float)Gold * 14 / 10); break;
; 2562 : 				case 3: Gold += (DWORD)((float)Gold * 28 / 10); break;
; 2563 : 				case 4: Gold += (DWORD)((float)Gold * 56 / 10); break;
; 2564 : #endif
; 2565 : 				}
; 2566 : 				break;

  00f37	eb 6e		 jmp	 SHORT $LN36@Value
$LN187@Value:

; 2567 : 			case AT_LUCK:
; 2568 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 2569 : 				Gold += (__int64)((double)Gold * 25 / 100);

  00f39	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00f3c	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00f3f	e8 00 00 00 00	 call	 __ltod3
  00f44	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4039000000000000
  00f4c	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4059000000000000
  00f54	e8 00 00 00 00	 call	 __dtol3
  00f59	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00f5c	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00f5f	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00f62	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx

; 2570 : #else
; 2571 : 				Gold += (DWORD)((float)Gold * 25 / 100);
; 2572 : #endif
; 2573 : 				break;

  00f65	eb 40		 jmp	 SHORT $LN36@Value
$LN188@Value:

; 2574 : 			case AT_IMPROVE_LIFE:
; 2575 : 			case AT_IMPROVE_MANA:
; 2576 : 			case AT_DECREASE_DAMAGE:
; 2577 : 			case AT_REFLECTION_DAMAGE:
; 2578 : 			case AT_IMPROVE_BLOCKING_PERCENT:
; 2579 : 			case AT_IMPROVE_GAIN_GOLD:
; 2580 : 			case AT_EXCELLENT_DAMAGE:
; 2581 : 			case AT_IMPROVE_DAMAGE_LEVEL:
; 2582 : 			case AT_IMPROVE_DAMAGE_PERCENT:
; 2583 : 			case AT_IMPROVE_MAGIC_LEVEL:
; 2584 : 			case AT_IMPROVE_MAGIC_PERCENT:
; 2585 : 			case AT_IMPROVE_ATTACK_SPEED:
; 2586 : 			case AT_IMPROVE_GAIN_LIFE:
; 2587 : 			case AT_IMPROVE_GAIN_MANA:
; 2588 : 				Gold += Gold;

  00f67	8b 45 ec	 mov	 eax, DWORD PTR _Gold$[ebp]
  00f6a	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00f6d	8b 4d f0	 mov	 ecx, DWORD PTR _Gold$[ebp+4]
  00f70	13 4d f0	 adc	 ecx, DWORD PTR _Gold$[ebp+4]
  00f73	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00f76	89 4d f0	 mov	 DWORD PTR _Gold$[ebp+4], ecx

; 2589 : 				break;

  00f79	eb 2c		 jmp	 SHORT $LN36@Value
$LN189@Value:

; 2590 : 
; 2591 : 				//  추가 날개.(2003.09.23)
; 2592 : 			case AT_PLUS_ONE_PERCENT_DAMAGE:
; 2593 : 			case AT_PLUS_WING_MAXLIFE:
; 2594 : 			case AT_PLUS_WING_MAXMANA:
; 2595 : 			case AT_IMPROVE_AG_MAX:
; 2596 : 			case AT_DAMAGE_ABSORB:
; 2597 : #ifdef ADD_THIRD_WING_20070525	// 3차 날개 가격 설정 - 옵션에 따른 추가금액
; 2598 : 			case AT_5PER_IGNORE_DEFENSE:
; 2599 : 			case AT_5PER_ATTACK_TURNING:
; 2600 : 			case AT_RECOVER_100PER_LIFE:
; 2601 : 			case AT_RECOVER_100PER_MASIC:
; 2602 : #endif				
; 2603 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 2604 : 				Gold += (__int64)((double)Gold * 25 / 100);

  00f7b	8b 55 f0	 mov	 edx, DWORD PTR _Gold$[ebp+4]
  00f7e	8b 4d ec	 mov	 ecx, DWORD PTR _Gold$[ebp]
  00f81	e8 00 00 00 00	 call	 __ltod3
  00f86	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4039000000000000
  00f8e	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4059000000000000
  00f96	e8 00 00 00 00	 call	 __dtol3
  00f9b	03 45 ec	 add	 eax, DWORD PTR _Gold$[ebp]
  00f9e	13 55 f0	 adc	 edx, DWORD PTR _Gold$[ebp+4]
  00fa1	89 45 ec	 mov	 DWORD PTR _Gold$[ebp], eax
  00fa4	89 55 f0	 mov	 DWORD PTR _Gold$[ebp+4], edx
$LN36@Value:

; 2605 : #else
; 2606 : 				Gold += (DWORD)((float)Gold * 25 / 100);
; 2607 : #endif
; 2608 : 				break;
; 2609 : 			}
; 2610 : 		}

  00fa7	e9 26 fd ff ff	 jmp	 $LN33@Value
$LN34@Value:

; 2611 : 
; 2612 : 	}
; 2613 : 
; 2614 : #ifndef CHARACTERDB_SERVER
; 2615 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 2616 : 	// 추가 옵션에 따른 가격 변경 : 380 추가 옵션
; 2617 : 	if (g_kItemSystemFor380.Is380OptionItem(this) == TRUE)
; 2618 : 	{
; 2619 : 		// 추가옵션 중 380 추가 옵션이 있는 경우 가격 1.6배
; 2620 : 		Gold += (__int64)((double)Gold * 16 / 100);
; 2621 : 	}
; 2622 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 2623 : 
; 2624 : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 2625 : 	// 소켓 아이템의 판매가격 설정 부분 추가
; 2626 : 	if (g_SocketOptionSystem.IsSocketItem(this) == true)
; 2627 : 	{
; 2628 : 		int iSocketSlotCount = 0;
; 2629 : 		int iSeedSphereValue = 0;
; 2630 : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_05_20080715
; 2631 : 		DWORD dwSeedSphereValue = 0;
; 2632 : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_05_20080715
; 2633 : 
; 2634 : 		for (int i = 0; i < MAX_SOCKET_SLOT; i++)
; 2635 : 		{
; 2636 : 			if (m_SocketOption[i] != SOCKETSLOT_NONE)
; 2637 : 			{
; 2638 : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_05_20080715
; 2639 : 				if (m_SocketOption[i] != SOCKETSLOT_EMPTY)
; 2640 : 				{
; 2641 : 					dwSeedSphereValue += g_SocketOptionSystem.GetSeedSphereValue(m_SocketOption[i]);
; 2642 : 				}
; 2643 : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_05_20080715
; 2644 : 				iSocketSlotCount++;
; 2645 : 			}
; 2646 : 		}
; 2647 : 		Gold += (DWORD)((float)Gold * (8 * iSocketSlotCount) / 10);
; 2648 : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_05_20080715
; 2649 : 		Gold += dwSeedSphereValue;
; 2650 : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_05_20080715
; 2651 : 	}
; 2652 : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 2653 : #endif
; 2654 : 
; 2655 : #ifdef MODIFY_ITEM_PRICE_MAXFIX
; 2656 : 
; 2657 : 	if (Gold > 3000000000)

  00fac	83 7d f0 00	 cmp	 DWORD PTR _Gold$[ebp+4], 0
  00fb0	7c 19		 jl	 SHORT $LN190@Value
  00fb2	7f 09		 jg	 SHORT $LN212@Value
  00fb4	81 7d ec 00 5e
	d0 b2		 cmp	 DWORD PTR _Gold$[ebp], -1294967296 ; b2d05e00H
  00fbb	76 0e		 jbe	 SHORT $LN190@Value
$LN212@Value:

; 2658 : 	{
; 2659 : 		Gold = 3000000000;

  00fbd	c7 45 ec 00 5e
	d0 b2		 mov	 DWORD PTR _Gold$[ebp], -1294967296 ; b2d05e00H
  00fc4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Gold$[ebp+4], 0
$LN190@Value:

; 2660 : 	}
; 2661 : 
; 2662 : #else
; 2663 : 	if (Gold > 1200000000)
; 2664 : 	{
; 2665 : 		Gold = 1200000000;
; 2666 : 	}
; 2667 : #endif
; 2668 : 
; 2669 : #ifdef FOR_TEMP_SERVER 
; 2670 : 	//------------------------------------------>
; 2671 : 	//grooving SEASON4 20080728 : 보석 판매 가격 1000 으로 통일(시즌4 체험 서버 임시 나중에 삭제)
; 2672 : 	if (m_Type == MAKE_ITEMNUM(14, 42))	// 조석
; 2673 : 	{
; 2674 : 		Gold = 1000;
; 2675 : 	}
; 2676 : 	//<------------------------------------------
; 2677 : #endif //FOR_TEMP_SERVER
; 2678 : 	m_BuyMoney = (DWORD)Gold;

  00fcb	8b 45 ec	 mov	 eax, DWORD PTR _Gold$[ebp]
  00fce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fd1	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 2679 : 	m_SellMoney = (DWORD)Gold;

  00fd4	8b 45 ec	 mov	 eax, DWORD PTR _Gold$[ebp]
  00fd7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00fda	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 2680 : 	m_SellMoney = m_SellMoney / 3;

  00fdd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fe0	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00fe3	33 d2		 xor	 edx, edx
  00fe5	b9 03 00 00 00	 mov	 ecx, 3
  00fea	f7 f1		 div	 ecx
  00fec	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00fef	89 42 60	 mov	 DWORD PTR [edx+96], eax

; 2681 : 
; 2682 : #ifdef _GAMESERVER
; 2683 : 	if (g_GlobalConfig.m_bBlessBug == true && this->m_Type == ITEM_POTION + 13)
; 2684 : #else
; 2685 : 	if (this->m_Type == ITEM_POTION + 13)

  00ff2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ff5	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00ff9	81 f9 cd 01 00
	00		 cmp	 ecx, 461		; 000001cdH
  00fff	75 5f		 jne	 SHORT $LN192@Value

; 2686 : #endif
; 2687 : 	{
; 2688 : 		this->m_SellMoney *= this->m_Durability;

  01001	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01004	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01007	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv1187[ebp], ecx
  0100d	f2 0f 2a 85 7c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv1187[ebp]
  01015	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv1187[ebp]
  0101b	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  0101e	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  01027	f2 0f 11 85 74
	ff ff ff	 movsd	 QWORD PTR tv1191[ebp], xmm0
  0102f	f2 0f 5a 85 74
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv1191[ebp]
  01037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0103a	f3 0f 59 40 24	 mulss	 xmm0, DWORD PTR [eax+36]
  0103f	e8 00 00 00 00	 call	 __ftoui3
  01044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01047	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 2689 : 
; 2690 : 		if (this->m_SellMoney > MAX_ZEN)

  0104a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0104d	81 78 60 00 94
	35 77		 cmp	 DWORD PTR [eax+96], 2000000000 ; 77359400H
  01054	76 0a		 jbe	 SHORT $LN192@Value

; 2691 : 			this->m_SellMoney = MAX_ZEN;

  01056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01059	c7 40 60 00 94
	35 77		 mov	 DWORD PTR [eax+96], 2000000000 ; 77359400H
$LN192@Value:

; 2692 : 	}
; 2693 : 
; 2694 : 	if ((m_Type < ITEM_POTION || m_Type > ITEM_POTION + 8) &&
; 2695 : #ifdef RING_EVENT_ITEMBOX_20031124		// 반지이벤트 - 마법사의 반지 판매가격
; 2696 : 		m_Type != ITEM_HELPER + 20 &&		// 마법사의 반지
; 2697 : #endif
; 2698 : #ifdef ADD_NEW_MAP_KALIMA_20040518
; 2699 : 		m_Type != ITEM_POTION + 28 &&		// 잃어버린 지도
; 2700 : 		m_Type != ITEM_POTION + 29 &&		// 쿤둔의 표식
; 2701 : #endif
; 2702 : 
; 2703 : #ifdef MODIFY_ACCUMULATED_BUG_MARKOFLORD_SELL_VALUE_01_20050531
; 2704 : 		m_Type != ITEM_POTION + 21 &&
; 2705 : #endif
; 2706 : 		m_Type != ITEM_HELPER + 15 &&		// 열매
; 2707 : 		m_Type != ITEM_HELPER + 16 &&		// 대천사의서
; 2708 : 		m_Type != ITEM_HELPER + 17 &&		// 블러드본

  01060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01063	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01067	81 f9 c0 01 00
	00		 cmp	 ecx, 448		; 000001c0H
  0106d	7c 13		 jl	 SHORT $LN194@Value
  0106f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01072	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01076	81 f9 c8 01 00
	00		 cmp	 ecx, 456		; 000001c8H
  0107c	0f 8e ff 00 00
	00		 jle	 $LN193@Value
$LN194@Value:
  01082	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01085	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01089	81 f9 b4 01 00
	00		 cmp	 ecx, 436		; 000001b4H
  0108f	0f 84 ec 00 00
	00		 je	 $LN193@Value
  01095	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01098	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0109c	81 f9 dc 01 00
	00		 cmp	 ecx, 476		; 000001dcH
  010a2	0f 84 d9 00 00
	00		 je	 $LN193@Value
  010a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010ab	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  010af	81 f9 dd 01 00
	00		 cmp	 ecx, 477		; 000001ddH
  010b5	0f 84 c6 00 00
	00		 je	 $LN193@Value
  010bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010be	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  010c2	81 f9 d5 01 00
	00		 cmp	 ecx, 469		; 000001d5H
  010c8	0f 84 b3 00 00
	00		 je	 $LN193@Value
  010ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010d1	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  010d5	81 f9 af 01 00
	00		 cmp	 ecx, 431		; 000001afH
  010db	0f 84 a0 00 00
	00		 je	 $LN193@Value
  010e1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010e4	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  010e8	81 f9 b0 01 00
	00		 cmp	 ecx, 432		; 000001b0H
  010ee	0f 84 8d 00 00
	00		 je	 $LN193@Value
  010f4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010f7	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  010fb	81 f9 b1 01 00
	00		 cmp	 ecx, 433		; 000001b1H
  01101	74 7e		 je	 SHORT $LN193@Value
  01103	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01106	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0110a	81 f9 b2 01 00
	00		 cmp	 ecx, 434		; 000001b2H
  01110	74 6f		 je	 SHORT $LN193@Value

; 2709 : 		m_Type != ITEM_HELPER + 18			// 투명망토
; 2710 : #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 2711 : 		&&m_Type != ITEM_HELPER + 11		// 라이프스톤
; 2712 : 		&& m_Type != ITEM_HELPER + 7		// 용병
; 2713 : #endif
; 2714 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 2715 : 		&&m_Type != ITEM_HELPER + 32		// 갑옷 파편
; 2716 : 		&& m_Type != ITEM_HELPER + 33		// 여신 파편
; 2717 : 		&& m_Type != ITEM_HELPER + 34		// 맹수 발톱
; 2718 : 		&& m_Type != ITEM_HELPER + 35		// 뿔피리 조각
; 2719 : 		&& m_Type != ITEM_HELPER + 36		// 부러진 뿔피리
; 2720 : 		&& m_Type != ITEM_HELPER + 37		// 펜릴의 뿔피리
; 2721 : #endif
; 2722 : #ifdef HALLOWINDAY_JACK_O_LANTERN_EVENT_20061017
; 2723 : 		&& m_Type != MAKE_ITEMNUM(14, 45)
; 2724 : 		&& m_Type != MAKE_ITEMNUM(14, 46)
; 2725 : 		&& m_Type != MAKE_ITEMNUM(14, 47)
; 2726 : 		&& m_Type != MAKE_ITEMNUM(14, 48)
; 2727 : 		&& m_Type != MAKE_ITEMNUM(14, 49)
; 2728 : 		&& m_Type != MAKE_ITEMNUM(14, 50)
; 2729 : #endif
; 2730 : #ifdef CHRISTMAS_STAR_20061211
; 2731 : 		&& m_Type != MAKE_ITEMNUM(14, 51)	// 크리스마스의 별
; 2732 : #endif	
; 2733 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029
; 2734 : 		&& m_Type != MAKE_ITEMNUM(14, 100)
; 2735 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029		
; 2736 : #ifdef MODIFY_SELLITEM_WITHOUT_DURABILITY_20090914
; 2737 : #ifdef MODIFY_CHERRYBLOSSOM_SELL_MONEY_BUGFIX_20090325
; 2738 : 		&& m_Type != MAKE_ITEMNUM(14, 85)		// 벚꽃술
; 2739 : 		&& m_Type != MAKE_ITEMNUM(14, 86)		// 벚꽃놀이 경단
; 2740 : 		&& m_Type != MAKE_ITEMNUM(14, 87)		// 벚꽃 꽃잎
; 2741 : 		&& m_Type != MAKE_ITEMNUM(14, 90)		// 황금 벚꽃 가지
; 2742 : #endif // MODIFY_CHERRYBLOSSOM_SELL_MONEY_BUGFIX_20090325
; 2743 : #else
; 2744 : #ifdef MODIFY_CHERRYBLOSSOM_SELL_MONEY_BUGFIX_20090325
; 2745 : 		&& m_Type == MAKE_ITEMNUM(14, 85)		// 벚꽃술
; 2746 : 		&& m_Type == MAKE_ITEMNUM(14, 86)		// 벚꽃놀이 경단
; 2747 : 		&& m_Type == MAKE_ITEMNUM(14, 87)		// 벚꽃 꽃잎
; 2748 : 		&& m_Type == MAKE_ITEMNUM(14, 90)		// 황금 벚꽃 가지
; 2749 : #endif // MODIFY_CHERRYBLOSSOM_SELL_MONEY_BUGFIX_20090325
; 2750 : #endif // MODIFY_SELLITEM_WITHOUT_DURABILITY_20090914
; 2751 : 		)
; 2752 : 	{
; 2753 : 		float  persent = 1.f - m_Durability / m_BaseDurability;

  01112	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01118	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0111d	f3 0f 5e 41 2c	 divss	 xmm0, DWORD PTR [ecx+44]
  01122	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0112a	f3 0f 5c c8	 subss	 xmm1, xmm0
  0112e	f3 0f 11 4d c4	 movss	 DWORD PTR _persent$2[ebp], xmm1

; 2754 : 		DWORD  repairGold = (DWORD)(m_SellMoney * 0.6 * persent);

  01133	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01136	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01139	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv1218[ebp], ecx
  0113f	f2 0f 2a 85 7c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv1218[ebp]
  01147	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv1218[ebp]
  0114d	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  01150	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  01159	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe3333333333333
  01161	f3 0f 5a 4d c4	 cvtss2sd xmm1, DWORD PTR _persent$2[ebp]
  01166	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0116a	e8 00 00 00 00	 call	 __dtoui3
  0116f	89 45 c0	 mov	 DWORD PTR _repairGold$1[ebp], eax

; 2755 : 		m_SellMoney -= repairGold;

  01172	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01175	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01178	2b 4d c0	 sub	 ecx, DWORD PTR _repairGold$1[ebp]
  0117b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0117e	89 4a 60	 mov	 DWORD PTR [edx+96], ecx
$LN193@Value:

; 2756 : 	}
; 2757 : 
; 2758 : 
; 2759 : 
; 2760 : 	//if(p->Durability > 0)
; 2761 : 	//	m_SellMoney += m_SellMoney*m_Durability/p->Durability;
; 2762 : 	if (m_SellMoney >= 1000)

  01181	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01184	81 78 60 e8 03
	00 00		 cmp	 DWORD PTR [eax+96], 1000 ; 000003e8H
  0118b	72 1a		 jb	 SHORT $LN195@Value

; 2763 : 		m_SellMoney = m_SellMoney / 100 * 100;

  0118d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01190	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  01193	33 d2		 xor	 edx, edx
  01195	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0119a	f7 f1		 div	 ecx
  0119c	6b d0 64	 imul	 edx, eax, 100
  0119f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011a2	89 50 60	 mov	 DWORD PTR [eax+96], edx
  011a5	eb 21		 jmp	 SHORT $LN197@Value
$LN195@Value:

; 2764 : 	else if (m_SellMoney >= 100)

  011a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011aa	83 78 60 64	 cmp	 DWORD PTR [eax+96], 100	; 00000064H
  011ae	72 18		 jb	 SHORT $LN197@Value

; 2765 : 		m_SellMoney = m_SellMoney / 10 * 10;

  011b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011b3	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  011b6	33 d2		 xor	 edx, edx
  011b8	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  011bd	f7 f1		 div	 ecx
  011bf	6b d0 0a	 imul	 edx, eax, 10
  011c2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011c5	89 50 60	 mov	 DWORD PTR [eax+96], edx
$LN197@Value:

; 2766 : 
; 2767 : 	if (m_BuyMoney >= 1000)

  011c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011cb	81 78 64 e8 03
	00 00		 cmp	 DWORD PTR [eax+100], 1000 ; 000003e8H
  011d2	72 1a		 jb	 SHORT $LN198@Value

; 2768 : 		m_BuyMoney = m_BuyMoney / 100 * 100;

  011d4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011d7	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  011da	33 d2		 xor	 edx, edx
  011dc	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  011e1	f7 f1		 div	 ecx
  011e3	6b d0 64	 imul	 edx, eax, 100
  011e6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011e9	89 50 64	 mov	 DWORD PTR [eax+100], edx
  011ec	eb 21		 jmp	 SHORT $LN200@Value
$LN198@Value:

; 2769 : 	else if (m_BuyMoney >= 100)

  011ee	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011f1	83 78 64 64	 cmp	 DWORD PTR [eax+100], 100 ; 00000064H
  011f5	72 18		 jb	 SHORT $LN200@Value

; 2770 : 		m_BuyMoney = m_BuyMoney / 10 * 10;

  011f7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011fa	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  011fd	33 d2		 xor	 edx, edx
  011ff	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  01204	f7 f1		 div	 ecx
  01206	6b d0 0a	 imul	 edx, eax, 10
  01209	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0120c	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN200@Value:
$LN1@Value:

; 2771 : 
; 2772 : }

  0120f	5f		 pop	 edi
  01210	5e		 pop	 esi
  01211	5b		 pop	 ebx
  01212	8b e5		 mov	 esp, ebp
  01214	5d		 pop	 ebp
  01215	c3		 ret	 0
  01216	66 90		 npad	 2
$LN202@Value:
  01218	00 00 00 00	 DD	 $LN89@Value
  0121c	00 00 00 00	 DD	 $LN90@Value
  01220	00 00 00 00	 DD	 $LN91@Value
  01224	00 00 00 00	 DD	 $LN92@Value
$LN203@Value:
  01228	00 00 00 00	 DD	 $LN96@Value
  0122c	00 00 00 00	 DD	 $LN97@Value
  01230	00 00 00 00	 DD	 $LN98@Value
  01234	00 00 00 00	 DD	 $LN99@Value
$LN204@Value:
  01238	00 00 00 00	 DD	 $LN103@Value
  0123c	00 00 00 00	 DD	 $LN104@Value
  01240	00 00 00 00	 DD	 $LN105@Value
  01244	00 00 00 00	 DD	 $LN106@Value
$LN205@Value:
  01248	00 00 00 00	 DD	 $LN119@Value
  0124c	00 00 00 00	 DD	 $LN120@Value
  01250	00 00 00 00	 DD	 $LN121@Value
  01254	00 00 00 00	 DD	 $LN122@Value
  01258	00 00 00 00	 DD	 $LN123@Value
  0125c	00 00 00 00	 DD	 $LN124@Value
  01260	00 00 00 00	 DD	 $LN125@Value
$LN206@Value:
  01264	00 00 00 00	 DD	 $LN130@Value
  01268	00 00 00 00	 DD	 $LN131@Value
  0126c	00 00 00 00	 DD	 $LN132@Value
  01270	00 00 00 00	 DD	 $LN133@Value
  01274	00 00 00 00	 DD	 $LN134@Value
  01278	00 00 00 00	 DD	 $LN135@Value
  0127c	00 00 00 00	 DD	 $LN136@Value
$LN207@Value:
  01280	00 00 00 00	 DD	 $LN163@Value
  01284	00 00 00 00	 DD	 $LN164@Value
  01288	00 00 00 00	 DD	 $LN165@Value
  0128c	00 00 00 00	 DD	 $LN166@Value
  01290	00 00 00 00	 DD	 $LN167@Value
  01294	00 00 00 00	 DD	 $LN168@Value
  01298	00 00 00 00	 DD	 $LN169@Value
  0129c	00 00 00 00	 DD	 $LN170@Value
  012a0	00 00 00 00	 DD	 $LN171@Value
$LN209@Value:
  012a4	00 00 00 00	 DD	 $LN176@Value
  012a8	00 00 00 00	 DD	 $LN177@Value
  012ac	00 00 00 00	 DD	 $LN182@Value
  012b0	00 00 00 00	 DD	 $LN187@Value
  012b4	00 00 00 00	 DD	 $LN188@Value
  012b8	00 00 00 00	 DD	 $LN189@Value
  012bc	00 00 00 00	 DD	 $LN36@Value
$LN208@Value:
  012c0	00		 DB	 0
  012c1	00		 DB	 0
  012c2	00		 DB	 0
  012c3	00		 DB	 0
  012c4	00		 DB	 0
  012c5	00		 DB	 0
  012c6	00		 DB	 0
  012c7	06		 DB	 6
  012c8	06		 DB	 6
  012c9	06		 DB	 6
  012ca	06		 DB	 6
  012cb	06		 DB	 6
  012cc	06		 DB	 6
  012cd	06		 DB	 6
  012ce	06		 DB	 6
  012cf	06		 DB	 6
  012d0	06		 DB	 6
  012d1	06		 DB	 6
  012d2	06		 DB	 6
  012d3	06		 DB	 6
  012d4	06		 DB	 6
  012d5	06		 DB	 6
  012d6	06		 DB	 6
  012d7	06		 DB	 6
  012d8	06		 DB	 6
  012d9	06		 DB	 6
  012da	06		 DB	 6
  012db	06		 DB	 6
  012dc	06		 DB	 6
  012dd	06		 DB	 6
  012de	06		 DB	 6
  012df	06		 DB	 6
  012e0	06		 DB	 6
  012e1	06		 DB	 6
  012e2	06		 DB	 6
  012e3	06		 DB	 6
  012e4	06		 DB	 6
  012e5	06		 DB	 6
  012e6	00		 DB	 0
  012e7	06		 DB	 6
  012e8	06		 DB	 6
  012e9	06		 DB	 6
  012ea	06		 DB	 6
  012eb	06		 DB	 6
  012ec	06		 DB	 6
  012ed	06		 DB	 6
  012ee	06		 DB	 6
  012ef	06		 DB	 6
  012f0	06		 DB	 6
  012f1	06		 DB	 6
  012f2	06		 DB	 6
  012f3	06		 DB	 6
  012f4	06		 DB	 6
  012f5	06		 DB	 6
  012f6	06		 DB	 6
  012f7	06		 DB	 6
  012f8	06		 DB	 6
  012f9	06		 DB	 6
  012fa	06		 DB	 6
  012fb	06		 DB	 6
  012fc	06		 DB	 6
  012fd	06		 DB	 6
  012fe	01		 DB	 1
  012ff	01		 DB	 1
  01300	02		 DB	 2
  01301	01		 DB	 1
  01302	03		 DB	 3
  01303	01		 DB	 1
  01304	04		 DB	 4
  01305	04		 DB	 4
  01306	04		 DB	 4
  01307	04		 DB	 4
  01308	04		 DB	 4
  01309	04		 DB	 4
  0130a	04		 DB	 4
  0130b	04		 DB	 4
  0130c	04		 DB	 4
  0130d	04		 DB	 4
  0130e	04		 DB	 4
  0130f	04		 DB	 4
  01310	04		 DB	 4
  01311	04		 DB	 4
  01312	05		 DB	 5
  01313	05		 DB	 5
  01314	05		 DB	 5
  01315	05		 DB	 5
  01316	05		 DB	 5
  01317	90		 npad	 1
$LN210@Value:
  01318	00 00 00 00	 DD	 $LN178@Value
  0131c	00 00 00 00	 DD	 $LN179@Value
  01320	00 00 00 00	 DD	 $LN180@Value
  01324	00 00 00 00	 DD	 $LN181@Value
$LN211@Value:
  01328	00 00 00 00	 DD	 $LN183@Value
  0132c	00 00 00 00	 DD	 $LN184@Value
  01330	00 00 00 00	 DD	 $LN185@Value
  01334	00 00 00 00	 DD	 $LN186@Value
?Value@CItem@@QAEXXZ ENDP				; CItem::Value
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?Convert@CItem@@QAEXHEEEEEE@Z
_TEXT	SEGMENT
tv236 = -97						; size = 1
_i$1 = -32						; size = 4
_iChaosItem$ = -28					; size = 4
_SOptionStatValue$ = -24				; size = 4
_SOption$ = -20						; size = 4
_p$ = -16						; size = 4
_ItemLevel$ = -12					; size = 4
__type$ = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 4
_Option1$ = 12						; size = 1
_Option2$ = 16						; size = 1
_Option3$ = 20						; size = 1
_Attribute2$ = 24					; size = 1
_SetOption$ = 28					; size = 1
_DbVersion$ = 32					; size = 1
?Convert@CItem@@QAEXHEEEEEE@Z PROC			; CItem::Convert, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 	int _type = type;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __type$[ebp], eax

; 148  : 	int ItemLevel;
; 149  : 
; 150  : 	if (DbVersion == 0x00)

  00012	0f b6 45 20	 movzx	 eax, BYTE PTR _DbVersion$[ebp]
  00016	85 c0		 test	 eax, eax
  00018	75 24		 jne	 SHORT $LN5@Convert

; 151  : 	{
; 152  : 		_type = ((type / 16)*MAX_ITEM_INDEX) + (type % 16);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  0001d	99		 cdq
  0001e	83 e2 0f	 and	 edx, 15			; 0000000fH
  00021	03 c2		 add	 eax, edx
  00023	c1 f8 04	 sar	 eax, 4
  00026	c1 e0 05	 shl	 eax, 5
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  0002c	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  00032	79 05		 jns	 SHORT $LN208@Convert
  00034	49		 dec	 ecx
  00035	83 c9 f0	 or	 ecx, -16		; fffffff0H
  00038	41		 inc	 ecx
$LN208@Convert:
  00039	03 c1		 add	 eax, ecx
  0003b	89 45 f8	 mov	 DWORD PTR __type$[ebp], eax
$LN5@Convert:

; 153  : 	}
; 154  : 
; 155  : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 156  : #ifdef ITEM_INDEX_EXTEND_20050706
; 157  : 	else if (DbVersion <= 0x02)
; 158  : 	{
; 159  : 		_type = ((type / 32)*MAX_ITEM_INDEX) + (type % 32);
; 160  : 	}
; 161  : #endif
; 162  : #endif
; 163  : 
; 164  : 	if (_type > MAX_ITEM - 1)

  0003e	81 7d f8 ff 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 511 ; 000001ffH
  00045	7e 14		 jle	 SHORT $LN6@Convert

; 165  : 	{
; 166  : 		LogAddC(LOGC_RED, "error-L1 : ItemIndex error %d", _type);

  00047	8b 45 f8	 mov	 eax, DWORD PTR __type$[ebp]
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NENAGJKH@error?9L1?5?3?5ItemIndex?5error?5?$CFd@
  00050	6a 02		 push	 2
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@Convert:

; 167  : 	}
; 168  : 
; 169  : 	ITEM_ATTRIBUTE *p = &ItemAttribute[_type];

  0005b	6b 45 f8 6c	 imul	 eax, DWORD PTR __type$[ebp], 108
  0005f	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00064	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 170  : 
; 171  : 	m_serial = ItemAttribute[_type].Serial;

  00067	6b 45 f8 6c	 imul	 eax, DWORD PTR __type$[ebp], 108
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	8a 90 25 00 00
	00		 mov	 dl, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+37]
  00074	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 172  : 	m_Type = type;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	66 8b 4d 08	 mov	 cx, WORD PTR _type$[ebp]
  0007e	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 173  : 
; 174  : #ifdef ITEM_INDEX_EXTEND_20050706
; 175  : 	if (DbVersion <= 0x02)
; 176  : #else
; 177  : 	if (DbVersion == 0x00)

  00082	0f b6 45 20	 movzx	 eax, BYTE PTR _DbVersion$[ebp]
  00086	85 c0		 test	 eax, eax
  00088	75 0b		 jne	 SHORT $LN7@Convert

; 178  : #endif
; 179  : 		m_Type = _type;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	66 8b 4d f8	 mov	 cx, WORD PTR __type$[ebp]
  00091	66 89 48 06	 mov	 WORD PTR [eax+6], cx
$LN7@Convert:

; 180  : 
; 181  : 	m_NewOption = Attribute2;

  00095	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8a 4d 18	 mov	 cl, BYTE PTR _Attribute2$[ebp]
  0009b	88 48 7b	 mov	 BYTE PTR [eax+123], cl

; 182  : 	if (p->OptionFlag == 0)

  0009e	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  000a1	0f b6 48 26	 movzx	 ecx, BYTE PTR [eax+38]
  000a5	85 c9		 test	 ecx, ecx
  000a7	75 07		 jne	 SHORT $LN8@Convert

; 183  : 	{
; 184  : 		m_NewOption = 0;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	c6 40 7b 00	 mov	 BYTE PTR [eax+123], 0
$LN8@Convert:

; 185  : 	}
; 186  : #ifdef NEW_FORSKYLAND2
; 187  : #ifdef ADD_THIRD_WING_20070525	// 3차날개 엑설런트 처리 하지 않는다.
; 188  : 	if ((_type >= ITEM_WING + 3 && _type <= ITEM_WING + 6) || (_type == ITEM_HELPER + 30)
; 189  : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 날개는 엑설런트 처리안함
; 190  : 		|| (_type == ITEM_WING + 41)	// 신규캐릭터 1차날개(재앙의 날개)
; 191  : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130
; 192  : 		|| (_type == ITEM_WING + 42)	// 신규캐릭터 2차날개(절망의 날개)
; 193  : 		|| (_type == ITEM_WING + 43)	// 신규캐릭터 3차날개(차원의 날개)
; 194  : #endif		
; 195  : #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912		
; 196  : 		|| (_type >= ITEM_WING + 36 && _type <= ITEM_WING + 40)) // 날개
; 197  : #else	
; 198  : #ifdef DARKLORD_WORK
; 199  : 	if ((_type >= ITEM_WING + 3 && _type <= ITEM_WING + 6) || (_type == ITEM_HELPER + 30)) // 날개	    

  000b0	81 7d f8 83 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 387 ; 00000183H
  000b7	7c 09		 jl	 SHORT $LN11@Convert
  000b9	81 7d f8 86 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 390 ; 00000186H
  000c0	7e 09		 jle	 SHORT $LN10@Convert
$LN11@Convert:
  000c2	81 7d f8 be 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 446 ; 000001beH
  000c9	75 04		 jne	 SHORT $LN9@Convert
$LN10@Convert:

; 200  : #else
; 201  : 	if (_type >= ITEM_WING + 3 && _type <= ITEM_WING + 6) // 날개	    
; 202  : #endif
; 203  : #endif	// ADD_THIRD_WING_20070525
; 204  : 	{
; 205  : 		Attribute2 = 0;

  000cb	c6 45 18 00	 mov	 BYTE PTR _Attribute2$[ebp], 0
$LN9@Convert:

; 206  : 	}
; 207  : #endif
; 208  : 
; 209  : #ifdef ADD_ITEM_FENRIR_01_20051110
; 210  : 	// 펜릴의 경우 액설런트 처리 ( 아이템 착용레벨, 내구도 등) 하지 않는다.
; 211  : 	if (_type == MAKE_ITEMNUM(13, 37))
; 212  : 	{
; 213  : 		Attribute2 = 0;
; 214  : 	}
; 215  : #endif
; 216  : 
; 217  : #if GAME_VERSION >= G_V_99B
; 218  : 	SetOption = SetOption & 0x0f;

  000cf	0f b6 45 1c	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  000d3	83 e0 0f	 and	 eax, 15			; 0000000fH
  000d6	88 45 1c	 mov	 BYTE PTR _SetOption$[ebp], al

; 219  : 
; 220  : 	int	SOption = SetOption & 0x03;					// 세트 옵션 타입 (1:A타입, 2:B타입)

  000d9	0f b6 45 1c	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  000dd	83 e0 03	 and	 eax, 3
  000e0	89 45 ec	 mov	 DWORD PTR _SOption$[ebp], eax

; 221  : 	int	SOptionStatValue = 0;						// 세트 옵션 스탯 값 (1:5, 2:10)

  000e3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SOptionStatValue$[ebp], 0

; 222  : 	if (SOption != 1 && SOption != 2)

  000ea	83 7d ec 01	 cmp	 DWORD PTR _SOption$[ebp], 1
  000ee	74 0d		 je	 SHORT $LN12@Convert
  000f0	83 7d ec 02	 cmp	 DWORD PTR _SOption$[ebp], 2
  000f4	74 07		 je	 SHORT $LN12@Convert

; 223  : 	{	// SetOption == 1 A Option || SetOption == 2 B Option
; 224  : 		SOption = 0;

  000f6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _SOption$[ebp], 0
$LN12@Convert:

; 225  : 	}
; 226  : 
; 227  : 	if (((SetOption >> 2) & 0x03) != 1 && ((SetOption >> 2) & 0x03) != 2)

  000fd	0f b6 45 1c	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  00101	c1 f8 02	 sar	 eax, 2
  00104	83 e0 03	 and	 eax, 3
  00107	83 f8 01	 cmp	 eax, 1
  0010a	74 16		 je	 SHORT $LN13@Convert
  0010c	0f b6 45 1c	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  00110	c1 f8 02	 sar	 eax, 2
  00113	83 e0 03	 and	 eax, 3
  00116	83 f8 02	 cmp	 eax, 2
  00119	74 07		 je	 SHORT $LN13@Convert

; 228  : 	{	// SetOption == 1 A Option || SetOption == 2 B Option
; 229  : 		SOption = 0;

  0011b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _SOption$[ebp], 0
$LN13@Convert:

; 230  : 	}
; 231  : 
; 232  : 	if (gSetItemOption.IsSetItem(_type) && SetOption != 0xFF && SOption)

  00122	8b 45 f8	 mov	 eax, DWORD PTR __type$[ebp]
  00125	50		 push	 eax
  00126	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0012b	e8 00 00 00 00	 call	 ?IsSetItem@CSetItemOption@@QAEHH@Z ; CSetItemOption::IsSetItem
  00130	85 c0		 test	 eax, eax
  00132	74 45		 je	 SHORT $LN14@Convert
  00134	0f b6 45 1c	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  00138	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0013d	74 3a		 je	 SHORT $LN14@Convert
  0013f	83 7d ec 00	 cmp	 DWORD PTR _SOption$[ebp], 0
  00143	74 34		 je	 SHORT $LN14@Convert

; 233  : 	{	// 세트 아이템정보가 있을때만 적용한다
; 234  : 		m_SetOption = SetOption;

  00145	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00148	8a 4d 1c	 mov	 cl, BYTE PTR _SetOption$[ebp]
  0014b	88 88 92 00 00
	00		 mov	 BYTE PTR [eax+146], cl

; 235  : 
; 236  : 		if (m_SetOption)

  00151	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00154	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  0015b	85 c9		 test	 ecx, ecx
  0015d	74 18		 je	 SHORT $LN16@Convert

; 237  : 		{	// 세트옵션일때는 엑설런트 옵션은 무시..
; 238  : 			m_NewOption = 0;

  0015f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00162	c6 40 7b 00	 mov	 BYTE PTR [eax+123], 0

; 239  : 			Attribute2 = 0;

  00166	c6 45 18 00	 mov	 BYTE PTR _Attribute2$[ebp], 0

; 240  : 
; 241  : 			SOptionStatValue = (SetOption >> 2) & 0x03;		// 세트 옵션 스탯 값 (1:5, 2:10)

  0016a	0f b6 45 1c	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  0016e	c1 f8 02	 sar	 eax, 2
  00171	83 e0 03	 and	 eax, 3
  00174	89 45 e8	 mov	 DWORD PTR _SOptionStatValue$[ebp], eax
$LN16@Convert:

; 242  : 		}
; 243  : 	}

  00177	eb 0a		 jmp	 SHORT $LN15@Convert
$LN14@Convert:

; 244  : 	else
; 245  : 	{
; 246  : 		m_SetOption = 0;

  00179	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0017c	c6 80 92 00 00
	00 00		 mov	 BYTE PTR [eax+146], 0
$LN15@Convert:

; 247  : 	}
; 248  : #endif
; 249  : 
; 250  : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 251  : 	m_ItemOptionEx = ItemEffectEx;			// 추가옵션 정보. 380추가옵션 상위 1bit.
; 252  : #endif // ADD_380ITEM_NEWOPTION_20060711
; 253  : 
; 254  : #ifndef CHARACTERDB_SERVER
; 255  : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 256  : 	if (g_SocketOptionSystem.IsEnableSocketItem(this) == true)
; 257  : 	{
; 258  : 		if (SocketOption != NULL)
; 259  : 		{
; 260  : 			m_BonusSocketOption = SocketBonusOption;
; 261  : 
; 262  : 			for (int i = 0; i < MAX_SOCKET_SLOT; i++)
; 263  : 			{
; 264  : 				m_SocketOption[i] = SocketOption[i];
; 265  : 			}
; 266  : 		}
; 267  : 
; 268  : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_02_20080630
; 269  : 		if (g_SocketOptionSystem.IsSocketItem(this) == true)
; 270  : 		{
; 271  : 			m_ItemOptionEx = 0;
; 272  : 			m_SetOption = 0;
; 273  : 			Attribute2 = 0;
; 274  : 			m_NewOption = 0;
; 275  : 			m_JewelOfHarmonyOption = 0;
; 276  : 		}
; 277  : 		else
; 278  : 		{
; 279  : 			m_BonusSocketOption = 0;
; 280  : 		}
; 281  : #else
; 282  : 		// 소켓 아이템의 경우는 엑설런트, 세트, 380, 조화옵션이 붙지 않는다.
; 283  : 		m_ItemOptionEx = 0;
; 284  : 		m_SetOption = 0;
; 285  : 		Attribute2 = 0;
; 286  : 		m_NewOption = 0;
; 287  : 		m_JewelOfHarmonyOption = 0;
; 288  : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_02_20080630
; 289  : 	}
; 290  : 	else
; 291  : 	{
; 292  : 		m_BonusSocketOption = 0;
; 293  : 		for (int i = 0; i < MAX_SOCKET_SLOT; i++)
; 294  : 		{
; 295  : 			m_SocketOption[i] = SOCKETSLOT_NONE;
; 296  : 		}
; 297  : 	}
; 298  : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 299  : #endif
; 300  : 
; 301  : 	memset(m_SkillResistance, 0, sizeof(m_SkillResistance));

  00183	6a 07		 push	 7
  00185	6a 00		 push	 0
  00187	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018a	05 95 00 00 00	 add	 eax, 149		; 00000095H
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 _memset
  00195	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  : 
; 303  : 	if (_type == MAKE_ITEMNUM(0, 19) ||
; 304  : 		_type == MAKE_ITEMNUM(4, 18) ||

  00198	6a 13		 push	 19			; 00000013H
  0019a	6a 00		 push	 0
  0019c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001a1	83 c4 08	 add	 esp, 8
  001a4	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  001a7	74 22		 je	 SHORT $LN18@Convert
  001a9	6a 12		 push	 18			; 00000012H
  001ab	6a 04		 push	 4
  001ad	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001b2	83 c4 08	 add	 esp, 8
  001b5	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  001b8	74 11		 je	 SHORT $LN18@Convert
  001ba	6a 0a		 push	 10			; 0000000aH
  001bc	6a 05		 push	 5
  001be	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001c3	83 c4 08	 add	 esp, 8
  001c6	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  001c9	75 04		 jne	 SHORT $LN17@Convert
$LN18@Convert:

; 305  : 		_type == MAKE_ITEMNUM(5, 10)
; 306  : #ifdef ADD_WEAPON_OF_ARCHANGEL_SCEPTER_20050706
; 307  : 		|| _type == MAKE_ITEMNUM(2, 13)
; 308  : #endif
; 309  : 		)
; 310  : 
; 311  : 	{	// 절대 무기의 경우 무조건 엑설런트 처리를 안한다
; 312  : 		Attribute2 = 0;

  001cb	c6 45 18 00	 mov	 BYTE PTR _Attribute2$[ebp], 0
$LN17@Convert:

; 313  : 	}
; 314  : 
; 315  : 	int	iChaosItem = 0;

  001cf	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iChaosItem$[ebp], 0

; 316  : 	if (m_Type == MAKE_ITEMNUM(2, 6))		// 카오스드라곤도끼

  001d6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d9	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  001dd	6a 06		 push	 6
  001df	6a 02		 push	 2
  001e1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e6	83 c4 08	 add	 esp, 8
  001e9	3b f0		 cmp	 esi, eax
  001eb	75 09		 jne	 SHORT $LN19@Convert

; 317  : 
; 318  : 	{
; 319  : 		iChaosItem = 15;

  001ed	c7 45 e4 0f 00
	00 00		 mov	 DWORD PTR _iChaosItem$[ebp], 15 ; 0000000fH

; 320  : 	}

  001f4	eb 3e		 jmp	 SHORT $LN23@Convert
$LN19@Convert:

; 321  : 	else if (m_Type == MAKE_ITEMNUM(5, 7))	// 카오스번개지팡이

  001f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001f9	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  001fd	6a 07		 push	 7
  001ff	6a 05		 push	 5
  00201	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00206	83 c4 08	 add	 esp, 8
  00209	3b f0		 cmp	 esi, eax
  0020b	75 09		 jne	 SHORT $LN21@Convert

; 322  : 	{
; 323  : 		iChaosItem = 25;

  0020d	c7 45 e4 19 00
	00 00		 mov	 DWORD PTR _iChaosItem$[ebp], 25 ; 00000019H

; 324  : 	}

  00214	eb 1e		 jmp	 SHORT $LN23@Convert
$LN21@Convert:

; 325  : 	else if (m_Type == MAKE_ITEMNUM(4, 6))	// 카오스네이쳐보우

  00216	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00219	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0021d	6a 06		 push	 6
  0021f	6a 04		 push	 4
  00221	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00226	83 c4 08	 add	 esp, 8
  00229	3b f0		 cmp	 esi, eax
  0022b	75 07		 jne	 SHORT $LN23@Convert

; 326  : 	{
; 327  : 		iChaosItem = 30;

  0022d	c7 45 e4 1e 00
	00 00		 mov	 DWORD PTR _iChaosItem$[ebp], 30 ; 0000001eH
$LN23@Convert:

; 328  : 	}
; 329  : 
; 330  : 	if (ItemGetDurability(m_Type, 0, 0, 0))

  00234	6a 00		 push	 0
  00236	6a 00		 push	 0
  00238	6a 00		 push	 0
  0023a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00241	51		 push	 ecx
  00242	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00247	83 c4 10	 add	 esp, 16			; 00000010H
  0024a	85 c0		 test	 eax, eax
  0024c	74 39		 je	 SHORT $LN24@Convert

; 331  : 	{
; 332  : 		m_BaseDurability = (float)ItemGetDurability(m_Type, m_Level, Attribute2 & 0x7F, m_SetOption);

  0024e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00251	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00258	51		 push	 ecx
  00259	0f b6 55 18	 movzx	 edx, BYTE PTR _Attribute2$[ebp]
  0025d	83 e2 7f	 and	 edx, 127		; 0000007fH
  00260	52		 push	 edx
  00261	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00264	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00268	51		 push	 ecx
  00269	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0026c	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  00270	50		 push	 eax
  00271	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00276	83 c4 10	 add	 esp, 16			; 00000010H
  00279	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0027d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00280	f3 0f 11 41 2c	 movss	 DWORD PTR [ecx+44], xmm0

; 333  : 	}

  00285	eb 0b		 jmp	 SHORT $LN25@Convert
$LN24@Convert:

; 334  : 	else
; 335  : 	{
; 336  : 		m_BaseDurability = 0.f;

  00287	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0028a	0f 57 c0	 xorps	 xmm0, xmm0
  0028d	f3 0f 11 40 2c	 movss	 DWORD PTR [eax+44], xmm0
$LN25@Convert:

; 337  : 	}
; 338  : 	m_DurabilityState[0] = m_BaseDurability * 0.5f;

  00292	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00295	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  0029a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  002a2	b9 04 00 00 00	 mov	 ecx, 4
  002a7	6b d1 00	 imul	 edx, ecx, 0
  002aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002ad	f3 0f 11 44 10
	7c		 movss	 DWORD PTR [eax+edx+124], xmm0

; 339  : 	m_DurabilityState[1] = m_BaseDurability * 0.3f;

  002b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002b6	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  002bb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e99999a
  002c3	b9 04 00 00 00	 mov	 ecx, 4
  002c8	c1 e1 00	 shl	 ecx, 0
  002cb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002ce	f3 0f 11 44 0a
	7c		 movss	 DWORD PTR [edx+ecx+124], xmm0

; 340  : 	m_DurabilityState[2] = m_BaseDurability * 0.2f;

  002d4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002d7	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  002dc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e4ccccd
  002e4	b9 04 00 00 00	 mov	 ecx, 4
  002e9	d1 e1		 shl	 ecx, 1
  002eb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002ee	f3 0f 11 44 0a
	7c		 movss	 DWORD PTR [edx+ecx+124], xmm0

; 341  : 
; 342  : 
; 343  : 	m_Value = p->Value;

  002f4	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  002f7	0f b7 48 3c	 movzx	 ecx, WORD PTR [eax+60]
  002fb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002fe	89 4a 5c	 mov	 DWORD PTR [edx+92], ecx

; 344  : 	m_AttackSpeed = p->AttackSpeed;

  00301	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00304	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  00307	8a 51 28	 mov	 dl, BYTE PTR [ecx+40]
  0030a	88 50 0d	 mov	 BYTE PTR [eax+13], dl

; 345  : 	m_TwoHand = p->TwoHand;

  0030d	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00310	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00314	74 06		 je	 SHORT $LN206@Convert
  00316	c6 45 9f 01	 mov	 BYTE PTR tv236[ebp], 1
  0031a	eb 04		 jmp	 SHORT $LN207@Convert
$LN206@Convert:
  0031c	c6 45 9f 00	 mov	 BYTE PTR tv236[ebp], 0
$LN207@Convert:
  00320	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00323	8a 55 9f	 mov	 dl, BYTE PTR tv236[ebp]
  00326	88 51 0c	 mov	 BYTE PTR [ecx+12], dl

; 346  : 	m_DamageMin = p->DamageMin;

  00329	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0032c	66 0f b6 48 2a	 movzx	 cx, BYTE PTR [eax+42]
  00331	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00334	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 347  : 	m_DamageMax = p->DamageMax;

  00338	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0033b	66 0f b6 48 2b	 movzx	 cx, BYTE PTR [eax+43]
  00340	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00343	66 89 4a 12	 mov	 WORD PTR [edx+18], cx

; 348  : 	m_SuccessfulBlocking = p->SuccessfulBlocking;

  00347	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0034a	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0034d	8a 51 2c	 mov	 dl, BYTE PTR [ecx+44]
  00350	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 349  : 	m_Defense = p->Defense;

  00353	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00356	66 0f b6 48 2d	 movzx	 cx, BYTE PTR [eax+45]
  0035b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0035e	66 89 4a 16	 mov	 WORD PTR [edx+22], cx

; 350  : 	m_MagicDefense = p->MagicDefense;

  00362	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00365	66 0f b6 48 2e	 movzx	 cx, BYTE PTR [eax+46]
  0036a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0036d	66 89 4a 18	 mov	 WORD PTR [edx+24], cx

; 351  : 	m_WalkSpeed = p->WalkSpeed;

  00371	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00374	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  00377	8a 51 29	 mov	 dl, BYTE PTR [ecx+41]
  0037a	88 50 0e	 mov	 BYTE PTR [eax+14], dl

; 352  : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 책일경우 마력대신 저주적용
; 353  : 	// 지팡이류에서 왼쪽에 장착하면 책이다..
; 354  : 	if ((_type >> ITEM_BITSHIFT) == ITEM_STAFF / MAX_ITEM_INDEX
; 355  : 		&& p->ItemSlot == EQUIPMENT_WEAPON_LEFT
; 356  : 		)
; 357  : 	{
; 358  : 		m_Magic = 0;
; 359  : 		// 책이면 저주력력증가
; 360  : 		m_Curse = p->MagicPW;
; 361  : 
; 362  : 	}
; 363  : 	else
; 364  : 	{
; 365  : 		m_Magic = p->MagicPW;
; 366  : 		m_Curse = 0;
; 367  : 	}
; 368  : #else	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 369  : 	m_Magic = p->MagicPW;

  0037d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00380	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  00383	66 8b 51 50	 mov	 dx, WORD PTR [ecx+80]
  00387	66 89 50 20	 mov	 WORD PTR [eax+32], dx

; 370  : #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 371  : 
; 372  : #ifdef CHARACTERDB_SERVER
; 373  : 	m_Durability = p->Durability;
; 374  : #endif
; 375  : 
; 376  : 	m_serial = p->Serial;

  0038b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0038e	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  00391	8a 51 25	 mov	 dl, BYTE PTR [ecx+37]
  00394	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 377  : 
; 378  : #ifdef NEW_SKILL_FORSKYLAND
; 379  : 	m_QuestItem = p->QuestItem;		// 퀘스트용 아이템가?

  00397	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0039a	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0039d	8a 51 5c	 mov	 dl, BYTE PTR [ecx+92]
  003a0	88 90 91 00 00
	00		 mov	 BYTE PTR [eax+145], dl

; 380  : #endif	
; 381  : 
; 382  : #ifdef EXPAND_ITEMSCRIPT_01_20050808
; 383  : 	m_RequireLeaderShip = 0;

  003a6	33 c0		 xor	 eax, eax
  003a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ab	66 89 41 4c	 mov	 WORD PTR [ecx+76], ax

; 384  : #endif
; 385  : 
; 386  : #ifdef MODIFY_ITEMDURABILITY_BUGFIX_20080408	// 마법사의 반지, 문스톤 펜던트 제외한 모든 아이템의 경우 내구가 최대를 넘으면 최대값으로
; 387  : 	if (m_BaseDurability > 10
; 388  : 		&& _type != MAKE_ITEMNUM(13, 20)
; 389  : 		&& (_type < MAKE_ITEMNUM(14, 0)

  003af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003b2	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  003b7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@41200000
  003be	76 50		 jbe	 SHORT $LN28@Convert
  003c0	6a 14		 push	 20			; 00000014H
  003c2	6a 0d		 push	 13			; 0000000dH
  003c4	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003c9	83 c4 08	 add	 esp, 8
  003cc	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  003cf	74 3f		 je	 SHORT $LN28@Convert
  003d1	6a 00		 push	 0
  003d3	6a 0e		 push	 14			; 0000000eH
  003d5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003da	83 c4 08	 add	 esp, 8
  003dd	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  003e0	7c 11		 jl	 SHORT $LN27@Convert
  003e2	6a 08		 push	 8
  003e4	6a 0e		 push	 14			; 0000000eH
  003e6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003eb	83 c4 08	 add	 esp, 8
  003ee	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  003f1	7e 1d		 jle	 SHORT $LN28@Convert
$LN27@Convert:

; 390  : 			|| _type > MAKE_ITEMNUM(14, 8))
; 391  : #if GAME_VERSION >= G_V_S2_2
; 392  : 		&& (_type < MAKE_ITEMNUM(14, 35)
; 393  : 			|| _type > MAKE_ITEMNUM(14, 40))
; 394  : #endif
; 395  : 		)
; 396  : 	{
; 397  : 		if (m_Durability > m_BaseDurability)

  003f3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003f9	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  003fe	0f 2f 41 2c	 comiss	 xmm0, DWORD PTR [ecx+44]
  00402	76 0c		 jbe	 SHORT $LN28@Convert

; 398  : 		{
; 399  : 			m_Durability = m_BaseDurability;

  00404	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00407	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0040a	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0040d	89 50 24	 mov	 DWORD PTR [eax+36], edx
$LN28@Convert:

; 400  : 		}
; 401  : 	}
; 402  : #endif	// MODIFY_ITEMDURABILITY_BUGFIX_20080408
; 403  : 
; 404  : #ifdef MODIFY_CALC_DURABILITY_20060523 
; 405  : 	// 최대 내구도 보다 큰 경우 현재 내구도를 최대 값으로 설정
; 406  : 	// 기본 내구도가 10 이상인 경우만 처리. 물약을 비롯한 예외적인 아이템이 존재함.
; 407  : 	// 일반 무기류 아이템은 기본 10이 넘는다.
; 408  : 	if (m_BaseDurability > 10)
; 409  : 	{
; 410  : 		if (m_Durability > m_BaseDurability)
; 411  : 		{
; 412  : 			m_Durability = m_BaseDurability;
; 413  : 		}
; 414  : 	}
; 415  : #endif // MODIFY_CALC_DURABILITY_20060523
; 416  : 
; 417  : 	// 내구도 상태설정	
; 418  : 	if (m_Durability == 0.f)

  00410	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00413	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00418	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0041f	9f		 lahf
  00420	f6 c4 44	 test	 ah, 68			; 00000044H
  00423	7a 18		 jp	 SHORT $LN29@Convert

; 419  : 		m_CurrentDurabilityState = 1.f;

  00425	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00428	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00430	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0
  00438	e9 9a 00 00 00	 jmp	 $LN36@Convert
$LN29@Convert:

; 420  : 	else if (m_Durability < m_DurabilityState[2])

  0043d	b8 04 00 00 00	 mov	 eax, 4
  00442	d1 e0		 shl	 eax, 1
  00444	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00447	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0044a	f3 0f 10 44 01
	7c		 movss	 xmm0, DWORD PTR [ecx+eax+124]
  00450	0f 2f 42 24	 comiss	 xmm0, DWORD PTR [edx+36]
  00454	76 15		 jbe	 SHORT $LN31@Convert

; 421  : 		m_CurrentDurabilityState = 0.5f;

  00456	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00459	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00461	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0
  00469	eb 6c		 jmp	 SHORT $LN36@Convert
$LN31@Convert:

; 422  : 	else if (m_Durability < m_DurabilityState[1])

  0046b	b8 04 00 00 00	 mov	 eax, 4
  00470	c1 e0 00	 shl	 eax, 0
  00473	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00476	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00479	f3 0f 10 44 01
	7c		 movss	 xmm0, DWORD PTR [ecx+eax+124]
  0047f	0f 2f 42 24	 comiss	 xmm0, DWORD PTR [edx+36]
  00483	76 15		 jbe	 SHORT $LN33@Convert

; 423  : 		m_CurrentDurabilityState = 0.3f;

  00485	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00488	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e99999a
  00490	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0
  00498	eb 3d		 jmp	 SHORT $LN36@Convert
$LN33@Convert:

; 424  : 	else if (m_Durability < m_DurabilityState[0])

  0049a	b8 04 00 00 00	 mov	 eax, 4
  0049f	6b c8 00	 imul	 ecx, eax, 0
  004a2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004a8	f3 0f 10 44 0a
	7c		 movss	 xmm0, DWORD PTR [edx+ecx+124]
  004ae	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  004b2	76 15		 jbe	 SHORT $LN35@Convert

; 425  : 		m_CurrentDurabilityState = 0.2f;

  004b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004b7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  004bf	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0
  004c7	eb 0e		 jmp	 SHORT $LN36@Convert
$LN35@Convert:

; 426  : 	else m_CurrentDurabilityState = 0.f;

  004c9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004cc	0f 57 c0	 xorps	 xmm0, xmm0
  004cf	f3 0f 11 80 8c
	00 00 00	 movss	 DWORD PTR [eax+140], xmm0
$LN36@Convert:

; 427  : 
; 428  : 	memcpy(m_RequireClass, p->RequireClass, MAX_CLASSTYPE);

  004d7	6a 05		 push	 5
  004d9	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  004dc	83 c0 3e	 add	 eax, 62			; 0000003eH
  004df	50		 push	 eax
  004e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004e3	83 c1 50	 add	 ecx, 80			; 00000050H
  004e6	51		 push	 ecx
  004e7	e8 00 00 00 00	 call	 _memcpy
  004ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 429  : 	//memcpy(m_Resistance,   p->Resistance,   MAX_RESISTANCE);
; 430  : 
; 431  : 	for (int i = 0; i < MAX_RESISTANCE; i++)

  004ef	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  004f6	eb 09		 jmp	 SHORT $LN4@Convert
$LN2@Convert:
  004f8	8b 45 e0	 mov	 eax, DWORD PTR _i$1[ebp]
  004fb	83 c0 01	 add	 eax, 1
  004fe	89 45 e0	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Convert:
  00501	83 7d e0 07	 cmp	 DWORD PTR _i$1[ebp], 7
  00505	7d 1f		 jge	 SHORT $LN3@Convert

; 432  : 	{
; 433  : 		m_Resistance[i] = p->Resistance[i] * m_Level;

  00507	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0050a	03 45 e0	 add	 eax, DWORD PTR _i$1[ebp]
  0050d	0f b6 48 43	 movzx	 ecx, BYTE PTR [eax+67]
  00511	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00514	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00518	0f af c8	 imul	 ecx, eax
  0051b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0051e	03 55 e0	 add	 edx, DWORD PTR _i$1[ebp]
  00521	88 4a 55	 mov	 BYTE PTR [edx+85], cl

; 434  : 	}

  00524	eb d2		 jmp	 SHORT $LN2@Convert
$LN3@Convert:

; 435  : 
; 436  : 
; 437  : 	//-------------------------------------------------------------------------
; 438  : 	//
; 439  : 	// ★ 아이템 사용가능 스탯 요구치 기본 설정
; 440  : 	//		- 아이템 추가 옵션에 따른 요구치 증가는 아래부분에서 처리.
; 441  : 	//
; 442  : 	//-------------------------------------------------------------------------
; 443  : 	ItemLevel = p->Level;

  00526	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00529	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  0052d	89 4d f4	 mov	 DWORD PTR _ItemLevel$[ebp], ecx

; 444  : 
; 445  : 	// 1. > 엑설런트 아이템 확인
; 446  : 	if ((Attribute2 & 63) > 0)

  00530	0f b6 45 18	 movzx	 eax, BYTE PTR _Attribute2$[ebp]
  00534	83 e0 3f	 and	 eax, 63			; 0000003fH
  00537	7e 0f		 jle	 SHORT $LN37@Convert

; 447  : 		ItemLevel = p->Level + 25;

  00539	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0053c	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  00540	83 c1 19	 add	 ecx, 25			; 00000019H
  00543	89 4d f4	 mov	 DWORD PTR _ItemLevel$[ebp], ecx
  00546	eb 1b		 jmp	 SHORT $LN39@Convert
$LN37@Convert:

; 448  : 
; 449  : 	// 2. > 세트 아이템 확인
; 450  : 	else if (m_SetOption)

  00548	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0054b	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00552	85 c9		 test	 ecx, ecx
  00554	74 0d		 je	 SHORT $LN39@Convert

; 451  : 	{
; 452  : 		ItemLevel = p->Level + 25;

  00556	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00559	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  0055d	83 c1 19	 add	 ecx, 25			; 00000019H
  00560	89 4d f4	 mov	 DWORD PTR _ItemLevel$[ebp], ecx
$LN39@Convert:

; 453  : 	}
; 454  : 
; 455  : 	// 3. > 일반 / 엑설런트 / 세트 아이템 여부에 따라 요구치 설정.
; 456  : 	if (p->RequireStrength)

  00563	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00566	0f b7 48 34	 movzx	 ecx, WORD PTR [eax+52]
  0056a	85 c9		 test	 ecx, ecx
  0056c	74 2e		 je	 SHORT $LN40@Convert

; 457  : 		m_RequireStrength = 20 + p->RequireStrength *(ItemLevel + m_Level * 3) * 3 / 100;

  0056e	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00571	0f b7 48 34	 movzx	 ecx, WORD PTR [eax+52]
  00575	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00578	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  0057c	6b d0 03	 imul	 edx, eax, 3
  0057f	03 55 f4	 add	 edx, DWORD PTR _ItemLevel$[ebp]
  00582	0f af ca	 imul	 ecx, edx
  00585	6b c1 03	 imul	 eax, ecx, 3
  00588	99		 cdq
  00589	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0058e	f7 f9		 idiv	 ecx
  00590	83 c0 14	 add	 eax, 20			; 00000014H
  00593	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00596	66 89 42 42	 mov	 WORD PTR [edx+66], ax
  0059a	eb 09		 jmp	 SHORT $LN41@Convert
$LN40@Convert:

; 458  : 	else
; 459  : 		m_RequireStrength = 0;

  0059c	33 c0		 xor	 eax, eax
  0059e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005a1	66 89 41 42	 mov	 WORD PTR [ecx+66], ax
$LN41@Convert:

; 460  : 
; 461  : 	if (p->RequireDexterity)

  005a5	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  005a8	0f b7 48 36	 movzx	 ecx, WORD PTR [eax+54]
  005ac	85 c9		 test	 ecx, ecx
  005ae	74 2e		 je	 SHORT $LN42@Convert

; 462  : 		m_RequireDexterity = 20 + p->RequireDexterity*(ItemLevel + m_Level * 3) * 3 / 100;

  005b0	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  005b3	0f b7 48 36	 movzx	 ecx, WORD PTR [eax+54]
  005b7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005ba	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  005be	6b d0 03	 imul	 edx, eax, 3
  005c1	03 55 f4	 add	 edx, DWORD PTR _ItemLevel$[ebp]
  005c4	0f af ca	 imul	 ecx, edx
  005c7	6b c1 03	 imul	 eax, ecx, 3
  005ca	99		 cdq
  005cb	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  005d0	f7 f9		 idiv	 ecx
  005d2	83 c0 14	 add	 eax, 20			; 00000014H
  005d5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005d8	66 89 42 44	 mov	 WORD PTR [edx+68], ax
  005dc	eb 09		 jmp	 SHORT $LN43@Convert
$LN42@Convert:

; 463  : 	else
; 464  : 		m_RequireDexterity = 0;

  005de	33 c0		 xor	 eax, eax
  005e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005e3	66 89 41 44	 mov	 WORD PTR [ecx+68], ax
$LN43@Convert:

; 465  : 
; 466  : 	if (p->RequireEnergy)

  005e7	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  005ea	0f b7 48 38	 movzx	 ecx, WORD PTR [eax+56]
  005ee	85 c9		 test	 ecx, ecx
  005f0	74 2e		 je	 SHORT $LN44@Convert

; 467  : 		m_RequireEnergy = 20 + p->RequireEnergy   *(ItemLevel + m_Level * 3) * 4 / 100;

  005f2	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  005f5	0f b7 40 38	 movzx	 eax, WORD PTR [eax+56]
  005f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005fc	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00600	6b ca 03	 imul	 ecx, edx, 3
  00603	03 4d f4	 add	 ecx, DWORD PTR _ItemLevel$[ebp]
  00606	0f af c1	 imul	 eax, ecx
  00609	c1 e0 02	 shl	 eax, 2
  0060c	99		 cdq
  0060d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00612	f7 f9		 idiv	 ecx
  00614	83 c0 14	 add	 eax, 20			; 00000014H
  00617	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0061a	66 89 42 46	 mov	 WORD PTR [edx+70], ax
  0061e	eb 09		 jmp	 SHORT $LN45@Convert
$LN44@Convert:

; 468  : 	else
; 469  : 		m_RequireEnergy = 0;

  00620	33 c0		 xor	 eax, eax
  00622	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00625	66 89 41 46	 mov	 WORD PTR [ecx+70], ax
$LN45@Convert:

; 470  : 
; 471  : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 신규캐릭터 책(서)에 대한 요구에너지 계산
; 472  : 	if (p->RequireEnergy)
; 473  : 	{
; 474  : 		if ((_type >> ITEM_BITSHIFT) == ITEM_STAFF / MAX_ITEM_INDEX
; 475  : 			&& p->ItemSlot == EQUIPMENT_WEAPON_LEFT
; 476  : 			)
; 477  : 		{
; 478  : 			m_RequireEnergy = 20 + p->RequireEnergy   *(ItemLevel + m_Level * 1) * 3 / 100;
; 479  : 		}
; 480  : 	}
; 481  : 	else
; 482  : 	{
; 483  : 		m_RequireEnergy = 0;
; 484  : 	}
; 485  : #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 486  : 
; 487  : #ifdef EXPAND_ITEMSCRIPT_01_20050808
; 488  : 	if (_type >= ITEM_SWORD && _type < ITEM_WING)

  00629	83 7d f8 00	 cmp	 DWORD PTR __type$[ebp], 0
  0062d	0f 8c 8f 00 00
	00		 jl	 $LN50@Convert
  00633	81 7d f8 80 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 384 ; 00000180H
  0063a	0f 8d 82 00 00
	00		 jge	 $LN50@Convert

; 489  : 	{
; 490  : 		if (p->RequireVitality)

  00640	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00643	0f b7 48 4a	 movzx	 ecx, WORD PTR [eax+74]
  00647	85 c9		 test	 ecx, ecx
  00649	74 2e		 je	 SHORT $LN47@Convert

; 491  : 			m_RequireVitality = 20 + p->RequireVitality *(ItemLevel + m_Level * 3) * 3 / 100;

  0064b	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0064e	0f b7 48 4a	 movzx	 ecx, WORD PTR [eax+74]
  00652	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00655	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00659	6b d0 03	 imul	 edx, eax, 3
  0065c	03 55 f4	 add	 edx, DWORD PTR _ItemLevel$[ebp]
  0065f	0f af ca	 imul	 ecx, edx
  00662	6b c1 03	 imul	 eax, ecx, 3
  00665	99		 cdq
  00666	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0066b	f7 f9		 idiv	 ecx
  0066d	83 c0 14	 add	 eax, 20			; 00000014H
  00670	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00673	66 89 42 4a	 mov	 WORD PTR [edx+74], ax
  00677	eb 09		 jmp	 SHORT $LN48@Convert
$LN47@Convert:

; 492  : 		else
; 493  : 			m_RequireVitality = 0;

  00679	33 c0		 xor	 eax, eax
  0067b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0067e	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax
$LN48@Convert:

; 494  : 
; 495  : 		if (p->RequireLeadership)

  00682	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00685	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00689	74 2e		 je	 SHORT $LN49@Convert

; 496  : 			m_RequireLeaderShip = 20 + p->RequireVitality *(ItemLevel + m_Level * 3) * 3 / 100;

  0068b	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0068e	0f b7 48 4a	 movzx	 ecx, WORD PTR [eax+74]
  00692	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00695	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00699	6b d0 03	 imul	 edx, eax, 3
  0069c	03 55 f4	 add	 edx, DWORD PTR _ItemLevel$[ebp]
  0069f	0f af ca	 imul	 ecx, edx
  006a2	6b c1 03	 imul	 eax, ecx, 3
  006a5	99		 cdq
  006a6	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  006ab	f7 f9		 idiv	 ecx
  006ad	83 c0 14	 add	 eax, 20			; 00000014H
  006b0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  006b3	66 89 42 4c	 mov	 WORD PTR [edx+76], ax
  006b7	eb 09		 jmp	 SHORT $LN50@Convert
$LN49@Convert:

; 497  : 		else
; 498  : 			m_RequireLeaderShip = 0;

  006b9	33 c0		 xor	 eax, eax
  006bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006be	66 89 41 4c	 mov	 WORD PTR [ecx+76], ax
$LN50@Convert:

; 499  : 	}
; 500  : #endif
; 501  : 
; 502  : 	// 4. > 다크 스피릿 요구 통솔 예외 처리
; 503  : #ifdef EXPAND_ITEMSCRIPT_01_20050808
; 504  : 	// 다크스피릿만 코드에 박혀 있다.
; 505  : #ifdef MODIFY_SETITEM_LEADERSHIP_BUGFIX
; 506  : 	if (_type == MAKE_ITEMNUM(13, 5)) {

  006c2	6a 05		 push	 5
  006c4	6a 0d		 push	 13			; 0000000dH
  006c6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  006cb	83 c4 08	 add	 esp, 8
  006ce	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  006d1	75 2d		 jne	 SHORT $LN51@Convert

; 507  : 		// gObjValidItem 에서 통솔요구치 체크 버그 수정
; 508  : 		// 다크스피릿은 item(kor).txt 에 요구수치가 없음으로 공식에 따라 직접 처리한다.
; 509  : 		m_RequireLeaderShip = 185 + (m_PetItem_Level * 15);

  006d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006d6	6b 88 a0 00 00
	00 0f		 imul	 ecx, DWORD PTR [eax+160], 15
  006dd	81 c1 b9 00 00
	00		 add	 ecx, 185		; 000000b9H
  006e3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  006e6	66 89 4a 4c	 mov	 WORD PTR [edx+76], cx

; 510  : 		p->RequireLeadership = 185 + (m_PetItem_Level * 15);

  006ea	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006ed	6b 88 a0 00 00
	00 0f		 imul	 ecx, DWORD PTR [eax+160], 15
  006f4	81 c1 b9 00 00
	00		 add	 ecx, 185		; 000000b9H
  006fa	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  006fd	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
$LN51@Convert:

; 511  : 	}
; 512  : #else
; 513  : 	if (_type == MAKE_ITEMNUM(13, 5))
; 514  : 		m_RequireLeaderShip = 185 + (m_PetItem_Level * 15);
; 515  : #endif // MODIFY_SETITEM_LEADERSHIP_BUGFIX
; 516  : 
; 517  : 
; 518  : #else
; 519  : #ifdef DARKLORD_WORK
; 520  : 	if (_type == MAKE_ITEMNUM(13, 5)) // 다크스피릿만 요구 통솔이 필요 하다
; 521  : 		m_RequireLeaderShip = 185 + (m_PetItem_Level * 15);
; 522  : 	else
; 523  : 		m_RequireLeaderShip = 0;
; 524  : #endif
; 525  : #endif // EXPAND_ITEMSCRIPT_01_20050808
; 526  : 
; 527  : #ifndef CHARACTERDB_SERVER
; 528  : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 529  : 	// 조화의 보석 강화 아이템 옵션 : 필요힘/민첩 감소
; 530  : 	if (g_kJewelOfHarmonySystem.IsActive(this) == TRUE)
; 531  : 	{
; 532  : 		BYTE btOption = g_kJewelOfHarmonySystem.GetItemStrengthenOption(this);
; 533  : #ifdef MODIFY_STAFF_DECREASE_DEXTERITY_BUGFIX_20080729
; 534  : 		int iItemType = g_kJewelOfHarmonySystem._GetItemType(this);
; 535  : 
; 536  : 		if (iItemType == JEWELOFHARMONY_ITEM_TYPE_WEAPON)
; 537  : 		{
; 538  : 			if (btOption == AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_STR)
; 539  : 				m_HJOpStrength = g_kJewelOfHarmonySystem.GetItemEffectValue(this, AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_STR);
; 540  : 			else if (btOption == AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_DEX)
; 541  : 				m_HJOpDexterity = g_kJewelOfHarmonySystem.GetItemEffectValue(this, AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_DEX);
; 542  : 		}
; 543  : 		else if (iItemType == JEWELOFHARMONY_ITEM_TYPE_STAFF)
; 544  : 		{
; 545  : 			if (btOption == AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_STR)
; 546  : 				m_HJOpStrength = g_kJewelOfHarmonySystem.GetItemEffectValue(this, AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_STR);
; 547  : 			else if (btOption == AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_DEX)
; 548  : 				m_HJOpDexterity = g_kJewelOfHarmonySystem.GetItemEffectValue(this, AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_DEX);
; 549  : 		}
; 550  : #else
; 551  : 		if (btOption == AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_STR)
; 552  : 			m_HJOpStrength = g_kJewelOfHarmonySystem.GetItemEffectValue(this, AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_STR);
; 553  : 		else if (btOption == AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_STR)
; 554  : 			m_HJOpStrength = g_kJewelOfHarmonySystem.GetItemEffectValue(this, AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_STR);
; 555  : 		else if (btOption == AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_DEX)
; 556  : 			m_HJOpDexterity = g_kJewelOfHarmonySystem.GetItemEffectValue(this, AT_JEWELOFHARMONY_WEAPON_DECREASE_REQUIRE_DEX);
; 557  : 		else if (btOption == AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_DEX)
; 558  : 			m_HJOpDexterity = g_kJewelOfHarmonySystem.GetItemEffectValue(this, AT_JEWELOFHARMONY_STAFF_DECREASE_REQUIRE_DEX);
; 559  : #endif // MODIFY_STAFF_DECREASE_DEXTERITY_BUGFIX_20080729
; 560  : 	}
; 561  : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 562  : 	else
; 563  : 	{
; 564  : 		m_HJOpStrength = 0;
; 565  : 		m_HJOpDexterity = 0;
; 566  : 	}
; 567  : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 568  : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 569  : 
; 570  : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_03_20080704
; 571  : 	g_SocketOptionSystem.SetRequireStatOption(this);
; 572  : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_03_20080704
; 573  : #endif
; 574  : 	// 5. > 요구 레벨 처리
; 575  : 	if (p->RequireLevel)

  00700	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00703	0f b7 48 3a	 movzx	 ecx, WORD PTR [eax+58]
  00707	85 c9		 test	 ecx, ecx
  00709	0f 84 9c 00 00
	00		 je	 $LN52@Convert

; 576  : 	{
; 577  : 
; 578  : #ifdef DARKLORD_WORK
; 579  : 		// 다크호스
; 580  : 		if (_type == MAKE_ITEMNUM(13, 4))

  0070f	6a 04		 push	 4
  00711	6a 0d		 push	 13			; 0000000dH
  00713	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00718	83 c4 08	 add	 esp, 8
  0071b	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  0071e	75 19		 jne	 SHORT $LN54@Convert

; 581  : 		{
; 582  : 			m_RequireLevel = 218 + m_PetItem_Level * 2;

  00720	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00723	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00729	8d 94 09 da 00
	00 00		 lea	 edx, DWORD PTR [ecx+ecx+218]
  00730	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00733	66 89 50 48	 mov	 WORD PTR [eax+72], dx

; 583  : 		}

  00737	eb 70		 jmp	 SHORT $LN59@Convert
$LN54@Convert:

; 584  : 		else
; 585  : #endif
; 586  : #ifdef ADD_THIRD_WING_20070525	// 3차 전직날개는 날개레벨에 상관없이 400으로 설정
; 587  : 			if (_type >= ITEM_WING + 36 && _type <= ITEM_WING + 40)
; 588  : 			{
; 589  : 				m_RequireLevel = p->RequireLevel;
; 590  : 			}
; 591  : 			else
; 592  : #endif
; 593  : 				// 추가 날개
; 594  : 				if (_type >= ITEM_WING + 3 && _type <= ITEM_WING + 6)

  00739	81 7d f8 83 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 387 ; 00000183H
  00740	7c 25		 jl	 SHORT $LN56@Convert
  00742	81 7d f8 86 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 390 ; 00000186H
  00749	7f 1c		 jg	 SHORT $LN56@Convert

; 595  : 				{
; 596  : 					m_RequireLevel = p->RequireLevel + m_Level * 5;

  0074b	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  0074e	0f b7 48 3a	 movzx	 ecx, WORD PTR [eax+58]
  00752	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00755	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00759	6b d0 05	 imul	 edx, eax, 5
  0075c	03 ca		 add	 ecx, edx
  0075e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00761	66 89 48 48	 mov	 WORD PTR [eax+72], cx

; 597  : 				}

  00765	eb 42		 jmp	 SHORT $LN59@Convert
$LN56@Convert:

; 598  : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 절망의 날개, 차원의 날개 레벨설정
; 599  : 				else if (_type == ITEM_WING + 42) // 절망의 날개
; 600  : 				{
; 601  : 					m_RequireLevel = p->RequireLevel + m_Level * 5;
; 602  : 				}
; 603  : 				else if (_type == ITEM_WING + 43) // 차원의 날개
; 604  : 				{
; 605  : 					m_RequireLevel = p->RequireLevel;
; 606  : 				}
; 607  : #endif
; 608  : #ifdef ADD_CHECKING_LEVEL_TO_LEARN_MAGIC_20041115
; 609  : 		// 구슬 아이템 쪽만..
; 610  : 				else
; 611  : 					if ((_type >= MAKE_ITEMNUM(12, 7)) && (_type <= MAKE_ITEMNUM(12, 24)))
; 612  : 					{
; 613  : 
; 614  : 						m_RequireLevel = p->RequireLevel;
; 615  : 					}
; 616  : #endif
; 617  : #ifdef EXPAND_ITEMSCRIPT_01_20050808
; 618  : 		// 무기, 방어구
; 619  : 					else
; 620  : 						if (_type >= ITEM_SWORD && _type < ITEM_WING)

  00767	83 7d f8 00	 cmp	 DWORD PTR __type$[ebp], 0
  0076b	7c 24		 jl	 SHORT $LN58@Convert
  0076d	81 7d f8 80 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 384 ; 00000180H
  00774	7d 1b		 jge	 SHORT $LN58@Convert

; 621  : 						{
; 622  : 							if (p->RequireLevel)

  00776	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00779	0f b7 48 3a	 movzx	 ecx, WORD PTR [eax+58]
  0077d	85 c9		 test	 ecx, ecx
  0077f	74 0e		 je	 SHORT $LN60@Convert

; 623  : 							{
; 624  : 								//m_RequireLevel = 10+p->RequireLevel + (ItemLevel+m_Level*4)*5/100;
; 625  : 								//m_RequireLevel = 10+p->RequireLevel + (p->Level+m_Level*4)*5/100;
; 626  : 
; 627  : 								// 레벨 제한의 경우 일반/세트/액설 모두 동일
; 628  : 								m_RequireLevel = p->RequireLevel;

  00781	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00784	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  00787	66 8b 51 3a	 mov	 dx, WORD PTR [ecx+58]
  0078b	66 89 50 48	 mov	 WORD PTR [eax+72], dx
$LN60@Convert:

; 629  : 							}
; 630  : 						}

  0078f	eb 18		 jmp	 SHORT $LN59@Convert
$LN58@Convert:

; 631  : #endif
; 632  : 		// 반지,목걸이;
; 633  : 						else
; 634  : 						{
; 635  : 							m_RequireLevel = p->RequireLevel + m_Level * 4;

  00791	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00794	0f b7 48 3a	 movzx	 ecx, WORD PTR [eax+58]
  00798	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0079b	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  0079f	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  007a2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  007a5	66 89 4a 48	 mov	 WORD PTR [edx+72], cx
$LN59@Convert:

; 636  : 						}
; 637  : 
; 638  : 	}

  007a9	eb 09		 jmp	 SHORT $LN53@Convert
$LN52@Convert:

; 639  : 	else
; 640  : 		m_RequireLevel = 0;

  007ab	33 c0		 xor	 eax, eax
  007ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007b0	66 89 41 48	 mov	 WORD PTR [ecx+72], ax
$LN53@Convert:

; 641  : 
; 642  : 
; 643  : 	if (m_Type == ITEM_HELPER + 10)//변신반지

  007b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007b7	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  007bb	81 f9 aa 01 00
	00		 cmp	 ecx, 426		; 000001aaH
  007c1	75 20		 jne	 SHORT $LN63@Convert

; 644  : 	{
; 645  : 		if (ItemLevel <= 2)

  007c3	83 7d f4 02	 cmp	 DWORD PTR _ItemLevel$[ebp], 2
  007c7	7f 0e		 jg	 SHORT $LN62@Convert

; 646  : 			m_RequireLevel = 20;

  007c9	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  007ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007d1	66 89 41 48	 mov	 WORD PTR [ecx+72], ax
  007d5	eb 0c		 jmp	 SHORT $LN63@Convert
$LN62@Convert:

; 647  : 		else
; 648  : 			m_RequireLevel = 50;

  007d7	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  007dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007df	66 89 41 48	 mov	 WORD PTR [ecx+72], ax
$LN63@Convert:

; 649  : 	}
; 650  : 
; 651  : 	if ((Attribute2 & 63) > 0)		// 엑셀런트 옵션이 하나라도 붙어 있다면

  007e3	0f b6 45 18	 movzx	 eax, BYTE PTR _Attribute2$[ebp]
  007e7	83 e0 3f	 and	 eax, 63			; 0000003fH
  007ea	7e 2b		 jle	 SHORT $LN66@Convert

; 652  : 	{
; 653  : 		if (m_RequireLevel > 0)

  007ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007ef	0f b7 48 48	 movzx	 ecx, WORD PTR [eax+72]
  007f3	85 c9		 test	 ecx, ecx
  007f5	7e 20		 jle	 SHORT $LN66@Convert

; 654  : 		{
; 655  : 
; 656  : #ifdef EXPAND_ITEMSCRIPT_01_20050808
; 657  : 			if (_type < ITEM_SWORD || _type >= ITEM_WING)

  007f7	83 7d f8 00	 cmp	 DWORD PTR __type$[ebp], 0
  007fb	7c 09		 jl	 SHORT $LN67@Convert
  007fd	81 7d f8 80 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 384 ; 00000180H
  00804	7c 11		 jl	 SHORT $LN66@Convert
$LN67@Convert:

; 658  : 			{
; 659  : 				// 레벨 제한의 경우 일반/세트/액설 모두 동일
; 660  : 				m_RequireLevel += 20;

  00806	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00809	0f b7 48 48	 movzx	 ecx, WORD PTR [eax+72]
  0080d	83 c1 14	 add	 ecx, 20			; 00000014H
  00810	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00813	66 89 4a 48	 mov	 WORD PTR [edx+72], cx
$LN66@Convert:

; 661  : 			}
; 662  : #else
; 663  : 			m_RequireLevel += 20;
; 664  : #endif
; 665  : 
; 666  : 		}
; 667  : 	}
; 668  : 	//-------------------------------------------------------------------------
; 669  : 
; 670  : 
; 671  : 
; 672  : 	//-------------------------------------------------------------------------
; 673  : 	//
; 674  : 	// ★ 아이템 기본 수치 설정
; 675  : 	//
; 676  : 	//	세트 아이템의 경우 
; 677  : 	//	- 요구능력치 계산 시 + 25 적용
; 678  : 	//	- 수치 계산 시 + 30 적용
; 679  : 	//
; 680  : 	//-------------------------------------------------------------------------
; 681  : 
; 682  : 	if (m_SetOption)

  00817	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0081a	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00821	85 c9		 test	 ecx, ecx
  00823	74 0d		 je	 SHORT $LN68@Convert

; 683  : 	{
; 684  : 		ItemLevel = p->Level + 30;

  00825	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00828	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  0082c	83 c1 1e	 add	 ecx, 30			; 0000001eH
  0082f	89 4d f4	 mov	 DWORD PTR _ItemLevel$[ebp], ecx
$LN68@Convert:

; 685  : 	}
; 686  : 
; 687  : #ifdef DARKLORD_WORK
; 688  : 	m_Leadership = 0;

  00832	33 c0		 xor	 eax, eax
  00834	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00837	66 89 41 4e	 mov	 WORD PTR [ecx+78], ax

; 689  : #endif
; 690  : 
; 691  : 	if (m_DamageMax > 0)

  0083b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0083e	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00842	85 c9		 test	 ecx, ecx
  00844	0f 8e fe 00 00
	00		 jle	 $LN76@Convert

; 692  : 	{
; 693  : 		if (m_SetOption && ItemLevel)

  0084a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0084d	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00854	85 c9		 test	 ecx, ecx
  00856	74 4b		 je	 SHORT $LN70@Convert
  00858	83 7d f4 00	 cmp	 DWORD PTR _ItemLevel$[ebp], 0
  0085c	74 45		 je	 SHORT $LN70@Convert

; 694  : 		{	// 세트 아이템 공격력
; 695  : 			m_DamageMax += m_DamageMin * 25 / p->Level + 5;

  0085e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00861	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00865	6b c1 19	 imul	 eax, ecx, 25
  00868	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  0086b	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  0086f	99		 cdq
  00870	f7 f9		 idiv	 ecx
  00872	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00875	0f b7 4a 12	 movzx	 ecx, WORD PTR [edx+18]
  00879	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  0087d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00880	66 89 50 12	 mov	 WORD PTR [eax+18], dx

; 696  : 			m_DamageMax += ItemLevel / 40 + 5;

  00884	8b 45 f4	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  00887	99		 cdq
  00888	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0088d	f7 f9		 idiv	 ecx
  0088f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00892	0f b7 4a 12	 movzx	 ecx, WORD PTR [edx+18]
  00896	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  0089a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0089d	66 89 50 12	 mov	 WORD PTR [eax+18], dx

; 697  : 		}

  008a1	eb 53		 jmp	 SHORT $LN75@Convert
$LN70@Convert:

; 698  : 		else
; 699  : 			if ((Attribute2 & 63) > 0)

  008a3	0f b6 45 18	 movzx	 eax, BYTE PTR _Attribute2$[ebp]
  008a7	83 e0 3f	 and	 eax, 63			; 0000003fH
  008aa	7e 4a		 jle	 SHORT $LN75@Convert

; 700  : 			{
; 701  : 				if (iChaosItem)

  008ac	83 7d e4 00	 cmp	 DWORD PTR _iChaosItem$[ebp], 0
  008b0	74 13		 je	 SHORT $LN73@Convert

; 702  : 				{
; 703  : 					m_DamageMax += iChaosItem;

  008b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008b5	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  008b9	03 4d e4	 add	 ecx, DWORD PTR _iChaosItem$[ebp]
  008bc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008bf	66 89 4a 12	 mov	 WORD PTR [edx+18], cx

; 704  : 				}

  008c3	eb 31		 jmp	 SHORT $LN75@Convert
$LN73@Convert:

; 705  : 				else if (p->Level)

  008c5	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  008c8	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  008cc	85 c9		 test	 ecx, ecx
  008ce	74 26		 je	 SHORT $LN75@Convert

; 706  : 				{
; 707  : 					m_DamageMax += m_DamageMin * 25 / p->Level + 5;

  008d0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008d3	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  008d7	6b c1 19	 imul	 eax, ecx, 25
  008da	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  008dd	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  008e1	99		 cdq
  008e2	f7 f9		 idiv	 ecx
  008e4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008e7	0f b7 4a 12	 movzx	 ecx, WORD PTR [edx+18]
  008eb	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  008ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008f2	66 89 50 12	 mov	 WORD PTR [eax+18], dx
$LN75@Convert:

; 708  : 				}
; 709  : 			}
; 710  : 
; 711  : 		m_DamageMax += m_Level * 3;

  008f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008f9	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  008fd	6b d1 03	 imul	 edx, ecx, 3
  00900	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00903	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00907	03 ca		 add	 ecx, edx
  00909	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0090c	66 89 4a 12	 mov	 WORD PTR [edx+18], cx

; 712  : 
; 713  : 		if (m_Level >= 10)

  00910	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00913	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00917	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0091a	7c 2c		 jl	 SHORT $LN76@Convert

; 714  : 		{	// +10 이상의 공격력 +
; 715  : #ifdef ITEM_12_13_20040401
; 716  : 			m_DamageMax += (m_Level - 9)*(m_Level - 9 + 1) / 2;

  0091c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0091f	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00923	83 e8 09	 sub	 eax, 9
  00926	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00929	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  0092d	83 ea 08	 sub	 edx, 8
  00930	0f af c2	 imul	 eax, edx
  00933	99		 cdq
  00934	2b c2		 sub	 eax, edx
  00936	d1 f8		 sar	 eax, 1
  00938	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0093b	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  0093f	03 d0		 add	 edx, eax
  00941	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00944	66 89 50 12	 mov	 WORD PTR [eax+18], dx
$LN76@Convert:

; 717  : #else
; 718  : 			m_DamageMax += (m_Level - 10) * 2 + 1;
; 719  : #endif
; 720  : 		}
; 721  : 	}
; 722  : 
; 723  : 	if (m_DamageMin > 0)

  00948	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0094b	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  0094f	85 c9		 test	 ecx, ecx
  00951	0f 8e fe 00 00
	00		 jle	 $LN84@Convert

; 724  : 	{
; 725  : 		if (m_SetOption && ItemLevel)

  00957	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0095a	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00961	85 c9		 test	 ecx, ecx
  00963	74 4b		 je	 SHORT $LN78@Convert
  00965	83 7d f4 00	 cmp	 DWORD PTR _ItemLevel$[ebp], 0
  00969	74 45		 je	 SHORT $LN78@Convert

; 726  : 		{
; 727  : 			m_DamageMin += m_DamageMin * 25 / p->Level + 5;

  0096b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0096e	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00972	6b c1 19	 imul	 eax, ecx, 25
  00975	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00978	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  0097c	99		 cdq
  0097d	f7 f9		 idiv	 ecx
  0097f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00982	0f b7 4a 10	 movzx	 ecx, WORD PTR [edx+16]
  00986	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  0098a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0098d	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 728  : 			m_DamageMin += ItemLevel / 40 + 5;

  00991	8b 45 f4	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  00994	99		 cdq
  00995	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0099a	f7 f9		 idiv	 ecx
  0099c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0099f	0f b7 4a 10	 movzx	 ecx, WORD PTR [edx+16]
  009a3	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  009a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009aa	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 729  : 		}

  009ae	eb 53		 jmp	 SHORT $LN83@Convert
$LN78@Convert:

; 730  : 		else
; 731  : 			if ((Attribute2 & 63) > 0)

  009b0	0f b6 45 18	 movzx	 eax, BYTE PTR _Attribute2$[ebp]
  009b4	83 e0 3f	 and	 eax, 63			; 0000003fH
  009b7	7e 4a		 jle	 SHORT $LN83@Convert

; 732  : 			{
; 733  : 				if (iChaosItem)

  009b9	83 7d e4 00	 cmp	 DWORD PTR _iChaosItem$[ebp], 0
  009bd	74 13		 je	 SHORT $LN81@Convert

; 734  : 				{
; 735  : 					m_DamageMin += iChaosItem;

  009bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009c2	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  009c6	03 4d e4	 add	 ecx, DWORD PTR _iChaosItem$[ebp]
  009c9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009cc	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 736  : 				}

  009d0	eb 31		 jmp	 SHORT $LN83@Convert
$LN81@Convert:

; 737  : 				else if (p->Level)

  009d2	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  009d5	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  009d9	85 c9		 test	 ecx, ecx
  009db	74 26		 je	 SHORT $LN83@Convert

; 738  : 					m_DamageMin += m_DamageMin * 25 / p->Level + 5;

  009dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009e0	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  009e4	6b c1 19	 imul	 eax, ecx, 25
  009e7	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  009ea	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  009ee	99		 cdq
  009ef	f7 f9		 idiv	 ecx
  009f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  009f4	0f b7 4a 10	 movzx	 ecx, WORD PTR [edx+16]
  009f8	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  009fc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009ff	66 89 50 10	 mov	 WORD PTR [eax+16], dx
$LN83@Convert:

; 739  : 			}
; 740  : 		m_DamageMin += m_Level * 3;

  00a03	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a06	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00a0a	6b d1 03	 imul	 edx, ecx, 3
  00a0d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a10	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00a14	03 ca		 add	 ecx, edx
  00a16	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a19	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 741  : 
; 742  : 		if (m_Level >= 10)

  00a1d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a20	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00a24	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00a27	7c 2c		 jl	 SHORT $LN84@Convert

; 743  : 		{	// +10 이상의 공격력 +
; 744  : #ifdef ITEM_12_13_20040401
; 745  : 			m_DamageMin += (m_Level - 9)*(m_Level - 9 + 1) / 2;

  00a29	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a2c	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00a30	83 e8 09	 sub	 eax, 9
  00a33	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a36	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00a3a	83 ea 08	 sub	 edx, 8
  00a3d	0f af c2	 imul	 eax, edx
  00a40	99		 cdq
  00a41	2b c2		 sub	 eax, edx
  00a43	d1 f8		 sar	 eax, 1
  00a45	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a48	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  00a4c	03 d0		 add	 edx, eax
  00a4e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a51	66 89 50 10	 mov	 WORD PTR [eax+16], dx
$LN84@Convert:

; 746  : #else
; 747  : 			m_DamageMin += (m_Level - 10) * 2 + 1;
; 748  : #endif
; 749  : 		}
; 750  : 	}
; 751  : 
; 752  : 	if (m_Magic > 0)

  00a55	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a58	0f b7 48 20	 movzx	 ecx, WORD PTR [eax+32]
  00a5c	85 c9		 test	 ecx, ecx
  00a5e	0f 8e fe 00 00
	00		 jle	 $LN92@Convert

; 753  : 	{
; 754  : 		if (m_SetOption && ItemLevel)

  00a64	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a67	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00a6e	85 c9		 test	 ecx, ecx
  00a70	74 4b		 je	 SHORT $LN86@Convert
  00a72	83 7d f4 00	 cmp	 DWORD PTR _ItemLevel$[ebp], 0
  00a76	74 45		 je	 SHORT $LN86@Convert

; 755  : 		{
; 756  : 			m_Magic += m_Magic * 25 / p->Level + 5;

  00a78	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a7b	0f b7 48 20	 movzx	 ecx, WORD PTR [eax+32]
  00a7f	6b c1 19	 imul	 eax, ecx, 25
  00a82	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00a85	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  00a89	99		 cdq
  00a8a	f7 f9		 idiv	 ecx
  00a8c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a8f	0f b7 4a 20	 movzx	 ecx, WORD PTR [edx+32]
  00a93	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  00a97	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a9a	66 89 50 20	 mov	 WORD PTR [eax+32], dx

; 757  : 			m_Magic += ItemLevel / 60 + 2;

  00a9e	8b 45 f4	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  00aa1	99		 cdq
  00aa2	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00aa7	f7 f9		 idiv	 ecx
  00aa9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00aac	0f b7 4a 20	 movzx	 ecx, WORD PTR [edx+32]
  00ab0	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  00ab4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ab7	66 89 50 20	 mov	 WORD PTR [eax+32], dx

; 758  : 		}

  00abb	eb 53		 jmp	 SHORT $LN91@Convert
$LN86@Convert:

; 759  : 		else
; 760  : 			if ((Attribute2 & 63) > 0)

  00abd	0f b6 45 18	 movzx	 eax, BYTE PTR _Attribute2$[ebp]
  00ac1	83 e0 3f	 and	 eax, 63			; 0000003fH
  00ac4	7e 4a		 jle	 SHORT $LN91@Convert

; 761  : 			{
; 762  : 				if (iChaosItem)

  00ac6	83 7d e4 00	 cmp	 DWORD PTR _iChaosItem$[ebp], 0
  00aca	74 13		 je	 SHORT $LN89@Convert

; 763  : 				{
; 764  : 					m_Magic += iChaosItem;

  00acc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00acf	0f b7 48 20	 movzx	 ecx, WORD PTR [eax+32]
  00ad3	03 4d e4	 add	 ecx, DWORD PTR _iChaosItem$[ebp]
  00ad6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ad9	66 89 4a 20	 mov	 WORD PTR [edx+32], cx

; 765  : 				}

  00add	eb 31		 jmp	 SHORT $LN91@Convert
$LN89@Convert:

; 766  : 				else if (p->Level)

  00adf	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00ae2	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  00ae6	85 c9		 test	 ecx, ecx
  00ae8	74 26		 je	 SHORT $LN91@Convert

; 767  : 					m_Magic += m_Magic * 25 / p->Level + 5;

  00aea	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00aed	0f b7 48 20	 movzx	 ecx, WORD PTR [eax+32]
  00af1	6b c1 19	 imul	 eax, ecx, 25
  00af4	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00af7	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  00afb	99		 cdq
  00afc	f7 f9		 idiv	 ecx
  00afe	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b01	0f b7 4a 20	 movzx	 ecx, WORD PTR [edx+32]
  00b05	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  00b09	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b0c	66 89 50 20	 mov	 WORD PTR [eax+32], dx
$LN91@Convert:

; 768  : 			}
; 769  : 
; 770  : 		m_Magic += m_Level * 3;

  00b10	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b13	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00b17	6b d1 03	 imul	 edx, ecx, 3
  00b1a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b1d	0f b7 48 20	 movzx	 ecx, WORD PTR [eax+32]
  00b21	03 ca		 add	 ecx, edx
  00b23	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b26	66 89 4a 20	 mov	 WORD PTR [edx+32], cx

; 771  : 
; 772  : 		if (m_Level >= 10)

  00b2a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b2d	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00b31	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00b34	7c 2c		 jl	 SHORT $LN92@Convert

; 773  : 		{	// +10 이상의 공격력 +
; 774  : #ifdef ITEM_12_13_20040401
; 775  : 			m_Magic += (m_Level - 9)*(m_Level - 9 + 1) / 2;

  00b36	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b39	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00b3d	83 e8 09	 sub	 eax, 9
  00b40	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b43	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00b47	83 ea 08	 sub	 edx, 8
  00b4a	0f af c2	 imul	 eax, edx
  00b4d	99		 cdq
  00b4e	2b c2		 sub	 eax, edx
  00b50	d1 f8		 sar	 eax, 1
  00b52	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b55	0f b7 51 20	 movzx	 edx, WORD PTR [ecx+32]
  00b59	03 d0		 add	 edx, eax
  00b5b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b5e	66 89 50 20	 mov	 WORD PTR [eax+32], dx
$LN92@Convert:

; 776  : #else
; 777  : 			m_Magic += (m_Level - 10) * 2 + 1;
; 778  : #endif
; 779  : 		}
; 780  : 	}
; 781  : 
; 782  : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 책에 대한 저주력 계산
; 783  : 	if (m_Curse > 0)
; 784  : 	{
; 785  : 		if (m_SetOption && ItemLevel)
; 786  : 		{
; 787  : 			m_Curse += m_Curse * 25 / p->Level + 5;
; 788  : 			m_Curse += ItemLevel / 60 + 2;
; 789  : 		}
; 790  : 		else
; 791  : 			if ((Attribute2 & 63) > 0)
; 792  : 			{
; 793  : 				if (iChaosItem)
; 794  : 				{
; 795  : 					m_Curse += iChaosItem;
; 796  : 				}
; 797  : 				else if (p->Level)
; 798  : 					m_Curse += m_Curse * 25 / p->Level + 5;
; 799  : 			}
; 800  : 
; 801  : 		m_Curse += m_Level * 3;
; 802  : 
; 803  : 		if (m_Level >= 10)
; 804  : 		{	// +10 이상의 공격력 +
; 805  : #ifdef ITEM_12_13_20040401
; 806  : 			m_Curse += (m_Level - 9)*(m_Level - 9 + 1) / 2;
; 807  : #else
; 808  : 			m_Curse += (m_Level - 10) * 2 + 1;
; 809  : #endif
; 810  : 		}
; 811  : 	}
; 812  : #endif
; 813  : 
; 814  : 	if (p->SuccessfulBlocking > 0)

  00b62	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00b65	0f b6 48 2c	 movzx	 ecx, BYTE PTR [eax+44]
  00b69	85 c9		 test	 ecx, ecx
  00b6b	0f 8e e0 00 00
	00		 jle	 $LN98@Convert

; 815  : 	{
; 816  : 		if (m_SetOption && ItemLevel)

  00b71	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b74	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00b7b	85 c9		 test	 ecx, ecx
  00b7d	74 49		 je	 SHORT $LN94@Convert
  00b7f	83 7d f4 00	 cmp	 DWORD PTR _ItemLevel$[ebp], 0
  00b83	74 43		 je	 SHORT $LN94@Convert

; 817  : 		{
; 818  : 			m_SuccessfulBlocking += m_SuccessfulBlocking * 25 / p->Level + 5;

  00b85	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b88	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  00b8c	6b c1 19	 imul	 eax, ecx, 25
  00b8f	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00b92	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  00b96	99		 cdq
  00b97	f7 f9		 idiv	 ecx
  00b99	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b9c	0f b6 4a 14	 movzx	 ecx, BYTE PTR [edx+20]
  00ba0	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  00ba4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ba7	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 819  : 			m_SuccessfulBlocking += ItemLevel / 40 + 5;

  00baa	8b 45 f4	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  00bad	99		 cdq
  00bae	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00bb3	f7 f9		 idiv	 ecx
  00bb5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00bb8	0f b6 4a 14	 movzx	 ecx, BYTE PTR [edx+20]
  00bbc	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  00bc0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bc3	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 820  : 		}

  00bc6	eb 39		 jmp	 SHORT $LN97@Convert
$LN94@Convert:

; 821  : 		else
; 822  : 			if ((Attribute2 & 63) > 0)

  00bc8	0f b6 45 18	 movzx	 eax, BYTE PTR _Attribute2$[ebp]
  00bcc	83 e0 3f	 and	 eax, 63			; 0000003fH
  00bcf	7e 30		 jle	 SHORT $LN97@Convert

; 823  : 			{
; 824  : 				if (p->Level)

  00bd1	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00bd4	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  00bd8	85 c9		 test	 ecx, ecx
  00bda	74 25		 je	 SHORT $LN97@Convert

; 825  : 					m_SuccessfulBlocking += m_SuccessfulBlocking * 25 / p->Level + 5;

  00bdc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bdf	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  00be3	6b c1 19	 imul	 eax, ecx, 25
  00be6	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00be9	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  00bed	99		 cdq
  00bee	f7 f9		 idiv	 ecx
  00bf0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00bf3	0f b6 4a 14	 movzx	 ecx, BYTE PTR [edx+20]
  00bf7	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  00bfb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bfe	88 50 14	 mov	 BYTE PTR [eax+20], dl
$LN97@Convert:

; 826  : 			}
; 827  : 		m_SuccessfulBlocking += m_Level * 3;

  00c01	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c04	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00c08	6b d1 03	 imul	 edx, ecx, 3
  00c0b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c0e	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  00c12	03 ca		 add	 ecx, edx
  00c14	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00c17	88 4a 14	 mov	 BYTE PTR [edx+20], cl

; 828  : 
; 829  : 		if (m_Level >= 10)

  00c1a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c1d	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00c21	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00c24	7c 2b		 jl	 SHORT $LN98@Convert

; 830  : 		{	// +10 이상의 공격력 +
; 831  : #ifdef ITEM_12_13_20040401
; 832  : 			m_SuccessfulBlocking += (m_Level - 9)*(m_Level - 9 + 1) / 2;

  00c26	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c29	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00c2d	83 e8 09	 sub	 eax, 9
  00c30	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c33	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00c37	83 ea 08	 sub	 edx, 8
  00c3a	0f af c2	 imul	 eax, edx
  00c3d	99		 cdq
  00c3e	2b c2		 sub	 eax, edx
  00c40	d1 f8		 sar	 eax, 1
  00c42	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c45	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  00c49	03 d0		 add	 edx, eax
  00c4b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c4e	88 50 14	 mov	 BYTE PTR [eax+20], dl
$LN98@Convert:

; 833  : #else
; 834  : 			m_SuccessfulBlocking += (m_Level - 10) * 2 + 1;
; 835  : #endif
; 836  : 		}
; 837  : 	}
; 838  : 
; 839  : 	if (p->Defense > 0)

  00c51	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00c54	0f b6 48 2d	 movzx	 ecx, BYTE PTR [eax+45]
  00c58	85 c9		 test	 ecx, ecx
  00c5a	0f 8e c9 01 00
	00		 jle	 $LN111@Convert

; 840  : 	{
; 841  : 		if (m_Type >= ITEM_SHIELD && m_Type < ITEM_SHIELD + MAX_ITEM_INDEX)

  00c60	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c63	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00c67	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  00c6d	7c 5f		 jl	 SHORT $LN100@Convert
  00c6f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c72	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00c76	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  00c7c	7d 50		 jge	 SHORT $LN100@Convert

; 842  : 		{
; 843  : 			m_Defense += m_Level;

  00c7e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c81	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00c85	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00c88	0f b7 42 16	 movzx	 eax, WORD PTR [edx+22]
  00c8c	03 c1		 add	 eax, ecx
  00c8e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c91	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 844  : 
; 845  : 			if (m_SetOption && ItemLevel)

  00c95	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c98	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00c9f	85 c9		 test	 ecx, ecx
  00ca1	74 26		 je	 SHORT $LN102@Convert
  00ca3	83 7d f4 00	 cmp	 DWORD PTR _ItemLevel$[ebp], 0
  00ca7	74 20		 je	 SHORT $LN102@Convert

; 846  : 			{
; 847  : 				m_Defense += (m_Defense * 20 / ItemLevel + 2);

  00ca9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cac	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00cb0	6b c1 14	 imul	 eax, ecx, 20
  00cb3	99		 cdq
  00cb4	f7 7d f4	 idiv	 DWORD PTR _ItemLevel$[ebp]
  00cb7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00cba	0f b7 4a 16	 movzx	 ecx, WORD PTR [edx+22]
  00cbe	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  00cc2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cc5	66 89 50 16	 mov	 WORD PTR [eax+22], dx
$LN102@Convert:

; 848  : 			}
; 849  : 		}

  00cc9	e9 5b 01 00 00	 jmp	 $LN111@Convert
$LN100@Convert:

; 850  : 		else
; 851  : 		{
; 852  : 			if (m_SetOption && ItemLevel)

  00cce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cd1	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  00cd8	85 c9		 test	 ecx, ecx
  00cda	74 70		 je	 SHORT $LN103@Convert
  00cdc	83 7d f4 00	 cmp	 DWORD PTR _ItemLevel$[ebp], 0
  00ce0	74 6a		 je	 SHORT $LN103@Convert

; 853  : 			{
; 854  : 				m_Defense += m_Defense * 12 / p->Level + 4 + p->Level / 5;

  00ce2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ce5	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00ce9	6b c1 0c	 imul	 eax, ecx, 12
  00cec	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00cef	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  00cf3	99		 cdq
  00cf4	f7 f9		 idiv	 ecx
  00cf6	8b c8		 mov	 ecx, eax
  00cf8	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00cfb	0f b6 42 22	 movzx	 eax, BYTE PTR [edx+34]
  00cff	99		 cdq
  00d00	be 05 00 00 00	 mov	 esi, 5
  00d05	f7 fe		 idiv	 esi
  00d07	8d 44 01 04	 lea	 eax, DWORD PTR [ecx+eax+4]
  00d0b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d0e	0f b7 51 16	 movzx	 edx, WORD PTR [ecx+22]
  00d12	03 d0		 add	 edx, eax
  00d14	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00d17	66 89 50 16	 mov	 WORD PTR [eax+22], dx

; 855  : 				m_Defense += m_Defense * 3 / ItemLevel + 2 + ItemLevel / 30;

  00d1b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00d1e	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00d22	6b c1 03	 imul	 eax, ecx, 3
  00d25	99		 cdq
  00d26	f7 7d f4	 idiv	 DWORD PTR _ItemLevel$[ebp]
  00d29	8b c8		 mov	 ecx, eax
  00d2b	8b 45 f4	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  00d2e	99		 cdq
  00d2f	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH
  00d34	f7 fe		 idiv	 esi
  00d36	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  00d3a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00d3d	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00d41	03 ca		 add	 ecx, edx
  00d43	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00d46	66 89 4a 16	 mov	 WORD PTR [edx+22], cx

; 856  : 			}

  00d4a	eb 4d		 jmp	 SHORT $LN106@Convert
$LN103@Convert:

; 857  : 			else
; 858  : 				if ((Attribute2 & 63) > 0)

  00d4c	0f b6 45 18	 movzx	 eax, BYTE PTR _Attribute2$[ebp]
  00d50	83 e0 3f	 and	 eax, 63			; 0000003fH
  00d53	7e 44		 jle	 SHORT $LN106@Convert

; 859  : 				{
; 860  : 					if (p->Level)

  00d55	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00d58	0f b6 48 22	 movzx	 ecx, BYTE PTR [eax+34]
  00d5c	85 c9		 test	 ecx, ecx
  00d5e	74 39		 je	 SHORT $LN106@Convert

; 861  : 						m_Defense += m_Defense * 12 / p->Level + 4 + p->Level / 5;

  00d60	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00d63	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00d67	6b c1 0c	 imul	 eax, ecx, 12
  00d6a	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00d6d	0f b6 4a 22	 movzx	 ecx, BYTE PTR [edx+34]
  00d71	99		 cdq
  00d72	f7 f9		 idiv	 ecx
  00d74	8b c8		 mov	 ecx, eax
  00d76	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00d79	0f b6 42 22	 movzx	 eax, BYTE PTR [edx+34]
  00d7d	99		 cdq
  00d7e	be 05 00 00 00	 mov	 esi, 5
  00d83	f7 fe		 idiv	 esi
  00d85	8d 44 01 04	 lea	 eax, DWORD PTR [ecx+eax+4]
  00d89	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d8c	0f b7 51 16	 movzx	 edx, WORD PTR [ecx+22]
  00d90	03 d0		 add	 edx, eax
  00d92	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00d95	66 89 50 16	 mov	 WORD PTR [eax+22], dx
$LN106@Convert:

; 862  : 				}
; 863  : 
; 864  : #ifdef ADD_THIRD_WING_20070525	// 3차날개의 방어력 적용
; 865  : 			// _MODIFY_ADD_THIRD_WING_20070623
; 866  : 			if (_type >= MAKE_ITEMNUM(12, 36) && _type <= MAKE_ITEMNUM(12, 40))
; 867  : 			{
; 868  : 				m_Defense += m_Level * 4;
; 869  : 
; 870  : 				if (m_Level >= 10)
; 871  : 				{	// 10레벨부터 추가 방여력 적용 +5 ~ +8
; 872  : 					m_Defense += m_Level - 9;
; 873  : 				}
; 874  : 			}
; 875  : 			else
; 876  : #endif	// ADD_THIRD_WING_20070525
; 877  : #ifdef DARKLORD_WORK
; 878  : 				if ((_type >= ITEM_WING + 3 && _type <= ITEM_WING + 6)
; 879  : 					|| _type == ITEM_HELPER + 30 || _type == ITEM_HELPER + 4) // 추가 날개&&망토&&다크호스

  00d99	81 7d f8 83 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 387 ; 00000183H
  00da0	7c 09		 jl	 SHORT $LN110@Convert
  00da2	81 7d f8 86 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 390 ; 00000186H
  00da9	7e 12		 jle	 SHORT $LN109@Convert
$LN110@Convert:
  00dab	81 7d f8 be 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 446 ; 000001beH
  00db2	74 09		 je	 SHORT $LN109@Convert
  00db4	81 7d f8 a4 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 420 ; 000001a4H
  00dbb	75 1a		 jne	 SHORT $LN107@Convert
$LN109@Convert:

; 880  : #else
; 881  : 				if (_type >= ITEM_WING + 3 && _type <= ITEM_WING + 6) // 추가 날개
; 882  : #endif
; 883  : 				{
; 884  : 					m_Defense += m_Level * 2;

  00dbd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00dc0	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00dc4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00dc7	0f b7 42 16	 movzx	 eax, WORD PTR [edx+22]
  00dcb	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00dce	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00dd1	66 89 4a 16	 mov	 WORD PTR [edx+22], cx

; 885  : 				}

  00dd5	eb 1a		 jmp	 SHORT $LN108@Convert
$LN107@Convert:

; 886  : 				else
; 887  : 				{
; 888  : 					m_Defense += m_Level * 3;

  00dd7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00dda	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00dde	6b d1 03	 imul	 edx, ecx, 3
  00de1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00de4	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00de8	03 ca		 add	 ecx, edx
  00dea	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ded	66 89 4a 16	 mov	 WORD PTR [edx+22], cx
$LN108@Convert:

; 889  : 				}
; 890  : 
; 891  : 			if (m_Level >= 10)

  00df1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00df4	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00df8	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00dfb	7c 2c		 jl	 SHORT $LN111@Convert

; 892  : 			{	// +10 이상의 공격력 +
; 893  : #ifdef ITEM_12_13_20040401
; 894  : 				m_Defense += (m_Level - 9)*(m_Level - 9 + 1) / 2;

  00dfd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e00	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00e04	83 e8 09	 sub	 eax, 9
  00e07	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e0a	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00e0e	83 ea 08	 sub	 edx, 8
  00e11	0f af c2	 imul	 eax, edx
  00e14	99		 cdq
  00e15	2b c2		 sub	 eax, edx
  00e17	d1 f8		 sar	 eax, 1
  00e19	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e1c	0f b7 51 16	 movzx	 edx, WORD PTR [ecx+22]
  00e20	03 d0		 add	 edx, eax
  00e22	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e25	66 89 50 16	 mov	 WORD PTR [eax+22], dx
$LN111@Convert:

; 895  : #else
; 896  : 				m_Defense += (m_Level - 10) * 2 + 1;
; 897  : #endif
; 898  : 			}
; 899  : 		}
; 900  : 	}
; 901  : 
; 902  : #ifdef DARKLORD_WORK
; 903  : 	if (_type == MAKE_ITEMNUM(13, 30))

  00e29	6a 1e		 push	 30			; 0000001eH
  00e2b	6a 0d		 push	 13			; 0000000dH
  00e2d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00e32	83 c4 08	 add	 esp, 8
  00e35	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  00e38	75 4a		 jne	 SHORT $LN113@Convert

; 904  : 	{	// 망토 방어력 증가
; 905  : 		m_Defense = 15 + m_Level * 2;

  00e3a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e3d	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00e41	8d 54 09 0f	 lea	 edx, DWORD PTR [ecx+ecx+15]
  00e45	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e48	66 89 50 16	 mov	 WORD PTR [eax+22], dx

; 906  : #ifdef MODIFY_ACCUMULATED_BUG_SLEEVEOFLORD_01_20050531			
; 907  : 		if (m_Level >= 10)

  00e4c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e4f	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00e53	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00e56	7c 2c		 jl	 SHORT $LN113@Convert

; 908  : 		{
; 909  : 			m_Defense += (m_Level - 9)*(m_Level - 9 + 1) / 2;

  00e58	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e5b	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00e5f	83 e8 09	 sub	 eax, 9
  00e62	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e65	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00e69	83 ea 08	 sub	 edx, 8
  00e6c	0f af c2	 imul	 eax, edx
  00e6f	99		 cdq
  00e70	2b c2		 sub	 eax, edx
  00e72	d1 f8		 sar	 eax, 1
  00e74	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00e77	0f b7 51 16	 movzx	 edx, WORD PTR [ecx+22]
  00e7b	03 d0		 add	 edx, eax
  00e7d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e80	66 89 50 16	 mov	 WORD PTR [eax+22], dx
$LN113@Convert:

; 910  : 		}
; 911  : #endif
; 912  : 
; 913  : 	}
; 914  : #endif
; 915  : 
; 916  : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 재앙의 날개, 절망의 날개, 차원의 날개 방어력 계산
; 917  : 	if (_type == MAKE_ITEMNUM(12, 41))
; 918  : 	{	// 재앙의 날개
; 919  : 		m_Defense += m_Level * 3;
; 920  : 		if (m_Level >= 10)
; 921  : 		{
; 922  : 			m_Defense += (m_Level - 9)*(m_Level - 9 + 1) / 2;
; 923  : 		}
; 924  : 	}
; 925  : 	else if (_type == MAKE_ITEMNUM(12, 42))
; 926  : 	{	// 절망의 날개
; 927  : 		m_Defense += m_Level * 2;
; 928  : 		if (m_Level >= 10)
; 929  : 		{
; 930  : 			m_Defense += (m_Level - 9)*(m_Level - 9 + 1) / 2;
; 931  : 		}
; 932  : 	}
; 933  : 	else if (_type == MAKE_ITEMNUM(12, 43))
; 934  : 	{	// 차원의 날개
; 935  : 		m_Defense += m_Level * 4;
; 936  : 
; 937  : 		if (m_Level >= 10)
; 938  : 		{	// 10레벨부터 추가 방여력 적용 +5 ~ +8
; 939  : 			m_Defense += m_Level - 9;
; 940  : 
; 941  : #ifndef MODIFY_SUMMONER_THIRD_WING_BUFGIX_20090109
; 942  : 			m_Defense += (m_Level - 9)*(m_Level - 9 + 1) / 2;
; 943  : #endif	// MODIFY_SUMMONER_THIRD_WING_BUFGIX_20090109
; 944  : 		}
; 945  : 	}
; 946  : #endif	// ADD_SUMMONER_SECOND_THIRD_WING_20071130
; 947  : 
; 948  : 	if (p->MagicDefense > 0)

  00e84	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00e87	0f b6 48 2e	 movzx	 ecx, BYTE PTR [eax+46]
  00e8b	85 c9		 test	 ecx, ecx
  00e8d	7e 52		 jle	 SHORT $LN115@Convert

; 949  : 	{
; 950  : 		m_MagicDefense += m_Level * 3;

  00e8f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e92	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00e96	6b d1 03	 imul	 edx, ecx, 3
  00e99	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00e9c	0f b7 48 18	 movzx	 ecx, WORD PTR [eax+24]
  00ea0	03 ca		 add	 ecx, edx
  00ea2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ea5	66 89 4a 18	 mov	 WORD PTR [edx+24], cx

; 951  : 		if (m_Level >= 10)

  00ea9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00eac	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00eb0	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00eb3	7c 2c		 jl	 SHORT $LN115@Convert

; 952  : 		{	// +10 이상의 공격력 +
; 953  : #ifdef ITEM_12_13_20040401
; 954  : 			m_MagicDefense += (m_Level - 9)*(m_Level - 9 + 1) / 2;

  00eb5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00eb8	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00ebc	83 e8 09	 sub	 eax, 9
  00ebf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ec2	0f bf 51 08	 movsx	 edx, WORD PTR [ecx+8]
  00ec6	83 ea 08	 sub	 edx, 8
  00ec9	0f af c2	 imul	 eax, edx
  00ecc	99		 cdq
  00ecd	2b c2		 sub	 eax, edx
  00ecf	d1 f8		 sar	 eax, 1
  00ed1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ed4	0f b7 51 18	 movzx	 edx, WORD PTR [ecx+24]
  00ed8	03 d0		 add	 edx, eax
  00eda	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00edd	66 89 50 18	 mov	 WORD PTR [eax+24], dx
$LN115@Convert:

; 955  : #else
; 956  : 			m_MagicDefense += (m_Level - 10) * 2 + 1;
; 957  : #endif
; 958  : 		}
; 959  : 	}
; 960  : 	//-------------------------------------------------------------------------
; 961  : 
; 962  : 
; 963  : 
; 964  : 	//if(p->RequireStrength    > 0)  m_RequireStrength    += (10+(ItemLevel+m_Level*3)*15/10)*p->RequireStrength /10;
; 965  : 	//if(p->RequireDexterity   > 0)  m_RequireDexterity   += (10+(ItemLevel+m_Level*3)*15/10)*p->RequireDexterity/10;
; 966  : 
; 967  : 	//int EnableSpecial = m_Level>>4;
; 968  : 	m_Level &= 0xf;

  00ee1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ee4	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00ee8	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00eeb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00eee	66 89 4a 08	 mov	 WORD PTR [edx+8], cx

; 969  : 
; 970  : 	memset(m_Special, 0, MAX_ITEM_SPECIAL);

  00ef2	6a 08		 push	 8
  00ef4	6a 00		 push	 0
  00ef6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ef9	83 c0 31	 add	 eax, 49			; 00000031H
  00efc	50		 push	 eax
  00efd	e8 00 00 00 00	 call	 _memset
  00f02	83 c4 0c	 add	 esp, 12			; 0000000cH

; 971  : 	memset(m_SpecialValue, 0, MAX_ITEM_SPECIAL);

  00f05	6a 08		 push	 8
  00f07	6a 00		 push	 0
  00f09	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f0c	83 c0 39	 add	 eax, 57			; 00000039H
  00f0f	50		 push	 eax
  00f10	e8 00 00 00 00	 call	 _memset
  00f15	83 c4 0c	 add	 esp, 12			; 0000000cH

; 972  : 	m_SpecialNum = 0;

  00f18	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f1b	c6 40 30 00	 mov	 BYTE PTR [eax+48], 0

; 973  : 	m_Option1 = 0;

  00f1f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f22	c6 40 78 00	 mov	 BYTE PTR [eax+120], 0

; 974  : 	m_Option2 = 0;

  00f26	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f29	c6 40 79 00	 mov	 BYTE PTR [eax+121], 0

; 975  : 	m_Option3 = 0;

  00f2d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f30	c6 40 7a 00	 mov	 BYTE PTR [eax+122], 0

; 976  : 
; 977  : #ifdef DARKLORD_WORK
; 978  : 	m_SkillChange = FALSE;

  00f34	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f37	c6 80 90 00 00
	00 00		 mov	 BYTE PTR [eax+144], 0

; 979  : 	//옵션1(스킬)
; 980  : 	if (Option1)

  00f3e	0f b6 45 0c	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00f42	85 c0		 test	 eax, eax
  00f44	74 4f		 je	 SHORT $LN119@Convert

; 981  : 	{	// ITem.txt에 스킬값이 들어감
; 982  : 		if (p->SkillType)

  00f46	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00f49	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  00f4d	74 46		 je	 SHORT $LN119@Convert

; 983  : 		{
; 984  : 			if (p->SkillType == AT_SKILL_LONGSPEAR)

  00f4f	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00f52	83 78 64 42	 cmp	 DWORD PTR [eax+100], 66	; 00000042H
  00f56	75 22		 jne	 SHORT $LN118@Convert

; 985  : 			{
; 986  : 				m_SkillChange = TRUE;

  00f58	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f5b	c6 80 90 00 00
	00 01		 mov	 BYTE PTR [eax+144], 1

; 987  : 				m_Special[m_SpecialNum] = 0;

  00f62	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f65	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  00f69	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00f6c	c6 44 0a 31 00	 mov	 BYTE PTR [edx+ecx+49], 0

; 988  : 				m_Option1 = 1;

  00f71	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f74	c6 40 78 01	 mov	 BYTE PTR [eax+120], 1

; 989  : 			}

  00f78	eb 1b		 jmp	 SHORT $LN119@Convert
$LN118@Convert:

; 990  : 			else
; 991  : 			{
; 992  : 				m_Special[m_SpecialNum] = p->SkillType;

  00f7a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f7d	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  00f81	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00f84	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00f87	8a 40 64	 mov	 al, BYTE PTR [eax+100]
  00f8a	88 44 0a 31	 mov	 BYTE PTR [edx+ecx+49], al

; 993  : 				m_Option1 = 1;

  00f8e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f91	c6 40 78 01	 mov	 BYTE PTR [eax+120], 1
$LN119@Convert:

; 994  : 			}
; 995  : 		}
; 996  : 	}
; 997  : #else
; 998  : 	/*
; 999  : 	//
; 1000 : 	//
; 1001 : 	//	20051110 DARKLORD_WORK 의 ELSE 부분 삭제 (apple)
; 1002 : 	//
; 1003 : 	//
; 1004 : 	//
; 1005 : 	*/
; 1006 : 	if (Option1)
; 1007 : 	{	// ITem.txt에 스킬값이 들어감
; 1008 : 		if (p->SkillType)
; 1009 : 		{
; 1010 : 			m_Special[m_SpecialNum] = p->SkillType;
; 1011 : 			m_Option1 = 1;
; 1012 : 		}
; 1013 : 	}
; 1014 : 
; 1015 : #endif // DARKLORD_WORK
; 1016 : 
; 1017 : 
; 1018 : 	if (m_Type == MAKE_ITEMNUM(13, 3))

  00f95	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00f98	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00f9c	6a 03		 push	 3
  00f9e	6a 0d		 push	 13			; 0000000dH
  00fa0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00fa5	83 c4 08	 add	 esp, 8
  00fa8	3b f0		 cmp	 esi, eax
  00faa	75 16		 jne	 SHORT $LN120@Convert

; 1019 : 	{	// 디노란트는 무조건 옵션이 들어 간다
; 1020 : 		m_Option1 = 1;

  00fac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00faf	c6 40 78 01	 mov	 BYTE PTR [eax+120], 1

; 1021 : 		m_Special[m_SpecialNum] = AT_SKILL_KNIGHTDINORANT;

  00fb3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fb6	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  00fba	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00fbd	c6 44 0a 31 31	 mov	 BYTE PTR [edx+ecx+49], 49 ; 00000031H
$LN120@Convert:

; 1022 : 	}
; 1023 : 
; 1024 : 
; 1025 : #ifdef DARKLORD_WORK
; 1026 : 	if (m_Type == MAKE_ITEMNUM(13, 4))

  00fc2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fc5	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00fc9	6a 04		 push	 4
  00fcb	6a 0d		 push	 13			; 0000000dH
  00fcd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00fd2	83 c4 08	 add	 esp, 8
  00fd5	3b f0		 cmp	 esi, eax
  00fd7	75 16		 jne	 SHORT $LN121@Convert

; 1027 : 	{	// 다크호스는 무조건 옵션이 들어 간다
; 1028 : 		m_Option1 = 1;

  00fd9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fdc	c6 40 78 01	 mov	 BYTE PTR [eax+120], 1

; 1029 : 		m_Special[m_SpecialNum] = AT_SKILL_DARKHORSE_ATTACK;

  00fe0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00fe3	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  00fe7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00fea	c6 44 0a 31 3e	 mov	 BYTE PTR [edx+ecx+49], 62 ; 0000003eH
$LN121@Convert:

; 1030 : 	}
; 1031 : #endif
; 1032 : 
; 1033 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 1034 : 	// 펜릴은 무조건 옵션이 들어간다.
; 1035 : 	// item.txt 의 SkillType에 스킬 값 들어가 있지만, Convert 함수가 예외적인 상황에 호출될 때를 대비한다.
; 1036 : 	if (m_Type == MAKE_ITEMNUM(13, 37))
; 1037 : 	{	// 펜릴은 무조건 옵션이 들어 간다
; 1038 : 		m_Option1 = 1;
; 1039 : 		m_Special[m_SpecialNum] = AT_SKILL_FENRIR_ATTACK;
; 1040 : 	}
; 1041 : #endif
; 1042 : 
; 1043 : 	m_SpecialNum++;

  00fef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00ff2	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  00ff5	80 c1 01	 add	 cl, 1
  00ff8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ffb	88 4a 30	 mov	 BYTE PTR [edx+48], cl

; 1044 : 
; 1045 : 	//옵션2(행운)
; 1046 : 	if (Option2 != 0)

  00ffe	0f b6 45 10	 movzx	 eax, BYTE PTR _Option2$[ebp]
  01002	85 c0		 test	 eax, eax
  01004	0f 84 cf 00 00
	00		 je	 $LN126@Convert

; 1047 : 	{
; 1048 : 		if (_type >= MAKE_ITEMNUM(0, 0) && _type < MAKE_ITEMNUM(12, 0))

  0100a	6a 00		 push	 0
  0100c	6a 00		 push	 0
  0100e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01013	83 c4 08	 add	 esp, 8
  01016	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  01019	7c 27		 jl	 SHORT $LN123@Convert
  0101b	6a 00		 push	 0
  0101d	6a 0c		 push	 12			; 0000000cH
  0101f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01024	83 c4 08	 add	 esp, 8
  01027	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  0102a	7d 16		 jge	 SHORT $LN123@Convert

; 1049 : 		{
; 1050 : 			this->m_Special[this->m_SpecialNum] = 84;

  0102c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0102f	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01036	c6 44 0a 31 54	 mov	 BYTE PTR [edx+ecx+49], 84 ; 00000054H

; 1051 : 			this->m_Option2 = 1;

  0103b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0103e	c6 40 79 01	 mov	 BYTE PTR [eax+121], 1
$LN123@Convert:

; 1052 : 		}
; 1053 : 
; 1054 : 		if (_type >= MAKE_ITEMNUM(12, 0) && _type <= MAKE_ITEMNUM(12, 6))	// Wings

  01042	6a 00		 push	 0
  01044	6a 0c		 push	 12			; 0000000cH
  01046	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0104b	83 c4 08	 add	 esp, 8
  0104e	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  01051	7c 27		 jl	 SHORT $LN124@Convert
  01053	6a 06		 push	 6
  01055	6a 0c		 push	 12			; 0000000cH
  01057	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0105c	83 c4 08	 add	 esp, 8
  0105f	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  01062	7f 16		 jg	 SHORT $LN124@Convert

; 1055 : 		{
; 1056 : 			this->m_Special[this->m_SpecialNum] = 84;

  01064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01067	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0106b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0106e	c6 44 0a 31 54	 mov	 BYTE PTR [edx+ecx+49], 84 ; 00000054H

; 1057 : 			this->m_Option2 = 1;

  01073	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01076	c6 40 79 01	 mov	 BYTE PTR [eax+121], 1
$LN124@Convert:

; 1058 : 		}
; 1059 : 
; 1060 : 		if (_type >= MAKE_ITEMNUM(12, 36) && _type <= MAKE_ITEMNUM(12, 40))	// Wings s3

  0107a	6a 24		 push	 36			; 00000024H
  0107c	6a 0c		 push	 12			; 0000000cH
  0107e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01083	83 c4 08	 add	 esp, 8
  01086	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  01089	7c 27		 jl	 SHORT $LN125@Convert
  0108b	6a 28		 push	 40			; 00000028H
  0108d	6a 0c		 push	 12			; 0000000cH
  0108f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01094	83 c4 08	 add	 esp, 8
  01097	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  0109a	7f 16		 jg	 SHORT $LN125@Convert

; 1061 : 		{
; 1062 : 			this->m_Special[this->m_SpecialNum] = 84;

  0109c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0109f	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  010a3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  010a6	c6 44 0a 31 54	 mov	 BYTE PTR [edx+ecx+49], 84 ; 00000054H

; 1063 : 			this->m_Option2 = 1;

  010ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010ae	c6 40 79 01	 mov	 BYTE PTR [eax+121], 1
$LN125@Convert:

; 1064 : 		}
; 1065 : #ifdef CUSTOM_WINGS
; 1066 : 		if (_type >= MAKE_ITEMNUM(12, 41) && _type <= MAKE_ITEMNUM(12, 45))	// New Wings
; 1067 : 		{
; 1068 : 			this->m_Special[this->m_SpecialNum] = 84;
; 1069 : 			this->m_Option2 = 1;
; 1070 : 		}
; 1071 : #endif
; 1072 : 		if (_type == MAKE_ITEMNUM(13, 30))	// Cape of Lord

  010b2	6a 1e		 push	 30			; 0000001eH
  010b4	6a 0d		 push	 13			; 0000000dH
  010b6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  010bb	83 c4 08	 add	 esp, 8
  010be	39 45 f8	 cmp	 DWORD PTR __type$[ebp], eax
  010c1	75 16		 jne	 SHORT $LN126@Convert

; 1073 : 		{
; 1074 : 			this->m_Special[this->m_SpecialNum] = 84;

  010c3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010c6	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  010ca	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  010cd	c6 44 0a 31 54	 mov	 BYTE PTR [edx+ecx+49], 84 ; 00000054H

; 1075 : 			this->m_Option2 = 1;

  010d2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010d5	c6 40 79 01	 mov	 BYTE PTR [eax+121], 1
$LN126@Convert:

; 1076 : 		}
; 1077 : 	}
; 1078 : 	m_SpecialNum++;

  010d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  010dc	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  010df	80 c1 01	 add	 cl, 1
  010e2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  010e5	88 4a 30	 mov	 BYTE PTR [edx+48], cl

; 1079 : 
; 1080 : 	//옵션3(추가포인트)
; 1081 : 	if (Option3)

  010e8	0f b6 45 14	 movzx	 eax, BYTE PTR _Option3$[ebp]
  010ec	85 c0		 test	 eax, eax
  010ee	0f 84 df 03 00
	00		 je	 $LN166@Convert

; 1082 : 	{
; 1083 : 
; 1084 : 		// 세트 아이템 옵션
; 1085 : 		{
; 1086 : 			if (_type >= ITEM_SWORD && _type < ITEM_BOW + MAX_ITEM_INDEX)

  010f4	83 7d f8 00	 cmp	 DWORD PTR __type$[ebp], 0
  010f8	7c 36		 jl	 SHORT $LN128@Convert
  010fa	81 7d f8 a0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 160 ; 000000a0H
  01101	7d 2d		 jge	 SHORT $LN128@Convert

; 1087 : 			{
; 1088 : 				m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;

  01103	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01106	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0110a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0110d	c6 44 0a 31 50	 mov	 BYTE PTR [edx+ecx+49], 80 ; 00000050H

; 1089 : 				m_Option3 = Option3;

  01112	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01115	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  01118	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1090 : 				m_RequireStrength += Option3 * 4;

  0111b	0f b6 45 14	 movzx	 eax, BYTE PTR _Option3$[ebp]
  0111f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01122	0f b7 51 42	 movzx	 edx, WORD PTR [ecx+66]
  01126	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  01129	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0112c	66 89 41 42	 mov	 WORD PTR [ecx+66], ax
$LN128@Convert:

; 1091 : 			}
; 1092 : 			if (_type >= ITEM_STAFF && _type < ITEM_STAFF + MAX_ITEM_INDEX)

  01130	81 7d f8 a0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 160 ; 000000a0H
  01137	7c 36		 jl	 SHORT $LN129@Convert
  01139	81 7d f8 c0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 192 ; 000000c0H
  01140	7d 2d		 jge	 SHORT $LN129@Convert

; 1093 : 			{
; 1094 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 책(왼쪽 지팡이) 일경우 저주력 증가
; 1095 : 				if (p->ItemSlot == EQUIPMENT_WEAPON_LEFT)
; 1096 : 				{
; 1097 : 					m_Special[m_SpecialNum] = AT_IMPROVE_CURSE;
; 1098 : 				}
; 1099 : 				else
; 1100 : 				{
; 1101 : 					m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;
; 1102 : 				}
; 1103 : #else
; 1104 : 				m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;

  01142	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01145	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01149	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0114c	c6 44 0a 31 51	 mov	 BYTE PTR [edx+ecx+49], 81 ; 00000051H

; 1105 : #endif
; 1106 : 				m_Option3 = Option3;

  01151	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01154	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  01157	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1107 : 				m_RequireStrength += Option3 * 4;

  0115a	0f b6 45 14	 movzx	 eax, BYTE PTR _Option3$[ebp]
  0115e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01161	0f b7 51 42	 movzx	 edx, WORD PTR [ecx+66]
  01165	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  01168	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0116b	66 89 41 42	 mov	 WORD PTR [ecx+66], ax
$LN129@Convert:

; 1108 : 			}
; 1109 : 			if (_type >= ITEM_SHIELD && _type < ITEM_SHIELD + MAX_ITEM_INDEX)

  0116f	81 7d f8 c0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 192 ; 000000c0H
  01176	7c 36		 jl	 SHORT $LN130@Convert
  01178	81 7d f8 e0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 224 ; 000000e0H
  0117f	7d 2d		 jge	 SHORT $LN130@Convert

; 1110 : 			{
; 1111 : 				m_Special[m_SpecialNum] = AT_IMPROVE_BLOCKING;

  01181	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01184	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01188	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0118b	c6 44 0a 31 52	 mov	 BYTE PTR [edx+ecx+49], 82 ; 00000052H

; 1112 : 				m_Option3 = Option3;

  01190	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01193	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  01196	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1113 : 				m_RequireStrength += Option3 * 4;

  01199	0f b6 45 14	 movzx	 eax, BYTE PTR _Option3$[ebp]
  0119d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011a0	0f b7 51 42	 movzx	 edx, WORD PTR [ecx+66]
  011a4	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  011a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011aa	66 89 41 42	 mov	 WORD PTR [ecx+66], ax
$LN130@Convert:

; 1114 : 			}
; 1115 : 			if (_type >= ITEM_HELM && _type < ITEM_BOOT + MAX_ITEM_INDEX)

  011ae	81 7d f8 e0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 224 ; 000000e0H
  011b5	7c 36		 jl	 SHORT $LN131@Convert
  011b7	81 7d f8 80 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 384 ; 00000180H
  011be	7d 2d		 jge	 SHORT $LN131@Convert

; 1116 : 			{
; 1117 : 				m_Special[m_SpecialNum] = AT_IMPROVE_DEFENSE;

  011c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011c3	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  011c7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  011ca	c6 44 0a 31 53	 mov	 BYTE PTR [edx+ecx+49], 83 ; 00000053H

; 1118 : 				m_Option3 = Option3;

  011cf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  011d2	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  011d5	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1119 : 				m_RequireStrength += Option3 * 4;

  011d8	0f b6 45 14	 movzx	 eax, BYTE PTR _Option3$[ebp]
  011dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011df	0f b7 51 42	 movzx	 edx, WORD PTR [ecx+66]
  011e3	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  011e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  011e9	66 89 41 42	 mov	 WORD PTR [ecx+66], ax
$LN131@Convert:

; 1120 : 			}
; 1121 : 			if ((_type >= ITEM_HELPER + 8 && _type < ITEM_HELPER + 14) ||

  011ed	81 7d f8 a8 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 424 ; 000001a8H
  011f4	7c 09		 jl	 SHORT $LN134@Convert
  011f6	81 7d f8 ae 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 430 ; 000001aeH
  011fd	7c 12		 jl	 SHORT $LN133@Convert
$LN134@Convert:
  011ff	81 7d f8 b4 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 436 ; 000001b4H
  01206	7c 67		 jl	 SHORT $LN138@Convert
  01208	81 7d f8 bc 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 444 ; 000001bcH
  0120f	7f 5e		 jg	 SHORT $LN138@Convert
$LN133@Convert:

; 1122 : 				(_type >= ITEM_HELPER + 20 && _type <= ITEM_HELPER + 28)) //반지,목걸이
; 1123 : 			{
; 1124 : 				if (_type == ITEM_HELPER + 24)

  01211	81 7d f8 b8 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 440 ; 000001b8H
  01218	75 1a		 jne	 SHORT $LN135@Convert

; 1125 : 				{	// 마법의 반지
; 1126 : 					m_Special[m_SpecialNum] = AT_SET_OPTION_IMPROVE_MAXMANA;

  0121a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0121d	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01221	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01224	c6 44 0a 31 ac	 mov	 BYTE PTR [edx+ecx+49], 172 ; 000000acH

; 1127 : 					m_Option3 = Option3;

  01229	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0122c	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  0122f	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1128 : 				}

  01232	eb 3b		 jmp	 SHORT $LN138@Convert
$LN135@Convert:

; 1129 : 				else if (_type == ITEM_HELPER + 28)

  01234	81 7d f8 bc 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 444 ; 000001bcH
  0123b	75 1a		 jne	 SHORT $LN137@Convert

; 1130 : 				{	// 기술의 목걸이
; 1131 : 					m_Special[m_SpecialNum] = AT_SET_OPTION_IMPROVE_MAXAG;

  0123d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01240	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01244	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01247	c6 44 0a 31 ad	 mov	 BYTE PTR [edx+ecx+49], 173 ; 000000adH

; 1132 : 					m_Option3 = Option3;

  0124c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0124f	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  01252	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1133 : 				}

  01255	eb 18		 jmp	 SHORT $LN138@Convert
$LN137@Convert:

; 1134 : 				else
; 1135 : 				{
; 1136 : 					m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;

  01257	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0125a	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0125e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01261	c6 44 0a 31 55	 mov	 BYTE PTR [edx+ecx+49], 85 ; 00000055H

; 1137 : 					m_Option3 = Option3;

  01266	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01269	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  0126c	88 48 7a	 mov	 BYTE PTR [eax+122], cl
$LN138@Convert:

; 1138 : 				}
; 1139 : 			}
; 1140 : 
; 1141 : 
; 1142 : #ifdef DARKLORD_WORK
; 1143 : 			if (_type == ITEM_HELPER + 30)

  0126f	81 7d f8 be 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 446 ; 000001beH
  01276	75 18		 jne	 SHORT $LN139@Convert

; 1144 : 			{	// 망토는 공격력 증가.
; 1145 : 				m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;

  01278	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0127b	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0127f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01282	c6 44 0a 31 50	 mov	 BYTE PTR [edx+ecx+49], 80 ; 00000050H

; 1146 : 				m_Option3 = Option3;

  01287	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0128a	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  0128d	88 48 7a	 mov	 BYTE PTR [eax+122], cl
$LN139@Convert:

; 1147 : 				//m_RequireStrength += Option3*4;
; 1148 : 			}
; 1149 : #endif
; 1150 : 
; 1151 : 			if (_type == ITEM_WING)

  01290	81 7d f8 80 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 384 ; 00000180H
  01297	75 1d		 jne	 SHORT $LN140@Convert

; 1152 : 			{
; 1153 : 				m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;

  01299	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0129c	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  012a0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  012a3	c6 44 0a 31 55	 mov	 BYTE PTR [edx+ecx+49], 85 ; 00000055H

; 1154 : 				m_Option3 = Option3;

  012a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012ab	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  012ae	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1155 : 			}

  012b1	e9 fc 01 00 00	 jmp	 $LN165@Convert
$LN140@Convert:

; 1156 : 			else if (_type == ITEM_WING + 1)

  012b6	81 7d f8 81 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 385 ; 00000181H
  012bd	75 1d		 jne	 SHORT $LN142@Convert

; 1157 : 			{
; 1158 : 				m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;

  012bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012c2	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  012c6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  012c9	c6 44 0a 31 51	 mov	 BYTE PTR [edx+ecx+49], 81 ; 00000051H

; 1159 : 				m_Option3 = Option3;

  012ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012d1	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  012d4	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1160 : 				//m_RequireStrength += Option3*4;
; 1161 : 			}

  012d7	e9 d6 01 00 00	 jmp	 $LN165@Convert
$LN142@Convert:

; 1162 : 			else if (_type == ITEM_WING + 2)

  012dc	81 7d f8 82 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 386 ; 00000182H
  012e3	75 1d		 jne	 SHORT $LN144@Convert

; 1163 : 			{
; 1164 : 				m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;

  012e5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012e8	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  012ec	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  012ef	c6 44 0a 31 50	 mov	 BYTE PTR [edx+ecx+49], 80 ; 00000050H

; 1165 : 				m_Option3 = Option3;

  012f4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012f7	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  012fa	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1166 : 				//m_RequireStrength += Option3*4;
; 1167 : 			}

  012fd	e9 b0 01 00 00	 jmp	 $LN165@Convert
$LN144@Convert:

; 1168 : 			else if (_type == ITEM_WING + 3)

  01302	81 7d f8 83 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 387 ; 00000183H
  01309	75 49		 jne	 SHORT $LN146@Convert

; 1169 : 			{	// 정령의 날개(요정)
; 1170 : 				m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;

  0130b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0130e	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01312	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01315	c6 44 0a 31 50	 mov	 BYTE PTR [edx+ecx+49], 80 ; 00000050H

; 1171 : 				m_Option3 = Option3;

  0131a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0131d	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  01320	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1172 : 				//m_RequireStrength += Option3*4;
; 1173 : 
; 1174 : 				if ((m_NewOption)&PLUS_WING_OP1_TYPE)

  01323	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01326	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  0132a	83 e1 20	 and	 ecx, 32			; 00000020H
  0132d	74 11		 je	 SHORT $LN148@Convert

; 1175 : 				{
; 1176 : 					m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;

  0132f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01332	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01336	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01339	c6 44 0a 31 55	 mov	 BYTE PTR [edx+ecx+49], 85 ; 00000055H

; 1177 : 				}

  0133e	eb 0f		 jmp	 SHORT $LN149@Convert
$LN148@Convert:

; 1178 : 				else
; 1179 : 				{
; 1180 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;

  01340	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01343	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01347	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0134a	c6 44 0a 31 50	 mov	 BYTE PTR [edx+ecx+49], 80 ; 00000050H
$LN149@Convert:

; 1181 : 				}
; 1182 : 			}

  0134f	e9 5e 01 00 00	 jmp	 $LN165@Convert
$LN146@Convert:

; 1183 : 			else if (_type == ITEM_WING + 4)

  01354	81 7d f8 84 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 388 ; 00000184H
  0135b	75 3a		 jne	 SHORT $LN150@Convert

; 1184 : 			{	// 영혼의 날개(법사)			
; 1185 : 				m_Option3 = Option3;

  0135d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01360	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  01363	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1186 : 				//m_RequireStrength += Option3*4;
; 1187 : 
; 1188 : 				if ((m_NewOption)&PLUS_WING_OP1_TYPE)

  01366	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01369	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  0136d	83 e1 20	 and	 ecx, 32			; 00000020H
  01370	74 11		 je	 SHORT $LN152@Convert

; 1189 : 				{
; 1190 : 					m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;

  01372	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01375	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01379	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0137c	c6 44 0a 31 51	 mov	 BYTE PTR [edx+ecx+49], 81 ; 00000051H

; 1191 : 				}

  01381	eb 0f		 jmp	 SHORT $LN153@Convert
$LN152@Convert:

; 1192 : 				else
; 1193 : 				{
; 1194 : 					m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;

  01383	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01386	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0138a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0138d	c6 44 0a 31 55	 mov	 BYTE PTR [edx+ecx+49], 85 ; 00000055H
$LN153@Convert:

; 1195 : 				}
; 1196 : 			}

  01392	e9 1b 01 00 00	 jmp	 $LN165@Convert
$LN150@Convert:

; 1197 : 			else if (_type == ITEM_WING + 5)

  01397	81 7d f8 85 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 389 ; 00000185H
  0139e	75 3a		 jne	 SHORT $LN154@Convert

; 1198 : 			{	// 드라곤의 날개(기사)			
; 1199 : 				m_Option3 = Option3;

  013a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013a3	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  013a6	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1200 : 				//m_RequireStrength += Option3*4;
; 1201 : 
; 1202 : 				if ((m_NewOption)&PLUS_WING_OP1_TYPE)

  013a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013ac	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  013b0	83 e1 20	 and	 ecx, 32			; 00000020H
  013b3	74 11		 je	 SHORT $LN156@Convert

; 1203 : 				{
; 1204 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;

  013b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013b8	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  013bc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  013bf	c6 44 0a 31 50	 mov	 BYTE PTR [edx+ecx+49], 80 ; 00000050H

; 1205 : 				}

  013c4	eb 0f		 jmp	 SHORT $LN157@Convert
$LN156@Convert:

; 1206 : 				else
; 1207 : 				{
; 1208 : 					m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;

  013c6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013c9	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  013cd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  013d0	c6 44 0a 31 55	 mov	 BYTE PTR [edx+ecx+49], 85 ; 00000055H
$LN157@Convert:

; 1209 : 				}
; 1210 : 			}

  013d5	e9 d8 00 00 00	 jmp	 $LN165@Convert
$LN154@Convert:

; 1211 : 			else if (_type == ITEM_WING + 6)

  013da	81 7d f8 86 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 390 ; 00000186H
  013e1	75 3a		 jne	 SHORT $LN158@Convert

; 1212 : 			{	// 어둠의 날개(마검)			
; 1213 : 				m_Option3 = Option3;

  013e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013e6	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  013e9	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1214 : 				//m_RequireStrength += Option3*4;
; 1215 : 
; 1216 : 				if ((m_NewOption)&PLUS_WING_OP1_TYPE)

  013ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013ef	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  013f3	83 e1 20	 and	 ecx, 32			; 00000020H
  013f6	74 11		 je	 SHORT $LN160@Convert

; 1217 : 				{
; 1218 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;

  013f8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013fb	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  013ff	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01402	c6 44 0a 31 50	 mov	 BYTE PTR [edx+ecx+49], 80 ; 00000050H

; 1219 : 				}

  01407	eb 0f		 jmp	 SHORT $LN161@Convert
$LN160@Convert:

; 1220 : 				else
; 1221 : 				{
; 1222 : 					m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;

  01409	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0140c	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01410	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01413	c6 44 0a 31 51	 mov	 BYTE PTR [edx+ecx+49], 81 ; 00000051H
$LN161@Convert:

; 1223 : 				}
; 1224 : 			}

  01418	e9 95 00 00 00	 jmp	 $LN165@Convert
$LN158@Convert:

; 1225 : 			else if (_type == ITEM_HELPER + 3)

  0141d	81 7d f8 a3 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 419 ; 000001a3H
  01424	0f 85 88 00 00
	00		 jne	 $LN165@Convert

; 1226 : 			{	// 디노란트
; 1227 : 				m_Option3 = Option3;

  0142a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0142d	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  01430	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1228 : 
; 1229 : 				if ((m_Option3)&PLUS_DINORANT_PLUS_MAX_AG)

  01433	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01436	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  0143a	83 e1 02	 and	 ecx, 2
  0143d	74 1e		 je	 SHORT $LN163@Convert

; 1230 : 				{
; 1231 : 					m_Special[m_SpecialNum] = AT_IMPROVE_AG_MAX;	m_SpecialNum++;

  0143f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01442	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01446	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01449	c6 44 0a 31 67	 mov	 BYTE PTR [edx+ecx+49], 103 ; 00000067H
  0144e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01451	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  01454	80 c1 01	 add	 cl, 1
  01457	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0145a	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN163@Convert:

; 1232 : 				}
; 1233 : 
; 1234 : 				if ((m_Option3)&PLUS_DINORANT_PLUS_ATTACKSPEED)

  0145d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01460	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  01464	83 e1 04	 and	 ecx, 4
  01467	74 2e		 je	 SHORT $LN164@Convert

; 1235 : 				{
; 1236 : 					m_Special[m_SpecialNum] = AT_IMPROVE_ATTACK_SPEED;	m_SpecialNum++;

  01469	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0146c	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01470	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01473	c6 44 0a 31 61	 mov	 BYTE PTR [edx+ecx+49], 97 ; 00000061H
  01478	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0147b	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  0147e	80 c1 01	 add	 cl, 1
  01481	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01484	88 4a 30	 mov	 BYTE PTR [edx+48], cl

; 1237 : 					m_AttackSpeed += 5;

  01487	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0148a	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  0148e	83 c1 05	 add	 ecx, 5
  01491	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01494	88 4a 0d	 mov	 BYTE PTR [edx+13], cl
$LN164@Convert:

; 1238 : 				}
; 1239 : 
; 1240 : 				if ((m_Option3)&PLUS_DINORANT_PLUS_REDUCE_DAMAGE)

  01497	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0149a	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  0149e	83 e1 01	 and	 ecx, 1
  014a1	74 0f		 je	 SHORT $LN165@Convert

; 1241 : 				{
; 1242 : 					m_Special[m_SpecialNum] = AT_DAMAGE_ABSORB;

  014a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014a6	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  014aa	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  014ad	c6 44 0a 31 68	 mov	 BYTE PTR [edx+ecx+49], 104 ; 00000068H
$LN165@Convert:

; 1243 : 				}
; 1244 : 			}
; 1245 : #ifdef DARKLORD_WORK
; 1246 : 			if (_type == ITEM_HELPER + 30)

  014b2	81 7d f8 be 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 446 ; 000001beH
  014b9	75 18		 jne	 SHORT $LN166@Convert

; 1247 : 			{	// 망토
; 1248 : 				m_Option3 = Option3;

  014bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014be	8a 4d 14	 mov	 cl, BYTE PTR _Option3$[ebp]
  014c1	88 48 7a	 mov	 BYTE PTR [eax+122], cl

; 1249 : 				//m_RequireStrength += Option3*4;
; 1250 : 
; 1251 : #ifdef SLEEVEOFLORD_OPTION_BUG_PATCH
; 1252 : 				m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;

  014c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014c7	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  014cb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  014ce	c6 44 0a 31 50	 mov	 BYTE PTR [edx+ecx+49], 80 ; 00000050H
$LN166@Convert:

; 1253 : #else
; 1254 : 				if ((m_NewOption)&PLUS_WING_OP1_TYPE)
; 1255 : 				{
; 1256 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;
; 1257 : 				}
; 1258 : 				else
; 1259 : 				{
; 1260 : 					m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;
; 1261 : 				}
; 1262 : #endif
; 1263 : 			}
; 1264 : #endif
; 1265 : #ifdef ADD_THIRD_WING_20070525	// 3차날개 추가옵션 적용
; 1266 : 			if (_type == ITEM_WING + 36)	// 폭풍의날개
; 1267 : 			{
; 1268 : 				m_Option3 = Option3;
; 1269 : 				// 기본은 생명 자동 회복
; 1270 : 				m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;
; 1271 : 
; 1272 : 				if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_1)
; 1273 : 				{	// 추가 공격력
; 1274 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;
; 1275 : 				}
; 1276 : 				else if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_2)
; 1277 : 				{	// 추가 방어력
; 1278 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DEFENSE;
; 1279 : 				}
; 1280 : 			}
; 1281 : 			if (_type == ITEM_WING + 37)	// 시공의날개
; 1282 : 			{
; 1283 : 				m_Option3 = Option3;
; 1284 : 				m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;
; 1285 : 
; 1286 : 				if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_1)
; 1287 : 				{	// 추가 마력
; 1288 : 					m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;
; 1289 : 				}
; 1290 : 				else if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_2)
; 1291 : 				{	// 추가 방어력
; 1292 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DEFENSE;
; 1293 : 				}
; 1294 : 			}
; 1295 : 			if (_type == ITEM_WING + 38)	// 환영의날개
; 1296 : 			{
; 1297 : 				m_Option3 = Option3;
; 1298 : 				m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;
; 1299 : 
; 1300 : 				if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_1)
; 1301 : 				{	// 추가 공격력
; 1302 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;
; 1303 : 				}
; 1304 : 				else if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_2)
; 1305 : 				{	// 추가 방어력
; 1306 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DEFENSE;
; 1307 : 				}
; 1308 : 			}
; 1309 : 			if (_type == ITEM_WING + 39)	// 파멸의날개
; 1310 : 			{
; 1311 : 				m_Option3 = Option3;
; 1312 : 				m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;
; 1313 : 
; 1314 : 				if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_1)
; 1315 : 				{	// 추가 공격력
; 1316 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;
; 1317 : 				}
; 1318 : 				else if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_2)
; 1319 : 				{	// 추가 마력
; 1320 : 					m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;
; 1321 : 				}
; 1322 : 			}
; 1323 : 			if (_type == ITEM_WING + 40)	// 제왕의망토
; 1324 : 			{
; 1325 : 				m_Option3 = Option3;
; 1326 : 				m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;
; 1327 : 
; 1328 : 				if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_1)
; 1329 : 				{	// 추가 공격력
; 1330 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE;
; 1331 : 				}
; 1332 : 				else if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_2)
; 1333 : 				{	// 추가 방어력
; 1334 : 					m_Special[m_SpecialNum] = AT_IMPROVE_DEFENSE;
; 1335 : 				}
; 1336 : 			}
; 1337 : #endif	// ADD_THIRD_WING_20070525	
; 1338 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 신규캐릭터 재앙의 날개 3번째 옵션처리
; 1339 : 			else if (_type == ITEM_WING + 41)
; 1340 : 			{	// 재앙의 날개(소환술사)			
; 1341 : 				m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;
; 1342 : 				m_Option3 = Option3;
; 1343 : 				//m_RequireStrength += Option3*4;
; 1344 : 			}
; 1345 : #endif		
; 1346 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	//  절망의 날개3번째 옵션
; 1347 : 			else if (_type == ITEM_WING + 42)
; 1348 : 			{	// 절망의 날개(법사)			
; 1349 : 				m_Option3 = Option3;
; 1350 : 				//m_RequireStrength += Option3*4;
; 1351 : 
; 1352 : 				if ((m_NewOption)&PLUS_WING_OP1_TYPE)
; 1353 : 				{
; 1354 : 					m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;
; 1355 : 				}
; 1356 : 				else
; 1357 : 				{
; 1358 : 					m_Special[m_SpecialNum] = AT_IMPROVE_CURSE;
; 1359 : 				}
; 1360 : 			}
; 1361 : 			else if (_type == ITEM_WING + 43)	// 차원의 날개
; 1362 : 			{
; 1363 : 				m_Option3 = Option3;
; 1364 : 				m_Special[m_SpecialNum] = AT_LIFE_REGENERATION;
; 1365 : 
; 1366 : 				if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_1)
; 1367 : 				{	// 추가 공격력
; 1368 : 					m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC;
; 1369 : 				}
; 1370 : 				else if ((m_NewOption)&PLUS_THIRD_WING_RAND_OPT_2)
; 1371 : 				{	// 추가 방어력
; 1372 : 					m_Special[m_SpecialNum] = AT_IMPROVE_CURSE;
; 1373 : 				}
; 1374 : 			}
; 1375 : #endif	// ADD_SUMMONER_SECOND_THIRD_WING_20071130			
; 1376 : 		}
; 1377 : 	}
; 1378 : 
; 1379 : 	m_SpecialNum++;

  014d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  014d6	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  014d9	80 c1 01	 add	 cl, 1
  014dc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  014df	88 4a 30	 mov	 BYTE PTR [edx+48], cl

; 1380 : 
; 1381 : 	if ((_type >= ITEM_SHIELD && _type < ITEM_BOOT + MAX_ITEM_INDEX) ||//방어구
; 1382 : 		(_type >= ITEM_HELPER + 8 && _type <= ITEM_HELPER + 9)
; 1383 : 		|| (_type >= ITEM_HELPER + 21 && _type <= ITEM_HELPER + 24)

  014e2	81 7d f8 c0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 192 ; 000000c0H
  014e9	7c 09		 jl	 SHORT $LN169@Convert
  014eb	81 7d f8 80 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 384 ; 00000180H
  014f2	7c 2c		 jl	 SHORT $LN168@Convert
$LN169@Convert:
  014f4	81 7d f8 a8 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 424 ; 000001a8H
  014fb	7c 09		 jl	 SHORT $LN170@Convert
  014fd	81 7d f8 a9 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 425 ; 000001a9H
  01504	7e 1a		 jle	 SHORT $LN168@Convert
$LN170@Convert:
  01506	81 7d f8 b5 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 437 ; 000001b5H
  0150d	0f 8c 17 01 00
	00		 jl	 $LN176@Convert
  01513	81 7d f8 b8 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 440 ; 000001b8H
  0151a	0f 8f 0a 01 00
	00		 jg	 $LN176@Convert
$LN168@Convert:

; 1384 : 		)//반지
; 1385 : 	{
; 1386 : 		//생명증가
; 1387 : 		if ((m_NewOption >> 5) & 1)

  01520	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01523	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  01527	c1 f9 05	 sar	 ecx, 5
  0152a	83 e1 01	 and	 ecx, 1
  0152d	74 1e		 je	 SHORT $LN171@Convert

; 1388 : 		{
; 1389 : 			m_Special[m_SpecialNum] = AT_IMPROVE_LIFE; m_SpecialNum++;

  0152f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01532	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01536	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01539	c6 44 0a 31 56	 mov	 BYTE PTR [edx+ecx+49], 86 ; 00000056H
  0153e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01541	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  01544	80 c1 01	 add	 cl, 1
  01547	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0154a	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN171@Convert:

; 1390 : 		}
; 1391 : 		//마나증가
; 1392 : 		if ((m_NewOption >> 4) & 1)

  0154d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01550	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  01554	c1 f9 04	 sar	 ecx, 4
  01557	83 e1 01	 and	 ecx, 1
  0155a	74 1e		 je	 SHORT $LN172@Convert

; 1393 : 		{
; 1394 : 			m_Special[m_SpecialNum] = AT_IMPROVE_MANA; m_SpecialNum++;

  0155c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0155f	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01563	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01566	c6 44 0a 31 57	 mov	 BYTE PTR [edx+ecx+49], 87 ; 00000057H
  0156b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0156e	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  01571	80 c1 01	 add	 cl, 1
  01574	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01577	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN172@Convert:

; 1395 : 		}
; 1396 : 		//데미지감소
; 1397 : 		if ((m_NewOption >> 3) & 1)

  0157a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0157d	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  01581	c1 f9 03	 sar	 ecx, 3
  01584	83 e1 01	 and	 ecx, 1
  01587	74 1e		 je	 SHORT $LN173@Convert

; 1398 : 		{
; 1399 : 			m_Special[m_SpecialNum] = AT_DECREASE_DAMAGE; m_SpecialNum++;

  01589	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0158c	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01590	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01593	c6 44 0a 31 58	 mov	 BYTE PTR [edx+ecx+49], 88 ; 00000058H
  01598	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0159b	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  0159e	80 c1 01	 add	 cl, 1
  015a1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  015a4	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN173@Convert:

; 1400 : 		}
; 1401 : 		//데미지반사
; 1402 : 		if ((m_NewOption >> 2) & 1)

  015a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015aa	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  015ae	c1 f9 02	 sar	 ecx, 2
  015b1	83 e1 01	 and	 ecx, 1
  015b4	74 1e		 je	 SHORT $LN174@Convert

; 1403 : 		{
; 1404 : 			m_Special[m_SpecialNum] = AT_REFLECTION_DAMAGE; m_SpecialNum++;

  015b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015b9	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  015bd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  015c0	c6 44 0a 31 59	 mov	 BYTE PTR [edx+ecx+49], 89 ; 00000059H
  015c5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015c8	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  015cb	80 c1 01	 add	 cl, 1
  015ce	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  015d1	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN174@Convert:

; 1405 : 		}
; 1406 : 		//방어성공율
; 1407 : 		if ((m_NewOption >> 1) & 1)

  015d4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015d7	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  015db	d1 f9		 sar	 ecx, 1
  015dd	83 e1 01	 and	 ecx, 1
  015e0	74 1e		 je	 SHORT $LN175@Convert

; 1408 : 		{
; 1409 : 			m_Special[m_SpecialNum] = AT_IMPROVE_BLOCKING_PERCENT; m_SpecialNum++;

  015e2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015e5	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  015e9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  015ec	c6 44 0a 31 5a	 mov	 BYTE PTR [edx+ecx+49], 90 ; 0000005aH
  015f1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  015f4	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  015f7	80 c1 01	 add	 cl, 1
  015fa	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  015fd	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN175@Convert:

; 1410 : 		}
; 1411 : 		//획득젠증가
; 1412 : 		if ((m_NewOption) & 1)

  01600	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01603	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  01607	83 e1 01	 and	 ecx, 1
  0160a	74 1e		 je	 SHORT $LN176@Convert

; 1413 : 		{
; 1414 : 			m_Special[m_SpecialNum] = AT_IMPROVE_GAIN_GOLD; m_SpecialNum++;

  0160c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0160f	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01613	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01616	c6 44 0a 31 5b	 mov	 BYTE PTR [edx+ecx+49], 91 ; 0000005bH
  0161b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0161e	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  01621	80 c1 01	 add	 cl, 1
  01624	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01627	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN176@Convert:

; 1415 : 		}
; 1416 : 	}
; 1417 : 	if ((_type >= ITEM_SWORD && _type < ITEM_STAFF + MAX_ITEM_INDEX) ||//무기
; 1418 : 		(_type >= ITEM_HELPER + 12 && _type <= ITEM_HELPER + 13)
; 1419 : 		|| (_type >= ITEM_HELPER + 25 && _type <= ITEM_HELPER + 28)

  0162a	83 7d f8 00	 cmp	 DWORD PTR __type$[ebp], 0
  0162e	7c 09		 jl	 SHORT $LN179@Convert
  01630	81 7d f8 c0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 192 ; 000000c0H
  01637	7c 2c		 jl	 SHORT $LN178@Convert
$LN179@Convert:
  01639	81 7d f8 ac 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 428 ; 000001acH
  01640	7c 09		 jl	 SHORT $LN180@Convert
  01642	81 7d f8 ad 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 429 ; 000001adH
  01649	7e 1a		 jle	 SHORT $LN178@Convert
$LN180@Convert:
  0164b	81 7d f8 b9 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 441 ; 000001b9H
  01652	0f 8c b0 01 00
	00		 jl	 $LN192@Convert
  01658	81 7d f8 bc 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 444 ; 000001bcH
  0165f	0f 8f a3 01 00
	00		 jg	 $LN192@Convert
$LN178@Convert:

; 1420 : 		)//목걸이
; 1421 : 	{
; 1422 : 		//마나사용량감소
; 1423 : 		if ((m_NewOption >> 5) & 1)

  01665	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01668	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  0166c	c1 f9 05	 sar	 ecx, 5
  0166f	83 e1 01	 and	 ecx, 1
  01672	74 1e		 je	 SHORT $LN181@Convert

; 1424 : 		{
; 1425 : 			m_Special[m_SpecialNum] = AT_EXCELLENT_DAMAGE; m_SpecialNum++;

  01674	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01677	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0167b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0167e	c6 44 0a 31 5c	 mov	 BYTE PTR [edx+ecx+49], 92 ; 0000005cH
  01683	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01686	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  01689	80 c1 01	 add	 cl, 1
  0168c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0168f	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN181@Convert:

; 1426 : 		}
; 1427 : 		if ((_type >= ITEM_STAFF && _type < ITEM_STAFF + MAX_ITEM_INDEX) ||//지팡이
; 1428 : 			(_type == ITEM_HELPER + 12)
; 1429 : 			//얼음의목걸이,물의목걸이만 마증
; 1430 : 			//바람,기술의 목걸이 공증
; 1431 : 			|| (_type == ITEM_HELPER + 25) || (_type == ITEM_HELPER + 27)

  01692	81 7d f8 a0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 160 ; 000000a0H
  01699	7c 09		 jl	 SHORT $LN185@Convert
  0169b	81 7d f8 c0 00
	00 00		 cmp	 DWORD PTR __type$[ebp], 192 ; 000000c0H
  016a2	7c 1b		 jl	 SHORT $LN184@Convert
$LN185@Convert:
  016a4	81 7d f8 ac 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 428 ; 000001acH
  016ab	74 12		 je	 SHORT $LN184@Convert
  016ad	81 7d f8 b9 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 441 ; 000001b9H
  016b4	74 09		 je	 SHORT $LN184@Convert
  016b6	81 7d f8 bb 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 443 ; 000001bbH
  016bd	75 5c		 jne	 SHORT $LN182@Convert
$LN184@Convert:

; 1432 : 			)//목걸이
; 1433 : 		{
; 1434 : 			//마력증가(레벨)
; 1435 : 			if ((m_NewOption >> 4) & 1)

  016bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  016c2	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  016c6	c1 f9 04	 sar	 ecx, 4
  016c9	83 e1 01	 and	 ecx, 1
  016cc	74 1e		 je	 SHORT $LN186@Convert

; 1436 : 			{
; 1437 : 				//		m_SpecialValue[m_SpecialNum] = CharacterAttribute->Level/20;
; 1438 : 				m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC_LEVEL; m_SpecialNum++;

  016ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  016d1	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  016d5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  016d8	c6 44 0a 31 5f	 mov	 BYTE PTR [edx+ecx+49], 95 ; 0000005fH
  016dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  016e0	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  016e3	80 c1 01	 add	 cl, 1
  016e6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  016e9	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN186@Convert:

; 1439 : 			}
; 1440 : 			//마력증가(퍼센트)
; 1441 : 			if ((m_NewOption >> 3) & 1)

  016ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  016ef	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  016f3	c1 f9 03	 sar	 ecx, 3
  016f6	83 e1 01	 and	 ecx, 1
  016f9	74 1e		 je	 SHORT $LN187@Convert

; 1442 : 			{
; 1443 : 				m_Special[m_SpecialNum] = AT_IMPROVE_MAGIC_PERCENT; m_SpecialNum++;

  016fb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  016fe	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01702	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01705	c6 44 0a 31 60	 mov	 BYTE PTR [edx+ecx+49], 96 ; 00000060H
  0170a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0170d	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  01710	80 c1 01	 add	 cl, 1
  01713	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01716	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN187@Convert:

; 1444 : 			}
; 1445 : 		}

  01719	eb 5a		 jmp	 SHORT $LN189@Convert
$LN182@Convert:

; 1446 : 		else
; 1447 : 		{
; 1448 : 			//공격력증가(레벨)
; 1449 : 			if ((m_NewOption >> 4) & 1)

  0171b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0171e	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  01722	c1 f9 04	 sar	 ecx, 4
  01725	83 e1 01	 and	 ecx, 1
  01728	74 1e		 je	 SHORT $LN188@Convert

; 1450 : 			{
; 1451 : 				//m_SpecialValue[m_SpecialNum] = CharacterAttribute->Level/20;
; 1452 : 				m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE_LEVEL; m_SpecialNum++;

  0172a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0172d	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01731	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01734	c6 44 0a 31 5d	 mov	 BYTE PTR [edx+ecx+49], 93 ; 0000005dH
  01739	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0173c	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  0173f	80 c1 01	 add	 cl, 1
  01742	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01745	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN188@Convert:

; 1453 : 			}
; 1454 : 			//공격력증가(퍼센트)
; 1455 : 			if ((m_NewOption >> 3) & 1)

  01748	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0174b	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  0174f	c1 f9 03	 sar	 ecx, 3
  01752	83 e1 01	 and	 ecx, 1
  01755	74 1e		 je	 SHORT $LN189@Convert

; 1456 : 			{
; 1457 : 				m_Special[m_SpecialNum] = AT_IMPROVE_DAMAGE_PERCENT; m_SpecialNum++;

  01757	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0175a	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0175e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01761	c6 44 0a 31 5e	 mov	 BYTE PTR [edx+ecx+49], 94 ; 0000005eH
  01766	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01769	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  0176c	80 c1 01	 add	 cl, 1
  0176f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01772	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN189@Convert:

; 1458 : 			}
; 1459 : 		}
; 1460 : 		//공격속도
; 1461 : 		if ((m_NewOption >> 2) & 1)

  01775	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01778	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  0177c	c1 f9 02	 sar	 ecx, 2
  0177f	83 e1 01	 and	 ecx, 1
  01782	74 2e		 je	 SHORT $LN190@Convert

; 1462 : 		{
; 1463 : 			m_Special[m_SpecialNum] = AT_IMPROVE_ATTACK_SPEED; m_SpecialNum++;

  01784	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01787	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0178b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0178e	c6 44 0a 31 61	 mov	 BYTE PTR [edx+ecx+49], 97 ; 00000061H
  01793	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01796	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  01799	80 c1 01	 add	 cl, 1
  0179c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0179f	88 4a 30	 mov	 BYTE PTR [edx+48], cl

; 1464 : 			m_AttackSpeed += 7;

  017a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017a5	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  017a9	83 c1 07	 add	 ecx, 7
  017ac	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  017af	88 4a 0d	 mov	 BYTE PTR [edx+13], cl
$LN190@Convert:

; 1465 : 		}
; 1466 : 		//획득생명증가
; 1467 : 		if ((m_NewOption >> 1) & 1)

  017b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017b5	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  017b9	d1 f9		 sar	 ecx, 1
  017bb	83 e1 01	 and	 ecx, 1
  017be	74 1e		 je	 SHORT $LN191@Convert

; 1468 : 		{
; 1469 : 			m_Special[m_SpecialNum] = AT_IMPROVE_GAIN_LIFE; m_SpecialNum++;

  017c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017c3	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  017c7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  017ca	c6 44 0a 31 62	 mov	 BYTE PTR [edx+ecx+49], 98 ; 00000062H
  017cf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017d2	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  017d5	80 c1 01	 add	 cl, 1
  017d8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  017db	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN191@Convert:

; 1470 : 		}
; 1471 : 		//획득마나증가
; 1472 : 		if ((m_NewOption) & 1)

  017de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017e1	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  017e5	83 e1 01	 and	 ecx, 1
  017e8	74 1e		 je	 SHORT $LN192@Convert

; 1473 : 		{
; 1474 : 			m_Special[m_SpecialNum] = AT_IMPROVE_GAIN_MANA; m_SpecialNum++;

  017ea	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017ed	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  017f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  017f4	c6 44 0a 31 63	 mov	 BYTE PTR [edx+ecx+49], 99 ; 00000063H
  017f9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  017fc	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  017ff	80 c1 01	 add	 cl, 1
  01802	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01805	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN192@Convert:

; 1475 : 		}
; 1476 : 	}
; 1477 : 
; 1478 : #ifdef NEW_FORSKYLAND2	
; 1479 : #ifdef DARKLORD_WORK
; 1480 : 	if ((_type >= ITEM_WING + 3 && _type <= ITEM_WING + 6) ||

  01808	81 7d f8 83 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 387 ; 00000183H
  0180f	7c 09		 jl	 SHORT $LN195@Convert
  01811	81 7d f8 86 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 390 ; 00000186H
  01818	7e 0d		 jle	 SHORT $LN194@Convert
$LN195@Convert:
  0181a	81 7d f8 be 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 446 ; 000001beH
  01821	0f 85 a8 00 00
	00		 jne	 $LN199@Convert
$LN194@Convert:

; 1481 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130
; 1482 : 		_type == ITEM_WING + 42 ||	// 절망의 날개 옵션
; 1483 : #endif
; 1484 : 		_type == ITEM_HELPER + 30) // 날개 & 망토	    
; 1485 : #else
; 1486 : 	if (_type >= ITEM_WING + 3 && _type <= ITEM_WING + 6) // 날개	    
; 1487 : #endif
; 1488 : 	{
; 1489 : 		if ((m_NewOption)&PLUS_WING_MAXLIFE)

  01827	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0182a	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  0182e	83 e1 01	 and	 ecx, 1
  01831	74 1e		 je	 SHORT $LN196@Convert

; 1490 : 		{	// 최대 HP+50
; 1491 : 			m_Special[m_SpecialNum] = AT_PLUS_WING_MAXLIFE; m_SpecialNum++;

  01833	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01836	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0183a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0183d	c6 44 0a 31 64	 mov	 BYTE PTR [edx+ecx+49], 100 ; 00000064H
  01842	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01845	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  01848	80 c1 01	 add	 cl, 1
  0184b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0184e	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN196@Convert:

; 1492 : 		}
; 1493 : 
; 1494 : 		if ((m_NewOption)&PLUS_WING_MAXMANA)

  01851	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01854	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  01858	83 e1 02	 and	 ecx, 2
  0185b	74 1e		 je	 SHORT $LN197@Convert

; 1495 : 		{	// 최대 MP+50
; 1496 : 			m_Special[m_SpecialNum] = AT_PLUS_WING_MAXMANA; m_SpecialNum++;

  0185d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01860	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  01864	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01867	c6 44 0a 31 65	 mov	 BYTE PTR [edx+ecx+49], 101 ; 00000065H
  0186c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0186f	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  01872	80 c1 01	 add	 cl, 1
  01875	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01878	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN197@Convert:

; 1497 : 		}
; 1498 : 
; 1499 : 		if ((m_NewOption)&PLUS_WING_ONE_PERCENT_DAMAGE)

  0187b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0187e	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  01882	83 e1 04	 and	 ecx, 4
  01885	74 1e		 je	 SHORT $LN198@Convert

; 1500 : 		{	// 데미지 HP->MP로 손실
; 1501 : 			m_Special[m_SpecialNum] = AT_PLUS_ONE_PERCENT_DAMAGE; m_SpecialNum++;

  01887	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0188a	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  0188e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01891	c6 44 0a 31 66	 mov	 BYTE PTR [edx+ecx+49], 102 ; 00000066H
  01896	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01899	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  0189c	80 c1 01	 add	 cl, 1
  0189f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  018a2	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN198@Convert:

; 1502 : 		}
; 1503 : 
; 1504 : #ifdef DARKLORD_WORK
; 1505 : 		if ((m_NewOption)&PLUS_WING_ADD_LEADERSHIP)

  018a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018a8	0f b6 48 7b	 movzx	 ecx, BYTE PTR [eax+123]
  018ac	83 e1 08	 and	 ecx, 8
  018af	74 1e		 je	 SHORT $LN199@Convert

; 1506 : 		{	// 통솔증가
; 1507 : 			m_Special[m_SpecialNum] = AT_PLUS_WING_ADD_LEADERSHIP; m_SpecialNum++;

  018b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018b4	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  018b8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  018bb	c6 44 0a 31 69	 mov	 BYTE PTR [edx+ecx+49], 105 ; 00000069H
  018c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  018c3	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  018c6	80 c1 01	 add	 cl, 1
  018c9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  018cc	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN199@Convert:

; 1508 : 		}
; 1509 : #endif			
; 1510 : 	}
; 1511 : #endif
; 1512 : 
; 1513 : 
; 1514 : 	// 펜릴 경우 특수 옵션 추가!
; 1515 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 1516 : 
; 1517 : 	// 펜릴 옵션에 따른 스킬 추가
; 1518 : 	if (_type == ITEM_HELPER + 37)
; 1519 : 	{
; 1520 : 		if ((m_NewOption)&PLUS_FENRIR_INCREASE_LAST_DAMAGE)
; 1521 : 		{
; 1522 : 			m_Special[m_SpecialNum] = AT_PLUS_FENRIR_INCREASE_LAST_DAMAGE;
; 1523 : 			m_SpecialNum++;
; 1524 : 		}
; 1525 : 		else if ((m_NewOption)&PLUS_FENRIR_DECREASE_LAST_DAMAGE)
; 1526 : 		{
; 1527 : 			m_Special[m_SpecialNum] = AT_PLUS_FENRIR_DECREASE_LAST_DAMAGE;
; 1528 : 			m_SpecialNum++;
; 1529 : 		}
; 1530 : #ifdef ADD_ILLUSION_FENRIR_20070703	// 환영 펜릴 옵션에 따른 스킬 추가
; 1531 : 		else if ((m_NewOption)&PLUS_ILLUSION_FENRIR_OPTION)
; 1532 : 		{
; 1533 : 			m_Special[m_SpecialNum] = AT_PLUS_ILLUSION_FENRIR_OPTION;
; 1534 : 			m_SpecialNum++;
; 1535 : 		}
; 1536 : #endif
; 1537 : 	}
; 1538 : 
; 1539 : #endif
; 1540 : 
; 1541 : #ifdef ADD_THIRD_WING_20070525	// 3차 날개 랜덤 옵션 적용
; 1542 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	// 차원의 날개 랜덤 옵션적용
; 1543 : 	if (_type >= ITEM_WING + 36 && _type <= ITEM_WING + 40
; 1544 : 		|| _type == ITEM_WING + 43)	// 차원의 날개
; 1545 : #else
; 1546 : 	if (_type >= ITEM_WING + 36 && _type <= ITEM_WING + 40)
; 1547 : #endif
; 1548 : 	{
; 1549 : 		if ((m_NewOption)&PLUS_THIRD_WING_5PER_IGNORE_DEFENSE)
; 1550 : 		{	// %5 확률로 적 방어력 무시
; 1551 : 			m_Special[m_SpecialNum] = AT_5PER_IGNORE_DEFENSE;
; 1552 : 			m_SpecialNum++;
; 1553 : 		}
; 1554 : 		if ((m_NewOption)&PLUS_THIRD_WING_5PER_ATTACK_TURNING)
; 1555 : 		{	// 5% 확률로 적 공격력 50% 돌려줌
; 1556 : 			m_Special[m_SpecialNum] = AT_5PER_ATTACK_TURNING;
; 1557 : 			m_SpecialNum++;
; 1558 : 		}
; 1559 : 		if ((m_NewOption)&PLUS_THIRD_WING_RECOVER_100PER_LIFE)
; 1560 : 		{	// 5% 확률로 유저 생명 100% 순간 회복
; 1561 : 			m_Special[m_SpecialNum] = AT_RECOVER_100PER_LIFE;
; 1562 : 			m_SpecialNum++;
; 1563 : 		}
; 1564 : 		if ((m_NewOption)&PLUS_THIRD_WING_RECOVER_100PER_MASIC)
; 1565 : 		{	// 5% 확률로 유저 마력 100% 순간 회복
; 1566 : 			m_Special[m_SpecialNum] = AT_RECOVER_100PER_MASIC;
; 1567 : 			m_SpecialNum++;
; 1568 : 		}
; 1569 : 	}
; 1570 : #endif
; 1571 : 
; 1572 : #if GAME_VERSION >= G_V_99B
; 1573 : 	if (SOptionStatValue)

  018cf	83 7d e8 00	 cmp	 DWORD PTR _SOptionStatValue$[ebp], 0
  018d3	74 42		 je	 SHORT $LN201@Convert

; 1574 : 	{	// 세트 속성 값을 넣는다
; 1575 : 		if (p->SetAttr)

  018d5	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  018d8	0f b6 48 5d	 movzx	 ecx, BYTE PTR [eax+93]
  018dc	85 c9		 test	 ecx, ecx
  018de	74 37		 je	 SHORT $LN201@Convert

; 1576 : 		{	// 세트 속성값이 있으면 세트 속성 값은 1부터 시작 되므로 -1이 필요			
; 1577 : 			m_Special[m_SpecialNum] = AT_SET_IMPROVE_STRENGTH + p->SetAttr - 1;

  018e0	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  018e3	0f b6 48 5d	 movzx	 ecx, BYTE PTR [eax+93]
  018e7	81 c1 c3 00 00
	00		 add	 ecx, 195		; 000000c3H
  018ed	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  018f0	0f b6 42 30	 movzx	 eax, BYTE PTR [edx+48]
  018f4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  018f7	88 4c 02 31	 mov	 BYTE PTR [edx+eax+49], cl

; 1578 : 			m_SetAddStat = SOptionStatValue * 5;

  018fb	6b 45 e8 05	 imul	 eax, DWORD PTR _SOptionStatValue$[ebp], 5
  018ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01902	88 81 93 00 00
	00		 mov	 BYTE PTR [ecx+147], al

; 1579 : 			m_SpecialNum++;

  01908	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0190b	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  0190e	80 c1 01	 add	 cl, 1
  01911	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01914	88 4a 30	 mov	 BYTE PTR [edx+48], cl
$LN201@Convert:

; 1580 : 		}
; 1581 : 	}
; 1582 : #endif
; 1583 : 
; 1584 : 	//#ifdef DARKLORD_WORK	//Item.txt에 위치 값 저장됨
; 1585 : 	m_Part = p->ItemSlot;

  01917	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0191a	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0191d	8a 51 60	 mov	 dl, BYTE PTR [ecx+96]
  01920	88 50 0a	 mov	 BYTE PTR [eax+10], dl

; 1586 : 	//#else
; 1587 : 		/*
; 1588 : 		//
; 1589 : 		//
; 1590 : 		//	20051110 DARKLORD_WORK 의 ELSE 부분 삭제 (apple)
; 1591 : 		//
; 1592 : 		//
; 1593 : 		//
; 1594 : 		*/
; 1595 : 		//#endif // DARKLORD_WORK
; 1596 : 
; 1597 : 	Value();

  01923	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01926	e8 00 00 00 00	 call	 ?Value@CItem@@QAEXXZ	; CItem::Value

; 1598 : 
; 1599 : 	if (m_Type != ITEM_BOW + 7 && m_Type != ITEM_BOW + 15)

  0192b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0192e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01932	81 f9 87 00 00
	00		 cmp	 ecx, 135		; 00000087H
  01938	0f 84 fa 00 00
	00		 je	 $LN203@Convert
  0193e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01941	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  01945	81 f9 8f 00 00
	00		 cmp	 ecx, 143		; 0000008fH
  0194b	0f 84 e7 00 00
	00		 je	 $LN203@Convert

; 1600 : 	{	// 화살, 석궁용화살이 아니면
; 1601 : 		m_DamageMinOrigin = m_DamageMin;

  01951	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01954	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01957	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  0195b	66 89 50 1c	 mov	 WORD PTR [eax+28], dx

; 1602 : 		m_DefenseOrigin = m_Defense;

  0195f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01962	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01965	66 8b 51 16	 mov	 dx, WORD PTR [ecx+22]
  01969	66 89 50 1e	 mov	 WORD PTR [eax+30], dx

; 1603 : 		m_DamageMin -= (WORD)(m_DamageMin*m_CurrentDurabilityState);

  0196d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01970	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  01974	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  01978	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0197b	f3 0f 59 82 8c
	00 00 00	 mulss	 xmm0, DWORD PTR [edx+140]
  01983	f3 0f 2c c0	 cvttss2si eax, xmm0
  01987	0f b7 c8	 movzx	 ecx, ax
  0198a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0198d	0f b7 42 10	 movzx	 eax, WORD PTR [edx+16]
  01991	2b c1		 sub	 eax, ecx
  01993	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01996	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 1604 : 		m_DamageMax -= (WORD)(m_DamageMax*m_CurrentDurabilityState);

  0199a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0199d	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  019a1	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  019a5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019a8	f3 0f 59 82 8c
	00 00 00	 mulss	 xmm0, DWORD PTR [edx+140]
  019b0	f3 0f 2c c0	 cvttss2si eax, xmm0
  019b4	0f b7 c8	 movzx	 ecx, ax
  019b7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019ba	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  019be	2b c1		 sub	 eax, ecx
  019c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019c3	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 1605 : 		m_Defense -= (WORD)(m_Defense*m_CurrentDurabilityState);

  019c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  019ca	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  019ce	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  019d2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019d5	f3 0f 59 82 8c
	00 00 00	 mulss	 xmm0, DWORD PTR [edx+140]
  019dd	f3 0f 2c c0	 cvttss2si eax, xmm0
  019e1	0f b7 c8	 movzx	 ecx, ax
  019e4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019e7	0f b7 42 16	 movzx	 eax, WORD PTR [edx+22]
  019eb	2b c1		 sub	 eax, ecx
  019ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019f0	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 1606 : 		m_SuccessfulBlocking -= (BYTE)(m_SuccessfulBlocking*m_CurrentDurabilityState);

  019f4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  019f7	0f b6 48 14	 movzx	 ecx, BYTE PTR [eax+20]
  019fb	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  019ff	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01a02	f3 0f 59 82 8c
	00 00 00	 mulss	 xmm0, DWORD PTR [edx+140]
  01a0a	f3 0f 2c c0	 cvttss2si eax, xmm0
  01a0e	0f b6 c8	 movzx	 ecx, al
  01a11	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01a14	0f b6 42 14	 movzx	 eax, BYTE PTR [edx+20]
  01a18	2b c1		 sub	 eax, ecx
  01a1a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a1d	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 1607 : 
; 1608 : 		if (m_Durability < 1.f)

  01a20	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a23	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01a2b	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  01a2f	76 07		 jbe	 SHORT $LN203@Convert

; 1609 : 			m_AttackSpeed = 0;

  01a31	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a34	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0
$LN203@Convert:

; 1610 : 	}
; 1611 : 
; 1612 : 	if (m_Durability == 0.f)

  01a38	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a3b	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  01a40	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  01a47	9f		 lahf
  01a48	f6 c4 44	 test	 ah, 68			; 00000044H
  01a4b	7a 13		 jp	 SHORT $LN204@Convert

; 1613 : 	{	// 내구도가 0이면 저항력도 없다
; 1614 : 		memset(m_Resistance, 0, MAX_RESISTANCE);

  01a4d	6a 07		 push	 7
  01a4f	6a 00		 push	 0
  01a51	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a54	83 c0 55	 add	 eax, 85			; 00000055H
  01a57	50		 push	 eax
  01a58	e8 00 00 00 00	 call	 _memset
  01a5d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN204@Convert:

; 1615 : 	}
; 1616 : }

  01a60	5f		 pop	 edi
  01a61	5e		 pop	 esi
  01a62	5b		 pop	 ebx
  01a63	8b e5		 mov	 esp, ebp
  01a65	5d		 pop	 ebp
  01a66	c2 1c 00	 ret	 28			; 0000001cH
?Convert@CItem@@QAEXHEEEEEE@Z ENDP			; CItem::Convert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ??0CItem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CItem@@QAE@XZ PROC					; CItem::CItem, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 44   : 	Clear();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 45   : }

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0CItem@@QAE@XZ ENDP					; CItem::CItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\common\zzzitem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
