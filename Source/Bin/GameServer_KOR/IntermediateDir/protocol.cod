; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?tempindex@@3HA					; tempindex
PUBLIC	?logincounttest@@3HA				; logincounttest
PUBLIC	?ltesttime@@3HA					; ltesttime
_BSS	SEGMENT
?tempindex@@3HA DD 01H DUP (?)				; tempindex
?logincounttest@@3HA DD 01H DUP (?)			; logincounttest
?ltesttime@@3HA DD 01H DUP (?)				; ltesttime
_BSS	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_vsprintf
PUBLIC	_sprintf
PUBLIC	?set@PBMSG_HEAD@@QAEXPAEEE@Z			; PBMSG_HEAD::set
PUBLIC	?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::IsValidDurationTime
PUBLIC	?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z	; TDurMagicKeyChecker::IsValidCount
PUBLIC	?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z	; TDurMagicKeyChecker::SetDurationTime
PUBLIC	?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidDurationTime
PUBLIC	?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z	; TDurMagicKeyChecker::GetValidCount
PUBLIC	?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z	; CheckAuthority
PUBLIC	?ObjectMapJoinPositionSend@@YAXF@Z		; ObjectMapJoinPositionSend
PUBLIC	?GCCloseMsgSend@@YAXHE@Z			; GCCloseMsgSend
PUBLIC	?CGPShopAnsOpen@@YAXHE@Z			; CGPShopAnsOpen
PUBLIC	?CGPShopAnsBuyItem@@YAXHHHE@Z			; CGPShopAnsBuyItem
PUBLIC	?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItem
PUBLIC	?CGPShopAnsClose@@YAXHE@Z			; CGPShopAnsClose
PUBLIC	?vChatSend@@YAXPAVOBJECTSTRUCT@@PADZZ		; vChatSend
PUBLIC	?ChatSend@@YAXPAVOBJECTSTRUCT@@PAD@Z		; ChatSend
PUBLIC	?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z		; PMoveProc
PUBLIC	?GCServerMsgStringSend@@YAXPADHE@Z		; GCServerMsgStringSend
PUBLIC	?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
PUBLIC	?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z	; ChatTargetSend
PUBLIC	?GCEventStateSend@@YAXHEE@Z			; GCEventStateSend
PUBLIC	?GCMapEventStateSend@@YAXHEE@Z			; GCMapEventStateSend
PUBLIC	?AllSendServerMsg@@YAXPAD@Z			; AllSendServerMsg
PUBLIC	?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z		; MsgSendV2
PUBLIC	?GCCheckMainExeKeySend@@YAXH@Z			; GCCheckMainExeKeySend
PUBLIC	?DataSendAll@@YAXPAEH@Z				; DataSendAll
PUBLIC	?GCResultSend@@YAXHEE@Z				; GCResultSend
PUBLIC	?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
PUBLIC	?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z		; CGActionRecv
PUBLIC	?ProtocolCore@@YAXEPAEHHHH@Z			; ProtocolCore
PUBLIC	?SCPJoinResultSend@@YAXHE@Z			; SCPJoinResultSend
PUBLIC	?GCReFillSend@@YAXHGEE@Z			; GCReFillSend
PUBLIC	?CGWeatherSend@@YAXHE@Z				; CGWeatherSend
PUBLIC	?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z		; CGAttack
PUBLIC	?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z	; CGMagicAttack
PUBLIC	?GCLevelUpMsgSend@@YAXHGGGGGFF@Z		; GCLevelUpMsgSend
PUBLIC	?GCManaSend@@YAXHFEEG@Z				; GCManaSend
PUBLIC	?GCDiePlayerSend@@YAXPAVOBJECTSTRUCT@@HEH@Z	; GCDiePlayerSend
PUBLIC	?GCDamageSend@@YAXHHHHH@Z			; GCDamageSend
PUBLIC	?GCDamageSend@@YAXHH@Z				; GCDamageSend
PUBLIC	?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z	; GCMagicCancelSend
PUBLIC	?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z	; GCTeleportSend
PUBLIC	?GCMagicListOneSend@@YAXHDEEE@Z			; GCMagicListOneSend
PUBLIC	?GCMagicListOneDelSend@@YAXHDEEE@Z		; GCMagicListOneDelSend
PUBLIC	?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z	; GCMagicListMultiSend
PUBLIC	?CGBeattackRecv@@YAXPAEHH@Z			; CGBeattackRecv
PUBLIC	?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv
PUBLIC	?GCKillPlayerExpSend@@YAXHHHHH@Z		; GCKillPlayerExpSend
PUBLIC	?GCActionSend@@YAXPAVOBJECTSTRUCT@@EH@Z		; GCActionSend
PUBLIC	?GCActionSend2@@YAXPAVOBJECTSTRUCT@@EHH@Z	; GCActionSend2
PUBLIC	?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
PUBLIC	?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ; CGPartyRequestRecv
PUBLIC	?GCGuildMasterQuestionSend@@YAXH@Z		; GCGuildMasterQuestionSend
PUBLIC	?GCGuildDelUserResult@@YAXHE@Z			; GCGuildDelUserResult
PUBLIC	?GCGuildViewportNowPaint@@YAXHPADPAE@Z		; GCGuildViewportNowPaint
PUBLIC	?GCGuildViewportDelNow@@YAXH@Z			; GCGuildViewportDelNow
PUBLIC	?GCManagerGuildWarEnd@@YAXPAD@Z			; GCManagerGuildWarEnd
PUBLIC	?GCManagerGuildWarSet@@YAXPAD0H@Z		; GCManagerGuildWarSet
PUBLIC	?GCGuildWarRequestSend@@YAXPADHH@Z		; GCGuildWarRequestSend
PUBLIC	?GCGuildWarEnd@@YAXHEPAD@Z			; GCGuildWarEnd
PUBLIC	?GCGuildWarRequestResult@@YAXPADHH@Z		; GCGuildWarRequestResult
PUBLIC	?GCGuildWarScore@@YAXH@Z			; GCGuildWarScore
PUBLIC	?GCGuildWarDeclare@@YAXHPAD@Z			; GCGuildWarDeclare
PUBLIC	?GCTradeOtherAdd@@YAHHEEEEEE@Z			; GCTradeOtherAdd
PUBLIC	?GCTradeOtherDel@@YAHHE@Z			; GCTradeOtherDel
PUBLIC	?CGTradeResult@@YAXHE@Z				; CGTradeResult
PUBLIC	?CGTradeCancelButtonRecv@@YAXH@Z		; CGTradeCancelButtonRecv
PUBLIC	?GCItemInventoryPutSend@@YAXHEEE@Z		; GCItemInventoryPutSend
PUBLIC	?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z	; CGItemDropRequest
PUBLIC	?GCPkLevelSend@@YAXHE@Z				; GCPkLevelSend
PUBLIC	?GCMoneySend@@YAXHK@Z				; GCMoneySend
PUBLIC	?GCEquipmentSend@@YAXH@Z			; GCEquipmentSend
PUBLIC	?GCEquipmentChange@@YAXHH@Z			; GCEquipmentChange
PUBLIC	?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z	; CGPartyDelUser
PUBLIC	?GCInventoryItemOneSend@@YAXHH@Z		; GCInventoryItemOneSend
PUBLIC	?GCItemUseSpecialTimeSend@@YAXHEH@Z		; GCItemUseSpecialTimeSend
PUBLIC	?GCItemDurSend@@YAXHEEE@Z			; GCItemDurSend
PUBLIC	?GCItemDurSend2@@YAXHEEE@Z			; GCItemDurSend2
PUBLIC	?GCInventoryItemDeleteSend@@YAXHEE@Z		; GCInventoryItemDeleteSend
PUBLIC	?GCJoinResult@@YAXEH@Z				; GCJoinResult
PUBLIC	?GCJoinSocketResult@@YAXEI@Z			; GCJoinSocketResult
PUBLIC	?GCJoinBillCheckSend@@YAXPADH@Z			; GCJoinBillCheckSend
PUBLIC	?GCUserWarehouseSend@@YAXPAVOBJECTSTRUCT@@@Z	; GCUserWarehouseSend
PUBLIC	?CGWarehouseUseEnd@@YAXH@Z			; CGWarehouseUseEnd
PUBLIC	?GCRecallMonLife@@YAXHHH@Z			; GCRecallMonLife
PUBLIC	?GCTimeViewSend@@YAXHH@Z			; GCTimeViewSend
PUBLIC	?GCGoalSend@@YAXHPADE0E@Z			; GCGoalSend
PUBLIC	?GCSkillKeySend@@YAXHPAEEEEEE@Z			; GCSkillKeySend
PUBLIC	?GCUserChaosBoxSend@@YAXPAVOBJECTSTRUCT@@H@Z	; GCUserChaosBoxSend
PUBLIC	?GCServerCmd@@YAXHEEE@Z				; GCServerCmd
PUBLIC	?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ; GCReqDevilSquareRemainTime
PUBLIC	?AllSendMsg@@YAXPAEH@Z				; AllSendMsg
PUBLIC	?AllSendSameMapMsg@@YAXPAEHE@Z			; AllSendSameMapMsg
PUBLIC	?GCSendPing@@YAXH@Z				; GCSendPing
PUBLIC	?GCWarehouseStateSend@@YAXHE@Z			; GCWarehouseStateSend
PUBLIC	?GCSendQuestInfo@@YAXHH@Z			; GCSendQuestInfo
PUBLIC	?GCSendQuestPrize@@YAXHEE@Z			; GCSendQuestPrize
PUBLIC	?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z	; GCStateInfoSend
PUBLIC	?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ; CGInventoryItemMove
PUBLIC	?GCItemMoveResultSend@@YAXHEEQAE@Z		; GCItemMoveResultSend
PUBLIC	?CGRequestQuestInfo@@YAXH@Z			; CGRequestQuestInfo
PUBLIC	?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z ; CGDuelStartRequestRecv
PUBLIC	?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ; CGDuelEndRequestRecv
PUBLIC	?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ; CGDuelOkRequestRecv
PUBLIC	?GCSendDuelScore@@YAXHH@Z			; GCSendDuelScore
PUBLIC	?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ; CGItemGetRequest
PUBLIC	?GCSendEffectInfo@@YAXHE@Z			; GCSendEffectInfo
PUBLIC	?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z		; CGUseItemRecv
PUBLIC	?_ARGB@@YAKEEEE@Z				; _ARGB
PUBLIC	?Size@CTerrainManager@@QAE?BHXZ			; CTerrainManager::Size
PUBLIC	?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ; CDevilSquare::GetState
PUBLIC	?GetRemainTime@CDevilSquare@@QAEHXZ		; CDevilSquare::GetRemainTime
PUBLIC	?GetQeustCount@CQuestInfo@@QAEHXZ		; CQuestInfo::GetQeustCount
PUBLIC	?TalkRefDel@CQeustNpcTeleport@@QAEXXZ		; CQeustNpcTeleport::TalkRefDel
PUBLIC	?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z		; PChatProc
PUBLIC	?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z	; CGChatRecv
PUBLIC	?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ; CGChatWhisperRecv
PUBLIC	?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z	; CGLiveClient
PUBLIC	?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ; CGCheckMainRecv
PUBLIC	?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z		; CGClientMsg
PUBLIC	?PEchoProc@@YAXPAEHF@Z				; PEchoProc
PUBLIC	?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z	; CSPJoinIdPassRequest
PUBLIC	?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z	; CGPCharacterCreate
PUBLIC	?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z		; CGPCharDel
PUBLIC	?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ; CGPCharacterMapJoinRequest
PUBLIC	?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z	; CGTalkRequestRecv
PUBLIC	?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z	; CGBuyRequestRecv
PUBLIC	?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z	; CGSellRequestRecv
PUBLIC	?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ; CGModifyRequestItem
PUBLIC	?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z	; CGLevelUpPointAdd
PUBLIC	?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z	; CGTeleportRecv
PUBLIC	?CGPartyList@@YAXH@Z				; CGPartyList
PUBLIC	?CGPartyListAll@@YAXH@Z				; CGPartyListAll
PUBLIC	?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ; CGPartyRequestResultRecv
PUBLIC	?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ; CGPShopReqSetItemPrice
PUBLIC	?CGPShopAnsSetItemPrice@@YAXHEE@Z		; CGPShopAnsSetItemPrice
PUBLIC	?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z	; CGPShopReqOpen
PUBLIC	?CGPShopReqClose@@YAXH@Z			; CGPShopReqClose
PUBLIC	?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ; CGPShopReqBuyList
PUBLIC	?CGPShopAnsBuyList@@YAXHHE_N@Z			; CGPShopAnsBuyList
PUBLIC	?CGPShopAnsSoldItem@@YAXHHH@Z			; CGPShopAnsSoldItem
PUBLIC	?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z ; CGPShopReqCloseDeal
PUBLIC	?CGPShopAnsDealerClosedShop@@YAXHH@Z		; CGPShopAnsDealerClosedShop
PUBLIC	?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z	; CGGuildRequestRecv
PUBLIC	?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ; CGGuildRequestResultRecv
PUBLIC	?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ; CGGuildMasterAnswerRecv
PUBLIC	?CGGuildListAll@@YAXH@Z				; CGGuildListAll
PUBLIC	?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ; CGGuildMasterInfoSave
PUBLIC	?GCGuildMasterManagerRun@@YAXH@Z		; GCGuildMasterManagerRun
PUBLIC	?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z	; CGGuildDelUser
PUBLIC	?CGGuildMasterCreateCancel@@YAXH@Z		; CGGuildMasterCreateCancel
PUBLIC	?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ; GCGuildWarRequestSendRecv
PUBLIC	?GCPartyDelUserSend@@YAXH@Z			; GCPartyDelUserSend
PUBLIC	?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ; CGTradeRequestSend
PUBLIC	?GCTradeResponseSend@@YAHEHPADGH@Z		; GCTradeResponseSend
PUBLIC	?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z	; CGTradeMoneyRecv
PUBLIC	?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ; CGTradeResponseRecv
PUBLIC	?GCTradeMoneyOther@@YAHHK@Z			; GCTradeMoneyOther
PUBLIC	?GCTradeOkButtonSend@@YAHHE@Z			; GCTradeOkButtonSend
PUBLIC	?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ; CGTradeOkButtonRecv
PUBLIC	?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z	; CGClientCloseMsg
PUBLIC	?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ; CGWarehouseMoneyInOut
PUBLIC	?GCWarehouseInventoryMoneySend@@YAXHEHH@Z	; GCWarehouseInventoryMoneySend
PUBLIC	?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ; CGChaosBoxItemMixButtonClick
PUBLIC	?CGChaosBoxUseEnd@@YAXH@Z			; CGChaosBoxUseEnd
PUBLIC	?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z	; GCSkillKeyRecv
PUBLIC	?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ; GCRegEventChipRecv
PUBLIC	?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ; GCGetMutoNumRecv
PUBLIC	?GCUseEndEventChipRescv@@YAXH@Z			; GCUseEndEventChipRescv
PUBLIC	?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ; GCUseRenaChangeZenRecv
PUBLIC	?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; GCReqmoveDevilSquare
PUBLIC	?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ; GCWarehouseRecivePassword
PUBLIC	?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z	; GCPingSendRecv
PUBLIC	?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ; GCPacketCheckSumRecv
PUBLIC	?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z	; CGSetQuestState
PUBLIC	?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; CGRequestEnterBloodCastle
PUBLIC	?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ; CGRequestEnterChaosCastle
PUBLIC	?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ; CGRequestRepositionUserInChaosCastle
PUBLIC	?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ; CGRequestEventEnterCount
PUBLIC	?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ; CGRequestLottoRegister
PUBLIC	?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ; CGTargetTeleportRecv
PUBLIC	?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ; CGRequestPetItemCommand
PUBLIC	?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ; CGRequestPetItemInfo
PUBLIC	?CGCloseWindow@@YAXH@Z				; CGCloseWindow
PUBLIC	?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z	; PacketCheckTime
PUBLIC	?DataEncryptCheck@@YAHHEH@Z			; DataEncryptCheck
PUBLIC	?TestSend@@YAXXZ				; TestSend
PUBLIC	?EncryptCheckSumKey@@YAGG@Z			; EncryptCheckSumKey
PUBLIC	?GCServerMsgSend@@YAXEH@Z			; GCServerMsgSend
PUBLIC	?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z ; CSPJoinIdPassRequestTEST
PUBLIC	?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z	; GetNeedMoneyItemDurRepaire
PUBLIC	?ItemDurRepaire@@YAXPAVOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd@ ; `string'
PUBLIC	??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??ProtocolCore@@YAXEPAEHHHH@Z@4JA ; `ProtocolCore'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5H@ ; `string'
PUBLIC	??_C@_0P@KNPEEFN@TEST?5Data?5Send@		; `string'
PUBLIC	??_C@_0O@DINGPLDD@218?4234?476?433@		; `string'
PUBLIC	??_C@_0CI@PHFKNJAD@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSum?9Ex@ ; `string'
PUBLIC	??_C@_0CM@ECHKHDMC@error?9L1?5?3?5CheckSum?9Exe?5error?5?$CF@ ; `string'
PUBLIC	??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_06CPENAAMN@?$FL?$CFs?$FN?3?5@		; `string'
PUBLIC	??_C@_0M@JGNMDCCD@?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG@ ; `string'
PUBLIC	?__LINE__Var@?0??CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z@4JA ; `CSPJoinIdPassRequest'::`1'::__LINE__Var
PUBLIC	??_C@_0CE@NFIPADMP@JOIN?5ERROR?5?9?5VERSION?3?5?$CFs?5SERIAL@ ; `string'
PUBLIC	??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs@ ; `string'
PUBLIC	??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd@	; `string'
PUBLIC	??_C@_04FLFDNKBN@m321@				; `string'
PUBLIC	??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs@ ; `string'
PUBLIC	??_C@_0EM@KAGGFAIG@?0?5?$FLUserSelClose?$FN?5Go?5Exit?0?5Accou@ ; `string'
PUBLIC	??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0FC@GOGPDPOG@?0?5?$FLUserSelClose?$FN?5Go?5ServerList?0@ ; `string'
PUBLIC	??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0FC@IHIAOFPA@?0?5?$FLUserSelClose?$FN?5Go?5CharSelect?0@ ; `string'
PUBLIC	??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50@ ; `string'
PUBLIC	??_C@_0BE@EJDMDEO@Client?5HackCheck?5?$CFu@	; `string'
PUBLIC	??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN@ ; `string'
PUBLIC	??_C@_0CN@BLKDKNKC@?$LM?$KN?$LJ?v?$LK?P?G?R?5?$LB?b?$LA?$KD?$LP?$KB?$LE?B?5?D?$LD?$LI?$KP?E?M?$LI?$KG?5?$LL?$PN?$LM?$LK@ ; `string'
PUBLIC	??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5cre@ ; `string'
PUBLIC	??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cr@ ; `string'
PUBLIC	??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs@ ; `string'
PUBLIC	??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempt@ ; `string'
PUBLIC	??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempt@ ; `string'
PUBLIC	??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs@ ; `string'
PUBLIC	??_C@_0EH@JPGCOFPC@?0?5?$FLG?9?$DOD?5Req?5MapJoin?$FN?5CharSelect@ ; `string'
PUBLIC	??_C@_0BI@PHONBDAL@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ ; `string'
PUBLIC	??_C@_0BI@LJJFCIF@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z@4JA ; `CGItemGetRequest'::`1'::__LINE__Var
PUBLIC	??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@ ; `string'
PUBLIC	??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fai@ ; `string'
PUBLIC	??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@	; `string'
PUBLIC	??_C@_0DC@DNFDPMM@?$FLQuest?$FN?5Too?5many?5have?5quest?5ite@ ; `string'
PUBLIC	??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magi@ ; `string'
PUBLIC	??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kal@ ; `string'
PUBLIC	??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	?__LINE__Var@?0??CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z@4JA ; `CGItemDropRequest'::`1'::__LINE__Var
PUBLIC	??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fa@ ; `string'
PUBLIC	??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd@		; `string'
PUBLIC	??_C@_04BGCMBJDA@Item@				; `string'
PUBLIC	??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLIte@ ; `string'
PUBLIC	??_C@_0FL@HPOJPJGH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5S@ ; `string'
PUBLIC	??_C@_0FM@DGEGEEP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5F@ ; `string'
PUBLIC	??_C@_0FM@EBLAMMBK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5H@ ; `string'
PUBLIC	??_C@_0FK@MPNDPHHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5G@ ; `string'
PUBLIC	??_C@_0FM@IGKKOJBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5S@ ; `string'
PUBLIC	??_C@_0FK@PGPEHJJI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ ; `string'
PUBLIC	??_C@_0FO@JEPLEEGL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ ; `string'
PUBLIC	??_C@_0FO@PNDHLIGG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ ; `string'
PUBLIC	??_C@_0FP@PHLHAFBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ ; `string'
PUBLIC	??_C@_0GA@JIKHBPIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ ; `string'
PUBLIC	??_C@_0GA@CCPCBLJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ ; `string'
PUBLIC	??_C@_0FO@FJBOPNFK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5D@ ; `string'
PUBLIC	??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Ma@ ; `string'
PUBLIC	?__LINE__Var@?0??CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z@4JA ; `CGInventoryItemMove'::`1'::__LINE__Var
PUBLIC	??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3@ ; `string'
PUBLIC	??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Ch@ ; `string'
PUBLIC	??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing@ ; `string'
PUBLIC	??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Da@ ; `string'
PUBLIC	??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainer@ ; `string'
PUBLIC	??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Wa@ ; `string'
PUBLIC	??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tr@ ; `string'
PUBLIC	??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventor@ ; `string'
PUBLIC	??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHous@ ; `string'
PUBLIC	?__LINE__Var@?0??CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z@4JA ; `CGTalkRequestRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5@ ; `string'
PUBLIC	??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSh@ ; `string'
PUBLIC	??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box@ ; `string'
PUBLIC	?__LINE__Var@?0??CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z@4JA ; `CGBuyRequestRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN@ ; `string'
PUBLIC	?__LINE__Var@?0??CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z@4JA ; `CGSellRequestRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fa@ ; `string'
PUBLIC	??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSel@ ; `string'
PUBLIC	??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5@	; `string'
PUBLIC	?__LINE__Var@?0??CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z@4JA ; `CGTradeRequestSend'::`1'::__LINE__Var
PUBLIC	??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0EH@JLPPNLGF@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?5n@ ; `string'
PUBLIC	??_C@_0CA@DGNFGBFP@?$FLPVP?5Event?$FN?5Accion?5no?5permitida@ ; `string'
PUBLIC	??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5F@ ; `string'
PUBLIC	?__LINE__Var@?0??CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z@4JA ; `CGTradeResponseRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5@ ; `string'
PUBLIC	??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5T@ ; `string'
PUBLIC	??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd@	; `string'
PUBLIC	?__LINE__Var@?0??CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z@4JA ; `CGTradeMoneyRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept@ ; `string'
PUBLIC	?__LINE__Var@?0??CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z@4JA ; `CGPShopReqSetItemPrice'::`1'::__LINE__Var
PUBLIC	??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CO@ ; `string'
PUBLIC	??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CH@ ; `string'
PUBLIC	??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5@ ; `string'
PUBLIC	??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5P@ ; `string'
PUBLIC	??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5D@ ; `string'
PUBLIC	??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSh@ ; `string'
PUBLIC	??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5re@ ; `string'
PUBLIC	??_C@_0DM@LPICNFPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Person@ ; `string'
PUBLIC	??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5P@ ; `string'
PUBLIC	??_C@_0FD@OAAFOEHL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5@ ; `string'
PUBLIC	?__LINE__Var@?0??CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z@4JA ; `CGPShopReqOpen'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t@ ; `string'
PUBLIC	??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSt@ ; `string'
PUBLIC	??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknow@ ; `string'
PUBLIC	??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transa@ ; `string'
PUBLIC	??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5@ ; `string'
PUBLIC	??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5@ ; `string'
PUBLIC	??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5C@ ; `string'
PUBLIC	??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop@ ; `string'
PUBLIC	?__LINE__Var@?0??CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z@4JA ; `CGPShopReqBuyList'::`1'::__LINE__Var
PUBLIC	??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ ; `string'
PUBLIC	??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ ; `string'
PUBLIC	??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ ; `string'
PUBLIC	??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ ; `string'
PUBLIC	??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ ; `string'
PUBLIC	??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ ; `string'
PUBLIC	??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5P@ ; `string'
PUBLIC	??_C@_0N@OAHJEEKI@ITEM?5TYPE?3?$CFd@		; `string'
PUBLIC	?__LINE__Var@?0??CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z@4JA ; `CGPShopReqBuyItem'::`1'::__LINE__Var
PUBLIC	??_C@_0BG@GGOILNKD@?4?4?2data?2QueryShop?4ini@	; `string'
PUBLIC	??_C@_0EK@BHAABMKG@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@ ; `string'
PUBLIC	??_C@_0O@HGOOMGKG@OFFTRADERESTA@		; `string'
PUBLIC	??_C@_0BA@FBHJCJB@UPDATE?5OFFTRADE@		; `string'
PUBLIC	??_C@_0EK@BCLMBCOI@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@ ; `string'
PUBLIC	??_C@_0N@HPCIFBAH@OFFTRADESUMA@			; `string'
PUBLIC	??_C@_0BO@BEPKGPIF@?$FLBOT?5STORE?$FN?5Necesitas?5?$CFd?5Cash@ ; `string'
PUBLIC	??_C@_0CI@DPKGHCGP@?$FLBOT?5STORE?$FN?5Actualmente?5tienes?5@ ; `string'
PUBLIC	??_C@_0BO@FNEEFLNP@?$FLBOT?5STORE?$FN?5Te?5quedan?5?$CFd?5Cash@ ; `string'
PUBLIC	??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSh@ ; `string'
PUBLIC	??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0BE@BABKIKBE@TIENDAPERSONALRESTA@		; `string'
PUBLIC	??_C@_0BG@CENNGABF@UPDATE?5TIENDAPERSONAL@	; `string'
PUBLIC	??_C@_0BD@INFPCJNN@TIENDAPERSONALSUMA@		; `string'
PUBLIC	??_C@_0CE@FKIEGGCJ@?$FLTienda?5Personal?$FN?5Necesitas?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CO@INIPKDON@?$FLTienda?5Personal?$FN?5Actualmente?5t@ ; `string'
PUBLIC	??_C@_0CE@BDDKFCHD@?$FLTienda?5Personal?$FN?5Te?5quedan?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0FL@OHDLELPO@?$FLCOMPRA?$FN?5Cuenta?3?$FL?$CFs?$FN?5Usuario?3?$FL?$CF@ ; `string'
PUBLIC	??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ ; `string'
PUBLIC	??_C@_0JC@NLGCBMPF@?$FLOffTrade?$FN?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item@ ; `string'
PUBLIC	??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items@ ; `string'
PUBLIC	??_C@_0EH@LCEBGPEH@?$FLHACKTOOL?$FN?5?3?5NPC?9PartyRequest?5n@ ; `string'
PUBLIC	??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ ; `string'
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs@			; `string'
PUBLIC	??_C@_0EP@FDAKNNLI@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?$CIR@ ; `string'
PUBLIC	?__LINE__Var@?0??CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z@4JA ; `CGPartyDelUser'::`1'::__LINE__Var
PUBLIC	??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs@	; `string'
PUBLIC	??_C@_0P@GAPFACKC@User?5Not?5found@		; `string'
PUBLIC	??_C@_05DIALNFFA@?$CFs?5?$CFd@			; `string'
PUBLIC	??_C@_0EH@LLMHNLJP@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?5n@ ; `string'
PUBLIC	??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3@ ; `string'
PUBLIC	??_C@_0EP@POEHMBEF@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?$CIr@ ; `string'
PUBLIC	??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismis@ ; `string'
PUBLIC	??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5@ ; `string'
PUBLIC	??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildM@ ; `string'
PUBLIC	??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target@ ; `string'
PUBLIC	??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd@		; `string'
PUBLIC	??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd@	; `string'
PUBLIC	?__LINE__Var@?0??CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z@4JA ; `CGWarehouseMoneyInOut'::`1'::__LINE__Var
PUBLIC	??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventor@ ; `string'
PUBLIC	??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHous@ ; `string'
PUBLIC	?__LINE__Var@?0??CGWarehouseUseEnd@@YAXH@Z@4JA	; `CGWarehouseUseEnd'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z@4JA ; `CGChaosBoxItemMixButtonClick'::`1'::__LINE__Var
PUBLIC	??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos@ ; `string'
PUBLIC	??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type@ ; `string'
PUBLIC	?__LINE__Var@?0??CGChaosBoxUseEnd@@YAXH@Z@4JA	; `CGChaosBoxUseEnd'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??PMoveProc@@YAXPAUPMSG_MOVE@@H@Z@4JA ; `PMoveProc'::`1'::__LINE__Var
PUBLIC	??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5@ ; `string'
PUBLIC	??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5@ ; `string'
PUBLIC	?__LINE__Var@?0??RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z@4JA ; `RecvPositionSetProc'::`1'::__LINE__Var
PUBLIC	??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5err@ ; `string'
PUBLIC	?__LINE__Var@?0??CGAttack@@YAXPAUPMSG_ATTACK@@H@Z@4JA ; `CGAttack'::`1'::__LINE__Var
PUBLIC	??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CF@ ; `string'
PUBLIC	??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCount@ ; `string'
PUBLIC	??_C@_0DN@GAMOBCPD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wro@ ; `string'
PUBLIC	??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5@ ; `string'
PUBLIC	?__LINE__Var@?0??CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z@4JA ; `CGActionRecv'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z@4JA ; `CGMagicAttack'::`1'::__LINE__Var
PUBLIC	??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd@ ; `string'
PUBLIC	??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Atta@ ; `string'
PUBLIC	??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5@ ; `string'
PUBLIC	??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5No@ ; `string'
PUBLIC	?__LINE__Var@?0??CGBeattackRecv@@YAXPAEHH@Z@4JA	; `CGBeattackRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@	; `string'
PUBLIC	??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5cast@ ; `string'
PUBLIC	??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wro@ ; `string'
PUBLIC	??_C@_0DN@EOJDOJAH@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5K@ ; `string'
PUBLIC	??_C@_0DJ@JFIBGMNL@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5@ ; `string'
PUBLIC	??_C@_0DF@GMGPOAFD@Magic?5Attack3?5?3?5?$CFd?0?5serial?5?$DN?5?$CFd@ ; `string'
PUBLIC	??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi@ ; `string'
PUBLIC	?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA ; `CGUseItemRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5ret@ ; `string'
PUBLIC	??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseT@ ; `string'
PUBLIC	??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed@ ; `string'
PUBLIC	??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invent@ ; `string'
PUBLIC	??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRe@ ; `string'
PUBLIC	??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUse@ ; `string'
PUBLIC	??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CF@ ; `string'
PUBLIC	??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??GCManaSend@@YAXHFEEG@Z@4JA	; `GCManaSend'::`1'::__LINE__Var
PUBLIC	??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z@4JA ; `GCReqmoveDevilSquare'::`1'::__LINE__Var
PUBLIC	??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd@		; `string'
PUBLIC	??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5@ ; `string'
PUBLIC	??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@ ; `string'
PUBLIC	??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@ ; `string'
PUBLIC	??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@ ; `string'
PUBLIC	??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@ ; `string'
PUBLIC	??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0DI@OGLBFJCJ@?$FLPK?5User?$FN?$FLChaosCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0BG@FMIMJBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ping?5?$DN?5?$CFd?5ms@ ; `string'
PUBLIC	??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5@ ; `string'
PUBLIC	??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5@ ; `string'
PUBLIC	??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@ ; `string'
PUBLIC	??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@ ; `string'
PUBLIC	??_C@_0DO@ODJBOBMD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@ ; `string'
PUBLIC	??_C@_0DK@EFAFIPG@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5Stone@ ; `string'
PUBLIC	??_C@_0DF@CGCEIIIK@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5Even@ ; `string'
PUBLIC	??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y@ ; `string'
PUBLIC	??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mu@ ; `string'
PUBLIC	?__LINE__Var@?0??GCUseEndEventChipRescv@@YAXH@Z@4JA ; `GCUseEndEventChipRescv'::`1'::__LINE__Var
PUBLIC	??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Ch@ ; `string'
PUBLIC	??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Ch@ ; `string'
PUBLIC	?__LINE__Var@?0??CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z@4JA ; `CGRequestEnterBloodCastle'::`1'::__LINE__Var
PUBLIC	??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	?__LINE__Var@?0??CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z@4JA ; `CGRequestEnterChaosCastle'::`1'::__LINE__Var
PUBLIC	??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Regist@ ; `string'
PUBLIC	?__LINE__Var@?0??CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z@4JA ; `CGDuelStartRequestRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5St@ ; `string'
PUBLIC	?__LINE__Var@?0??CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z@4JA ; `CGDuelEndRequestRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0CG@KCMDMGAG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL?$CF@ ; `string'
PUBLIC	?__LINE__Var@?0??CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z@4JA ; `CGRequestPetItemCommand'::`1'::__LINE__Var
PUBLIC	??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z@4JA ; `CGRequestPetItemInfo'::`1'::__LINE__Var
PUBLIC	??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ ; `string'
PUBLIC	??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ ; `string'
PUBLIC	??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ ; `string'
PUBLIC	??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ ; `string'
PUBLIC	??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40a00000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_rand:PROC
EXTRN	_sqrt:PROC
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?Convert@CItem@@QAEXHEEEEEE@Z:PROC		; CItem::Convert
EXTRN	?Value@CItem@@QAEXXZ:PROC			; CItem::Value
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?PetValue@CItem@@QAEXXZ:PROC			; CItem::PetValue
EXTRN	?IsClass@CItem@@QAEHDH@Z:PROC			; CItem::IsClass
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?GetNumber@CItem@@QAEKXZ:PROC			; CItem::GetNumber
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?ItemByteConvert@@YAXPAEHEEEEEEE@Z:PROC		; ItemByteConvert
EXTRN	?HasItemDurability@@YAHH@Z:PROC			; HasItemDurability
EXTRN	?GetAllRepairItemRate@@YAMH@Z:PROC		; GetAllRepairItemRate
EXTRN	?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z:PROC	; GetItemAttr
EXTRN	?IsMagic@CMagicInf@@QAEHXZ:PROC			; CMagicInf::IsMagic
EXTRN	?DataSocketSend@CwsGameServer@@QAEHIPADH@Z:PROC	; CwsGameServer::DataSocketSend
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z:PROC ; CGuildClass::SearchGuild
EXTRN	?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z:PROC	; gObjCheckSerial0ItemList
EXTRN	?gCheckSkillDistance@@YAHHHH@Z:PROC		; gCheckSkillDistance
EXTRN	?CheckCombo@CComboAttack@@QAEHHH@Z:PROC		; CComboAttack::CheckCombo
EXTRN	?gObjUserKill@@YAXH@Z:PROC			; gObjUserKill
EXTRN	?gObjJoominCheck@@YAHHPAD@Z:PROC		; gObjJoominCheck
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
EXTRN	?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
EXTRN	?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@H@Z:PROC	; gObjIsConnected
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
EXTRN	?gObjIsGamePlaing@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjIsGamePlaing
EXTRN	?gObjCheckXYMapTile@@YAHPAVOBJECTSTRUCT@@H@Z:PROC ; gObjCheckXYMapTile
EXTRN	?PShop_CheckInventoryEmpty@@YA_NF@Z:PROC	; PShop_CheckInventoryEmpty
EXTRN	?gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z:PROC ; gObjLevelUpPointAdd
EXTRN	?LevelSmallConvert@@YAEHH@Z:PROC		; LevelSmallConvert
EXTRN	?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z:PROC ; gObjInventoryInsertItem
EXTRN	?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z:PROC ; gObjOnlyInventoryInsertItem
EXTRN	?gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z:PROC ; gObjInventoryInsertItemTemp
EXTRN	?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z:PROC ; gObjShopBuyInventoryInsertItem
EXTRN	?gObjSearchItem@@YAHPAVOBJECTSTRUCT@@HHH@Z:PROC	; gObjSearchItem
EXTRN	?gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z:PROC ; gObjSearchItemMinus
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?gObjInventoryItemSet_PShop@@YAXHHE@Z:PROC	; gObjInventoryItemSet_PShop
EXTRN	?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z:PROC ; gObjAttack
EXTRN	?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjTeleportMagicUse@@YAXHEE@Z:PROC		; gObjTeleportMagicUse
EXTRN	?gObjMagicManaUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicManaUse
EXTRN	?gObjMagicBPUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicBPUse
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?gObjMoveDataLoadingOK@@YAXH@Z:PROC		; gObjMoveDataLoadingOK
EXTRN	?gObjTeleport@@YAXHHHH@Z:PROC			; gObjTeleport
EXTRN	?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z:PROC ; gObjMagicAdd
EXTRN	?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagic
EXTRN	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z:PROC ; gObjGetMagicSearch
EXTRN	?gObjTradeCancel@@YAXH@Z:PROC			; gObjTradeCancel
EXTRN	?gObjTradeOkButton@@YAXH@Z:PROC			; gObjTradeOkButton
EXTRN	?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z:PROC	; gObjInventoryMoveItem
EXTRN	?gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z:PROC ; gObjTradeInventoryMove
EXTRN	?gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z:PROC ; gObjTradeTradeMove
EXTRN	?gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z:PROC ; gObjInventoryTradeMove
EXTRN	?gObjInventoryTrans@@YAHH@Z:PROC		; gObjInventoryTrans
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?gObjItemLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z:PROC	; gObjItemLevelUp
EXTRN	?gObjItemRandomLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z:PROC ; gObjItemRandomLevelUp
EXTRN	?gObjItemRandomOption3Up@@YAHPAVOBJECTSTRUCT@@HH@Z:PROC ; gObjItemRandomOption3Up
EXTRN	?gObjUseDrink@@YAXPAVOBJECTSTRUCT@@H@Z:PROC	; gObjUseDrink
EXTRN	?gObjCloseSet@@YAXHH@Z:PROC			; gObjCloseSet
EXTRN	?gObjPositionCheck@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjPositionCheck
EXTRN	?gObjGuildMasterCapacityTest@@YAHPAVOBJECTSTRUCT@@@Z:PROC ; gObjGuildMasterCapacityTest
EXTRN	?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z:PROC ; gObjGuildWarEndSend
EXTRN	?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z:PROC ; gObjGuildWarEnd
EXTRN	?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z:PROC ; gObjInventorySearchSerialNumber
EXTRN	?gObjItemTextSave@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; gObjItemTextSave
EXTRN	?gObjWarehouseTextSave@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; gObjWarehouseTextSave
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
EXTRN	?IsDuelEnable@@YA_NH@Z:PROC			; IsDuelEnable
EXTRN	?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; gObjClearViewport
EXTRN	?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z:PROC	; gObjCanItemTouch
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?gObjCheckTeleportArea@@YAHHEE@Z:PROC		; gObjCheckTeleportArea
EXTRN	?gObjCheckAttackArea@@YAHHH@Z:PROC		; gObjCheckAttackArea
EXTRN	?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjDuelCheck
EXTRN	?gObjFind10EventChip@@YAHH@Z:PROC		; gObjFind10EventChip
EXTRN	?gObjSetPosition@@YAXHHH@Z:PROC			; gObjSetPosition
EXTRN	?gObjGetItemCountInIventory@@YAHHHHH@Z:PROC	; gObjGetItemCountInIventory
EXTRN	?gObjGetItemCountInIventory@@YAHHH@Z:PROC	; gObjGetItemCountInIventory
EXTRN	?gObjUseCircle@@YAXHH@Z:PROC			; gObjUseCircle
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
EXTRN	?gObjFixInventoryPointer@@YA_NH@Z:PROC		; gObjFixInventoryPointer
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
EXTRN	?SendNoticeToUser@TNotice@@SAXHPAX@Z:PROC	; TNotice::SendNoticeToUser
EXTRN	?ExecFormat@CDataBase@@QAA_NPBDZZ:PROC		; CDataBase::ExecFormat
EXTRN	?KCredits@CManager@@QAEHPAD@Z:PROC		; CManager::KCredits
EXTRN	?Pshopnpc@CManager@@QAEHPAD@Z:PROC		; CManager::Pshopnpc
EXTRN	?SendPostMessage@CPostSystem@@QAEXHPAD@Z:PROC	; CPostSystem::SendPostMessage
EXTRN	?CustomLogcash@LogSystem@@SAXPAD@Z:PROC		; LogSystem::CustomLogcash
EXTRN	?Closeoffafk@COFFSystem@@QAEXPAD@Z:PROC		; COFFSystem::Closeoffafk
EXTRN	?Closeofftrade@COFFtrade@@QAEXPAD@Z:PROC	; COFFtrade::Closeofftrade
EXTRN	?CGPShopReqBuyItemTest@CPShop@@SAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z:PROC ; CPShop::CGPShopReqBuyItemTest
EXTRN	?BuxConvert@@YAXPADH@Z:PROC			; BuxConvert
EXTRN	?ChatRecv@CHAT_COMMANDS@@QAE_NPAUPMSG_CHATDATA@@H@Z:PROC ; CHAT_COMMANDS::ChatRecv
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
EXTRN	?PHeadSubSetBE@@YAXPAEEEH@Z:PROC		; PHeadSubSetBE
EXTRN	?GCItemListSend@@YAXH@Z:PROC			; GCItemListSend
EXTRN	?DataServerGetCharListRequest@@YAXF@Z:PROC	; DataServerGetCharListRequest
EXTRN	?GDUserItemSave@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; GDUserItemSave
EXTRN	?JGCharacterCreateFailSend@@YAXHPAD@Z:PROC	; JGCharacterCreateFailSend
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z:PROC	; ItemSerialCreateSend
EXTRN	?GDGetWarehouseList@@YAXHPAD@Z:PROC		; GDGetWarehouseList
EXTRN	?GDSetWarehouseList@@YAXH@Z:PROC		; GDSetWarehouseList
EXTRN	?DGOptionDataSend@@YAXHPADPAEEEEEE@Z:PROC	; DGOptionDataSend
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?ItemGive@MapClass@@QAEHHH_N@Z:PROC		; MapClass::ItemGive
EXTRN	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z:PROC	; MapClass::ItemDrop
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?GetWarehouseUsedHowMuch@@YAHHH@Z:PROC		; GetWarehouseUsedHowMuch
EXTRN	?AddCash@CWhisperCash@@QAEHPAD@Z:PROC		; CWhisperCash::AddCash
EXTRN	?IsParty@PartyClass@@QAEHH@Z:PROC		; PartyClass::IsParty
EXTRN	?Create@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::Create
EXTRN	?Destroy@PartyClass@@QAEHH@Z:PROC		; PartyClass::Destroy
EXTRN	?Add@PartyClass@@QAEHHHHH@Z:PROC		; PartyClass::Add
EXTRN	?Delete@PartyClass@@QAEXHH@Z:PROC		; PartyClass::Delete
EXTRN	?GetCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetCount
EXTRN	?GetIndexUser@PartyClass@@QAEHHHAAH0@Z:PROC	; PartyClass::GetIndexUser
EXTRN	?GetPartyCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetPartyCount
EXTRN	?GetIndex@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::GetIndex
EXTRN	?Paint@PartyClass@@QAEXH@Z:PROC			; PartyClass::Paint
EXTRN	?LuckyBoxOpenEven@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; LuckyBoxOpenEven
EXTRN	?StarOfXMasOpenEven@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; StarOfXMasOpenEven
EXTRN	?FireCrackerOpenEven@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; FireCrackerOpenEven
EXTRN	?HeartOfLoveOpenEven@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; HeartOfLoveOpenEven
EXTRN	?DarkLordHeartItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; DarkLordHeartItemBoxOpen
EXTRN	?GoldMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; GoldMedalOpenEven
EXTRN	?SilverMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; SilverMedalOpenEven
EXTRN	?EventChipOpenEven@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; EventChipOpenEven
EXTRN	?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z:PROC ; EledoradoBoxOpenEven
EXTRN	?RingEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; RingEventItemBoxOpen
EXTRN	?FriendShipItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; FriendShipItemBoxOpen
EXTRN	?EGReqBloodCastleEnterCount@@YAXH@Z:PROC	; EGReqBloodCastleEnterCount
EXTRN	?DataSendEventChip@@YAXPADH@Z:PROC		; DataSendEventChip
EXTRN	?ManagementProc@CGMMng@@QAEHPAVOBJECTSTRUCT@@PADH@Z:PROC ; CGMMng::ManagementProc
EXTRN	?BattleInfoSend@CGMMng@@QAEXPADE0E@Z:PROC	; CGMMng::BattleInfoSend
EXTRN	?DataSend@CGMMng@@QAEXPAEH@Z:PROC		; CGMMng::DataSend
EXTRN	?NpcTalk@@YAHPAVOBJECTSTRUCT@@0@Z:PROC		; NpcTalk
EXTRN	?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z:PROC ; CMagicDamage::SkillGetRequireClass
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?Close@cOffExp@@QAEXPAD@Z:PROC			; cOffExp::Close
EXTRN	?FriendListRequest@@YAXH@Z:PROC			; FriendListRequest
EXTRN	?FriendDelRequest@@YAXPAUPMSG_FRIEND_DEL_REQ@@H@Z:PROC ; FriendDelRequest
EXTRN	?FriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_REQ@@H@Z:PROC ; FriendAddRequest
EXTRN	?WaitFriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_SIN_RESULT@@H@Z:PROC ; WaitFriendAddRequest
EXTRN	?FriendMemoSend@@YAXPAUPMSG_FRIEND_MEMO@@H@Z:PROC ; FriendMemoSend
EXTRN	?FriendMemoReadReq@@YAXPAUPMSG_FRIEND_READ_MEMO_REQ@@H@Z:PROC ; FriendMemoReadReq
EXTRN	?FriendMemoDelReq@@YAXPAUPMSG_FRIEND_MEMO_DEL_REQ@@H@Z:PROC ; FriendMemoDelReq
EXTRN	?FriendMemoListReq@@YAXH@Z:PROC			; FriendMemoListReq
EXTRN	?FriendChatRoomCreateReq@@YAXPAUPMSG_FRIEND_ROOMCREATE_REQ@@H@Z:PROC ; FriendChatRoomCreateReq
EXTRN	?FriendRoomInvitationReq@@YAXPAUPMSG_ROOM_INVITATION@@H@Z:PROC ; FriendRoomInvitationReq
EXTRN	?FriendStateClientRecv@@YAXPAUPMSG_FRIEND_STATE_C@@H@Z:PROC ; FriendStateClientRecv
EXTRN	?GDGuildCreateSend@@YAXHPAD0PAE@Z:PROC		; GDGuildCreateSend
EXTRN	?GDGuildDestroySend@@YAXHPAD0@Z:PROC		; GDGuildDestroySend
EXTRN	?GDGuildMemberAdd@@YAXHPAD0@Z:PROC		; GDGuildMemberAdd
EXTRN	?GDGuildMemberDel@@YAXHPAD0@Z:PROC		; GDGuildMemberDel
EXTRN	?GDGuildNoticeSave@@YAXPAD0@Z:PROC		; GDGuildNoticeSave
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?DefaultChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::DefaultChaosMix
EXTRN	?DevilSquareItemChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::DevilSquareItemChaosMix
EXTRN	?PlusItemLevelChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@H@Z:PROC ; CMixSystem::PlusItemLevelChaosMix
EXTRN	?PegasiaChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::PegasiaChaosMix
EXTRN	?CircleChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::CircleChaosMix
EXTRN	?WingChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::WingChaosMix
EXTRN	?BloodCastleItemChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::BloodCastleItemChaosMix
EXTRN	?DarkHorseChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::DarkHorseChaosMix
EXTRN	?DarkSpiritChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::DarkSpiritChaosMix
EXTRN	?IsMember@CConMember@@QAEHPAD@Z:PROC		; CConMember::IsMember
EXTRN	?InCheck@NSerialCheck@@QAEHE@Z:PROC		; NSerialCheck::InCheck
EXTRN	?GetSerial@NSerialCheck@@QAEHXZ:PROC		; NSerialCheck::GetSerial
EXTRN	?IncObjCount@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::IncObjCount
EXTRN	?GetObjCount@CDevilSquareGround@@QAEJXZ:PROC	; CDevilSquareGround::GetObjCount
EXTRN	?gCheckBlankBattleGround@@YAHXZ:PROC		; gCheckBlankBattleGround
EXTRN	?gBattleGroundEnable@@YAXHH@Z:PROC		; gBattleGroundEnable
EXTRN	?GetBattleTeamName@@YAPADHH@Z:PROC		; GetBattleTeamName
EXTRN	?GetBattleTeamScore@@YAHHH@Z:PROC		; GetBattleTeamScore
EXTRN	?BattleSoccerGoalEnd@@YAXH@Z:PROC		; BattleSoccerGoalEnd
EXTRN	?AddExperience@CBloodCastle@@QAE_NHH@Z:PROC	; CBloodCastle::AddExperience
EXTRN	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDeleteQuestItem
EXTRN	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDropQuestItem
EXTRN	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z:PROC ; CBloodCastle::SendNoticeMessage
EXTRN	?EnterUserBridge@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::EnterUserBridge
EXTRN	?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z:PROC	; CBloodCastle::CheckUsersOnConnect
EXTRN	?GetCurrentState@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetCurrentState
EXTRN	?GetRemainTime@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetRemainTime
EXTRN	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::CheckEnterLevel
EXTRN	?CheckCanEnter@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckCanEnter
EXTRN	?CheckPlayStart@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckPlayStart
EXTRN	?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z:PROC ; CBloodCastle::CheckQuestItemSerial
EXTRN	?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::EnterUserChaosCastle
EXTRN	?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::LeaveUserChaosCastle
EXTRN	?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetUserLevelToEnter
EXTRN	?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::CheckUserEnterMoney
EXTRN	?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z:PROC	; CChaosCastle::PayUserEnterMoney
EXTRN	?GetCurrentState@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurrentState
EXTRN	?GetCurEnteredUser@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurEnteredUser
EXTRN	?GetRemainTime@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetRemainTime
EXTRN	?CheckCanEnter@CChaosCastle@@QAE_NH@Z:PROC	; CChaosCastle::CheckCanEnter
EXTRN	?ObjSetPosition@CChaosCastle@@QAEHHHH@Z:PROC	; CChaosCastle::ObjSetPosition
EXTRN	?CheckWearingMOPH@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::CheckWearingMOPH
EXTRN	?IsInGate@CGate@@QAEHHH@Z:PROC			; CGate::IsInGate
EXTRN	?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z:PROC ; CQuestInfo::GetQuestInfo
EXTRN	?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestState
EXTRN	?GetQuestStateBYTE@CQuestInfo@@QAEEPAVOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestStateBYTE
EXTRN	?SetQuestState@CQuestInfo@@QAEEPAVOBJECTSTRUCT@@HH@Z:PROC ; CQuestInfo::SetQuestState
EXTRN	?Send@CSendHackLog@@QAEXHEPAD@Z:PROC		; CSendHackLog::Send
EXTRN	?SendData@CSendHackLog@@QAEHPAEK@Z:PROC		; CSendHackLog::SendData
EXTRN	?SpeedHackCheck@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SpeedHackCheck
EXTRN	?EnableSkill@CObjUseSkill@@QAEHE@Z:PROC		; CObjUseSkill::EnableSkill
EXTRN	?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z:PROC ; CObjUseSkill::MaGumSkillDefenseDown
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z:PROC ; CMultiAttackHackCheck::CheckPenetrationSkill
EXTRN	?AddCheckSum@CPacketCheckSum@@QAEXHHK@Z:PROC	; CPacketCheckSum::AddCheckSum
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjMonsterRegen
EXTRN	?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z:PROC	; CKalimaGate::CreateKalimaGate
EXTRN	?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z:PROC ; CKalimaGate::CheckOverlapKundunMark
EXTRN	?ChangeCommand@CDarkSpirit@@QAEXHH@Z:PROC	; CDarkSpirit::ChangeCommand
EXTRN	?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z:PROC ; gSetBattleTeamMaster
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__except_handler4:PROC
EXTRN	__local_unwind4:PROC
EXTRN	_memset:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddL@@3P6AXPADZZA:DWORD			; LogAddL
EXTRN	?LogAddHeadHex@@3P6AXPAD0H@ZA:DWORD		; LogAddHeadHex
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?LogAddTD_TempLog@@3P6AXPADZZA:DWORD		; LogAddTD_TempLog
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?gComboAttack@@3VCComboAttack@@A:DWORD		; gComboAttack
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?RoadPathTable@@3PAFA:BYTE			; RoadPathTable
EXTRN	?Manager@@3VCManager@@A:BYTE			; Manager
EXTRN	?g_GlobalConfig@@3VCGlobalConfig@@A:BYTE	; g_GlobalConfig
EXTRN	?g_PostSystem@@3VCPostSystem@@A:BYTE		; g_PostSystem
EXTRN	?g_TerrainManager@@3VCTerrainManager@@A:BYTE	; g_TerrainManager
EXTRN	?OFFSystem@@3VCOFFSystem@@A:BYTE		; OFFSystem
EXTRN	?OFFtrade@@3VCOFFtrade@@A:BYTE			; OFFtrade
EXTRN	?gs_cmd@@3VCHAT_COMMANDS@@A:BYTE		; gs_cmd
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?bCanTrade@@3HA:DWORD				; bCanTrade
EXTRN	?bCanChaosBox@@3HA:DWORD			; bCanChaosBox
EXTRN	?bCanConnectMember@@3HA:DWORD			; bCanConnectMember
EXTRN	?bCanWarehouseLock@@3HA:DWORD			; bCanWarehouseLock
EXTRN	?gMerryXMasNpcEvent@@3HA:DWORD			; gMerryXMasNpcEvent
EXTRN	?gHappyNewYearNpcEvent@@3HA:DWORD		; gHappyNewYearNpcEvent
EXTRN	?dwgCheckSum@@3PAKA:BYTE			; dwgCheckSum
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?ShopC@@3PAVCShop@@A:BYTE			; ShopC
EXTRN	?szClientVersion@@3PADA:BYTE			; szClientVersion
EXTRN	?szGameServerExeSerial@@3PADA:BYTE		; szGameServerExeSerial
EXTRN	?gCreateCharacter@@3HA:DWORD			; gCreateCharacter
EXTRN	?gGuildDestroy@@3HA:DWORD			; gGuildDestroy
EXTRN	?gNonPK@@3HA:DWORD				; gNonPK
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
EXTRN	?gSpeedHackPenalty@@3HA:DWORD			; gSpeedHackPenalty
EXTRN	?gDQChaosSuccessRateLevel1@@3HA:DWORD		; gDQChaosSuccessRateLevel1
EXTRN	?gDQChaosSuccessRateLevel2@@3HA:DWORD		; gDQChaosSuccessRateLevel2
EXTRN	?gDQChaosSuccessRateLevel3@@3HA:DWORD		; gDQChaosSuccessRateLevel3
EXTRN	?gDQChaosSuccessRateLevel4@@3HA:DWORD		; gDQChaosSuccessRateLevel4
EXTRN	?bIsIgnorePacketSpeedHackDetect@@3HA:DWORD	; bIsIgnorePacketSpeedHackDetect
EXTRN	?gHackCheckCount@@3KA:DWORD			; gHackCheckCount
EXTRN	?gDetectedHackKickCount@@3HA:DWORD		; gDetectedHackKickCount
EXTRN	?gIsKickDetecHackCountLimit@@3HA:DWORD		; gIsKickDetecHackCountLimit
EXTRN	?gWriteChatLog@@3HA:DWORD			; gWriteChatLog
EXTRN	?gWriteSkillLog@@3HA:DWORD			; gWriteSkillLog
EXTRN	?gDoPShopOpen@@3HA:DWORD			; gDoPShopOpen
EXTRN	?gEnableCheckPenetrationSkill@@3HA:DWORD	; gEnableCheckPenetrationSkill
EXTRN	?g_iSkillDistanceKick@@3HA:DWORD		; g_iSkillDistanceKick
EXTRN	?g_iSkillDistanceKickCount@@3HA:DWORD		; g_iSkillDistanceKickCount
EXTRN	?g_iSkillDiatanceKickCheckTime@@3HA:DWORD	; g_iSkillDiatanceKickCheckTime
EXTRN	?cManager@@3VCGMMng@@A:BYTE			; cManager
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?OffExp@@3VcOffExp@@A:BYTE			; OffExp
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?ConMember@@3VCConMember@@A:BYTE		; ConMember
EXTRN	?g_DevilSquare@@3VCDevilSquare@@A:BYTE		; g_DevilSquare
EXTRN	?gBSGround@@3PAPAVCBattleSoccer@@A:DWORD	; gBSGround
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?gGateC@@3VCGate@@A:BYTE			; gGateC
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?gSendHackLog@@3VCSendHackLog@@A:BYTE		; gSendHackLog
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A:BYTE ; gMultiAttackHackCheck
EXTRN	?gPacketCheckSum@@3VCPacketCheckSum@@A:BYTE	; gPacketCheckSum
EXTRN	?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A:BYTE	; gQeustNpcTeleport
EXTRN	?g_KalimaGate@@3VCKalimaGate@@A:BYTE		; g_KalimaGate
EXTRN	?gDarkSpirit@@3PAVCDarkSpirit@@A:BYTE		; gDarkSpirit
EXTRN	?wsGServer@@3VCwsGameServer@@A:BYTE		; wsGServer
EXTRN	?wsJServerCli@@3VwsJoinServerCli@@A:BYTE	; wsJServerCli
EXTRN	?WhisperCash@@3VCWhisperCash@@A:BYTE		; WhisperCash
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?Guild@@3VCGuildClass@@A:BYTE			; Guild
EXTRN	?gStalkProtocolId@@3PADA:BYTE			; gStalkProtocolId
EXTRN	?gStalkProtocol@@3HA:DWORD			; gStalkProtocol
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
CONST	SEGMENT
??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Chaos nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
CONST	SEGMENT
??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid TargetTrade nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
CONST	SEGMENT
??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Trade nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
CONST	SEGMENT
??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid WareHouse nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
CONST	SEGMENT
??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z@4JA DD 05657H ; `CGRequestPetItemInfo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd@ DB 'error-L2 : Ind'
	DB	'ex %s %d', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z@4JA DD 05642H ; `CGRequestPetItemCommand'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CG@KCMDMGAG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CG@KCMDMGAG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL?$CF@ DB '['
	DB	'Duel] [%s][%s] Duel Started [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN@ DB '['
	DB	'Duel] [%s][%s] Duel Ended [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z@4JA DD 054adH ; `CGDuelEndRequestRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5St@
CONST	SEGMENT
??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5St@ DB '['
	DB	'Duel] [%s][%s] Requested to Start Duel to [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z@4JA DD 05396H ; `CGDuelStartRequestRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Regist@
CONST	SEGMENT
??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Regist@ DB '['
	DB	'Mu_2Anv_Event] [%s][%s] Register Lotto Number (Serial: %s-%s-'
	DB	'%s)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ DB '['
	DB	'Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle'
	DB	' (Guard Mail Set Serial:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z@4JA DD 04f32H ; `CGRequestEnterChaosCastle'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle'
	DB	' (Invisible Cloak Serial:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z@4JA DD 04ca2H ; `CGRequestEnterBloodCastle'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Ch@
CONST	SEGMENT
??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Ch@ DB '['
	DB	'EventChip] [%s][%s] Request Change Rena', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Ch@
CONST	SEGMENT
??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Ch@ DB '['
	DB	'EventChip] [%s][%s] Request Change Stones', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GCUseEndEventChipRescv@@YAXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GCUseEndEventChipRescv@@YAXH@Z@4JA DD 04bcfH ; `GCUseEndEventChipRescv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mu@
CONST	SEGMENT
??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mu@ DB '['
	DB	'EventChip] [%s][%s] Request MutoNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y@
CONST	SEGMENT
??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y@ DB 0c0H
	DB	0ccH, 0b9H, 0ccH, ' ', 0b7H, 0e7H, 0b0H, 0a1H, 0b5H, 0e5H, 0c0H
	DB	0c7H, ' ', 0bcH, 0fdH, 0c0H, 0daH, 0b0H, 0a1H, ' ', 0c0H, 0d6H
	DB	0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CGCEIIIK@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5Even@
CONST	SEGMENT
??_C@_0DF@CGCEIIIK@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5Even@ DB '['
	DB	'Stone] [%s][%s] Not Found EventChip (Stone Pos: %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EFAFIPG@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5Stone@
CONST	SEGMENT
??_C@_0DK@EFAFIPG@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5Stone@ DB '['
	DB	'Stone] [%s][%s] Register Stone (Stone Pos:%d, Serial:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@ODJBOBMD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@
CONST	SEGMENT
??_C@_0DO@ODJBOBMD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #3 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@
CONST	SEGMENT
??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #2 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@
CONST	SEGMENT
??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #1 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5@
CONST	SEGMENT
??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5@ DB '['
	DB	'EventChip] [%s][%s] Attempted ItemCopy using ChaosBox Window', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5@
CONST	SEGMENT
??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5@ DB '['
	DB	'EventChip] [%s][%s] Attempted ItemCopy using Trade Window', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMIMJBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ping?5?$DN?5?$CFd?5ms@
CONST	SEGMENT
??_C@_0BG@FMIMJBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ping?5?$DN?5?$CFd?5ms@ DB '['
	DB	'%s][%s] Ping = %d ms', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OGLBFJCJ@?$FLPK?5User?$FN?$FLChaosCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0DI@OGLBFJCJ@?$FLPK?5User?$FN?$FLChaosCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'PK User][ChaosCastle] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'PK User][BloodCastle] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'PK User][DevilSquare] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
CONST	SEGMENT
??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] Remov'
	DB	'eItem[%s][%d][%d][%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
CONST	SEGMENT
??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
CONST	SEGMENT
??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Invitation LevelError '
	DB	'[%d][%d][%d][%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
CONST	SEGMENT
??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5@
CONST	SEGMENT
??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5@ DB '['
	DB	'DevilSquare] [%s][%s] Request Move DevilSquare [%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd@ DB 'return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z@4JA DD 04890H ; `GCReqmoveDevilSquare'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd@ DB 'GCManaSe'
	DB	'nd() return %s %d', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GCManaSend@@YAXHFEEG@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GCManaSend@@YAXHFEEG@Z@4JA DD 0481dH	; `GCManaSend'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd@ DB 'e'
	DB	'rror-L3 : %s return %s %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CF@
CONST	SEGMENT
??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CF@ DB 'e'
	DB	'rror-L3 : %s return %s %d %d %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CF@
CONST	SEGMENT
??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CF@ DB '['
	DB	'Using Item] [Return Scroll] [%s][%s] - Current Map:[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUse@
CONST	SEGMENT
??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUse@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [UseItem] (%s)(%s) Item(%s) Pos(%d)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRe@
CONST	SEGMENT
??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRe@ DB 'e'
	DB	'rror-L1 : [%s][%s] CGUseItemRecv()_Pos return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invent@
CONST	SEGMENT
??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invent@ DB '['
	DB	'%s][%s] CGUseItemRecv()_Inventory return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed@
CONST	SEGMENT
??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed@ DB '['
	DB	'%s][%s] CGUseItemRecv() Failed : Transaction == 1, IF_TYPE : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseT@
CONST	SEGMENT
??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseT@ DB '['
	DB	'%s][%s] CGUseItemRecv()_CloseType return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5ret@
CONST	SEGMENT
??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5ret@ DB '['
	DB	'%s][%s] CGUseItemRecv()_If return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA DD 04207H ; `CGUseItemRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi@
CONST	SEGMENT
??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi@ DB '['
	DB	'%s][%s] %s Detect Hack : Multi Attack', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GMGPOAFD@Magic?5Attack3?5?3?5?$CFd?0?5serial?5?$DN?5?$CFd@
CONST	SEGMENT
??_C@_0DF@GMGPOAFD@Magic?5Attack3?5?3?5?$CFd?0?5serial?5?$DN?5?$CFd@ DB 'M'
	DB	'agic Attack3 : %d, serial = %d, Tgt =  %d, cnt = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JFIBGMNL@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5@
CONST	SEGMENT
??_C@_0DJ@JFIBGMNL@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0daH, 0a1H, 0daH, ' InValid VailidCoun'
	DB	't = %d ( Count : %d) [%d][%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EOJDOJAH@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5K@
CONST	SEGMENT
??_C@_0DN@EOJDOJAH@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5K@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0daH, 0a1H, 0daH, ' InValid DurationTi'
	DB	'me Key = %d ( Time : %d) [%d][%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wro@
CONST	SEGMENT
??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wro@ DB '['
	DB	'%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5cast@
CONST	SEGMENT
??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5cast@ DB 'Too long tim'
	DB	'e passed after casting magic. [%s][%s] (%d)(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@ DB 'error-L3 %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGBeattackRecv@@YAXPAEHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGBeattackRecv@@YAXPAEHH@Z@4JA DD 03f11H ; `CGBeattackRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5No@
CONST	SEGMENT
??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5No@ DB '['
	DB	'%s][%s] Try Target Teleport Not Move Area [%d,%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5@
CONST	SEGMENT
??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5@ DB '['
	DB	'%s][%s] Try Teleport Not Move Area [%d,%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. '
	DB	'count(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Atta@
CONST	SEGMENT
??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Atta@ DB '['
	DB	'%s][%s] Try Attack In Not Attack Area [Protocol] (%s:%d,%d) e'
	DB	'rrortype = %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd@ DB 'error :%s %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z@4JA DD 03b46H ; `CGMagicAttack'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z@4JA DD 03b05H ; `CGActionRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5@
CONST	SEGMENT
??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5@ DB '['
	DB	'%s][%s] %s Apply Attack Speed Penalty (%d left)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GAMOBCPD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wro@
CONST	SEGMENT
??_C@_0DN@GAMOBCPD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wro@ DB '['
	DB	'%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCount@
CONST	SEGMENT
??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCount@ DB '['
	DB	'%s][%s] %s Kick DetecHackCountLimit Over User (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CF@
CONST	SEGMENT
??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CF@ DB '['
	DB	'CGAttack] [UserIndex Error] :%s %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGAttack@@YAXPAUPMSG_ATTACK@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGAttack@@YAXPAUPMSG_ATTACK@@H@Z@4JA DD 0393dH ; `CGAttack'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5err@
CONST	SEGMENT
??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5err@ DB 'error : mov'
	DB	'e protocol index error %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z@4JA DD 038d8H ; `RecvPositionSetProc'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5@
CONST	SEGMENT
??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5@ DB 'error-'
	DB	'L3 : Path Count error %d id:%s %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5@
CONST	SEGMENT
??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5@ DB 'error-L3 :'
	DB	' move protocol index error %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??PMoveProc@@YAXPAUPMSG_MOVE@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??PMoveProc@@YAXPAUPMSG_MOVE@@H@Z@4JA DD 036ffH ; `PMoveProc'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??CGChaosBoxUseEnd@@YAXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGChaosBoxUseEnd@@YAXH@Z@4JA DD 036ddH	; `CGChaosBoxUseEnd'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type@
CONST	SEGMENT
??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type@ DB '['
	DB	'%s][%s] Undefine chaosmix type detect %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos@
CONST	SEGMENT
??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos@ DB '['
	DB	'%s][%s] Already Used Chaos', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z@4JA DD 03499H ; `CGChaosBoxItemMixButtonClick'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??CGWarehouseUseEnd@@YAXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGWarehouseUseEnd@@YAXH@Z@4JA DD 033b4H ; `CGWarehouseUseEnd'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHous@
CONST	SEGMENT
??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHous@ DB 'Get WareHou'
	DB	'se Money(In WareHouse) : %d - %d = %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventor@
CONST	SEGMENT
??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventor@ DB 'Get WareHou'
	DB	'se Money(In Inventory) : %d - %d = %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@ DB 'error-L3 [%'
	DB	's][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z@4JA DD 03328H ; `CGWarehouseMoneyInOut'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd@ DB 'Target Score %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd@ DB 'Score %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target@
CONST	SEGMENT
??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target@ DB 'Error on de'
	DB	'claring war : Target GuildMaster Is Murderer 0x04 %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildM@
CONST	SEGMENT
??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildM@ DB 'Error on de'
	DB	'claring war : GuildMaster Is Murderer 0x04 %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5@
CONST	SEGMENT
??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5@ DB '['
	DB	'%s][%s] Guild Request - Leave : %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismis@
CONST	SEGMENT
??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismis@ DB '['
	DB	'%s][%s] Guild Request - Dismiss All : %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@POEHMBEF@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?$CIr@
CONST	SEGMENT
??_C@_0EP@POEHMBEF@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?$CIr@ DB '[HAC'
	DB	'KTOOL] : NPC-GuildRequest(result) npc:%d ip:%s account:%s nam'
	DB	'e:%s State:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3@
CONST	SEGMENT
??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3@ DB '['
	DB	'%s][%s] Guild Request - Join : %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@LLMHNLJP@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?5n@
CONST	SEGMENT
??_C@_0EH@LLMHNLJP@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?5n@ DB '[HACKT'
	DB	'OOL] : NPC-GuildRequest npc:%d ip:%s account:%s name:%s State'
	DB	':%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIALNFFA@?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_05DIALNFFA@?$CFs?5?$CFd@ DB '%s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAPFACKC@User?5Not?5found@
CONST	SEGMENT
??_C@_0P@GAPFACKC@User?5Not?5found@ DB 'User Not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs@
CONST	SEGMENT
??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs@ DB 'No Party %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z@4JA DD 02ca2H ; `CGPartyDelUser'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EP@FDAKNNLI@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?$CIR@
CONST	SEGMENT
??_C@_0EP@FDAKNNLI@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?$CIR@ DB '[HAC'
	DB	'KTOOL] : NPC-TradeRequest(Result) npc:%d ip:%s account:%s nam'
	DB	'e:%s State:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs@ DB '%s %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ DB 'Par'
	DB	'ty result : %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@LCEBGPEH@?$FLHACKTOOL?$FN?5?3?5NPC?9PartyRequest?5n@
CONST	SEGMENT
??_C@_0EH@LCEBGPEH@?$FLHACKTOOL?$FN?5?3?5NPC?9PartyRequest?5n@ DB '[HACKT'
	DB	'OOL] : NPC-PartyRequest npc:%d ip:%s account:%s name:%s State'
	DB	':%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items@
CONST	SEGMENT
??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items@ DB '['
	DB	'PShop] [%s][%s] Sold All Items - Auto Closing PShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item@
CONST	SEGMENT
??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item@ DB '['
	DB	'PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s]'
	DB	'[%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, S'
	DB	'erial:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0JC@NLGCBMPF@?$FLOffTrade?$FN?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0JC@NLGCBMPF@?$FLOffTrade?$FN?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'OffTrade][PShop] [%s][%s][%s] PShop Item Buy Request Succeed '
	DB	': [%s][%s][%s] (Price=%d ZEN, ItemType:%d (%s), ItemLevel:%d,'
	DB	' ItemDur:%d, Serial:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exce'
	DB	'eding Zen of the Host', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack'
	DB	' of Zen', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No R'
	DB	'oom to Buy Item', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@OHDLELPO@?$FLCOMPRA?$FN?5Cuenta?3?$FL?$CFs?$FN?5Usuario?3?$FL?$CF@
CONST	SEGMENT
??_C@_0FL@OHDLELPO@?$FLCOMPRA?$FN?5Cuenta?3?$FL?$CFs?$FN?5Usuario?3?$FL?$CF@ DB '['
	DB	'COMPRA] Cuenta:[%s] Usuario:[%s] Compro por [%d] Cash [VENDED'
	DB	'OR] Cuenta:[%s] Usuario:[%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BDDKFCHD@?$FLTienda?5Personal?$FN?5Te?5quedan?5?$CFd?5@
CONST	SEGMENT
??_C@_0CE@BDDKFCHD@?$FLTienda?5Personal?$FN?5Te?5quedan?5?$CFd?5@ DB '[Ti'
	DB	'enda Personal] Te quedan %d Cash', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@INIPKDON@?$FLTienda?5Personal?$FN?5Actualmente?5t@
CONST	SEGMENT
??_C@_0CO@INIPKDON@?$FLTienda?5Personal?$FN?5Actualmente?5t@ DB '[Tienda '
	DB	'Personal] Actualmente tienes  %d Cash', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FKIEGGCJ@?$FLTienda?5Personal?$FN?5Necesitas?5?$CFd?5@
CONST	SEGMENT
??_C@_0CE@FKIEGGCJ@?$FLTienda?5Personal?$FN?5Necesitas?5?$CFd?5@ DB '[Tie'
	DB	'nda Personal] Necesitas %d Cash', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@INFPCJNN@TIENDAPERSONALSUMA@
CONST	SEGMENT
??_C@_0BD@INFPCJNN@TIENDAPERSONALSUMA@ DB 'TIENDAPERSONALSUMA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CENNGABF@UPDATE?5TIENDAPERSONAL@
CONST	SEGMENT
??_C@_0BG@CENNGABF@UPDATE?5TIENDAPERSONAL@ DB 'UPDATE TIENDAPERSONAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BABKIKBE@TIENDAPERSONALRESTA@
CONST	SEGMENT
??_C@_0BE@BABKIKBE@TIENDAPERSONALRESTA@ DB 'TIENDAPERSONALRESTA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did '
	DB	'Not Choose Item Price', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Requester Tra'
	DB	'nsaction == 1, IF_TYPE : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSh@
CONST	SEGMENT
??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSh@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [PShop Buy] (%s)(%s) Item(%s) Pos(%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Alre'
	DB	'ady Trade With Other', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is i'
	DB	'n Item Block', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is C'
	DB	'losing Connection', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch'
	DB	' [%s] - [%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did '
	DB	'not Open PShop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not'
	DB	' CHARACTER (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller did No'
	DB	't CONNECTED (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FNEEFLNP@?$FLBOT?5STORE?$FN?5Te?5quedan?5?$CFd?5Cash@
CONST	SEGMENT
??_C@_0BO@FNEEFLNP@?$FLBOT?5STORE?$FN?5Te?5quedan?5?$CFd?5Cash@ DB '[BOT '
	DB	'STORE] Te quedan %d Cash', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPKGHCGP@?$FLBOT?5STORE?$FN?5Actualmente?5tienes?5@
CONST	SEGMENT
??_C@_0CI@DPKGHCGP@?$FLBOT?5STORE?$FN?5Actualmente?5tienes?5@ DB '[BOT ST'
	DB	'ORE] Actualmente tienes  %d Cash', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BEPKGPIF@?$FLBOT?5STORE?$FN?5Necesitas?5?$CFd?5Cash@
CONST	SEGMENT
??_C@_0BO@BEPKGPIF@?$FLBOT?5STORE?$FN?5Necesitas?5?$CFd?5Cash@ DB '[BOT S'
	DB	'TORE] Necesitas %d Cash', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPCIFBAH@OFFTRADESUMA@
CONST	SEGMENT
??_C@_0N@HPCIFBAH@OFFTRADESUMA@ DB 'OFFTRADESUMA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BCLMBCOI@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@
CONST	SEGMENT
??_C@_0EK@BCLMBCOI@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@ DB 'UPDATE MuOnli'
	DB	'ne.dbo.MEMB_INFO SET Cash = Cash + %d WHERE memb___id = ''%s'''
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FBHJCJB@UPDATE?5OFFTRADE@
CONST	SEGMENT
??_C@_0BA@FBHJCJB@UPDATE?5OFFTRADE@ DB 'UPDATE OFFTRADE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HGOOMGKG@OFFTRADERESTA@
CONST	SEGMENT
??_C@_0O@HGOOMGKG@OFFTRADERESTA@ DB 'OFFTRADERESTA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BHAABMKG@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@
CONST	SEGMENT
??_C@_0EK@BHAABMKG@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@ DB 'UPDATE MuOnli'
	DB	'ne.dbo.MEMB_INFO SET Cash = Cash - %d WHERE memb___id = ''%s'''
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GGOILNKD@?4?4?2data?2QueryShop?4ini@
CONST	SEGMENT
??_C@_0BG@GGOILNKD@?4?4?2data?2QueryShop?4ini@ DB '..\data\QueryShop.ini', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z@4JA DD 02861H ; `CGPShopReqBuyItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@OAHJEEKI@ITEM?5TYPE?3?$CFd@
CONST	SEGMENT
??_C@_0N@OAHJEEKI@ITEM?5TYPE?3?$CFd@ DB 'ITEM TYPE:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5P@
CONST	SEGMENT
??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5P@ DB '['
	DB	'PShop] [%s][%s] is Receiving PShop List From [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
CONST	SEGMENT
??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Requester Transac'
	DB	'tion == 1, IF_TYPE : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
CONST	SEGMENT
??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : [%s][%s] is in It'
	DB	'em Block', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
CONST	SEGMENT
??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : [%s][%s] Did not '
	DB	'Open PShop', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
CONST	SEGMENT
??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ DB '['
	DB	'PShop] [%s][%s] PShop List Requested to Him(/Her)Self', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Clos'
	DB	'ing (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
CONST	SEGMENT
??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Clo'
	DB	'sing (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
CONST	SEGMENT
??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Seller is Not CHA'
	DB	'RACTER (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
CONST	SEGMENT
??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Seller did Not CO'
	DB	'NNECTED (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z@4JA DD 02780H ; `CGPShopReqBuyList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop@
CONST	SEGMENT
??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop@ DB '['
	DB	'PShop] [%s][%s] Close PShop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5C@
CONST	SEGMENT
??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5C@ DB '['
	DB	'PShop] [%s][%s] Requested to Close PShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5@
CONST	SEGMENT
??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5@ DB '['
	DB	'PShop] [%s][%s] Personal Shop Already Opened - Changing PShop'
	DB	' Name', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5@
CONST	SEGMENT
??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5@ DB '['
	DB	'PShop] [%s][%s] Personal Shop Opened', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transa@
CONST	SEGMENT
??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transa@ DB '['
	DB	'PShop] [%s][%s] ERROR : Transaction == 1, IF_TYPE : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknow@
CONST	SEGMENT
??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknow@ DB '['
	DB	'PShop] [%s][%s] ERROR : Unknown m_IfState.type : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSt@
CONST	SEGMENT
??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSt@ DB '['
	DB	'PShop] [%s][%s] ERROR : m_IfState.type is Using : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t@
CONST	SEGMENT
??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t@ DB '['
	DB	'PShop] [%s][%s] ERROR : Cant''t Open Shop - Item Block', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z@4JA DD 02677H ; `CGPShopReqOpen'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FD@OAAFOEHL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5@
CONST	SEGMENT
??_C@_0FD@OAAFOEHL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5@ DB '['
	DB	'PShop] [%s][%s] Changing Item Price : %d (Type:%d (%s), Lev:%'
	DB	'd, Serial:%d, Dur:%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5P@
CONST	SEGMENT
??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5P@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Price Change - Item Block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LPICNFPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Person@
CONST	SEGMENT
??_C@_0DM@LPICNFPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Person@ DB '['
	DB	'PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5re@
CONST	SEGMENT
??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5re@ DB 'e'
	DB	'rror-L2 : CopyItem [%s][%s] return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSh@
CONST	SEGMENT
??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSh@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [PShop] (%s)(%s) Item(%s) Pos(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5D@
CONST	SEGMENT
??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5D@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Does Not Exist : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5P@
CONST	SEGMENT
??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5P@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Position Out of Bound : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5@
CONST	SEGMENT
??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5@ DB '['
	DB	'PShop] [%s][%s] ERROR : Level is Under 6 : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CH@
CONST	SEGMENT
??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CH@ DB '[PSh'
	DB	'op] ERROR : Index is not CHARACTER : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CO@
CONST	SEGMENT
??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CO@ DB '[PSh'
	DB	'op] ERROR : Index is not CONNECTED : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z@4JA DD 025e4H ; `CGPShopReqSetItemPrice'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept@
CONST	SEGMENT
??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept@ DB '[%s][%s'
	DB	'] Trade Accept', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z@4JA DD 02517H ; `CGTradeMoneyRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd@
CONST	SEGMENT
??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd@ DB 'Interface State : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'%s][%s] Trade Ready [%s][%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5T@
CONST	SEGMENT
??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5T@ DB '['
	DB	'%s][%s] Made Trade Error (in Transaction) [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5@ DB '['
	DB	'%s][%s] CGTradeResponseRecv() Failed : Transaction == 1, IF_T'
	DB	'YPE : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5@
CONST	SEGMENT
??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5@ DB '('
	DB	'%s)(%s) Trade Interface State Error : use:%d type:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5@ DB 'e'
	DB	'rror-L1 : target:%d (A_ID:%s) %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd@ DB 'e'
	DB	'rror-L1 : %d (A_ID:%s) %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z@4JA DD 0240aH ; `CGTradeResponseRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5F@
CONST	SEGMENT
??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5F@ DB '['
	DB	'%s][%s] CGTradeRequestSend() Failed : Transaction == 1, IF_TY'
	DB	'PE : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DGNFGBFP@?$FLPVP?5Event?$FN?5Accion?5no?5permitida@
CONST	SEGMENT
??_C@_0CA@DGNFGBFP@?$FLPVP?5Event?$FN?5Accion?5no?5permitida@ DB '[PVP Ev'
	DB	'ent] Accion no permitida', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JLPPNLGF@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?5n@
CONST	SEGMENT
??_C@_0EH@JLPPNLGF@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?5n@ DB '[HACKT'
	DB	'OOL] : NPC-TradeRequest npc:%d ip:%s account:%s name:%s State'
	DB	':%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ@ DB 'error : %s'
	DB	' %d (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z@4JA DD 02340H ; `CGTradeRequestSend'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5@
CONST	SEGMENT
??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5@ DB 'ID:%s CharID:%s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSel@
CONST	SEGMENT
??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSel@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [Sell Item] (%s)(%s) Item(%s) Pos(%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fa@
CONST	SEGMENT
??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fa@ DB '['
	DB	'%s][%s] CGSellRequestRecv() Failed : Transaction == 1, IF_TYP'
	DB	'E : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z@4JA DD 01f73H ; `CGSellRequestRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN@ DB '['
	DB	'%s][%s] (%d) Shop buy [%d][%d][%d][%s] LEV:%d, DUR:%d, OP:[%d'
	DB	'][%d][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z@4JA DD 01ef1H ; `CGBuyRequestRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box@
CONST	SEGMENT
??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box@ DB '[%s]'
	DB	'[%s] Open Chaos Box', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSh@
CONST	SEGMENT
??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSh@ DB '['
	DB	'%s][%s] is Already Opening PShop, ChaosBox Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5@
CONST	SEGMENT
??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5@ DB '['
	DB	'ANTI-HACK][NPC Talk] Couldn''t talk.. (%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z@4JA DD 01d84H ; `CGTalkRequestRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHous@
CONST	SEGMENT
??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHous@ DB 'Pay WareHou'
	DB	'se Money(In WareHouse) : %d - %d = %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventor@
CONST	SEGMENT
??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventor@ DB 'Pay WareHou'
	DB	'se Money(In Inventory) : %d - %d = %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tr@
CONST	SEGMENT
??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tr@ DB '['
	DB	'%s][%s] error-L1 : used not Trade', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Wa@
CONST	SEGMENT
??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Wa@ DB '['
	DB	'%s][%s] error-L1 : used not Warehouse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainer@
CONST	SEGMENT
??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainer@ DB '['
	DB	'%s][%s] error-L3 : DarkTrainerBoxMixing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Da@
CONST	SEGMENT
??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Da@ DB '['
	DB	'%s][%s] error-L1 : used not DarkTrainerBox', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing@
CONST	SEGMENT
??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing@ DB '['
	DB	'%s][%s] error-L3 : CBMixing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Ch@
CONST	SEGMENT
??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Ch@ DB '['
	DB	'%s][%s] error-L1 : used not Chaosbox', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3@
CONST	SEGMENT
??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3@ DB '[%s][%d] er'
	DB	'ror-L3', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z@4JA DD 019f4H ; `CGInventoryItemMove'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Ma@
CONST	SEGMENT
??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Ma@ DB '['
	DB	'Kalima] [%s][%s] Success to Make Kalima Gate (Lost Kalima Map'
	DB	' Serial:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@FJBOPNFK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5D@
CONST	SEGMENT
??_C@_0FO@FJBOPNFK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5D@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of DarkLordHeart Serial:%d (%s:%d/l'
	DB	'evel:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@CCPCBLJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
CONST	SEGMENT
??_C@_0GA@CCPCBLJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox1-12 Serial:%d (%s:%d'
	DB	'/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@JIKHBPIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
CONST	SEGMENT
??_C@_0GA@JIKHBPIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox1-11 Serial:%d (%s:%d'
	DB	'/level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@PHLHAFBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
CONST	SEGMENT
??_C@_0FP@PHLHAFBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox-10 Serial:%d (%s:%d/'
	DB	'level:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@PNDHLIGG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
CONST	SEGMENT
??_C@_0FO@PNDHLIGG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox-9 Serial:%d (%s:%d/l'
	DB	'evel:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@JEPLEEGL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
CONST	SEGMENT
??_C@_0FO@JEPLEEGL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of ElradoraBox-8 Serial:%d (%s:%d/l'
	DB	'evel:%d/skill:%d/op2:%d/op3:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@PGPEHJJI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
CONST	SEGMENT
??_C@_0FK@PGPEHJJI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of EventChip Serial:%d (%s:%d/level'
	DB	':%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@IGKKOJBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5S@
CONST	SEGMENT
??_C@_0FM@IGKKOJBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5S@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of SilverMedal Serial:%d (%s:%d/lev'
	DB	'el:%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@MPNDPHHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5G@
CONST	SEGMENT
??_C@_0FK@MPNDPHHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5G@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of GoldMedal Serial:%d (%s:%d/level'
	DB	':%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@EBLAMMBK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5H@
CONST	SEGMENT
??_C@_0FM@EBLAMMBK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5H@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of HeartOfLove Serial:%d (%s:%d/lev'
	DB	'el:%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@DGEGEEP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5F@
CONST	SEGMENT
??_C@_0FM@DGEGEEP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5F@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of FireCracker Serial:%d (%s:%d/lev'
	DB	'el:%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@HPOJPJGH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5S@
CONST	SEGMENT
??_C@_0FL@HPOJPJGH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5S@ DB '['
	DB	'%s][%s][%d]%d/%d Used box of StarOfXMas Serial:%d (%s:%d/leve'
	DB	'l:%d/skill:%d/op2:%d/op3:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLIte@
CONST	SEGMENT
??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLIte@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [ItemDrop] (%s)(%s) Item(%s) Pos(%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGCMBJDA@Item@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item@ DB 'Item', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd@ DB 'error:%s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fa@
CONST	SEGMENT
??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fa@ DB '['
	DB	'%s][%s] CGItemDropRequest() Failed : Transaction == 1, IF_TYP'
	DB	'E : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z@4JA DD 014a1H ; `CGItemDropRequest'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) picked up Angel King'
	DB	'''s Weapon (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kal@
CONST	SEGMENT
??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kal@ DB '['
	DB	'Kalima] [%s][%s] Make Lost Kalima Map (Left Kundun Mark:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magi@
CONST	SEGMENT
??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magi@ DB '[Ring '
	DB	'Event] Too many have Magician''s Ring [%s][%s] (Name:%s, Coun'
	DB	't:%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DNFDPMM@?$FLQuest?$FN?5Too?5many?5have?5quest?5ite@
CONST	SEGMENT
??_C@_0DC@DNFDPMM@?$FLQuest?$FN?5Too?5many?5have?5quest?5ite@ DB '[Quest]'
	DB	' Too many have quest item [%s][%s] (%s) %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@ DB 'error-L3 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fai@
CONST	SEGMENT
??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fai@ DB '['
	DB	'%s][%s] CGItemGetRequest() Failed : Transaction == 1, IF_TYPE'
	DB	' : %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
CONST	SEGMENT
??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@ DB '[Fix'
	DB	' Inv.Ptr] False Location - %s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z@4JA DD 01114H ; `CGItemGetRequest'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@LJJFCIF@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0BI@LJJFCIF@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ DB 'Option Se'
	DB	'nd %d %d %d %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PHONBDAL@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
CONST	SEGMENT
??_C@_0BI@PHONBDAL@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd@ DB 'Option R'
	DB	'ecv %d %d %d %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JPGCOFPC@?0?5?$FLG?9?$DOD?5Req?5MapJoin?$FN?5CharSelect@
CONST	SEGMENT
??_C@_0EH@JPGCOFPC@?0?5?$FLG?9?$DOD?5Req?5MapJoin?$FN?5CharSelect@ DB ', '
	DB	'[G->D Req MapJoin] CharSelected, Account [%s], IP [%s], Name['
	DB	'%s](%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs@
CONST	SEGMENT
??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs@ DB 'Character del'
	DB	'ete : %s,%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempt@
CONST	SEGMENT
??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempt@ DB '[An'
	DB	'ti-HACK][CGPCharDel] Attempted Character Delete during Preven'
	DB	'ted Time. [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempt@
CONST	SEGMENT
??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempt@ DB '[Ant'
	DB	'i-HACK][CGPCharDel] Attempted Character Delete during GamePla'
	DB	'y. [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs@
CONST	SEGMENT
??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs@ DB 'Character cre'
	DB	'ate : %s,%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cr@
CONST	SEGMENT
??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cr@ DB 'error-L1: Da'
	DB	'rklord Character create error [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5cre@
CONST	SEGMENT
??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5cre@ DB 'error-L1: Ma'
	DB	'gumsa Character create error [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BLKDKNKC@?$LM?$KN?$LJ?v?$LK?P?G?R?5?$LB?b?$LA?$KD?$LP?$KB?$LE?B?5?D?$LD?$LI?$KP?E?M?$LI?$KG?5?$LL?$PN?$LM?$LK@
CONST	SEGMENT
??_C@_0CN@BLKDKNKC@?$LM?$KN?$LJ?v?$LK?P?G?R?5?$LB?b?$LA?$KD?$LP?$KB?$LE?B?5?D?$LD?$LI?$KP?E?M?$LI?$KG?5?$LL?$PN?$LM?$LK@ DB 0bcH
	DB	0adH, 0b9H, 0f6H, 0baH, 0d0H, 0c7H, 0d2H, ' ', 0b1H, 0e2H, 0b0H
	DB	0a3H, 0bfH, 0a1H, 0b4H, 0c2H, ' ', 0c4H, 0b3H, 0b8H, 0afH, 0c5H
	DB	0cdH, 0b8H, 0a6H, ' ', 0bbH, 0fdH, 0bcH, 0baH, 0c7H, 0d2H, 0bcH
	DB	0f6H, ' ', 0beH, 0f8H, 0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN@
CONST	SEGMENT
??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN@ DB '[Ant'
	DB	'i-HACK][CGPCharacterCreate] Attempted Character Create during'
	DB	' GamePlay. [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJDMDEO@Client?5HackCheck?5?$CFu@
CONST	SEGMENT
??_C@_0BE@EJDMDEO@Client?5HackCheck?5?$CFu@ DB 'Client HackCheck %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50@
CONST	SEGMENT
??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50@ DB 'e'
	DB	'rror-L1 : HackCheck [%s][%s] 0x%x 0x%x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CF@
CONST	SEGMENT
??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CF@ DB '[U'
	DB	'serSelClose] Go CharSelect [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@IHIAOFPA@?0?5?$FLUserSelClose?$FN?5Go?5CharSelect?0@
CONST	SEGMENT
??_C@_0FC@IHIAOFPA@?0?5?$FLUserSelClose?$FN?5Go?5CharSelect?0@ DB ', [Use'
	DB	'rSelClose] Go CharSelect, Account [%s], IP [%s], Name [%s], M'
	DB	'ap:[%d][%d/%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CF@
CONST	SEGMENT
??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CF@ DB '[U'
	DB	'serSelClose] Go ServerList [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@GOGPDPOG@?0?5?$FLUserSelClose?$FN?5Go?5ServerList?0@
CONST	SEGMENT
??_C@_0FC@GOGPDPOG@?0?5?$FLUserSelClose?$FN?5Go?5ServerList?0@ DB ', [Use'
	DB	'rSelClose] Go ServerList, Account [%s], IP [%s], Name [%s], M'
	DB	'ap:[%d][%d/%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'UserSelClose] Go Exit [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@KAGGFAIG@?0?5?$FLUserSelClose?$FN?5Go?5Exit?0?5Accou@
CONST	SEGMENT
??_C@_0EM@KAGGFAIG@?0?5?$FLUserSelClose?$FN?5Go?5Exit?0?5Accou@ DB ', [Us'
	DB	'erSelClose] Go Exit, Account [%s], IP [%s], Name [%s], Map:[%'
	DB	'd][%d/%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs@
CONST	SEGMENT
??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs@ DB 'login send : %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FLFDNKBN@m321@
CONST	SEGMENT
??_C@_04FLFDNKBN@m321@ DB 'm321', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd@
CONST	SEGMENT
??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd@ DB 0bdH, 0b8H, 0b5H, 0b9H, 0c0H
	DB	0ccH, '%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs@
CONST	SEGMENT
??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs@ DB 'join send : (%'
	DB	'd)%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd@ DB 'error : %d %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs@ DB 'e'
	DB	'rror-L1: Serial error [%s] [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NFIPADMP@JOIN?5ERROR?5?9?5VERSION?3?5?$CFs?5SERIAL@
CONST	SEGMENT
??_C@_0CE@NFIPADMP@JOIN?5ERROR?5?9?5VERSION?3?5?$CFs?5SERIAL@ DB 'JOIN ER'
	DB	'ROR - VERSION: %s SERIAL: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z@4JA DD 0bf0H ; `CSPJoinIdPassRequest'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@JGNMDCCD@?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG@
CONST	SEGMENT
??_C@_0M@JGNMDCCD@?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG@ DB 0c0H, 0ccH, 0b5H
	DB	0bfH, ' ', 0c4H, 0aeH, 0b8H, 0aeH, 0b8H, 0b6H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CPENAAMN@?$FL?$CFs?$FN?3?5@
CONST	SEGMENT
??_C@_06CPENAAMN@?$FL?$CFs?$FN?3?5@ DB '[%s]: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'Anti-HACK][PChatProc][%s][%s] Chat Message Len : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ECHKHDMC@error?9L1?5?3?5CheckSum?9Exe?5error?5?$CF@
CONST	SEGMENT
??_C@_0CM@ECHKHDMC@error?9L1?5?3?5CheckSum?9Exe?5error?5?$CF@ DB 'error-L'
	DB	'1 : CheckSum-Exe error %d %d %d [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PHFKNJAD@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSum?9Ex@
CONST	SEGMENT
??_C@_0CI@PHFKNJAD@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSum?9Ex@ DB 'e'
	DB	'rror-L1 : [%s][%s] CheckSum-Exe error ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DINGPLDD@218?4234?476?433@
CONST	SEGMENT
??_C@_0O@DINGPLDD@218?4234?476?433@ DB '218.234.76.33', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KNPEEFN@TEST?5Data?5Send@
CONST	SEGMENT
??_C@_0P@KNPEEFN@TEST?5Data?5Send@ DB 'TEST Data Send', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5H@
CONST	SEGMENT
??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5H@ DB 'err'
	DB	'or-L2 : account:%s name:%s HEAD:%x (%s,%d) State:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onl'
	DB	'ine\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5@
CONST	SEGMENT
??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5@ DB 'Err'
	DB	'or-L1 : Socket Serial %s %d o_serial:%d serial:%d ', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ProtocolCore@@YAXEPAEHHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ProtocolCore@@YAXEPAEHHHH@Z@4JA DD 0348H ; `ProtocolCore'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd@ DB 'Error-L'
	DB	'1 : Not Encrypt %s %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd@
CONST	SEGMENT
??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd@ DB 'QeustNpc RefCo'
	DB	'unt Dec= %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z DD 0ffffffe4H
	DD	00H
	DD	0fffffe38H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN55@CGPShopReq
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?ItemDurRepaire@@YAXPAVOBJECTSTRUCT@@PAVCItem@@HH@Z
_TEXT	SEGMENT
_itemtype$ = -16					; size = 4
_result$ = -12						; size = 4
_pResult$ = -8						; size = 8
_lpObj$ = 8						; size = 4
_DurItem$ = 12						; size = 4
_pos$ = 16						; size = 4
_RequestPos$ = 20					; size = 4
?ItemDurRepaire@@YAXPAVOBJECTSTRUCT@@PAVCItem@@HH@Z PROC ; ItemDurRepaire, COMDAT

; 8544 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8545 : 	PMSG_ITEMDURREPAIR_RESULT pResult;
; 8546 : 	DWORD result=1;

  00009	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1

; 8547 : 	
; 8548 : 	PHeadSetB((LPBYTE)&pResult, 0x34, sizeof( pResult));

  00010	6a 08		 push	 8
  00012	6a 34		 push	 52			; 00000034H
  00014	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8549 : 
; 8550 : 	int itemtype = DurItem->m_Type;

  00020	8b 45 0c	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00023	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00027	89 4d f0	 mov	 DWORD PTR _itemtype$[ebp], ecx

; 8551 : 
; 8552 : #ifdef DARKLORD_WORK
; 8553 : #ifndef UPDATE_DARKROAD_PET_ITEMREPAIR_20090109	//   
; 8554 : 	if( lpObj->m_IfState.type  != I_DARK_TRAINER )
; 8555 : 	{
; 8556 : 		if( itemtype == MAKE_ITEMNUM(13,4) || itemtype == MAKE_ITEMNUM(13,5) )
; 8557 : 		{	//         
; 8558 : 			pResult.Money = 0;
; 8559 : 			DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 8560 : 			return;
; 8561 : 		}
; 8562 : 	}
; 8563 : #endif	// UPDATE_DARKROAD_PET_ITEMREPAIR_20090109
; 8564 : #endif
; 8565 : 
; 8566 : 	if( itemtype >= ITEM_POTION ||		//  &&  
; 8567 : 		itemtype >= ITEM_HELPER && itemtype < ITEM_HELPER+4 ||
; 8568 : 		itemtype == MAKE_ITEMNUM(13,10)  || //  
; 8569 : #ifdef	ADD_THIRD_WING_20070525	// 3 
; 8570 : 		( itemtype >= ITEM_WING + 7 && itemtype < ITEM_WING + 36 ) ||
; 8571 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	//   ,  ,   
; 8572 : 		( itemtype > ITEM_WING + 43 && itemtype < ITEM_HELPER ) || 
; 8573 : #else
; 8574 : 		( itemtype > ITEM_WING + 40 && itemtype < ITEM_HELPER ) || 
; 8575 : #endif
; 8576 : #else
; 8577 : 		itemtype >= ITEM_WING+7 && itemtype < ITEM_HELPER || 
; 8578 : #endif
; 8579 : 		itemtype == MAKE_ITEMNUM(4,7) || 

  0002a	81 7d f0 c0 01
	00 00		 cmp	 DWORD PTR _itemtype$[ebp], 448 ; 000001c0H
  00031	7d 57		 jge	 SHORT $LN3@ItemDurRep
  00033	81 7d f0 a0 01
	00 00		 cmp	 DWORD PTR _itemtype$[ebp], 416 ; 000001a0H
  0003a	7c 09		 jl	 SHORT $LN4@ItemDurRep
  0003c	81 7d f0 a4 01
	00 00		 cmp	 DWORD PTR _itemtype$[ebp], 420 ; 000001a4H
  00043	7c 45		 jl	 SHORT $LN3@ItemDurRep
$LN4@ItemDurRep:
  00045	6a 0a		 push	 10			; 0000000aH
  00047	6a 0d		 push	 13			; 0000000dH
  00049	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0004e	83 c4 08	 add	 esp, 8
  00051	39 45 f0	 cmp	 DWORD PTR _itemtype$[ebp], eax
  00054	74 34		 je	 SHORT $LN3@ItemDurRep
  00056	81 7d f0 87 01
	00 00		 cmp	 DWORD PTR _itemtype$[ebp], 391 ; 00000187H
  0005d	7c 09		 jl	 SHORT $LN5@ItemDurRep
  0005f	81 7d f0 a0 01
	00 00		 cmp	 DWORD PTR _itemtype$[ebp], 416 ; 000001a0H
  00066	7c 22		 jl	 SHORT $LN3@ItemDurRep
$LN5@ItemDurRep:
  00068	6a 07		 push	 7
  0006a	6a 04		 push	 4
  0006c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00071	83 c4 08	 add	 esp, 8
  00074	39 45 f0	 cmp	 DWORD PTR _itemtype$[ebp], eax
  00077	74 11		 je	 SHORT $LN3@ItemDurRep
  00079	6a 0f		 push	 15			; 0000000fH
  0007b	6a 04		 push	 4
  0007d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00082	83 c4 08	 add	 esp, 8
  00085	39 45 f0	 cmp	 DWORD PTR _itemtype$[ebp], eax
  00088	75 23		 jne	 SHORT $LN2@ItemDurRep
$LN3@ItemDurRep:

; 8580 : 		itemtype == MAKE_ITEMNUM(4,15) )	// / ..
; 8581 : 	{
; 8582 : 		pResult.Money = 0;

  0008a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0

; 8583 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  00091	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00095	50		 push	 eax
  00096	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00099	51		 push	 ecx
  0009a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009d	8b 02		 mov	 eax, DWORD PTR [edx]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8584 : 		return;

  000a8	e9 4e 01 00 00	 jmp	 $LN1@ItemDurRep
$LN2@ItemDurRep:

; 8585 : 	}
; 8586 : 	
; 8587 : #ifdef KANTURU_MOONSTONEPENDANT_20060804		//    .
; 8588 : 	if( itemtype == MAKE_ITEMNUM( 13,38 ) )
; 8589 : 	{	
; 8590 : 		pResult.Money = 0;
; 8591 : 		DataSend(lpObj->m_Index, ( LPBYTE )&pResult, pResult.h.size );
; 8592 : 		return;			
; 8593 : 	}
; 8594 : #endif
; 8595 : 
; 8596 : #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//  
; 8597 : 	if( itemtype == MAKE_ITEMNUM( 13, 39 ) )
; 8598 : 	{	
; 8599 : 		pResult.Money = 0;
; 8600 : 		DataSend( lpObj->m_Index, ( LPBYTE )&pResult, pResult.h.size );
; 8601 : 		return;			
; 8602 : 	}
; 8603 : #endif
; 8604 : 	
; 8605 : #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 8606 : 	if( itemtype == MAKE_ITEMNUM( 13, 40 ) )
; 8607 : 	{
; 8608 : 		pResult.Money = 0;
; 8609 : 		DataSend( lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size );
; 8610 : 		return;
; 8611 : 	}
; 8612 : #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 8613 : 	
; 8614 : #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 8615 : 	if( itemtype == MAKE_ITEMNUM( 13, 41 ) )
; 8616 : 	{
; 8617 : 		pResult.Money = 0;
; 8618 : 		DataSend( lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size );
; 8619 : 	}
; 8620 : #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 8621 : 
; 8622 : #ifdef UPDATE_GM_FUNCTION_20070228
; 8623 : 	if( itemtype == MAKE_ITEMNUM( 13, 42 ) )
; 8624 : 	{
; 8625 : 		pResult.Money = 0;
; 8626 : 		DataSend( lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size );
; 8627 : 	}
; 8628 : #endif
; 8629 : 
; 8630 : 	pResult.Money = GetNeedMoneyItemDurRepaire(DurItem, RequestPos);

  000ad	8b 45 14	 mov	 eax, DWORD PTR _RequestPos$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d 0c	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 ?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z ; GetNeedMoneyItemDurRepaire
  000ba	83 c4 08	 add	 esp, 8
  000bd	89 45 fc	 mov	 DWORD PTR _pResult$[ebp+4], eax

; 8631 : 
; 8632 : 	if( pResult.Money <= 0 )

  000c0	83 7d fc 00	 cmp	 DWORD PTR _pResult$[ebp+4], 0
  000c4	7f 23		 jg	 SHORT $LN6@ItemDurRep

; 8633 : 	{	//    
; 8634 : 		pResult.Money = 0;

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0

; 8635 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  000cd	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000d1	50		 push	 eax
  000d2	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000d5	51		 push	 ecx
  000d6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8636 : 		return;

  000e4	e9 12 01 00 00	 jmp	 $LN1@ItemDurRep
$LN6@ItemDurRep:

; 8637 : 	}	
; 8638 : 
; 8639 : 	//   .
; 8640 : #ifdef MODIFY_ITEM_REPAIR_HIRE_BUGFIX_20090415
; 8641 : 	if( lpObj->Money-pResult.Money < 0 ) 

  000e9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ec	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  000f2	2b 4d fc	 sub	 ecx, DWORD PTR _pResult$[ebp+4]
  000f5	79 0c		 jns	 SHORT $LN7@ItemDurRep

; 8642 : #else // MODIFY_ITEM_REPAIR_HIRE_BUGFIX_20090415
; 8643 : 	if( lpObj->Money-pResult.Money < 1 ) 
; 8644 : #endif // MODIFY_ITEM_REPAIR_HIRE_BUGFIX_20090415
; 8645 : 	{
; 8646 : 		//   
; 8647 : 		pResult.Money = 0;

  000f7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0

; 8648 : 	}

  000fe	e9 e1 00 00 00	 jmp	 $LN8@ItemDurRep
$LN7@ItemDurRep:

; 8649 : 	else {
; 8650 : 		//      .
; 8651 : 		lpObj->Money -= pResult.Money;

  00103	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00106	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0010c	2b 4d fc	 sub	 ecx, DWORD PTR _pResult$[ebp+4]
  0010f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00112	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 8652 : 		pResult.Money = lpObj->Money;

  00118	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011b	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00121	89 4d fc	 mov	 DWORD PTR _pResult$[ebp+4], ecx

; 8653 : 
; 8654 : #ifdef MODIFY_ITEM_REPAIR_HIRE_BUGFIX_20090415
; 8655 : 		GCMoneySend( lpObj->m_Index, lpObj->Money );

  00124	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00127	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0012d	51		 push	 ecx
  0012e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00131	8b 02		 mov	 eax, DWORD PTR [edx]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00139	83 c4 08	 add	 esp, 8

; 8656 : #endif // MODIFY_ITEM_REPAIR_HIRE_BUGFIX_20090415
; 8657 : 				
; 8658 : 		DurItem->m_Durability = (int)DurItem->m_BaseDurability;

  0013c	8b 45 0c	 mov	 eax, DWORD PTR _DurItem$[ebp]
  0013f	f3 0f 2c 48 2c	 cvttss2si ecx, DWORD PTR [eax+44]
  00144	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00148	8b 55 0c	 mov	 edx, DWORD PTR _DurItem$[ebp]
  0014b	f3 0f 11 42 24	 movss	 DWORD PTR [edx+36], xmm0

; 8659 : 
; 8660 : 		//   
; 8661 : 
; 8662 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 8663 : 		DurItem->Convert(DurItem->m_Type, 
; 8664 : 		                 DurItem->m_Option1, 
; 8665 : 						 DurItem->m_Option2,
; 8666 : 						 DurItem->m_Option3,
; 8667 : 						 DurItem->m_NewOption,
; 8668 : 						 DurItem->m_SetOption,
; 8669 : 						 DurItem->m_ItemOptionEx);	
; 8670 : #else
; 8671 : 		DurItem->Convert(DurItem->m_Type, 

  00150	6a 01		 push	 1
  00152	8b 45 0c	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00155	0f b6 88 92 00
	00 00		 movzx	 ecx, BYTE PTR [eax+146]
  0015c	51		 push	 ecx
  0015d	8b 55 0c	 mov	 edx, DWORD PTR _DurItem$[ebp]
  00160	0f b6 42 7b	 movzx	 eax, BYTE PTR [edx+123]
  00164	50		 push	 eax
  00165	8b 4d 0c	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  00168	0f b6 51 7a	 movzx	 edx, BYTE PTR [ecx+122]
  0016c	52		 push	 edx
  0016d	8b 45 0c	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00170	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  00174	51		 push	 ecx
  00175	8b 55 0c	 mov	 edx, DWORD PTR _DurItem$[ebp]
  00178	0f b6 42 78	 movzx	 eax, BYTE PTR [edx+120]
  0017c	50		 push	 eax
  0017d	8b 4d 0c	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  00180	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00184	52		 push	 edx
  00185	8b 4d 0c	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  00188	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 8672 : 		                 DurItem->m_Option1, 
; 8673 : 						 DurItem->m_Option2,
; 8674 : 						 DurItem->m_Option3,
; 8675 : 						 DurItem->m_NewOption,
; 8676 : 						 DurItem->m_SetOption);	
; 8677 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 8678 : 
; 8679 : #ifdef UPDATE_DARKROAD_PET_ITEMREPAIR_20090109
; 8680 : 		if(DurItem->m_Type == MAKE_ITEMNUM(13,4) || DurItem->m_Type == MAKE_ITEMNUM(13,5))

  0018d	8b 45 0c	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00190	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00194	6a 04		 push	 4
  00196	6a 0d		 push	 13			; 0000000dH
  00198	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0019d	83 c4 08	 add	 esp, 8
  001a0	3b f0		 cmp	 esi, eax
  001a2	74 17		 je	 SHORT $LN10@ItemDurRep
  001a4	8b 45 0c	 mov	 eax, DWORD PTR _DurItem$[ebp]
  001a7	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  001ab	6a 05		 push	 5
  001ad	6a 0d		 push	 13			; 0000000dH
  001af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001b4	83 c4 08	 add	 esp, 8
  001b7	3b f0		 cmp	 esi, eax
  001b9	75 08		 jne	 SHORT $LN9@ItemDurRep
$LN10@ItemDurRep:

; 8681 : 		{
; 8682 : 			DurItem->PetValue();		

  001bb	8b 4d 0c	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  001be	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue
$LN9@ItemDurRep:

; 8683 : 		}
; 8684 : #endif	// UPDATE_DARKROAD_PET_ITEMREPAIR_20090109
; 8685 : 		
; 8686 : 		//   
; 8687 : 		GCItemDurSend(lpObj->m_Index, pos, DurItem->m_Durability, 0);

  001c3	6a 00		 push	 0
  001c5	8b 45 0c	 mov	 eax, DWORD PTR _DurItem$[ebp]
  001c8	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  001cd	0f b6 d1	 movzx	 edx, cl
  001d0	52		 push	 edx
  001d1	0f b6 45 10	 movzx	 eax, BYTE PTR _pos$[ebp]
  001d5	50		 push	 eax
  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d9	8b 11		 mov	 edx, DWORD PTR [ecx]
  001db	52		 push	 edx
  001dc	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  001e1	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@ItemDurRep:

; 8688 : 	}
; 8689 : 
; 8690 : 	//    .
; 8691 : 	DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  001e4	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001e8	50		 push	 eax
  001e9	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001ec	51		 push	 ecx
  001ed	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001f0	8b 02		 mov	 eax, DWORD PTR [edx]
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ItemDurRep:

; 8692 : }

  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	8b e5		 mov	 esp, ebp
  00200	5d		 pop	 ebp
  00201	c3		 ret	 0
?ItemDurRepaire@@YAXPAVOBJECTSTRUCT@@PAVCItem@@HH@Z ENDP ; ItemDurRepaire
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z
_TEXT	SEGMENT
tv223 = -104						; size = 4
_fRootRoot$1 = -36					; size = 4
_fRoot$2 = -32						; size = 4
_sellmoney$3 = -28					; size = 4
_persent$4 = -24					; size = 4
_RepaireMoney$5 = -20					; size = 4
_Durability$6 = -16					; size = 4
_ItemDurability$ = -12					; size = 4
_type$ = -8						; size = 4
_iMoney$ = -4						; size = 4
_DurItem$ = 8						; size = 4
_RequestPos$ = 12					; size = 4
?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z PROC	; GetNeedMoneyItemDurRepaire, COMDAT

; 8412 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8413 : 	int iMoney = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iMoney$[ebp], 0

; 8414 : 
; 8415 : 	int type = DurItem->m_Type;

  00010	8b 45 08	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00013	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00017	89 4d f8	 mov	 DWORD PTR _type$[ebp], ecx

; 8416 : 	float ItemDurability = (float)DurItem->m_Durability;

  0001a	8b 45 08	 mov	 eax, DWORD PTR _DurItem$[ebp]
  0001d	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00022	f3 0f 11 45 f4	 movss	 DWORD PTR _ItemDurability$[ebp], xmm0

; 8417 : 
; 8418 : 	if( type == MAKE_ITEMNUM(13,10) )

  00027	6a 0a		 push	 10			; 0000000aH
  00029	6a 0d		 push	 13			; 0000000dH
  0002b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00030	83 c4 08	 add	 esp, 8
  00033	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00036	75 07		 jne	 SHORT $LN2@GetNeedMon

; 8419 : 		return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 0d 02 00 00	 jmp	 $LN1@GetNeedMon
$LN2@GetNeedMon:

; 8420 : 
; 8421 : 	if( HasItemDurability(type) )

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _type$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?HasItemDurability@@YAHH@Z ; HasItemDurability
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 ef 01 00
	00		 je	 $LN3@GetNeedMon

; 8422 : 	{	//   
; 8423 : 		float Durability;
; 8424 : 		float RepaireMoney = 0;	

  00053	0f 57 c0	 xorps	 xmm0, xmm0
  00056	f3 0f 11 45 ec	 movss	 DWORD PTR _RepaireMoney$5[ebp], xmm0

; 8425 : 
; 8426 : 		Durability = DurItem->m_BaseDurability;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _DurItem$[ebp]
  0005e	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  00063	f3 0f 11 45 f0	 movss	 DWORD PTR _Durability$6[ebp], xmm0

; 8427 : 
; 8428 : 		if( ItemDurability == Durability )

  00068	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _ItemDurability$[ebp]
  0006d	0f 2e 45 f0	 ucomiss xmm0, DWORD PTR _Durability$6[ebp]
  00071	9f		 lahf
  00072	f6 c4 44	 test	 ah, 68			; 00000044H
  00075	7a 07		 jp	 SHORT $LN5@GetNeedMon

; 8429 : 			return 0;

  00077	33 c0		 xor	 eax, eax
  00079	e9 ce 01 00 00	 jmp	 $LN1@GetNeedMon
$LN5@GetNeedMon:

; 8430 : 
; 8431 : 		//RepaireMoney = DurItem->m_SellMoney*GetRepairItemRate(type)/Durability;
; 8432 : 		//RepaireMoney = RepaireMoney*(Durability-ItemDurability);
; 8433 : 
; 8434 : 		float   persent = 1.f - (ItemDurability/Durability);

  0007e	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _ItemDurability$[ebp]
  00083	f3 0f 5e 45 f0	 divss	 xmm0, DWORD PTR _Durability$6[ebp]
  00088	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00090	f3 0f 5c c8	 subss	 xmm1, xmm0
  00094	f3 0f 11 4d e8	 movss	 DWORD PTR _persent$4[ebp], xmm1

; 8435 : 
; 8436 : 		int sellmoney;
; 8437 : 
; 8438 : #ifdef DARKLORD_WORK
; 8439 : 		if( type == MAKE_ITEMNUM(13,4) || type == MAKE_ITEMNUM(13,5) )

  00099	6a 04		 push	 4
  0009b	6a 0d		 push	 13			; 0000000dH
  0009d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000a2	83 c4 08	 add	 esp, 8
  000a5	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  000a8	74 11		 je	 SHORT $LN8@GetNeedMon
  000aa	6a 05		 push	 5
  000ac	6a 0d		 push	 13			; 0000000dH
  000ae	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b3	83 c4 08	 add	 esp, 8
  000b6	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  000b9	75 0b		 jne	 SHORT $LN6@GetNeedMon
$LN8@GetNeedMon:

; 8440 : 		{	// ,     2
; 8441 : 			sellmoney =  DurItem->m_BuyMoney;

  000bb	8b 45 08	 mov	 eax, DWORD PTR _DurItem$[ebp]
  000be	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000c1	89 4d e4	 mov	 DWORD PTR _sellmoney$3[ebp], ecx

; 8442 : 		}

  000c4	eb 12		 jmp	 SHORT $LN7@GetNeedMon
$LN6@GetNeedMon:

; 8443 : 		else
; 8444 : #endif
; 8445 : 		{
; 8446 : 			sellmoney =  DurItem->m_BuyMoney/3;

  000c6	8b 45 08	 mov	 eax, DWORD PTR _DurItem$[ebp]
  000c9	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  000cc	33 d2		 xor	 edx, edx
  000ce	b9 03 00 00 00	 mov	 ecx, 3
  000d3	f7 f1		 div	 ecx
  000d5	89 45 e4	 mov	 DWORD PTR _sellmoney$3[ebp], eax
$LN7@GetNeedMon:

; 8447 : 		}
; 8448 : 		
; 8449 : #ifdef MODIFY_ITEM_REPAIRE_MAXMONEY
; 8450 : 		if( sellmoney > 400000000 )

  000d8	81 7d e4 00 84
	d7 17		 cmp	 DWORD PTR _sellmoney$3[ebp], 400000000 ; 17d78400H
  000df	7e 07		 jle	 SHORT $LN9@GetNeedMon

; 8451 : 		{
; 8452 : 			sellmoney = 400000000;

  000e1	c7 45 e4 00 84
	d7 17		 mov	 DWORD PTR _sellmoney$3[ebp], 400000000 ; 17d78400H
$LN9@GetNeedMon:

; 8453 : 		}
; 8454 : #endif
; 8455 : 
; 8456 : 		if(sellmoney>= 1000)

  000e8	81 7d e4 e8 03
	00 00		 cmp	 DWORD PTR _sellmoney$3[ebp], 1000 ; 000003e8H
  000ef	7c 13		 jl	 SHORT $LN10@GetNeedMon

; 8457 : 			sellmoney = sellmoney/100*100;

  000f1	8b 45 e4	 mov	 eax, DWORD PTR _sellmoney$3[ebp]
  000f4	99		 cdq
  000f5	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000fa	f7 f9		 idiv	 ecx
  000fc	6b d0 64	 imul	 edx, eax, 100
  000ff	89 55 e4	 mov	 DWORD PTR _sellmoney$3[ebp], edx
  00102	eb 17		 jmp	 SHORT $LN12@GetNeedMon
$LN10@GetNeedMon:

; 8458 : 		else if(sellmoney >= 100)

  00104	83 7d e4 64	 cmp	 DWORD PTR _sellmoney$3[ebp], 100 ; 00000064H
  00108	7c 11		 jl	 SHORT $LN12@GetNeedMon

; 8459 : 			sellmoney = sellmoney/10*10;

  0010a	8b 45 e4	 mov	 eax, DWORD PTR _sellmoney$3[ebp]
  0010d	99		 cdq
  0010e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00113	f7 f9		 idiv	 ecx
  00115	6b d0 0a	 imul	 edx, eax, 10
  00118	89 55 e4	 mov	 DWORD PTR _sellmoney$3[ebp], edx
$LN12@GetNeedMon:

; 8460 : 
; 8461 : 		float fRoot = ( float)sqrt( ( double)sellmoney);

  0011b	f2 0f 2a 45 e4	 cvtsi2sd xmm0, DWORD PTR _sellmoney$3[ebp]
  00120	83 ec 08	 sub	 esp, 8
  00123	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00128	e8 00 00 00 00	 call	 _sqrt
  0012d	83 c4 08	 add	 esp, 8
  00130	d9 5d e0	 fstp	 DWORD PTR _fRoot$2[ebp]

; 8462 : 		float fRootRoot = ( float)sqrt( sqrt( ( double)sellmoney));

  00133	f2 0f 2a 45 e4	 cvtsi2sd xmm0, DWORD PTR _sellmoney$3[ebp]
  00138	83 ec 08	 sub	 esp, 8
  0013b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00140	e8 00 00 00 00	 call	 _sqrt
  00145	dd 1c 24	 fstp	 QWORD PTR [esp]
  00148	e8 00 00 00 00	 call	 _sqrt
  0014d	83 c4 08	 add	 esp, 8
  00150	d9 5d dc	 fstp	 DWORD PTR _fRootRoot$1[ebp]

; 8463 : 		RepaireMoney = 3.f * fRoot * fRootRoot;

  00153	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  0015b	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _fRoot$2[ebp]
  00160	f3 0f 59 45 dc	 mulss	 xmm0, DWORD PTR _fRootRoot$1[ebp]
  00165	f3 0f 11 45 ec	 movss	 DWORD PTR _RepaireMoney$5[ebp], xmm0

; 8464 : 
; 8465 : 		RepaireMoney *= persent;

  0016a	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _RepaireMoney$5[ebp]
  0016f	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _persent$4[ebp]
  00174	f3 0f 11 45 ec	 movss	 DWORD PTR _RepaireMoney$5[ebp], xmm0

; 8466 :         RepaireMoney++;

  00179	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _RepaireMoney$5[ebp]
  0017e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00186	f3 0f 11 45 ec	 movss	 DWORD PTR _RepaireMoney$5[ebp], xmm0

; 8467 : 
; 8468 : 		if( ItemDurability <= 0 )

  0018b	0f 57 c0	 xorps	 xmm0, xmm0
  0018e	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _ItemDurability$[ebp]
  00192	72 54		 jb	 SHORT $LN15@GetNeedMon

; 8469 : 		{	//    +  
; 8470 : #ifdef DARKLORD_WORK
; 8471 : 			if( type == MAKE_ITEMNUM(13,4) || type == MAKE_ITEMNUM(13,5) )

  00194	6a 04		 push	 4
  00196	6a 0d		 push	 13			; 0000000dH
  00198	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0019d	83 c4 08	 add	 esp, 8
  001a0	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001a3	74 11		 je	 SHORT $LN16@GetNeedMon
  001a5	6a 05		 push	 5
  001a7	6a 0d		 push	 13			; 0000000dH
  001a9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001ae	83 c4 08	 add	 esp, 8
  001b1	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001b4	75 14		 jne	 SHORT $LN14@GetNeedMon
$LN16@GetNeedMon:

; 8472 : 			{	// ,     2
; 8473 : 				RepaireMoney *= 2;

  001b6	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _RepaireMoney$5[ebp]
  001bb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  001c3	f3 0f 11 45 ec	 movss	 DWORD PTR _RepaireMoney$5[ebp], xmm0

; 8474 : 			}

  001c8	eb 1e		 jmp	 SHORT $LN15@GetNeedMon
$LN14@GetNeedMon:

; 8475 : 			else
; 8476 : #endif
; 8477 : 				RepaireMoney *= GetAllRepairItemRate(type);

  001ca	8b 45 f8	 mov	 eax, DWORD PTR _type$[ebp]
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 ?GetAllRepairItemRate@@YAMH@Z ; GetAllRepairItemRate
  001d3	83 c4 04	 add	 esp, 4
  001d6	d9 5d 98	 fstp	 DWORD PTR tv223[ebp]
  001d9	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR tv223[ebp]
  001de	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _RepaireMoney$5[ebp]
  001e3	f3 0f 11 45 ec	 movss	 DWORD PTR _RepaireMoney$5[ebp], xmm0
$LN15@GetNeedMon:

; 8478 : 		}
; 8479 : 
; 8480 : 		if( RequestPos == 1 )

  001e8	83 7d 0c 01	 cmp	 DWORD PTR _RequestPos$[ebp], 1
  001ec	75 17		 jne	 SHORT $LN17@GetNeedMon

; 8481 : 		{	//   5%  
; 8482 : 			
; 8483 : #ifdef MODIFY_AUTOREPAIR_CALC_20090608
; 8484 : 			RepaireMoney += RepaireMoney*1.5f;
; 8485 : #else
; 8486 : #ifdef UPDATE_INVEN_REPAIREMONEY_INC_20081112	//  3
; 8487 : 			RepaireMoney += RepaireMoney*2.0f;

  001ee	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _RepaireMoney$5[ebp]
  001f3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  001fb	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _RepaireMoney$5[ebp]
  00200	f3 0f 11 45 ec	 movss	 DWORD PTR _RepaireMoney$5[ebp], xmm0
$LN17@GetNeedMon:

; 8488 : #else	// UPDATE_INVEN_REPAIREMONEY_INC_20081112
; 8489 : 			RepaireMoney += RepaireMoney*0.05f;
; 8490 : #endif	// UPDATE_INVEN_REPAIREMONEY_INC_20081112
; 8491 : #endif //MODIFY_AUTOREPAIR_CALC_20090608
; 8492 : 
; 8493 : #ifdef REPAIR_ITEM_CHANGE	//   100%			
; 8494 : 			if( DurItem->m_Type >= MAKE_ITEMNUM(12,0) && DurItem->m_Type <= MAKE_ITEMNUM(12,6) )
; 8495 : 			{	//   500%
; 8496 : 				RepaireMoney *= 5.f;
; 8497 : 
; 8498 : 			}
; 8499 : 			else
; 8500 : 			{
; 8501 : 				RepaireMoney += RepaireMoney;
; 8502 : 			}
; 8503 : #endif
; 8504 : 		}
; 8505 : #ifdef REPAIR_ITEM_CHANGE
; 8506 : 		else
; 8507 : 		{	
; 8508 : 			if( DurItem->m_Type >= MAKE_ITEMNUM(12,0) && DurItem->m_Type <= MAKE_ITEMNUM(12,6) )
; 8509 : 			{	//   200%
; 8510 : 				RepaireMoney *= 2.f;
; 8511 : 			}
; 8512 : 			else
; 8513 : 			{
; 8514 : 				RepaireMoney -= RepaireMoney*0.4f;
; 8515 : 			}
; 8516 : 		}
; 8517 : #endif
; 8518 : 
; 8519 : 		iMoney = (int)RepaireMoney;

  00205	f3 0f 2c 45 ec	 cvttss2si eax, DWORD PTR _RepaireMoney$5[ebp]
  0020a	89 45 fc	 mov	 DWORD PTR _iMoney$[ebp], eax

; 8520 : 
; 8521 : 		if( iMoney >= 1000 )

  0020d	81 7d fc e8 03
	00 00		 cmp	 DWORD PTR _iMoney$[ebp], 1000 ; 000003e8H
  00214	7c 13		 jl	 SHORT $LN18@GetNeedMon

; 8522 : 		{
; 8523 : 			iMoney = iMoney/100*100;

  00216	8b 45 fc	 mov	 eax, DWORD PTR _iMoney$[ebp]
  00219	99		 cdq
  0021a	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0021f	f7 f9		 idiv	 ecx
  00221	6b d0 64	 imul	 edx, eax, 100
  00224	89 55 fc	 mov	 DWORD PTR _iMoney$[ebp], edx

; 8524 : 		}

  00227	eb 17		 jmp	 SHORT $LN20@GetNeedMon
$LN18@GetNeedMon:

; 8525 : #ifdef	MODIFY_CALREPAIRRATE_20090528
; 8526 : 		else if( iMoney > 100 )
; 8527 : #else
; 8528 : 		else if( iMoney > 10 )

  00229	83 7d fc 0a	 cmp	 DWORD PTR _iMoney$[ebp], 10 ; 0000000aH
  0022d	7e 11		 jle	 SHORT $LN20@GetNeedMon

; 8529 : #endif
; 8530 : 		{
; 8531 : 			iMoney = iMoney/10*10;

  0022f	8b 45 fc	 mov	 eax, DWORD PTR _iMoney$[ebp]
  00232	99		 cdq
  00233	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00238	f7 f9		 idiv	 ecx
  0023a	6b d0 0a	 imul	 edx, eax, 10
  0023d	89 55 fc	 mov	 DWORD PTR _iMoney$[ebp], edx
$LN20@GetNeedMon:

; 8532 : 		}
; 8533 : 	}

  00240	eb 07		 jmp	 SHORT $LN4@GetNeedMon
$LN3@GetNeedMon:

; 8534 : 	else
; 8535 : 	{
; 8536 : 		iMoney = -1;

  00242	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _iMoney$[ebp], -1
$LN4@GetNeedMon:

; 8537 : 	}	
; 8538 : 	return iMoney;

  00249	8b 45 fc	 mov	 eax, DWORD PTR _iMoney$[ebp]
$LN1@GetNeedMon:

; 8539 : }

  0024c	5f		 pop	 edi
  0024d	5e		 pop	 esi
  0024e	5b		 pop	 ebx
  0024f	8b e5		 mov	 esp, ebp
  00251	5d		 pop	 ebp
  00252	c3		 ret	 0
?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z ENDP	; GetNeedMoneyItemDurRepaire
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z
_TEXT	SEGMENT
_spMsg$ = -76						; size = 44
_lpObj$ = -32						; size = 4
_szPass$ = -28						; size = 11
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z PROC	; CSPJoinIdPassRequestTEST, COMDAT

; 3203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3204 : 	char szId[MAX_IDSTRING+1];
; 3205 : 	char szPass[MAX_IDSTRING+1];
; 3206 : 
; 3207 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00016	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 e0	 mov	 DWORD PTR _lpObj$[ebp], eax

; 3208 : 
; 3209 : 	SDHP_IDPASS	spMsg;
; 3210 : 
; 3211 : 	PHeadSetB((LPBYTE)&spMsg, 0x11, sizeof( spMsg ));

  00026	6a 2c		 push	 44			; 0000002cH
  00028	6a 11		 push	 17			; 00000011H
  0002a	8d 45 b4	 lea	 eax, DWORD PTR _spMsg$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3212 : 
; 3213 : 	spMsg.Number     = aIndex;

  00036	66 8b 45 0c	 mov	 ax, WORD PTR _aIndex$[ebp]
  0003a	66 89 45 cc	 mov	 WORD PTR _spMsg$[ebp+24], ax

; 3214 : 
; 3215 : 	wsprintf(szId, "%d",logincounttest);

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?logincounttest@@3HA ; logincounttest
  00043	50		 push	 eax
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd@
  00049	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0004c	51		 push	 ecx
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3216 : 	wsprintf(szPass, "m321");

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_04FLFDNKBN@m321@
  0005b	8d 45 e4	 lea	 eax, DWORD PTR _szPass$[ebp]
  0005e	50		 push	 eax
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00065	83 c4 08	 add	 esp, 8

; 3217 : 	
; 3218 : 	LogAdd("login send : %s %s", szId, szPass);

  00068	8d 45 e4	 lea	 eax, DWORD PTR _szPass$[ebp]
  0006b	50		 push	 eax
  0006c	8d 4d f0	 lea	 ecx, DWORD PTR _szId$[ebp]
  0006f	51		 push	 ecx
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs@
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3219 : 
; 3220 : 	BuxConvert(szId, MAX_IDSTRING);

  0007e	6a 0a		 push	 10			; 0000000aH
  00080	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  00089	83 c4 08	 add	 esp, 8

; 3221 : 	BuxConvert(szPass, MAX_IDSTRING);

  0008c	6a 0a		 push	 10			; 0000000aH
  0008e	8d 45 e4	 lea	 eax, DWORD PTR _szPass$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  00097	83 c4 08	 add	 esp, 8

; 3222 : 
; 3223 : 	memcpy(spMsg.Id,   szId,   MAX_IDSTRING);

  0009a	6a 0a		 push	 10			; 0000000aH
  0009c	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0009f	50		 push	 eax
  000a0	8d 4d b7	 lea	 ecx, DWORD PTR _spMsg$[ebp+3]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 _memcpy
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3224 : 	memcpy(spMsg.Pass, szPass, MAX_IDSTRING);

  000ac	6a 0a		 push	 10			; 0000000aH
  000ae	8d 45 e4	 lea	 eax, DWORD PTR _szPass$[ebp]
  000b1	50		 push	 eax
  000b2	8d 4d c1	 lea	 ecx, DWORD PTR _spMsg$[ebp+13]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 _memcpy
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3225 : 	
; 3226 : 	logincounttest++;

  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?logincounttest@@3HA ; logincounttest
  000c3	83 c0 01	 add	 eax, 1
  000c6	a3 00 00 00 00	 mov	 DWORD PTR ?logincounttest@@3HA, eax ; logincounttest

; 3227 : 	if( GetTickCount()-ltesttime > 1000 )

  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000d1	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ltesttime@@3HA ; ltesttime
  000d7	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  000dc	76 15		 jbe	 SHORT $LN2@CSPJoinIdP

; 3228 : 	{
; 3229 : 		ltesttime = GetTickCount();

  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000e4	a3 00 00 00 00	 mov	 DWORD PTR ?ltesttime@@3HA, eax ; ltesttime

; 3230 : 		logincounttest = 0;

  000e9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?logincounttest@@3HA, 0 ; logincounttest
$LN2@CSPJoinIdP:

; 3231 : 
; 3232 : 	}
; 3233 : 
; 3234 : 	//strcpy(spMsg.IpAddress, gObj[aIndex].sb.Ip_addr);
; 3235 : 	
; 3236 : 	//gObj[aIndex].CheckTick			= lpMsg->TickCount;
; 3237 : 	//gObj[aIndex].CheckTick2			= GetTickCount();
; 3238 : 	//gObj[aIndex].ConnectCheckTime	= GetTickCount();
; 3239 : 	//gObj[aIndex].CheckSpeedHack		= 1;
; 3240 : 	
; 3241 : 	//    .
; 3242 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  000f3	0f b6 45 b5	 movzx	 eax, BYTE PTR _spMsg$[ebp+1]
  000f7	50		 push	 eax
  000f8	8d 4d b4	 lea	 ecx, DWORD PTR _spMsg$[ebp]
  000fb	51		 push	 ecx
  000fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00101	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 3243 : 
; 3244 : 	spMsg.h.headcode = 0x01;

  00106	c6 45 b6 01	 mov	 BYTE PTR _spMsg$[ebp+2], 1

; 3245 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  0010a	0f b6 45 b5	 movzx	 eax, BYTE PTR _spMsg$[ebp+1]
  0010e	50		 push	 eax
  0010f	8d 4d b4	 lea	 ecx, DWORD PTR _spMsg$[ebp]
  00112	51		 push	 ecx
  00113	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00118	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 3246 : }

  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	33 cd		 xor	 ecx, ebp
  00125	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z ENDP	; CSPJoinIdPassRequestTEST
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCServerMsgSend@@YAXEH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_msg$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?GCServerMsgSend@@YAXEH@Z PROC				; GCServerMsgSend, COMDAT

; 2849 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2850 : 	PMSG_SERVERMSG	pMsg;
; 2851 : 
; 2852 : 	PHeadSetB((LPBYTE)&pMsg, 0x0C, sizeof( pMsg ));

  00009	6a 04		 push	 4
  0000b	6a 0c		 push	 12			; 0000000cH
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2853 : 
; 2854 : 	pMsg.MsgNumber	= msg;

  00019	8a 45 08	 mov	 al, BYTE PTR _msg$[ebp]
  0001c	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2855 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001f	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00023	50		 push	 eax
  00024	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2856 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?GCServerMsgSend@@YAXEH@Z ENDP				; GCServerMsgSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?EncryptCheckSumKey@@YAGG@Z
_TEXT	SEGMENT
_wAcc$ = -8						; size = 2
_wRandom$ = -4						; size = 2
_wSource$ = 8						; size = 2
?EncryptCheckSumKey@@YAGG@Z PROC			; EncryptCheckSumKey, COMDAT

; 2093 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2094 : 	WORD wRandom = rand() % 0x40;	// 

  00009	e8 00 00 00 00	 call	 _rand
  0000e	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  00013	79 05		 jns	 SHORT $LN3@EncryptChe
  00015	48		 dec	 eax
  00016	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00019	40		 inc	 eax
$LN3@EncryptChe:
  0001a	66 89 45 fc	 mov	 WORD PTR _wRandom$[ebp], ax

; 2095 : 	WORD wAcc = ( ( wSource & ( 0x3FF - 0xF)) << 6) | ( wRandom << 4) | ( wSource & 0xF);	// 10  6 

  0001e	0f b7 45 08	 movzx	 eax, WORD PTR _wSource$[ebp]
  00022	25 f0 03 00 00	 and	 eax, 1008		; 000003f0H
  00027	c1 e0 06	 shl	 eax, 6
  0002a	0f b7 4d fc	 movzx	 ecx, WORD PTR _wRandom$[ebp]
  0002e	c1 e1 04	 shl	 ecx, 4
  00031	0b c1		 or	 eax, ecx
  00033	0f b7 55 08	 movzx	 edx, WORD PTR _wSource$[ebp]
  00037	83 e2 0f	 and	 edx, 15			; 0000000fH
  0003a	0b c2		 or	 eax, edx
  0003c	66 89 45 f8	 mov	 WORD PTR _wAcc$[ebp], ax

; 2096 : 
; 2097 : 	return ( wAcc ^ 0xB479);

  00040	0f b7 45 f8	 movzx	 eax, WORD PTR _wAcc$[ebp]
  00044	35 79 b4 00 00	 xor	 eax, 46201		; 0000b479H

; 2098 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?EncryptCheckSumKey@@YAGG@Z ENDP			; EncryptCheckSumKey
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?TestSend@@YAXXZ
_TEXT	SEGMENT
_size$ = -2012						; size = 4
_pMsg$ = -2008						; size = 2004
__$ArrayPad$ = -4					; size = 4
?TestSend@@YAXXZ PROC					; TestSend, COMDAT

; 1945 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 08 00
	00		 sub	 esp, 2268		; 000008dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1946 : 	PMSG_TEST	pMsg;
; 1947 : 	int			size;
; 1948 : 
; 1949 : 	size = sizeof( PMSG_TEST );

  00016	c7 85 24 f8 ff
	ff d4 07 00 00	 mov	 DWORD PTR _size$[ebp], 2004 ; 000007d4H

; 1950 : 	pMsg.h.c			= 0xC2;

  00020	c6 85 28 f8 ff
	ff c2		 mov	 BYTE PTR _pMsg$[ebp], 194 ; 000000c2H

; 1951 : 	pMsg.h.headcode		= 0xFF;

  00027	c6 85 2b f8 ff
	ff ff		 mov	 BYTE PTR _pMsg$[ebp+3], 255 ; 000000ffH

; 1952 : 	pMsg.h.sizeH			= HIBYTE(size);

  0002e	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00034	c1 e8 08	 shr	 eax, 8
  00037	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003c	88 85 29 f8 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], al

; 1953 : 	pMsg.h.sizeL			= LOBYTE(size);

  00042	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00048	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004d	88 85 2a f8 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+2], al

; 1954 : 	DataSend(tempindex, (LPBYTE)&pMsg, size);

  00053	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00059	50		 push	 eax
  0005a	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00060	51		 push	 ecx
  00061	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?tempindex@@3HA ; tempindex
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1955 : 	DataSend(tempindex, (LPBYTE)&pMsg, size);

  00070	8b 85 24 f8 ff
	ff		 mov	 eax, DWORD PTR _size$[ebp]
  00076	50		 push	 eax
  00077	8d 8d 28 f8 ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?tempindex@@3HA ; tempindex
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1956 : 	LogAdd("TEST Data Send");

  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KNPEEFN@TEST?5Data?5Send@
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00098	83 c4 04	 add	 esp, 4

; 1957 : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	33 cd		 xor	 ecx, ebp
  000a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
?TestSend@@YAXXZ ENDP					; TestSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?DataEncryptCheck@@YAHHEH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_protoNum$ = 12						; size = 1
_Encrypt$ = 16						; size = 4
?DataEncryptCheck@@YAHHEH@Z PROC			; DataEncryptCheck, COMDAT

; 774  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 775  : 	if( Encrypt == FALSE )

  00009	83 7d 10 00	 cmp	 DWORD PTR _Encrypt$[ebp], 0
  0000d	75 35		 jne	 SHORT $LN2@DataEncryp

; 776  : 	{
; 777  : 		LogAdd("Error-L1 : Not Encrypt %s %d", gObj[aIndex].AccountID, protoNum);

  0000f	0f b6 45 0c	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00013	50		 push	 eax
  00014	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0001b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00021	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00025	50		 push	 eax
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 778  : 		CloseClient(aIndex);

  00034	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0003d	83 c4 04	 add	 esp, 4

; 779  : 		return FALSE;

  00040	33 c0		 xor	 eax, eax
  00042	eb 05		 jmp	 SHORT $LN1@DataEncryp
$LN2@DataEncryp:

; 780  : 	}
; 781  : 	return TRUE;

  00044	b8 01 00 00 00	 mov	 eax, 1
$LN1@DataEncryp:

; 782  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?DataEncryptCheck@@YAHHEH@Z ENDP			; DataEncryptCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z PROC		; PacketCheckTime, COMDAT

; 767  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 768  : 	if( GetTickCount()-lpObj->m_PacketCheckTime < 300 ) return FALSE;

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00012	2b 81 e8 01 00
	00		 sub	 eax, DWORD PTR [ecx+488]
  00018	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  0001d	73 04		 jae	 SHORT $LN2@PacketChec
  0001f	33 c0		 xor	 eax, eax
  00021	eb 14		 jmp	 SHORT $LN1@PacketChec
$LN2@PacketChec:

; 769  : 	lpObj->m_PacketCheckTime = GetTickCount();

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0002c	89 81 e8 01 00
	00		 mov	 DWORD PTR [ecx+488], eax

; 770  : 	return TRUE;

  00032	b8 01 00 00 00	 mov	 eax, 1
$LN1@PacketChec:

; 771  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; PacketCheckTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGCloseWindow@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGCloseWindow@@YAXH@Z PROC				; CGCloseWindow, COMDAT

; 19542: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19543: 	if( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type != 0 )

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0001d	80 e2 03	 and	 dl, 3
  00020	0f b6 c2	 movzx	 eax, dl
  00023	85 c0		 test	 eax, eax
  00025	0f 84 0a 02 00
	00		 je	 $LN1@CGCloseWin
  0002b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00038	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0003f	c0 ea 04	 shr	 dl, 4
  00042	80 e2 0f	 and	 dl, 15			; 0000000fH
  00045	0f b6 c2	 movzx	 eax, dl
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 e5 01 00
	00		 je	 $LN1@CGCloseWin

; 19544: 	{
; 19545: #ifdef CHAOS_BOX_ITEMCOPY_FIX_20041112_FOR_CHS
; 19546: 		if( gObj[aIndex].m_IfState.type == I_CHAOSBOX )	//     

  00050	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005d	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00064	c0 ea 04	 shr	 dl, 4
  00067	80 e2 0f	 and	 dl, 15			; 0000000fH
  0006a	0f b6 c2	 movzx	 eax, dl
  0006d	83 f8 07	 cmp	 eax, 7
  00070	75 05		 jne	 SHORT $LN3@CGCloseWin

; 19547: 		{
; 19548: 			return;

  00072	e9 be 01 00 00	 jmp	 $LN1@CGCloseWin
$LN3@CGCloseWin:

; 19549: 		}
; 19550: #endif
; 19551: 
; 19552: #ifdef SECOND_QUEST
; 19553: 		if( gObj[aIndex].m_IfState.type == I_QUEST && gObj[aIndex].TargetShopNumber == NPC_QEUSTNPC2 )

  00077	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00084	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0008b	c0 ea 04	 shr	 dl, 4
  0008e	80 e2 0f	 and	 dl, 15			; 0000000fH
  00091	0f b6 c2	 movzx	 eax, dl
  00094	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00097	75 3f		 jne	 SHORT $LN4@CGCloseWin
  00099	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a6	0f bf 94 01 ae
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+686]
  000ae	81 fa e5 00 00
	00		 cmp	 edx, 229		; 000000e5H
  000b4	75 22		 jne	 SHORT $LN4@CGCloseWin

; 19554: 		{	//     NPC 2  NPC		
; 19555: 			gQeustNpcTeleport.TalkRefDel();

  000b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  000bb	e8 00 00 00 00	 call	 ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ; CQeustNpcTeleport::TalkRefDel

; 19556: 			gObj[aIndex].TargetShopNumber = -1;	

  000c0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c7	83 c9 ff	 or	 ecx, -1
  000ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d0	66 89 8c 02 ae
	02 00 00	 mov	 WORD PTR [edx+eax+686], cx
$LN4@CGCloseWin:

; 19557: 		}
; 19558: #endif
; 19559: 		if( gObj[aIndex].m_IfState.type == I_SHOP )	//  ..

  000d8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e5	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000ec	c0 ea 04	 shr	 dl, 4
  000ef	80 e2 0f	 and	 dl, 15			; 0000000fH
  000f2	0f b6 c2	 movzx	 eax, dl
  000f5	83 f8 03	 cmp	 eax, 3
  000f8	75 18		 jne	 SHORT $LN5@CGCloseWin

; 19560: 		{
; 19561: 			gObj[aIndex].TargetShopNumber = -1;	

  000fa	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00101	83 c9 ff	 or	 ecx, -1
  00104	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010a	66 89 8c 02 ae
	02 00 00	 mov	 WORD PTR [edx+eax+686], cx
$LN5@CGCloseWin:

; 19562: 		}
; 19563: 
; 19564: #ifdef TRADE_BUG_FIX_CLOSE_WINDOWS_20040727		
; 19565: 		if( gObj[aIndex].m_IfState.type == I_TRADE )

  00112	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00119	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011f	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00126	c0 ea 04	 shr	 dl, 4
  00129	80 e2 0f	 and	 dl, 15			; 0000000fH
  0012c	0f b6 c2	 movzx	 eax, dl
  0012f	83 f8 01	 cmp	 eax, 1
  00132	75 0c		 jne	 SHORT $LN6@CGCloseWin

; 19566: 		{
; 19567: 			CGTradeCancelButtonRecv(aIndex);

  00134	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  0013d	83 c4 04	 add	 esp, 4
$LN6@CGCloseWin:

; 19568: 		}
; 19569: 		
; 19570: 		if( gObj[aIndex].m_IfState.type == I_WAREHOUSE )

  00140	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014d	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00154	c0 ea 04	 shr	 dl, 4
  00157	80 e2 0f	 and	 dl, 15			; 0000000fH
  0015a	0f b6 c2	 movzx	 eax, dl
  0015d	83 f8 06	 cmp	 eax, 6
  00160	75 0c		 jne	 SHORT $LN7@CGCloseWin

; 19571: 		{
; 19572: 			CGWarehouseUseEnd(aIndex);

  00162	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  0016b	83 c4 04	 add	 esp, 4
$LN7@CGCloseWin:

; 19573: 		}				
; 19574: #endif
; 19575: 
; 19576: #ifdef DARKLORD_WORK	//  
; 19577: 		if( gObj[aIndex].m_IfState.type == I_DARK_TRAINER )

  0016e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00175	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017b	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00182	c0 ea 04	 shr	 dl, 4
  00185	80 e2 0f	 and	 dl, 15			; 0000000fH
  00188	0f b6 c2	 movzx	 eax, dl
  0018b	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0018e	75 24		 jne	 SHORT $LN8@CGCloseWin

; 19578: 		{
; 19579: 			g_MixSystem.ChaosBoxInit(&gObj[aIndex]);

  00190	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00197	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019d	50		 push	 eax
  0019e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  001a3	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 19580: 			gObjInventoryCommit(aIndex);

  001a8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  001b1	83 c4 04	 add	 esp, 4
$LN8@CGCloseWin:

; 19581: 		}
; 19582: #endif
; 19583: 
; 19584: #ifdef ADD_NEW_WEAPON_FOR_CASTLE_01_20041116	
; 19585: 		if( gObj[aIndex].m_IfState.type == I_CS_MACHINE_ATTACK 
; 19586: 			|| gObj[aIndex].m_IfState.type == I_CS_MACHINE_DEFENSE )
; 19587: 		{
; 19588: 			
; 19589: 		}
; 19590: 
; 19591: #endif
; 19592: 
; 19593: #ifdef MODIFY_PCBANGPOINTSHOP_CLOSEWINDOWS_BUGFIX_20080218
; 19594: 		if( gObj[aIndex].m_IfState.type == I_PCBANG_POINT_SHOP )	//  ..
; 19595: 		{
; 19596: 			gObj[aIndex].TargetShopNumber = -1;	
; 19597: 		}
; 19598: #endif	// MODIFY_PCBANGPOINTSHOP_CLOSEWINDOWS_BUGFIX_20080218
; 19599: 		
; 19600: 		gObj[aIndex].m_IfState.state = 0;	

  001b4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c1	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  001c8	80 e2 f3	 and	 dl, 243			; 000000f3H
  001cb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d8	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19601: 		gObj[aIndex].m_IfState.type = 0;

  001df	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ec	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  001f3	80 e2 0f	 and	 dl, 15			; 0000000fH
  001f6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00203	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19602: 		gObj[aIndex].m_IfState.use =  0;

  0020a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00211	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00217	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0021e	80 e2 fc	 and	 dl, 252			; 000000fcH
  00221	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00228	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0022e	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN1@CGCloseWin:

; 19603: 
; 19604: #ifdef AUTH_GAMESERVER_CHECKKEY
; 19605: 	if( szAuthKey[7] != AUTH_CHECK_07 )
; 19606: 		DestroyGIocp();
; 19607: #endif
; 19608: 	}
; 19609: }

  00235	5f		 pop	 edi
  00236	5e		 pop	 esi
  00237	5b		 pop	 ebx
  00238	8b e5		 mov	 esp, ebp
  0023a	5d		 pop	 ebp
  0023b	c3		 ret	 0
?CGCloseWindow@@YAXH@Z ENDP				; CGCloseWindow
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z
_TEXT	SEGMENT
tv420 = -96						; size = 4
tv403 = -96						; size = 4
tv360 = -96						; size = 4
tv311 = -96						; size = 4
tv287 = -96						; size = 4
tv232 = -96						; size = 4
tv178 = -96						; size = 4
tv132 = -96						; size = 4
tv73 = -96						; size = 4
tv421 = -92						; size = 4
tv404 = -92						; size = 4
tv361 = -92						; size = 4
tv312 = -92						; size = 4
tv288 = -92						; size = 4
tv233 = -92						; size = 4
tv179 = -92						; size = 4
tv133 = -92						; size = 4
tv74 = -92						; size = 4
_iTargetIndex$1 = -24					; size = 4
_pMsg$ = -20						; size = 12
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z PROC ; CGRequestPetItemInfo, COMDAT

; 22103: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 22104: 	if( gObjIsConnectedGP(aIndex) == FALSE ) 

  00013	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	75 21		 jne	 SHORT $LN2@CGRequestP

; 22105: 	{
; 22106: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z@4JA
  00028	83 c0 03	 add	 eax, 3
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd@
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22107: 		return;

  0003f	e9 ca 07 00 00	 jmp	 $LN1@CGRequestP
$LN2@CGRequestP:

; 22108: 	}
; 22109: 
; 22110: 	if(!CHECK_LIMIT(aIndex, MAX_OBJECT)) 

  00044	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00048	7d 09		 jge	 SHORT $LN42@CGRequestP
  0004a	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00051	eb 1f		 jmp	 SHORT $LN43@CGRequestP
$LN42@CGRequestP:
  00053	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0005a	7e 09		 jle	 SHORT $LN40@CGRequestP
  0005c	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00063	eb 07		 jmp	 SHORT $LN41@CGRequestP
$LN40@CGRequestP:
  00065	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN41@CGRequestP:
  0006c	8b 45 a0	 mov	 eax, DWORD PTR tv73[ebp]
  0006f	89 45 a4	 mov	 DWORD PTR tv74[ebp], eax
$LN43@CGRequestP:
  00072	83 7d a4 00	 cmp	 DWORD PTR tv74[ebp], 0
  00076	75 05		 jne	 SHORT $LN3@CGRequestP

; 22111: 		return;

  00078	e9 91 07 00 00	 jmp	 $LN1@CGRequestP
$LN3@CGRequestP:

; 22112: 
; 22113: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  0007d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00084	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008a	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 22114: 
; 22115: 	if( lpMsg->PetType != 0 && lpMsg->PetType != 1 )

  0008d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00090	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00094	85 c9		 test	 ecx, ecx
  00096	74 11		 je	 SHORT $LN4@CGRequestP
  00098	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0009b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0009f	83 f9 01	 cmp	 ecx, 1
  000a2	74 05		 je	 SHORT $LN4@CGRequestP

; 22116: 		return;	//  

  000a4	e9 65 07 00 00	 jmp	 $LN1@CGRequestP
$LN4@CGRequestP:

; 22117: 
; 22118: 	PMSG_SEND_PET_ITEMINFO pMsg;
; 22119: 	pMsg.h.set((LPBYTE)&pMsg, 0xA9, sizeof(pMsg));

  000a9	6a 0c		 push	 12			; 0000000cH
  000ab	68 a9 00 00 00	 push	 169			; 000000a9H
  000b0	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000b3	50		 push	 eax
  000b4	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000b7	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 22120: 
; 22121: 	pMsg.PetType = lpMsg->PetType;

  000bc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000bf	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  000c2	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 22122: 	pMsg.InvenType = lpMsg->InvenType;

  000c5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000c8	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  000cb	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 22123: 	pMsg.nPos = lpMsg->nPos;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000d1	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  000d4	88 4d f1	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 22124: 
; 22125: 	if( lpMsg->InvenType == 0 )

  000d7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000da	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000de	85 c9		 test	 ecx, ecx
  000e0	0f 85 db 00 00
	00		 jne	 $LN5@CGRequestP

; 22126: 	{	// 
; 22127: 		
; 22128: #ifdef PERSONAL_SHOP_20040113		
; 22129: 		if(!CHECK_LIMIT(lpMsg->nPos, MAX_INVENTORY_EXTEND)) 

  000e6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000e9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000ed	85 c9		 test	 ecx, ecx
  000ef	7d 09		 jge	 SHORT $LN46@CGRequestP
  000f1	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
  000f8	eb 22		 jmp	 SHORT $LN47@CGRequestP
$LN46@CGRequestP:
  000fa	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000fd	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00101	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  00104	7e 09		 jle	 SHORT $LN44@CGRequestP
  00106	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
  0010d	eb 07		 jmp	 SHORT $LN45@CGRequestP
$LN44@CGRequestP:
  0010f	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv132[ebp], 1
$LN45@CGRequestP:
  00116	8b 4d a0	 mov	 ecx, DWORD PTR tv132[ebp]
  00119	89 4d a4	 mov	 DWORD PTR tv133[ebp], ecx
$LN47@CGRequestP:
  0011c	83 7d a4 00	 cmp	 DWORD PTR tv133[ebp], 0
  00120	75 29		 jne	 SHORT $LN7@CGRequestP

; 22130: #else
; 22131: 		if(!CHECK_LIMIT(lpMsg->nPos, MAX_INVENTORY)) 
; 22132: #endif
; 22133: 		{
; 22134: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d", 

  00122	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00125	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00129	51		 push	 ecx
  0012a	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0012d	83 c2 73	 add	 edx, 115		; 00000073H
  00130	52		 push	 edx
  00131	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00134	83 c0 68	 add	 eax, 104		; 00000068H
  00137	50		 push	 eax
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00143	83 c4 10	 add	 esp, 16			; 00000010H

; 22135: 					 lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 22136: 			return;

  00146	e9 c3 06 00 00	 jmp	 $LN1@CGRequestP
$LN7@CGRequestP:

; 22137: 		}
; 22138: 
; 22139: 		if( lpObj->pInventory[lpMsg->nPos].IsItem() )

  0014b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0014e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00152	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00158	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015b	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00161	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00166	85 c0		 test	 eax, eax
  00168	74 52		 je	 SHORT $LN8@CGRequestP

; 22140: 		{
; 22141: 			pMsg.Exp = lpObj->pInventory[lpMsg->nPos].m_PetItem_Exp;

  0016a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0016d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00171	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00177	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017a	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00180	8b 94 11 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+164]
  00187	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx

; 22142: 			pMsg.Level = lpObj->pInventory[lpMsg->nPos].m_PetItem_Level;

  0018a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0018d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00191	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00197	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019a	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  001a0	8a 94 11 a0 00
	00 00		 mov	 dl, BYTE PTR [ecx+edx+160]
  001a7	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl

; 22143: 			
; 22144: #ifdef MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22145: 			pMsg.Life = (BYTE)(lpObj->pInventory[lpMsg->nPos].m_Durability);
; 22146: #endif // MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22147: 
; 22148: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  001aa	6a 0c		 push	 12			; 0000000cH
  001ac	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001af	50		 push	 eax
  001b0	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001b3	51		 push	 ecx
  001b4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001b9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CGRequestP:

; 22149: 		}
; 22150: 	}

  001bc	e9 4d 06 00 00	 jmp	 $LN1@CGRequestP
$LN5@CGRequestP:

; 22151: 	else if( lpMsg->InvenType == 1 )

  001c1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001c4	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001c8	83 f9 01	 cmp	 ecx, 1
  001cb	0f 85 ed 00 00
	00		 jne	 $LN9@CGRequestP

; 22152: 	{	// 
; 22153: 		if( lpObj->LoadWareHouseInfo )

  001d1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d4	0f b6 88 88 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3720]
  001db	85 c9		 test	 ecx, ecx
  001dd	0f 84 d6 00 00
	00		 je	 $LN11@CGRequestP

; 22154: 		{
; 22155: 			if(!CHECK_LIMIT(lpMsg->nPos, MAX_WAREHOUSEITEMS)) 

  001e3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001e6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  001ea	85 c9		 test	 ecx, ecx
  001ec	7d 09		 jge	 SHORT $LN50@CGRequestP
  001ee	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
  001f5	eb 22		 jmp	 SHORT $LN51@CGRequestP
$LN50@CGRequestP:
  001f7	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  001fa	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  001fe	83 f8 77	 cmp	 eax, 119		; 00000077H
  00201	7e 09		 jle	 SHORT $LN48@CGRequestP
  00203	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv178[ebp], 0
  0020a	eb 07		 jmp	 SHORT $LN49@CGRequestP
$LN48@CGRequestP:
  0020c	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv178[ebp], 1
$LN49@CGRequestP:
  00213	8b 4d a0	 mov	 ecx, DWORD PTR tv178[ebp]
  00216	89 4d a4	 mov	 DWORD PTR tv179[ebp], ecx
$LN51@CGRequestP:
  00219	83 7d a4 00	 cmp	 DWORD PTR tv179[ebp], 0
  0021d	75 29		 jne	 SHORT $LN12@CGRequestP

; 22156: 			{
; 22157: 				LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid WareHouse nPos %d", 

  0021f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00222	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00226	51		 push	 ecx
  00227	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0022a	83 c2 73	 add	 edx, 115		; 00000073H
  0022d	52		 push	 edx
  0022e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00231	83 c0 68	 add	 eax, 104		; 00000068H
  00234	50		 push	 eax
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
  0023a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00240	83 c4 10	 add	 esp, 16			; 00000010H

; 22158: 						 lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 22159: 				return;

  00243	e9 c6 05 00 00	 jmp	 $LN1@CGRequestP
$LN12@CGRequestP:

; 22160: 			}
; 22161: 
; 22162: 			if( lpObj->pWarehouse[lpMsg->nPos].IsItem() )

  00248	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0024b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0024f	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00255	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00258	03 8a 94 0c 00
	00		 add	 ecx, DWORD PTR [edx+3220]
  0025e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00263	85 c0		 test	 eax, eax
  00265	74 52		 je	 SHORT $LN11@CGRequestP

; 22163: 			{
; 22164: 				pMsg.Exp = lpObj->pWarehouse[lpMsg->nPos].m_PetItem_Exp;

  00267	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0026a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0026e	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00274	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00277	8b 88 94 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3220]
  0027d	8b 94 11 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+164]
  00284	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx

; 22165: 				pMsg.Level = lpObj->pWarehouse[lpMsg->nPos].m_PetItem_Level;

  00287	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0028a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0028e	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00294	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00297	8b 88 94 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3220]
  0029d	8a 94 11 a0 00
	00 00		 mov	 dl, BYTE PTR [ecx+edx+160]
  002a4	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl

; 22166: 
; 22167: #ifdef MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22168: 				pMsg.Life = (BYTE)(lpObj->pWarehouse[lpMsg->nPos].m_Durability);
; 22169: #endif // MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22170: 
; 22171: 				DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  002a7	6a 0c		 push	 12			; 0000000cH
  002a9	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002ac	50		 push	 eax
  002ad	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002b0	51		 push	 ecx
  002b1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002b6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@CGRequestP:

; 22172: 			}
; 22173: 		}
; 22174: 	}

  002b9	e9 50 05 00 00	 jmp	 $LN1@CGRequestP
$LN9@CGRequestP:

; 22175: 	else if( lpMsg->InvenType == 2 )

  002be	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002c1	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  002c5	83 f9 02	 cmp	 ecx, 2
  002c8	0f 85 0b 01 00
	00		 jne	 $LN14@CGRequestP

; 22176: 	{	// 
; 22177: 		if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_TRADE ) 

  002ce	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d1	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  002d7	80 e1 03	 and	 cl, 3
  002da	0f b6 d1	 movzx	 edx, cl
  002dd	83 fa 01	 cmp	 edx, 1
  002e0	7c 17		 jl	 SHORT $LN17@CGRequestP
  002e2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e5	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  002eb	c0 e9 04	 shr	 cl, 4
  002ee	80 e1 0f	 and	 cl, 15			; 0000000fH
  002f1	0f b6 d1	 movzx	 edx, cl
  002f4	83 fa 01	 cmp	 edx, 1
  002f7	74 05		 je	 SHORT $LN16@CGRequestP
$LN17@CGRequestP:

; 22178: 		{
; 22179: 			return;

  002f9	e9 10 05 00 00	 jmp	 $LN1@CGRequestP
$LN16@CGRequestP:

; 22180: 		}
; 22181: 		if(!CHECK_LIMIT(lpMsg->nPos, MAX_TRADEITEM)) 

  002fe	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00301	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00305	85 c9		 test	 ecx, ecx
  00307	7d 09		 jge	 SHORT $LN54@CGRequestP
  00309	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv233[ebp], 0
  00310	eb 22		 jmp	 SHORT $LN55@CGRequestP
$LN54@CGRequestP:
  00312	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00315	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00319	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0031c	7e 09		 jle	 SHORT $LN52@CGRequestP
  0031e	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv232[ebp], 0
  00325	eb 07		 jmp	 SHORT $LN53@CGRequestP
$LN52@CGRequestP:
  00327	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv232[ebp], 1
$LN53@CGRequestP:
  0032e	8b 4d a0	 mov	 ecx, DWORD PTR tv232[ebp]
  00331	89 4d a4	 mov	 DWORD PTR tv233[ebp], ecx
$LN55@CGRequestP:
  00334	83 7d a4 00	 cmp	 DWORD PTR tv233[ebp], 0
  00338	75 29		 jne	 SHORT $LN18@CGRequestP

; 22182: 		{
; 22183: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Trade nPos %d", 

  0033a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0033d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00341	51		 push	 ecx
  00342	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00345	83 c2 73	 add	 edx, 115		; 00000073H
  00348	52		 push	 edx
  00349	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034c	83 c0 68	 add	 eax, 104		; 00000068H
  0034f	50		 push	 eax
  00350	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
  00355	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0035b	83 c4 10	 add	 esp, 16			; 00000010H

; 22184: 					 lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 22185: 			return;

  0035e	e9 ab 04 00 00	 jmp	 $LN1@CGRequestP
$LN18@CGRequestP:

; 22186: 		}
; 22187: 
; 22188: 		if( lpObj->Trade[lpMsg->nPos].IsItem() )

  00363	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00366	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0036a	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00370	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00373	03 8a 84 0c 00
	00		 add	 ecx, DWORD PTR [edx+3204]
  00379	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0037e	85 c0		 test	 eax, eax
  00380	74 52		 je	 SHORT $LN19@CGRequestP

; 22189: 		{
; 22190: 			pMsg.Exp = lpObj->Trade[lpMsg->nPos].m_PetItem_Exp;

  00382	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00385	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00389	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0038f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00392	8b 88 84 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3204]
  00398	8b 94 11 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+164]
  0039f	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx

; 22191: 			pMsg.Level = lpObj->Trade[lpMsg->nPos].m_PetItem_Level;

  003a2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003a5	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  003a9	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  003af	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b2	8b 88 84 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3204]
  003b8	8a 94 11 a0 00
	00 00		 mov	 dl, BYTE PTR [ecx+edx+160]
  003bf	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl

; 22192: 
; 22193: #ifdef MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22194: 			pMsg.Life = (BYTE)(lpObj->Trade[lpMsg->nPos].m_Durability);
; 22195: #endif // MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22196: 
; 22197: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  003c2	6a 0c		 push	 12			; 0000000cH
  003c4	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  003c7	50		 push	 eax
  003c8	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  003cb	51		 push	 ecx
  003cc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@CGRequestP:

; 22198: 		}
; 22199: 	}

  003d4	e9 35 04 00 00	 jmp	 $LN1@CGRequestP
$LN14@CGRequestP:

; 22200: 	else if( lpMsg->InvenType == 3 )

  003d9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003dc	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  003e0	83 f9 03	 cmp	 ecx, 3
  003e3	0f 85 ce 01 00
	00		 jne	 $LN20@CGRequestP

; 22201: 	{	// 
; 22202: 		if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_TRADE ) 

  003e9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ec	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  003f2	80 e1 03	 and	 cl, 3
  003f5	0f b6 d1	 movzx	 edx, cl
  003f8	83 fa 01	 cmp	 edx, 1
  003fb	7c 17		 jl	 SHORT $LN23@CGRequestP
  003fd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00400	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00406	c0 e9 04	 shr	 cl, 4
  00409	80 e1 0f	 and	 cl, 15			; 0000000fH
  0040c	0f b6 d1	 movzx	 edx, cl
  0040f	83 fa 01	 cmp	 edx, 1
  00412	74 05		 je	 SHORT $LN22@CGRequestP
$LN23@CGRequestP:

; 22203: 		{
; 22204: 			return;

  00414	e9 f5 03 00 00	 jmp	 $LN1@CGRequestP
$LN22@CGRequestP:

; 22205: 		}
; 22206: 
; 22207: 		int iTargetIndex = gObj[aIndex].TargetNumber;

  00419	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00420	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00426	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  0042e	89 55 e8	 mov	 DWORD PTR _iTargetIndex$1[ebp], edx

; 22208: 		if( iTargetIndex < 0 )

  00431	83 7d e8 00	 cmp	 DWORD PTR _iTargetIndex$1[ebp], 0
  00435	7d 05		 jge	 SHORT $LN24@CGRequestP

; 22209: 		{
; 22210: 			return;

  00437	e9 d2 03 00 00	 jmp	 $LN1@CGRequestP
$LN24@CGRequestP:

; 22211: 		}
; 22212: 
; 22213: 		if(!CHECK_LIMIT(iTargetIndex, MAX_OBJECT)) 

  0043c	83 7d e8 00	 cmp	 DWORD PTR _iTargetIndex$1[ebp], 0
  00440	7d 09		 jge	 SHORT $LN58@CGRequestP
  00442	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv288[ebp], 0
  00449	eb 1f		 jmp	 SHORT $LN59@CGRequestP
$LN58@CGRequestP:
  0044b	81 7d e8 e7 1c
	00 00		 cmp	 DWORD PTR _iTargetIndex$1[ebp], 7399 ; 00001ce7H
  00452	7e 09		 jle	 SHORT $LN56@CGRequestP
  00454	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv287[ebp], 0
  0045b	eb 07		 jmp	 SHORT $LN57@CGRequestP
$LN56@CGRequestP:
  0045d	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv287[ebp], 1
$LN57@CGRequestP:
  00464	8b 45 a0	 mov	 eax, DWORD PTR tv287[ebp]
  00467	89 45 a4	 mov	 DWORD PTR tv288[ebp], eax
$LN59@CGRequestP:
  0046a	83 7d a4 00	 cmp	 DWORD PTR tv288[ebp], 0
  0046e	75 05		 jne	 SHORT $LN25@CGRequestP

; 22214: 		{
; 22215: 			return;

  00470	e9 99 03 00 00	 jmp	 $LN1@CGRequestP
$LN25@CGRequestP:

; 22216: 		}
; 22217: 
; 22218: 		if( gObj[iTargetIndex].m_IfState.use < 1 || gObj[iTargetIndex].m_IfState.type != I_TRADE ) 

  00475	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTargetIndex$1[ebp], 7072
  0047c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00482	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00489	80 e2 03	 and	 dl, 3
  0048c	0f b6 c2	 movzx	 eax, dl
  0048f	83 f8 01	 cmp	 eax, 1
  00492	7c 22		 jl	 SHORT $LN27@CGRequestP
  00494	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTargetIndex$1[ebp], 7072
  0049b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004a1	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  004a8	c0 ea 04	 shr	 dl, 4
  004ab	80 e2 0f	 and	 dl, 15			; 0000000fH
  004ae	0f b6 c2	 movzx	 eax, dl
  004b1	83 f8 01	 cmp	 eax, 1
  004b4	74 05		 je	 SHORT $LN26@CGRequestP
$LN27@CGRequestP:

; 22219: 		{
; 22220: 			return;

  004b6	e9 53 03 00 00	 jmp	 $LN1@CGRequestP
$LN26@CGRequestP:

; 22221: 		}
; 22222: 
; 22223: 		if(!CHECK_LIMIT(lpMsg->nPos, MAX_TRADEITEM)) 

  004bb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004be	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  004c2	85 c9		 test	 ecx, ecx
  004c4	7d 09		 jge	 SHORT $LN62@CGRequestP
  004c6	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv312[ebp], 0
  004cd	eb 22		 jmp	 SHORT $LN63@CGRequestP
$LN62@CGRequestP:
  004cf	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  004d2	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  004d6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004d9	7e 09		 jle	 SHORT $LN60@CGRequestP
  004db	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv311[ebp], 0
  004e2	eb 07		 jmp	 SHORT $LN61@CGRequestP
$LN60@CGRequestP:
  004e4	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv311[ebp], 1
$LN61@CGRequestP:
  004eb	8b 4d a0	 mov	 ecx, DWORD PTR tv311[ebp]
  004ee	89 4d a4	 mov	 DWORD PTR tv312[ebp], ecx
$LN63@CGRequestP:
  004f1	83 7d a4 00	 cmp	 DWORD PTR tv312[ebp], 0
  004f5	75 29		 jne	 SHORT $LN28@CGRequestP

; 22224: 		{
; 22225: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid TargetTrade nPos %d", 

  004f7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004fa	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  004fe	51		 push	 ecx
  004ff	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00502	83 c2 73	 add	 edx, 115		; 00000073H
  00505	52		 push	 edx
  00506	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00509	83 c0 68	 add	 eax, 104		; 00000068H
  0050c	50		 push	 eax
  0050d	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
  00512	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00518	83 c4 10	 add	 esp, 16			; 00000010H

; 22226: 					 lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 22227: 			return;

  0051b	e9 ee 02 00 00	 jmp	 $LN1@CGRequestP
$LN28@CGRequestP:

; 22228: 		}
; 22229: 
; 22230: 		if( gObj[iTargetIndex].Trade[lpMsg->nPos].IsItem() )

  00520	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTargetIndex$1[ebp], 7072
  00527	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0052a	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  0052e	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00534	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0053a	03 8c 02 84 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3204]
  00541	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00546	85 c0		 test	 eax, eax
  00548	74 68		 je	 SHORT $LN29@CGRequestP

; 22231: 		{
; 22232: 			pMsg.Exp = gObj[iTargetIndex].Trade[lpMsg->nPos].m_PetItem_Exp;

  0054a	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTargetIndex$1[ebp], 7072
  00551	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00554	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00558	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  0055e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00564	8b 84 02 84 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3204]
  0056b	8b 8c 08 a4 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+164]
  00572	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx

; 22233: 			pMsg.Level = gObj[iTargetIndex].Trade[lpMsg->nPos].m_PetItem_Level;

  00575	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTargetIndex$1[ebp], 7072
  0057c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0057f	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00583	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00589	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0058f	8b 84 02 84 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3204]
  00596	8a 8c 08 a0 00
	00 00		 mov	 cl, BYTE PTR [eax+ecx+160]
  0059d	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl

; 22234: 
; 22235: #ifdef MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22236: 			pMsg.Life = (BYTE)(gObj[iTargetIndex].Trade[lpMsg->nPos].m_Durability);
; 22237: #endif // MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22238: 
; 22239: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  005a0	6a 0c		 push	 12			; 0000000cH
  005a2	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  005a5	50		 push	 eax
  005a6	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  005a9	51		 push	 ecx
  005aa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@CGRequestP:

; 22240: 		}
; 22241: 	}

  005b2	e9 57 02 00 00	 jmp	 $LN1@CGRequestP
$LN20@CGRequestP:

; 22242: 	else if( lpMsg->InvenType == 4 )

  005b7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  005ba	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  005be	83 f9 04	 cmp	 ecx, 4
  005c1	0f 85 db 00 00
	00		 jne	 $LN30@CGRequestP

; 22243: 	{	//  
; 22244: 		if(!CHECK_LIMIT(lpMsg->nPos, MAX_CHAOSBOXSIZE)) 

  005c7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  005ca	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  005ce	85 c9		 test	 ecx, ecx
  005d0	7d 09		 jge	 SHORT $LN66@CGRequestP
  005d2	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv361[ebp], 0
  005d9	eb 22		 jmp	 SHORT $LN67@CGRequestP
$LN66@CGRequestP:
  005db	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  005de	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  005e2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  005e5	7e 09		 jle	 SHORT $LN64@CGRequestP
  005e7	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv360[ebp], 0
  005ee	eb 07		 jmp	 SHORT $LN65@CGRequestP
$LN64@CGRequestP:
  005f0	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv360[ebp], 1
$LN65@CGRequestP:
  005f7	8b 4d a0	 mov	 ecx, DWORD PTR tv360[ebp]
  005fa	89 4d a4	 mov	 DWORD PTR tv361[ebp], ecx
$LN67@CGRequestP:
  005fd	83 7d a4 00	 cmp	 DWORD PTR tv361[ebp], 0
  00601	75 29		 jne	 SHORT $LN32@CGRequestP

; 22245: 		{
; 22246: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Chaos nPos %d", 

  00603	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00606	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0060a	51		 push	 ecx
  0060b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0060e	83 c2 73	 add	 edx, 115		; 00000073H
  00611	52		 push	 edx
  00612	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00615	83 c0 68	 add	 eax, 104		; 00000068H
  00618	50		 push	 eax
  00619	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
  0061e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00624	83 c4 10	 add	 esp, 16			; 00000010H

; 22247: 					 lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 22248: 			return;

  00627	e9 e2 01 00 00	 jmp	 $LN1@CGRequestP
$LN32@CGRequestP:

; 22249: 		}
; 22250: 
; 22251: 		if( lpObj->pChaosBox[lpMsg->nPos].IsItem() )

  0062c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0062f	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00633	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00639	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0063c	03 8a ac 0c 00
	00		 add	 ecx, DWORD PTR [edx+3244]
  00642	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00647	85 c0		 test	 eax, eax
  00649	74 52		 je	 SHORT $LN33@CGRequestP

; 22252: 		{
; 22253: 			pMsg.Exp = lpObj->pChaosBox[lpMsg->nPos].m_PetItem_Exp;

  0064b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0064e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00652	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00658	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0065b	8b 88 ac 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3244]
  00661	8b 94 11 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+164]
  00668	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx

; 22254: 			pMsg.Level = lpObj->pChaosBox[lpMsg->nPos].m_PetItem_Level;

  0066b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0066e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00672	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00678	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0067b	8b 88 ac 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3244]
  00681	8a 94 11 a0 00
	00 00		 mov	 dl, BYTE PTR [ecx+edx+160]
  00688	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl

; 22255: 
; 22256: #ifdef MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22257: 			pMsg.Life = (BYTE)(lpObj->pChaosBox[lpMsg->nPos].m_Durability);
; 22258: #endif // MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22259: 
; 22260: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0068b	6a 0c		 push	 12			; 0000000cH
  0068d	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00690	50		 push	 eax
  00691	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00694	51		 push	 ecx
  00695	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0069a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN33@CGRequestP:

; 22261: 		}
; 22262: 	}

  0069d	e9 6c 01 00 00	 jmp	 $LN1@CGRequestP
$LN30@CGRequestP:

; 22263: 	else if( lpMsg->InvenType == 5 )

  006a2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006a5	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  006a9	83 f9 05	 cmp	 ecx, 5
  006ac	0f 85 5c 01 00
	00		 jne	 $LN1@CGRequestP

; 22264: 	{	//  
; 22265: #ifdef PERSONAL_SHOP_20040113		
; 22266: 		if(!CHECK_LIMIT(lpMsg->nPos, MAX_INVENTORY_EXTEND)) 

  006b2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006b5	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  006b9	85 c9		 test	 ecx, ecx
  006bb	7d 09		 jge	 SHORT $LN70@CGRequestP
  006bd	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv404[ebp], 0
  006c4	eb 22		 jmp	 SHORT $LN71@CGRequestP
$LN70@CGRequestP:
  006c6	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  006c9	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  006cd	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  006d0	7e 09		 jle	 SHORT $LN68@CGRequestP
  006d2	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv403[ebp], 0
  006d9	eb 07		 jmp	 SHORT $LN69@CGRequestP
$LN68@CGRequestP:
  006db	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv403[ebp], 1
$LN69@CGRequestP:
  006e2	8b 4d a0	 mov	 ecx, DWORD PTR tv403[ebp]
  006e5	89 4d a4	 mov	 DWORD PTR tv404[ebp], ecx
$LN71@CGRequestP:
  006e8	83 7d a4 00	 cmp	 DWORD PTR tv404[ebp], 0
  006ec	75 29		 jne	 SHORT $LN35@CGRequestP

; 22267: #else
; 22268: 		if(!CHECK_LIMIT(lpMsg->nPos, MAX_INVENTORY)) 
; 22269: #endif
; 22270: 		{
; 22271: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d", 

  006ee	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006f1	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  006f5	51		 push	 ecx
  006f6	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006f9	83 c2 73	 add	 edx, 115		; 00000073H
  006fc	52		 push	 edx
  006fd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00700	83 c0 68	 add	 eax, 104		; 00000068H
  00703	50		 push	 eax
  00704	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIt@
  00709	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0070f	83 c4 10	 add	 esp, 16			; 00000010H

; 22272: 					 lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 22273: 			return;

  00712	e9 f7 00 00 00	 jmp	 $LN1@CGRequestP
$LN35@CGRequestP:

; 22274: 		}
; 22275: 
; 22276: 		if( lpObj->m_iPShopDealerIndex != -1 )

  00717	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071a	83 b8 24 0d 00
	00 ff		 cmp	 DWORD PTR [eax+3364], -1
  00721	0f 84 e7 00 00
	00		 je	 $LN1@CGRequestP

; 22277: 		{
; 22278: 			if(CHECK_LIMIT(lpObj->m_iPShopDealerIndex, MAX_OBJECT)) 

  00727	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0072a	83 b8 24 0d 00
	00 00		 cmp	 DWORD PTR [eax+3364], 0
  00731	7d 09		 jge	 SHORT $LN74@CGRequestP
  00733	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv421[ebp], 0
  0073a	eb 25		 jmp	 SHORT $LN75@CGRequestP
$LN74@CGRequestP:
  0073c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0073f	81 b9 24 0d 00
	00 e7 1c 00 00	 cmp	 DWORD PTR [ecx+3364], 7399 ; 00001ce7H
  00749	7e 09		 jle	 SHORT $LN72@CGRequestP
  0074b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv420[ebp], 0
  00752	eb 07		 jmp	 SHORT $LN73@CGRequestP
$LN72@CGRequestP:
  00754	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv420[ebp], 1
$LN73@CGRequestP:
  0075b	8b 55 a0	 mov	 edx, DWORD PTR tv420[ebp]
  0075e	89 55 a4	 mov	 DWORD PTR tv421[ebp], edx
$LN75@CGRequestP:
  00761	83 7d a4 00	 cmp	 DWORD PTR tv421[ebp], 0
  00765	0f 84 a3 00 00
	00		 je	 $LN1@CGRequestP

; 22279: 			{	
; 22280: 				if( gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].IsItem() )				

  0076b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0076e	69 88 24 0d 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+3364], 7072
  00778	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0077b	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  0077f	69 d0 a8 00 00
	00		 imul	 edx, eax, 168
  00785	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0078a	03 94 08 5c 0c
	00 00		 add	 edx, DWORD PTR [eax+ecx+3164]
  00791	8b ca		 mov	 ecx, edx
  00793	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00798	85 c0		 test	 eax, eax
  0079a	74 72		 je	 SHORT $LN1@CGRequestP

; 22281: 				{
; 22282: 					pMsg.Exp = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Exp;

  0079c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0079f	69 88 24 0d 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+3364], 7072
  007a9	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  007ac	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  007b0	69 d0 a8 00 00
	00		 imul	 edx, eax, 168
  007b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007bb	8b 8c 08 5c 0c
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+3164]
  007c2	8b 94 11 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+164]
  007c9	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+8], edx

; 22283: 					pMsg.Level = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Level;

  007cc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007cf	69 88 24 0d 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+3364], 7072
  007d9	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  007dc	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  007e0	69 d0 a8 00 00
	00		 imul	 edx, eax, 168
  007e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007eb	8b 8c 08 5c 0c
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+3164]
  007f2	8a 94 11 a0 00
	00 00		 mov	 dl, BYTE PTR [ecx+edx+160]
  007f9	88 55 f2	 mov	 BYTE PTR _pMsg$[ebp+6], dl

; 22284: 
; 22285: #ifdef MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22286: 					pMsg.Life = (BYTE)(gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_Durability);
; 22287: #endif // MODIFY_DARKLORD_SEND_INFO_PROTOCOL_EXTEND_20080626
; 22288: 
; 22289: 					DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  007fc	6a 0c		 push	 12			; 0000000cH
  007fe	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00801	50		 push	 eax
  00802	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00805	51		 push	 ecx
  00806	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0080b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGRequestP:

; 22290: 				}
; 22291: 			}
; 22292: 		}
; 22293: 	}
; 22294: }

  0080e	5f		 pop	 edi
  0080f	5e		 pop	 esi
  00810	5b		 pop	 ebx
  00811	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00814	33 cd		 xor	 ecx, ebp
  00816	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0081b	8b e5		 mov	 esp, ebp
  0081d	5d		 pop	 ebp
  0081e	c3		 ret	 0
?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ENDP ; CGRequestPetItemInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z
_TEXT	SEGMENT
tv73 = -80						; size = 4
tv74 = -76						; size = 4
_iTargetIndex$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z PROC ; CGRequestPetItemCommand, COMDAT

; 22082: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 22083: 	if( gObjIsConnectedGP(aIndex) == FALSE ) 

  00009	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	75 21		 jne	 SHORT $LN2@CGRequestP

; 22084: 	{
; 22085: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z@4JA
  0001e	83 c0 03	 add	 eax, 3
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22086: 		return;

  00035	e9 99 00 00 00	 jmp	 $LN1@CGRequestP
$LN2@CGRequestP:

; 22087: 	}
; 22088: 
; 22089: 	if(!CHECK_LIMIT(aIndex, MAX_OBJECT)) 

  0003a	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0003e	7d 09		 jge	 SHORT $LN8@CGRequestP
  00040	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00047	eb 1f		 jmp	 SHORT $LN9@CGRequestP
$LN8@CGRequestP:
  00049	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00050	7e 09		 jle	 SHORT $LN6@CGRequestP
  00052	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00059	eb 07		 jmp	 SHORT $LN7@CGRequestP
$LN6@CGRequestP:
  0005b	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN7@CGRequestP:
  00062	8b 45 b0	 mov	 eax, DWORD PTR tv73[ebp]
  00065	89 45 b4	 mov	 DWORD PTR tv74[ebp], eax
$LN9@CGRequestP:
  00068	83 7d b4 00	 cmp	 DWORD PTR tv74[ebp], 0
  0006c	75 02		 jne	 SHORT $LN3@CGRequestP

; 22090: 		return;

  0006e	eb 63		 jmp	 SHORT $LN1@CGRequestP
$LN3@CGRequestP:

; 22091: 
; 22092: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00070	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00077	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007d	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 22093: 
; 22094: 	if( lpMsg->PetType != 0 )

  00080	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00083	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00087	85 c9		 test	 ecx, ecx
  00089	74 02		 je	 SHORT $LN4@CGRequestP

; 22095: 		return;	//  

  0008b	eb 46		 jmp	 SHORT $LN1@CGRequestP
$LN4@CGRequestP:

; 22096: 
; 22097: 	int iTargetIndex = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  0008d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00090	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00094	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0009a	0f b6 d1	 movzx	 edx, cl
  0009d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a0	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000a4	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000aa	0f b6 c1	 movzx	 eax, cl
  000ad	c1 e0 08	 shl	 eax, 8
  000b0	0b d0		 or	 edx, eax
  000b2	0f b7 ca	 movzx	 ecx, dx
  000b5	89 4d f8	 mov	 DWORD PTR _iTargetIndex$[ebp], ecx

; 22098: 	gDarkSpirit[aIndex].ChangeCommand(lpMsg->Command,iTargetIndex);

  000b8	8b 45 f8	 mov	 eax, DWORD PTR _iTargetIndex$[ebp]
  000bb	50		 push	 eax
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000bf	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  000c3	52		 push	 edx
  000c4	6b 4d 0c 28	 imul	 ecx, DWORD PTR _aIndex$[ebp], 40
  000c8	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  000ce	e8 00 00 00 00	 call	 ?ChangeCommand@CDarkSpirit@@QAEXHH@Z ; CDarkSpirit::ChangeCommand
$LN1@CGRequestP:

; 22099: 
; 22100: }

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ENDP ; CGRequestPetItemCommand
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z
_TEXT	SEGMENT
_usebp$1 = -28						; size = 4
_usemana$2 = -24					; size = 4
_iTargetIndex$ = -20					; size = 4
_pAttack$ = -16						; size = 8
_y$ = -6						; size = 1
_x$ = -5						; size = 1
_lpMagic$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z PROC ; CGTargetTeleportRecv, COMDAT

; 15963: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15964: 
; 15965: #ifdef ADD_NEW_SKILL_FOR_CASTLE_02_20050531
; 15966: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )
; 15967: 		return;
; 15968: 
; 15969: 	//       .
; 15970: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 15971: 	if( gObjCheckUsedBuffEffect( &gObj[aIndex], BUFFTYPE_STUN ) == true )
; 15972: 	#else
; 15973: 	if( gObj[aIndex].m_iSkillStunTime > 0 )
; 15974: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 15975: 		return;
; 15976: #endif
; 15977: 
; 15978: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//    .
; 15979: 	if( gObjCheckUsedBuffEffect( &gObj[aIndex], BUFFTYPE_SLEEP ) == true )
; 15980: 		return;
; 15981: #endif
; 15982: 
; 15983: 	//LogAdd("   Recv %s %d", gObj[aIndex].Name, lpMsg->MoveNumber);	
; 15984: 	CMagicInf *lpMagic;
; 15985: 	BYTE x, y;
; 15986: 	
; 15987: 	PMSG_MAGICATTACK_RESULT	pAttack;
; 15988: 	
; 15989: 	PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof( pAttack));

  00009	6a 08		 push	 8
  0000b	6a 19		 push	 25			; 00000019H
  0000d	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15990: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD 
; 15991: 	pAttack.MagicNumberH   = HIBYTE( AT_SKILL_TARGET_TELEPORT );
; 15992: 	pAttack.MagicNumberL   = LOBYTE( AT_SKILL_TARGET_TELEPORT );
; 15993: #else
; 15994: 	pAttack.MagicNumber   = AT_SKILL_TARGET_TELEPORT;

  00019	c6 45 f3 0f	 mov	 BYTE PTR _pAttack$[ebp+3], 15 ; 0000000fH

; 15995: #endif
; 15996: 	pAttack.SourceNumberH = HIBYTE(aIndex);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00020	c1 e8 08	 shr	 eax, 8
  00023	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00028	88 45 f4	 mov	 BYTE PTR _pAttack$[ebp+4], al

; 15997: 	pAttack.SourceNumberL = LOBYTE(aIndex);	

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0002e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00033	88 45 f5	 mov	 BYTE PTR _pAttack$[ebp+5], al

; 15998: 
; 15999: 	int iTargetIndex = MAKEWORD(lpMsg->NumberH,lpMsg->NumberL);

  00036	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00039	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0003d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00043	0f b6 d1	 movzx	 edx, cl
  00046	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00049	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0004d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00053	0f b6 c1	 movzx	 eax, cl
  00056	c1 e0 08	 shl	 eax, 8
  00059	0b d0		 or	 edx, eax
  0005b	0f b7 ca	 movzx	 ecx, dx
  0005e	89 4d ec	 mov	 DWORD PTR _iTargetIndex$[ebp], ecx

; 16000: 
; 16001: 	pAttack.TargetNumberH = HIBYTE(iTargetIndex);

  00061	8b 45 ec	 mov	 eax, DWORD PTR _iTargetIndex$[ebp]
  00064	c1 e8 08	 shr	 eax, 8
  00067	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0006c	88 45 f6	 mov	 BYTE PTR _pAttack$[ebp+6], al

; 16002: 	pAttack.TargetNumberL = LOBYTE(iTargetIndex);

  0006f	8b 45 ec	 mov	 eax, DWORD PTR _iTargetIndex$[ebp]
  00072	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00077	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al

; 16003: 	
; 16004: 
; 16005: 	lpMagic  = gObjGetMagicSearch(&gObj[aIndex], AT_SKILL_TARGET_TELEPORT);

  0007a	6a 0f		 push	 15			; 0000000fH
  0007c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00083	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  0008f	83 c4 08	 add	 esp, 8
  00092	89 45 fc	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 16006: 
; 16007: 	x = lpMsg->MapX;

  00095	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00098	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  0009b	88 4d fb	 mov	 BYTE PTR _x$[ebp], cl

; 16008: 	y = lpMsg->MapY;

  0009e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a1	8a 48 06	 mov	 cl, BYTE PTR [eax+6]
  000a4	88 4d fa	 mov	 BYTE PTR _y$[ebp], cl

; 16009: 
; 16010: 	if( gObjIsConnectedGP(iTargetIndex) == FALSE ) 

  000a7	8b 45 ec	 mov	 eax, DWORD PTR _iTargetIndex$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  000b0	83 c4 04	 add	 esp, 4
  000b3	85 c0		 test	 eax, eax
  000b5	75 41		 jne	 SHORT $LN2@CGTargetTe

; 16011: 	{
; 16012: 		LogAddC(LOGC_RED, "[%s][%s] Try Target Teleport Not Move Area [%d,%d]", 

  000b7	0f b6 45 fa	 movzx	 eax, BYTE PTR _y$[ebp]
  000bb	50		 push	 eax
  000bc	0f b6 4d fb	 movzx	 ecx, BYTE PTR _x$[ebp]
  000c0	51		 push	 ecx
  000c1	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cd	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  000d1	51		 push	 ecx
  000d2	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000de	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  000e2	51		 push	 ecx
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5No@
  000e8	6a 02		 push	 2
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000f0	83 c4 18	 add	 esp, 24			; 00000018H

; 16013: 			   gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);
; 16014: 
; 16015: 		return;

  000f3	e9 f3 01 00 00	 jmp	 $LN1@CGTargetTe
$LN2@CGTargetTe:

; 16016: 	}
; 16017: 
; 16018: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//        
; 16019: 	if(CHECK_ILLUSION_TEMPLE(gObj[iTargetIndex].MapNumber))
; 16020: 	{
; 16021: 		if(g_IllusionTempleEvent.CheckRelics(gObj[iTargetIndex].m_Index))
; 16022: 		{
; 16023: 			return;
; 16024: 		}
; 16025: 	}
; 16026: #endif
; 16027: 
; 16028: 	if( gObj[aIndex].PartyNumber != gObj[iTargetIndex].PartyNumber
; 16029: #ifdef MODIFY_TELEPORT_SKILL_USING_PARTY_MEMBER_20060504
; 16030: 		|| gObj[aIndex].PartyNumber == -1
; 16031: 		|| gObj[iTargetIndex].PartyNumber == -1

  000f8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ff	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _iTargetIndex$[ebp], 7072
  00106	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00112	8b 84 02 88 02
	00 00		 mov	 eax, DWORD PTR [edx+eax+648]
  00119	3b 84 0e 88 02
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+648]
  00120	75 2e		 jne	 SHORT $LN4@CGTargetTe
  00122	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00129	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012f	83 bc 01 88 02
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+648], -1
  00137	74 17		 je	 SHORT $LN4@CGTargetTe
  00139	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _iTargetIndex$[ebp], 7072
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00146	83 bc 01 88 02
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+648], -1
  0014e	75 05		 jne	 SHORT $LN3@CGTargetTe
$LN4@CGTargetTe:

; 16032: #endif
; 16033: 		)
; 16034: 	{
; 16035: #ifndef MODIFY_TELEPORT_SKILL_USING_PARTY_MEMBER_20060504
; 16036: 		//  ..   
; 16037: 		PMSG_TELEPORT_RESULT	pTeleportResult;
; 16038: 		pTeleportResult.h.c		= PMHCE_BYTE;
; 16039: 		pTeleportResult.h.size		= sizeof( pTeleportResult );
; 16040: 		pTeleportResult.h.headcode = 0x1C;
; 16041: 		pTeleportResult.MoveNumber = 0;
; 16042: 		pTeleportResult.MapNumber  = gObj[iTargetIndex].MapNumber;
; 16043: 		pTeleportResult.MapX		= gObj[iTargetIndex].X;
; 16044: 		pTeleportResult.MapY		= gObj[iTargetIndex].Y;
; 16045: 		pTeleportResult.Dir		= gObj[iTargetIndex].Dir;			
; 16046: 
; 16047: 		DataSend(iTargetIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);	
; 16048: #endif
; 16049: 		return;

  00150	e9 96 01 00 00	 jmp	 $LN1@CGTargetTe
$LN3@CGTargetTe:

; 16050: 	}
; 16051: 
; 16052: 	if( !gObjCheckTeleportArea(iTargetIndex, x, y) )

  00155	0f b6 45 fa	 movzx	 eax, BYTE PTR _y$[ebp]
  00159	50		 push	 eax
  0015a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _x$[ebp]
  0015e	51		 push	 ecx
  0015f	8b 55 ec	 mov	 edx, DWORD PTR _iTargetIndex$[ebp]
  00162	52		 push	 edx
  00163	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016b	85 c0		 test	 eax, eax
  0016d	75 41		 jne	 SHORT $LN5@CGTargetTe

; 16053: 	{
; 16054: 		LogAddC(LOGC_RED, "[%s][%s] Try Target Teleport Not Move Area [%d,%d]", 

  0016f	0f b6 45 fa	 movzx	 eax, BYTE PTR _y$[ebp]
  00173	50		 push	 eax
  00174	0f b6 4d fb	 movzx	 ecx, BYTE PTR _x$[ebp]
  00178	51		 push	 ecx
  00179	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00185	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00189	51		 push	 ecx
  0018a	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00191	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00196	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  0019a	51		 push	 ecx
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5No@
  001a0	6a 02		 push	 2
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001a8	83 c4 18	 add	 esp, 24			; 00000018H

; 16055: 			   gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);
; 16056: 
; 16057: #ifndef MODIFY_TELEPORT_SKILL_USING_PARTY_MEMBER_20060504
; 16058: 		//  ..   
; 16059: 		PMSG_TELEPORT_RESULT	pTeleportResult;
; 16060: 		pTeleportResult.h.c		= PMHCE_BYTE;
; 16061: 		pTeleportResult.h.size		= sizeof( pTeleportResult );
; 16062: 		pTeleportResult.h.headcode = 0x1C;
; 16063: 		pTeleportResult.MoveNumber = 0;
; 16064: 		pTeleportResult.MapNumber  = gObj[iTargetIndex].MapNumber;
; 16065: 		pTeleportResult.MapX		= gObj[iTargetIndex].X;
; 16066: 		pTeleportResult.MapY		= gObj[iTargetIndex].Y;
; 16067: 		pTeleportResult.Dir		= gObj[iTargetIndex].Dir;			
; 16068: 
; 16069: 		DataSend(iTargetIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);	
; 16070: #endif
; 16071: 		return;

  001ab	e9 3b 01 00 00	 jmp	 $LN1@CGTargetTe
$LN5@CGTargetTe:

; 16072: 	}
; 16073: 
; 16074: 
; 16075: 	if( lpMagic != NULL )

  001b0	83 7d fc 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  001b4	0f 84 31 01 00
	00		 je	 $LN8@CGTargetTe

; 16076: 	{
; 16077: 		//  . (  ... )
; 16078: 		int usemana;
; 16079: 		usemana = gObjMagicManaUse(&gObj[aIndex], lpMagic);

  001ba	8b 45 fc	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001bd	50		 push	 eax
  001be	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001c5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cb	51		 push	 ecx
  001cc	e8 00 00 00 00	 call	 ?gObjMagicManaUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
  001d1	83 c4 08	 add	 esp, 8
  001d4	89 45 e8	 mov	 DWORD PTR _usemana$2[ebp], eax

; 16080: 		if( usemana >= 0 )

  001d7	83 7d e8 00	 cmp	 DWORD PTR _usemana$2[ebp], 0
  001db	0f 8c 0a 01 00
	00		 jl	 $LN8@CGTargetTe

; 16081: 		{
; 16082: #ifdef NEW_FORSKYLAND2
; 16083: 			int usebp = gObjMagicBPUse(&gObj[aIndex], lpMagic);

  001e1	8b 45 fc	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001e4	50		 push	 eax
  001e5	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001ec	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f2	51		 push	 ecx
  001f3	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  001f8	83 c4 08	 add	 esp, 8
  001fb	89 45 e4	 mov	 DWORD PTR _usebp$1[ebp], eax

; 16084: 			if( usebp >= 0 )

  001fe	83 7d e4 00	 cmp	 DWORD PTR _usebp$1[ebp], 0
  00202	0f 8c e3 00 00
	00		 jl	 $LN8@CGTargetTe

; 16085: #endif
; 16086: 			{				
; 16087: 				if( gObj[aIndex].Type == OBJTYPE_CHARACTER )

  00208	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0020f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00215	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0021a	83 fa 01	 cmp	 edx, 1
  0021d	75 15		 jne	 SHORT $LN9@CGTargetTe

; 16088: 					DataSend(aIndex, (LPBYTE)&pAttack, pAttack.h.size);

  0021f	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  00223	50		 push	 eax
  00224	8d 4d f0	 lea	 ecx, DWORD PTR _pAttack$[ebp]
  00227	51		 push	 ecx
  00228	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0022b	52		 push	 edx
  0022c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00231	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGTargetTe:

; 16089: 
; 16090: 				MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  00234	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  00238	50		 push	 eax
  00239	8d 4d f0	 lea	 ecx, DWORD PTR _pAttack$[ebp]
  0023c	51		 push	 ecx
  0023d	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00244	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024a	52		 push	 edx
  0024b	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00250	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16091: 				gObjTeleportMagicUse(iTargetIndex, x, y);

  00253	0f b6 45 fa	 movzx	 eax, BYTE PTR _y$[ebp]
  00257	50		 push	 eax
  00258	0f b6 4d fb	 movzx	 ecx, BYTE PTR _x$[ebp]
  0025c	51		 push	 ecx
  0025d	8b 55 ec	 mov	 edx, DWORD PTR _iTargetIndex$[ebp]
  00260	52		 push	 edx
  00261	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse
  00266	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16092: 				gObj[aIndex].Mana = (float)usemana;

  00269	f3 0f 2a 45 e8	 cvtsi2ss xmm0, DWORD PTR _usemana$2[ebp]
  0026e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00275	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027b	f3 0f 11 84 01
	d0 00 00 00	 movss	 DWORD PTR [ecx+eax+208], xmm0

; 16093: 
; 16094: #ifdef NEW_FORSKYLAND2
; 16095: 				gObj[aIndex].BP = usebp;

  00284	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0028b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00291	8b 55 e4	 mov	 edx, DWORD PTR _usebp$1[ebp]
  00294	89 94 01 e8 00
	00 00		 mov	 DWORD PTR [ecx+eax+232], edx

; 16096: 				GCManaSend(gObj[aIndex].m_Index, (short)gObj[aIndex].Mana, 0xFF, 0, gObj[aIndex].BP);

  0029b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a8	0f b7 94 01 e8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+232]
  002b0	52		 push	 edx
  002b1	6a 00		 push	 0
  002b3	68 ff 00 00 00	 push	 255			; 000000ffH
  002b8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c5	f3 0f 2c 94 01
	d0 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+208]
  002ce	0f b7 c2	 movzx	 eax, dx
  002d1	50		 push	 eax
  002d2	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002df	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  002e2	50		 push	 eax
  002e3	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  002e8	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@CGTargetTe:
$LN1@CGTargetTe:

; 16097: #else
; 16098: 				GCManaSend(gObj[aIndex].m_Index, (short)gObj[aIndex].Mana, 0xFF, 0, 0);
; 16099: #endif
; 16100: 			}
; 16101: 
; 16102: 		}
; 16103: 	}	
; 16104: }

  002eb	5f		 pop	 edi
  002ec	5e		 pop	 esi
  002ed	5b		 pop	 ebx
  002ee	8b e5		 mov	 esp, ebp
  002f0	5d		 pop	 ebp
  002f1	c3		 ret	 0
?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ENDP ; CGTargetTeleportRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z PROC ; CGRequestLottoRegister, COMDAT

; 20767: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 20768: 	PMSG_REQ_2ANIV_SERIAL	pMsg;
; 20769: 	PHeadSetB((LPBYTE)&pMsg, 0x08, sizeof(pMsg));

  00013	6a 28		 push	 40			; 00000028H
  00015	6a 08		 push	 8
  00017	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20770: 
; 20771: 	if (gObj[aIndex].UseEventServer) {

  00023	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00030	83 bc 01 84 0e
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3716], 0
  00038	74 07		 je	 SHORT $LN2@CGRequestL

; 20772: 		return;

  0003a	e9 13 01 00 00	 jmp	 $LN1@CGRequestL

; 20773: 	}

  0003f	eb 18		 jmp	 SHORT $LN3@CGRequestL
$LN2@CGRequestL:

; 20774: 	else {
; 20775: 		gObj[aIndex].UseEventServer = TRUE;

  00041	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	c7 84 01 84 0e
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+3716], 1
$LN3@CGRequestL:

; 20776: 	}
; 20777: 
; 20778: 	pMsg.iINDEX = aIndex;

  00059	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0005c	89 45 d8	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 20779: 	pMsg.iMEMB_GUID = gObj[aIndex].DBNumber;

  0005f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006c	8b 54 01 2c	 mov	 edx, DWORD PTR [ecx+eax+44]
  00070	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+36], edx

; 20780: 	memcpy (pMsg.szUID, gObj[aIndex].AccountID, 10);	pMsg.szUID[10] = 0;

  00073	6a 0a		 push	 10			; 0000000aH
  00075	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00082	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00086	52		 push	 edx
  00087	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _memcpy
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	6b c8 0a	 imul	 ecx, eax, 10
  0009b	c6 44 0d dc 00	 mov	 BYTE PTR _pMsg$[ebp+ecx+8], 0

; 20781: 	memcpy (pMsg.SERIAL1, lpMsg->SERIAL1, 4);			pMsg.SERIAL1[4] = 0;

  000a0	6a 04		 push	 4
  000a2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a5	83 c0 03	 add	 eax, 3
  000a8	50		 push	 eax
  000a9	8d 4d e7	 lea	 ecx, DWORD PTR _pMsg$[ebp+19]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 _memcpy
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	c1 e0 02	 shl	 eax, 2
  000bd	c6 44 05 e7 00	 mov	 BYTE PTR _pMsg$[ebp+eax+19], 0

; 20782: 	memcpy (pMsg.SERIAL2, lpMsg->SERIAL2, 4);			pMsg.SERIAL2[4] = 0;

  000c2	6a 04		 push	 4
  000c4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000c7	83 c0 08	 add	 eax, 8
  000ca	50		 push	 eax
  000cb	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp+24]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	c1 e0 02	 shl	 eax, 2
  000df	c6 44 05 ec 00	 mov	 BYTE PTR _pMsg$[ebp+eax+24], 0

; 20783: 	memcpy (pMsg.SERIAL3, lpMsg->SERIAL3, 4);			pMsg.SERIAL3[4] = 0;

  000e4	6a 04		 push	 4
  000e6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000e9	83 c0 0d	 add	 eax, 13			; 0000000dH
  000ec	50		 push	 eax
  000ed	8d 4d f1	 lea	 ecx, DWORD PTR _pMsg$[ebp+29]
  000f0	51		 push	 ecx
  000f1	e8 00 00 00 00	 call	 _memcpy
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	c1 e0 02	 shl	 eax, 2
  00101	c6 44 05 f1 00	 mov	 BYTE PTR _pMsg$[ebp+eax+29], 0

; 20784: 	 
; 20785: 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));	

  00106	6a 28		 push	 40			; 00000028H
  00108	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  00111	83 c4 08	 add	 esp, 8

; 20786: 
; 20787: 	LogAddTD("[Mu_2Anv_Event] [%s][%s] Register Lotto Number (Serial: %s-%s-%s)", 

  00114	8d 45 f1	 lea	 eax, DWORD PTR _pMsg$[ebp+29]
  00117	50		 push	 eax
  00118	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp+24]
  0011b	51		 push	 ecx
  0011c	8d 55 e7	 lea	 edx, DWORD PTR _pMsg$[ebp+19]
  0011f	52		 push	 edx
  00120	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00131	52		 push	 edx
  00132	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00139	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013f	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00143	52		 push	 edx
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Regist@
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0014f	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@CGRequestL:

; 20788: 		   gObj[aIndex].AccountID, gObj[aIndex].Name,
; 20789: 		   pMsg.SERIAL1,
; 20790: 		   pMsg.SERIAL2,
; 20791: 		   pMsg.SERIAL3
; 20792: 		   );
; 20793: }

  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00158	33 cd		 xor	 ecx, ebp
  0015a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c3		 ret	 0
?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ENDP ; CGRequestLottoRegister
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z
_TEXT	SEGMENT
tv67 = -68						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z PROC ; CGRequestEventEnterCount, COMDAT

; 20739: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20740: 	if (lpMsg == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN4@CGRequestE

; 20741: 		return;

  0000f	eb 1f		 jmp	 SHORT $LN1@CGRequestE
$LN4@CGRequestE:

; 20742: 
; 20743: 	switch (lpMsg->btEventType) {

  00011	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00014	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00017	88 4d bc	 mov	 BYTE PTR tv67[ebp], cl
  0001a	80 7d bc 02	 cmp	 BYTE PTR tv67[ebp], 2
  0001e	74 04		 je	 SHORT $LN6@CGRequestE
  00020	eb 0e		 jmp	 SHORT $LN1@CGRequestE

; 20744: 	case 1 :		// 
; 20745: #ifdef DEVILSQUARE_CHECK_ENTERCOUNT_20040715
; 20746: 		EGReqDevilSquareEnterCount	(aIndex);
; 20747: #endif
; 20748: 		break;

  00022	eb 0c		 jmp	 SHORT $LN1@CGRequestE
$LN6@CGRequestE:

; 20749: 	case 2 :		// 
; 20750: 		EGReqBloodCastleEnterCount	(aIndex);

  00024	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?EGReqBloodCastleEnterCount@@YAXH@Z ; EGReqBloodCastleEnterCount
  0002d	83 c4 04	 add	 esp, 4
$LN1@CGRequestE:

; 20751: 		break;
; 20752: #ifdef ADD_SEASON_3_NEW_UI_20071122	//   
; 20753: 	case 3:
; 20754: 		g_IllusionTempleEvent.EGReqIllusionTempleEnterCount(aIndex);
; 20755: 		break;
; 20756: #endif
; 20757: 	}
; 20758: 
; 20759: }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ENDP ; CGRequestEventEnterCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z
_TEXT	SEGMENT
tv77 = -72						; size = 4
tv78 = -68						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z PROC ; CGRequestRepositionUserInChaosCastle, COMDAT

; 20715: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20716: 	if (!gObjIsConnected(aIndex))

  00009	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	75 05		 jne	 SHORT $LN2@CGRequestR

; 20717: 		return;

  00019	e9 b4 00 00 00	 jmp	 $LN1@CGRequestR
$LN2@CGRequestR:

; 20718: 
; 20719: 	if (!CHECK_CHAOSCASTLE(gObj[aIndex].MapNumber)) {

  0001e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002b	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00033	83 fa 12	 cmp	 edx, 18			; 00000012H
  00036	7d 09		 jge	 SHORT $LN8@CGRequestR
  00038	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  0003f	eb 30		 jmp	 SHORT $LN9@CGRequestR
$LN8@CGRequestR:
  00041	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00056	83 fa 17	 cmp	 edx, 23			; 00000017H
  00059	7e 09		 jle	 SHORT $LN6@CGRequestR
  0005b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  00062	eb 07		 jmp	 SHORT $LN7@CGRequestR
$LN6@CGRequestR:
  00064	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
$LN7@CGRequestR:
  0006b	8b 45 b8	 mov	 eax, DWORD PTR tv77[ebp]
  0006e	89 45 bc	 mov	 DWORD PTR tv78[ebp], eax
$LN9@CGRequestR:
  00071	83 7d bc 00	 cmp	 DWORD PTR tv78[ebp], 0
  00075	75 02		 jne	 SHORT $LN3@CGRequestR

; 20720: 		//      .
; 20721: //		gObj[aIndex].DieRegen = 2;		//    .
; 20722: 		return;

  00077	eb 59		 jmp	 SHORT $LN1@CGRequestR
$LN3@CGRequestR:

; 20723: 	}
; 20724: 
; 20725: 	if (g_ChaosCastle.ObjSetPosition (aIndex, gObj[aIndex].X, gObj[aIndex].Y) == TRUE) {

  00079	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00086	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  0008e	52		 push	 edx
  0008f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009c	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  000a4	52		 push	 edx
  000a5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000a8	50		 push	 eax
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  000ae	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  000b3	83 f8 01	 cmp	 eax, 1
  000b6	75 1a		 jne	 SHORT $LN1@CGRequestR

; 20726: 		//      .
; 20727: 		gObj[aIndex].m_iChaosCastleBlowTime = GetTickCount();

  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000be	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cb	89 84 0a dc 0c
	00 00		 mov	 DWORD PTR [edx+ecx+3292], eax
$LN1@CGRequestR:

; 20728: 	}
; 20729: }

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ENDP ; CGRequestRepositionUserInChaosCastle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z
_TEXT	SEGMENT
tv146 = -1928						; size = 4
tv133 = -1928						; size = 4
tv66 = -1928						; size = 4
tv516 = -1924						; size = 4
tv147 = -1924						; size = 4
tv134 = -1924						; size = 4
tv67 = -1924						; size = 4
_szTemp$ = -1664					; size = 256
_pindex$1 = -1408					; size = 4
_pMsg$2 = -1404						; size = 4
_bRES$ = -1400						; size = 4
_iBC_INDEX$ = -1396					; size = 4
_btMapAttr$ = -1389					; size = 1
_iENTER_LEVEL$ = -1388					; size = 4
_pNotice$3 = -1384					; size = 272
_pNotice$4 = -1112					; size = 272
_pNotice$5 = -840					; size = 272
_pNotice$6 = -568					; size = 272
_pNotice$7 = -296					; size = 272
_pResult$ = -24						; size = 5
_dwITEM_SERIAL$ = -16					; size = 4
_iITEM_LEVEL$ = -12					; size = 4
_btGuardMailSetItemPos$ = -6				; size = 1
_btChaosCastleNumber$ = -5				; size = 1
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z PROC ; CGRequestEnterChaosCastle, COMDAT

; 20274: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 07 00
	00		 sub	 esp, 1928		; 00000788H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 20275: 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  00016	83 7d 0c 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  0001a	7d 0c		 jge	 SHORT $LN42@CGRequestE
  0001c	c7 85 7c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00026	eb 2b		 jmp	 SHORT $LN43@CGRequestE
$LN42@CGRequestE:
  00028	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  0002f	7e 0c		 jle	 SHORT $LN40@CGRequestE
  00031	c7 85 78 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN41@CGRequestE
$LN40@CGRequestE:
  0003d	c7 85 78 f8 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN41@CGRequestE:
  00047	8b 85 78 f8 ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 7c f8 ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN43@CGRequestE:
  00053	83 bd 7c f8 ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 21		 jne	 SHORT $LN4@CGRequestE

; 20276: 	{
; 20277: 		LogAdd("return %s %d", __FILE__, __LINE__);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z@4JA
  00061	83 c0 03	 add	 eax, 3
  00064	50		 push	 eax
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20278: 		return;

  00078	e9 c2 09 00 00	 jmp	 $LN1@CGRequestE
$LN4@CGRequestE:

; 20279: 	}
; 20280: 
; 20281: 	BYTE btChaosCastleNumber = lpMsg->iChaosCastleNumber-1;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00080	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00084	83 e9 01	 sub	 ecx, 1
  00087	88 4d fb	 mov	 BYTE PTR _btChaosCastleNumber$[ebp], cl

; 20282: 	BYTE btGuardMailSetItemPos = lpMsg->iItemPos;

  0008a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008d	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  00090	88 4d fa	 mov	 BYTE PTR _btGuardMailSetItemPos$[ebp], cl

; 20283: 	INT	 iITEM_LEVEL = 0;

  00093	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0

; 20284: 	DWORD dwITEM_SERIAL = 0;

  0009a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], 0

; 20285: 
; 20286: 	PMSG_RESULT_MOVECHAOSCASTLE pResult;
; 20287: 	PHeadSubSetB((LPBYTE)&pResult, 0xAF, 0x01, sizeof(pResult));

  000a1	6a 05		 push	 5
  000a3	6a 01		 push	 1
  000a5	68 af 00 00 00	 push	 175			; 000000afH
  000aa	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  000b3	83 c4 10	 add	 esp, 16			; 00000010H

; 20288: 	pResult.Result = 0;

  000b6	c6 45 ec 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 20289: 
; 20290: 	if ((gObj[iIndex].Type != OBJTYPE_CHARACTER) || (gObj[iIndex].Connected <= 2)) {

  000ba	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000cc	83 fa 01	 cmp	 edx, 1
  000cf	75 14		 jne	 SHORT $LN6@CGRequestE
  000d1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000de	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  000e3	7f 05		 jg	 SHORT $LN5@CGRequestE
$LN6@CGRequestE:

; 20291: 		return;

  000e5	e9 55 09 00 00	 jmp	 $LN1@CGRequestE
$LN5@CGRequestE:

; 20292: 	}
; 20293: 
; 20294: 	// *> .     .
; 20295: 	if (CHECK_BLOODCASTLE(gObj[iIndex].MapNumber) ||		// 
; 20296: 		CHECK_CHAOSCASTLE(gObj[iIndex].MapNumber) ||		// 

  000ea	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f7	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000ff	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00102	7d 0c		 jge	 SHORT $LN46@CGRequestE
  00104	c7 85 7c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp], 0
  0010e	eb 3c		 jmp	 SHORT $LN47@CGRequestE
$LN46@CGRequestE:
  00110	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011d	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00125	83 fa 11	 cmp	 edx, 17			; 00000011H
  00128	7e 0c		 jle	 SHORT $LN44@CGRequestE
  0012a	c7 85 78 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv133[ebp], 0
  00134	eb 0a		 jmp	 SHORT $LN45@CGRequestE
$LN44@CGRequestE:
  00136	c7 85 78 f8 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv133[ebp], 1
$LN45@CGRequestE:
  00140	8b 85 78 f8 ff
	ff		 mov	 eax, DWORD PTR tv133[ebp]
  00146	89 85 7c f8 ff
	ff		 mov	 DWORD PTR tv134[ebp], eax
$LN47@CGRequestE:
  0014c	83 bd 7c f8 ff
	ff 00		 cmp	 DWORD PTR tv134[ebp], 0
  00153	0f 85 85 00 00
	00		 jne	 $LN8@CGRequestE
  00159	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00166	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0016e	83 fa 12	 cmp	 edx, 18			; 00000012H
  00171	7d 0c		 jge	 SHORT $LN50@CGRequestE
  00173	c7 85 7c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv147[ebp], 0
  0017d	eb 3c		 jmp	 SHORT $LN51@CGRequestE
$LN50@CGRequestE:
  0017f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00186	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00194	83 fa 17	 cmp	 edx, 23			; 00000017H
  00197	7e 0c		 jle	 SHORT $LN48@CGRequestE
  00199	c7 85 78 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv146[ebp], 0
  001a3	eb 0a		 jmp	 SHORT $LN49@CGRequestE
$LN48@CGRequestE:
  001a5	c7 85 78 f8 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv146[ebp], 1
$LN49@CGRequestE:
  001af	8b 85 78 f8 ff
	ff		 mov	 eax, DWORD PTR tv146[ebp]
  001b5	89 85 7c f8 ff
	ff		 mov	 DWORD PTR tv147[ebp], eax
$LN51@CGRequestE:
  001bb	83 bd 7c f8 ff
	ff 00		 cmp	 DWORD PTR tv147[ebp], 0
  001c2	75 1a		 jne	 SHORT $LN8@CGRequestE
  001c4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d1	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001d9	83 fa 09	 cmp	 edx, 9
  001dc	75 42		 jne	 SHORT $LN7@CGRequestE
$LN8@CGRequestE:

; 20297: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 20298: 		CHECK_DEVILSQUARE(gObj[iIndex].MapNumber)			// 
; 20299: #else
; 20300: 		gObj[iIndex].MapNumber == 9							// 
; 20301: #endif
; 20302: 		)
; 20303: 	{
; 20304: 		PMSG_NOTICE	pNotice;
; 20305: #ifdef MODIFY_NOTICE_20040325
; 20306: 		TNotice::MakeNoticeMsgEx( &pNotice, 1, lMsg.Get(1224));		// "     ."

  001de	68 c8 04 00 00	 push	 1224			; 000004c8H
  001e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001ee	50		 push	 eax
  001ef	6a 01		 push	 1
  001f1	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$7[ebp]
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  001fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20307: #else
; 20308: 		pNotice.type = 1;
; 20309: 		wsprintf(pNotice.Notice, lMsg.Get(1224));					// "     ."
; 20310: 		PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 20311: #endif
; 20312: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00200	0f b6 85 d9 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$7[ebp+1]
  00207	50		 push	 eax
  00208	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$7[ebp]
  0020e	51		 push	 ecx
  0020f	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00212	52		 push	 edx
  00213	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00218	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20313: 
; 20314: 		return;

  0021b	e9 1f 08 00 00	 jmp	 $LN1@CGRequestE
$LN7@CGRequestE:

; 20315: 	}
; 20316: 
; 20317: 
; 20318: 	// *> .     .
; 20319: 	if (gObj[iIndex].m_IfState.use != 0 && gObj[iIndex].m_IfState.type != I_ETCWINDOW ) {

  00220	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00227	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0022d	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00234	80 e2 03	 and	 dl, 3
  00237	0f b6 c2	 movzx	 eax, dl
  0023a	85 c0		 test	 eax, eax
  0023c	74 27		 je	 SHORT $LN9@CGRequestE
  0023e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00245	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024b	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00252	c0 ea 04	 shr	 dl, 4
  00255	80 e2 0f	 and	 dl, 15			; 0000000fH
  00258	0f b6 c2	 movzx	 eax, dl
  0025b	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0025e	74 05		 je	 SHORT $LN9@CGRequestE

; 20320: 		return;

  00260	e9 da 07 00 00	 jmp	 $LN1@CGRequestE
$LN9@CGRequestE:

; 20321: 	}
; 20322: 
; 20323: 
; 20324: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 20325: 	if (!gPkLimitFree) {

  00265	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  0026c	75 5c		 jne	 SHORT $LN10@CGRequestE

; 20326: #endif
; 20327: 	// *> .      .
; 20328: #ifdef UPDATE_PK_SYSTEM_20070302	//     .
; 20329: 	BOOL	PKFlag = FALSE;
; 20330: 	if(gObj[iIndex].PartyNumber >= 0)	//  
; 20331: 	{
; 20332: 		if( gParty.GetPKPartyPenalty(gObj[iIndex].PartyNumber) >= PK_LEVEL_DEFAULT+3)
; 20333: 		{
; 20334: 			PKFlag = TRUE;
; 20335: 		}
; 20336: 	}
; 20337: 	else
; 20338: 	{
; 20339: 		if(gObj[iIndex].m_PK_Level >= PK_LEVEL_DEFAULT+3)
; 20340: 		{
; 20341: 			PKFlag = TRUE;
; 20342: 		}
; 20343: 	}
; 20344: 	
; 20345: 	if(PKFlag == TRUE) {
; 20346: #else	// UPDATE_PK_SYSTEM_20070302
; 20347: 	if (gObj[iIndex].m_PK_Level >= PK_LEVEL_DEFAULT+3) {

  0026e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00275	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027b	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00283	83 fa 06	 cmp	 edx, 6
  00286	7c 42		 jl	 SHORT $LN10@CGRequestE

; 20348: #endif	// UPDATE_PK_SYSTEM_20070302
; 20349: 		PMSG_NOTICE	pNotice;
; 20350: #ifdef MODIFY_NOTICE_20040325
; 20351: 		TNotice::MakeNoticeMsgEx( &pNotice, 1, lMsg.Get(1225));		// "     ."

  00288	68 c9 04 00 00	 push	 1225			; 000004c9H
  0028d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00298	50		 push	 eax
  00299	6a 01		 push	 1
  0029b	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$6[ebp]
  002a1	50		 push	 eax
  002a2	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  002a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20352: #else
; 20353: 		pNotice.type = 1;
; 20354: 		wsprintf(pNotice.Notice, lMsg.Get(1225));					// "     ."
; 20355: 		PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 20356: #endif
; 20357: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  002aa	0f b6 85 c9 fd
	ff ff		 movzx	 eax, BYTE PTR _pNotice$6[ebp+1]
  002b1	50		 push	 eax
  002b2	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _pNotice$6[ebp]
  002b8	51		 push	 ecx
  002b9	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  002bc	52		 push	 edx
  002bd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20358: 		return;

  002c5	e9 75 07 00 00	 jmp	 $LN1@CGRequestE
$LN10@CGRequestE:

; 20359: 	}
; 20360: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 20361: 	}
; 20362: #endif
; 20363: 	
; 20364: 
; 20365: 	// *> .      .
; 20366: 	if (gObjDuelCheck(&gObj[iIndex]) == TRUE) {

  002ca	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002d1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d7	50		 push	 eax
  002d8	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@@Z ; gObjDuelCheck
  002dd	83 c4 04	 add	 esp, 4
  002e0	83 f8 01	 cmp	 eax, 1
  002e3	75 42		 jne	 SHORT $LN12@CGRequestE

; 20367: 		PMSG_NOTICE	pNotice;
; 20368: #ifdef MODIFY_NOTICE_20040325
; 20369: 		TNotice::MakeNoticeMsgEx( &pNotice, 1, lMsg.Get(1226));		// "      ."

  002e5	68 ca 04 00 00	 push	 1226			; 000004caH
  002ea	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002f5	50		 push	 eax
  002f6	6a 01		 push	 1
  002f8	8d 85 b8 fc ff
	ff		 lea	 eax, DWORD PTR _pNotice$5[ebp]
  002fe	50		 push	 eax
  002ff	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  00304	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20370: #else
; 20371: 		pNotice.type = 1;
; 20372: 		wsprintf(pNotice.Notice, lMsg.Get(1226));					// "      ."
; 20373: 		PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 20374: #endif
; 20375: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00307	0f b6 85 b9 fc
	ff ff		 movzx	 eax, BYTE PTR _pNotice$5[ebp+1]
  0030e	50		 push	 eax
  0030f	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR _pNotice$5[ebp]
  00315	51		 push	 ecx
  00316	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00319	52		 push	 edx
  0031a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0031f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20376: 		return;

  00322	e9 18 07 00 00	 jmp	 $LN1@CGRequestE
$LN12@CGRequestE:

; 20377: 	}
; 20378: 	
; 20379: 
; 20380: 	// *> .      .
; 20381: 	if (gObj[iIndex].lpGuild && gObj[iIndex].lpGuild->WarState == 1) {

  00327	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0032e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00334	83 bc 01 94 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+660], 0
  0033c	74 62		 je	 SHORT $LN13@CGRequestE
  0033e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00345	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0034b	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  00352	0f b6 82 91 05
	00 00		 movzx	 eax, BYTE PTR [edx+1425]
  00359	83 f8 01	 cmp	 eax, 1
  0035c	75 42		 jne	 SHORT $LN13@CGRequestE

; 20382: 		PMSG_NOTICE	pNotice;
; 20383: #ifdef MODIFY_NOTICE_20040325
; 20384: 		TNotice::MakeNoticeMsgEx( &pNotice, 1, lMsg.Get(1227));		// "       ."

  0035e	68 cb 04 00 00	 push	 1227			; 000004cbH
  00363	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00368	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0036e	50		 push	 eax
  0036f	6a 01		 push	 1
  00371	8d 85 a8 fb ff
	ff		 lea	 eax, DWORD PTR _pNotice$4[ebp]
  00377	50		 push	 eax
  00378	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  0037d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20385: #else
; 20386: 		pNotice.type = 1;
; 20387: 		wsprintf(pNotice.Notice, lMsg.Get(1227));					// "       ."
; 20388: 		PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 20389: #endif
; 20390: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00380	0f b6 85 a9 fb
	ff ff		 movzx	 eax, BYTE PTR _pNotice$4[ebp+1]
  00387	50		 push	 eax
  00388	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _pNotice$4[ebp]
  0038e	51		 push	 ecx
  0038f	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00392	52		 push	 edx
  00393	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00398	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20391: 		return;

  0039b	e9 9f 06 00 00	 jmp	 $LN1@CGRequestE
$LN13@CGRequestE:

; 20392: 	}
; 20393: 	
; 20394: 
; 20395: 	// *> .        .
; 20396: 	if( gObj[iIndex].pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,3) ||		// 

  003a0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  003a7	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  003ac	c1 e1 03	 shl	 ecx, 3
  003af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b5	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  003bc	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  003c1	6a 03		 push	 3
  003c3	6a 0d		 push	 13			; 0000000dH
  003c5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003ca	83 c4 08	 add	 esp, 8
  003cd	3b f0		 cmp	 esi, eax
  003cf	74 31		 je	 SHORT $LN15@CGRequestE
  003d1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  003d8	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  003dd	c1 e1 03	 shl	 ecx, 3
  003e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003e6	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  003ed	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  003f2	6a 02		 push	 2
  003f4	6a 0d		 push	 13			; 0000000dH
  003f6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003fb	83 c4 08	 add	 esp, 8
  003fe	3b f0		 cmp	 esi, eax
  00400	75 42		 jne	 SHORT $LN14@CGRequestE
$LN15@CGRequestE:

; 20397: 		gObj[iIndex].pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,2) 			// 
; 20398: 		
; 20399: #ifdef ADD_ITEM_FENRIR_01_20051110
; 20400: 		|| gObj[iIndex].pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,37) 			// 
; 20401: 		//       .
; 20402: #endif
; 20403: 	  )
; 20404: 
; 20405: 	{	
; 20406: 		PMSG_NOTICE	pNotice;
; 20407: #ifdef MODIFY_NOTICE_20040325
; 20408: 		TNotice::MakeNoticeMsgEx( &pNotice, 1, lMsg.Get(1228));		// "       ."

  00402	68 cc 04 00 00	 push	 1228			; 000004ccH
  00407	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0040c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00412	50		 push	 eax
  00413	6a 01		 push	 1
  00415	8d 85 98 fa ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  0041b	50		 push	 eax
  0041c	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  00421	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20409: #else
; 20410: 		pNotice.type = 1;
; 20411: 		wsprintf(pNotice.Notice, lMsg.Get(1228));					// "       ."
; 20412: 		PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 20413: #endif
; 20414: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00424	0f b6 85 99 fa
	ff ff		 movzx	 eax, BYTE PTR _pNotice$3[ebp+1]
  0042b	50		 push	 eax
  0042c	8d 8d 98 fa ff
	ff		 lea	 ecx, DWORD PTR _pNotice$3[ebp]
  00432	51		 push	 ecx
  00433	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00436	52		 push	 edx
  00437	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0043c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20415: 		return;

  0043f	e9 fb 05 00 00	 jmp	 $LN1@CGRequestE
$LN14@CGRequestE:

; 20416: 	}						
; 20417: 
; 20418: #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 20419: 	// *> .     .	
; 20420: #ifdef UPDATE_PK_SYSTEM_20070302	//     .
; 20421: 	BOOL	PKFlag = FALSE;
; 20422: 	if(gObj[iIndex].PartyNumber >= 0)	//  
; 20423: 	{
; 20424: 		if( gParty.GetPKPartyPenalty(gObj[iIndex].PartyNumber) >= PK_LEVEL_DEFAULT+2)
; 20425: 		{
; 20426: 			PKFlag = TRUE;
; 20427: 		}
; 20428: 	}
; 20429: 	else
; 20430: 	{
; 20431: 		if(gObj[iIndex].m_PK_Level >= PK_LEVEL_DEFAULT+1)
; 20432: 		{
; 20433: 			PKFlag = TRUE;
; 20434: 		}
; 20435: 	}
; 20436: 	
; 20437: 	if(PKFlag == TRUE)
; 20438: #else	// UPDATE_PK_SYSTEM_20070302
; 20439: 	if( gObj[iIndex].m_PK_Level >= PK_LEVEL_DEFAULT + 1 )

  00444	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0044b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00451	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00459	83 fa 04	 cmp	 edx, 4
  0045c	7c 1e		 jl	 SHORT $LN16@CGRequestE

; 20440: #endif	// UPDATE_PK_SYSTEM_20070302
; 20441: 	{
; 20442: 		pResult.Result = 8;

  0045e	c6 45 ec 08	 mov	 BYTE PTR _pResult$[ebp+4], 8

; 20443: 		DataSend( iIndex, (LPBYTE)&pResult, pResult.h.size );

  00462	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00466	50		 push	 eax
  00467	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0046a	51		 push	 ecx
  0046b	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0046e	52		 push	 edx
  0046f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00474	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20444: 		return;

  00477	e9 c3 05 00 00	 jmp	 $LN1@CGRequestE
$LN16@CGRequestE:

; 20445: 	}
; 20446: #endif
; 20447: 
; 20448: 	// 1 .      .
; 20449: 	INT iENTER_LEVEL = g_ChaosCastle.GetUserLevelToEnter(iIndex);

  0047c	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0047f	50		 push	 eax
  00480	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00485	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetUserLevelToEnter
  0048a	89 85 94 fa ff
	ff		 mov	 DWORD PTR _iENTER_LEVEL$[ebp], eax

; 20450: 	if (iENTER_LEVEL == -1) {

  00490	83 bd 94 fa ff
	ff ff		 cmp	 DWORD PTR _iENTER_LEVEL$[ebp], -1
  00497	75 1e		 jne	 SHORT $LN17@CGRequestE

; 20451: 		pResult.Result = 1;

  00499	c6 45 ec 01	 mov	 BYTE PTR _pResult$[ebp+4], 1

; 20452: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0049d	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  004a1	50		 push	 eax
  004a2	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  004a5	51		 push	 ecx
  004a6	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  004a9	52		 push	 edx
  004aa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20453: 		return;

  004b2	e9 88 05 00 00	 jmp	 $LN1@CGRequestE
$LN17@CGRequestE:

; 20454: 	}
; 20455: 
; 20456: 
; 20457: 	// 2 .      .
; 20458: #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 20459: 	if( !g_ChaosCastle.CheckCanEnter( iIndex, iENTER_LEVEL ) ) {
; 20460: #else
; 20461: 	if (!g_ChaosCastle.CheckCanEnter(iENTER_LEVEL)) {

  004b7	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _iENTER_LEVEL$[ebp]
  004bd	50		 push	 eax
  004be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  004c3	e8 00 00 00 00	 call	 ?CheckCanEnter@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanEnter
  004c8	0f b6 c8	 movzx	 ecx, al
  004cb	85 c9		 test	 ecx, ecx
  004cd	75 1e		 jne	 SHORT $LN18@CGRequestE

; 20462: #endif	
; 20463: 		pResult.Result = 2;

  004cf	c6 45 ec 02	 mov	 BYTE PTR _pResult$[ebp+4], 2

; 20464: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  004d3	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  004d7	50		 push	 eax
  004d8	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  004db	51		 push	 ecx
  004dc	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  004df	52		 push	 edx
  004e0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20465: 		return;

  004e8	e9 52 05 00 00	 jmp	 $LN1@CGRequestE
$LN18@CGRequestE:

; 20466: 	}
; 20467: 
; 20468: 
; 20469: 	// 3 .         .
; 20470: 	if( gObj[iIndex].pInventory[btGuardMailSetItemPos].IsItem() == TRUE )

  004ed	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  004f4	0f b6 4d fa	 movzx	 ecx, BYTE PTR _btGuardMailSetItemPos$[ebp]
  004f8	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  004fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00504	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0050b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00510	83 f8 01	 cmp	 eax, 1
  00513	0f 85 9f 00 00
	00		 jne	 $LN19@CGRequestE

; 20471: 	{
; 20472: 		if( gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Type == MAKE_ITEMNUM(13, 29) )	//   

  00519	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00520	0f b6 4d fa	 movzx	 ecx, BYTE PTR _btGuardMailSetItemPos$[ebp]
  00524	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0052a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00530	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00537	0f bf 74 10 06	 movsx	 esi, WORD PTR [eax+edx+6]
  0053c	6a 1d		 push	 29			; 0000001dH
  0053e	6a 0d		 push	 13			; 0000000dH
  00540	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00545	83 c4 08	 add	 esp, 8
  00548	3b f0		 cmp	 esi, eax
  0054a	75 4c		 jne	 SHORT $LN21@CGRequestE

; 20473: 		{
; 20474: 			iITEM_LEVEL = gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Level;				//   .

  0054c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00553	0f b6 4d fa	 movzx	 ecx, BYTE PTR _btGuardMailSetItemPos$[ebp]
  00557	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0055d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00563	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  0056a	0f bf 4c 10 08	 movsx	 ecx, WORD PTR [eax+edx+8]
  0056f	89 4d f4	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], ecx

; 20475: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Number;			//   .

  00572	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00579	0f b6 4d fa	 movzx	 ecx, BYTE PTR _btGuardMailSetItemPos$[ebp]
  0057d	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00583	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00589	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00590	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00593	89 4d f0	 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], ecx

; 20476: /*
; 20477: 			if (!CHECK_LIMIT(iITEM_LEVEL, MAX_CHAOSCASTLE_COUNT+1)) {						// 0 < iITEM_LEVEL <   + 1
; 20478: 				pResult.Result = 1;
; 20479: 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20480: 				return;
; 20481: 			}
; 20482: */
; 20483: 		}

  00596	eb 1e		 jmp	 SHORT $LN22@CGRequestE
$LN21@CGRequestE:

; 20484: 		else {
; 20485: 			pResult.Result = 1;

  00598	c6 45 ec 01	 mov	 BYTE PTR _pResult$[ebp+4], 1

; 20486: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0059c	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  005a0	50		 push	 eax
  005a1	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  005a4	51		 push	 ecx
  005a5	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  005a8	52		 push	 edx
  005a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20487: 			return;

  005b1	e9 89 04 00 00	 jmp	 $LN1@CGRequestE
$LN22@CGRequestE:

; 20488: 		}
; 20489: 	}

  005b6	eb 1e		 jmp	 SHORT $LN20@CGRequestE
$LN19@CGRequestE:

; 20490: 	else {
; 20491: 		pResult.Result = 1;

  005b8	c6 45 ec 01	 mov	 BYTE PTR _pResult$[ebp+4], 1

; 20492: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  005bc	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  005c0	50		 push	 eax
  005c1	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  005c4	51		 push	 ecx
  005c5	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  005c8	52		 push	 edx
  005c9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20493: 		return;

  005d1	e9 69 04 00 00	 jmp	 $LN1@CGRequestE
$LN20@CGRequestE:

; 20494: 	}
; 20495: 
; 20496: 	
; 20497: 	// 3 .        .
; 20498: /*
; 20499: 	INT iRESULT = g_ChaosCastle.CheckEnterLevel(iIndex, iITEM_LEVEL);
; 20500: 
; 20501: 	if (!iRESULT) {					//  .
; 20502: 		pResult.Result = 0;
; 20503: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20504: 	}
; 20505: 	else if (iRESULT == -1) {		//   .
; 20506: 		pResult.Result = 4;
; 20507: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20508: 		return;
; 20509: 	}
; 20510: 	else if (iRESULT == 1) {		//   .
; 20511: 		pResult.Result = 3;
; 20512: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20513: 		return;
; 20514: 	}
; 20515: 	else return;					//  .
; 20516: */
; 20517: 
; 20518: 
; 20519: 	// 4 .     .
; 20520: 	if (g_ChaosCastle.CheckWearingMOPH(iIndex) == TRUE) {

  005d6	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  005d9	50		 push	 eax
  005da	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  005df	e8 00 00 00 00	 call	 ?CheckWearingMOPH@CChaosCastle@@QAEHH@Z ; CChaosCastle::CheckWearingMOPH
  005e4	83 f8 01	 cmp	 eax, 1
  005e7	75 24		 jne	 SHORT $LN23@CGRequestE

; 20521: 		GCServerMsgStringSend(lMsg.Get(1229), iIndex, 1);			// "      ."

  005e9	6a 01		 push	 1
  005eb	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  005ee	50		 push	 eax
  005ef	68 cd 04 00 00	 push	 1229			; 000004cdH
  005f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  005ff	50		 push	 eax
  00600	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00605	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20522: 		return;

  00608	e9 32 04 00 00	 jmp	 $LN1@CGRequestE
$LN23@CGRequestE:

; 20523: 	}
; 20524: 
; 20525: #ifdef MODIFY_ENTER_CHOSCASTLE_BUGFIX_20070316
; 20526: 	BYTE btMapAttr = MapC[gObj[iIndex].MapNumber].GetAttr(gObj[iIndex].X, gObj[iIndex].Y);

  0060d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00614	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0061a	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  00622	52		 push	 edx
  00623	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0062a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00630	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00638	52		 push	 edx
  00639	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00640	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00646	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0064e	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00654	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0065a	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0065f	88 85 93 fa ff
	ff		 mov	 BYTE PTR _btMapAttr$[ebp], al

; 20527: 	if ((btMapAttr&MAP_ATTR_SAFTYZONE)!=MAP_ATTR_SAFTYZONE)		// 

  00665	0f b6 85 93 fa
	ff ff		 movzx	 eax, BYTE PTR _btMapAttr$[ebp]
  0066c	83 e0 01	 and	 eax, 1
  0066f	75 05		 jne	 SHORT $LN24@CGRequestE

; 20528: 	{
; 20529: 		return;

  00671	e9 c9 03 00 00	 jmp	 $LN1@CGRequestE
$LN24@CGRequestE:

; 20530: 	}
; 20531: #endif
; 20532: 
; 20533: #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 20534: 	// 5 .      .
; 20535: 	INT iBC_INDEX = -1;
; 20536: 	if( gObj[iIndex].m_bPCBangFreeChaosCastleUser )		// PC     .
; 20537: 	{		
; 20538: 		iBC_INDEX = g_ChaosCastle.EnterUserChaosCastle( iENTER_LEVEL, iIndex );
; 20539: 		if( iBC_INDEX == -1 ) 
; 20540: 		{
; 20541: 			//   .
; 20542: 			pResult.Result = 5;
; 20543: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20544: 			return;
; 20545: 		}
; 20546: 	}
; 20547: 	else										//     .
; 20548: 	{	
; 20549: 		if( g_ChaosCastle.CheckUserEnterMoney( iIndex, iENTER_LEVEL ) ) 
; 20550: 		{
; 20551: 			iBC_INDEX = g_ChaosCastle.EnterUserChaosCastle( iENTER_LEVEL, iIndex );
; 20552: 			if( iBC_INDEX == -1 ) 
; 20553: 			{
; 20554: 				//   .
; 20555: 				pResult.Result = 5;
; 20556: 				DataSend( iIndex, ( LPBYTE )&pResult, pResult.h.size );
; 20557: 				return;
; 20558: 			}
; 20559: 		}
; 20560: 		else 
; 20561: 		{
; 20562: 			//    .
; 20563: 			pResult.Result = 7;
; 20564: 			DataSend( iIndex, ( LPBYTE )&pResult, pResult.h.size );
; 20565: 			return;
; 20566: 		}
; 20567: 
; 20568: 
; 20569: 		// 6 .    .
; 20570: 		BOOL bRES = g_ChaosCastle.PayUserEnterMoney( iIndex, iENTER_LEVEL );
; 20571: 		if( bRES == FALSE ) 
; 20572: 		{
; 20573: 			//     .
; 20574: 			g_ChaosCastle.LeaveUserChaosCastle( iENTER_LEVEL, iIndex );
; 20575: 			pResult.Result = 5;
; 20576: 			DataSend( iIndex, ( LPBYTE )&pResult, pResult.h.size );
; 20577: 			return;
; 20578: 		}
; 20579: 	}
; 20580: #else	// #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 20581: 	
; 20582: 	// 5 .      .
; 20583: 	INT iBC_INDEX = -1;

  00676	c7 85 8c fa ff
	ff ff ff ff ff	 mov	 DWORD PTR _iBC_INDEX$[ebp], -1

; 20584: 	if (g_ChaosCastle.CheckUserEnterMoney(iIndex, iENTER_LEVEL)) {

  00680	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _iENTER_LEVEL$[ebp]
  00686	50		 push	 eax
  00687	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0068a	51		 push	 ecx
  0068b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00690	e8 00 00 00 00	 call	 ?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z ; CChaosCastle::CheckUserEnterMoney
  00695	85 c0		 test	 eax, eax
  00697	74 44		 je	 SHORT $LN25@CGRequestE

; 20585: 		iBC_INDEX = g_ChaosCastle.EnterUserChaosCastle(iENTER_LEVEL, iIndex);

  00699	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0069c	50		 push	 eax
  0069d	8b 8d 94 fa ff
	ff		 mov	 ecx, DWORD PTR _iENTER_LEVEL$[ebp]
  006a3	51		 push	 ecx
  006a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  006a9	e8 00 00 00 00	 call	 ?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z ; CChaosCastle::EnterUserChaosCastle
  006ae	89 85 8c fa ff
	ff		 mov	 DWORD PTR _iBC_INDEX$[ebp], eax

; 20586: 		if (iBC_INDEX == -1) {

  006b4	83 bd 8c fa ff
	ff ff		 cmp	 DWORD PTR _iBC_INDEX$[ebp], -1
  006bb	75 1e		 jne	 SHORT $LN27@CGRequestE

; 20587: 			//   .
; 20588: 			pResult.Result = 5;

  006bd	c6 45 ec 05	 mov	 BYTE PTR _pResult$[ebp+4], 5

; 20589: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  006c1	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  006c5	50		 push	 eax
  006c6	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  006c9	51		 push	 ecx
  006ca	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  006cd	52		 push	 edx
  006ce	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20590: 			return;

  006d6	e9 64 03 00 00	 jmp	 $LN1@CGRequestE
$LN27@CGRequestE:

; 20591: 		}
; 20592: 	}

  006db	eb 1e		 jmp	 SHORT $LN26@CGRequestE
$LN25@CGRequestE:

; 20593: 	else {
; 20594: 		//    .
; 20595: 		pResult.Result = 7;

  006dd	c6 45 ec 07	 mov	 BYTE PTR _pResult$[ebp+4], 7

; 20596: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  006e1	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  006e5	50		 push	 eax
  006e6	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  006e9	51		 push	 ecx
  006ea	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  006ed	52		 push	 edx
  006ee	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20597: 		return;

  006f6	e9 44 03 00 00	 jmp	 $LN1@CGRequestE
$LN26@CGRequestE:

; 20598: 	}
; 20599: 
; 20600: 
; 20601: 	// 6 .    .
; 20602: 	BOOL bRES = g_ChaosCastle.PayUserEnterMoney (iIndex, iENTER_LEVEL);

  006fb	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _iENTER_LEVEL$[ebp]
  00701	50		 push	 eax
  00702	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00705	51		 push	 ecx
  00706	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0070b	e8 00 00 00 00	 call	 ?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z ; CChaosCastle::PayUserEnterMoney
  00710	89 85 88 fa ff
	ff		 mov	 DWORD PTR _bRES$[ebp], eax

; 20603: 	if (bRES == FALSE) {

  00716	83 bd 88 fa ff
	ff 00		 cmp	 DWORD PTR _bRES$[ebp], 0
  0071d	75 33		 jne	 SHORT $LN28@CGRequestE

; 20604: 		//     .
; 20605: 		g_ChaosCastle.LeaveUserChaosCastle(iENTER_LEVEL, iIndex);

  0071f	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00722	50		 push	 eax
  00723	8b 8d 94 fa ff
	ff		 mov	 ecx, DWORD PTR _iENTER_LEVEL$[ebp]
  00729	51		 push	 ecx
  0072a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0072f	e8 00 00 00 00	 call	 ?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z ; CChaosCastle::LeaveUserChaosCastle

; 20606: 		pResult.Result = 5;

  00734	c6 45 ec 05	 mov	 BYTE PTR _pResult$[ebp+4], 5

; 20607: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00738	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0073c	50		 push	 eax
  0073d	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00740	51		 push	 ecx
  00741	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00744	52		 push	 edx
  00745	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0074a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20608: 		return;

  0074d	e9 ed 02 00 00	 jmp	 $LN1@CGRequestE
$LN28@CGRequestE:

; 20609: 	}
; 20610: #endif	// #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 20611: 
; 20612: 	// !!>  ->      .
; 20613: 
; 20614: 	// *> .  
; 20615: 	gObjInventoryDeleteItem(iIndex, btGuardMailSetItemPos);

  00752	0f b6 45 fa	 movzx	 eax, BYTE PTR _btGuardMailSetItemPos$[ebp]
  00756	50		 push	 eax
  00757	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0075a	51		 push	 ecx
  0075b	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00760	83 c4 08	 add	 esp, 8

; 20616: 	GCInventoryItemDeleteSend(iIndex, btGuardMailSetItemPos, 1);

  00763	6a 01		 push	 1
  00765	0f b6 45 fa	 movzx	 eax, BYTE PTR _btGuardMailSetItemPos$[ebp]
  00769	50		 push	 eax
  0076a	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0076d	51		 push	 ecx
  0076e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00773	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20617: 	DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00776	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0077a	50		 push	 eax
  0077b	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0077e	51		 push	 ecx
  0077f	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00782	52		 push	 edx
  00783	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00788	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20618: 
; 20619: 	// *> .    
; 20620: 	gObj[iIndex].m_cChaosCastleIndex = iENTER_LEVEL;

  0078b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00792	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00798	8a 95 94 fa ff
	ff		 mov	 dl, BYTE PTR _iENTER_LEVEL$[ebp]
  0079e	88 94 01 d9 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3289], dl

; 20621: 	gObj[iIndex].m_cChaosCastleSubIndex = iBC_INDEX;

  007a5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  007ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007b2	8a 95 8c fa ff
	ff		 mov	 dl, BYTE PTR _iBC_INDEX$[ebp]
  007b8	88 94 01 da 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3290], dl

; 20622: 
; 20623: #ifdef BLOOD_DEVILSQUARE_TRADE_BUG_FIX
; 20624: 	gObj[iIndex].m_IfState.state = 0;	

  007bf	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  007c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007cc	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  007d3	80 e2 f3	 and	 dl, 243			; 000000f3H
  007d6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  007dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007e3	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 20625: 	gObj[iIndex].m_IfState.type = 0;

  007ea	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  007f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007f7	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  007fe	80 e2 0f	 and	 dl, 15			; 0000000fH
  00801	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00808	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0080e	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 20626: 	gObj[iIndex].m_IfState.use =  0;

  00815	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0081c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00822	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00829	80 e2 fc	 and	 dl, 252			; 000000fcH
  0082c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00833	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00839	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 20627: #endif
; 20628: 
; 20629: 	// *> .      
; 20630: 	if (gObj[iIndex].m_bPShopOpen == true) {

  00840	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00847	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0084d	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  00855	83 fa 01	 cmp	 edx, 1
  00858	75 0c		 jne	 SHORT $LN29@CGRequestE

; 20631: 		CGPShopReqClose (iIndex);

  0085a	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0085d	50		 push	 eax
  0085e	e8 00 00 00 00	 call	 ?CGPShopReqClose@@YAXH@Z ; CGPShopReqClose
  00863	83 c4 04	 add	 esp, 4
$LN29@CGRequestE:

; 20632: 	}
; 20633: 
; 20634: 	// *> .      
; 20635: 	if( gObj[iIndex].PartyNumber >= 0 )

  00866	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0086d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00873	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  0087b	7c 63		 jl	 SHORT $LN30@CGRequestE

; 20636: 	{
; 20637: 		PMSG_PARTYDELUSER pMsg;
; 20638: 		
; 20639: 		int pindex = gParty.GetIndex(gObj[iIndex].PartyNumber, iIndex, gObj[iIndex].DBNumber);

  0087d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00884	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0088a	8b 54 01 2c	 mov	 edx, DWORD PTR [ecx+eax+44]
  0088e	52		 push	 edx
  0088f	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00892	50		 push	 eax
  00893	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  0089a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008a0	8b 84 0a 88 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+648]
  008a7	50		 push	 eax
  008a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  008ad	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex
  008b2	89 85 80 fa ff
	ff		 mov	 DWORD PTR _pindex$1[ebp], eax

; 20640: 		if( pindex >= 0 )

  008b8	83 bd 80 fa ff
	ff 00		 cmp	 DWORD PTR _pindex$1[ebp], 0
  008bf	7c 1f		 jl	 SHORT $LN30@CGRequestE

; 20641: 		{
; 20642: 			pMsg.Number = pindex;

  008c1	8a 85 80 fa ff
	ff		 mov	 al, BYTE PTR _pindex$1[ebp]
  008c7	88 85 87 fa ff
	ff		 mov	 BYTE PTR _pMsg$2[ebp+3], al

; 20643: 			CGPartyDelUser( &pMsg, iIndex);

  008cd	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  008d0	50		 push	 eax
  008d1	8d 8d 84 fa ff
	ff		 lea	 ecx, DWORD PTR _pMsg$2[ebp]
  008d7	51		 push	 ecx
  008d8	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  008dd	83 c4 08	 add	 esp, 8
$LN30@CGRequestE:

; 20644: 		}
; 20645: 	}
; 20646: 	
; 20647: 	// *> .     
; 20648: 	if((gObj[iIndex].Class == CLASS_ELF) && (gObj[iIndex].m_RecallMon >= 0))

  008e0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  008e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008ed	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  008f5	83 fa 02	 cmp	 edx, 2
  008f8	75 33		 jne	 SHORT $LN32@CGRequestE
  008fa	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00901	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00907	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  0090f	7c 1c		 jl	 SHORT $LN32@CGRequestE

; 20649: 	{
; 20650: 		GCRecallMonLife(iIndex, 60, 0);

  00911	6a 00		 push	 0
  00913	6a 3c		 push	 60			; 0000003cH
  00915	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00918	50		 push	 eax
  00919	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  0091e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20651: 		gObjMonsterCallKill(iIndex);

  00921	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00924	50		 push	 eax
  00925	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  0092a	83 c4 04	 add	 esp, 4
$LN32@CGRequestE:

; 20652: 	}
; 20653: 
; 20654: 	// *> .    
; 20655: 	CHAR szTemp [256];
; 20656: 	wsprintf(szTemp, lMsg.Get(1230), iENTER_LEVEL+1);					// "  %d   ."

  0092d	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _iENTER_LEVEL$[ebp]
  00933	83 c0 01	 add	 eax, 1
  00936	50		 push	 eax
  00937	68 ce 04 00 00	 push	 1230			; 000004ceH
  0093c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00941	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00947	50		 push	 eax
  00948	8d 8d 80 f9 ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0094e	51		 push	 ecx
  0094f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00955	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20657: 	GCServerMsgStringSend(szTemp, iIndex, 1);

  00958	6a 01		 push	 1
  0095a	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0095d	50		 push	 eax
  0095e	8d 8d 80 f9 ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00964	51		 push	 ecx
  00965	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0096a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20658: 
; 20659: 
; 20660: 	switch(iENTER_LEVEL+1) {

  0096d	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _iENTER_LEVEL$[ebp]
  00973	83 c0 01	 add	 eax, 1
  00976	89 85 7c f8 ff
	ff		 mov	 DWORD PTR tv516[ebp], eax
  0097c	8b 8d 7c f8 ff
	ff		 mov	 ecx, DWORD PTR tv516[ebp]
  00982	83 e9 01	 sub	 ecx, 1
  00985	89 8d 7c f8 ff
	ff		 mov	 DWORD PTR tv516[ebp], ecx
  0098b	83 bd 7c f8 ff
	ff 05		 cmp	 DWORD PTR tv516[ebp], 5
  00992	77 6b		 ja	 SHORT $LN2@CGRequestE
  00994	8b 95 7c f8 ff
	ff		 mov	 edx, DWORD PTR tv516[ebp]
  0099a	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN52@CGRequestE[edx*4]
$LN33@CGRequestE:

; 20661: 	case 1 :		// 1
; 20662: 		gObjMoveGate(iIndex, GATE_CHAOSCASTLE_1);

  009a1	6a 52		 push	 82			; 00000052H
  009a3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  009a6	50		 push	 eax
  009a7	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  009ac	83 c4 08	 add	 esp, 8

; 20663: 		break;

  009af	eb 4e		 jmp	 SHORT $LN2@CGRequestE
$LN34@CGRequestE:

; 20664: 	case 2 :		// 2
; 20665: 		gObjMoveGate(iIndex, GATE_CHAOSCASTLE_2);

  009b1	6a 53		 push	 83			; 00000053H
  009b3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  009b6	50		 push	 eax
  009b7	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  009bc	83 c4 08	 add	 esp, 8

; 20666: 		break;

  009bf	eb 3e		 jmp	 SHORT $LN2@CGRequestE
$LN35@CGRequestE:

; 20667: 	case 3 :		// 3
; 20668: 		gObjMoveGate(iIndex, GATE_CHAOSCASTLE_3);

  009c1	6a 54		 push	 84			; 00000054H
  009c3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  009c6	50		 push	 eax
  009c7	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  009cc	83 c4 08	 add	 esp, 8

; 20669: 		break;

  009cf	eb 2e		 jmp	 SHORT $LN2@CGRequestE
$LN36@CGRequestE:

; 20670: 	case 4 :		// 4
; 20671: 		gObjMoveGate(iIndex, GATE_CHAOSCASTLE_4);

  009d1	6a 55		 push	 85			; 00000055H
  009d3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  009d6	50		 push	 eax
  009d7	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  009dc	83 c4 08	 add	 esp, 8

; 20672: 		break;

  009df	eb 1e		 jmp	 SHORT $LN2@CGRequestE
$LN37@CGRequestE:

; 20673: 	case 5 :		// 5
; 20674: 		gObjMoveGate(iIndex, GATE_CHAOSCASTLE_5);

  009e1	6a 56		 push	 86			; 00000056H
  009e3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  009e6	50		 push	 eax
  009e7	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  009ec	83 c4 08	 add	 esp, 8

; 20675: 		break;

  009ef	eb 0e		 jmp	 SHORT $LN2@CGRequestE
$LN38@CGRequestE:

; 20676: 	case 6 :		// 6
; 20677: 		gObjMoveGate(iIndex, GATE_CHAOSCASTLE_6);

  009f1	6a 57		 push	 87			; 00000057H
  009f3	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  009f6	50		 push	 eax
  009f7	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  009fc	83 c4 08	 add	 esp, 8
$LN2@CGRequestE:

; 20678: 		break;
; 20679: #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	// 7 
; 20680: 	case 7 :		// 6
; 20681: 		gObjMoveGate(iIndex, GATE_CHAOSCASTLE_7);
; 20682: 		break;
; 20683: #endif		
; 20684: 	}
; 20685: 
; 20686: #ifdef EXTEND_LOG_SYSTEM_06_20070308
; 20687: 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20688: 	LogAddTD("[Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle (Guard Mail Set Serial:%u) PCRoom:%d", 
; 20689: 	#else
; 20690: 	LogAddTD("[Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle (Guard Mail Set Serial:%d) PCRoom:%d", 
; 20691: 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20692: 		iENTER_LEVEL+1, 
; 20693: 		gObj[iIndex].AccountID,
; 20694: 		gObj[iIndex].Name,
; 20695: 		dwITEM_SERIAL,
; 20696: 		gObj[iIndex].m_bPCBangUser
; 20697: 		);
; 20698: #else
; 20699: 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20700: 	LogAddTD("[Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle (Guard Mail Set Serial:%u)", 
; 20701: 	#else
; 20702: 	LogAddTD("[Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle (Guard Mail Set Serial:%d)", 

  009ff	8b 45 f0	 mov	 eax, DWORD PTR _dwITEM_SERIAL$[ebp]
  00a02	50		 push	 eax
  00a03	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00a0a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a10	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00a14	50		 push	 eax
  00a15	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00a1c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a22	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00a26	50		 push	 eax
  00a27	8b 8d 94 fa ff
	ff		 mov	 ecx, DWORD PTR _iENTER_LEVEL$[ebp]
  00a2d	83 c1 01	 add	 ecx, 1
  00a30	51		 push	 ecx
  00a31	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
  00a36	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a3c	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CGRequestE:

; 20703: 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20704: 		iENTER_LEVEL+1, 
; 20705: 		gObj[iIndex].AccountID,
; 20706: 		gObj[iIndex].Name,
; 20707: 		dwITEM_SERIAL
; 20708: 		);
; 20709: #endif // EXTEND_LOG_SYSTEM_06_20070308
; 20710: }

  00a3f	5f		 pop	 edi
  00a40	5e		 pop	 esi
  00a41	5b		 pop	 ebx
  00a42	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a45	33 cd		 xor	 ecx, ebp
  00a47	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a4c	8b e5		 mov	 esp, ebp
  00a4e	5d		 pop	 ebp
  00a4f	c3		 ret	 0
$LN52@CGRequestE:
  00a50	00 00 00 00	 DD	 $LN33@CGRequestE
  00a54	00 00 00 00	 DD	 $LN34@CGRequestE
  00a58	00 00 00 00	 DD	 $LN35@CGRequestE
  00a5c	00 00 00 00	 DD	 $LN36@CGRequestE
  00a60	00 00 00 00	 DD	 $LN37@CGRequestE
  00a64	00 00 00 00	 DD	 $LN38@CGRequestE
?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ENDP ; CGRequestEnterChaosCastle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z
_TEXT	SEGMENT
tv194 = -360						; size = 4
tv66 = -360						; size = 4
tv301 = -356						; size = 4
tv195 = -356						; size = 4
tv67 = -356						; size = 4
_szTemp$1 = -288					; size = 256
_iBC_INDEX$2 = -32					; size = 4
_iRESULT$3 = -28					; size = 4
_bBCENTER_ANYWAY$ = -24					; size = 4
_pResult$ = -20						; size = 4
_dwITEM_SERIAL$ = -16					; size = 4
_iITEM_LEVEL$ = -12					; size = 4
_btInvisibleCourtItemPos$ = -6				; size = 1
_btBridgeNumber$ = -5					; size = 1
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z PROC ; CGRequestEnterBloodCastle, COMDAT

; 19618: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 19619: 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  00016	83 7d 0c 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  0001a	7d 0c		 jge	 SHORT $LN33@CGRequestE
  0001c	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00026	eb 2b		 jmp	 SHORT $LN34@CGRequestE
$LN33@CGRequestE:
  00028	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  0002f	7e 0c		 jle	 SHORT $LN31@CGRequestE
  00031	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN32@CGRequestE
$LN31@CGRequestE:
  0003d	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN32@CGRequestE:
  00047	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN34@CGRequestE:
  00053	83 bd 9c fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 21		 jne	 SHORT $LN4@CGRequestE

; 19620: 	{
; 19621: 		LogAdd("return %s %d", __FILE__, __LINE__);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z@4JA
  00061	83 c0 03	 add	 eax, 3
  00064	50		 push	 eax
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19622: 		return;

  00078	e9 70 05 00 00	 jmp	 $LN1@CGRequestE
$LN4@CGRequestE:

; 19623: 	}
; 19624: 
; 19625: 	BYTE btBridgeNumber = lpMsg->iBridgeNumber-1;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00080	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00084	83 e9 01	 sub	 ecx, 1
  00087	88 4d fb	 mov	 BYTE PTR _btBridgeNumber$[ebp], cl

; 19626: 	BYTE btInvisibleCourtItemPos = lpMsg->iItemPos;

  0008a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008d	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  00090	88 4d fa	 mov	 BYTE PTR _btInvisibleCourtItemPos$[ebp], cl

; 19627: 	INT	 iITEM_LEVEL = 0;

  00093	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0

; 19628: 	DWORD dwITEM_SERIAL = 0;

  0009a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], 0

; 19629: 
; 19630: 	PMSG_RESULT_MOVEBLOODCASTLE pResult;
; 19631: 	PHeadSetB((LPBYTE)&pResult, 0x9A, sizeof(pResult));

  000a1	6a 04		 push	 4
  000a3	68 9a 00 00 00	 push	 154			; 0000009aH
  000a8	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19632: 	pResult.Result = 0;

  000b4	c6 45 ef 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 19633: 
; 19634: 	if ((gObj[iIndex].Type != OBJTYPE_CHARACTER) || (gObj[iIndex].Connected <= 2)) {

  000b8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c5	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000ca	83 fa 01	 cmp	 edx, 1
  000cd	75 14		 jne	 SHORT $LN6@CGRequestE
  000cf	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000dc	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  000e1	7f 05		 jg	 SHORT $LN5@CGRequestE
$LN6@CGRequestE:

; 19635: 		return;

  000e3	e9 05 05 00 00	 jmp	 $LN1@CGRequestE
$LN5@CGRequestE:

; 19636: 	}
; 19637: 
; 19638: #ifdef BLOOD_DEVILSQUARE_TRADE_BUG_FIX	
; 19639: 	// *> .     .
; 19640: 	if (gObj[iIndex].m_IfState.use != 0 && gObj[iIndex].m_IfState.type != I_ETCWINDOW ) {

  000e8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f5	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000fc	80 e2 03	 and	 dl, 3
  000ff	0f b6 c2	 movzx	 eax, dl
  00102	85 c0		 test	 eax, eax
  00104	74 27		 je	 SHORT $LN7@CGRequestE
  00106	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00113	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0011a	c0 ea 04	 shr	 dl, 4
  0011d	80 e2 0f	 and	 dl, 15			; 0000000fH
  00120	0f b6 c2	 movzx	 eax, dl
  00123	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00126	74 05		 je	 SHORT $LN7@CGRequestE

; 19641: 		return;

  00128	e9 c0 04 00 00	 jmp	 $LN1@CGRequestE
$LN7@CGRequestE:

; 19642: 	}
; 19643: #endif
; 19644: 
; 19645: #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 19646: 	// *> .     .
; 19647: #ifdef UPDATE_PK_SYSTEM_20070302	//     .
; 19648: 	BOOL	PKFlag = FALSE;
; 19649: 	if(gObj[iIndex].PartyNumber >= 0)	//  
; 19650: 	{
; 19651: 		if( gParty.GetPKPartyPenalty(gObj[iIndex].PartyNumber) >= PK_LEVEL_DEFAULT+2)
; 19652: 		{
; 19653: 			PKFlag = TRUE;
; 19654: 		}
; 19655: 	}
; 19656: 	else
; 19657: 	{
; 19658: 		if(gObj[iIndex].m_PK_Level >= PK_LEVEL_DEFAULT+1)
; 19659: 		{
; 19660: 			PKFlag = TRUE;
; 19661: 		}
; 19662: 	}
; 19663: 	
; 19664: 	if(PKFlag == TRUE)
; 19665: #else	// UPDATE_PK_SYSTEM_20070302
; 19666: 	if( gObj[iIndex].m_PK_Level >= PK_LEVEL_DEFAULT + 1 )

  0012d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013a	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00142	83 fa 04	 cmp	 edx, 4
  00145	7c 1e		 jl	 SHORT $LN8@CGRequestE

; 19667: #endif	// UPDATE_PK_SYSTEM_20070302
; 19668: 	{
; 19669: 		pResult.Result = 7;

  00147	c6 45 ef 07	 mov	 BYTE PTR _pResult$[ebp+3], 7

; 19670: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0014b	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0014f	50		 push	 eax
  00150	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00153	51		 push	 ecx
  00154	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19671: 		return;

  00160	e9 88 04 00 00	 jmp	 $LN1@CGRequestE
$LN8@CGRequestE:

; 19672: 	}
; 19673: #endif
; 19674: 
; 19675: 	// 1 .      .
; 19676: 	if (!g_BloodCastle.CheckCanEnter(btBridgeNumber)) {

  00165	0f b6 45 fb	 movzx	 eax, BYTE PTR _btBridgeNumber$[ebp]
  00169	50		 push	 eax
  0016a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0016f	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  00174	0f b6 c8	 movzx	 ecx, al
  00177	85 c9		 test	 ecx, ecx
  00179	75 1e		 jne	 SHORT $LN9@CGRequestE

; 19677: 		pResult.Result = 2;

  0017b	c6 45 ef 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 19678: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0017f	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00183	50		 push	 eax
  00184	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00187	51		 push	 ecx
  00188	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0018b	52		 push	 edx
  0018c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19679: 		return;

  00194	e9 54 04 00 00	 jmp	 $LN1@CGRequestE
$LN9@CGRequestE:

; 19680: 	}
; 19681: 
; 19682: 
; 19683: 	// 2 .        .
; 19684: 	if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].IsItem() == TRUE )

  00199	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001a0	0f b6 4d fa	 movzx	 ecx, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  001a4	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  001aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b0	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  001b7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001bc	83 f8 01	 cmp	 eax, 1
  001bf	0f 85 04 01 00
	00		 jne	 $LN10@CGRequestE

; 19685: 	{
; 19686: 		if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM(13, 18) )	//  

  001c5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001cc	0f b6 4d fa	 movzx	 ecx, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  001d0	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001dc	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  001e3	0f bf 74 10 06	 movsx	 esi, WORD PTR [eax+edx+6]
  001e8	6a 12		 push	 18			; 00000012H
  001ea	6a 0d		 push	 13			; 0000000dH
  001ec	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f1	83 c4 08	 add	 esp, 8
  001f4	3b f0		 cmp	 esi, eax
  001f6	0f 85 ad 00 00
	00		 jne	 $LN12@CGRequestE

; 19687: 		{
; 19688: 			iITEM_LEVEL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Level;				//   .

  001fc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00203	0f b6 4d fa	 movzx	 ecx, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  00207	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00213	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  0021a	0f bf 4c 10 08	 movsx	 ecx, WORD PTR [eax+edx+8]
  0021f	89 4d f4	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], ecx

; 19689: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;			//   .

  00222	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00229	0f b6 4d fa	 movzx	 ecx, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  0022d	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00233	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00239	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00240	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00243	89 4d f0	 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], ecx

; 19690: 			if (!CHECK_LIMIT(iITEM_LEVEL, MAX_BLOODCASTLE_BRIDGE_COUNT+1)) {					// 0 < iITEM_LEVEL <  + 1

  00246	83 7d f4 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  0024a	7d 0c		 jge	 SHORT $LN37@CGRequestE
  0024c	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv195[ebp], 0
  00256	eb 28		 jmp	 SHORT $LN38@CGRequestE
$LN37@CGRequestE:
  00258	83 7d f4 07	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 7
  0025c	7e 0c		 jle	 SHORT $LN35@CGRequestE
  0025e	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv194[ebp], 0
  00268	eb 0a		 jmp	 SHORT $LN36@CGRequestE
$LN35@CGRequestE:
  0026a	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv194[ebp], 1
$LN36@CGRequestE:
  00274	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR tv194[ebp]
  0027a	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv195[ebp], eax
$LN38@CGRequestE:
  00280	83 bd 9c fe ff
	ff 00		 cmp	 DWORD PTR tv195[ebp], 0
  00287	75 1e		 jne	 SHORT $LN14@CGRequestE

; 19691: 				pResult.Result = 1;

  00289	c6 45 ef 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 19692: 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0028d	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00291	50		 push	 eax
  00292	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00295	51		 push	 ecx
  00296	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00299	52		 push	 edx
  0029a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0029f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19693: 				return;

  002a2	e9 46 03 00 00	 jmp	 $LN1@CGRequestE
$LN14@CGRequestE:

; 19694: 			}
; 19695: 		}

  002a7	eb 1e		 jmp	 SHORT $LN13@CGRequestE
$LN12@CGRequestE:

; 19696: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 19697: 		//     
; 19698: 		else if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 47 )
; 19699: 			&& gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 0
; 19700: 			   )
; 19701: 		{
; 19702: #ifdef MODIFY_MASTER_LEVEL_SYSTEM_20080414
; 19703: 			if( g_MasterLevelSystem.IsMasterLevelUser( &gObj[iIndex] ) )
; 19704: 			{
; 19705: 				iITEM_LEVEL		= MAX_BLOODCASTLE_BRIDGE_COUNT;
; 19706: 				//iITEM_LEVEL	= MAX_DEVILSQUARE - 1;
; 19707: 			} else {
; 19708: #endif // MODIFY_MASTER_LEVEL_SYSTEM_20080414
; 19709: 			for( int i = 0 ; i < MAX_BLOODCASTLE_BRIDGE_COUNT + 1 ; i++ )
; 19710: 			{
; 19711: 				if( g_BloodCastle.CheckEnterLevel( iIndex, i + 1 ) == 0 )
; 19712: 				{
; 19713: 					iITEM_LEVEL = i + 1;
; 19714: 					break;
; 19715: 				}
; 19716: 			}
; 19717: #ifdef MODIFY_MASTER_LEVEL_SYSTEM_20080414
; 19718: 			}
; 19719: #endif // MODIFY_MASTER_LEVEL_SYSTEM_20080414
; 19720: 			
; 19721: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;
; 19722: 			if( !CHECK_LIMIT( iITEM_LEVEL, MAX_BLOODCASTLE_BRIDGE_COUNT+1 ) )
; 19723: 			{
; 19724: 				pResult.Result = 1;
; 19725: 				DataSend( iIndex, (LPBYTE)&pResult, pResult.h.size );
; 19726: 				return;
; 19727: 			}
; 19728: 		}
; 19729: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 19730: 		else {
; 19731: 			pResult.Result = 1;

  002a9	c6 45 ef 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 19732: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  002ad	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002b1	50		 push	 eax
  002b2	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  002b5	51		 push	 ecx
  002b6	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  002b9	52		 push	 edx
  002ba	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19733: 			return;

  002c2	e9 26 03 00 00	 jmp	 $LN1@CGRequestE
$LN13@CGRequestE:

; 19734: 		}
; 19735: 	}

  002c7	eb 1e		 jmp	 SHORT $LN11@CGRequestE
$LN10@CGRequestE:

; 19736: 	else {
; 19737: 		pResult.Result = 1;

  002c9	c6 45 ef 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 19738: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  002cd	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002d1	50		 push	 eax
  002d2	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  002d5	51		 push	 ecx
  002d6	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  002d9	52		 push	 edx
  002da	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19739: 		return;

  002e2	e9 06 03 00 00	 jmp	 $LN1@CGRequestE
$LN11@CGRequestE:

; 19740: 	}
; 19741: 
; 19742: 	
; 19743: #ifdef	BLOODCASTLE_CHECK_ENTERCOUNT_20040304
; 19744: 	// *> .    .
; 19745: 	BOOL bBCENTER_ANYWAY = TRUE;

  002e7	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bBCENTER_ANYWAY$[ebp], 1

; 19746: #if 0 // BLOOD CASTLE ENTER COUNT
; 19747: 	if (!DevilSquareEventConnect) {
; 19748: 		if (IsDevilSquareEventConnected) {
; 19749: 			//    .
; 19750: 			PMSG_REQ_BLOODCASTLEENTERCHECK pMsg;
; 19751: 			pMsg.h.c = 0xC1;
; 19752: 			pMsg.h.headcode = 0x08;
; 19753: 			pMsg.h.size = sizeof(pMsg);
; 19754: 			memcpy (pMsg.AccountID, gObj[iIndex].AccountID, MAX_IDSTRING);
; 19755: 			memcpy (pMsg.GameID, gObj[iIndex].Name, MAX_IDSTRING);
; 19756: 			pMsg.ServerCode = gGameServerCode;
; 19757: 			pMsg.iObjIndex = iIndex;
; 19758: 			pMsg.iItemPos = lpMsg->iItemPos;
; 19759: 			pMsg.iItemLevel = iITEM_LEVEL;
; 19760: 			pMsg.iBridgeNumber = lpMsg->iBridgeNumber;
; 19761: 
; 19762: 			wsRServerCli.DataSend((char*)&pMsg, pMsg.h.size);
; 19763: 		
; 19764: 			bBCENTER_ANYWAY = FALSE;
; 19765: 		}
; 19766: 		else {
; 19767: 			BOOL bRETVAL = GMRankingServerConnect(gDevilSquareEventServerIp, WM_USER+12);	// WM_ASS_RANKINGCLIMSG
; 19768: 			if (bRETVAL == FALSE) {
; 19769: 				bBCENTER_ANYWAY = TRUE;
; 19770: 			}
; 19771: 			else {
; 19772: 				//    .
; 19773: 				PMSG_REQ_BLOODCASTLEENTERCHECK pMsg;
; 19774: 				pMsg.h.c = 0xC1;
; 19775: 				pMsg.h.headcode = 0x08;
; 19776: 				pMsg.h.size = sizeof(pMsg);
; 19777: 				memcpy (pMsg.AccountID, gObj[iIndex].AccountID, MAX_IDSTRING);
; 19778: 				memcpy (pMsg.GameID, gObj[iIndex].Name, MAX_IDSTRING);
; 19779: 				pMsg.ServerCode = gGameServerCode;
; 19780: 				pMsg.iObjIndex = iIndex;
; 19781: 				pMsg.iItemPos = lpMsg->iItemPos;
; 19782: 				pMsg.iItemLevel = iITEM_LEVEL;
; 19783: 				pMsg.iBridgeNumber = lpMsg->iBridgeNumber;
; 19784: 
; 19785: 				wsRServerCli.DataSend((char*)&pMsg, pMsg.h.size);
; 19786: 				
; 19787: 				bBCENTER_ANYWAY = FALSE;
; 19788: 			}
; 19789: 		}
; 19790: 	}
; 19791: 	else
; 19792: 	{
; 19793: 		bBCENTER_ANYWAY = TRUE;
; 19794: 	}
; 19795: #endif
; 19796: 
; 19797: 	//      .
; 19798: 	if (bBCENTER_ANYWAY == TRUE) {

  002ee	83 7d e8 01	 cmp	 DWORD PTR _bBCENTER_ANYWAY$[ebp], 1
  002f2	0f 85 f5 02 00
	00		 jne	 $LN1@CGRequestE

; 19799: 		
; 19800: 		// 3 .        .
; 19801: 		INT iRESULT = g_BloodCastle.CheckEnterLevel(iIndex, iITEM_LEVEL);

  002f8	8b 45 f4	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  002fb	50		 push	 eax
  002fc	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  002ff	51		 push	 ecx
  00300	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00305	e8 00 00 00 00	 call	 ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CheckEnterLevel
  0030a	89 45 e4	 mov	 DWORD PTR _iRESULT$3[ebp], eax

; 19802: 
; 19803: 		if (!iRESULT) {					//  .

  0030d	83 7d e4 00	 cmp	 DWORD PTR _iRESULT$3[ebp], 0
  00311	75 1b		 jne	 SHORT $LN16@CGRequestE

; 19804: 			pResult.Result = 0;

  00313	c6 45 ef 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 19805: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00317	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0031b	50		 push	 eax
  0031c	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0031f	51		 push	 ecx
  00320	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00323	52		 push	 edx
  00324	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00329	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19806: 		}

  0032c	eb 51		 jmp	 SHORT $LN17@CGRequestE
$LN16@CGRequestE:

; 19807: 		else if (iRESULT == -1) {		//   .

  0032e	83 7d e4 ff	 cmp	 DWORD PTR _iRESULT$3[ebp], -1
  00332	75 20		 jne	 SHORT $LN18@CGRequestE

; 19808: 			pResult.Result = 4;

  00334	c6 45 ef 04	 mov	 BYTE PTR _pResult$[ebp+3], 4

; 19809: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00338	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0033c	50		 push	 eax
  0033d	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00340	51		 push	 ecx
  00341	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00344	52		 push	 edx
  00345	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0034a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19810: 			return;

  0034d	e9 9b 02 00 00	 jmp	 $LN1@CGRequestE

; 19811: 		}

  00352	eb 2b		 jmp	 SHORT $LN17@CGRequestE
$LN18@CGRequestE:

; 19812: 		else if (iRESULT == 1) {		//   .

  00354	83 7d e4 01	 cmp	 DWORD PTR _iRESULT$3[ebp], 1
  00358	75 20		 jne	 SHORT $LN20@CGRequestE

; 19813: 			pResult.Result = 3;

  0035a	c6 45 ef 03	 mov	 BYTE PTR _pResult$[ebp+3], 3

; 19814: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0035e	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00362	50		 push	 eax
  00363	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00366	51		 push	 ecx
  00367	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0036a	52		 push	 edx
  0036b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00370	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19815: 			return;

  00373	e9 75 02 00 00	 jmp	 $LN1@CGRequestE

; 19816: 		}

  00378	eb 05		 jmp	 SHORT $LN17@CGRequestE
$LN20@CGRequestE:

; 19817: 		else return;					//  .

  0037a	e9 6e 02 00 00	 jmp	 $LN1@CGRequestE
$LN17@CGRequestE:

; 19818: 
; 19819: #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 19820: 		// *> .     3    .
; 19821: /*
; 19822: 		if( gObj[iIndex].PartyNumber >= 0 )
; 19823: 		{
; 19824: 			int iPartyUsers = gParty.GetCount(gObj[iIndex].PartyNumber);
; 19825: 			if (iPartyUsers < 3) {
; 19826: 				//  3    .
; 19827: 				pResult.Result = 5;		// !!! .   
; 19828: 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 19829: 				return;
; 19830: 			}
; 19831: 		}
; 19832: 		else {
; 19833: 			//     .
; 19834: 			pResult.Result = 5;			// !!! .   
; 19835: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 19836: 			return;
; 19837: 		}
; 19838: */
; 19839: #endif
; 19840: 		
; 19841: /*
; 19842: 	#ifdef APPLY_TESTSERVER
; 19843: 		// 4 .       . ->  
; 19844: 		if (g_BloodCastle.CheckUserHaveUlimateWeapon(iIndex)) {
; 19845: 			LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) tried to Enter Castle but Have Ultimate Weapon", 
; 19846: 				iITEM_LEVEL,
; 19847: 				gObj[iIndex].AccountID,
; 19848: 				gObj[iIndex].Name
; 19849: 				);
; 19850: 
; 19851: 			PMSG_NOTICE	pNotice;
; 19852: 
; 19853: #ifdef MODIFY_NOTICE_20040325
; 19854: 			TNotice::MakeNoticeMsg( &pNotice, 1, "      ." );
; 19855: #else
; 19856: 			pNotice.type = 1;
; 19857: 			strcpy(pNotice.Notice, "      .");
; 19858: 			PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 19859: #endif
; 19860: 
; 19861: 			DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 19862: 
; 19863: 			return;
; 19864: 		}
; 19865: 	#endif	
; 19866: */
; 19867: 
; 19868: 
; 19869: 		// *> .           .
; 19870: 		g_BloodCastle.CheckUsersOnConnect(iITEM_LEVEL-1);

  0037f	8b 45 f4	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  00382	83 e8 01	 sub	 eax, 1
  00385	50		 push	 eax
  00386	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0038b	e8 00 00 00 00	 call	 ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ; CBloodCastle::CheckUsersOnConnect

; 19871: 
; 19872: 
; 19873: 		// 5 .      .
; 19874: #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 19875: 		INT iBC_INDEX = g_BloodCastle.EnterUserBridge(btBridgeNumber, iIndex);
; 19876: #else
; 19877: 		INT iBC_INDEX = g_BloodCastle.EnterUserBridge(iITEM_LEVEL-1, iIndex);

  00390	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00393	50		 push	 eax
  00394	8b 4d f4	 mov	 ecx, DWORD PTR _iITEM_LEVEL$[ebp]
  00397	83 e9 01	 sub	 ecx, 1
  0039a	51		 push	 ecx
  0039b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  003a0	e8 00 00 00 00	 call	 ?EnterUserBridge@CBloodCastle@@QAEHHH@Z ; CBloodCastle::EnterUserBridge
  003a5	89 45 e0	 mov	 DWORD PTR _iBC_INDEX$2[ebp], eax

; 19878: #endif
; 19879: 
; 19880: 		if (iBC_INDEX == -1) {

  003a8	83 7d e0 ff	 cmp	 DWORD PTR _iBC_INDEX$2[ebp], -1
  003ac	75 1e		 jne	 SHORT $LN22@CGRequestE

; 19881: 			pResult.Result = 5;

  003ae	c6 45 ef 05	 mov	 BYTE PTR _pResult$[ebp+3], 5

; 19882: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  003b2	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  003b6	50		 push	 eax
  003b7	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  003ba	51		 push	 ecx
  003bb	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  003be	52		 push	 edx
  003bf	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19883: 			return;

  003c7	e9 21 02 00 00	 jmp	 $LN1@CGRequestE
$LN22@CGRequestE:

; 19884: 		}
; 19885: 
; 19886: 		// !!>  ->      .
; 19887: 
; 19888: 		// *> .  
; 19889: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 19890: 		//    
; 19891: 		if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 18 )
; 19892: 			|| ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 47 ) && gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability == 1 )
; 19893: 		  )
; 19894: 		{
; 19895: 			gObjInventoryDeleteItem(iIndex, btInvisibleCourtItemPos);
; 19896: 			GCInventoryItemDeleteSend(iIndex, btInvisibleCourtItemPos, 1);
; 19897: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 19898: 		}
; 19899: 		else if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 47 )
; 19900: 			&& gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 1
; 19901: 			)
; 19902: 		{
; 19903: 			gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability--;
; 19904: 
; 19905: 			GCItemDurSend2( iIndex, btInvisibleCourtItemPos, gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability, 0 );
; 19906: 		}
; 19907: #else
; 19908: 		gObjInventoryDeleteItem(iIndex, btInvisibleCourtItemPos);

  003cc	0f b6 45 fa	 movzx	 eax, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  003d0	50		 push	 eax
  003d1	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  003d4	51		 push	 ecx
  003d5	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  003da	83 c4 08	 add	 esp, 8

; 19909: 		GCInventoryItemDeleteSend(iIndex, btInvisibleCourtItemPos, 1);

  003dd	6a 01		 push	 1
  003df	0f b6 45 fa	 movzx	 eax, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  003e3	50		 push	 eax
  003e4	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  003e7	51		 push	 ecx
  003e8	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  003ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19910: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  003f0	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  003f4	50		 push	 eax
  003f5	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  003f8	51		 push	 ecx
  003f9	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  003fc	52		 push	 edx
  003fd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00402	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19911: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 19912: 
; 19913: 		// *> .    
; 19914: #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 19915: 		gObj[iIndex].m_cBloodCastleIndex = btBridgeNumber;
; 19916: #else
; 19917: 		gObj[iIndex].m_cBloodCastleIndex = iITEM_LEVEL-1;

  00405	8b 45 f4	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  00408	83 e8 01	 sub	 eax, 1
  0040b	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00412	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00418	88 84 0a d2 0c
	00 00		 mov	 BYTE PTR [edx+ecx+3282], al

; 19918: #endif
; 19919: 		gObj[iIndex].m_cBloodCastleSubIndex = iBC_INDEX;

  0041f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00426	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0042c	8a 55 e0	 mov	 dl, BYTE PTR _iBC_INDEX$2[ebp]
  0042f	88 94 01 d3 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3283], dl

; 19920: 		gObj[iIndex].m_iBloodCastleEXP = 0;

  00436	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0043d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00443	c7 84 01 d4 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3284], 0

; 19921: 
; 19922: 	#ifdef BLOOD_DEVILSQUARE_TRADE_BUG_FIX
; 19923: 		gObj[iIndex].m_IfState.state = 0;	

  0044e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00455	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0045b	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00462	80 e2 f3	 and	 dl, 243			; 000000f3H
  00465	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0046c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00472	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19924: 		gObj[iIndex].m_IfState.type = 0;

  00479	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00480	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00486	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0048d	80 e2 0f	 and	 dl, 15			; 0000000fH
  00490	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00497	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0049d	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19925: 		gObj[iIndex].m_IfState.use =  0;

  004a4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  004ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004b1	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  004b8	80 e2 fc	 and	 dl, 252			; 000000fcH
  004bb	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  004c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004c8	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19926: 	#endif
; 19927: 		// *> .       
; 19928: /*		if( gObj[iIndex].PartyNumber >= 0 )
; 19929: 		{
; 19930: 			PMSG_PARTYDELUSER pMsg;
; 19931: 			
; 19932: 			int pindex = gParty.GetIndex(gObj[iIndex].PartyNumber, iIndex, gObj[iIndex].DBNumber);
; 19933: 			if( pindex >= 0 )
; 19934: 			{
; 19935: 				pMsg.Number = pindex;
; 19936: 				CGPartyDelUser( &pMsg, iIndex);
; 19937: 			}
; 19938: 		}
; 19939: */
; 19940: 		// *> .     .
; 19941: 		g_BloodCastle.SearchUserDeleteQuestItem(iIndex);

  004cf	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004d2	50		 push	 eax
  004d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  004d8	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 19942: 
; 19943: 		// *> .    
; 19944: 		CHAR szTemp [256];
; 19945: #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 19946: 		wsprintf(szTemp, lMsg.Get(1171), btBridgeNumber+1);			// "  %d  ."
; 19947: #else
; 19948: 		wsprintf(szTemp, lMsg.Get(1171), iITEM_LEVEL);				// "  %d  ."

  004dd	8b 45 f4	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  004e0	50		 push	 eax
  004e1	68 93 04 00 00	 push	 1171			; 00000493H
  004e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  004f1	50		 push	 eax
  004f2	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$1[ebp]
  004f8	51		 push	 ecx
  004f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  004ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19949: #endif
; 19950: 		GCServerMsgStringSend(szTemp, iIndex, 1);

  00502	6a 01		 push	 1
  00504	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00507	50		 push	 eax
  00508	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$1[ebp]
  0050e	51		 push	 ecx
  0050f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00514	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19951: 
; 19952: #ifdef BLOODCASTLE_EXTEND_20040314
; 19953: #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 19954: 		if (btBridgeNumber+1 == iITEM_LEVEL) {
; 19955: 			switch(iITEM_LEVEL) {
; 19956: 			case 1 :		// 1
; 19957: 				gObjMoveGate(iIndex, GATE_BLOODCASTLE_1);
; 19958: 				break;
; 19959: 			case 2 :		// 2
; 19960: 				gObjMoveGate(iIndex, GATE_BLOODCASTLE_2);
; 19961: 				break;
; 19962: 			case 3 :		// 3
; 19963: 				gObjMoveGate(iIndex, GATE_BLOODCASTLE_3);
; 19964: 				break;
; 19965: 			case 4 :		// 4
; 19966: 				gObjMoveGate(iIndex, GATE_BLOODCASTLE_4);
; 19967: 				break;
; 19968: 			case 5 :		// 5
; 19969: 				gObjMoveGate(iIndex, GATE_BLOODCASTLE_5);
; 19970: 				break;
; 19971: 			case 6 :		// 6
; 19972: 				gObjMoveGate(iIndex, GATE_BLOODCASTLE_6);
; 19973: 				break;
; 19974: 			case 7 :		// 7
; 19975: 				gObjMoveGate(iIndex, GATE_BLOODCASTLE_7);
; 19976: 				break;
; 19977: 			}
; 19978: 		}
; 19979: 		else if (btBridgeNumber+1 == 7 && iITEM_LEVEL == 6) {
; 19980: 			// 7
; 19981: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_7);
; 19982: 		}
; 19983: #else
; 19984: 		switch(iITEM_LEVEL) {

  00517	8b 45 f4	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  0051a	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv301[ebp], eax
  00520	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR tv301[ebp]
  00526	83 e9 01	 sub	 ecx, 1
  00529	89 8d 9c fe ff
	ff		 mov	 DWORD PTR tv301[ebp], ecx
  0052f	83 bd 9c fe ff
	ff 06		 cmp	 DWORD PTR tv301[ebp], 6
  00536	77 7b		 ja	 SHORT $LN2@CGRequestE
  00538	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR tv301[ebp]
  0053e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN39@CGRequestE[edx*4]
$LN23@CGRequestE:

; 19985: 		case 1 :		// 1
; 19986: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_1);

  00545	6a 42		 push	 66			; 00000042H
  00547	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00550	83 c4 08	 add	 esp, 8

; 19987: 			break;

  00553	eb 5e		 jmp	 SHORT $LN2@CGRequestE
$LN24@CGRequestE:

; 19988: 		case 2 :		// 2
; 19989: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_2);

  00555	6a 43		 push	 67			; 00000043H
  00557	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0055a	50		 push	 eax
  0055b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00560	83 c4 08	 add	 esp, 8

; 19990: 			break;

  00563	eb 4e		 jmp	 SHORT $LN2@CGRequestE
$LN25@CGRequestE:

; 19991: 		case 3 :		// 3
; 19992: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_3);

  00565	6a 44		 push	 68			; 00000044H
  00567	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0056a	50		 push	 eax
  0056b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00570	83 c4 08	 add	 esp, 8

; 19993: 			break;

  00573	eb 3e		 jmp	 SHORT $LN2@CGRequestE
$LN26@CGRequestE:

; 19994: 		case 4 :		// 4
; 19995: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_4);

  00575	6a 45		 push	 69			; 00000045H
  00577	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0057a	50		 push	 eax
  0057b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00580	83 c4 08	 add	 esp, 8

; 19996: 			break;

  00583	eb 2e		 jmp	 SHORT $LN2@CGRequestE
$LN27@CGRequestE:

; 19997: 		case 5 :		// 5
; 19998: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_5);

  00585	6a 46		 push	 70			; 00000046H
  00587	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0058a	50		 push	 eax
  0058b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00590	83 c4 08	 add	 esp, 8

; 19999: 			break;

  00593	eb 1e		 jmp	 SHORT $LN2@CGRequestE
$LN28@CGRequestE:

; 20000: 		case 6 :		// 6
; 20001: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_6);

  00595	6a 47		 push	 71			; 00000047H
  00597	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0059a	50		 push	 eax
  0059b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  005a0	83 c4 08	 add	 esp, 8

; 20002: 			break;

  005a3	eb 0e		 jmp	 SHORT $LN2@CGRequestE
$LN29@CGRequestE:

; 20003: 		case 7 :		// 7
; 20004: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_7);

  005a5	6a 50		 push	 80			; 00000050H
  005a7	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  005aa	50		 push	 eax
  005ab	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  005b0	83 c4 08	 add	 esp, 8
$LN2@CGRequestE:

; 20005: 			break;
; 20006: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 8 
; 20007: 		case 8 :		// 8
; 20008: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_8);
; 20009: 			break;
; 20010: #endif			
; 20011: 		}
; 20012: #endif
; 20013: #else
; 20014: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_1 + iITEM_LEVEL - 1);	//     
; 20015: #endif
; 20016: 
; 20017: #ifdef EXTEND_LOG_SYSTEM_06_20070308
; 20018: 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20019: 		LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%u), PCRoom:%d", 
; 20020: 	#else
; 20021: 		LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%d), PCRoom:%d", 
; 20022: 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20023: 			iITEM_LEVEL, 
; 20024: 			gObj[iIndex].AccountID,
; 20025: 			gObj[iIndex].Name,
; 20026: 			dwITEM_SERIAL,
; 20027: 			gObj[iIndex].m_bPCBangUser
; 20028: 			);
; 20029: #else
; 20030: 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20031: 		LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%u)", 
; 20032: 	#else
; 20033: 		LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%d)", 

  005b3	8b 45 f0	 mov	 eax, DWORD PTR _dwITEM_SERIAL$[ebp]
  005b6	50		 push	 eax
  005b7	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  005be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c4	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  005c8	50		 push	 eax
  005c9	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  005d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005d6	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  005da	50		 push	 eax
  005db	8b 4d f4	 mov	 ecx, DWORD PTR _iITEM_LEVEL$[ebp]
  005de	51		 push	 ecx
  005df	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
  005e4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005ea	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CGRequestE:

; 20034: 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20035: 			iITEM_LEVEL, 
; 20036: 			gObj[iIndex].AccountID,
; 20037: 			gObj[iIndex].Name,
; 20038: 			dwITEM_SERIAL
; 20039: 			);
; 20040: #endif // EXTEND_LOG_SYSTEM_06_20070308
; 20041: 	}
; 20042: 
; 20043: 
; 20044: #else
; 20045: 	
; 20046: 	// 3 .        .
; 20047: 	INT iRESULT = g_BloodCastle.CheckEnterLevel(iIndex, iITEM_LEVEL);
; 20048: 
; 20049: 	if (!iRESULT) {					//  .
; 20050: 		pResult.Result = 0;
; 20051: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20052: 	}
; 20053: 	else if (iRESULT == -1) {		//   .
; 20054: 		pResult.Result = 4;
; 20055: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20056: 		return;
; 20057: 	}
; 20058: 	else if (iRESULT == 1) {		//   .
; 20059: 		pResult.Result = 3;
; 20060: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20061: 		return;
; 20062: 	}
; 20063: 	else return;					//  .
; 20064: 
; 20065: 
; 20066: /*
; 20067: #ifdef APPLY_TESTSERVER
; 20068: 	// 4 .       . ->  
; 20069: 	if (g_BloodCastle.CheckUserHaveUlimateWeapon(iIndex)) {
; 20070: 		LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) tried to Enter Castle but Have Ultimate Weapon", 
; 20071: 			iITEM_LEVEL,
; 20072: 			gObj[iIndex].AccountID,
; 20073: 			gObj[iIndex].Name
; 20074: 			);
; 20075: 
; 20076: 		PMSG_NOTICE	pNotice;
; 20077: 
; 20078: #ifdef MODIFY_NOTICE_20040325
; 20079: 		TNotice::MakeNoticeMsg( &pNotice, 1, "      ." );
; 20080: #else
; 20081: 		pNotice.type = 1;
; 20082: 		strcpy(pNotice.Notice, "      .");
; 20083: 		PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 20084: #endif
; 20085: 
; 20086: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 20087: 
; 20088: 		return;
; 20089: 	}
; 20090: #endif	
; 20091: */
; 20092: 
; 20093: 
; 20094: 	// 5 .      .
; 20095: #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 20096: 	INT iBC_INDEX = g_BloodCastle.EnterUserBridge(btBridgeNumber, iIndex);
; 20097: #else
; 20098: 	INT iBC_INDEX = g_BloodCastle.EnterUserBridge(iITEM_LEVEL-1, iIndex);
; 20099: #endif
; 20100: 
; 20101: 	if (iBC_INDEX == -1) {
; 20102: 		pResult.Result = 5;
; 20103: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20104: 		return;
; 20105: 	}
; 20106: 
; 20107: 	// !!>  ->      .
; 20108: 
; 20109: 	// *> .  
; 20110: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 20111: 	//    
; 20112: 	if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 18 )
; 20113: 		|| ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 47 ) && gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability == 1 )
; 20114: 	  )
; 20115: 	{
; 20116: 		gObjInventoryDeleteItem(iIndex, btInvisibleCourtItemPos);
; 20117: 		GCInventoryItemDeleteSend(iIndex, btInvisibleCourtItemPos, 1);
; 20118: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20119: 	}
; 20120: 	else if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 47 )
; 20121: 		&& gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 1
; 20122: 		)
; 20123: 	{
; 20124: 		gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability--;
; 20125: 
; 20126: 		GCItemDurSend2( iIndex, btInvisibleCourtItemPos, gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability, 0 );
; 20127: 	}
; 20128: #else
; 20129: 	gObjInventoryDeleteItem(iIndex, btInvisibleCourtItemPos);
; 20130: 	GCInventoryItemDeleteSend(iIndex, btInvisibleCourtItemPos, 1);
; 20131: 	DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 20132: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 20133: 
; 20134: 	// *> .    
; 20135: #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 20136: 	gObj[iIndex].m_cBloodCastleIndex = btBridgeNumber;
; 20137: #else
; 20138: 	gObj[iIndex].m_cBloodCastleIndex = iITEM_LEVEL-1;
; 20139: #endif
; 20140: 	gObj[iIndex].m_cBloodCastleSubIndex = iBC_INDEX;
; 20141: 	gObj[iIndex].m_iBloodCastleEXP = 0;
; 20142: 
; 20143: #ifdef BLOOD_DEVILSQUARE_TRADE_BUG_FIX
; 20144: 	gObj[iIndex].m_IfState.state = 0;	
; 20145: 	gObj[iIndex].m_IfState.type = 0;
; 20146: 	gObj[iIndex].m_IfState.use =  0;
; 20147: #endif
; 20148: 	// *> .       
; 20149: /*	if( gObj[iIndex].PartyNumber >= 0 )
; 20150: 	{
; 20151: 		PMSG_PARTYDELUSER pMsg;
; 20152: 		
; 20153: 		int pindex = gParty.GetIndex(gObj[iIndex].PartyNumber, iIndex, gObj[iIndex].DBNumber);
; 20154: 		if( pindex >= 0 )
; 20155: 		{
; 20156: 			pMsg.Number = pindex;
; 20157: 			CGPartyDelUser( &pMsg, iIndex);
; 20158: 		}
; 20159: 	}
; 20160: */
; 20161: 	// *> .     .
; 20162: 	g_BloodCastle.SearchUserDeleteQuestItem(iIndex);
; 20163: 
; 20164: 	// *> .    
; 20165: 	CHAR szTemp [256];
; 20166: #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 20167: 	wsprintf(szTemp, lMsg.Get(1171), btBridgeNumber+1);			// "  %d  ."
; 20168: #else
; 20169: 	wsprintf(szTemp, lMsg.Get(1171), iITEM_LEVEL);				// "  %d  ."
; 20170: #endif
; 20171: 	GCServerMsgStringSend(szTemp, iIndex, 1);
; 20172: 
; 20173: #ifdef BLOODCASTLE_EXTEND_20040314
; 20174: #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 20175: 	if (btBridgeNumber+1 == iITEM_LEVEL) {
; 20176: 		switch(iITEM_LEVEL) {
; 20177: 		case 1 :		// 1
; 20178: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_1);
; 20179: 			break;
; 20180: 		case 2 :		// 2
; 20181: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_2);
; 20182: 			break;
; 20183: 		case 3 :		// 3
; 20184: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_3);
; 20185: 			break;
; 20186: 		case 4 :		// 4
; 20187: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_4);
; 20188: 			break;
; 20189: 		case 5 :		// 5
; 20190: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_5);
; 20191: 			break;
; 20192: 		case 6 :		// 6
; 20193: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_6);
; 20194: 			break;
; 20195: 		case 7 :		// 7
; 20196: 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_7);
; 20197: 			break;
; 20198: 		}
; 20199: 	}
; 20200: 	else if (btBridgeNumber+1 == 7 && iITEM_LEVEL == 6) {
; 20201: 		// 7
; 20202: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_7);
; 20203: 	}
; 20204: #else
; 20205: 	switch(iITEM_LEVEL) {
; 20206: 	case 1 :		// 1
; 20207: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_1);
; 20208: 		break;
; 20209: 	case 2 :		// 2
; 20210: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_2);
; 20211: 		break;
; 20212: 	case 3 :		// 3
; 20213: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_3);
; 20214: 		break;
; 20215: 	case 4 :		// 4
; 20216: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_4);
; 20217: 		break;
; 20218: 	case 5 :		// 5
; 20219: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_5);
; 20220: 		break;
; 20221: 	case 6 :		// 6
; 20222: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_6);
; 20223: 		break;
; 20224: 	case 7 :		// 7
; 20225: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_7);
; 20226: 		break;
; 20227: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 8 
; 20228: 	case 8 :		// 8
; 20229: 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_8);
; 20230: 		break;
; 20231: #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 20232: 	}
; 20233: #endif
; 20234: #else
; 20235: 	gObjMoveGate(iIndex, GATE_BLOODCASTLE_1 + iITEM_LEVEL - 1);	//     
; 20236: #endif
; 20237: 
; 20238: #ifdef EXTEND_LOG_SYSTEM_06_20070308
; 20239: 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20240: 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%u),PCRoom:%d", 
; 20241: 	#else
; 20242: 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%d),PCRoom:%d", 
; 20243: 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20244: 		iITEM_LEVEL, 
; 20245: 		gObj[iIndex].AccountID,
; 20246: 		gObj[iIndex].Name,
; 20247: 		dwITEM_SERIAL,
; 20248: 		gObj[iIndex].m_bPCBangUser
; 20249: 		);
; 20250: #else
; 20251: 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20252: 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%u)", 
; 20253: 	#else
; 20254: 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%d)", 
; 20255: 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 20256: 		iITEM_LEVEL, 
; 20257: 		gObj[iIndex].AccountID,
; 20258: 		gObj[iIndex].Name,
; 20259: 		dwITEM_SERIAL
; 20260: 		);
; 20261: #endif // EXTEND_LOG_SYSTEM_06_20070308
; 20262: 
; 20263: #endif
; 20264: 
; 20265: }

  005ed	5f		 pop	 edi
  005ee	5e		 pop	 esi
  005ef	5b		 pop	 ebx
  005f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f3	33 cd		 xor	 ecx, ebp
  005f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005fa	8b e5		 mov	 esp, ebp
  005fc	5d		 pop	 ebp
  005fd	c3		 ret	 0
  005fe	66 90		 npad	 2
$LN39@CGRequestE:
  00600	00 00 00 00	 DD	 $LN23@CGRequestE
  00604	00 00 00 00	 DD	 $LN24@CGRequestE
  00608	00 00 00 00	 DD	 $LN25@CGRequestE
  0060c	00 00 00 00	 DD	 $LN26@CGRequestE
  00610	00 00 00 00	 DD	 $LN27@CGRequestE
  00614	00 00 00 00	 DD	 $LN28@CGRequestE
  00618	00 00 00 00	 DD	 $LN29@CGRequestE
?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ENDP ; CGRequestEnterBloodCastle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 6
_lpObj$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z PROC		; CGSetQuestState, COMDAT

; 19507: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19508: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 19509: 
; 19510: 	PMSG_SETQUEST_RESULT pMsg;
; 19511: 	PHeadSetB((LPBYTE)&pMsg, 0xA2, sizeof(pMsg));

  00019	6a 06		 push	 6
  0001b	68 a2 00 00 00	 push	 162			; 000000a2H
  00020	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19512: 
; 19513: 	pMsg.QuestIndex = lpMsg->QuestIndex;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002f	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00032	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 19514: 	//  
; 19515: 	pMsg.Result = g_QuestInfo.SetQuestState(lpObj, lpMsg->QuestIndex, lpMsg->State);

  00035	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00038	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0003c	51		 push	 ecx
  0003d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00040	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00044	50		 push	 eax
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00048	51		 push	 ecx
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0004e	e8 00 00 00 00	 call	 ?SetQuestState@CQuestInfo@@QAEEPAVOBJECTSTRUCT@@HH@Z ; CQuestInfo::SetQuestState
  00053	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19516: 	pMsg.State = g_QuestInfo.GetQuestStateBYTE(lpObj, lpMsg->QuestIndex);

  00056	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00059	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0005d	51		 push	 ecx
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00061	52		 push	 edx
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00067	e8 00 00 00 00	 call	 ?GetQuestStateBYTE@CQuestInfo@@QAEEPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestStateBYTE
  0006c	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 19517: 	
; 19518: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0006f	6a 06		 push	 6
  00071	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00074	50		 push	 eax
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19519: }

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z ENDP		; CGSetQuestState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z PROC ; GCPacketCheckSumRecv, COMDAT

; 20860: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20861: 	gPacketCheckSum.AddCheckSum(aIndex, aRecv->funcindex, aRecv->CheckSum);

  00009	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00013	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00017	50		 push	 eax
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001b	51		 push	 ecx
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gPacketCheckSum@@3VCPacketCheckSum@@A ; gPacketCheckSum
  00021	e8 00 00 00 00	 call	 ?AddCheckSum@CPacketCheckSum@@QAEXHHK@Z ; CPacketCheckSum::AddCheckSum

; 20862: }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ENDP ; GCPacketCheckSumRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z
_TEXT	SEGMENT
_PingTime$ = -4						; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z PROC	; GCPingSendRecv, COMDAT

; 19141: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19142: 	int PingTime = GetTickCount() - gObj[aIndex].iPingTime;

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000f	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00016	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001c	2b 44 0a 50	 sub	 eax, DWORD PTR [edx+ecx+80]
  00020	89 45 fc	 mov	 DWORD PTR _PingTime$[ebp], eax

; 19143: 	LogAdd("[%s][%s] Ping = %d ms", gObj[aIndex].AccountID, gObj[aIndex].Name, PingTime);	

  00023	8b 45 fc	 mov	 eax, DWORD PTR _PingTime$[ebp]
  00026	50		 push	 eax
  00027	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0002e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00038	50		 push	 eax
  00039	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00040	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00046	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMIMJBJK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Ping?5?$DN?5?$CFd?5ms@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 10	 add	 esp, 16			; 00000010H

; 19144: }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z ENDP	; GCPingSendRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z
_TEXT	SEGMENT
tv69 = -100						; size = 4
_szJoomin$1 = -32					; size = 11
_szJoomin$2 = -20					; size = 11
_pw$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z PROC ; GCWarehouseRecivePassword, COMDAT

; 13274: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 13275: 	int pw;
; 13276: 
; 13277: 	if( bCanWarehouseLock == FALSE ) return;

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 0 ; bCanWarehouseLock
  0001a	75 05		 jne	 SHORT $LN4@GCWarehous
  0001c	e9 09 02 00 00	 jmp	 $LN1@GCWarehous
$LN4@GCWarehous:

; 13278: 
; 13279: 	pw = lpMsg->Pass;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00024	0f bf 48 04	 movsx	 ecx, WORD PTR [eax+4]
  00028	89 4d f8	 mov	 DWORD PTR _pw$[ebp], ecx

; 13280: 	
; 13281: 	switch( lpMsg->Type )

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002e	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00031	88 4d 9c	 mov	 BYTE PTR tv69[ebp], cl
  00034	80 7d 9c 00	 cmp	 BYTE PTR tv69[ebp], 0
  00038	74 15		 je	 SHORT $LN5@GCWarehous
  0003a	80 7d 9c 01	 cmp	 BYTE PTR tv69[ebp], 1
  0003e	74 7a		 je	 SHORT $LN9@GCWarehous
  00040	80 7d 9c 02	 cmp	 BYTE PTR tv69[ebp], 2
  00044	0f 84 47 01 00
	00		 je	 $LN14@GCWarehous
  0004a	e9 db 01 00 00	 jmp	 $LN1@GCWarehous
$LN5@GCWarehous:

; 13282: 	{
; 13283: 	case 0 : //  
; 13284: 		if( gObj[aIndex].WarehouseLock )

  0004f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005c	0f b6 94 01 a0
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3232]
  00064	85 d2		 test	 edx, edx
  00066	74 4d		 je	 SHORT $LN6@GCWarehous

; 13285: 		{
; 13286: 			if( gObj[aIndex].WarehousePW == pw )

  00068	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00075	0f bf 94 01 9e
	0c 00 00	 movsx	 edx, WORD PTR [ecx+eax+3230]
  0007d	3b 55 f8	 cmp	 edx, DWORD PTR _pw$[ebp]
  00080	75 25		 jne	 SHORT $LN7@GCWarehous

; 13287: 			{
; 13288: 				gObj[aIndex].WarehouseLock = 0;

  00082	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008f	c6 84 01 a0 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3232], 0

; 13289: 				//GCWarehouseStateSend(aIndex, gObj[aIndex].WarehouseLock);
; 13290: 				GCWarehouseStateSend(aIndex, 12);

  00097	6a 0c		 push	 12			; 0000000cH
  00099	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  000a2	83 c4 08	 add	 esp, 8

; 13291: 			}

  000a5	eb 0e		 jmp	 SHORT $LN6@GCWarehous
$LN7@GCWarehous:

; 13292: 			else 
; 13293: 			{
; 13294: 				GCWarehouseStateSend(aIndex, 10);

  000a7	6a 0a		 push	 10			; 0000000aH
  000a9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  000b2	83 c4 08	 add	 esp, 8
$LN6@GCWarehous:

; 13295: 			}
; 13296: 		}
; 13297: 		break;

  000b5	e9 70 01 00 00	 jmp	 $LN1@GCWarehous
$LN9@GCWarehous:

; 13298: 	case 1 : // 
; 13299: 		if( gObj[aIndex].WarehouseLock == 0 || gObj[aIndex].WarehouseLock == 255 )

  000ba	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	0f b6 94 01 a0
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3232]
  000cf	85 d2		 test	 edx, edx
  000d1	74 21		 je	 SHORT $LN12@GCWarehous
  000d3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e0	0f b6 94 01 a0
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3232]
  000e8	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  000ee	0f 85 8a 00 00
	00		 jne	 $LN10@GCWarehous
$LN12@GCWarehous:

; 13300: 		{
; 13301: #ifndef FOR_CHINA		
; 13302: #ifdef UPDATE_USERPASSWORD_LENGTH_20090424
; 13303: 			char szJoomin[MAX_JOOMINNUMBER_LENGTH+1];
; 13304: 			
; 13305: 			memset( szJoomin, 0 , MAX_JOOMINNUMBER_LENGTH+1);
; 13306: 			memcpy( szJoomin, lpMsg->LastJoominNumber, MAX_JOOMINNUMBER_LENGTH);
; 13307: #else
; 13308: 			char szJoomin[11];
; 13309: 						
; 13310: 			memset( szJoomin, 0 , 11);

  000f4	6a 0b		 push	 11			; 0000000bH
  000f6	6a 00		 push	 0
  000f8	8d 45 ec	 lea	 eax, DWORD PTR _szJoomin$2[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _memset
  00101	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13311: 			memcpy( szJoomin, lpMsg->LastJoominNumber, 10);

  00104	6a 0a		 push	 10			; 0000000aH
  00106	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00109	83 c0 06	 add	 eax, 6
  0010c	50		 push	 eax
  0010d	8d 4d ec	 lea	 ecx, DWORD PTR _szJoomin$2[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 _memcpy
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13312: #endif	// UPDATE_USERPASSWORD_LENGTH_20090424
; 13313: 
; 13314: #ifdef FOR_TAIWAN
; 13315: 			if( gObjTaiwanJoominCheck(aIndex, szJoomin) == FALSE )
; 13316: #else			
; 13317: 			if( gObjJoominCheck(aIndex, szJoomin) == FALSE )

  00119	8d 45 ec	 lea	 eax, DWORD PTR _szJoomin$2[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00126	83 c4 08	 add	 esp, 8
  00129	85 c0		 test	 eax, eax
  0012b	75 13		 jne	 SHORT $LN13@GCWarehous

; 13318: #endif
; 13319: 			{
; 13320: 				GCWarehouseStateSend(aIndex, 13);

  0012d	6a 0d		 push	 13			; 0000000dH
  0012f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  00138	83 c4 08	 add	 esp, 8

; 13321: 				return;

  0013b	e9 ea 00 00 00	 jmp	 $LN1@GCWarehous
$LN13@GCWarehous:

; 13322: 			}
; 13323: #endif
; 13324: 			gObj[aIndex].WarehousePW   = pw;			

  00140	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014d	66 8b 55 f8	 mov	 dx, WORD PTR _pw$[ebp]
  00151	66 89 94 01 9e
	0c 00 00	 mov	 WORD PTR [ecx+eax+3230], dx

; 13325: 			gObj[aIndex].WarehouseLock = 0;

  00159	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00166	c6 84 01 a0 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3232], 0

; 13326: 			GCWarehouseStateSend(aIndex, 12);

  0016e	6a 0c		 push	 12			; 0000000cH
  00170	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  00179	83 c4 08	 add	 esp, 8

; 13327: 		}

  0017c	eb 0e		 jmp	 SHORT $LN11@GCWarehous
$LN10@GCWarehous:

; 13328: 		else
; 13329: 		{
; 13330: 			GCWarehouseStateSend(aIndex, 11);

  0017e	6a 0b		 push	 11			; 0000000bH
  00180	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  00189	83 c4 08	 add	 esp, 8
$LN11@GCWarehous:

; 13331: 		}
; 13332: 		break;

  0018c	e9 99 00 00 00	 jmp	 $LN1@GCWarehous
$LN14@GCWarehous:

; 13333: 	case 2 : // (  )
; 13334: 		{
; 13335: #ifdef FOR_CHINA
; 13336: 			if( gObj[aIndex].WarehousePW == pw )
; 13337: 			{
; 13338: 				gObj[aIndex].WarehouseLock = 0;
; 13339: 				gObj[aIndex].WarehousePW   = 0;
; 13340: 				gObj[aIndex].WarehouseUnfailLock = 0;
; 13341: 				GCWarehouseStateSend(aIndex, gObj[aIndex].WarehouseLock);
; 13342: 			}
; 13343: 			else
; 13344: 			{
; 13345: 				gObj[aIndex].WarehouseUnfailLock++;
; 13346: 				if( gObj[aIndex].WarehouseUnfailLock > 4 )
; 13347: 				{	//    
; 13348: 					CloseClient(aIndex);
; 13349: 					return;
; 13350: 				}
; 13351: 
; 13352: 				GCWarehouseStateSend(aIndex, 10);
; 13353: 			}
; 13354: #else
; 13355: 
; 13356: #ifdef UPDATE_USERPASSWORD_LENGTH_20090424
; 13357: 			char szJoomin[MAX_JOOMINNUMBER_LENGTH+1];						
; 13358: 			memset( szJoomin, 0 , MAX_JOOMINNUMBER_LENGTH+1);
; 13359: 			memcpy( szJoomin, lpMsg->LastJoominNumber, MAX_JOOMINNUMBER_LENGTH);
; 13360: #else	// UPDATE_USERPASSWORD_LENGTH_20090424
; 13361: 			char szJoomin[11];						
; 13362: 			memset( szJoomin, 0 , 11);

  00191	6a 0b		 push	 11			; 0000000bH
  00193	6a 00		 push	 0
  00195	8d 45 e0	 lea	 eax, DWORD PTR _szJoomin$1[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _memset
  0019e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13363: 			memcpy( szJoomin, lpMsg->LastJoominNumber, 10);

  001a1	6a 0a		 push	 10			; 0000000aH
  001a3	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001a6	83 c0 06	 add	 eax, 6
  001a9	50		 push	 eax
  001aa	8d 4d e0	 lea	 ecx, DWORD PTR _szJoomin$1[ebp]
  001ad	51		 push	 ecx
  001ae	e8 00 00 00 00	 call	 _memcpy
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13364: #endif	// UPDATE_USERPASSWORD_LENGTH_20090424
; 13365: 			
; 13366: 	#ifdef FOR_TAIWAN
; 13367: 			if( gObjTaiwanJoominCheck(aIndex, szJoomin) == FALSE )
; 13368: 	#else			
; 13369: 			if( gObjJoominCheck(aIndex, szJoomin) == FALSE )

  001b6	8d 45 e0	 lea	 eax, DWORD PTR _szJoomin$1[ebp]
  001b9	50		 push	 eax
  001ba	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001bd	51		 push	 ecx
  001be	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  001c3	83 c4 08	 add	 esp, 8
  001c6	85 c0		 test	 eax, eax
  001c8	75 12		 jne	 SHORT $LN15@GCWarehous

; 13370: 	#endif
; 13371: 			{
; 13372: 				GCWarehouseStateSend(aIndex, 13);

  001ca	6a 0d		 push	 13			; 0000000dH
  001cc	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  001d5	83 c4 08	 add	 esp, 8

; 13373: 				return;

  001d8	eb 50		 jmp	 SHORT $LN1@GCWarehous

; 13374: 			}

  001da	eb 4e		 jmp	 SHORT $LN1@GCWarehous
$LN15@GCWarehous:

; 13375: 			else
; 13376: 			{
; 13377: 				gObj[aIndex].WarehouseLock = 0;

  001dc	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e9	c6 84 01 a0 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3232], 0

; 13378: 				gObj[aIndex].WarehousePW   = 0;

  001f1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001f8	33 c9		 xor	 ecx, ecx
  001fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00200	66 89 8c 02 9e
	0c 00 00	 mov	 WORD PTR [edx+eax+3230], cx

; 13379: 				GCWarehouseStateSend(aIndex, gObj[aIndex].WarehouseLock);

  00208	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0020f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00215	0f b6 94 01 a0
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3232]
  0021d	52		 push	 edx
  0021e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  00227	83 c4 08	 add	 esp, 8
$LN1@GCWarehous:

; 13380: 			}
; 13381: #endif			
; 13382: 		}		
; 13383: 		break;
; 13384: 	}
; 13385: }

  0022a	5f		 pop	 edi
  0022b	5e		 pop	 esi
  0022c	5b		 pop	 ebx
  0022d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00230	33 cd		 xor	 ecx, ebp
  00232	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	c3		 ret	 0
?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ENDP ; GCWarehouseRecivePassword
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z
_TEXT	SEGMENT
tv179 = -104						; size = 4
tv154 = -104						; size = 4
tv180 = -100						; size = 4
tv155 = -100						; size = 4
_movegateindex$ = -29					; size = 1
_bEnterCheck$ = -28					; size = 4
_level$ = -24						; size = 4
_ItemLevel$ = -20					; size = 4
_sitem$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_pResult$ = -8						; size = 4
_cInvitationItemPos$ = -2				; size = 1
_cSquareNumber$ = -1					; size = 1
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z PROC ; GCReqmoveDevilSquare, COMDAT

; 18576: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18577: 	if( aIndex < 0  || aIndex > MAX_OBJECT-1 ) 

  00009	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@GCReqmoveD
  0000f	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 21		 jle	 SHORT $LN2@GCReqmoveD
$LN3@GCReqmoveD:

; 18578: 	{
; 18579: 		LogAdd("return %s %d", __FILE__, __LINE__);

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z@4JA
  0001d	83 c0 03	 add	 eax, 3
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18580: 		return;

  00034	e9 ca 06 00 00	 jmp	 $LN1@GCReqmoveD
$LN2@GCReqmoveD:

; 18581: 	}	
; 18582: 
; 18583: 	BYTE cSquareNumber = lpMsg->SquareNumber;

  00039	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0003c	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  0003f	88 4d ff	 mov	 BYTE PTR _cSquareNumber$[ebp], cl

; 18584: 	BYTE cInvitationItemPos = lpMsg->InvitationItemPos-12;

  00042	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00045	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00049	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  0004c	88 4d fe	 mov	 BYTE PTR _cInvitationItemPos$[ebp], cl

; 18585: 
; 18586: #ifdef BLOOD_DEVILSQUARE_TRADE_BUG_FIX
; 18587: 	// *> .     .
; 18588: 	if (gObj[aIndex].m_IfState.use != 0 && gObj[aIndex].m_IfState.type != I_ETCWINDOW ) {

  0004f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005c	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00063	80 e2 03	 and	 dl, 3
  00066	0f b6 c2	 movzx	 eax, dl
  00069	85 c0		 test	 eax, eax
  0006b	74 27		 je	 SHORT $LN4@GCReqmoveD
  0006d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007a	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00081	c0 ea 04	 shr	 dl, 4
  00084	80 e2 0f	 and	 dl, 15			; 0000000fH
  00087	0f b6 c2	 movzx	 eax, dl
  0008a	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0008d	74 05		 je	 SHORT $LN4@GCReqmoveD

; 18589: 		return;

  0008f	e9 6f 06 00 00	 jmp	 $LN1@GCReqmoveD
$LN4@GCReqmoveD:

; 18590: 	}
; 18591: #endif
; 18592: 
; 18593: 	PMSG_RESULT_MOVEDEVILSQUARE pResult;
; 18594: 	PHeadSetB((LPBYTE)&pResult, 0x90, sizeof(pResult));

  00094	6a 04		 push	 4
  00096	68 90 00 00 00	 push	 144			; 00000090H
  0009b	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18595: 	pResult.Result = 0;		

  000a7	c6 45 fb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 18596: 
; 18597: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  000ab	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b8	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 18598: 
; 18599: 	LogAddTD("[DevilSquare] [%s][%s] Request Move DevilSquare [%d][%d][%d]", 

  000bb	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  000bf	83 c0 01	 add	 eax, 1
  000c2	50		 push	 eax
  000c3	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c6	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  000cd	52		 push	 edx
  000ce	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000d8	51		 push	 ecx
  000d9	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000dc	83 c2 73	 add	 edx, 115		; 00000073H
  000df	52		 push	 edx
  000e0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e3	83 c0 68	 add	 eax, 104		; 00000068H
  000e6	50		 push	 eax
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5@
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f2	83 c4 18	 add	 esp, 24			; 00000018H

; 18600: 		   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 18601: 
; 18602: #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 18603: 	//     .
; 18604: #ifdef UPDATE_PK_SYSTEM_20070302	//     .
; 18605: 			BOOL	PKFlag = FALSE;
; 18606: 			if(lpObj->PartyNumber >= 0)	//  
; 18607: 			{
; 18608: 				if( gParty.GetPKPartyPenalty(lpObj->PartyNumber) >= PK_LEVEL_DEFAULT+2)
; 18609: 				{
; 18610: 					PKFlag = TRUE;
; 18611: 				}
; 18612: 			}
; 18613: 			else
; 18614: 			{
; 18615: 				if(lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+1)
; 18616: 				{
; 18617: 					PKFlag = TRUE;
; 18618: 				}
; 18619: 			}
; 18620: 			
; 18621: 			if(PKFlag == TRUE)
; 18622: #else	// UPDATE_PK_SYSTEM_20070302
; 18623: 	if( gObj[aIndex].m_PK_Level >= PK_LEVEL_DEFAULT + 1 )

  000f5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00102	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  0010a	83 fa 04	 cmp	 edx, 4
  0010d	7c 1e		 jl	 SHORT $LN5@GCReqmoveD

; 18624: #endif	// UPDATE_PK_SYSTEM_20070302
; 18625: 	{
; 18626: 		pResult.Result = 6;

  0010f	c6 45 fb 06	 mov	 BYTE PTR _pResult$[ebp+3], 6

; 18627: 		DataSend( aIndex, (LPBYTE)&pResult, pResult.h.size );

  00113	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00117	50		 push	 eax
  00118	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0011b	51		 push	 ecx
  0011c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18628: 		return;

  00128	e9 d6 05 00 00	 jmp	 $LN1@GCReqmoveD
$LN5@GCReqmoveD:

; 18629: 	}
; 18630: #endif
; 18631: 	
; 18632: 	if( !CHECK_LIMIT(cInvitationItemPos, MAX_INVENTORY) )

  0012d	0f b6 45 fe	 movzx	 eax, BYTE PTR _cInvitationItemPos$[ebp]
  00131	85 c0		 test	 eax, eax
  00133	7d 09		 jge	 SHORT $LN36@GCReqmoveD
  00135	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv155[ebp], 0
  0013c	eb 1f		 jmp	 SHORT $LN37@GCReqmoveD
$LN36@GCReqmoveD:
  0013e	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cInvitationItemPos$[ebp]
  00142	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  00145	7e 09		 jle	 SHORT $LN34@GCReqmoveD
  00147	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv154[ebp], 0
  0014e	eb 07		 jmp	 SHORT $LN35@GCReqmoveD
$LN34@GCReqmoveD:
  00150	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv154[ebp], 1
$LN35@GCReqmoveD:
  00157	8b 55 98	 mov	 edx, DWORD PTR tv154[ebp]
  0015a	89 55 9c	 mov	 DWORD PTR tv155[ebp], edx
$LN37@GCReqmoveD:
  0015d	83 7d 9c 00	 cmp	 DWORD PTR tv155[ebp], 0
  00161	75 58		 jne	 SHORT $LN6@GCReqmoveD

; 18633: 	{	//  
; 18634: 		pResult.Result = 1;

  00163	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 18635: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00167	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0016b	50		 push	 eax
  0016c	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0016f	51		 push	 ecx
  00170	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00173	52		 push	 edx
  00174	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18636: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", 

  0017c	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  00180	83 c0 01	 add	 eax, 1
  00183	50		 push	 eax
  00184	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00187	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  0018e	52		 push	 edx
  0018f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00192	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00199	51		 push	 ecx
  0019a	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0019d	83 c2 73	 add	 edx, 115		; 00000073H
  001a0	52		 push	 edx
  001a1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a4	83 c0 68	 add	 eax, 104		; 00000068H
  001a7	50		 push	 eax
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b3	83 c4 18	 add	 esp, 24			; 00000018H

; 18637: 			   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 18638: 		return;

  001b6	e9 48 05 00 00	 jmp	 $LN1@GCReqmoveD
$LN6@GCReqmoveD:

; 18639: 	}
; 18640: 
; 18641: 	if( !CHECK_LIMIT(cSquareNumber, MAX_DEVILSQUARE) )

  001bb	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  001bf	85 c0		 test	 eax, eax
  001c1	7d 09		 jge	 SHORT $LN40@GCReqmoveD
  001c3	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv180[ebp], 0
  001ca	eb 1f		 jmp	 SHORT $LN41@GCReqmoveD
$LN40@GCReqmoveD:
  001cc	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cSquareNumber$[ebp]
  001d0	83 f9 03	 cmp	 ecx, 3
  001d3	7e 09		 jle	 SHORT $LN38@GCReqmoveD
  001d5	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
  001dc	eb 07		 jmp	 SHORT $LN39@GCReqmoveD
$LN38@GCReqmoveD:
  001de	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv179[ebp], 1
$LN39@GCReqmoveD:
  001e5	8b 55 98	 mov	 edx, DWORD PTR tv179[ebp]
  001e8	89 55 9c	 mov	 DWORD PTR tv180[ebp], edx
$LN41@GCReqmoveD:
  001eb	83 7d 9c 00	 cmp	 DWORD PTR tv180[ebp], 0
  001ef	75 58		 jne	 SHORT $LN7@GCReqmoveD

; 18642: 	{	//   
; 18643: 		pResult.Result = 1;

  001f1	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 18644: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001f5	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001f9	50		 push	 eax
  001fa	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001fd	51		 push	 ecx
  001fe	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00201	52		 push	 edx
  00202	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00207	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18645: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", 

  0020a	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  0020e	83 c0 01	 add	 eax, 1
  00211	50		 push	 eax
  00212	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00215	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  0021c	52		 push	 edx
  0021d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00220	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00227	51		 push	 ecx
  00228	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0022b	83 c2 73	 add	 edx, 115		; 00000073H
  0022e	52		 push	 edx
  0022f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00232	83 c0 68	 add	 eax, 104		; 00000068H
  00235	50		 push	 eax
  00236	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00241	83 c4 18	 add	 esp, 24			; 00000018H

; 18646: 			   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 18647: 		return;

  00244	e9 ba 04 00 00	 jmp	 $LN1@GCReqmoveD
$LN7@GCReqmoveD:

; 18648: 	}
; 18649: 
; 18650: 	if( g_DevilSquare.GetState() != DevilSquare_OPEN )

  00249	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0024e	e8 00 00 00 00	 call	 ?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ; CDevilSquare::GetState
  00253	83 f8 01	 cmp	 eax, 1
  00256	74 58		 je	 SHORT $LN8@GCReqmoveD

; 18651: 	{	//      
; 18652: 		pResult.Result = 2;

  00258	c6 45 fb 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 18653: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0025c	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00260	50		 push	 eax
  00261	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00264	51		 push	 ecx
  00265	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00268	52		 push	 edx
  00269	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0026e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18654: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", 

  00271	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  00275	83 c0 01	 add	 eax, 1
  00278	50		 push	 eax
  00279	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0027c	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  00283	52		 push	 edx
  00284	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00287	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0028e	51		 push	 ecx
  0028f	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00292	83 c2 73	 add	 edx, 115		; 00000073H
  00295	52		 push	 edx
  00296	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00299	83 c0 68	 add	 eax, 104		; 00000068H
  0029c	50		 push	 eax
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002a8	83 c4 18	 add	 esp, 24			; 00000018H

; 18655: 			   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 18656: 		return;

  002ab	e9 53 04 00 00	 jmp	 $LN1@GCReqmoveD
$LN8@GCReqmoveD:

; 18657: 	}
; 18658: 
; 18659: 	if( g_DevilSquare.m_DevilSquareGround[cSquareNumber].GetObjCount() >= MAX_DEVILSQUARE_OBJCOUNT )

  002b0	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  002b4	69 c8 e0 03 00
	00		 imul	 ecx, eax, 992
  002ba	81 c1 30 00 00
	00		 add	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A+48
  002c0	e8 00 00 00 00	 call	 ?GetObjCount@CDevilSquareGround@@QAEJXZ ; CDevilSquareGround::GetObjCount
  002c5	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002c8	7c 58		 jl	 SHORT $LN9@GCReqmoveD

; 18660: 	{	//    
; 18661: 		pResult.Result = 5;

  002ca	c6 45 fb 05	 mov	 BYTE PTR _pResult$[ebp+3], 5

; 18662: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  002ce	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002d2	50		 push	 eax
  002d3	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  002d6	51		 push	 ecx
  002d7	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002da	52		 push	 edx
  002db	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18663: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", 

  002e3	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  002e7	83 c0 01	 add	 eax, 1
  002ea	50		 push	 eax
  002eb	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ee	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  002f5	52		 push	 edx
  002f6	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f9	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00300	51		 push	 ecx
  00301	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00304	83 c2 73	 add	 edx, 115		; 00000073H
  00307	52		 push	 edx
  00308	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030b	83 c0 68	 add	 eax, 104		; 00000068H
  0030e	50		 push	 eax
  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0031a	83 c4 18	 add	 esp, 24			; 00000018H

; 18664: 			   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 18665: 		return;

  0031d	e9 e1 03 00 00	 jmp	 $LN1@GCReqmoveD
$LN9@GCReqmoveD:

; 18666: 	}
; 18667: 	
; 18668: 	CItem* sitem = &lpObj->pInventory[cInvitationItemPos];		

  00322	0f b6 45 fe	 movzx	 eax, BYTE PTR _cInvitationItemPos$[ebp]
  00326	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0032c	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0032f	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00335	89 4d f0	 mov	 DWORD PTR _sitem$[ebp], ecx

; 18669: 
; 18670: 	if( sitem->m_Type != MAKE_ITEMNUM(14, 19)

  00338	8b 45 f0	 mov	 eax, DWORD PTR _sitem$[ebp]
  0033b	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0033f	6a 13		 push	 19			; 00000013H
  00341	6a 0e		 push	 14			; 0000000eH
  00343	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00348	83 c4 08	 add	 esp, 8
  0034b	3b f0		 cmp	 esi, eax
  0034d	74 58		 je	 SHORT $LN10@GCReqmoveD

; 18671: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18672: 		//    
; 18673: 		&& ( sitem->m_Type != MAKE_ITEMNUM( 13, 46 ) || sitem->m_Durability <= 0 )
; 18674: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18675: 		)
; 18676: 	{	//  
; 18677: 		pResult.Result = 1;

  0034f	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 18678: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00353	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00357	50		 push	 eax
  00358	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0035b	51		 push	 ecx
  0035c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0035f	52		 push	 edx
  00360	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00365	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18679: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]", 

  00368	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  0036c	83 c0 01	 add	 eax, 1
  0036f	50		 push	 eax
  00370	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00373	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  0037a	52		 push	 edx
  0037b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00385	51		 push	 ecx
  00386	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00389	83 c2 73	 add	 edx, 115		; 00000073H
  0038c	52		 push	 edx
  0038d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00390	83 c0 68	 add	 eax, 104		; 00000068H
  00393	50		 push	 eax
  00394	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
  00399	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0039f	83 c4 18	 add	 esp, 24			; 00000018H

; 18680: 			   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 18681: 		return;

  003a2	e9 5c 03 00 00	 jmp	 $LN1@GCReqmoveD
$LN10@GCReqmoveD:

; 18682: 	}
; 18683: 
; 18684: #ifdef DEVILSQUARE_CHECK_ENTERCOUNT_20040715
; 18685: 	//       ->     .
; 18686: 	BOOL bRET_VAL = EGReqDevilSquareEnterCountCheck	(aIndex, cInvitationItemPos, sitem->m_Level, lpMsg->SquareNumber);
; 18687: 	if (bRET_VAL == TRUE)		//    .
; 18688: 		return;
; 18689: 
; 18690: 	//     .
; 18691: #endif
; 18692: 
; 18693: 	int	ItemLevel = sitem->m_Level;

  003a7	8b 45 f0	 mov	 eax, DWORD PTR _sitem$[ebp]
  003aa	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  003ae	89 4d ec	 mov	 DWORD PTR _ItemLevel$[ebp], ecx

; 18694: 
; 18695: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18696: 	if( sitem->m_Type == MAKE_ITEMNUM( 13, 46 ) )
; 18697: 	{
; 18698: 		ItemLevel = 10;
; 18699: 	}
; 18700: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18701: 
; 18702: 	int level = lpObj->Level;

  003b1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b4	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  003bb	89 4d e8	 mov	 DWORD PTR _level$[ebp], ecx

; 18703: 
; 18704: #ifdef DARKLORD_WORK
; 18705: 	if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )	

  003be	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003c8	83 f9 04	 cmp	 ecx, 4
  003cb	74 0f		 je	 SHORT $LN12@GCReqmoveD
  003cd	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003d7	83 f9 03	 cmp	 ecx, 3
  003da	75 11		 jne	 SHORT $LN11@GCReqmoveD
$LN12@GCReqmoveD:

; 18706: #else
; 18707: 	if( lpObj->Class == CLASS_MAGUMSA )	
; 18708: #endif
; 18709: 	{	//   3/2 
; 18710: 		level = (((level+1)/2)*3);

  003dc	8b 45 e8	 mov	 eax, DWORD PTR _level$[ebp]
  003df	83 c0 01	 add	 eax, 1
  003e2	99		 cdq
  003e3	2b c2		 sub	 eax, edx
  003e5	d1 f8		 sar	 eax, 1
  003e7	6b c0 03	 imul	 eax, eax, 3
  003ea	89 45 e8	 mov	 DWORD PTR _level$[ebp], eax
$LN11@GCReqmoveD:

; 18711: 	}	
; 18712: 
; 18713: 	if( ItemLevel != 0 )

  003ed	83 7d ec 00	 cmp	 DWORD PTR _ItemLevel$[ebp], 0
  003f1	74 68		 je	 SHORT $LN13@GCReqmoveD

; 18714: 	{
; 18715: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18716: 		if( ItemLevel != 10 )		//   
; 18717: 		{
; 18718: 			if( ItemLevel != cSquareNumber+1 )
; 18719: 			{	//        
; 18720: 				pResult.Result = 1;
; 18721: 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 18722: 				LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Invitation LevelError [%d][%d][%d][%d]", 
; 18723: 					   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1, ItemLevel);
; 18724: 				return;
; 18725: 			}
; 18726: 		}
; 18727: #else
; 18728: 		if( ItemLevel != cSquareNumber+1 )

  003f3	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  003f7	83 c0 01	 add	 eax, 1
  003fa	39 45 ec	 cmp	 DWORD PTR _ItemLevel$[ebp], eax
  003fd	74 5c		 je	 SHORT $LN13@GCReqmoveD

; 18729: 		{	//        
; 18730: 			pResult.Result = 1;

  003ff	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 18731: 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00403	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00407	50		 push	 eax
  00408	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0040b	51		 push	 ecx
  0040c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0040f	52		 push	 edx
  00410	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00415	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18732: 			LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Invitation LevelError [%d][%d][%d][%d]", 

  00418	8b 45 ec	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  0041b	50		 push	 eax
  0041c	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cSquareNumber$[ebp]
  00420	83 c1 01	 add	 ecx, 1
  00423	51		 push	 ecx
  00424	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00427	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  0042e	50		 push	 eax
  0042f	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00432	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  00439	52		 push	 edx
  0043a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0043d	83 c0 73	 add	 eax, 115		; 00000073H
  00440	50		 push	 eax
  00441	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00444	83 c1 68	 add	 ecx, 104		; 00000068H
  00447	51		 push	 ecx
  00448	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
  0044d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00453	83 c4 1c	 add	 esp, 28			; 0000001cH

; 18733: 				   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1, ItemLevel);
; 18734: 			return;

  00456	e9 a8 02 00 00	 jmp	 $LN1@GCReqmoveD
$LN13@GCReqmoveD:

; 18735: 		}
; 18736: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18737: 	}
; 18738: 
; 18739: 	BOOL bEnterCheck = 0;	// 0  1       

  0045b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bEnterCheck$[ebp], 0

; 18740: 							// 2      
; 18741: 
; 18742: #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010
; 18743: 	INT movegateindex = 61;
; 18744: #else
; 18745: 	BYTE movegateindex = 61;

  00462	c6 45 e3 3d	 mov	 BYTE PTR _movegateindex$[ebp], 61 ; 0000003dH

; 18746: #endif
; 18747: 
; 18748: #ifdef DEVILSQUARE_EXTEND_20050221		//   
; 18749: 	INT iENTER_LEVEL = g_DevilSquare.GetUserLevelToEnter(aIndex, movegateindex);
; 18750: 	if (!CHECK_DEVILSQUARE_INDEX(iENTER_LEVEL)) {
; 18751: 		LogAddTD("[DevilSquare] [%s][%s] GetUserLevelToEnter() failed", 
; 18752: 			   lpObj->AccountID, 
; 18753: 			   lpObj->Name
; 18754: 			   );
; 18755: 		return;
; 18756: 	}
; 18757: 
; 18758: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18759: 	if( ItemLevel == 10 )			//      
; 18760: 	{
; 18761: 		//     .
; 18762: 		cSquareNumber = iENTER_LEVEL;
; 18763: 	}
; 18764: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18765: 
; 18766: 	if (cSquareNumber != iENTER_LEVEL) {
; 18767: 		if (cSquareNumber > iENTER_LEVEL) {
; 18768: 			//     
; 18769: 			bEnterCheck	= 2;
; 18770: 		}
; 18771: 		else {
; 18772: 			//     
; 18773: 			bEnterCheck	= 1;
; 18774: 		}
; 18775: 	}
; 18776: #else
; 18777: 	if( cSquareNumber == 0 )

  00466	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  0046a	85 c0		 test	 eax, eax
  0046c	75 20		 jne	 SHORT $LN15@GCReqmoveD

; 18778: 	{	// 1
; 18779: 		if( level >= 100 )

  0046e	83 7d e8 64	 cmp	 DWORD PTR _level$[ebp], 100 ; 00000064H
  00472	7c 07		 jl	 SHORT $LN17@GCReqmoveD

; 18780: 		{
; 18781: 			bEnterCheck = 1;

  00474	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bEnterCheck$[ebp], 1
$LN17@GCReqmoveD:

; 18782: 		}
; 18783: 
; 18784: 		if( level < 10 )

  0047b	83 7d e8 0a	 cmp	 DWORD PTR _level$[ebp], 10 ; 0000000aH
  0047f	7d 07		 jge	 SHORT $LN18@GCReqmoveD

; 18785: 		{
; 18786: 			bEnterCheck = 2;

  00481	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _bEnterCheck$[ebp], 2
$LN18@GCReqmoveD:

; 18787: 		}
; 18788: 		movegateindex = 58;

  00488	c6 45 e3 3a	 mov	 BYTE PTR _movegateindex$[ebp], 58 ; 0000003aH

; 18789: 	}

  0048c	eb 6f		 jmp	 SHORT $LN16@GCReqmoveD
$LN15@GCReqmoveD:

; 18790: 	else if( cSquareNumber == 1 )

  0048e	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  00492	83 f8 01	 cmp	 eax, 1
  00495	75 25		 jne	 SHORT $LN19@GCReqmoveD

; 18791: 	{	// 2
; 18792: 		if( level >= 180 )

  00497	81 7d e8 b4 00
	00 00		 cmp	 DWORD PTR _level$[ebp], 180 ; 000000b4H
  0049e	7c 09		 jl	 SHORT $LN21@GCReqmoveD

; 18793: 		{
; 18794: 			bEnterCheck = 1;

  004a0	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bEnterCheck$[ebp], 1

; 18795: 		}

  004a7	eb 0d		 jmp	 SHORT $LN22@GCReqmoveD
$LN21@GCReqmoveD:

; 18796: 		else if( level < 100 )

  004a9	83 7d e8 64	 cmp	 DWORD PTR _level$[ebp], 100 ; 00000064H
  004ad	7d 07		 jge	 SHORT $LN22@GCReqmoveD

; 18797: 		{
; 18798: 			bEnterCheck = 2;

  004af	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _bEnterCheck$[ebp], 2
$LN22@GCReqmoveD:

; 18799: 		}
; 18800: 		movegateindex = 59;

  004b6	c6 45 e3 3b	 mov	 BYTE PTR _movegateindex$[ebp], 59 ; 0000003bH

; 18801: 	}

  004ba	eb 41		 jmp	 SHORT $LN16@GCReqmoveD
$LN19@GCReqmoveD:

; 18802: 	else if( cSquareNumber == 2 )

  004bc	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  004c0	83 f8 02	 cmp	 eax, 2
  004c3	75 28		 jne	 SHORT $LN24@GCReqmoveD

; 18803: 	{	// 3
; 18804: 		if( level >= 250 )

  004c5	81 7d e8 fa 00
	00 00		 cmp	 DWORD PTR _level$[ebp], 250 ; 000000faH
  004cc	7c 09		 jl	 SHORT $LN26@GCReqmoveD

; 18805: 		{
; 18806: 			bEnterCheck = 1;

  004ce	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bEnterCheck$[ebp], 1

; 18807: 		}

  004d5	eb 10		 jmp	 SHORT $LN27@GCReqmoveD
$LN26@GCReqmoveD:

; 18808: 		else if( level < 180 )

  004d7	81 7d e8 b4 00
	00 00		 cmp	 DWORD PTR _level$[ebp], 180 ; 000000b4H
  004de	7d 07		 jge	 SHORT $LN27@GCReqmoveD

; 18809: 		{
; 18810: 			bEnterCheck = 2;

  004e0	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _bEnterCheck$[ebp], 2
$LN27@GCReqmoveD:

; 18811: 		}
; 18812: 		movegateindex = 60;

  004e7	c6 45 e3 3c	 mov	 BYTE PTR _movegateindex$[ebp], 60 ; 0000003cH

; 18813: 	}

  004eb	eb 10		 jmp	 SHORT $LN16@GCReqmoveD
$LN24@GCReqmoveD:

; 18814: 	else
; 18815: 	{		
; 18816: 		if( level < 250 )

  004ed	81 7d e8 fa 00
	00 00		 cmp	 DWORD PTR _level$[ebp], 250 ; 000000faH
  004f4	7d 07		 jge	 SHORT $LN16@GCReqmoveD

; 18817: 		{	// 250 ..    
; 18818: 			bEnterCheck = 2;

  004f6	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR _bEnterCheck$[ebp], 2
$LN16@GCReqmoveD:

; 18819: 		}
; 18820: 	}
; 18821: #endif
; 18822: 	
; 18823: 	if( bEnterCheck == 1)

  004fd	83 7d e4 01	 cmp	 DWORD PTR _bEnterCheck$[ebp], 1
  00501	75 5b		 jne	 SHORT $LN30@GCReqmoveD

; 18824: 	{
; 18825: 		pResult.Result = 3;

  00503	c6 45 fb 03	 mov	 BYTE PTR _pResult$[ebp+3], 3

; 18826: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00507	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0050b	50		 push	 eax
  0050c	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0050f	51		 push	 ecx
  00510	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00513	52		 push	 edx
  00514	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00519	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18827: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]", 

  0051c	8b 45 ec	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  0051f	50		 push	 eax
  00520	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cSquareNumber$[ebp]
  00524	51		 push	 ecx
  00525	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00528	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  0052f	50		 push	 eax
  00530	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00533	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  0053a	52		 push	 edx
  0053b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053e	83 c0 73	 add	 eax, 115		; 00000073H
  00541	50		 push	 eax
  00542	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00545	83 c1 68	 add	 ecx, 104		; 00000068H
  00548	51		 push	 ecx
  00549	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
  0054e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00554	83 c4 1c	 add	 esp, 28			; 0000001cH

; 18828: 			   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);
; 18829: 		return;

  00557	e9 a7 01 00 00	 jmp	 $LN1@GCReqmoveD

; 18830: 	}

  0055c	eb 5f		 jmp	 SHORT $LN31@GCReqmoveD
$LN30@GCReqmoveD:

; 18831: 	else if( bEnterCheck == 2)

  0055e	83 7d e4 02	 cmp	 DWORD PTR _bEnterCheck$[ebp], 2
  00562	75 59		 jne	 SHORT $LN31@GCReqmoveD

; 18832: 	{
; 18833: 		pResult.Result = 4;

  00564	c6 45 fb 04	 mov	 BYTE PTR _pResult$[ebp+3], 4

; 18834: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00568	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0056c	50		 push	 eax
  0056d	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00570	51		 push	 ecx
  00571	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00574	52		 push	 edx
  00575	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0057a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18835: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]", 

  0057d	8b 45 ec	 mov	 eax, DWORD PTR _ItemLevel$[ebp]
  00580	50		 push	 eax
  00581	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cSquareNumber$[ebp]
  00585	51		 push	 ecx
  00586	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00589	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  00590	50		 push	 eax
  00591	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00594	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  0059b	52		 push	 edx
  0059c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0059f	83 c0 73	 add	 eax, 115		; 00000073H
  005a2	50		 push	 eax
  005a3	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005a6	83 c1 68	 add	 ecx, 104		; 00000068H
  005a9	51		 push	 ecx
  005aa	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
  005af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005b5	83 c4 1c	 add	 esp, 28			; 0000001cH

; 18836: 			   lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);
; 18837: 		return;

  005b8	e9 46 01 00 00	 jmp	 $LN1@GCReqmoveD
$LN31@GCReqmoveD:

; 18838: 	}
; 18839: 
; 18840: #ifdef AUTH_GAMESERVER_CHECKKEY
; 18841: 	if( szAuthKey[6] != AUTH_CHECK_06 )
; 18842: 		DestroyGIocp();
; 18843: #endif
; 18844: 
; 18845: #ifdef EXTEND_LOG_SYSTEM_06_20070308
; 18846: 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 18847: 	LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] RemoveItem[%s][%d][%d][%u], PCRoom:%d", 
; 18848: 	#else
; 18849: 	LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] RemoveItem[%s][%d][%d][%d], PCRoom:%d", 
; 18850: 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 18851: 			lpObj->AccountID, lpObj->Name, lpObj->Level, cSquareNumber,
; 18852: 			lpObj->pInventory[cInvitationItemPos].GetName(), cInvitationItemPos, ItemLevel, lpObj->pInventory[cInvitationItemPos].m_Number,
; 18853: 			lpObj->m_bPCBangUser);
; 18854: #else
; 18855: 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 18856: 	LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] RemoveItem[%s][%d][%d][%u]", 
; 18857: 	#else
; 18858: 	LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] RemoveItem[%s][%d][%d][%d]", 

  005bd	0f b6 45 fe	 movzx	 eax, BYTE PTR _cInvitationItemPos$[ebp]
  005c1	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  005c7	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005ca	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  005d0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  005d3	51		 push	 ecx
  005d4	8b 55 ec	 mov	 edx, DWORD PTR _ItemLevel$[ebp]
  005d7	52		 push	 edx
  005d8	0f b6 45 fe	 movzx	 eax, BYTE PTR _cInvitationItemPos$[ebp]
  005dc	50		 push	 eax
  005dd	0f b6 4d fe	 movzx	 ecx, BYTE PTR _cInvitationItemPos$[ebp]
  005e1	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  005e7	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005ea	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  005f0	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  005f5	50		 push	 eax
  005f6	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  005fa	50		 push	 eax
  005fb	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005fe	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  00605	52		 push	 edx
  00606	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00609	83 c0 73	 add	 eax, 115		; 00000073H
  0060c	50		 push	 eax
  0060d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00610	83 c1 68	 add	 ecx, 104		; 00000068H
  00613	51		 push	 ecx
  00614	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Dev@
  00619	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0061f	83 c4 24	 add	 esp, 36			; 00000024H

; 18859: 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 18860: 			lpObj->AccountID, lpObj->Name, lpObj->Level, cSquareNumber,
; 18861: 			lpObj->pInventory[cInvitationItemPos].GetName(), cInvitationItemPos, ItemLevel, lpObj->pInventory[cInvitationItemPos].m_Number);
; 18862: #endif // EXTEND_LOG_SYSTEM_06_20070308
; 18863: 	
; 18864: 	// 
; 18865: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18866: 	if( sitem->m_Type == MAKE_ITEMNUM( 14, 19 )
; 18867: 		//    
; 18868: 		|| ( sitem->m_Type == MAKE_ITEMNUM( 13, 46 ) && sitem->m_Durability == 1 )
; 18869: 	  )
; 18870: 	{
; 18871: 		gObjInventoryDeleteItem(aIndex, cInvitationItemPos);
; 18872: 		GCInventoryItemDeleteSend(aIndex, cInvitationItemPos, 1);
; 18873: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	
; 18874: 	}
; 18875: 	else if( sitem->m_Type == MAKE_ITEMNUM( 13, 46 ) && sitem->m_Durability > 1 )
; 18876: 	{
; 18877: 		sitem->m_Durability--;
; 18878: 
; 18879: 		GCItemDurSend2( lpObj->m_Index, cInvitationItemPos, sitem->m_Durability, 0 );
; 18880: 	}
; 18881: #else
; 18882: 	gObjInventoryDeleteItem(aIndex, cInvitationItemPos);

  00622	0f b6 45 fe	 movzx	 eax, BYTE PTR _cInvitationItemPos$[ebp]
  00626	50		 push	 eax
  00627	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0062a	51		 push	 ecx
  0062b	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00630	83 c4 08	 add	 esp, 8

; 18883: 	GCInventoryItemDeleteSend(aIndex, cInvitationItemPos, 1);

  00633	6a 01		 push	 1
  00635	0f b6 45 fe	 movzx	 eax, BYTE PTR _cInvitationItemPos$[ebp]
  00639	50		 push	 eax
  0063a	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0063d	51		 push	 ecx
  0063e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00643	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18884: 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	

  00646	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0064a	50		 push	 eax
  0064b	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0064e	51		 push	 ecx
  0064f	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00652	52		 push	 edx
  00653	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00658	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18885: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18886: 
; 18887: 	//    	
; 18888: 	lpObj->m_nEventExp = 0;

  0065b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0065e	c7 80 c8 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3272], 0

; 18889: 	lpObj->m_nEventScore = 0;

  00668	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0066b	c7 80 c4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3268], 0

; 18890: 	lpObj->m_nEventMoney = 0;

  00675	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00678	c7 80 cc 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3276], 0

; 18891: #ifdef DEVILSQUARE_EXTEND_20050221
; 18892: 	lpObj->m_bDevilSquareIndex = g_DevilSquare.GetDevilSquareIndex(movegateindex);
; 18893: #else
; 18894: 	lpObj->m_bDevilSquareIndex = movegateindex - 58;

  00682	0f b6 45 e3	 movzx	 eax, BYTE PTR _movegateindex$[ebp]
  00686	83 e8 3a	 sub	 eax, 58			; 0000003aH
  00689	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0068c	88 81 d0 0c 00
	00		 mov	 BYTE PTR [ecx+3280], al

; 18895: #endif
; 18896: 
; 18897: 	lpObj->m_bDevilSquareAuth = TRUE;

  00692	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00695	c6 80 d1 0c 00
	00 01		 mov	 BYTE PTR [eax+3281], 1

; 18898: 
; 18899: 	
; 18900: #ifdef BLOOD_DEVILSQUARE_TRADE_BUG_FIX
; 18901: 	lpObj->m_IfState.state = 0;	

  0069c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0069f	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  006a5	80 e1 f3	 and	 cl, 243			; 000000f3H
  006a8	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006ab	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 18902: 	lpObj->m_IfState.type = 0;

  006b1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b4	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  006ba	80 e1 0f	 and	 cl, 15			; 0000000fH
  006bd	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006c0	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 18903: 	lpObj->m_IfState.use =  0;

  006c6	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006c9	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  006cf	80 e1 fc	 and	 cl, 252			; 000000fcH
  006d2	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006d5	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 18904: #endif
; 18905: 
; 18906: 	//   
; 18907: 	gObjMoveGate(lpObj->m_Index, movegateindex);	

  006db	0f b6 45 e3	 movzx	 eax, BYTE PTR _movegateindex$[ebp]
  006df	50		 push	 eax
  006e0	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  006e5	52		 push	 edx
  006e6	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  006eb	83 c4 08	 add	 esp, 8

; 18908: 
; 18909: 	//   
; 18910: 	g_DevilSquare.m_DevilSquareGround[cSquareNumber].IncObjCount();

  006ee	0f b6 45 ff	 movzx	 eax, BYTE PTR _cSquareNumber$[ebp]
  006f2	69 c8 e0 03 00
	00		 imul	 ecx, eax, 992
  006f8	81 c1 30 00 00
	00		 add	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A+48
  006fe	e8 00 00 00 00	 call	 ?IncObjCount@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::IncObjCount
$LN1@GCReqmoveD:

; 18911: }

  00703	5f		 pop	 edi
  00704	5e		 pop	 esi
  00705	5b		 pop	 ebx
  00706	8b e5		 mov	 esp, ebp
  00708	5d		 pop	 ebp
  00709	c3		 ret	 0
?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ENDP ; GCReqmoveDevilSquare
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z PROC ; GCUseRenaChangeZenRecv, COMDAT

; 19423: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 19424: 	if( gObj[aIndex].UseEventServer )

  00013	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00020	83 bc 01 84 0e
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3716], 0
  00028	74 05		 je	 SHORT $LN2@GCUseRenaC

; 19425: 		return;

  0002a	e9 ea 00 00 00	 jmp	 $LN1@GCUseRenaC
$LN2@GCUseRenaC:

; 19426: 	gObj[aIndex].UseEventServer = TRUE;

  0002f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003c	c7 84 01 84 0e
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+3716], 1

; 19427: 
; 19428: 	PMSG_REQ_RESET_EVENTCHIP pMsg;
; 19429: 
; 19430: 	if (lpMsg->btType == 1)		// 

  00047	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0004e	83 f9 01	 cmp	 ecx, 1
  00051	75 12		 jne	 SHORT $LN3@GCUseRenaC

; 19431: 		PHeadSetB((LPBYTE)&pMsg, 0x09, sizeof(pMsg));

  00053	6a 14		 push	 20			; 00000014H
  00055	6a 09		 push	 9
  00057	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	eb 10		 jmp	 SHORT $LN4@GCUseRenaC
$LN3@GCUseRenaC:

; 19432: 	else
; 19433: 		PHeadSetB((LPBYTE)&pMsg, 0x04, sizeof(pMsg));

  00065	6a 14		 push	 20			; 00000014H
  00067	6a 04		 push	 4
  00069	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GCUseRenaC:

; 19434: 
; 19435: 	pMsg.iINDEX = aIndex;

  00075	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00078	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 19436: 
; 19437: 	strcpy(pMsg.szUID, gObj[aIndex].AccountID);

  0007b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00088	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0008c	52		 push	 edx
  0008d	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _strcpy
  00096	83 c4 08	 add	 esp, 8

; 19438: 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  00099	6a 14		 push	 20			; 00000014H
  0009b	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  000a4	83 c4 08	 add	 esp, 8

; 19439: 
; 19440: 	if (lpMsg->btType == 1)		// 

  000a7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000aa	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000ae	83 f9 01	 cmp	 ecx, 1
  000b1	75 34		 jne	 SHORT $LN5@GCUseRenaC

; 19441: 		LogAddTD("[EventChip] [%s][%s] Request Change Stones", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000b3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c0	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000c4	52		 push	 edx
  000c5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d2	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000d6	52		 push	 edx
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Ch@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e5	eb 32		 jmp	 SHORT $LN1@GCUseRenaC
$LN5@GCUseRenaC:

; 19442: 	else
; 19443: 		LogAddTD("[EventChip] [%s][%s] Request Change Rena", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000e7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f4	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000f8	52		 push	 edx
  000f9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00106	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0010a	52		 push	 edx
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Ch@
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCUseRenaC:

; 19444: }

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011f	33 cd		 xor	 ecx, ebp
  00121	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ENDP ; GCUseRenaChangeZenRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCUseEndEventChipRescv@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GCUseEndEventChipRescv@@YAXH@Z PROC			; GCUseEndEventChipRescv, COMDAT

; 19407: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19408: 	if( gObjIsConnectedGP(aIndex) == FALSE ) 

  00009	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	75 23		 jne	 SHORT $LN2@GCUseEndEv

; 19409: 	{
; 19410: 		LogAddC(LOGC_RED, "error-L3 [%s][%d]", __FILE__,__LINE__);

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GCUseEndEventChipRescv@@YAXH@Z@4JA
  0001e	83 c0 03	 add	 eax, 3
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
  0002c	6a 02		 push	 2
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 19411: 		return;

  00037	e9 c9 00 00 00	 jmp	 $LN1@GCUseEndEv
$LN2@GCUseEndEv:

; 19412: 	}
; 19413: 
; 19414: 	if( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_EVENTCHIP )

  0003c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00049	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00050	80 e2 03	 and	 dl, 3
  00053	0f b6 c2	 movzx	 eax, dl
  00056	85 c0		 test	 eax, eax
  00058	0f 84 a7 00 00
	00		 je	 $LN1@GCUseEndEv
  0005e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006b	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00072	c0 ea 04	 shr	 dl, 4
  00075	80 e2 0f	 and	 dl, 15			; 0000000fH
  00078	0f b6 c2	 movzx	 eax, dl
  0007b	83 f8 09	 cmp	 eax, 9
  0007e	0f 85 81 00 00
	00		 jne	 $LN1@GCUseEndEv

; 19415: 	{
; 19416: 		gObj[aIndex].m_IfState.state = 0;	

  00084	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00091	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00098	80 e2 f3	 and	 dl, 243			; 000000f3H
  0009b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a8	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19417: 		gObj[aIndex].m_IfState.type = 0;

  000af	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bc	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000c3	80 e2 0f	 and	 dl, 15			; 0000000fH
  000c6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d3	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19418: 		gObj[aIndex].m_IfState.use =  0;

  000da	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e7	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000ee	80 e2 fc	 and	 dl, 252			; 000000fcH
  000f1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fe	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN1@GCUseEndEv:

; 19419: 	}	
; 19420: }

  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
?GCUseEndEventChipRescv@@YAXH@Z ENDP			; GCUseEndEventChipRescv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z
_TEXT	SEGMENT
_pMsg$ = -292						; size = 20
_Result$1 = -272					; size = 10
_msg$2 = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z PROC	; GCGetMutoNumRecv, COMDAT

; 19367: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 19368: 	if( gObj[aIndex].MutoNumber != 0 )

  00016	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	83 bc 01 80 0e
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3712], 0
  0002b	74 2f		 je	 SHORT $LN2@GCGetMutoN

; 19369: 	{
; 19370: 		char msg[255];
; 19371: 		wsprintf(msg, "   ");	

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y@
  00032	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$2[ebp]
  00038	50		 push	 eax
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0003f	83 c4 08	 add	 esp, 8

; 19372: 		GCServerMsgStringSend(msg, aIndex, 1);	

  00042	6a 01		 push	 1
  00044	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00047	50		 push	 eax
  00048	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$2[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19373: 		return;

  00057	e9 4c 01 00 00	 jmp	 $LN1@GCGetMutoN
$LN2@GCGetMutoN:

; 19374: 	}
; 19375: 	
; 19376: 	if( gObj[aIndex].UseEventServer )

  0005c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00069	83 bc 01 84 0e
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3716], 0
  00071	74 05		 je	 SHORT $LN3@GCGetMutoN

; 19377: 		return;

  00073	e9 30 01 00 00	 jmp	 $LN1@GCGetMutoN
$LN3@GCGetMutoN:

; 19378: 
; 19379: 	gObj[aIndex].UseEventServer = TRUE;

  00078	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00085	c7 84 01 84 0e
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+3716], 1

; 19380: 
; 19381: 
; 19382: 	if( !gObjFind10EventChip(aIndex) )

  00090	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?gObjFind10EventChip@@YAHH@Z ; gObjFind10EventChip
  00099	83 c4 04	 add	 esp, 4
  0009c	85 c0		 test	 eax, eax
  0009e	0f 85 84 00 00
	00		 jne	 $LN4@GCGetMutoN

; 19383: 	{	//   
; 19384: 		PMSG_GETMUTONUMBER_RESULT Result;
; 19385: 		PHeadSetB((LPBYTE)&Result, 0x96, sizeof(Result));	

  000a4	6a 0a		 push	 10			; 0000000aH
  000a6	68 96 00 00 00	 push	 150			; 00000096H
  000ab	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _Result$1[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19386: 
; 19387: 		Result.MutoNum[0] = -1;

  000ba	b8 02 00 00 00	 mov	 eax, 2
  000bf	6b c8 00	 imul	 ecx, eax, 0
  000c2	83 ca ff	 or	 edx, -1
  000c5	66 89 94 0d f4
	fe ff ff	 mov	 WORD PTR _Result$1[ebp+ecx+4], dx

; 19388: 		Result.MutoNum[1] = 0;

  000cd	b8 02 00 00 00	 mov	 eax, 2
  000d2	c1 e0 00	 shl	 eax, 0
  000d5	33 c9		 xor	 ecx, ecx
  000d7	66 89 8c 05 f4
	fe ff ff	 mov	 WORD PTR _Result$1[ebp+eax+4], cx

; 19389: 		Result.MutoNum[2] = 0;

  000df	b8 02 00 00 00	 mov	 eax, 2
  000e4	d1 e0		 shl	 eax, 1
  000e6	33 c9		 xor	 ecx, ecx
  000e8	66 89 8c 05 f4
	fe ff ff	 mov	 WORD PTR _Result$1[ebp+eax+4], cx

; 19390: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000f0	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _Result$1[ebp+1]
  000f7	50		 push	 eax
  000f8	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _Result$1[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00102	52		 push	 edx
  00103	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19391: 		gObj[aIndex].UseEventServer = FALSE;

  0010b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00118	c7 84 01 84 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3716], 0

; 19392: 		return;

  00123	e9 80 00 00 00	 jmp	 $LN1@GCGetMutoN
$LN4@GCGetMutoN:

; 19393: 	}	
; 19394: 
; 19395: 	PMSG_REQ_REGISTER_MUTONUM	pMsg;
; 19396: 	PHeadSetB((LPBYTE)&pMsg, 0x03, sizeof(pMsg));	

  00128	6a 14		 push	 20			; 00000014H
  0012a	6a 03		 push	 3
  0012c	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19397: 
; 19398: 	pMsg.iINDEX = aIndex;	

  0013b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0013e	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 19399: 	strcpy(pMsg.szUID, gObj[aIndex].AccountID);

  00144	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0014b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00151	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00155	52		 push	 edx
  00156	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _strcpy
  00162	83 c4 08	 add	 esp, 8

; 19400: 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  00165	6a 14		 push	 20			; 00000014H
  00167	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  00173	83 c4 08	 add	 esp, 8

; 19401: 	
; 19402: 	LogAddTD("[EventChip] [%s][%s] Request MutoNumber", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00176	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00183	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00187	52		 push	 edx
  00188	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0018f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00195	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00199	52		 push	 edx
  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mu@
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001a5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGetMutoN:

; 19403: 
; 19404: }

  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx
  001ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ae	33 cd		 xor	 ecx, ebp
  001b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b5	8b e5		 mov	 esp, ebp
  001b7	5d		 pop	 ebp
  001b8	c3		 ret	 0
?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ENDP	; GCGetMutoNumRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z
_TEXT	SEGMENT
tv70 = -160						; size = 4
tv175 = -156						; size = 4
tv71 = -156						; size = 4
_Result$1 = -88						; size = 6
_pMsg$2 = -80						; size = 20
_Result$3 = -60						; size = 6
_pMsg$4 = -52						; size = 20
_Result$5 = -32						; size = 6
_sitem$ = -24						; size = 4
_Pos$ = -20						; size = 4
_Result$6 = -16						; size = 6
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z PROC	; GCRegEventChipRecv, COMDAT

; 19147: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 19148: 
; 19149: #ifdef  FOR_BLOODCASTLE
; 19150: 
; 19151: 	if (!CHECK_LIMIT(lpMsg->Type, 5))			//      

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00019	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0001d	85 c9		 test	 ecx, ecx
  0001f	7d 0c		 jge	 SHORT $LN19@GCRegEvent
  00021	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
  0002b	eb 2e		 jmp	 SHORT $LN20@GCRegEvent
$LN19@GCRegEvent:
  0002d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00030	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00034	83 f8 04	 cmp	 eax, 4
  00037	7e 0c		 jle	 SHORT $LN17@GCRegEvent
  00039	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
  00043	eb 0a		 jmp	 SHORT $LN18@GCRegEvent
$LN17@GCRegEvent:
  00045	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv70[ebp], 1
$LN18@GCRegEvent:
  0004f	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv70[ebp]
  00055	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], ecx
$LN20@GCRegEvent:
  0005b	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR tv71[ebp], 0
  00062	75 05		 jne	 SHORT $LN4@GCRegEvent

; 19152: 		return;

  00064	e9 77 03 00 00	 jmp	 $LN1@GCRegEvent
$LN4@GCRegEvent:

; 19153: 
; 19154: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00069	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00070	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00076	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 19155: 
; 19156: #ifdef BUGFIX_EVENT_CHIP_DUPLICATE_PREVENT_20050422
; 19157: 	//         
; 19158: 	if( lpObj->m_IfState.type == I_TRADE ) //   

  00079	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007c	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00082	c0 e9 04	 shr	 cl, 4
  00085	80 e1 0f	 and	 cl, 15			; 0000000fH
  00088	0f b6 d1	 movzx	 edx, cl
  0008b	83 fa 01	 cmp	 edx, 1
  0008e	75 21		 jne	 SHORT $LN5@GCRegEvent

; 19159: 	{
; 19160: 		LogAddTD("[EventChip] [%s][%s] Attempted ItemCopy using Trade Window", lpObj->AccountID, lpObj->Name );

  00090	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00093	83 c0 73	 add	 eax, 115		; 00000073H
  00096	50		 push	 eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009a	83 c1 68	 add	 ecx, 104		; 00000068H
  0009d	51		 push	 ecx
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19161: 		return;

  000ac	e9 2f 03 00 00	 jmp	 $LN1@GCRegEvent
$LN5@GCRegEvent:

; 19162: 	}
; 19163: 
; 19164: 	if( lpObj->m_IfState.type == I_CHAOSBOX ) //      

  000b1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b4	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000ba	c0 e9 04	 shr	 cl, 4
  000bd	80 e1 0f	 and	 cl, 15			; 0000000fH
  000c0	0f b6 d1	 movzx	 edx, cl
  000c3	83 fa 07	 cmp	 edx, 7
  000c6	75 21		 jne	 SHORT $LN6@GCRegEvent

; 19165: 	{
; 19166: 		LogAddTD("[EventChip] [%s][%s] Attempted ItemCopy using ChaosBox Window", lpObj->AccountID, lpObj->Name );

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cb	83 c0 73	 add	 eax, 115		; 00000073H
  000ce	50		 push	 eax
  000cf	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d2	83 c1 68	 add	 ecx, 104		; 00000068H
  000d5	51		 push	 ecx
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5@
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19167: 		return;

  000e4	e9 f7 02 00 00	 jmp	 $LN1@GCRegEvent
$LN6@GCRegEvent:

; 19168: 	}
; 19169: #endif
; 19170: 
; 19171: 	if( lpObj->UseEventServer ) {

  000e9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ec	83 b8 84 0e 00
	00 00		 cmp	 DWORD PTR [eax+3716], 0
  000f3	74 61		 je	 SHORT $LN7@GCRegEvent

; 19172: 		PMSG_REGEVENTCHIP_RESULT Result;
; 19173: 		PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  000f5	6a 06		 push	 6
  000f7	68 95 00 00 00	 push	 149			; 00000095H
  000fc	8d 45 f0	 lea	 eax, DWORD PTR _Result$6[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19174: 
; 19175: 		Result.ChipCount = -1;

  00108	83 c8 ff	 or	 eax, -1
  0010b	66 89 45 f4	 mov	 WORD PTR _Result$6[ebp+4], ax

; 19176: 		Result.Type = lpMsg->Type;

  0010f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00112	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00115	88 4d f3	 mov	 BYTE PTR _Result$6[ebp+3], cl

; 19177: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #1 %d", 

  00118	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0011b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0011f	51		 push	 ecx
  00120	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00123	83 c2 73	 add	 edx, 115		; 00000073H
  00126	52		 push	 edx
  00127	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012a	83 c0 68	 add	 eax, 104		; 00000068H
  0012d	50		 push	 eax
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00139	83 c4 10	 add	 esp, 16			; 00000010H

; 19178: 			   lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);
; 19179: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);		

  0013c	0f b6 45 f1	 movzx	 eax, BYTE PTR _Result$6[ebp+1]
  00140	50		 push	 eax
  00141	8d 4d f0	 lea	 ecx, DWORD PTR _Result$6[ebp]
  00144	51		 push	 ecx
  00145	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00148	52		 push	 edx
  00149	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19180: 		return;

  00151	e9 8a 02 00 00	 jmp	 $LN1@GCRegEvent
$LN7@GCRegEvent:

; 19181: 	}
; 19182: 
; 19183: 	int Pos = lpMsg->ChipPos+12;

  00156	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00159	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0015d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00160	89 4d ec	 mov	 DWORD PTR _Pos$[ebp], ecx

; 19184: 
; 19185: 	CItem* sitem = &lpObj->pInventory[Pos];	

  00163	69 45 ec a8 00
	00 00		 imul	 eax, DWORD PTR _Pos$[ebp], 168
  0016a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0016d	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00173	89 45 e8	 mov	 DWORD PTR _sitem$[ebp], eax

; 19186: 
; 19187: 	if( !sitem->IsItem() ) {

  00176	8b 4d e8	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00179	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0017e	85 c0		 test	 eax, eax
  00180	75 61		 jne	 SHORT $LN8@GCRegEvent

; 19188: 		PMSG_REGEVENTCHIP_RESULT Result;
; 19189: 		PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00182	6a 06		 push	 6
  00184	68 95 00 00 00	 push	 149			; 00000095H
  00189	8d 45 e0	 lea	 eax, DWORD PTR _Result$5[ebp]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19190: 
; 19191: 		Result.ChipCount = -1;

  00195	83 c8 ff	 or	 eax, -1
  00198	66 89 45 e4	 mov	 WORD PTR _Result$5[ebp+4], ax

; 19192: 		Result.Type = lpMsg->Type;

  0019c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0019f	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  001a2	88 4d e3	 mov	 BYTE PTR _Result$5[ebp+3], cl

; 19193: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #2 %d", 

  001a5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001a8	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001ac	51		 push	 ecx
  001ad	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001b0	83 c2 73	 add	 edx, 115		; 00000073H
  001b3	52		 push	 edx
  001b4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b7	83 c0 68	 add	 eax, 104		; 00000068H
  001ba	50		 push	 eax
  001bb	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c6	83 c4 10	 add	 esp, 16			; 00000010H

; 19194: 			   lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);
; 19195: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);		

  001c9	0f b6 45 e1	 movzx	 eax, BYTE PTR _Result$5[ebp+1]
  001cd	50		 push	 eax
  001ce	8d 4d e0	 lea	 ecx, DWORD PTR _Result$5[ebp]
  001d1	51		 push	 ecx
  001d2	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001d5	52		 push	 edx
  001d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19196: 		return;

  001de	e9 fd 01 00 00	 jmp	 $LN1@GCRegEvent
$LN8@GCRegEvent:

; 19197: 	}
; 19198: 
; 19199: 	lpObj->UseEventServer = TRUE;

  001e3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e6	c7 80 84 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3716], 1

; 19200: 
; 19201: 	switch (lpMsg->Type) {

  001f0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001f3	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  001f6	88 8d 64 ff ff
	ff		 mov	 BYTE PTR tv175[ebp], cl
  001fc	80 bd 64 ff ff
	ff 00		 cmp	 BYTE PTR tv175[ebp], 0
  00203	74 12		 je	 SHORT $LN9@GCRegEvent
  00205	80 bd 64 ff ff
	ff 01		 cmp	 BYTE PTR tv175[ebp], 1
  0020c	0f 84 cf 00 00
	00		 je	 $LN12@GCRegEvent
  00212	e9 bc 01 00 00	 jmp	 $LN15@GCRegEvent
$LN9@GCRegEvent:

; 19202: 	case 0 :		//  
; 19203: 		{
; 19204: 			/*   
; 19205: 			if( (sitem->m_Type != MAKE_ITEMNUM(14, 21)) && (sitem->m_Level == 0) )
; 19206: 			{
; 19207: 				//  
; 19208: 				PMSG_REGEVENTCHIP_RESULT Result;
; 19209: 				PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));
; 19210: 
; 19211: 				Result.ChipCount = -1;
; 19212: 				Result.Type = 0;
; 19213: 				LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) %d", 
; 19214: 					   lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);
; 19215: 				DataSend(aIndex, (LPBYTE)&Result, Result.h.size);		
; 19216: 				lpObj->UseEventServer = FALSE;			
; 19217: 			}
; 19218: 			else
; 19219: 			{	
; 19220: 				PMSG_REQ_REGISTER_EVENTCHIP	pMsg;
; 19221: 				PHeadSetB((LPBYTE)&pMsg, 0x02, sizeof(pMsg));	
; 19222: 
; 19223: 				pMsg.iINDEX = aIndex;
; 19224: 				pMsg.Pos = Pos;
; 19225: 				strcpy(pMsg.szUID, lpObj->AccountID);
; 19226: 				DataSendEventChip((char*)&pMsg, sizeof(pMsg));		
; 19227: 			}
; 19228: 			*/
; 19229: 			if( (sitem->m_Type == MAKE_ITEMNUM(14, 21)) && (sitem->m_Level == 0) )

  00217	8b 45 e8	 mov	 eax, DWORD PTR _sitem$[ebp]
  0021a	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0021e	6a 15		 push	 21			; 00000015H
  00220	6a 0e		 push	 14			; 0000000eH
  00222	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00227	83 c4 08	 add	 esp, 8
  0022a	3b f0		 cmp	 esi, eax
  0022c	75 4a		 jne	 SHORT $LN10@GCRegEvent
  0022e	8b 45 e8	 mov	 eax, DWORD PTR _sitem$[ebp]
  00231	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00235	85 c9		 test	 ecx, ecx
  00237	75 3f		 jne	 SHORT $LN10@GCRegEvent

; 19230: 			{
; 19231: 				PMSG_REQ_REGISTER_EVENTCHIP	pMsg;
; 19232: 				PHeadSetB((LPBYTE)&pMsg, 0x02, sizeof(pMsg));	

  00239	6a 14		 push	 20			; 00000014H
  0023b	6a 02		 push	 2
  0023d	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$4[ebp]
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00246	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19233: 
; 19234: 				pMsg.iINDEX = aIndex;

  00249	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0024c	89 45 d0	 mov	 DWORD PTR _pMsg$4[ebp+4], eax

; 19235: 				pMsg.Pos = Pos;

  0024f	8a 45 ec	 mov	 al, BYTE PTR _Pos$[ebp]
  00252	88 45 d4	 mov	 BYTE PTR _pMsg$4[ebp+8], al

; 19236: 				strcpy(pMsg.szUID, lpObj->AccountID);

  00255	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00258	83 c0 68	 add	 eax, 104		; 00000068H
  0025b	50		 push	 eax
  0025c	8d 4d d5	 lea	 ecx, DWORD PTR _pMsg$4[ebp+9]
  0025f	51		 push	 ecx
  00260	e8 00 00 00 00	 call	 _strcpy
  00265	83 c4 08	 add	 esp, 8

; 19237: 				DataSendEventChip((char*)&pMsg, sizeof(pMsg));		

  00268	6a 14		 push	 20			; 00000014H
  0026a	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$4[ebp]
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  00273	83 c4 08	 add	 esp, 8

; 19238: 
; 19239: 			}

  00276	eb 64		 jmp	 SHORT $LN11@GCRegEvent
$LN10@GCRegEvent:

; 19240: 			else
; 19241: 			{	//  
; 19242: 				PMSG_REGEVENTCHIP_RESULT Result;
; 19243: 				PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00278	6a 06		 push	 6
  0027a	68 95 00 00 00	 push	 149			; 00000095H
  0027f	8d 45 c4	 lea	 eax, DWORD PTR _Result$3[ebp]
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00288	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19244: 
; 19245: 				Result.ChipCount = -1;

  0028b	83 c8 ff	 or	 eax, -1
  0028e	66 89 45 c8	 mov	 WORD PTR _Result$3[ebp+4], ax

; 19246: 				Result.Type = 0;

  00292	c6 45 c7 00	 mov	 BYTE PTR _Result$3[ebp+3], 0

; 19247: 				LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #3 %d", 

  00296	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00299	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0029d	51		 push	 ecx
  0029e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002a1	83 c2 73	 add	 edx, 115		; 00000073H
  002a4	52		 push	 edx
  002a5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a8	83 c0 68	 add	 eax, 104		; 00000068H
  002ab	50		 push	 eax
  002ac	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@ODJBOBMD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5@
  002b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002b7	83 c4 10	 add	 esp, 16			; 00000010H

; 19248: 					   lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);
; 19249: 				DataSend(aIndex, (LPBYTE)&Result, Result.h.size);		

  002ba	0f b6 45 c5	 movzx	 eax, BYTE PTR _Result$3[ebp+1]
  002be	50		 push	 eax
  002bf	8d 4d c4	 lea	 ecx, DWORD PTR _Result$3[ebp]
  002c2	51		 push	 ecx
  002c3	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002c6	52		 push	 edx
  002c7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19250: 				lpObj->UseEventServer = FALSE;

  002cf	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d2	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0
$LN11@GCRegEvent:

; 19251: 			}
; 19252: 		}
; 19253: 		break;

  002dc	e9 ff 00 00 00	 jmp	 $LN1@GCRegEvent
$LN12@GCRegEvent:

; 19254: 	case 1 :		//  
; 19255: 		{
; 19256: 			if( (sitem->m_Type == MAKE_ITEMNUM(14, 21)) && (sitem->m_Level == 1) )

  002e1	8b 45 e8	 mov	 eax, DWORD PTR _sitem$[ebp]
  002e4	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  002e8	6a 15		 push	 21			; 00000015H
  002ea	6a 0e		 push	 14			; 0000000eH
  002ec	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002f1	83 c4 08	 add	 esp, 8
  002f4	3b f0		 cmp	 esi, eax
  002f6	75 75		 jne	 SHORT $LN13@GCRegEvent
  002f8	8b 45 e8	 mov	 eax, DWORD PTR _sitem$[ebp]
  002fb	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  002ff	83 f9 01	 cmp	 ecx, 1
  00302	75 69		 jne	 SHORT $LN13@GCRegEvent

; 19257: 			{
; 19258: 				PMSG_REQ_REGISTER_STONES	pMsg;
; 19259: 				PHeadSetB((LPBYTE)&pMsg, 0x06, sizeof(pMsg));	

  00304	6a 14		 push	 20			; 00000014H
  00306	6a 06		 push	 6
  00308	8d 45 b0	 lea	 eax, DWORD PTR _pMsg$2[ebp]
  0030b	50		 push	 eax
  0030c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00311	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19260: 
; 19261: 				pMsg.iINDEX = aIndex;

  00314	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00317	89 45 b4	 mov	 DWORD PTR _pMsg$2[ebp+4], eax

; 19262: 				pMsg.iPosition = Pos;

  0031a	8a 45 ec	 mov	 al, BYTE PTR _Pos$[ebp]
  0031d	88 45 b8	 mov	 BYTE PTR _pMsg$2[ebp+8], al

; 19263: 				strcpy(pMsg.szUID, lpObj->AccountID);

  00320	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00323	83 c0 68	 add	 eax, 104		; 00000068H
  00326	50		 push	 eax
  00327	8d 4d b9	 lea	 ecx, DWORD PTR _pMsg$2[ebp+9]
  0032a	51		 push	 ecx
  0032b	e8 00 00 00 00	 call	 _strcpy
  00330	83 c4 08	 add	 esp, 8

; 19264: 				DataSendEventChip((char*)&pMsg, sizeof(pMsg));	

  00333	6a 14		 push	 20			; 00000014H
  00335	8d 45 b0	 lea	 eax, DWORD PTR _pMsg$2[ebp]
  00338	50		 push	 eax
  00339	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  0033e	83 c4 08	 add	 esp, 8

; 19265: 	
; 19266: #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 19267: 				LogAddTD("[Stone] [%s][%s] Register Stone (Stone Pos:%d, Serial:%u)", 
; 19268: #else
; 19269: 				LogAddTD("[Stone] [%s][%s] Register Stone (Stone Pos:%d, Serial:%d)", 

  00341	8b 45 e8	 mov	 eax, DWORD PTR _sitem$[ebp]
  00344	8b 08		 mov	 ecx, DWORD PTR [eax]
  00346	51		 push	 ecx
  00347	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0034a	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0034e	50		 push	 eax
  0034f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00352	83 c1 73	 add	 ecx, 115		; 00000073H
  00355	51		 push	 ecx
  00356	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00359	83 c2 68	 add	 edx, 104		; 00000068H
  0035c	52		 push	 edx
  0035d	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EFAFIPG@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5Stone@
  00362	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00368	83 c4 14	 add	 esp, 20			; 00000014H

; 19270: #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 19271: 					   lpObj->AccountID, lpObj->Name, lpMsg->ChipPos, sitem->m_Number);
; 19272: 			}

  0036b	eb 64		 jmp	 SHORT $LN14@GCRegEvent
$LN13@GCRegEvent:

; 19273: 			else 
; 19274: 			{	//  
; 19275: 				PMSG_REGEVENTCHIP_RESULT Result;
; 19276: 				PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  0036d	6a 06		 push	 6
  0036f	68 95 00 00 00	 push	 149			; 00000095H
  00374	8d 45 a8	 lea	 eax, DWORD PTR _Result$1[ebp]
  00377	50		 push	 eax
  00378	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0037d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19277: 
; 19278: 				Result.ChipCount = -1;

  00380	83 c8 ff	 or	 eax, -1
  00383	66 89 45 ac	 mov	 WORD PTR _Result$1[ebp+4], ax

; 19279: 				Result.Type = 1;

  00387	c6 45 ab 01	 mov	 BYTE PTR _Result$1[ebp+3], 1

; 19280: 				LogAddTD("[Stone] [%s][%s] Not Found EventChip (Stone Pos: %d)", 

  0038b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0038e	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00392	51		 push	 ecx
  00393	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00396	83 c2 73	 add	 edx, 115		; 00000073H
  00399	52		 push	 edx
  0039a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039d	83 c0 68	 add	 eax, 104		; 00000068H
  003a0	50		 push	 eax
  003a1	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@CGCEIIIK@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5Even@
  003a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003ac	83 c4 10	 add	 esp, 16			; 00000010H

; 19281: 					   lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);
; 19282: 				DataSend(aIndex, (LPBYTE)&Result, Result.h.size);		

  003af	0f b6 45 a9	 movzx	 eax, BYTE PTR _Result$1[ebp+1]
  003b3	50		 push	 eax
  003b4	8d 4d a8	 lea	 ecx, DWORD PTR _Result$1[ebp]
  003b7	51		 push	 ecx
  003b8	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  003bb	52		 push	 edx
  003bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19283: 				lpObj->UseEventServer = FALSE;

  003c4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c7	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0
$LN14@GCRegEvent:

; 19284: 			}
; 19285: 		}
; 19286: 		break;

  003d1	eb 0d		 jmp	 SHORT $LN1@GCRegEvent
$LN15@GCRegEvent:

; 19287: 
; 19288: #ifdef EVENT_STONE_OF_FRIENDSHIP_20040206
; 19289: 	case 4 :		//  
; 19290: 		{
; 19291: 			if( (sitem->m_Type == MAKE_ITEMNUM(14, 21)) && (sitem->m_Level == 2) )
; 19292: 			{
; 19293: 				PMSG_REQ_REGISTER_FRIENDSHIP_STONES	pMsg;
; 19294: 				PHeadSetB((LPBYTE)&pMsg, 0x12, sizeof(pMsg));	
; 19295: 
; 19296: 				pMsg.iINDEX = aIndex;
; 19297: 				pMsg.iPosition = Pos;
; 19298: 				strcpy(pMsg.szUID, lpObj->AccountID);
; 19299: 				strcpy(pMsg.szNAME, lpObj->Name);
; 19300: 				pMsg.wServerCode = gGameServerCode / 20;
; 19301: 				DataSendEventChip((char*)&pMsg, sizeof(pMsg));	
; 19302: 	
; 19303: #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 19304: 				LogAddTD("[FriendShip Stone] [%s][%s] Register FriendShip Stone (Stone Pos:%d, Serial:%u)", 
; 19305: #else
; 19306: 				LogAddTD("[FriendShip Stone] [%s][%s] Register FriendShip Stone (Stone Pos:%d, Serial:%d)", 
; 19307: #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 19308: 					   lpObj->AccountID, lpObj->Name, lpMsg->ChipPos, sitem->m_Number);
; 19309: 			}
; 19310: 			else 
; 19311: 			{	//  
; 19312: 				PMSG_REGEVENTCHIP_RESULT Result;
; 19313: 				PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));
; 19314: 
; 19315: 				Result.ChipCount = -1;
; 19316: 				Result.Type = 1;
; 19317: 				LogAddTD("[FriendShip Stone] [%s][%s] Not Found EventChip (Stone Pos: %d)", 
; 19318: 					   lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);
; 19319: 				DataSend(aIndex, (LPBYTE)&Result, Result.h.size);		
; 19320: 				lpObj->UseEventServer = FALSE;
; 19321: 			}
; 19322: 		}
; 19323: 		break;
; 19324: #endif // EVENT_STONE_OF_FRIENDSHIP_20040206
; 19325: 	default :
; 19326: 		lpObj->UseEventServer = FALSE;

  003d3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d6	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0
$LN1@GCRegEvent:

; 19327: 		return;
; 19328: 	}
; 19329: 
; 19330: #else
; 19331: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];
; 19332: 
; 19333: 	if( lpObj->UseEventServer )
; 19334: 		return;
; 19335: 
; 19336: 	lpObj->UseEventServer = TRUE;
; 19337: 
; 19338: 	int Pos = lpMsg->ChipPos+12;
; 19339: 
; 19340: 	CItem* sitem = &lpObj->pInventory[Pos];	
; 19341: 
; 19342: 	if( sitem->m_Type != MAKE_ITEMNUM(14, 21) )
; 19343: 	{	//  
; 19344: 		PMSG_REGEVENTCHIP_RESULT Result;
; 19345: 		PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));
; 19346: 
; 19347: 		Result.ChipCount = -1;
; 19348: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #4 %d", 
; 19349: 			   lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);
; 19350: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);		
; 19351: 		lpObj->UseEventServer = FALSE;
; 19352: 	}
; 19353: 	else
; 19354: 	{
; 19355: 		PMSG_REQ_REGISTER_EVENTCHIP	pMsg;
; 19356: 		PHeadSetB((LPBYTE)&pMsg, 0x02, sizeof(pMsg));	
; 19357: 
; 19358: 		pMsg.iINDEX = aIndex;
; 19359: 		pMsg.Pos = Pos;
; 19360: 		strcpy(pMsg.szUID, lpObj->AccountID);
; 19361: 		DataSendEventChip((char*)&pMsg, sizeof(pMsg));		
; 19362: 	}
; 19363: #endif
; 19364: }

  003e0	5f		 pop	 edi
  003e1	5e		 pop	 esi
  003e2	5b		 pop	 ebx
  003e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e6	33 cd		 xor	 ecx, ebp
  003e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003ed	8b e5		 mov	 esp, ebp
  003ef	5d		 pop	 ebp
  003f0	c3		 ret	 0
?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ENDP	; GCRegEventChipRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z PROC		; GCSkillKeyRecv, COMDAT

; 4215 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4216 : 	if( gObjIsGamePlaing(&gObj[aIndex]) == FALSE ) 

  00009	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?gObjIsGamePlaing@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsGamePlaing
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	75 05		 jne	 SHORT $LN2@GCSkillKey

; 4217 : 	{
; 4218 : 		return;

  00023	e9 ae 00 00 00	 jmp	 $LN1@GCSkillKey
$LN2@GCSkillKey:

; 4219 : 	}	
; 4220 : 
; 4221 : #ifdef MODIFY_0708_BUFFIX_20070820	//     .
; 4222 : 	if( gObj[aIndex].m_bSkillKeyRecv == TRUE )

  00028	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00035	83 bc 01 40 1a
	00 00 01	 cmp	 DWORD PTR [ecx+eax+6720], 1
  0003d	75 05		 jne	 SHORT $LN3@GCSkillKey

; 4223 : 	{
; 4224 : 		return;

  0003f	e9 92 00 00 00	 jmp	 $LN1@GCSkillKey
$LN3@GCSkillKey:

; 4225 : 	}
; 4226 : 
; 4227 : 	gObj[aIndex].m_bSkillKeyRecv = TRUE;

  00044	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0004b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00051	c7 84 01 40 1a
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+6720], 1

; 4228 : #endif
; 4229 : 	
; 4230 : #ifdef ADD_SEASON_3_NEW_UI_20071122
; 4231 : 	BYTE	Rkey = 0;
; 4232 : 	if( lpMsg->h.size == sizeof(PMSG_SKILLKEY) )
; 4233 : 	{
; 4234 : 		Rkey = lpMsg->RkeyDefine;
; 4235 : 	}
; 4236 : #endif
; 4237 : 
; 4238 : #ifdef UPDATE_OPTIONKEY_LEVEL_20080116
; 4239 : 	int	QWERLevel = 0;
; 4240 : 
; 4241 : 	if( lpMsg->h.size == sizeof(PMSG_SKILLKEY) )
; 4242 : 	{
; 4243 : 		QWERLevel = ntohl(lpMsg->QWERLevel);
; 4244 : 	}
; 4245 : 
; 4246 : 	DGOptionDataSend(aIndex, gObj[aIndex].Name, lpMsg->SKillKey, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, lpMsg->ChatWindow, Rkey, QWERLevel);
; 4247 : #else	// UPDATE_OPTIONKEY_LEVEL_20080116	
; 4248 : #ifdef VER_CHATWINDOW_OPTION
; 4249 : #ifdef ADD_SEASON_3_NEW_UI_20071122
; 4250 : 	DGOptionDataSend(aIndex, gObj[aIndex].Name, lpMsg->SKillKey, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, lpMsg->ChatWindow, Rkey);
; 4251 : #else
; 4252 : 	DGOptionDataSend(aIndex, gObj[aIndex].Name, lpMsg->SKillKey, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, lpMsg->ChatWindow);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0005f	0f b6 48 12	 movzx	 ecx, BYTE PTR [eax+18]
  00063	51		 push	 ecx
  00064	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00067	0f b6 42 11	 movzx	 eax, BYTE PTR [edx+17]
  0006b	50		 push	 eax
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0006f	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00073	52		 push	 edx
  00074	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00077	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  0007b	51		 push	 ecx
  0007c	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0007f	0f b6 42 0e	 movzx	 eax, BYTE PTR [edx+14]
  00083	50		 push	 eax
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00087	83 c1 04	 add	 ecx, 4
  0008a	51		 push	 ecx
  0008b	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00097	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0009b	51		 push	 ecx
  0009c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 ?DGOptionDataSend@@YAXHPADPAEEEEEE@Z ; DGOptionDataSend
  000a5	83 c4 20	 add	 esp, 32			; 00000020H

; 4253 : #endif
; 4254 : #else
; 4255 : 	DGOptionDataSend(aIndex, gObj[aIndex].Name, lpMsg->SKillKey, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine);
; 4256 : #endif
; 4257 : #endif	// UPDATE_OPTIONKEY_LEVEL_20080116
; 4258 : 
; 4259 : 
; 4260 : #ifdef UPDATE_OPTIONKEY_LEVEL_20080116
; 4261 : 	LogAddL("Option Recv %d %d %d %d %d %d", lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, Rkey, lpMsg->QWERLevel);
; 4262 : #else	// UPDATE_OPTIONKEY_LEVEL_20080116
; 4263 : 	LogAddL("Option Recv %d %d %d %d", lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine);

  000a8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000ab	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  000af	51		 push	 ecx
  000b0	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000b3	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  000b7	50		 push	 eax
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000bb	0f b6 51 0f	 movzx	 edx, BYTE PTR [ecx+15]
  000bf	52		 push	 edx
  000c0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000c3	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  000c7	51		 push	 ecx
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@PHONBDAL@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  000d3	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@GCSkillKey:

; 4264 : #endif	// UPDATE_OPTIONKEY_LEVEL_20080116
; 4265 : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z ENDP		; GCSkillKeyRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGChaosBoxUseEnd@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 3
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CGChaosBoxUseEnd@@YAXH@Z PROC				; CGChaosBoxUseEnd, COMDAT

; 14045: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14046: 	if( gObjIsConnectedGP(aIndex) == FALSE ) 

  00009	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	75 23		 jne	 SHORT $LN2@CGChaosBox

; 14047: 	{
; 14048: 		LogAddC(LOGC_RED, "error-L3 [%s][%d]", __FILE__,__LINE__);

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGChaosBoxUseEnd@@YAXH@Z@4JA
  0001e	83 c0 03	 add	 eax, 3
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
  0002c	6a 02		 push	 2
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 14049: 		return;

  00037	e9 a8 00 00 00	 jmp	 $LN1@CGChaosBox
$LN2@CGChaosBox:

; 14050: 	}
; 14051: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  0003c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00043	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00049	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 14052: 
; 14053: 	PMSG_DEFAULT	pMsg;
; 14054: 
; 14055: 	PHeadSetB((LPBYTE)&pMsg, 0x87, sizeof( pMsg ));

  0004c	6a 03		 push	 3
  0004e	68 87 00 00 00	 push	 135			; 00000087H
  00053	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14056: 
; 14057: 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0005f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00063	50		 push	 eax
  00064	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14058: 
; 14059: 	if( lpObj->m_IfState.use && lpObj->m_IfState.type == I_CHAOSBOX )

  00074	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00077	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0007d	80 e1 03	 and	 cl, 3
  00080	0f b6 d1	 movzx	 edx, cl
  00083	85 d2		 test	 edx, edx
  00085	74 41		 je	 SHORT $LN3@CGChaosBox
  00087	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008a	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00090	c0 e9 04	 shr	 cl, 4
  00093	80 e1 0f	 and	 cl, 15			; 0000000fH
  00096	0f b6 d1	 movzx	 edx, cl
  00099	83 fa 07	 cmp	 edx, 7
  0009c	75 2a		 jne	 SHORT $LN3@CGChaosBox

; 14060: 	{
; 14061: 		lpObj->m_IfState.use   = 0;

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a1	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000a7	80 e1 fc	 and	 cl, 252			; 000000fcH
  000aa	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ad	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 14062: 		lpObj->m_IfState.state = 0;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b6	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000bc	80 e1 f3	 and	 cl, 243			; 000000f3H
  000bf	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c2	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl
$LN3@CGChaosBox:

; 14063: 	}
; 14064: 		g_MixSystem.ChaosBoxInit(lpObj);

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cb	50		 push	 eax
  000cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  000d1	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 14065: 	gObjInventoryCommit(lpObj->m_Index);

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  000e1	83 c4 04	 add	 esp, 4
$LN1@CGChaosBox:

; 14066: 
; 14067: #ifdef MODIFY_CASTLE_NPC_UPGRADE_PROCESS_20060619
; 14068: 	lpObj->m_bIsCastleNPCUpgradeCompleted	= false;
; 14069: #endif	
; 14070: }

  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
?CGChaosBoxUseEnd@@YAXH@Z ENDP				; CGChaosBoxUseEnd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z
_TEXT	SEGMENT
tv141 = -92						; size = 4
_iMixType$ = -24					; size = 4
_pMsg$ = -20						; size = 9
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z PROC ; CGChaosBoxItemMixButtonClick, COMDAT

; 13465: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 13466: 
; 13467: 
; 13468: 	if( gObjIsConnectedGP(aIndex) == FALSE ) 

  00013	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	75 23		 jne	 SHORT $LN4@CGChaosBox

; 13469: 	{
; 13470: 		LogAddC(LOGC_RED, "error-L3 [%s][%d]", __FILE__,__LINE__);

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z@4JA
  00028	83 c0 05	 add	 eax, 5
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
  00036	6a 02		 push	 2
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 13471: 		return;

  00041	e9 fe 01 00 00	 jmp	 $LN1@CGChaosBox
$LN4@CGChaosBox:

; 13472: 	}
; 13473: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];	

  00046	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0004d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00053	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 13474: 
; 13475: 	if( lpObj->ChaosLock == TRUE )

  00056	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00059	83 b8 bc 0c 00
	00 01		 cmp	 DWORD PTR [eax+3260], 1
  00060	75 42		 jne	 SHORT $LN5@CGChaosBox

; 13476: 	{
; 13477: 		LogAdd("[%s][%s] Already Used Chaos", lpObj->AccountID, lpObj->Name);

  00062	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00065	83 c0 73	 add	 eax, 115		; 00000073H
  00068	50		 push	 eax
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0006c	83 c1 68	 add	 ecx, 104		; 00000068H
  0006f	51		 push	 ecx
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos@
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13478: 		GCServerMsgStringSend(lMsg.Get(710), lpObj->m_Index, 1);		// " "

  0007e	6a 01		 push	 1
  00080	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	51		 push	 ecx
  00086	68 c6 02 00 00	 push	 710			; 000002c6H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13479: 		return;

  0009f	e9 a0 01 00 00	 jmp	 $LN1@CGChaosBox
$LN5@CGChaosBox:

; 13480: 	}
; 13481: 
; 13482: #ifdef PERSONAL_SHOP_20040113		//         .
; 13483: 	if (lpObj->m_bPShopOpen == true) {

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a7	0f b6 88 f8 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3320]
  000ae	83 f9 01	 cmp	 ecx, 1
  000b1	75 42		 jne	 SHORT $LN6@CGChaosBox

; 13484: 		LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed", lpObj->AccountID, lpObj->Name);

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b6	83 c0 73	 add	 eax, 115		; 00000073H
  000b9	50		 push	 eax
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bd	83 c1 68	 add	 ecx, 104		; 00000068H
  000c0	51		 push	 ecx
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSh@
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13485: 		GCServerMsgStringSend(lMsg.Get(1218), lpObj->m_Index, 1);		// "       ."

  000cf	6a 01		 push	 1
  000d1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d6	51		 push	 ecx
  000d7	68 c2 04 00 00	 push	 1218			; 000004c2H
  000dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13486: 		return;

  000f0	e9 4f 01 00 00	 jmp	 $LN1@CGChaosBox
$LN6@CGChaosBox:

; 13487: 	}
; 13488: #endif
; 13489: 
; 13490: 
; 13491: #ifdef CHAOS_MIX_LEVEL_LIMIT
; 13492: 	if( lpObj->Level < 10 )
; 13493: 	{	//  
; 13494: 		return;
; 13495: 	}
; 13496: #endif
; 13497: 
; 13498: 
; 13499: 	PMSG_CHAOSMIXRESULT	pMsg;
; 13500: 	PHeadSetB((LPBYTE)&pMsg, 0x86, sizeof( pMsg ));

  000f5	6a 09		 push	 9
  000f7	68 86 00 00 00	 push	 134			; 00000086H
  000fc	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13501: 	pMsg.Result		= 0x00;	

  00108	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 13502: 
; 13503: 	//              [ ]
; 13504: 	//  1    ,       .
; 13505: 	// by natinda 2008/10/15
; 13506: 	// [BEGIN]
; 13507: 
; 13508: #ifdef MODIFY_MIXSYSTEM_BUGFIX_20081016
; 13509: 	if(aRecv->Type == CHAOS_TYPE_UPGRADE_10 || aRecv->Type == CHAOS_TYPE_UPGRADE_11 || aRecv->Type == CHAOS_TYPE_UPGRADE_12 || aRecv->Type == CHAOS_TYPE_UPGRADE_13) {
; 13510: 		
; 13511: 		//   .     ,            .
; 13512: 
; 13513: 		int nPlusItemPos = 0;
; 13514: 		int nItemCount = 0;
; 13515: 		//    ..
; 13516: 		for( int n = 0; n < MAX_CHAOSBOXITEMS; n++)	{
; 13517: 
; 13518: 			if( lpObj->pChaosBox[n].IsItem() == TRUE ) {
; 13519: 
; 13520: 				if( lpObj->pChaosBox[n].m_Level == 9 ) {
; 13521: 					nPlusItemPos = n;
; 13522: 					nItemCount++;
; 13523: 				} else if( lpObj->pChaosBox[n].m_Level == 10 ) {
; 13524: 					nPlusItemPos = n;
; 13525: 					nItemCount++;
; 13526: 				}
; 13527: #ifdef ITEM_12_13_20040401
; 13528: 				else if( lpObj->pChaosBox[n].m_Level == 11 ) {
; 13529: 						nPlusItemPos = n;
; 13530: 						nItemCount++;
; 13531: 				} else if( lpObj->pChaosBox[n].m_Level == 12 ) {
; 13532: 						nPlusItemPos = n;
; 13533: 						nItemCount++;
; 13534: 				}
; 13535: #endif
; 13536: 				else {
; 13537: 						//   ..   .        . 
; 13538: 				}
; 13539: 			}
; 13540: 		}
; 13541: 
; 13542: 		if(nItemCount != 1) {
; 13543: 			//  ,    1   0 or 1 
; 13544: 			//         .   ..
; 13545: 			pMsg.Result	= 0x00;  
; 13546: 			DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13547: 			return;  //     . 
; 13548: 		}
; 13549: 
; 13550: 		int nWidth = 0, nHeight = 0;
; 13551: 
; 13552: 		lpObj->pChaosBox[nPlusItemPos].GetSize(nWidth, nHeight);
; 13553: 		if(CheckInventoryEmptySpace_(lpObj, nHeight, nWidth)) {
; 13554: 			//    .     .
; 13555: 			//   .
; 13556: 
; 13557: 		} else {
; 13558: 			//  . 
; 13559: 			pMsg.Result	= 0x00;  
; 13560: 			DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13561: 			return;
; 13562: 		}
; 13563: 	}
; 13564: #endif //MODIFY_MIXSYSTEM_BUGFIX_20081016
; 13565: // by natinda 2008/10/15 
; 13566: // [END]
; 13567: 
; 13568: #ifdef CHAOS_MIX_TRANSACTION_BUXFIX_20040610
; 13569: 	lpObj->bIsChaosMixCompleted	= true;		//        Commit  .

  0010c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010f	c6 80 81 10 00
	00 01		 mov	 BYTE PTR [eax+4225], 1

; 13570: #endif
; 13571: 
; 13572: 
; 13573: //     
; 13574: #ifdef CHAOS_MIX_UPGRADE
; 13575: 	int	iMixType = aRecv->Type;

  00116	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00119	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0011d	89 4d e8	 mov	 DWORD PTR _iMixType$[ebp], ecx

; 13576: 
; 13577: 	switch(iMixType)

  00120	8b 45 e8	 mov	 eax, DWORD PTR _iMixType$[ebp]
  00123	89 45 a4	 mov	 DWORD PTR tv141[ebp], eax
  00126	8b 4d a4	 mov	 ecx, DWORD PTR tv141[ebp]
  00129	83 e9 01	 sub	 ecx, 1
  0012c	89 4d a4	 mov	 DWORD PTR tv141[ebp], ecx
  0012f	83 7d a4 17	 cmp	 DWORD PTR tv141[ebp], 23 ; 00000017H
  00133	0f 87 eb 00 00
	00		 ja	 $LN19@CGChaosBox
  00139	8b 55 a4	 mov	 edx, DWORD PTR tv141[ebp]
  0013c	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN21@CGChaosBox[edx]
  00143	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN22@CGChaosBox[eax*4]
$LN7@CGChaosBox:

; 13578: 	{
; 13579: 		case CHAOS_TYPE_DEVILSQUARE:	//   + 			
; 13580: 			g_MixSystem.DevilSquareItemChaosMix(lpObj);

  0014a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014d	50		 push	 eax
  0014e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00153	e8 00 00 00 00	 call	 ?DevilSquareItemChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CMixSystem::DevilSquareItemChaosMix

; 13581: 		break;

  00158	e9 e7 00 00 00	 jmp	 $LN1@CGChaosBox
$LN8@CGChaosBox:

; 13582: 
; 13583: 		case CHAOS_TYPE_UPGRADE_10:		// +10			
; 13584: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_10);

  0015d	6a 03		 push	 3
  0015f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00162	50		 push	 eax
  00163	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00168	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix

; 13585: 		break;

  0016d	e9 d2 00 00 00	 jmp	 $LN1@CGChaosBox
$LN9@CGChaosBox:

; 13586: 
; 13587: 		case CHAOS_TYPE_UPGRADE_11:		// +11 			
; 13588: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_11);			

  00172	6a 04		 push	 4
  00174	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00177	50		 push	 eax
  00178	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0017d	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix

; 13589: 		break;

  00182	e9 bd 00 00 00	 jmp	 $LN1@CGChaosBox
$LN10@CGChaosBox:

; 13590: 
; 13591: 	#ifdef ITEM_12_13_20040401
; 13592: 			case CHAOS_TYPE_UPGRADE_12:		// +12 			
; 13593: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_12);			

  00187	6a 16		 push	 22			; 00000016H
  00189	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018c	50		 push	 eax
  0018d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00192	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix

; 13594: 			break;

  00197	e9 a8 00 00 00	 jmp	 $LN1@CGChaosBox
$LN11@CGChaosBox:

; 13595: 
; 13596: 			case CHAOS_TYPE_UPGRADE_13:		// +13 			
; 13597: 			g_MixSystem.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_13);			

  0019c	6a 17		 push	 23			; 00000017H
  0019e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a1	50		 push	 eax
  001a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  001a7	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@H@Z ; CMixSystem::PlusItemLevelChaosMix

; 13598: 			break;

  001ac	e9 93 00 00 00	 jmp	 $LN1@CGChaosBox
$LN12@CGChaosBox:

; 13599: 	#endif
; 13600: 		
; 13601: 		case CHAOS_TYPE_DINORANT:		//  
; 13602: 			g_MixSystem.PegasiaChaosMix(lpObj);

  001b1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b4	50		 push	 eax
  001b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  001ba	e8 00 00 00 00	 call	 ?PegasiaChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CMixSystem::PegasiaChaosMix

; 13603: 		break;

  001bf	e9 80 00 00 00	 jmp	 $LN1@CGChaosBox
$LN13@CGChaosBox:

; 13604: 
; 13605: 	#ifdef ADD_FRUIT_N_WING_OF_CHAOS_MIX_20050502
; 13606: 		case CHAOS_TYPE_FRUIT:			//  
; 13607: 			g_MixSystem.CircleChaosMix(lpObj);

  001c4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c7	50		 push	 eax
  001c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  001cd	e8 00 00 00 00	 call	 ?CircleChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CMixSystem::CircleChaosMix

; 13608: 		break;

  001d2	eb 70		 jmp	 SHORT $LN1@CGChaosBox
$LN14@CGChaosBox:

; 13609: 
; 13610: 		case CHAOS_TYPE_SECOND_WING:	 //  
; 13611: 		
; 13612: 		#ifdef DARKLORD_WORK				
; 13613: 		case CHAOS_TYPE_CLOAK:
; 13614: 		#endif
; 13615: 		
; 13616: 			g_MixSystem.WingChaosMix(lpObj);

  001d4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d7	50		 push	 eax
  001d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  001dd	e8 00 00 00 00	 call	 ?WingChaosMix@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CMixSystem::WingChaosMix

; 13617: 		break;

  001e2	eb 60		 jmp	 SHORT $LN1@CGChaosBox
$LN15@CGChaosBox:

; 13618: 
; 13619: 	#endif // ADD_FRUIT_N_WING_OF_CHAOS_MIX_20050502
; 13620: 
; 13621: 		case CHAOS_TYPE_BLOODCATLE:		//  
; 13622: 			g_MixSystem.BloodCastleItemChaosMix(lpObj);

  001e4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e7	50		 push	 eax
  001e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  001ed	e8 00 00 00 00	 call	 ?BloodCastleItemChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CMixSystem::BloodCastleItemChaosMix

; 13623: 		break;

  001f2	eb 50		 jmp	 SHORT $LN1@CGChaosBox
$LN16@CGChaosBox:

; 13624: 
; 13625: 		case CHAOS_TYPE_DEFAULT:		//  		
; 13626: 		case CHAOS_TYPE_FIRST_WING:		//   
; 13627: 			g_MixSystem.DefaultChaosMix(lpObj);

  001f4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f7	50		 push	 eax
  001f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  001fd	e8 00 00 00 00	 call	 ?DefaultChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CMixSystem::DefaultChaosMix

; 13628: 		break;

  00202	eb 40		 jmp	 SHORT $LN1@CGChaosBox
$LN17@CGChaosBox:

; 13629: 
; 13630: 
; 13631: 	#ifdef DARKLORD_WORK
; 13632: 			case CHAOS_TYPE_DARKHORSE:		//  
; 13633: 				g_MixSystem.DarkHorseChaosMix(lpObj);

  00204	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00207	50		 push	 eax
  00208	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0020d	e8 00 00 00 00	 call	 ?DarkHorseChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CMixSystem::DarkHorseChaosMix

; 13634: 			break;

  00212	eb 30		 jmp	 SHORT $LN1@CGChaosBox
$LN18@CGChaosBox:

; 13635: 
; 13636: 			case CHAOS_TYPE_DARKSPIRIT:		//  
; 13637: 				g_MixSystem.DarkSpiritChaosMix(lpObj);

  00214	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00217	50		 push	 eax
  00218	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  0021d	e8 00 00 00 00	 call	 ?DarkSpiritChaosMix@CMixSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CMixSystem::DarkSpiritChaosMix

; 13638: 			break;

  00222	eb 20		 jmp	 SHORT $LN1@CGChaosBox
$LN19@CGChaosBox:

; 13639: 	#endif
; 13640: 			
; 13641: 
; 13642: #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 13643: 			case CHAOS_TYPE_BLESS_POTION:	
; 13644: 				g_MixSystem.BlessPotionChaosMix(lpObj);	// ()   
; 13645: 				break;
; 13646: 
; 13647: 			case CHAOS_TYPE_SOUL_POTION:
; 13648: 				g_MixSystem.SoulPotionChaosMix(lpObj);  // ()   
; 13649: 				break;
; 13650: 
; 13651: 			case CHAOS_TYPE_LIFE_STONE:
; 13652: 				g_MixSystem.LifeStoneChaosMix(lpObj);	// ()  
; 13653: 				break;
; 13654: #endif
; 13655: 				
; 13656: #ifdef CASTLE_SPECIAL_ITEMMIX_20050425
; 13657: 			case CHAOS_TYPE_CASTLE_ITEM:	//      
; 13658: 				g_MixSystem.CastleSpecialItemMix(lpObj);
; 13659: 				break;
; 13660: #endif
; 13661: 
; 13662: #ifdef HIDDEN_TREASUREBOX_EVENT_20050804	//    - 
; 13663: 			case CHAOS_TYPE_HT_BOX:
; 13664: 				g_MixSystem.HiddenTreasureBoxItemMix(lpObj);
; 13665: 				break;
; 13666: #endif
; 13667: 
; 13668: #ifdef ADD_ITEM_FENRIR_01_20051110
; 13669: 			case CHAOS_TYPE_FENRIR_01:
; 13670: 				g_MixSystem.Fenrir_01Level_Mix(lpObj);	//  1 -   
; 13671: 				break;
; 13672: 			case CHAOS_TYPE_FENRIR_02:
; 13673: 				g_MixSystem.Fenrir_02Level_Mix(lpObj);	//  2 -   
; 13674: 				break;
; 13675: 			case CHAOS_TYPE_FENRIR_03:
; 13676: 				g_MixSystem.Fenrir_03Level_Mix(lpObj);	//  3 -   
; 13677: 				break;
; 13678: 			case CHAOS_TYPE_FENRIR_04:
; 13679: 				g_MixSystem.Fenrir_04Upgrade_Mix(lpObj);//  4 -   
; 13680: 				break;
; 13681: #endif
; 13682: 
; 13683: #ifdef ADD_SHIELD_POINT_01_20060403
; 13684: 			case CHAOS_TYPE_COMPOUNDPOTION_LV1:
; 13685: 				g_MixSystem.ShieldPotionLv1_Mix(lpObj);
; 13686: 				break;
; 13687: 			case CHAOS_TYPE_COMPOUNTPOTION_LV2:
; 13688: 				g_MixSystem.ShieldPotionLv2_Mix(lpObj);
; 13689: 				break;
; 13690: 			case CHAOS_TYPE_COMPOUNTPOTION_LV3:
; 13691: 				g_MixSystem.ShieldPotionLv3_Mix(lpObj);
; 13692: 				break;
; 13693: #endif
; 13694: 
; 13695: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530	
; 13696: 			case CHAOS_TYPE_JEWELOFHARMONY_PURITY:
; 13697: 				g_kJewelOfHarmonySystem.PurityJewelOfHarmony(lpObj);
; 13698: 				break;
; 13699: 			case CHAOS_TYPE_JEWELOFHARMONY_MIX_SMELTINGITEM:
; 13700: 				g_kJewelOfHarmonySystem.MakeSmeltingStoneItem(lpObj);
; 13701: 				break;
; 13702: 			case CHAOS_TYPE_JEWELOFHARMONY_RESTORE_ITEM:
; 13703: 				g_kJewelOfHarmonySystem.RestoreStrengthenItem(lpObj);
; 13704: 				break;
; 13705: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 13706: 
; 13707: #ifdef ADD_380ITEM_NEWOPTION_20060711
; 13708: 			case CHAOS_TYPE_380_OPTIONITEM:
; 13709: 				g_kItemSystemFor380.ChaosMix380ItemOption( lpObj );
; 13710: 				break;
; 13711: #endif // ADD_380ITEM_NEWOPTION_20060711
; 13712: 
; 13713: #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 13714: 			case CHAOS_TYPE_LOTTERY_MIX:
; 13715: #ifdef MODIFY_PCS_CHAOSMIX_REFACTORING_20070903
; 13716: 				g_MixSystem.ChaosCardMix( lpObj );
; 13717: #else
; 13718: 				LotteryItemMix( lpObj );
; 13719: #endif // MODIFY_MIX_SYSTEM_20070518
; 13720: 				break;
; 13721: #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 13722: 
; 13723: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//     
; 13724: 			case CHAOS_TYPE_ILLUSION_TEMPLE_ITEM:
; 13725: 				g_IllusionTempleEvent.IllusionTempleChaosMixItem(lpObj);
; 13726: 				break;
; 13727: #endif
; 13728: #ifdef ADD_THIRD_WING_20070525		// 3   
; 13729: 			case CHAOS_TYPE_THIRD_WING_1:
; 13730: 				g_MixSystem.ThirdWingLevel1_Mix( lpObj );
; 13731: 				break;
; 13732: 			case CHAOS_TYPE_THIRD_WING_2:
; 13733: 				g_MixSystem.ThirdWingLevel2_Mix( lpObj );
; 13734: 				break;
; 13735: #endif
; 13736: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 13737: 			case CHAOS_TYPE_CHERRY_MIX:
; 13738: 				g_MixSystem.CherryBlossomMix( lpObj );
; 13739: 				break;
; 13740: #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 13741: 
; 13742: #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 13743: 			case CHAOS_TYPE_SEED_EXTRACT:
; 13744: 				g_MixSystem.MixExtractSeed( lpObj );
; 13745: 				break;
; 13746: 			case CHAOS_TYPE_SEED_COMPOSIT:
; 13747: 				g_MixSystem.MixCompositeSeedSphere( lpObj );
; 13748: 				break;
; 13749: 			case CHAOS_TYPE_SEED_EQUIP:
; 13750: 				g_MixSystem.MixSetSeedSphere( lpObj, aRecv->SubType );
; 13751: 				break;
; 13752: 			case CHAOS_TYPE_SEED_REMOVE:
; 13753: 				g_MixSystem.MixRemoveSeedSphere( lpObj, aRecv->SubType );
; 13754: 				break;
; 13755: #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 13756: 
; 13757: 		default:	//   
; 13758: 			LogAddTD("[%s][%s] Undefine chaosmix type detect %d", lpObj->AccountID, lpObj->Name,iMixType);			

  00224	8b 45 e8	 mov	 eax, DWORD PTR _iMixType$[ebp]
  00227	50		 push	 eax
  00228	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0022b	83 c1 73	 add	 ecx, 115		; 00000073H
  0022e	51		 push	 ecx
  0022f	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00232	83 c2 68	 add	 edx, 104		; 00000068H
  00235	52		 push	 edx
  00236	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type@
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00241	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@CGChaosBox:

; 13759: 		break;
; 13760: 	}
; 13761: //      
; 13762: #else	//#ifdef CHAOS_MIX_UPGRADE
; 13763: 	BOOL fail=TRUE;
; 13764: 	BOOL MixResult2;
; 13765: 
; 13766: //       
; 13767: //	PMSG_CHAOSMIXRESULT	pMsg;
; 13768: //	PHeadSetB((LPBYTE)&pMsg, 0x86, sizeof( pMsg ));
; 13769: //	pMsg.Result		= 0x00;	
; 13770: 
; 13771: 	#ifdef NEW_FORSKYLAND2
; 13772: //		#ifndef FOR_JAPAN	//   ( ) 2 ,  .
; 13773: 		#ifndef FOR_THAILAND	//  2 ,  .
; 13774: 			if( g_MixSystem.WingChaosMix(lpObj) == 1 )
; 13775: 			{
; 13776: 				return;
; 13777: 			}
; 13778: 
; 13779: 			if( g_MixSystem.CircleChaosMix(lpObj) == 1 )
; 13780: 			{
; 13781: 				return;
; 13782: 			}
; 13783: 		#endif
; 13784: //		#endif
; 13785: 	#endif
; 13786: 
; 13787: 	#ifdef NEW_SKILL_FORSKYLAND
; 13788: 		if( g_MixSystem.PegasiaChaosMix(lpObj) == 1 )
; 13789: 		{
; 13790: 			return;
; 13791: 		}
; 13792: 	#endif
; 13793: 
; 13794: 	if( gDevilSquareEvent )
; 13795: 	{	//     ,  
; 13796: 		int	iEventItemCount;
; 13797: 		int iItemLevel;
; 13798: 
; 13799: 		BOOL bret = g_MixSystem.CheckDevilSquareItem(lpObj, iEventItemCount, iItemLevel);
; 13800: 
; 13801: 		if( bret )
; 13802: 		{
; 13803: 			if( bret == 3 )
; 13804: 			{	//   DQ  
; 13805: 				pMsg.Result		= 0x07;		
; 13806: 				DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13807: 				LogAdd("[DevilSquare] DiffLevel Devil's Key or Eyes [%d]", iEventItemCount);
; 13808: 				lpObj->ChaosLock = FALSE;
; 13809: 				return;
; 13810: 			}
; 13811: 
; 13812: 			if( bret == 2 )
; 13813: 			{	//  
; 13814: 				pMsg.Result		= 0x07;		
; 13815: 				DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13816: 				LogAdd("[DevilSquare] Not Found Chaos Gem [%d]", iEventItemCount);
; 13817: 				lpObj->ChaosLock = FALSE;
; 13818: 				return;
; 13819: 			}
; 13820: 
; 13821: 			if( iEventItemCount > 2 )
; 13822: 			{
; 13823: 				pMsg.Result		= 0x03;		//     
; 13824: 				DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13825: 				LogAdd("[DevilSquare] Too many Devil's Key or Eyes [%d]", iEventItemCount);
; 13826: 				lpObj->ChaosLock = FALSE;
; 13827: 				return;
; 13828: 			}
; 13829: 
; 13830: 			if( lpObj->Level < 10 )
; 13831: 			{
; 13832: 				pMsg.Result		= 0x04;		//      10  
; 13833: 				DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13834: 				lpObj->ChaosLock = FALSE;
; 13835: 				return;
; 13836: 			}
; 13837: 
; 13838: 			g_MixSystem.DevilSquareEventChaosMix(lpObj, bret, iItemLevel);
; 13839: 			return;
; 13840: 		}
; 13841: 		else if( iEventItemCount > 1 )
; 13842: 		{	
; 13843: 			pMsg.Result		= 0x06;		//   ,     
; 13844: 			DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13845: 			lpObj->ChaosLock = FALSE;
; 13846: 			return;
; 13847: 		}
; 13848: 	}	
; 13849: 
; 13850: 
; 13851: 	#ifdef FOR_BLOODCASTLE
; 13852: 		// ,  
; 13853: 		int iRET_VAL = g_BloodCastle.CheckChoasMixItem(aIndex);
; 13854: 
; 13855: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//   
; 13856: 		int iMapNum = g_BloodCastle.GetMapNumByBCBridge( iRET_VAL );
; 13857: 
; 13858: 		if (CHECK_BLOODCASTLE( iMapNum ) ) 
; 13859: 		{
; 13860: #else		
; 13861: 		if (CHECK_BLOODCASTLE(iRET_VAL - 1 + MAP_INDEX_BLOODCASTLE1)) {
; 13862: #endif
; 13863: 			//     ()  . =>   .
; 13864: 			g_BloodCastle.BloodCastleChaosMix(aIndex, iRET_VAL);
; 13865: 			lpObj->ChaosLock = FALSE;
; 13866: 			return;
; 13867: 		}
; 13868: 		else {
; 13869: 			//  
; 13870: 			switch(iRET_VAL) {
; 13871: 			case 0 :		//   -   .
; 13872: 				{
; 13873: 				}
; 13874: 				break;
; 13875: 			case 8 :		//    ->    
; 13876: 				{
; 13877: 	/*				pMsg.Result	= 0x0A;
; 13878: 					DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13879: 					lpObj->ChaosLock = FALSE;
; 13880: 					return;
; 13881: 	*/			}
; 13882: 				break;
; 13883: 			case 9 :		//   
; 13884: 				{
; 13885: 					pMsg.Result	= 0x0A;
; 13886: 					DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13887: 					lpObj->ChaosLock = FALSE;
; 13888: 					return;
; 13889: 				}
; 13890: 				break;
; 13891: 			case 10 :		//  . (     )
; 13892: 				{
; 13893: 					pMsg.Result	= 0x0A;
; 13894: 					DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13895: 					lpObj->ChaosLock = FALSE;
; 13896: 					return;
; 13897: 				}
; 13898: 				break;
; 13899: 			case 11 :		//      . (  )
; 13900: 				{
; 13901: 					pMsg.Result	= 0x0A;
; 13902: 					DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13903: 					lpObj->ChaosLock = FALSE;
; 13904: 					return;
; 13905: 				}
; 13906: 				break;
; 13907: 			case 12 :		//    .
; 13908: 				{
; 13909: 					pMsg.Result	= 0x08;
; 13910: 					DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13911: 					lpObj->ChaosLock = FALSE;
; 13912: 					return;
; 13913: 				}
; 13914: 				break;
; 13915: 			case 13 :		//    . (      .)
; 13916: 				{
; 13917: 					pMsg.Result	= 0x0B;
; 13918: 					DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13919: 					lpObj->ChaosLock = FALSE;
; 13920: 					return;
; 13921: 				}
; 13922: 				break;
; 13923: 			case 14 :		//     .
; 13924: 				{
; 13925: 					pMsg.Result	= 0x09;
; 13926: 					DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13927: 					lpObj->ChaosLock = FALSE;
; 13928: 					return;
; 13929: 				}
; 13930: 				break;
; 13931: 			default:
; 13932: 				{
; 13933: 				}
; 13934: 				break;
; 13935: 			}
; 13936: 		}
; 13937: 	#endif	// #ifdef FOR_BLOODCASTLE
; 13938: 
; 13939: 	if(	g_MixSystem.PlusItemLevelChaosMix(lpObj) )
; 13940: 		return;
; 13941: 
; 13942: 	
; 13943: 	lpObj->ChaosLock = TRUE;
; 13944: 
; 13945: 	if( g_MixSystem.ChaosBoxMix(lpObj, MixResult2) == 0 )
; 13946: 	{	//   
; 13947: 		pMsg.Result		= 0x07;		//   
; 13948: 		DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13949: 		lpObj->ChaosLock = FALSE;
; 13950: 		return;
; 13951: 	}
; 13952: 
; 13953: 	if( lpObj->Money < lpObj->ChaosMoney )
; 13954: 	{
; 13955: 		pMsg.Result		= 0x02;		//  .
; 13956: 		DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 13957: 		lpObj->ChaosLock = FALSE;
; 13958: 	}
; 13959: 	else 
; 13960: 	{
; 13961: 		if( lpObj->ChaosSuccessRate> 0 ) 
; 13962: 		{
; 13963: 			if( lpObj->ChaosSuccessRate >= 100 ) lpObj->ChaosSuccessRate = 100;
; 13964: 			if( (rand()%100) <= (lpObj->ChaosSuccessRate-1) )
; 13965: 			{
; 13966: 				fail			= FALSE;
; 13967: 
; 13968: 				pMsg.Result		= 0x01;
; 13969: 				
; 13970: 				int level = rand()%5;
; 13971: 				int Option1=0, Option2=0, Option3=0;
; 13972: 
; 13973: 				if((rand()%100) < (6+(lpObj->ChaosSuccessRate/5)) ) Option1 = 1;
; 13974: 				if((rand()%100) < (4+(lpObj->ChaosSuccessRate/5)) ) Option2 = 1;	//    
; 13975: 
; 13976: 				int optionrand, optionc;
; 13977: 
; 13978: 				optionc = (rand()%3);
; 13979: 				optionrand = (rand()%100);
; 13980: 
; 13981: 				switch( optionc )
; 13982: 				{
; 13983: 				case 0 :
; 13984: 					if( optionrand < (4+(lpObj->ChaosSuccessRate/5)) ) Option3 = 3;	// 
; 13985: 					break;
; 13986: 				case 1 :
; 13987: 					if( optionrand < (8+(lpObj->ChaosSuccessRate/5)) ) Option3 = 2;	// 
; 13988: 					break;
; 13989: 				case 2 :
; 13990: 					if( optionrand < (12+(lpObj->ChaosSuccessRate/5)) ) Option3 = 1;	// 
; 13991: 					break;
; 13992: 				}
; 13993: 				if( MixResult2 == TRUE )
; 13994: 				{
; 13995: 					int itemindex = rand()%3;
; 13996: 					int itemtype  = 0;
; 13997: 					if( itemindex == 0 ) itemtype = MAKE_ITEMNUM(12,0);
; 13998: 					else if( itemindex == 1 ) itemtype = MAKE_ITEMNUM(12,1);
; 13999: 					else if( itemindex == 2 ) itemtype = MAKE_ITEMNUM(12,2);
; 14000: 
; 14001: 	#ifdef CHAOS_MIX_WING_ITEMLEVEL_FIX
; 14002: 						ItemSerialCreateSend(lpObj->m_Index, 255, 0, 0, itemtype, 0, 255, Option1, Option2, Option3);
; 14003: 	#else
; 14004: 						ItemSerialCreateSend(lpObj->m_Index, 255, 0, 0, itemtype, level, 255, Option1, Option2, Option3);
; 14005: 	#endif	// #ifdef CHAOS_MIX_WING_ITEMLEVEL_FIX
; 14006: 				}
; 14007: 				else
; 14008: 				{
; 14009: 					int itemindex = rand()%3;
; 14010: 					int itemtype  = 0;
; 14011: 
; 14012: 					if( itemindex == 0 )      itemtype = MAKE_ITEMNUM(2,6);
; 14013: 					else if( itemindex == 1 ) itemtype = MAKE_ITEMNUM(4,6);
; 14014: 					else if( itemindex == 2 ) itemtype = MAKE_ITEMNUM(5,7);
; 14015: 					ItemSerialCreateSend(lpObj->m_Index, 255, 0, 0, itemtype, level, 255, Option1, Option2, Option3);
; 14016: 				}
; 14017: 			}
; 14018: 		}
; 14019: 		
; 14020: 		lpObj->Money -= lpObj->ChaosMoney;
; 14021: 		GCMoneySend(lpObj->m_Index, lpObj->Money);							
; 14022: 
; 14023: 		if( fail == TRUE )
; 14024: 		{
; 14025: 			g_MixSystem.ChaosBoxItemDown(lpObj);
; 14026: 			GCUserChaosBoxSend(lpObj);
; 14027: 			DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 14028: 			LogAddTD("[%s][%s] CBMix Fail %d Money : %d-%d", lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->Money, lpObj->ChaosMoney );		
; 14029: 			lpObj->ChaosLock = FALSE;
; 14030: 		}
; 14031: 		else 
; 14032: 		{
; 14033: 			LogAddTD("[%s][%s] CBMix Success Rate:%d Money : %d", lpObj->AccountID, lpObj->Name, lpObj->ChaosSuccessRate, lpObj->ChaosMoney);
; 14034: 		}
; 14035: 		if( gChaosEvent )
; 14036: 			g_MixSystem.CBUPS_ItemRequest(lpObj->m_Index, lpObj->AccountID, lpObj->Name);
; 14037: 	}	
; 14038: 	gObjInventoryCommit(lpObj->m_Index);
; 14039: //       
; 14040: #endif	// #ifdef CHAOS_MIX_UPGRADE
; 14041: }

  00244	5f		 pop	 edi
  00245	5e		 pop	 esi
  00246	5b		 pop	 ebx
  00247	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024a	33 cd		 xor	 ecx, ebp
  0024c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00251	8b e5		 mov	 esp, ebp
  00253	5d		 pop	 ebp
  00254	c3		 ret	 0
  00255	0f 1f 00	 npad	 3
$LN22@CGChaosBox:
  00258	00 00 00 00	 DD	 $LN16@CGChaosBox
  0025c	00 00 00 00	 DD	 $LN7@CGChaosBox
  00260	00 00 00 00	 DD	 $LN8@CGChaosBox
  00264	00 00 00 00	 DD	 $LN9@CGChaosBox
  00268	00 00 00 00	 DD	 $LN12@CGChaosBox
  0026c	00 00 00 00	 DD	 $LN13@CGChaosBox
  00270	00 00 00 00	 DD	 $LN14@CGChaosBox
  00274	00 00 00 00	 DD	 $LN15@CGChaosBox
  00278	00 00 00 00	 DD	 $LN17@CGChaosBox
  0027c	00 00 00 00	 DD	 $LN18@CGChaosBox
  00280	00 00 00 00	 DD	 $LN10@CGChaosBox
  00284	00 00 00 00	 DD	 $LN11@CGChaosBox
  00288	00 00 00 00	 DD	 $LN19@CGChaosBox
$LN21@CGChaosBox:
  0028c	00		 DB	 0
  0028d	01		 DB	 1
  0028e	02		 DB	 2
  0028f	03		 DB	 3
  00290	04		 DB	 4
  00291	05		 DB	 5
  00292	06		 DB	 6
  00293	07		 DB	 7
  00294	0c		 DB	 12			; 0000000cH
  00295	0c		 DB	 12			; 0000000cH
  00296	00		 DB	 0
  00297	0c		 DB	 12			; 0000000cH
  00298	08		 DB	 8
  00299	09		 DB	 9
  0029a	0c		 DB	 12			; 0000000cH
  0029b	0c		 DB	 12			; 0000000cH
  0029c	0c		 DB	 12			; 0000000cH
  0029d	0c		 DB	 12			; 0000000cH
  0029e	0c		 DB	 12			; 0000000cH
  0029f	0c		 DB	 12			; 0000000cH
  002a0	0c		 DB	 12			; 0000000cH
  002a1	0a		 DB	 10			; 0000000aH
  002a2	0b		 DB	 11			; 0000000bH
  002a3	06		 DB	 6
?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ENDP ; CGChaosBoxItemMixButtonClick
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_money$ = 16						; size = 4
_wmoney$ = 20						; size = 4
?GCWarehouseInventoryMoneySend@@YAXHEHH@Z PROC		; GCWarehouseInventoryMoneySend, COMDAT

; 13224: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 13225: 	PMSG_MONEY	pMsg;
; 13226: 
; 13227: 	PHeadSetB((LPBYTE)&pMsg, 0x81, sizeof( pMsg ));

  00013	6a 0c		 push	 12			; 0000000cH
  00015	68 81 00 00 00	 push	 129			; 00000081H
  0001a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13228: 	pMsg.Result     = result;

  00026	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00029	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 13229: 	pMsg.iMoney		= money; 

  0002c	8b 45 10	 mov	 eax, DWORD PTR _money$[ebp]
  0002f	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 13230: 	pMsg.wMoney		= wmoney;

  00032	8b 45 14	 mov	 eax, DWORD PTR _wmoney$[ebp]
  00035	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 13231: 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00038	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0003c	50		 push	 eax
  0003d	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13232: }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00053	33 cd		 xor	 ecx, ebp
  00055	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ENDP		; GCWarehouseInventoryMoneySend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z
_TEXT	SEGMENT
tv147 = -348						; size = 4
_msg$1 = -280						; size = 255
_oldmoney$2 = -24					; size = 4
_oldmoney$3 = -20					; size = 4
_rZen$4 = -16						; size = 4
_lpObj$ = -12						; size = 4
_money$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z PROC ; CGWarehouseMoneyInOut, COMDAT

; 13096: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 13097: 	int money=0;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _money$[ebp], 0

; 13098: 	if( gObjIsConnected(aIndex) == FALSE ) 

  0001d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 35		 jne	 SHORT $LN4@CGWarehous

; 13099: 	{
; 13100: 		LogAddC(LOGC_RED, "error-L3 [%s][%d]", __FILE__,__LINE__);

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z@4JA
  00032	83 c0 04	 add	 eax, 4
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
  00040	6a 02		 push	 2
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 13101: 		GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  0005a	83 c4 10	 add	 esp, 16			; 00000010H

; 13102: 		return;

  0005d	e9 12 04 00 00	 jmp	 $LN1@CGWarehous
$LN4@CGWarehous:

; 13103: 	}
; 13104: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00062	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00069	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006f	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 13105: 	money = lpMsg->Money;

  00072	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00075	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00078	89 4d f8	 mov	 DWORD PTR _money$[ebp], ecx

; 13106: 
; 13107: 	if( lpObj->m_IfState.state == 0 )

  0007b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007e	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00084	c0 e9 02	 shr	 cl, 2
  00087	80 e1 03	 and	 cl, 3
  0008a	0f b6 d1	 movzx	 edx, cl
  0008d	85 d2		 test	 edx, edx
  0008f	75 17		 jne	 SHORT $LN5@CGWarehous

; 13108: 	{
; 13109: 		GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  00091	6a 00		 push	 0
  00093	6a 00		 push	 0
  00095	6a 00		 push	 0
  00097	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  000a0	83 c4 10	 add	 esp, 16			; 00000010H

; 13110: 		return;

  000a3	e9 cc 03 00 00	 jmp	 $LN1@CGWarehous
$LN5@CGWarehous:

; 13111: 	}
; 13112: 
; 13113: #ifdef TRADE_BUG_FIX_CLOSE_WINDOWS_20040727
; 13114: 	if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_WAREHOUSE ) 

  000a8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ab	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000b1	80 e1 03	 and	 cl, 3
  000b4	0f b6 d1	 movzx	 edx, cl
  000b7	83 fa 01	 cmp	 edx, 1
  000ba	7c 17		 jl	 SHORT $LN7@CGWarehous
  000bc	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bf	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000c5	c0 e9 04	 shr	 cl, 4
  000c8	80 e1 0f	 and	 cl, 15			; 0000000fH
  000cb	0f b6 d1	 movzx	 edx, cl
  000ce	83 fa 06	 cmp	 edx, 6
  000d1	74 49		 je	 SHORT $LN6@CGWarehous
$LN7@CGWarehous:

; 13115: 	{
; 13116: 		GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  000d3	6a 00		 push	 0
  000d5	6a 00		 push	 0
  000d7	6a 00		 push	 0
  000d9	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  000e2	83 c4 10	 add	 esp, 16			; 00000010H

; 13117: 		LogAdd("[%s][%s] error-L1 : used not Warehouse", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000e5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f2	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000f6	52		 push	 edx
  000f7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00104	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00108	52		 push	 edx
  00109	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Wa@
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13118: 		return;

  00117	e9 58 03 00 00	 jmp	 $LN1@CGWarehous
$LN6@CGWarehous:

; 13119: 	}
; 13120: #endif
; 13121: 
; 13122: 	switch( lpMsg->Type )

  0011c	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0011f	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00122	88 8d a4 fe ff
	ff		 mov	 BYTE PTR tv147[ebp], cl
  00128	80 bd a4 fe ff
	ff 00		 cmp	 BYTE PTR tv147[ebp], 0
  0012f	74 12		 je	 SHORT $LN8@CGWarehous
  00131	80 bd a4 fe ff
	ff 01		 cmp	 BYTE PTR tv147[ebp], 1
  00138	0f 84 aa 00 00
	00		 je	 $LN13@CGWarehous
  0013e	e9 e6 02 00 00	 jmp	 $LN23@CGWarehous
$LN8@CGWarehous:

; 13123: 	{
; 13124: 	case 0 :	// 
; 13125: 		if( money <= 0 || money > 100000000 )

  00143	83 7d f8 00	 cmp	 DWORD PTR _money$[ebp], 0
  00147	7e 09		 jle	 SHORT $LN10@CGWarehous
  00149	81 7d f8 00 e1
	f5 05		 cmp	 DWORD PTR _money$[ebp], 100000000 ; 05f5e100H
  00150	7e 17		 jle	 SHORT $LN9@CGWarehous
$LN10@CGWarehous:

; 13126: 		{
; 13127: 			GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  00152	6a 00		 push	 0
  00154	6a 00		 push	 0
  00156	6a 00		 push	 0
  00158	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00161	83 c4 10	 add	 esp, 16			; 00000010H

; 13128: 			return;

  00164	e9 0b 03 00 00	 jmp	 $LN1@CGWarehous
$LN9@CGWarehous:

; 13129: 		}		
; 13130: 		// 1    ..
; 13131: 		if( (lpObj->WarehouseMoney+money > 100000000)  )

  00169	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016c	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00172	03 4d f8	 add	 ecx, DWORD PTR _money$[ebp]
  00175	81 f9 00 e1 f5
	05		 cmp	 ecx, 100000000		; 05f5e100H
  0017b	7e 17		 jle	 SHORT $LN11@CGWarehous

; 13132: 		{
; 13133: 			GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  0017d	6a 00		 push	 0
  0017f	6a 00		 push	 0
  00181	6a 00		 push	 0
  00183	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  0018c	83 c4 10	 add	 esp, 16			; 00000010H

; 13134: 			return;

  0018f	e9 e0 02 00 00	 jmp	 $LN1@CGWarehous
$LN11@CGWarehous:

; 13135: 		}
; 13136: 		//    .
; 13137: 		if( money > lpObj->Money )

  00194	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00197	8b 4d f8	 mov	 ecx, DWORD PTR _money$[ebp]
  0019a	3b 88 b0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+176]
  001a0	7e 17		 jle	 SHORT $LN12@CGWarehous

; 13138: 		{
; 13139: 			GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  001a2	6a 00		 push	 0
  001a4	6a 00		 push	 0
  001a6	6a 00		 push	 0
  001a8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  001b1	83 c4 10	 add	 esp, 16			; 00000010H

; 13140: 			return;

  001b4	e9 bb 02 00 00	 jmp	 $LN1@CGWarehous
$LN12@CGWarehous:

; 13141: 		}
; 13142: 		lpObj->Money -= money;

  001b9	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bc	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  001c2	2b 4d f8	 sub	 ecx, DWORD PTR _money$[ebp]
  001c5	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001c8	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 13143: 		lpObj->WarehouseMoney += money;

  001ce	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d1	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  001d7	03 4d f8	 add	 ecx, DWORD PTR _money$[ebp]
  001da	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001dd	89 8a a4 0c 00
	00		 mov	 DWORD PTR [edx+3236], ecx

; 13144: 		break;

  001e3	e9 55 02 00 00	 jmp	 $LN2@CGWarehous
$LN13@CGWarehous:

; 13145: 	case 1 :	// 
; 13146: 		{	
; 13147: 			if( bCanWarehouseLock == TRUE )

  001e8	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  001ef	75 47		 jne	 SHORT $LN14@CGWarehous

; 13148: 			{
; 13149: 				if( lpObj->WarehouseLock == 1 )

  001f1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f4	0f b6 88 a0 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3232]
  001fb	83 f9 01	 cmp	 ecx, 1
  001fe	75 38		 jne	 SHORT $LN14@CGWarehous

; 13150: 				{
; 13151: 					GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  00200	6a 00		 push	 0
  00202	6a 00		 push	 0
  00204	6a 00		 push	 0
  00206	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  0020f	83 c4 10	 add	 esp, 16			; 00000010H

; 13152: 					GCServerMsgStringSend(lMsg.Get(1606), lpObj->m_Index, 1);	

  00212	6a 01		 push	 1
  00214	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00217	8b 08		 mov	 ecx, DWORD PTR [eax]
  00219	51		 push	 ecx
  0021a	68 46 06 00 00	 push	 1606			; 00000646H
  0021f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0022a	50		 push	 eax
  0022b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00230	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13153: 					return;

  00233	e9 3c 02 00 00	 jmp	 $LN1@CGWarehous
$LN14@CGWarehous:

; 13154: 				}
; 13155: 			}
; 13156: 
; 13157: 			if( money <= 0 || money > 100000000 )

  00238	83 7d f8 00	 cmp	 DWORD PTR _money$[ebp], 0
  0023c	7e 09		 jle	 SHORT $LN17@CGWarehous
  0023e	81 7d f8 00 e1
	f5 05		 cmp	 DWORD PTR _money$[ebp], 100000000 ; 05f5e100H
  00245	7e 17		 jle	 SHORT $LN16@CGWarehous
$LN17@CGWarehous:

; 13158: 			{
; 13159: 				GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  00247	6a 00		 push	 0
  00249	6a 00		 push	 0
  0024b	6a 00		 push	 0
  0024d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00250	50		 push	 eax
  00251	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00256	83 c4 10	 add	 esp, 16			; 00000010H

; 13160: 				return;

  00259	e9 16 02 00 00	 jmp	 $LN1@CGWarehous
$LN16@CGWarehous:

; 13161: 			}
; 13162: 			if( money > lpObj->WarehouseMoney )

  0025e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00261	8b 4d f8	 mov	 ecx, DWORD PTR _money$[ebp]
  00264	3b 88 a4 0c 00
	00		 cmp	 ecx, DWORD PTR [eax+3236]
  0026a	7e 17		 jle	 SHORT $LN18@CGWarehous

; 13163: 			{
; 13164: 				GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  0026c	6a 00		 push	 0
  0026e	6a 00		 push	 0
  00270	6a 00		 push	 0
  00272	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00275	50		 push	 eax
  00276	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  0027b	83 c4 10	 add	 esp, 16			; 00000010H

; 13165: 				return;

  0027e	e9 f1 01 00 00	 jmp	 $LN1@CGWarehous
$LN18@CGWarehous:

; 13166: 			}
; 13167: 			lpObj->WarehouseMoney -= money;

  00283	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00286	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  0028c	2b 4d f8	 sub	 ecx, DWORD PTR _money$[ebp]
  0028f	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00292	89 8a a4 0c 00
	00		 mov	 DWORD PTR [edx+3236], ecx

; 13168: 			lpObj->Money += money;

  00298	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029b	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  002a1	03 4d f8	 add	 ecx, DWORD PTR _money$[ebp]
  002a4	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002a7	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 13169: 
; 13170: 			//    
; 13171: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//  -   
; 13172: 			int  rZen = GetWarehouseUsedHowMuch( lpObj->Level, lpObj->m_nMasterLevel, lpObj->WarehousePW );
; 13173: #else
; 13174: 			int  rZen = GetWarehouseUsedHowMuch(lpObj->Level, lpObj->WarehousePW);

  002ad	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b0	0f bf 88 9e 0c
	00 00		 movsx	 ecx, WORD PTR [eax+3230]
  002b7	51		 push	 ecx
  002b8	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002bb	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  002c2	50		 push	 eax
  002c3	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHH@Z ; GetWarehouseUsedHowMuch
  002c8	83 c4 08	 add	 esp, 8
  002cb	89 45 f0	 mov	 DWORD PTR _rZen$4[ebp], eax

; 13175: #endif
; 13176: 
; 13177: 			
; 13178: #ifdef MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 13179: 			if( lpObj->Money-rZen >= 0 )

  002ce	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d1	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  002d7	2b 4d f0	 sub	 ecx, DWORD PTR _rZen$4[ebp]
  002da	78 5e		 js	 SHORT $LN19@CGWarehous

; 13180: #else // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 13181: 			if( lpObj->Money-rZen > 0 )
; 13182: #endif // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 13183: 			{
; 13184: 				int oldmoney=lpObj->Money;

  002dc	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002df	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  002e5	89 4d ec	 mov	 DWORD PTR _oldmoney$3[ebp], ecx

; 13185: 				lpObj->Money -= rZen;

  002e8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002eb	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  002f1	2b 4d f0	 sub	 ecx, DWORD PTR _rZen$4[ebp]
  002f4	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002f7	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 13186: 				GCMoneySend(lpObj->m_Index, lpObj->Money);

  002fd	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00300	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00306	51		 push	 ecx
  00307	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0030a	8b 02		 mov	 eax, DWORD PTR [edx]
  0030c	50		 push	 eax
  0030d	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00312	83 c4 08	 add	 esp, 8

; 13187: 				LogAdd("Get WareHouse Money(In Inventory) : %d - %d = %d", oldmoney, rZen, lpObj->Money);

  00315	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00318	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0031e	51		 push	 ecx
  0031f	8b 55 f0	 mov	 edx, DWORD PTR _rZen$4[ebp]
  00322	52		 push	 edx
  00323	8b 45 ec	 mov	 eax, DWORD PTR _oldmoney$3[ebp]
  00326	50		 push	 eax
  00327	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventor@
  0032c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00332	83 c4 10	 add	 esp, 16			; 00000010H

; 13188: 			}

  00335	e9 ed 00 00 00	 jmp	 $LN20@CGWarehous
$LN19@CGWarehous:

; 13189: #ifdef MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 13190: 			else if( lpObj->WarehouseMoney-rZen >= 0 )

  0033a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033d	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00343	2b 4d f0	 sub	 ecx, DWORD PTR _rZen$4[ebp]
  00346	78 65		 js	 SHORT $LN21@CGWarehous

; 13191: #else // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 13192: 			else if( lpObj->WarehouseMoney-rZen > 0 )
; 13193: #endif // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 13194: 			{
; 13195: 				int oldmoney=lpObj->WarehouseMoney;

  00348	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034b	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00351	89 4d e8	 mov	 DWORD PTR _oldmoney$2[ebp], ecx

; 13196: 				lpObj->WarehouseMoney -= rZen;

  00354	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00357	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  0035d	2b 4d f0	 sub	 ecx, DWORD PTR _rZen$4[ebp]
  00360	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00363	89 8a a4 0c 00
	00		 mov	 DWORD PTR [edx+3236], ecx

; 13197: 				LogAdd("Get WareHouse Money(In WareHouse) : %d - %d = %d", oldmoney, rZen, lpObj->WarehouseMoney);

  00369	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0036c	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00372	51		 push	 ecx
  00373	8b 55 f0	 mov	 edx, DWORD PTR _rZen$4[ebp]
  00376	52		 push	 edx
  00377	8b 45 e8	 mov	 eax, DWORD PTR _oldmoney$2[ebp]
  0037a	50		 push	 eax
  0037b	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHous@
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00386	83 c4 10	 add	 esp, 16			; 00000010H

; 13198: 				GCWarehouseInventoryMoneySend(aIndex, 0x01, lpObj->Money, lpObj->WarehouseMoney);

  00389	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0038c	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00392	51		 push	 ecx
  00393	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00396	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  0039c	50		 push	 eax
  0039d	6a 01		 push	 1
  0039f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  003a2	51		 push	 ecx
  003a3	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  003a8	83 c4 10	 add	 esp, 16			; 00000010H

; 13199: 			}

  003ab	eb 7a		 jmp	 SHORT $LN20@CGWarehous
$LN21@CGWarehous:

; 13200: 			else
; 13201: 			{
; 13202: 				lpObj->WarehouseMoney += money;

  003ad	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b0	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  003b6	03 4d f8	 add	 ecx, DWORD PTR _money$[ebp]
  003b9	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003bc	89 8a a4 0c 00
	00		 mov	 DWORD PTR [edx+3236], ecx

; 13203: 				lpObj->Money -= money;

  003c2	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c5	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  003cb	2b 4d f8	 sub	 ecx, DWORD PTR _money$[ebp]
  003ce	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003d1	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 13204: 				GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  003d7	6a 00		 push	 0
  003d9	6a 00		 push	 0
  003db	6a 00		 push	 0
  003dd	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003e0	50		 push	 eax
  003e1	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  003e6	83 c4 10	 add	 esp, 16			; 00000010H

; 13205: 
; 13206: 				char msg[255];
; 13207: 				wsprintf(msg, lMsg.Get(1605), rZen);

  003e9	8b 45 f0	 mov	 eax, DWORD PTR _rZen$4[ebp]
  003ec	50		 push	 eax
  003ed	68 45 06 00 00	 push	 1605			; 00000645H
  003f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003fd	50		 push	 eax
  003fe	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _msg$1[ebp]
  00404	51		 push	 ecx
  00405	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0040b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13208: 				GCServerMsgStringSend(msg, lpObj->m_Index, 1);

  0040e	6a 01		 push	 1
  00410	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00413	8b 08		 mov	 ecx, DWORD PTR [eax]
  00415	51		 push	 ecx
  00416	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _msg$1[ebp]
  0041c	52		 push	 edx
  0041d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00422	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13209: 				return;

  00425	eb 4d		 jmp	 SHORT $LN1@CGWarehous
$LN20@CGWarehous:

; 13210: 			}
; 13211: 		}
; 13212: 		break;

  00427	eb 14		 jmp	 SHORT $LN2@CGWarehous
$LN23@CGWarehous:

; 13213: 	default :
; 13214: 		GCWarehouseInventoryMoneySend(aIndex, 0x00, 0,0);

  00429	6a 00		 push	 0
  0042b	6a 00		 push	 0
  0042d	6a 00		 push	 0
  0042f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00432	50		 push	 eax
  00433	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00438	83 c4 10	 add	 esp, 16			; 00000010H

; 13215: 		return;

  0043b	eb 37		 jmp	 SHORT $LN1@CGWarehous
$LN2@CGWarehous:

; 13216: 	}
; 13217: 
; 13218: 	lpObj->WarehouseCount++;

  0043d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00440	8a 88 9c 0c 00
	00		 mov	 cl, BYTE PTR [eax+3228]
  00446	80 c1 01	 add	 cl, 1
  00449	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0044c	88 8a 9c 0c 00
	00		 mov	 BYTE PTR [edx+3228], cl

; 13219: 	GCWarehouseInventoryMoneySend(aIndex, 0x01, lpObj->Money, lpObj->WarehouseMoney);

  00452	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00455	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  0045b	51		 push	 ecx
  0045c	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0045f	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00465	50		 push	 eax
  00466	6a 01		 push	 1
  00468	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0046b	51		 push	 ecx
  0046c	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00471	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@CGWarehous:

; 13220: }

  00474	5f		 pop	 edi
  00475	5e		 pop	 esi
  00476	5b		 pop	 ebx
  00477	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0047a	33 cd		 xor	 ecx, ebp
  0047c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00481	8b e5		 mov	 esp, ebp
  00483	5d		 pop	 ebp
  00484	c3		 ret	 0
?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ENDP ; CGWarehouseMoneyInOut
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z
_TEXT	SEGMENT
tv66 = -68						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z PROC	; CGClientCloseMsg, COMDAT

; 3292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3293 : 	switch( lpMsg->Flag )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0000f	88 4d bc	 mov	 BYTE PTR tv66[ebp], cl
  00012	80 7d bc 00	 cmp	 BYTE PTR tv66[ebp], 0
  00016	74 19		 je	 SHORT $LN4@CGClientCl
  00018	80 7d bc 01	 cmp	 BYTE PTR tv66[ebp], 1
  0001c	0f 84 79 02 00
	00		 je	 $LN14@CGClientCl
  00022	80 7d bc 02	 cmp	 BYTE PTR tv66[ebp], 2
  00026	0f 84 3a 01 00
	00		 je	 $LN9@CGClientCl
  0002c	e9 97 03 00 00	 jmp	 $LN1@CGClientCl
$LN4@CGClientCl:

; 3294 : 	{
; 3295 : 	case 0x00 :	// 5  
; 3296 : 		gObjCloseSet(aIndex, CL_EXIT);		

  00031	6a 00		 push	 0
  00033	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  0003c	83 c4 08	 add	 esp, 8

; 3297 : 
; 3298 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 3299 : 		if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) return ;

  0003f	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00043	7c 09		 jl	 SHORT $LN6@CGClientCl
  00045	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0004c	7e 05		 jle	 SHORT $LN5@CGClientCl
$LN6@CGClientCl:
  0004e	e9 75 03 00 00	 jmp	 $LN1@CGClientCl
$LN5@CGClientCl:

; 3300 : 		LogAddTD_TempLog(", [UserSelClose] Go Exit, Account [%s], IP [%s], Name [%s], Map:[%d][%d/%d]",

  00053	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00060	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  00068	52		 push	 edx
  00069	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00076	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  0007e	52		 push	 edx
  0007f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00086	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00094	52		 push	 edx
  00095	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a2	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000a6	52		 push	 edx
  000a7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b4	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  000b8	52		 push	 edx
  000b9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c6	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000ca	52		 push	 edx
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@KAGGFAIG@?0?5?$FLUserSelClose?$FN?5Go?5Exit?0?5Accou@
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  000d6	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3301 : 			gObj[aIndex].AccountID, gObj[aIndex].Ip_addr, gObj[aIndex].Name,
; 3302 : 			gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 3303 : #endif
; 3304 : 
; 3305 : #ifdef ADD_LOG_USER_CLOSE_SET
; 3306 : 		if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) return ;

  000d9	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  000dd	7c 09		 jl	 SHORT $LN8@CGClientCl
  000df	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  000e6	7e 05		 jle	 SHORT $LN7@CGClientCl
$LN8@CGClientCl:
  000e8	e9 db 02 00 00	 jmp	 $LN1@CGClientCl
$LN7@CGClientCl:

; 3307 : 		LogAddTD("[UserSelClose] Go Exit [%s][%s] Map:[%d][%d/%d]", 

  000ed	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fa	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  00102	52		 push	 edx
  00103	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00110	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00118	52		 push	 edx
  00119	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00126	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0012e	52		 push	 edx
  0012f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00136	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013c	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00140	52		 push	 edx
  00141	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014e	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00152	52		 push	 edx
  00153	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0015e	83 c4 18	 add	 esp, 24			; 00000018H

; 3308 : 				 gObj[aIndex].AccountID, gObj[aIndex].Name,
; 3309 : 				 gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 3310 : #endif
; 3311 : 		break;	

  00161	e9 62 02 00 00	 jmp	 $LN1@CGClientCl
$LN9@CGClientCl:

; 3312 : 	case 0x02 :	//  
; 3313 : 		gObjCloseSet(aIndex, CL_SERVERLIST);

  00166	6a 02		 push	 2
  00168	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  00171	83 c4 08	 add	 esp, 8

; 3314 : 
; 3315 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 3316 : 		if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) 

  00174	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00178	7c 09		 jl	 SHORT $LN11@CGClientCl
  0017a	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00181	7e 05		 jle	 SHORT $LN10@CGClientCl
$LN11@CGClientCl:

; 3317 : 			return ;

  00183	e9 40 02 00 00	 jmp	 $LN1@CGClientCl
$LN10@CGClientCl:

; 3318 : 		
; 3319 : 		LogAddTD_TempLog(", [UserSelClose] Go ServerList, Account [%s], IP [%s], Name [%s], Map:[%d][%d/%d]", 

  00188	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0018f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00195	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  0019d	52		 push	 edx
  0019e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ab	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  001b3	52		 push	 edx
  001b4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c1	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001c9	52		 push	 edx
  001ca	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d7	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001db	52		 push	 edx
  001dc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e9	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  001ed	52		 push	 edx
  001ee	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001fb	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001ff	52		 push	 edx
  00200	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@GOGPDPOG@?0?5?$FLUserSelClose?$FN?5Go?5ServerList?0@
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  0020b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3320 : 			gObj[aIndex].AccountID, gObj[aIndex].Ip_addr, gObj[aIndex].Name,
; 3321 : 			gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 3322 : #endif
; 3323 : 
; 3324 : #ifdef ADD_LOG_USER_CLOSE_SET
; 3325 : 		if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) return ;

  0020e	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00212	7c 09		 jl	 SHORT $LN13@CGClientCl
  00214	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0021b	7e 05		 jle	 SHORT $LN12@CGClientCl
$LN13@CGClientCl:
  0021d	e9 a6 01 00 00	 jmp	 $LN1@CGClientCl
$LN12@CGClientCl:

; 3326 : 
; 3327 : 		LogAddTD("[UserSelClose] Go ServerList [%s][%s] Map:[%d][%d/%d]", 

  00222	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0022f	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  00237	52		 push	 edx
  00238	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0023f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00245	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  0024d	52		 push	 edx
  0024e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00255	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0025b	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00263	52		 push	 edx
  00264	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0026b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00271	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00275	52		 push	 edx
  00276	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0027d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00283	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00287	52		 push	 edx
  00288	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CF@
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00293	83 c4 18	 add	 esp, 24			; 00000018H

; 3328 : 				 gObj[aIndex].AccountID, gObj[aIndex].Name,
; 3329 : 				 gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 3330 : #endif
; 3331 : 		break;	

  00296	e9 2d 01 00 00	 jmp	 $LN1@CGClientCl
$LN14@CGClientCl:

; 3332 : 	case 0x01 :	//   ..
; 3333 : 		gObjCloseSet(aIndex, CL_BACK);

  0029b	6a 01		 push	 1
  0029d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002a0	50		 push	 eax
  002a1	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  002a6	83 c4 08	 add	 esp, 8

; 3334 : 
; 3335 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 3336 : 		if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) return ;

  002a9	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  002ad	7c 09		 jl	 SHORT $LN16@CGClientCl
  002af	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  002b6	7e 05		 jle	 SHORT $LN15@CGClientCl
$LN16@CGClientCl:
  002b8	e9 0b 01 00 00	 jmp	 $LN1@CGClientCl
$LN15@CGClientCl:

; 3337 : 		LogAddTD_TempLog(", [UserSelClose] Go CharSelect, Account [%s], IP [%s], Name [%s], Map:[%d][%d/%d]", 

  002bd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ca	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  002d2	52		 push	 edx
  002d3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e0	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  002e8	52		 push	 edx
  002e9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f6	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  002fe	52		 push	 edx
  002ff	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0030c	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00310	52		 push	 edx
  00311	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00318	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0031e	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00322	52		 push	 edx
  00323	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0032a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00330	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00334	52		 push	 edx
  00335	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@IHIAOFPA@?0?5?$FLUserSelClose?$FN?5Go?5CharSelect?0@
  0033a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  00340	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3338 : 			gObj[aIndex].AccountID, gObj[aIndex].Ip_addr, gObj[aIndex].Name,
; 3339 : 			gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 3340 : #endif
; 3341 : 
; 3342 : 
; 3343 : #ifdef ADD_LOG_USER_CLOSE_SET
; 3344 : 		if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) return ;

  00343	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00347	7c 09		 jl	 SHORT $LN18@CGClientCl
  00349	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00350	7e 02		 jle	 SHORT $LN17@CGClientCl
$LN18@CGClientCl:
  00352	eb 74		 jmp	 SHORT $LN1@CGClientCl
$LN17@CGClientCl:

; 3345 : 		LogAddTD("[UserSelClose] Go CharSelect [%s][%s] Map:[%d][%d/%d]", 

  00354	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0035b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00361	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  00369	52		 push	 edx
  0036a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00371	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00377	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  0037f	52		 push	 edx
  00380	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00387	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0038d	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00395	52		 push	 edx
  00396	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0039d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a3	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  003a7	52		 push	 edx
  003a8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b5	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  003b9	52		 push	 edx
  003ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CF@
  003bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003c5	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@CGClientCl:

; 3346 : 				 gObj[aIndex].AccountID, gObj[aIndex].Name,
; 3347 : 				 gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 3348 : #endif
; 3349 : 		break;
; 3350 : 	}
; 3351 : }

  003c8	5f		 pop	 edi
  003c9	5e		 pop	 esi
  003ca	5b		 pop	 ebx
  003cb	8b e5		 mov	 esp, ebp
  003cd	5d		 pop	 ebp
  003ce	c3		 ret	 0
?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z ENDP	; CGClientCloseMsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z
_TEXT	SEGMENT
_number$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z PROC ; CGTradeOkButtonRecv, COMDAT

; 9591 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9592 : 	int number;	
; 9593 : 	
; 9594 : 	number = gObj[aIndex].TargetNumber;

  00009	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  0001e	89 55 fc	 mov	 DWORD PTR _number$[ebp], edx

; 9595 : 	if( number < 0 || number > MAX_OBJECT-1 ) return; 

  00021	83 7d fc 00	 cmp	 DWORD PTR _number$[ebp], 0
  00025	7c 09		 jl	 SHORT $LN3@CGTradeOkB
  00027	81 7d fc e7 1c
	00 00		 cmp	 DWORD PTR _number$[ebp], 7399 ; 00001ce7H
  0002e	7e 05		 jle	 SHORT $LN2@CGTradeOkB
$LN3@CGTradeOkB:
  00030	e9 b3 01 00 00	 jmp	 $LN1@CGTradeOkB
$LN2@CGTradeOkB:

; 9596 : 
; 9597 : 	//   .
; 9598 : 	if( gObjIsConnected(&gObj[number]) == FALSE ) return;	

  00035	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0003c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsConnected
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	75 05		 jne	 SHORT $LN4@CGTradeOkB
  0004f	e9 94 01 00 00	 jmp	 $LN1@CGTradeOkB
$LN4@CGTradeOkB:

; 9599 : 
; 9600 : 	//    
; 9601 : 	if( gObj[aIndex].m_IfState.use < 1 || gObj[aIndex].m_IfState.state != I_TRADE ) 

  00054	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00061	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00068	80 e2 03	 and	 dl, 3
  0006b	0f b6 c2	 movzx	 eax, dl
  0006e	83 f8 01	 cmp	 eax, 1
  00071	7c 22		 jl	 SHORT $LN6@CGTradeOkB
  00073	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00080	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00087	c0 ea 02	 shr	 dl, 2
  0008a	80 e2 03	 and	 dl, 3
  0008d	0f b6 c2	 movzx	 eax, dl
  00090	83 f8 01	 cmp	 eax, 1
  00093	74 05		 je	 SHORT $LN5@CGTradeOkB
$LN6@CGTradeOkB:

; 9602 : 		return;

  00095	e9 4e 01 00 00	 jmp	 $LN1@CGTradeOkB
$LN5@CGTradeOkB:

; 9603 : 	
; 9604 : 	//     
; 9605 : 	if( gObj[number].m_IfState.use < 1 || gObj[number].m_IfState.state != I_TRADE ) 

  0009a	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a7	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000ae	80 e2 03	 and	 dl, 3
  000b1	0f b6 c2	 movzx	 eax, dl
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	7c 22		 jl	 SHORT $LN8@CGTradeOkB
  000b9	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c6	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000cd	c0 ea 02	 shr	 dl, 2
  000d0	80 e2 03	 and	 dl, 3
  000d3	0f b6 c2	 movzx	 eax, dl
  000d6	83 f8 01	 cmp	 eax, 1
  000d9	74 05		 je	 SHORT $LN7@CGTradeOkB
$LN8@CGTradeOkB:

; 9606 : 		return;

  000db	e9 08 01 00 00	 jmp	 $LN1@CGTradeOkB
$LN7@CGTradeOkB:

; 9607 : 	
; 9608 : 	// ..
; 9609 : 	if( gObj[aIndex].CloseType != -1 )

  000e0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ed	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  000f2	83 fa ff	 cmp	 edx, -1
  000f5	74 05		 je	 SHORT $LN9@CGTradeOkB

; 9610 : 	{
; 9611 : 		return;

  000f7	e9 ec 00 00 00	 jmp	 $LN1@CGTradeOkB
$LN9@CGTradeOkB:

; 9612 : 	}
; 9613 : 	if( gObj[number].CloseType != -1 )

  000fc	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00109	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  0010e	83 fa ff	 cmp	 edx, -1
  00111	74 05		 je	 SHORT $LN10@CGTradeOkB

; 9614 : 	{
; 9615 : 		return;

  00113	e9 d0 00 00 00	 jmp	 $LN1@CGTradeOkB
$LN10@CGTradeOkB:

; 9616 : 	}
; 9617 : 
; 9618 : 	if( lpMsg->Flag == 0x01 )	// 

  00118	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0011b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0011f	83 f9 01	 cmp	 ecx, 1
  00122	75 70		 jne	 SHORT $LN11@CGTradeOkB

; 9619 : 	{	
; 9620 : 		if( gObj[aIndex].TradeOk == 0 ) 

  00124	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00131	0f b6 94 01 90
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3216]
  00139	85 d2		 test	 edx, edx
  0013b	75 55		 jne	 SHORT $LN13@CGTradeOkB

; 9621 : 		{
; 9622 : 			gObj[aIndex].TradeOk = 1;

  0013d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00144	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014a	c6 84 01 90 0c
	00 00 01	 mov	 BYTE PTR [ecx+eax+3216], 1

; 9623 : 			LogAddTD("[%s][%s] Trade Accept", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00152	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00159	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015f	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00163	52		 push	 edx
  00164	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00171	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00175	52		 push	 edx
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept@
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9624 : 			GCTradeOkButtonSend(number, 0x01);

  00184	6a 01		 push	 1
  00186	8b 45 fc	 mov	 eax, DWORD PTR _number$[ebp]
  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  0018f	83 c4 08	 add	 esp, 8
$LN13@CGTradeOkB:

; 9625 : 		}
; 9626 : 	}

  00192	eb 48		 jmp	 SHORT $LN12@CGTradeOkB
$LN11@CGTradeOkB:

; 9627 : 	else if( lpMsg->Flag == 0x00 ) //  

  00194	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00197	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0019b	85 c9		 test	 ecx, ecx
  0019d	75 3d		 jne	 SHORT $LN12@CGTradeOkB

; 9628 : 	{	
; 9629 : 		if( gObj[aIndex].TradeOk == 1 ) 

  0019f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ac	0f b6 94 01 90
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3216]
  001b4	83 fa 01	 cmp	 edx, 1
  001b7	75 23		 jne	 SHORT $LN12@CGTradeOkB

; 9630 : 		{
; 9631 : 			GCTradeOkButtonSend(number, 0x00);

  001b9	6a 00		 push	 0
  001bb	8b 45 fc	 mov	 eax, DWORD PTR _number$[ebp]
  001be	50		 push	 eax
  001bf	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  001c4	83 c4 08	 add	 esp, 8

; 9632 : 			gObj[aIndex].TradeOk = 0;

  001c7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d4	c6 84 01 90 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3216], 0
$LN12@CGTradeOkB:

; 9633 : 		}
; 9634 : 	}
; 9635 : 	gObjTradeOkButton(aIndex);

  001dc	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ?gObjTradeOkButton@@YAXH@Z ; gObjTradeOkButton
  001e5	83 c4 04	 add	 esp, 4
$LN1@CGTradeOkB:

; 9636 : }

  001e8	5f		 pop	 edi
  001e9	5e		 pop	 esi
  001ea	5b		 pop	 ebx
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c3		 ret	 0
?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ENDP ; CGTradeOkButtonRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCTradeOkButtonSend@@YAHHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_flag$ = 12						; size = 1
?GCTradeOkButtonSend@@YAHHE@Z PROC			; GCTradeOkButtonSend, COMDAT

; 9579 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9580 : 	PMSG_TRADE_OKBUTTON		pMsg;
; 9581 : 	
; 9582 : 	PHeadSetB((LPBYTE)&pMsg, 0x3C, sizeof( pMsg ));

  00009	6a 04		 push	 4
  0000b	6a 3c		 push	 60			; 0000003cH
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9583 : 	pMsg.Flag       = flag;

  00019	8a 45 0c	 mov	 al, BYTE PTR _flag$[ebp]
  0001c	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 9584 : 
; 9585 : 	return DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size );

  0001f	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00023	50		 push	 eax
  00024	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9586 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?GCTradeOkButtonSend@@YAHHE@Z ENDP			; GCTradeOkButtonSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCTradeMoneyOther@@YAHHK@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?GCTradeMoneyOther@@YAHHK@Z PROC			; GCTradeMoneyOther, COMDAT

; 9568 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9569 : 	PMSG_TRADE_OTHER_GOLD	pMsg;
; 9570 : 	
; 9571 : 	PHeadSetB((LPBYTE)&pMsg, 0x3B, sizeof( pMsg ));

  00009	6a 08		 push	 8
  0000b	6a 3b		 push	 59			; 0000003bH
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9572 : 
; 9573 : 	pMsg.Money		= money;

  00019	8b 45 0c	 mov	 eax, DWORD PTR _money$[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 9574 : 
; 9575 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00023	50		 push	 eax
  00024	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9576 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?GCTradeMoneyOther@@YAHHK@Z ENDP			; GCTradeMoneyOther
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z
_TEXT	SEGMENT
tv85 = -84						; size = 4
tv70 = -84						; size = 4
tv86 = -80						; size = 4
tv71 = -80						; size = 4
_n$1 = -12						; size = 4
_number$ = -8						; size = 4
_Result$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z PROC ; CGTradeResponseRecv, COMDAT

; 9226 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9227 : 	int Result=1;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 1

; 9228 : 	int number;
; 9229 : 	
; 9230 : 	number = gObj[aIndex].TargetNumber;

  00010	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00017	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001d	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  00025	89 55 f8	 mov	 DWORD PTR _number$[ebp], edx

; 9231 : 
; 9232 : 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  00028	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0002c	7d 09		 jge	 SHORT $LN36@CGTradeRes
  0002e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00035	eb 1f		 jmp	 SHORT $LN37@CGTradeRes
$LN36@CGTradeRes:
  00037	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0003e	7e 09		 jle	 SHORT $LN34@CGTradeRes
  00040	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00047	eb 07		 jmp	 SHORT $LN35@CGTradeRes
$LN34@CGTradeRes:
  00049	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
$LN35@CGTradeRes:
  00050	8b 45 ac	 mov	 eax, DWORD PTR tv70[ebp]
  00053	89 45 b0	 mov	 DWORD PTR tv71[ebp], eax
$LN37@CGTradeRes:
  00056	83 7d b0 00	 cmp	 DWORD PTR tv71[ebp], 0
  0005a	75 40		 jne	 SHORT $LN5@CGTradeRes

; 9233 : 	{
; 9234 : 		LogAdd("error-L1 : %d (A_ID:%s) %s %d",number, gObj[aIndex].AccountID, __FILE__, __LINE__);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z@4JA
  00061	83 c0 08	 add	 eax, 8
  00064	50		 push	 eax
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0006a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00071	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00077	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0007b	50		 push	 eax
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _number$[ebp]
  0007f	51		 push	 ecx
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd@
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0008b	83 c4 14	 add	 esp, 20			; 00000014H

; 9235 : 		Result = 0;

  0008e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 9236 : 		lpMsg->Response = 0x00;

  00095	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00098	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
$LN5@CGTradeRes:

; 9237 : 	}
; 9238 : 
; 9239 : 	if( !CHECK_LIMIT(number, MAX_OBJECT) )

  0009c	83 7d f8 00	 cmp	 DWORD PTR _number$[ebp], 0
  000a0	7d 09		 jge	 SHORT $LN40@CGTradeRes
  000a2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  000a9	eb 1f		 jmp	 SHORT $LN41@CGTradeRes
$LN40@CGTradeRes:
  000ab	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _number$[ebp], 7399 ; 00001ce7H
  000b2	7e 09		 jle	 SHORT $LN38@CGTradeRes
  000b4	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  000bb	eb 07		 jmp	 SHORT $LN39@CGTradeRes
$LN38@CGTradeRes:
  000bd	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
$LN39@CGTradeRes:
  000c4	8b 45 ac	 mov	 eax, DWORD PTR tv85[ebp]
  000c7	89 45 b0	 mov	 DWORD PTR tv86[ebp], eax
$LN41@CGTradeRes:
  000ca	83 7d b0 00	 cmp	 DWORD PTR tv86[ebp], 0
  000ce	0f 85 c8 00 00
	00		 jne	 $LN6@CGTradeRes

; 9240 : 	{	//   ...   .
; 9241 : 		if(gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_TRADE )

  000d4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e1	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000e8	80 e2 03	 and	 dl, 3
  000eb	0f b6 c2	 movzx	 eax, dl
  000ee	85 c0		 test	 eax, eax
  000f0	74 65		 je	 SHORT $LN7@CGTradeRes
  000f2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ff	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00106	c0 ea 04	 shr	 dl, 4
  00109	80 e2 0f	 and	 dl, 15			; 0000000fH
  0010c	0f b6 c2	 movzx	 eax, dl
  0010f	83 f8 01	 cmp	 eax, 1
  00112	75 43		 jne	 SHORT $LN7@CGTradeRes

; 9242 : 		{
; 9243 : 			gObj[aIndex].m_IfState.use = 0;

  00114	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0011b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00121	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00128	80 e2 fc	 and	 dl, 252			; 000000fcH
  0012b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00138	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 9244 : 			gObj[aIndex].TargetNumber  = -1;

  0013f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00146	83 c9 ff	 or	 ecx, -1
  00149	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014f	66 89 8c 02 ac
	02 00 00	 mov	 WORD PTR [edx+eax+684], cx
$LN7@CGTradeRes:

; 9245 : 		}
; 9246 : 		LogAdd("error-L1 : target:%d (A_ID:%s) %s %d",number, gObj[aIndex].AccountID, __FILE__, __LINE__);

  00157	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z@4JA
  0015c	83 c0 14	 add	 eax, 20			; 00000014H
  0015f	50		 push	 eax
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00165	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0016c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00172	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00176	50		 push	 eax
  00177	8b 4d f8	 mov	 ecx, DWORD PTR _number$[ebp]
  0017a	51		 push	 ecx
  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5@
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00186	83 c4 14	 add	 esp, 20			; 00000014H

; 9247 : 		Result = 0;

  00189	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 9248 : 		lpMsg->Response = 0x00;

  00190	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00193	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 9249 : 
; 9250 : #ifdef MODIFY_TARGETNUMBER_RECALLMON_INDEX_BUFGIX_20080711
; 9251 : 		return;

  00197	e9 f9 08 00 00	 jmp	 $LN1@CGTradeRes
$LN6@CGTradeRes:

; 9252 : #endif	// MODIFY_TARGETNUMBER_RECALLMON_INDEX_BUFGIX_20080711		
; 9253 : 	}
; 9254 : 	//    
; 9255 : 	if( gObjIsConnected(number) == FALSE ) 

  0019c	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  001a5	83 c4 04	 add	 esp, 4
  001a8	85 c0		 test	 eax, eax
  001aa	75 0e		 jne	 SHORT $LN8@CGTradeRes

; 9256 : 	{	
; 9257 : 		Result = 0;

  001ac	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 9258 : 		lpMsg->Response = 0x00;

  001b3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001b6	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
$LN8@CGTradeRes:

; 9259 : 	}	
; 9260 : 
; 9261 : 	if( gObj[aIndex].CloseType != -1 )

  001ba	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c7	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  001cc	83 fa ff	 cmp	 edx, -1
  001cf	74 0e		 je	 SHORT $LN9@CGTradeRes

; 9262 : 	{
; 9263 : 		Result = 0;

  001d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 9264 : 		lpMsg->Response = 0x00;

  001d8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001db	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
$LN9@CGTradeRes:

; 9265 : 	}
; 9266 : 
; 9267 : 
; 9268 : #ifdef PERSONAL_SHOP_20040113		//         .
; 9269 : 	if (gObj[aIndex].m_bPShopOpen == true) {

  001df	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ec	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  001f4	83 fa 01	 cmp	 edx, 1
  001f7	75 0e		 jne	 SHORT $LN10@CGTradeRes

; 9270 : 		Result = 0;

  001f9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 9271 : 		lpMsg->Response = 0x00;

  00200	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00203	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
$LN10@CGTradeRes:

; 9272 : 	}
; 9273 : 	if (gObj[number].m_bPShopOpen == true) {

  00207	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0020e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00214	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  0021c	83 fa 01	 cmp	 edx, 1
  0021f	75 0e		 jne	 SHORT $LN11@CGTradeRes

; 9274 : 		Result = 0;

  00221	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 9275 : 		lpMsg->Response = 0x00;

  00228	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0022b	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
$LN11@CGTradeRes:

; 9276 : 	}
; 9277 : #endif
; 9278 : 
; 9279 : 	
; 9280 : 	//      .
; 9281 : 	if( (gObj[aIndex].X < gObj[number].X-2) || (gObj[aIndex].X > gObj[number].X+2) || 
; 9282 : 		(gObj[aIndex].Y < gObj[number].Y-2) || (gObj[aIndex].Y > gObj[number].Y+2))

  0022f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023c	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00244	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0024b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00251	0f bf 84 01 04
	01 00 00	 movsx	 eax, WORD PTR [ecx+eax+260]
  00259	83 e8 02	 sub	 eax, 2
  0025c	3b d0		 cmp	 edx, eax
  0025e	0f 8c 93 00 00
	00		 jl	 $LN13@CGTradeRes
  00264	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0026b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00271	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00279	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00280	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00286	0f bf 84 01 04
	01 00 00	 movsx	 eax, WORD PTR [ecx+eax+260]
  0028e	83 c0 02	 add	 eax, 2
  00291	3b d0		 cmp	 edx, eax
  00293	7f 62		 jg	 SHORT $LN13@CGTradeRes
  00295	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0029c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a2	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  002aa	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b7	0f bf 84 01 06
	01 00 00	 movsx	 eax, WORD PTR [ecx+eax+262]
  002bf	83 e8 02	 sub	 eax, 2
  002c2	3b d0		 cmp	 edx, eax
  002c4	7c 31		 jl	 SHORT $LN13@CGTradeRes
  002c6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d3	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  002db	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e8	0f bf 84 01 06
	01 00 00	 movsx	 eax, WORD PTR [ecx+eax+262]
  002f0	83 c0 02	 add	 eax, 2
  002f3	3b d0		 cmp	 edx, eax
  002f5	7e 0e		 jle	 SHORT $LN12@CGTradeRes
$LN13@CGTradeRes:

; 9283 : 	{
; 9284 : 		Result = 0;

  002f7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 9285 : 		lpMsg->Response = 0x00;

  002fe	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00301	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
$LN12@CGTradeRes:

; 9286 : 	}
; 9287 : 
; 9288 : 
; 9289 : 	
; 9290 : 	if( !gObj[aIndex].m_IfState.use || gObj[aIndex].m_IfState.type != I_TRADE ||

  00305	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0030c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00312	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00319	80 e2 03	 and	 dl, 3
  0031c	0f b6 c2	 movzx	 eax, dl
  0031f	85 c0		 test	 eax, eax
  00321	74 43		 je	 SHORT $LN15@CGTradeRes
  00323	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0032a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00330	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00337	c0 ea 04	 shr	 dl, 4
  0033a	80 e2 0f	 and	 dl, 15			; 0000000fH
  0033d	0f b6 c2	 movzx	 eax, dl
  00340	83 f8 01	 cmp	 eax, 1
  00343	75 21		 jne	 SHORT $LN15@CGTradeRes
  00345	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0034c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00352	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00359	c0 ea 02	 shr	 dl, 2
  0035c	80 e2 03	 and	 dl, 3
  0035f	0f b6 c2	 movzx	 eax, dl
  00362	85 c0		 test	 eax, eax
  00364	74 6d		 je	 SHORT $LN14@CGTradeRes
$LN15@CGTradeRes:

; 9291 : 			gObj[aIndex].m_IfState.state != 0 )
; 9292 : 	{		
; 9293 : 		LogAddTD("(%s)(%s) Trade Interface State Error : use:%d type:%d",

  00366	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0036d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00373	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0037a	c0 ea 04	 shr	 dl, 4
  0037d	80 e2 0f	 and	 dl, 15			; 0000000fH
  00380	0f b6 c2	 movzx	 eax, dl
  00383	50		 push	 eax
  00384	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0038b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00391	8a 84 0a 56 0c
	00 00		 mov	 al, BYTE PTR [edx+ecx+3158]
  00398	24 03		 and	 al, 3
  0039a	0f b6 c8	 movzx	 ecx, al
  0039d	51		 push	 ecx
  0039e	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  003a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003aa	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  003ae	51		 push	 ecx
  003af	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  003b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003bb	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  003bf	51		 push	 ecx
  003c0	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5@
  003c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003cb	83 c4 14	 add	 esp, 20			; 00000014H

; 9294 : 				 gObj[aIndex].AccountID,
; 9295 : 				 gObj[aIndex].Name,
; 9296 : 				 gObj[aIndex].m_IfState.use,
; 9297 : 				 gObj[aIndex].m_IfState.type);
; 9298 : 		return;

  003ce	e9 c2 06 00 00	 jmp	 $LN1@CGTradeRes
$LN14@CGTradeRes:

; 9299 : 	}
; 9300 : 
; 9301 : 	if( !gObj[number].m_IfState.use || gObj[number].m_IfState.type != I_TRADE || 

  003d3	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  003da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003e0	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  003e7	80 e2 03	 and	 dl, 3
  003ea	0f b6 c2	 movzx	 eax, dl
  003ed	85 c0		 test	 eax, eax
  003ef	74 43		 je	 SHORT $LN17@CGTradeRes
  003f1	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  003f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003fe	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00405	c0 ea 04	 shr	 dl, 4
  00408	80 e2 0f	 and	 dl, 15			; 0000000fH
  0040b	0f b6 c2	 movzx	 eax, dl
  0040e	83 f8 01	 cmp	 eax, 1
  00411	75 21		 jne	 SHORT $LN17@CGTradeRes
  00413	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0041a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00420	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00427	c0 ea 02	 shr	 dl, 2
  0042a	80 e2 03	 and	 dl, 3
  0042d	0f b6 c2	 movzx	 eax, dl
  00430	85 c0		 test	 eax, eax
  00432	74 6d		 je	 SHORT $LN16@CGTradeRes
$LN17@CGTradeRes:

; 9302 : 		gObj[number].m_IfState.state != 0 )
; 9303 : 	{		
; 9304 : 		LogAddTD("(%s)(%s) Trade Interface State Error : use:%d type:%d",

  00434	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0043b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00441	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00448	c0 ea 04	 shr	 dl, 4
  0044b	80 e2 0f	 and	 dl, 15			; 0000000fH
  0044e	0f b6 c2	 movzx	 eax, dl
  00451	50		 push	 eax
  00452	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  00459	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0045f	8a 84 0a 56 0c
	00 00		 mov	 al, BYTE PTR [edx+ecx+3158]
  00466	24 03		 and	 al, 3
  00468	0f b6 c8	 movzx	 ecx, al
  0046b	51		 push	 ecx
  0046c	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _number$[ebp], 7072
  00473	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00478	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0047c	51		 push	 ecx
  0047d	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _number$[ebp], 7072
  00484	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00489	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  0048d	51		 push	 ecx
  0048e	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5@
  00493	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00499	83 c4 14	 add	 esp, 20			; 00000014H

; 9305 : 				 gObj[number].AccountID,
; 9306 : 				 gObj[number].Name,
; 9307 : 				 gObj[number].m_IfState.use,
; 9308 : 				 gObj[number].m_IfState.type);
; 9309 : 		return;

  0049c	e9 f4 05 00 00	 jmp	 $LN1@CGTradeRes
$LN16@CGTradeRes:

; 9310 : 	}	
; 9311 : 
; 9312 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719		//    -      
; 9313 : 	if (gObjFixInventoryPointer(aIndex) == false) {

  004a1	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004a4	50		 push	 eax
  004a5	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  004aa	83 c4 04	 add	 esp, 4
  004ad	0f b6 c8	 movzx	 ecx, al
  004b0	85 c9		 test	 ecx, ecx
  004b2	75 1c		 jne	 SHORT $LN18@CGTradeRes

; 9314 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  004b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z@4JA
  004b9	83 c0 58	 add	 eax, 88			; 00000058H
  004bc	50		 push	 eax
  004bd	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  004c2	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  004c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004cd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CGTradeRes:

; 9315 : 	}
; 9316 : #endif
; 9317 : 
; 9318 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//          .
; 9319 : 	if (gObj[aIndex].pTransaction == 1) {

  004d0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004dd	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  004e5	83 fa 01	 cmp	 edx, 1
  004e8	75 55		 jne	 SHORT $LN19@CGTradeRes

; 9320 : 		LogAddTD("[%s][%s] CGTradeResponseRecv() Failed : Transaction == 1, IF_TYPE : %d",

  004ea	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004f7	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  004fe	c0 ea 04	 shr	 dl, 4
  00501	80 e2 0f	 and	 dl, 15			; 0000000fH
  00504	0f b6 c2	 movzx	 eax, dl
  00507	50		 push	 eax
  00508	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0050f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00515	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00519	50		 push	 eax
  0051a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00521	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00527	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0052b	50		 push	 eax
  0052c	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5@
  00531	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00537	83 c4 10	 add	 esp, 16			; 00000010H

; 9321 : 			gObj[aIndex].AccountID,
; 9322 : 			gObj[aIndex].Name,
; 9323 : 			gObj[aIndex].m_IfState.type
; 9324 : 			);
; 9325 : 		return;

  0053a	e9 56 05 00 00	 jmp	 $LN1@CGTradeRes
$LN19@CGTradeRes:

; 9326 : 	}
; 9327 : #endif
; 9328 : 	
; 9329 : 	//    
; 9330 : 	//   
; 9331 : 
; 9332 : 	//     .
; 9333 : 	if( lpMsg->Response == 0x00 )

  0053f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00542	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00546	85 c9		 test	 ecx, ecx
  00548	75 36		 jne	 SHORT $LN20@CGTradeRes

; 9334 : 	{
; 9335 : 		GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name);

  0054a	6a 00		 push	 0
  0054c	6a 00		 push	 0
  0054e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00555	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0055b	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0055f	52		 push	 edx
  00560	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00563	50		 push	 eax
  00564	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00567	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0056b	52		 push	 edx
  0056c	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  00571	83 c4 14	 add	 esp, 20			; 00000014H

; 9336 : 		Result = 0;

  00574	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 9337 : 	}

  0057b	e9 8d 03 00 00	 jmp	 $LN21@CGTradeRes
$LN20@CGTradeRes:

; 9338 : 	else {
; 9339 : 		
; 9340 : 		//   		
; 9341 : #ifndef ITEMCOPY_BUGFIX_20040112
; 9342 : 		GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, gObj[aIndex].Level, gObj[aIndex].GuildNumber);		
; 9343 : 		GCTradeResponseSend(lpMsg->Response, aIndex, gObj[number].Name, gObj[number].Level, gObj[number].GuildNumber);
; 9344 : #endif
; 9345 : 		Result = 1;

  00580	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 1

; 9346 : 		for( int n=0; n<MAX_TRADEITEM; n++)

  00587	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0058e	eb 09		 jmp	 SHORT $LN4@CGTradeRes
$LN2@CGTradeRes:
  00590	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00593	83 c0 01	 add	 eax, 1
  00596	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@CGTradeRes:
  00599	83 7d f4 20	 cmp	 DWORD PTR _n$1[ebp], 32	; 00000020H
  0059d	7d 42		 jge	 SHORT $LN3@CGTradeRes

; 9347 : 		{
; 9348 : 			gObj[aIndex].Trade[n].Clear();

  0059f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005a6	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  005ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005b3	03 8c 02 84 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3204]
  005ba	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 9349 : 			gObj[number].Trade[n].Clear();

  005bf	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  005c6	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  005cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005d3	03 8c 02 84 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3204]
  005da	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 9350 : 		}

  005df	eb af		 jmp	 SHORT $LN2@CGTradeRes
$LN3@CGTradeRes:

; 9351 : 		memset(gObj[aIndex].TradeMap, 0xff, 4*8);

  005e1	6a 20		 push	 32			; 00000020H
  005e3	68 ff 00 00 00	 push	 255			; 000000ffH
  005e8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005f5	8b 94 01 88 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3208]
  005fc	52		 push	 edx
  005fd	e8 00 00 00 00	 call	 _memset
  00602	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9352 : 		memset(gObj[number].TradeMap, 0xff, 4*8);

  00605	6a 20		 push	 32			; 00000020H
  00607	68 ff 00 00 00	 push	 255			; 000000ffH
  0060c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00613	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00619	8b 94 01 88 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3208]
  00620	52		 push	 edx
  00621	e8 00 00 00 00	 call	 _memset
  00626	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9353 : 
; 9354 : 		gObj[aIndex].m_IfState.state = 1;

  00629	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00630	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00636	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0063d	80 e2 f3	 and	 dl, 243			; 000000f3H
  00640	80 ca 04	 or	 dl, 4
  00643	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0064a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00650	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 9355 : 		gObj[number].m_IfState.state = 1;

  00657	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0065e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00664	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0066b	80 e2 f3	 and	 dl, 243			; 000000f3H
  0066e	80 ca 04	 or	 dl, 4
  00671	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00678	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0067e	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 9356 : 		gObj[aIndex].TradeMoney      = 0;

  00685	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0068c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00692	c7 84 01 8c 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3212], 0

; 9357 : 		gObj[number].TradeMoney      = 0;

  0069d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  006a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006aa	c7 84 01 8c 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3212], 0

; 9358 : #ifdef ITEMCOPY_BUGFIX_20040112
; 9359 : 		if (gObjInventoryTrans(aIndex) == FALSE)

  006b5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006b8	50		 push	 eax
  006b9	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  006be	83 c4 04	 add	 esp, 4
  006c1	85 c0		 test	 eax, eax
  006c3	75 07		 jne	 SHORT $LN22@CGTradeRes

; 9360 : 			Result = 2;

  006c5	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 2
$LN22@CGTradeRes:

; 9361 : 		if (gObjInventoryTrans(number) == FALSE)

  006cc	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  006cf	50		 push	 eax
  006d0	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  006d5	83 c4 04	 add	 esp, 4
  006d8	85 c0		 test	 eax, eax
  006da	75 07		 jne	 SHORT $LN23@CGTradeRes

; 9362 : 			Result = 3;

  006dc	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 3
$LN23@CGTradeRes:

; 9363 : 
; 9364 : 		if (Result != 1) {	//    (  OK  )	P.S.>        

  006e3	83 7d fc 01	 cmp	 DWORD PTR _Result$[ebp], 1
  006e7	0f 84 21 01 00
	00		 je	 $LN24@CGTradeRes

; 9365 : 			lpMsg->Response = 0x00;		//   

  006ed	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006f0	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 9366 : 			GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name);

  006f4	6a 00		 push	 0
  006f6	6a 00		 push	 0
  006f8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00705	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00709	52		 push	 edx
  0070a	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0070d	50		 push	 eax
  0070e	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00711	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00715	52		 push	 edx
  00716	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  0071b	83 c4 14	 add	 esp, 20			; 00000014H

; 9367 : 			GCTradeResponseSend(lpMsg->Response, aIndex, gObj[number].Name);

  0071e	6a 00		 push	 0
  00720	6a 00		 push	 0
  00722	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00729	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0072f	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00733	52		 push	 edx
  00734	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00737	50		 push	 eax
  00738	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0073b	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0073f	52		 push	 edx
  00740	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  00745	83 c4 14	 add	 esp, 20			; 00000014H

; 9368 : 
; 9369 : 			if (Result == 2)

  00748	83 7d fc 02	 cmp	 DWORD PTR _Result$[ebp], 2
  0074c	75 58		 jne	 SHORT $LN26@CGTradeRes

; 9370 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[number].AccountID, gObj[number].Name);

  0074e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00755	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0075b	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0075f	52		 push	 edx
  00760	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00767	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0076d	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00771	52		 push	 edx
  00772	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00779	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0077f	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00783	52		 push	 edx
  00784	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0078b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00791	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00795	52		 push	 edx
  00796	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5T@
  0079b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  007a1	83 c4 14	 add	 esp, 20			; 00000014H
  007a4	eb 5c		 jmp	 SHORT $LN27@CGTradeRes
$LN26@CGTradeRes:

; 9371 : 			else if (Result == 3)

  007a6	83 7d fc 03	 cmp	 DWORD PTR _Result$[ebp], 3
  007aa	75 56		 jne	 SHORT $LN27@CGTradeRes

; 9372 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]", gObj[number].AccountID, gObj[number].Name, gObj[aIndex].AccountID, gObj[aIndex].Name);

  007ac	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007b9	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  007bd	52		 push	 edx
  007be	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007cb	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  007cf	52		 push	 edx
  007d0	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  007d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007dd	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  007e1	52		 push	 edx
  007e2	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  007e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007ef	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  007f3	52		 push	 edx
  007f4	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5T@
  007f9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  007ff	83 c4 14	 add	 esp, 20			; 00000014H
$LN27@CGTradeRes:

; 9373 : 			Result = 0;

  00802	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Result$[ebp], 0

; 9374 : 		}

  00809	e9 ff 00 00 00	 jmp	 $LN21@CGTradeRes
$LN24@CGTradeRes:

; 9375 : 		else {
; 9376 : 			lpMsg->Response = 1;

  0080e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00811	c6 40 03 01	 mov	 BYTE PTR [eax+3], 1

; 9377 : 			GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, gObj[aIndex].Level, gObj[aIndex].GuildNumber);		

  00815	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0081c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00822	8b 94 01 90 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+656]
  00829	52		 push	 edx
  0082a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00831	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00837	0f b7 94 01 a0
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+160]
  0083f	52		 push	 edx
  00840	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00847	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0084d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00851	52		 push	 edx
  00852	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00855	50		 push	 eax
  00856	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00859	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0085d	52		 push	 edx
  0085e	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  00863	83 c4 14	 add	 esp, 20			; 00000014H

; 9378 : 			GCTradeResponseSend(lpMsg->Response, aIndex, gObj[number].Name, gObj[number].Level, gObj[number].GuildNumber);

  00866	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0086d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00873	8b 94 01 90 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+656]
  0087a	52		 push	 edx
  0087b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00882	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00888	0f b7 94 01 a0
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+160]
  00890	52		 push	 edx
  00891	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00898	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0089e	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  008a2	52		 push	 edx
  008a3	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  008a6	50		 push	 eax
  008a7	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  008aa	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  008ae	52		 push	 edx
  008af	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  008b4	83 c4 14	 add	 esp, 20			; 00000014H

; 9379 : 
; 9380 : 			LogAddTD("[%s][%s] Trade Ready [%s][%s]", gObj[number].AccountID, gObj[number].Name, gObj[aIndex].AccountID, gObj[aIndex].Name);

  008b7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  008be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008c4	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  008c8	52		 push	 edx
  008c9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  008d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008d6	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  008da	52		 push	 edx
  008db	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  008e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008e8	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  008ec	52		 push	 edx
  008ed	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  008f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008fa	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  008fe	52		 push	 edx
  008ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  00904	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0090a	83 c4 14	 add	 esp, 20			; 00000014H
$LN21@CGTradeRes:

; 9381 : 		}
; 9382 : #else
; 9383 : 		gObjInventoryTrans(aIndex);
; 9384 : 		gObjInventoryTrans(number);
; 9385 : 
; 9386 : 		LogAddTD("[%s][%s] Trade Ready [%s][%s]", gObj[number].AccountID, gObj[number].Name, gObj[aIndex].AccountID, gObj[aIndex].Name);
; 9387 : #endif
; 9388 : 
; 9389 : 	}
; 9390 : 	
; 9391 : 	//    .
; 9392 : 	if( Result == 0 ) 

  0090d	83 7d fc 00	 cmp	 DWORD PTR _Result$[ebp], 0
  00911	0f 85 7e 01 00
	00		 jne	 $LN1@CGTradeRes

; 9393 : 	{
; 9394 : 		if( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_TRADE)

  00917	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0091e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00924	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0092b	80 e2 03	 and	 dl, 3
  0092e	0f b6 c2	 movzx	 eax, dl
  00931	85 c0		 test	 eax, eax
  00933	0f 84 8e 00 00
	00		 je	 $LN30@CGTradeRes
  00939	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00940	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00946	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0094d	c0 ea 04	 shr	 dl, 4
  00950	80 e2 0f	 and	 dl, 15			; 0000000fH
  00953	0f b6 c2	 movzx	 eax, dl
  00956	83 f8 01	 cmp	 eax, 1
  00959	75 6c		 jne	 SHORT $LN30@CGTradeRes

; 9395 : 		{
; 9396 : 			gObj[aIndex].m_IfState.use    = 0;

  0095b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00962	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00968	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0096f	80 e2 fc	 and	 dl, 252			; 000000fcH
  00972	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00979	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0097f	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 9397 : 			gObj[aIndex].TargetNumber	  = -1;

  00986	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0098d	83 c9 ff	 or	 ecx, -1
  00990	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00996	66 89 8c 02 ac
	02 00 00	 mov	 WORD PTR [edx+eax+684], cx

; 9398 : 			LogAddTD("Interface State : %d",gObj[aIndex].m_IfState.use);

  0099e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  009a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009ab	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  009b2	80 e2 03	 and	 dl, 3
  009b5	0f b6 c2	 movzx	 eax, dl
  009b8	50		 push	 eax
  009b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd@
  009be	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  009c4	83 c4 08	 add	 esp, 8
$LN30@CGTradeRes:

; 9399 : 		}
; 9400 : 		
; 9401 : 		//  ..
; 9402 : 		if( gObj[number].TargetNumber == aIndex )

  009c7	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  009ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009d4	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  009dc	3b 55 0c	 cmp	 edx, DWORD PTR _aIndex$[ebp]
  009df	0f 85 b0 00 00
	00		 jne	 $LN1@CGTradeRes

; 9403 : 		{
; 9404 : 			if( gObj[number].m_IfState.use && gObj[number].m_IfState.type == I_TRADE)

  009e5	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  009ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009f2	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  009f9	80 e2 03	 and	 dl, 3
  009fc	0f b6 c2	 movzx	 eax, dl
  009ff	85 c0		 test	 eax, eax
  00a01	0f 84 8e 00 00
	00		 je	 $LN1@CGTradeRes
  00a07	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00a0e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a14	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00a1b	c0 ea 04	 shr	 dl, 4
  00a1e	80 e2 0f	 and	 dl, 15			; 0000000fH
  00a21	0f b6 c2	 movzx	 eax, dl
  00a24	83 f8 01	 cmp	 eax, 1
  00a27	75 6c		 jne	 SHORT $LN1@CGTradeRes

; 9405 : 			{
; 9406 : 				gObj[number].m_IfState.use = 0;

  00a29	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00a30	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a36	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00a3d	80 e2 fc	 and	 dl, 252			; 000000fcH
  00a40	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00a47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a4d	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 9407 : 				gObj[number].TargetNumber  = -1;

  00a54	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00a5b	83 c9 ff	 or	 ecx, -1
  00a5e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a64	66 89 8c 02 ac
	02 00 00	 mov	 WORD PTR [edx+eax+684], cx

; 9408 : 				LogAddTD("Interface State : %d",gObj[number].m_IfState.use);

  00a6c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00a73	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a79	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00a80	80 e2 03	 and	 dl, 3
  00a83	0f b6 c2	 movzx	 eax, dl
  00a86	50		 push	 eax
  00a87	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd@
  00a8c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a92	83 c4 08	 add	 esp, 8
$LN1@CGTradeRes:

; 9409 : 			}
; 9410 : 		}
; 9411 : 	}
; 9412 : }

  00a95	5f		 pop	 edi
  00a96	5e		 pop	 esi
  00a97	5b		 pop	 ebx
  00a98	8b e5		 mov	 esp, ebp
  00a9a	5d		 pop	 ebp
  00a9b	c3		 ret	 0
?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ENDP ; CGTradeResponseRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z
_TEXT	SEGMENT
tv134 = -84						; size = 4
tv71 = -84						; size = 4
tv135 = -80						; size = 4
tv72 = -80						; size = 4
_number$ = -12						; size = 4
_money$ = -8						; size = 4
_pMsg$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z PROC	; CGTradeMoneyRecv, COMDAT

; 9495 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9496 : 	PMSG_DEFRESULT pMsg;
; 9497 : 	int money=0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _money$[ebp], 0

; 9498 : 
; 9499 : 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;

  00010	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00017	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	75 05		 jne	 SHORT $LN2@CGTradeMon
  0002a	e9 34 03 00 00	 jmp	 $LN1@CGTradeMon
$LN2@CGTradeMon:

; 9500 : 
; 9501 : 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  0002f	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00033	7d 09		 jge	 SHORT $LN15@CGTradeMon
  00035	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  0003c	eb 1f		 jmp	 SHORT $LN16@CGTradeMon
$LN15@CGTradeMon:
  0003e	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00045	7e 09		 jle	 SHORT $LN13@CGTradeMon
  00047	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0004e	eb 07		 jmp	 SHORT $LN14@CGTradeMon
$LN13@CGTradeMon:
  00050	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN14@CGTradeMon:
  00057	8b 45 ac	 mov	 eax, DWORD PTR tv71[ebp]
  0005a	89 45 b0	 mov	 DWORD PTR tv72[ebp], eax
$LN16@CGTradeMon:
  0005d	83 7d b0 00	 cmp	 DWORD PTR tv72[ebp], 0
  00061	75 26		 jne	 SHORT $LN3@CGTradeMon

; 9502 : 	{
; 9503 : 		LogAdd("error : %s %d (%d)",__FILE__, __LINE__, aIndex);

  00063	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00066	50		 push	 eax
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z@4JA
  0006d	83 c1 08	 add	 ecx, 8
  00070	51		 push	 ecx
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ@
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00081	83 c4 10	 add	 esp, 16			; 00000010H

; 9504 : 		return ;

  00084	e9 da 02 00 00	 jmp	 $LN1@CGTradeMon
$LN3@CGTradeMon:

; 9505 : 	}
; 9506 : 	// ..
; 9507 : 	if( gObj[aIndex].CloseType != -1 )

  00089	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00096	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  0009b	83 fa ff	 cmp	 edx, -1
  0009e	74 43		 je	 SHORT $LN4@CGTradeMon

; 9508 : 	{
; 9509 : 		LogAdd(lMsg.Get(487), gObj[aIndex].AccountID, gObj[aIndex].Name);

  000a0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ad	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000b1	52		 push	 edx
  000b2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bf	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000c3	52		 push	 edx
  000c4	68 e7 01 00 00	 push	 487			; 000001e7H
  000c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000d4	50		 push	 eax
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9510 : 		return;

  000de	e9 80 02 00 00	 jmp	 $LN1@CGTradeMon
$LN4@CGTradeMon:

; 9511 : 	}
; 9512 : 
; 9513 : 	int number = gObj[aIndex].TargetNumber;

  000e3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f0	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  000f8	89 55 f4	 mov	 DWORD PTR _number$[ebp], edx

; 9514 : 
; 9515 : 	if( !CHECK_LIMIT(number, MAX_OBJECT) )

  000fb	83 7d f4 00	 cmp	 DWORD PTR _number$[ebp], 0
  000ff	7d 09		 jge	 SHORT $LN19@CGTradeMon
  00101	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
  00108	eb 1f		 jmp	 SHORT $LN20@CGTradeMon
$LN19@CGTradeMon:
  0010a	81 7d f4 e7 1c
	00 00		 cmp	 DWORD PTR _number$[ebp], 7399 ; 00001ce7H
  00111	7e 09		 jle	 SHORT $LN17@CGTradeMon
  00113	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], 0
  0011a	eb 07		 jmp	 SHORT $LN18@CGTradeMon
$LN17@CGTradeMon:
  0011c	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
$LN18@CGTradeMon:
  00123	8b 45 ac	 mov	 eax, DWORD PTR tv134[ebp]
  00126	89 45 b0	 mov	 DWORD PTR tv135[ebp], eax
$LN20@CGTradeMon:
  00129	83 7d b0 00	 cmp	 DWORD PTR tv135[ebp], 0
  0012d	75 47		 jne	 SHORT $LN5@CGTradeMon

; 9516 : 	{
; 9517 : 		LogAdd(lMsg.Get(488), gObj[aIndex].AccountID, gObj[aIndex].Name, number);

  0012f	8b 45 f4	 mov	 eax, DWORD PTR _number$[ebp]
  00132	50		 push	 eax
  00133	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0013a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00140	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00144	50		 push	 eax
  00145	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0014c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00152	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00156	50		 push	 eax
  00157	68 e8 01 00 00	 push	 488			; 000001e8H
  0015c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00167	50		 push	 eax
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0016e	83 c4 10	 add	 esp, 16			; 00000010H

; 9518 : 		return;

  00171	e9 ed 01 00 00	 jmp	 $LN1@CGTradeMon
$LN5@CGTradeMon:

; 9519 : 	}
; 9520 : 	
; 9521 : 	// ..
; 9522 : 	if( gObj[number].CloseType != -1 )

  00176	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00183	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  00188	83 fa ff	 cmp	 edx, -1
  0018b	74 67		 je	 SHORT $LN6@CGTradeMon

; 9523 : 	{
; 9524 : 		LogAdd(lMsg.Get(489), gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[number].AccountID, gObj[number].Name);

  0018d	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00194	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019a	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0019e	52		 push	 edx
  0019f	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ac	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001b0	52		 push	 edx
  001b1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001be	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001c2	52		 push	 edx
  001c3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d0	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001d4	52		 push	 edx
  001d5	68 e9 01 00 00	 push	 489			; 000001e9H
  001da	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001e5	50		 push	 eax
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001ec	83 c4 14	 add	 esp, 20			; 00000014H

; 9525 : 		return;

  001ef	e9 6f 01 00 00	 jmp	 $LN1@CGTradeMon
$LN6@CGTradeMon:

; 9526 : 	}
; 9527 : 	
; 9528 : 	//  ..  
; 9529 : 	if( !gObj[aIndex].m_IfState.use && (gObj[aIndex].m_IfState.type != I_TRADE )) return;

  001f4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00201	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00208	80 e2 03	 and	 dl, 3
  0020b	0f b6 c2	 movzx	 eax, dl
  0020e	85 c0		 test	 eax, eax
  00210	75 27		 jne	 SHORT $LN7@CGTradeMon
  00212	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00219	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0021f	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00226	c0 ea 04	 shr	 dl, 4
  00229	80 e2 0f	 and	 dl, 15			; 0000000fH
  0022c	0f b6 c2	 movzx	 eax, dl
  0022f	83 f8 01	 cmp	 eax, 1
  00232	74 05		 je	 SHORT $LN7@CGTradeMon
  00234	e9 2a 01 00 00	 jmp	 $LN1@CGTradeMon
$LN7@CGTradeMon:

; 9530 : 
; 9531 : 	if( gObjCanItemTouch(&gObj[aIndex], I_TRADE) == FALSE )	//    

  00239	6a 01		 push	 1
  0023b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00242	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  0024e	83 c4 08	 add	 esp, 8
  00251	85 c0		 test	 eax, eax
  00253	75 05		 jne	 SHORT $LN8@CGTradeMon

; 9532 : 	{
; 9533 : 		return;

  00255	e9 09 01 00 00	 jmp	 $LN1@CGTradeMon
$LN8@CGTradeMon:

; 9534 : 	}
; 9535 : 
; 9536 : 	//    50000000   . 
; 9537 : 	if( lpMsg->Money > 100000000 )

  0025a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0025d	81 78 04 00 e1
	f5 05		 cmp	 DWORD PTR [eax+4], 100000000 ; 05f5e100H
  00264	76 05		 jbe	 SHORT $LN9@CGTradeMon

; 9538 : 	{
; 9539 : 		return;

  00266	e9 f8 00 00 00	 jmp	 $LN1@CGTradeMon
$LN9@CGTradeMon:

; 9540 : 	}
; 9541 : 	
; 9542 : 	money = lpMsg->Money;

  0026b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0026e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00271	89 4d f8	 mov	 DWORD PTR _money$[ebp], ecx

; 9543 : 
; 9544 : 	if( (int)gObj[aIndex].Money-money < 0 ) return;

  00274	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0027b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00281	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  00288	2b 55 f8	 sub	 edx, DWORD PTR _money$[ebp]
  0028b	79 05		 jns	 SHORT $LN10@CGTradeMon
  0028d	e9 d1 00 00 00	 jmp	 $LN1@CGTradeMon
$LN10@CGTradeMon:

; 9545 : 	
; 9546 : 	GCMoneySend(aIndex, gObj[aIndex].Money-money);

  00292	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0029f	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  002a6	2b 55 f8	 sub	 edx, DWORD PTR _money$[ebp]
  002a9	52		 push	 edx
  002aa	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002ad	50		 push	 eax
  002ae	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  002b3	83 c4 08	 add	 esp, 8

; 9547 : 
; 9548 : 	PHeadSetB((LPBYTE)&pMsg, 0x3A, sizeof( pMsg ));

  002b6	6a 04		 push	 4
  002b8	6a 3a		 push	 58			; 0000003aH
  002ba	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002bd	50		 push	 eax
  002be	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  002c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9549 : 
; 9550 : 	pMsg.result     = 0x01;	

  002c6	c6 45 ff 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1

; 9551 : 	
; 9552 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  002ca	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  002ce	50		 push	 eax
  002cf	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  002d2	51		 push	 ecx
  002d3	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002d6	52		 push	 edx
  002d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9553 : 
; 9554 : 	if( number >= 0 )

  002df	83 7d f4 00	 cmp	 DWORD PTR _number$[ebp], 0
  002e3	7c 7e		 jl	 SHORT $LN1@CGTradeMon

; 9555 : 	{
; 9556 : 		gObj[aIndex].TradeMoney = money;

  002e5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f2	8b 55 f8	 mov	 edx, DWORD PTR _money$[ebp]
  002f5	89 94 01 8c 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3212], edx

; 9557 : 		gObj[aIndex].TradeOk = 0;

  002fc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00303	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00309	c6 84 01 90 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3216], 0

; 9558 : 		gObj[number].TradeOk = 0;

  00311	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00318	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0031e	c6 84 01 90 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3216], 0

; 9559 : 		GCTradeOkButtonSend(number, 0x02);

  00326	6a 02		 push	 2
  00328	8b 45 f4	 mov	 eax, DWORD PTR _number$[ebp]
  0032b	50		 push	 eax
  0032c	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  00331	83 c4 08	 add	 esp, 8

; 9560 : 		GCTradeOkButtonSend(aIndex, 0x00);

  00334	6a 00		 push	 0
  00336	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00339	50		 push	 eax
  0033a	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  0033f	83 c4 08	 add	 esp, 8

; 9561 : 		GCTradeMoneyOther(number, gObj[aIndex].TradeMoney);

  00342	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00349	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0034f	8b 94 01 8c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3212]
  00356	52		 push	 edx
  00357	8b 45 f4	 mov	 eax, DWORD PTR _number$[ebp]
  0035a	50		 push	 eax
  0035b	e8 00 00 00 00	 call	 ?GCTradeMoneyOther@@YAHHK@Z ; GCTradeMoneyOther
  00360	83 c4 08	 add	 esp, 8
$LN1@CGTradeMon:

; 9562 : 	}
; 9563 : }

  00363	5f		 pop	 edi
  00364	5e		 pop	 esi
  00365	5b		 pop	 ebx
  00366	8b e5		 mov	 esp, ebp
  00368	5d		 pop	 ebp
  00369	c3		 ret	 0
?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z ENDP	; CGTradeMoneyRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCTradeResponseSend@@YAHEHPADGH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_response$ = 8						; size = 1
_aIndex$ = 12						; size = 4
_id$ = 16						; size = 4
_level$ = 20						; size = 2
_GuildNumber$ = 24					; size = 4
?GCTradeResponseSend@@YAHEHPADGH@Z PROC			; GCTradeResponseSend, COMDAT

; 9417 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 9418 : 	PMSG_TRADE_RESPONSE	pMsg;
; 9419 : 	
; 9420 : 	PHeadSetB((LPBYTE)&pMsg, 0x37, sizeof( pMsg ));

  00013	6a 14		 push	 20			; 00000014H
  00015	6a 37		 push	 55			; 00000037H
  00017	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9421 : 
; 9422 : 	pMsg.Response = response;

  00023	8a 45 08	 mov	 al, BYTE PTR _response$[ebp]
  00026	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 9423 : 	pMsg.Level = level;

  00029	66 8b 45 14	 mov	 ax, WORD PTR _level$[ebp]
  0002d	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 9424 : 	pMsg.GuildNumber = GuildNumber;

  00031	8b 45 18	 mov	 eax, DWORD PTR _GuildNumber$[ebp]
  00034	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 9425 : 	memcpy(pMsg.Id, id, MAX_IDSTRING);

  00037	6a 0a		 push	 10			; 0000000aH
  00039	8b 45 10	 mov	 eax, DWORD PTR _id$[ebp]
  0003c	50		 push	 eax
  0003d	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _memcpy
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9426 : 
; 9427 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00049	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0004d	50		 push	 eax
  0004e	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9428 : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	33 cd		 xor	 ecx, ebp
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?GCTradeResponseSend@@YAHEHPADGH@Z ENDP			; GCTradeResponseSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z
_TEXT	SEGMENT
tv251 = -100						; size = 4
tv232 = -100						; size = 4
tv135 = -100						; size = 4
tv252 = -96						; size = 4
tv233 = -96						; size = 4
tv136 = -96						; size = 4
_pMsg$ = -28						; size = 13
_lpObj$ = -12						; size = 4
_number$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z PROC	; CGTradeRequestSend, COMDAT

; 9024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 9025 : 	int number;
; 9026 : 	
; 9027 : 	//   .
; 9028 : 	if( bCanTrade == FALSE )

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bCanTrade@@3HA, 0 ; bCanTrade
  0001a	75 43		 jne	 SHORT $LN2@CGTradeReq

; 9029 : 	{
; 9030 : 		GCServerMsgStringSend(lMsg.Get(1149), aIndex, 1);	//     

  0001c	6a 01		 push	 1
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00021	50		 push	 eax
  00022	68 7d 04 00 00	 push	 1149			; 0000047dH
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9031 : 		GCServerMsgStringSend(lMsg.Get(1150), aIndex, 1);	//    

  0003b	6a 01		 push	 1
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00040	50		 push	 eax
  00041	68 7e 04 00 00	 push	 1150			; 0000047eH
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9032 : 		return;

  0005a	e9 20 07 00 00	 jmp	 $LN1@CGTradeReq
$LN2@CGTradeReq:

; 9033 : 	}
; 9034 : 
; 9035 : 	// ..
; 9036 : 	if( gObj[aIndex].CloseType != -1 )

  0005f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006c	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  00071	83 fa ff	 cmp	 edx, -1
  00074	74 05		 je	 SHORT $LN3@CGTradeReq

; 9037 : 	{
; 9038 : 		return;

  00076	e9 04 07 00 00	 jmp	 $LN1@CGTradeReq
$LN3@CGTradeReq:

; 9039 : 	}
; 9040 : 
; 9041 : 	LPOBJECTSTRUCT lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  0007b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00082	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00088	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 9042 : 	if( PacketCheckTime(lpObj) == FALSE ) return;

  0008b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00094	83 c4 04	 add	 esp, 4
  00097	85 c0		 test	 eax, eax
  00099	75 05		 jne	 SHORT $LN4@CGTradeReq
  0009b	e9 df 06 00 00	 jmp	 $LN1@CGTradeReq
$LN4@CGTradeReq:

; 9043 : 
; 9044 : 	number = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  000a0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a3	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000a7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000ad	0f b6 d1	 movzx	 edx, cl
  000b0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000b3	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000b7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000bd	0f b6 c1	 movzx	 eax, cl
  000c0	c1 e0 08	 shl	 eax, 8
  000c3	0b d0		 or	 edx, eax
  000c5	0f b7 ca	 movzx	 ecx, dx
  000c8	89 4d f8	 mov	 DWORD PTR _number$[ebp], ecx

; 9045 : 	
; 9046 : 	if( !CHECK_LIMIT(number, MAX_OBJECT) )

  000cb	83 7d f8 00	 cmp	 DWORD PTR _number$[ebp], 0
  000cf	7d 09		 jge	 SHORT $LN29@CGTradeReq
  000d1	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
  000d8	eb 1f		 jmp	 SHORT $LN30@CGTradeReq
$LN29@CGTradeReq:
  000da	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _number$[ebp], 7399 ; 00001ce7H
  000e1	7e 09		 jle	 SHORT $LN27@CGTradeReq
  000e3	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
  000ea	eb 07		 jmp	 SHORT $LN28@CGTradeReq
$LN27@CGTradeReq:
  000ec	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv135[ebp], 1
$LN28@CGTradeReq:
  000f3	8b 45 9c	 mov	 eax, DWORD PTR tv135[ebp]
  000f6	89 45 a0	 mov	 DWORD PTR tv136[ebp], eax
$LN30@CGTradeReq:
  000f9	83 7d a0 00	 cmp	 DWORD PTR tv136[ebp], 0
  000fd	75 26		 jne	 SHORT $LN5@CGTradeReq

; 9047 : 	{
; 9048 : 		LogAdd("error : %s %d (%d)",__FILE__, __LINE__, number);

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00102	50		 push	 eax
  00103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z@4JA
  00109	83 c1 18	 add	 ecx, 24			; 00000018H
  0010c	51		 push	 ecx
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ@
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0011d	83 c4 10	 add	 esp, 16			; 00000010H

; 9049 : 		return;

  00120	e9 5a 06 00 00	 jmp	 $LN1@CGTradeReq
$LN5@CGTradeReq:

; 9050 : 	}
; 9051 : 
; 9052 : 	//     .
; 9053 : 	if( number == aIndex ) return;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00128	3b 45 0c	 cmp	 eax, DWORD PTR _aIndex$[ebp]
  0012b	75 05		 jne	 SHORT $LN6@CGTradeReq
  0012d	e9 4d 06 00 00	 jmp	 $LN1@CGTradeReq
$LN6@CGTradeReq:

; 9054 : 	
; 9055 : 	//   .
; 9056 : 	if( gObjIsConnected(number) == FALSE ) return;

  00132	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0013b	83 c4 04	 add	 esp, 4
  0013e	85 c0		 test	 eax, eax
  00140	75 05		 jne	 SHORT $LN7@CGTradeReq
  00142	e9 38 06 00 00	 jmp	 $LN1@CGTradeReq
$LN7@CGTradeReq:

; 9057 : 	if( gObj[number].Type == OBJTYPE_MONSTER ) return;

  00147	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00154	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00159	83 fa 02	 cmp	 edx, 2
  0015c	75 05		 jne	 SHORT $LN8@CGTradeReq
  0015e	e9 1c 06 00 00	 jmp	 $LN1@CGTradeReq
$LN8@CGTradeReq:

; 9058 : 	if( gObj[number].CloseCount >= 0 ) return;

  00163	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0016a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00170	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  00175	85 d2		 test	 edx, edx
  00177	7c 05		 jl	 SHORT $LN9@CGTradeReq
  00179	e9 01 06 00 00	 jmp	 $LN1@CGTradeReq
$LN9@CGTradeReq:

; 9059 : 	if( lpObj->DieRegen > 0 || gObj[number].DieRegen > 0 ) return;

  0017e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00181	0f be 88 fe 01
	00 00		 movsx	 ecx, BYTE PTR [eax+510]
  00188	85 c9		 test	 ecx, ecx
  0018a	7f 19		 jg	 SHORT $LN11@CGTradeReq
  0018c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00193	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00199	0f be 94 01 fe
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+510]
  001a1	85 d2		 test	 edx, edx
  001a3	7e 05		 jle	 SHORT $LN10@CGTradeReq
$LN11@CGTradeReq:
  001a5	e9 d5 05 00 00	 jmp	 $LN1@CGTradeReq
$LN10@CGTradeReq:

; 9060 : 
; 9061 : #ifdef MODIFY_REQUESTNPC_HACK
; 9062 : 	if (gObj[number].Type != OBJTYPE_CHARACTER)

  001aa	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  001b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b7	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  001bc	83 fa 01	 cmp	 edx, 1
  001bf	74 7f		 je	 SHORT $LN12@CGTradeReq

; 9063 : 	{
; 9064 : 		LogAddC(LOGC_RED,"[HACKTOOL] : NPC-TradeRequest npc:%d ip:%s account:%s name:%s State:%d", 

  001c1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ce	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  001d2	52		 push	 edx
  001d3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e0	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001e4	52		 push	 edx
  001e5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f2	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001f6	52		 push	 edx
  001f7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00204	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00208	52		 push	 edx
  00209	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00210	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00216	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  0021e	52		 push	 edx
  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@JLPPNLGF@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?5n@
  00224	6a 02		 push	 2
  00226	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0022c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 9065 : 			gObj[number].Class, 
; 9066 : 			gObj[aIndex].Ip_addr,
; 9067 : 			gObj[aIndex].AccountID, 
; 9068 : 			gObj[aIndex].Name, 
; 9069 : 			gObj[aIndex].Connected);
; 9070 : 		
; 9071 : 		CloseClient(aIndex);

  0022f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00238	83 c4 04	 add	 esp, 4

; 9072 : 		return;

  0023b	e9 3f 05 00 00	 jmp	 $LN1@CGTradeReq
$LN12@CGTradeReq:

; 9073 : 	}
; 9074 : #endif // MODIFY_REQUESTNPC_HACK
; 9075 : 
; 9076 : #ifdef ADD_NEWPVP_PKFIELD
; 9077 : 	if ( g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[number]) )
; 9078 : 	{
; 9079 : 		// "    ."
; 9080 : 		GCServerMsgStringSend(lMsg.Get(3422), aIndex, 1);
; 9081 : 		return;
; 9082 : 	}
; 9083 : 
; 9084 : 	if ( g_NewPVP.IsObserver(gObj[aIndex]) )
; 9085 : 	{
; 9086 : 		// "    ."
; 9087 : 		GCServerMsgStringSend(lMsg.Get(3423), aIndex, 1);
; 9088 : 		return;
; 9089 : 	}
; 9090 : #endif // ADD_NEWPVP_PKFIELD
; 9091 : 
; 9092 : 	if( gObj[number].m_stateEngagePVP == PVP_USER_PLAYING )

  00240	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00247	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024d	83 bc 01 80 1a
	00 00 02	 cmp	 DWORD PTR [ecx+eax+6784], 2
  00255	75 18		 jne	 SHORT $LN13@CGTradeReq

; 9093 : 	{
; 9094 : 		GCServerMsgStringSend("[PVP Event] Accion no permitida", aIndex, 1);

  00257	6a 01		 push	 1
  00259	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0025c	50		 push	 eax
  0025d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DGNFGBFP@?$FLPVP?5Event?$FN?5Accion?5no?5permitida@
  00262	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00267	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9095 : 		return;

  0026a	e9 10 05 00 00	 jmp	 $LN1@CGTradeReq
$LN13@CGTradeReq:

; 9096 : 	}
; 9097 : 
; 9098 : #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 9099 : 	if( CHECK_DEVILSQUARE(gObj[number].MapNumber) )
; 9100 : #else
; 9101 : 	if( gObj[number].MapNumber == 9 )

  0026f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00276	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00284	83 fa 09	 cmp	 edx, 9
  00287	75 24		 jne	 SHORT $LN14@CGTradeReq

; 9102 : #endif
; 9103 : 	{	//    
; 9104 : 		GCServerMsgStringSend(lMsg.Get(711), aIndex, 1);

  00289	6a 01		 push	 1
  0028b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0028e	50		 push	 eax
  0028f	68 c7 02 00 00	 push	 711			; 000002c7H
  00294	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00299	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9105 : 		return;

  002a8	e9 d2 04 00 00	 jmp	 $LN1@CGTradeReq
$LN14@CGTradeReq:

; 9106 : 	}
; 9107 : 	
; 9108 : #ifdef PERSONAL_SHOP_20040113		//        .
; 9109 : 	if (gObj[aIndex].m_bPShopOpen == true)

  002ad	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ba	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  002c2	83 fa 01	 cmp	 edx, 1
  002c5	75 05		 jne	 SHORT $LN15@CGTradeReq

; 9110 : 		return;

  002c7	e9 b3 04 00 00	 jmp	 $LN1@CGTradeReq
$LN15@CGTradeReq:

; 9111 : 	if (gObj[number].m_bPShopOpen == true)

  002cc	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d9	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  002e1	83 fa 01	 cmp	 edx, 1
  002e4	75 05		 jne	 SHORT $LN16@CGTradeReq

; 9112 : 		return;

  002e6	e9 94 04 00 00	 jmp	 $LN1@CGTradeReq
$LN16@CGTradeReq:

; 9113 : #endif
; 9114 : 
; 9115 : #ifdef CHAOSCASTLE_SYSTEM_20040408	//       .
; 9116 : 	if (CHECK_CHAOSCASTLE(gObj[number].MapNumber)) {

  002eb	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f8	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00300	83 fa 12	 cmp	 edx, 18			; 00000012H
  00303	7d 09		 jge	 SHORT $LN33@CGTradeReq
  00305	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv233[ebp], 0
  0030c	eb 30		 jmp	 SHORT $LN34@CGTradeReq
$LN33@CGTradeReq:
  0030e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00315	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0031b	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00323	83 fa 17	 cmp	 edx, 23			; 00000017H
  00326	7e 09		 jle	 SHORT $LN31@CGTradeReq
  00328	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv232[ebp], 0
  0032f	eb 07		 jmp	 SHORT $LN32@CGTradeReq
$LN31@CGTradeReq:
  00331	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv232[ebp], 1
$LN32@CGTradeReq:
  00338	8b 45 9c	 mov	 eax, DWORD PTR tv232[ebp]
  0033b	89 45 a0	 mov	 DWORD PTR tv233[ebp], eax
$LN34@CGTradeReq:
  0033e	83 7d a0 00	 cmp	 DWORD PTR tv233[ebp], 0
  00342	74 24		 je	 SHORT $LN17@CGTradeReq

; 9117 : 		GCServerMsgStringSend(lMsg.Get(1220), aIndex, 1);		// "      ."

  00344	6a 01		 push	 1
  00346	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00349	50		 push	 eax
  0034a	68 c4 04 00 00	 push	 1220			; 000004c4H
  0034f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00354	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0035a	50		 push	 eax
  0035b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00360	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9118 : 		return;

  00363	e9 17 04 00 00	 jmp	 $LN1@CGTradeReq
$LN17@CGTradeReq:

; 9119 : 	}
; 9120 : #endif
; 9121 : 	
; 9122 : #ifdef FOR_BLOODCASTLE
; 9123 : 	if (CHECK_BLOODCASTLE(gObj[aIndex].MapNumber)) {			//        .

  00368	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0036f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00375	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0037d	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00380	7d 09		 jge	 SHORT $LN37@CGTradeReq
  00382	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv252[ebp], 0
  00389	eb 30		 jmp	 SHORT $LN38@CGTradeReq
$LN37@CGTradeReq:
  0038b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00392	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00398	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  003a0	83 fa 11	 cmp	 edx, 17			; 00000011H
  003a3	7e 09		 jle	 SHORT $LN35@CGTradeReq
  003a5	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv251[ebp], 0
  003ac	eb 07		 jmp	 SHORT $LN36@CGTradeReq
$LN35@CGTradeReq:
  003ae	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv251[ebp], 1
$LN36@CGTradeReq:
  003b5	8b 45 9c	 mov	 eax, DWORD PTR tv251[ebp]
  003b8	89 45 a0	 mov	 DWORD PTR tv252[ebp], eax
$LN38@CGTradeReq:
  003bb	83 7d a0 00	 cmp	 DWORD PTR tv252[ebp], 0
  003bf	74 76		 je	 SHORT $LN18@CGTradeReq

; 9124 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 9125 : 		int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( gObj[aIndex].MapNumber );
; 9126 : 		if (
; 9127 : 			(g_BloodCastle.GetCurrentState( iBridgeIndex ) != BLOODCASTLE_STATE_CLOSED) ||	//     .
; 9128 : 			(!g_BloodCastle.CheckCanEnter( iBridgeIndex ) )
; 9129 : 			)
; 9130 : #else
; 9131 : 		if (
; 9132 : 			(g_BloodCastle.GetCurrentState(gObj[aIndex].MapNumber - MAP_INDEX_BLOODCASTLE1) != BLOODCASTLE_STATE_CLOSED) ||	//     .

  003c1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ce	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  003d6	83 ea 0b	 sub	 edx, 11			; 0000000bH
  003d9	52		 push	 edx
  003da	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  003df	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  003e4	83 f8 01	 cmp	 eax, 1
  003e7	75 2a		 jne	 SHORT $LN20@CGTradeReq
  003e9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f6	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  003fe	83 ea 0b	 sub	 edx, 11			; 0000000bH
  00401	52		 push	 edx
  00402	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00407	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  0040c	0f b6 c0	 movzx	 eax, al
  0040f	85 c0		 test	 eax, eax
  00411	75 24		 jne	 SHORT $LN18@CGTradeReq
$LN20@CGTradeReq:

; 9133 : 			(!g_BloodCastle.CheckCanEnter(gObj[aIndex].MapNumber - MAP_INDEX_BLOODCASTLE1))
; 9134 : 			)
; 9135 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 9136 : 		{
; 9137 : 			GCServerMsgStringSend(lMsg.Get(1212), aIndex, 1);	// "      ."

  00413	6a 01		 push	 1
  00415	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00418	50		 push	 eax
  00419	68 bc 04 00 00	 push	 1212			; 000004bcH
  0041e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00423	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00429	50		 push	 eax
  0042a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0042f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9138 : 			return;

  00432	e9 48 03 00 00	 jmp	 $LN1@CGTradeReq
$LN18@CGTradeReq:

; 9139 : 		}
; 9140 : 	}
; 9141 : #endif
; 9142 : 
; 9143 : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_2_20070724	//    
; 9144 : 	if(CHECK_ILLUSION_TEMPLE(gObj[aIndex].MapNumber))
; 9145 : 	{
; 9146 : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_6_200708013	// wtf  
; 9147 : 		GCServerMsgStringSend(lMsg.Get(3396), aIndex, 1);	// "     ."
; 9148 : #else
; 9149 : 		GCServerMsgStringSend("     .", aIndex, 1);	// "     ."
; 9150 : #endif
; 9151 : 		return;
; 9152 : 	}
; 9153 : #endif
; 9154 : 	
; 9155 : 	//    
; 9156 : 	if( (gObj[number].m_Option&OPTION_TRADE) != OPTION_TRADE )

  00437	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0043e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00444	8b 94 01 c0 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3264]
  0044b	83 e2 01	 and	 edx, 1
  0044e	75 29		 jne	 SHORT $LN21@CGTradeReq

; 9157 : 	{
; 9158 : 		GCTradeResponseSend(0x00, aIndex, gObj[number].Name);

  00450	6a 00		 push	 0
  00452	6a 00		 push	 0
  00454	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0045b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00461	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00465	52		 push	 edx
  00466	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00469	50		 push	 eax
  0046a	6a 00		 push	 0
  0046c	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  00471	83 c4 14	 add	 esp, 20			; 00000014H

; 9159 : 		return;

  00474	e9 06 03 00 00	 jmp	 $LN1@CGTradeReq
$LN21@CGTradeReq:

; 9160 : 	}
; 9161 : 	
; 9162 : 	//         
; 9163 : 	if( lpObj->m_IfState.use > 0 )

  00479	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0047c	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00482	80 e1 03	 and	 cl, 3
  00485	0f b6 d1	 movzx	 edx, cl
  00488	85 d2		 test	 edx, edx
  0048a	7e 29		 jle	 SHORT $LN22@CGTradeReq

; 9164 : 	{
; 9165 : 		GCTradeResponseSend(0x03, aIndex, gObj[number].Name);

  0048c	6a 00		 push	 0
  0048e	6a 00		 push	 0
  00490	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00497	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0049d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  004a1	52		 push	 edx
  004a2	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004a5	50		 push	 eax
  004a6	6a 03		 push	 3
  004a8	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  004ad	83 c4 14	 add	 esp, 20			; 00000014H

; 9166 : 		return;

  004b0	e9 ca 02 00 00	 jmp	 $LN1@CGTradeReq
$LN22@CGTradeReq:

; 9167 : 	}
; 9168 : 	//         
; 9169 : 	if( gObj[number].m_IfState.use > 0 )

  004b5	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  004bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004c2	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  004c9	80 e2 03	 and	 dl, 3
  004cc	0f b6 c2	 movzx	 eax, dl
  004cf	85 c0		 test	 eax, eax
  004d1	7e 29		 jle	 SHORT $LN23@CGTradeReq

; 9170 : 	{
; 9171 : 		GCTradeResponseSend(0x02, aIndex, gObj[number].Name);

  004d3	6a 00		 push	 0
  004d5	6a 00		 push	 0
  004d7	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  004de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004e4	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  004e8	52		 push	 edx
  004e9	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004ec	50		 push	 eax
  004ed	6a 02		 push	 2
  004ef	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  004f4	83 c4 14	 add	 esp, 20			; 00000014H

; 9172 : 		return;

  004f7	e9 83 02 00 00	 jmp	 $LN1@CGTradeReq
$LN23@CGTradeReq:

; 9173 : 	}
; 9174 : 
; 9175 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719		//    -     
; 9176 : 	if (gObjFixInventoryPointer(aIndex) == false) {

  004fc	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004ff	50		 push	 eax
  00500	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00505	83 c4 04	 add	 esp, 4
  00508	0f b6 c8	 movzx	 ecx, al
  0050b	85 c9		 test	 ecx, ecx
  0050d	75 1e		 jne	 SHORT $LN24@CGTradeReq

; 9177 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0050f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z@4JA
  00514	05 99 00 00 00	 add	 eax, 153		; 00000099H
  00519	50		 push	 eax
  0051a	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0051f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  00524	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0052a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@CGTradeReq:

; 9178 : 	}
; 9179 : #endif
; 9180 : 
; 9181 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//          .
; 9182 : 	if (gObj[aIndex].pTransaction == 1) {

  0052d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00534	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0053a	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  00542	83 fa 01	 cmp	 edx, 1
  00545	75 55		 jne	 SHORT $LN25@CGTradeReq

; 9183 : 		LogAddTD("[%s][%s] CGTradeRequestSend() Failed : Transaction == 1, IF_TYPE : %d",

  00547	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0054e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00554	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0055b	c0 ea 04	 shr	 dl, 4
  0055e	80 e2 0f	 and	 dl, 15			; 0000000fH
  00561	0f b6 c2	 movzx	 eax, dl
  00564	50		 push	 eax
  00565	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0056c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00572	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00576	50		 push	 eax
  00577	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0057e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00584	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00588	50		 push	 eax
  00589	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5F@
  0058e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00594	83 c4 10	 add	 esp, 16			; 00000010H

; 9184 : 			gObj[aIndex].AccountID,
; 9185 : 			gObj[aIndex].Name,
; 9186 : 			gObj[aIndex].m_IfState.type
; 9187 : 			);
; 9188 : 		return;

  00597	e9 e3 01 00 00	 jmp	 $LN1@CGTradeReq
$LN25@CGTradeReq:

; 9189 : 	}
; 9190 : #endif
; 9191 : 	
; 9192 : 	//   .
; 9193 : 	lpObj->m_IfState.use         = 1;

  0059c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0059f	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  005a5	80 e1 fc	 and	 cl, 252			; 000000fcH
  005a8	80 c9 01	 or	 cl, 1
  005ab	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005ae	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 9194 : 	lpObj->m_IfState.state       = 0;

  005b4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b7	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  005bd	80 e1 f3	 and	 cl, 243			; 000000f3H
  005c0	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005c3	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 9195 : 	lpObj->m_IfState.type        = I_TRADE;

  005c9	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005cc	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  005d2	80 e1 0f	 and	 cl, 15			; 0000000fH
  005d5	80 c9 10	 or	 cl, 16			; 00000010H
  005d8	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005db	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 9196 : 	lpObj->TargetNumber	         = number;

  005e1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005e4	66 8b 4d f8	 mov	 cx, WORD PTR _number$[ebp]
  005e8	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx

; 9197 : 	gObj[number].m_IfState.use   = 1;

  005ef	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  005f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005fc	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00603	80 e2 fc	 and	 dl, 252			; 000000fcH
  00606	80 ca 01	 or	 dl, 1
  00609	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00610	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00616	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 9198 : 	gObj[number].m_IfState.state = 0;

  0061d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00624	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0062a	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00631	80 e2 f3	 and	 dl, 243			; 000000f3H
  00634	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0063b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00641	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 9199 : 	gObj[number].m_IfState.type  = I_TRADE;

  00648	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0064f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00655	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0065c	80 e2 0f	 and	 dl, 15			; 0000000fH
  0065f	80 ca 10	 or	 dl, 16			; 00000010H
  00662	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00669	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0066f	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 9200 : 	gObj[number].TargetNumber	 = aIndex;

  00676	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0067d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00683	66 8b 55 0c	 mov	 dx, WORD PTR _aIndex$[ebp]
  00687	66 89 94 01 ac
	02 00 00	 mov	 WORD PTR [ecx+eax+684], dx

; 9201 : 	lpObj->m_InterfaceTime       = GetTickCount();

  0068f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00695	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00698	89 81 58 0c 00
	00		 mov	 DWORD PTR [ecx+3160], eax

; 9202 : 	gObj[number].m_InterfaceTime = GetTickCount();

  0069e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  006a4	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  006ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006b1	89 84 0a 58 0c
	00 00		 mov	 DWORD PTR [edx+ecx+3160], eax

; 9203 : 
; 9204 : 	PMSG_TRADE_REQUESTSEND	pMsg;	
; 9205 : 
; 9206 : 	pMsg.h.c = PMHCE_BYTE;

  006b8	c6 45 e4 c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H

; 9207 : 	pMsg.h.headcode = 0x36;

  006bc	c6 45 e6 36	 mov	 BYTE PTR _pMsg$[ebp+2], 54 ; 00000036H

; 9208 : 	pMsg.h.size = sizeof( pMsg );

  006c0	c6 45 e5 0d	 mov	 BYTE PTR _pMsg$[ebp+1], 13 ; 0000000dH

; 9209 : 
; 9210 : 	memcpy(pMsg.szId, gObj[aIndex].Name, MAX_IDSTRING);

  006c4	6a 0a		 push	 10			; 0000000aH
  006c6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006d3	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  006d7	52		 push	 edx
  006d8	8d 45 e7	 lea	 eax, DWORD PTR _pMsg$[ebp+3]
  006db	50		 push	 eax
  006dc	e8 00 00 00 00	 call	 _memcpy
  006e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9211 : 
; 9212 : 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  006e4	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  006e8	50		 push	 eax
  006e9	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  006ec	51		 push	 ecx
  006ed	8b 55 f8	 mov	 edx, DWORD PTR _number$[ebp]
  006f0	52		 push	 edx
  006f1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9213 : 	LogAddTD(lMsg.Get(486), 

  006f9	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00700	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00706	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0070a	52		 push	 edx
  0070b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00712	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00718	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0071c	52		 push	 edx
  0071d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00724	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0072a	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0072e	52		 push	 edx
  0072f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00736	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0073c	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00740	52		 push	 edx
  00741	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00748	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0074e	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00752	52		 push	 edx
  00753	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0075a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00760	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00764	52		 push	 edx
  00765	68 e6 01 00 00	 push	 486			; 000001e6H
  0076a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0076f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00775	50		 push	 eax
  00776	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0077c	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@CGTradeReq:

; 9214 : 			gObj[aIndex].AccountID, 
; 9215 : 			gObj[aIndex].Name,
; 9216 : 			gObj[aIndex].Ip_addr,
; 9217 : 			gObj[number].AccountID, 
; 9218 : 			gObj[number].Name,
; 9219 : 			gObj[number].Ip_addr);
; 9220 : }

  0077f	5f		 pop	 edi
  00780	5e		 pop	 esi
  00781	5b		 pop	 ebx
  00782	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00785	33 cd		 xor	 ecx, ebp
  00787	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0078c	8b e5		 mov	 esp, ebp
  0078e	5d		 pop	 ebp
  0078f	c3		 ret	 0
?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ENDP	; CGTradeRequestSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCPartyDelUserSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCPartyDelUserSend@@YAXH@Z PROC			; GCPartyDelUserSend, COMDAT

; 11651: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 11652: 	PMSG_PARTYDELUSERSEND	pMsg;
; 11653: 
; 11654: 	PHeadSetB((LPBYTE)&pMsg, 0x43, sizeof( pMsg ));

  00009	6a 03		 push	 3
  0000b	6a 43		 push	 67			; 00000043H
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11655: 	
; 11656: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00019	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001d	50		 push	 eax
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11657: }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?GCPartyDelUserSend@@YAXH@Z ENDP			; GCPartyDelUserSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z
_TEXT	SEGMENT
tv140 = -416						; size = 4
tv95 = -416						; size = 4
tv507 = -412						; size = 4
tv396 = -412						; size = 4
tv207 = -412						; size = 4
tv141 = -412						; size = 4
tv128 = -412						; size = 4
_x$1 = -344						; size = 4
_n$2 = -340						; size = 4
_x$3 = -336						; size = 4
_n$4 = -332						; size = 4
_pResult$5 = -328					; size = 4
_pTeleportMsg$6 = -324					; size = 6
_pResult$7 = -316					; size = 4
_pNotice$8 = -312					; size = 272
_iTarGetIndex$9 = -40					; size = 4
_pResult$10 = -36					; size = 4
_lpMyNode$ = -32					; size = 4
_g_call$ = -28						; size = 4
_count$ = -24						; size = 4
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z PROC ; GCGuildWarRequestSendRecv, COMDAT

; 12733: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 12734: 
; 12735: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 12736: 	return;
; 12737: #endif
; 12738: 
; 12739: 	PMSG_GUILDWAR_DECLARE pMsg;
; 12740: 	int count=0;

  00016	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 12741: 	int g_call = 0;

  0001d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _g_call$[ebp], 0

; 12742: 			
; 12743: 	
; 12744: 	PHeadSetB((LPBYTE)&pMsg, 0x62, sizeof( pMsg ));

  00024	6a 0d		 push	 13			; 0000000dH
  00026	6a 62		 push	 98			; 00000062H
  00028	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12745: 
; 12746: 	pMsg.Type		= 0;

  00034	c6 45 f7 00	 mov	 BYTE PTR _pMsg$[ebp+11], 0

; 12747: 
; 12748: 	//if( gObj[aIndex].GuildNumber < 1 ) return;
; 12749: 	LPGUILD_INFO lpMyNode = gObj[aIndex].lpGuild;

  00038	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00045	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  0004c	89 55 e0	 mov	 DWORD PTR _lpMyNode$[ebp], edx

; 12750: 
; 12751: 	if( lpMyNode == NULL ) 

  0004f	83 7d e0 00	 cmp	 DWORD PTR _lpMyNode$[ebp], 0
  00053	75 2a		 jne	 SHORT $LN10@GCGuildWar

; 12752: 	{
; 12753: 		PMSG_GUILDWARREQUEST_RESULT	pResult;
; 12754: 				
; 12755: 		pResult.h.c			= PMHC_BYTE;

  00055	c6 45 dc c1	 mov	 BYTE PTR _pResult$10[ebp], 193 ; 000000c1H

; 12756: 		pResult.h.headcode	= 0x60;

  00059	c6 45 de 60	 mov	 BYTE PTR _pResult$10[ebp+2], 96 ; 00000060H

; 12757: 		pResult.h.size		= sizeof( pMsg );

  0005d	c6 45 dd 0d	 mov	 BYTE PTR _pResult$10[ebp+1], 13 ; 0000000dH

; 12758: 		pResult.Result		= 0x00;

  00061	c6 45 df 00	 mov	 BYTE PTR _pResult$10[ebp+3], 0

; 12759: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00065	0f b6 45 dd	 movzx	 eax, BYTE PTR _pResult$10[ebp+1]
  00069	50		 push	 eax
  0006a	8d 4d dc	 lea	 ecx, DWORD PTR _pResult$10[ebp]
  0006d	51		 push	 ecx
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12760: 		return;

  0007a	e9 6c 0a 00 00	 jmp	 $LN1@GCGuildWar
$LN10@GCGuildWar:

; 12761: 	}	
; 12762: 
; 12763: #ifdef CHAOSCASTLE_DUAL_GUILDWAR_CHANGE_20040614	
; 12764: 	#ifndef WORLD_TOURNAMENT_EVENT_SETTING		//    ..   .
; 12765: 		if( lpMyNode->lpTargetGuildNode != NULL && lpMsg->Result != 0x00 )

  0007f	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00082	83 b8 8c 05 00
	00 00		 cmp	 DWORD PTR [eax+1420], 0
  00089	0f 84 63 01 00
	00		 je	 $LN11@GCGuildWar
  0008f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00092	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00096	85 c9		 test	 ecx, ecx
  00098	0f 84 54 01 00
	00		 je	 $LN11@GCGuildWar

; 12766: 		{	//  OK
; 12767: 			int iTarGetIndex = lpMyNode->lpTargetGuildNode->Index[0];

  0009e	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  000a1	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  000a7	ba 02 00 00 00	 mov	 edx, 2
  000ac	6b c2 00	 imul	 eax, edx, 0
  000af	0f bf 8c 01 a0
	03 00 00	 movsx	 ecx, WORD PTR [ecx+eax+928]
  000b7	89 4d d8	 mov	 DWORD PTR _iTarGetIndex$9[ebp], ecx

; 12768: 			if (CHECK_BLOODCASTLE(gObj[iTarGetIndex].MapNumber) ||		// 
; 12769: #ifdef CHAOSCASTLE_SYSTEM_20040408
; 12770: 				CHECK_CHAOSCASTLE(gObj[iTarGetIndex].MapNumber) ||		// 

  000ba	69 45 d8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTarGetIndex$9[ebp], 7072
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000cf	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  000d2	7d 0c		 jge	 SHORT $LN55@GCGuildWar
  000d4	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv128[ebp], 0
  000de	eb 3c		 jmp	 SHORT $LN56@GCGuildWar
$LN55@GCGuildWar:
  000e0	69 45 d8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTarGetIndex$9[ebp], 7072
  000e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ed	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000f5	83 fa 11	 cmp	 edx, 17			; 00000011H
  000f8	7e 0c		 jle	 SHORT $LN53@GCGuildWar
  000fa	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv95[ebp], 0
  00104	eb 0a		 jmp	 SHORT $LN54@GCGuildWar
$LN53@GCGuildWar:
  00106	c7 85 60 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv95[ebp], 1
$LN54@GCGuildWar:
  00110	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv95[ebp]
  00116	89 85 64 fe ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
$LN56@GCGuildWar:
  0011c	83 bd 64 fe ff
	ff 00		 cmp	 DWORD PTR tv128[ebp], 0
  00123	0f 85 85 00 00
	00		 jne	 $LN13@GCGuildWar
  00129	69 45 d8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTarGetIndex$9[ebp], 7072
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00136	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0013e	83 fa 12	 cmp	 edx, 18			; 00000012H
  00141	7d 0c		 jge	 SHORT $LN59@GCGuildWar
  00143	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv141[ebp], 0
  0014d	eb 3c		 jmp	 SHORT $LN60@GCGuildWar
$LN59@GCGuildWar:
  0014f	69 45 d8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTarGetIndex$9[ebp], 7072
  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00164	83 fa 17	 cmp	 edx, 23			; 00000017H
  00167	7e 0c		 jle	 SHORT $LN57@GCGuildWar
  00169	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv140[ebp], 0
  00173	eb 0a		 jmp	 SHORT $LN58@GCGuildWar
$LN57@GCGuildWar:
  00175	c7 85 60 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv140[ebp], 1
$LN58@GCGuildWar:
  0017f	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv140[ebp]
  00185	89 85 64 fe ff
	ff		 mov	 DWORD PTR tv141[ebp], eax
$LN60@GCGuildWar:
  0018b	83 bd 64 fe ff
	ff 00		 cmp	 DWORD PTR tv141[ebp], 0
  00192	75 1a		 jne	 SHORT $LN13@GCGuildWar
  00194	69 45 d8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iTarGetIndex$9[ebp], 7072
  0019b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a1	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001a9	83 fa 09	 cmp	 edx, 9
  001ac	75 44		 jne	 SHORT $LN11@GCGuildWar
$LN13@GCGuildWar:

; 12771: #endif
; 12772: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 12773: 				CHECK_DEVILSQUARE(gObj[iTarGetIndex].MapNumber)			// 
; 12774: #else
; 12775: 				gObj[iTarGetIndex].MapNumber == 9						// 
; 12776: #endif
; 12777: 				)
; 12778: 			{
; 12779: 				PMSG_NOTICE	pNotice;
; 12780: 		#ifdef MODIFY_NOTICE_20040325
; 12781: 				TNotice::MakeNoticeMsgEx( &pNotice, 1, lMsg.Get(1223));		//        .

  001ae	68 c7 04 00 00	 push	 1223			; 000004c7H
  001b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001be	50		 push	 eax
  001bf	6a 01		 push	 1
  001c1	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$8[ebp]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12782: 		#else
; 12783: 				pNotice.type = 1;
; 12784: 				wsprintf(pNotice.Notice, lMsg.Get(1223));					//        .
; 12785: 				PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 12786: 		#endif
; 12787: 				DataSend(aIndex, (LPBYTE)&pNotice, pNotice.h.size);

  001d0	0f b6 85 c9 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$8[ebp+1]
  001d7	50		 push	 eax
  001d8	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$8[ebp]
  001de	51		 push	 ecx
  001df	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001e2	52		 push	 edx
  001e3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12788: 				lpMsg->Result = 0x00;

  001eb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001ee	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
$LN11@GCGuildWar:

; 12789: 			}
; 12790: 		}
; 12791: 	#endif	// #ifdef WORLD_TOURNAMENT_EVENT_SETTING	
; 12792: #endif
; 12793: 
; 12794: 	pMsg.Type = lpMyNode->WarType;

  001f2	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  001f5	8a 88 92 05 00
	00		 mov	 cl, BYTE PTR [eax+1426]
  001fb	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+11], cl

; 12795: 	if( lpMsg->Result == 0x00 )

  001fe	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00201	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00205	85 c9		 test	 ecx, ecx
  00207	0f 85 b0 00 00
	00		 jne	 $LN14@GCGuildWar

; 12796: 	{
; 12797: 		if( lpMyNode->lpTargetGuildNode != NULL )

  0020d	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00210	83 b8 8c 05 00
	00 00		 cmp	 DWORD PTR [eax+1420], 0
  00217	0f 84 9b 00 00
	00		 je	 $LN15@GCGuildWar

; 12798: 		{
; 12799: 			if( lpMyNode->lpTargetGuildNode->WarDeclareState == 1 )

  0021d	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00220	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00226	0f b6 91 90 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1424]
  0022d	83 fa 01	 cmp	 edx, 1
  00230	0f 85 82 00 00
	00		 jne	 $LN15@GCGuildWar

; 12800: 			{
; 12801: 				lpMyNode->lpTargetGuildNode->WarDeclareState = 0;

  00236	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00239	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0023f	c6 81 90 05 00
	00 00		 mov	 BYTE PTR [ecx+1424], 0

; 12802: 				lpMyNode->WarDeclareState = 0;

  00246	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00249	c6 80 90 05 00
	00 00		 mov	 BYTE PTR [eax+1424], 0

; 12803: 
; 12804: 				PMSG_GUILDWARREQUEST_RESULT	pResult;
; 12805: 				
; 12806: 				
; 12807: 				PHeadSetB((LPBYTE)&pResult, 0x60, sizeof( pResult ));

  00250	6a 04		 push	 4
  00252	6a 60		 push	 96			; 00000060H
  00254	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$7[ebp]
  0025a	50		 push	 eax
  0025b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00260	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12808: 
; 12809: 				pResult.Result		= 0x06;

  00263	c6 85 c7 fe ff
	ff 06		 mov	 BYTE PTR _pResult$7[ebp+3], 6

; 12810: 				if( lpMyNode->lpTargetGuildNode->Index[0] >= 0 )

  0026a	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  0026d	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00273	ba 02 00 00 00	 mov	 edx, 2
  00278	6b c2 00	 imul	 eax, edx, 0
  0027b	0f bf 8c 01 a0
	03 00 00	 movsx	 ecx, WORD PTR [ecx+eax+928]
  00283	85 c9		 test	 ecx, ecx
  00285	7c 31		 jl	 SHORT $LN15@GCGuildWar

; 12811: 				{
; 12812: 					DataSend(lpMyNode->lpTargetGuildNode->Index[0], (LPBYTE)&pResult, pResult.h.size);

  00287	0f b6 85 c5 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$7[ebp+1]
  0028e	50		 push	 eax
  0028f	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$7[ebp]
  00295	51		 push	 ecx
  00296	8b 55 e0	 mov	 edx, DWORD PTR _lpMyNode$[ebp]
  00299	8b 82 8c 05 00
	00		 mov	 eax, DWORD PTR [edx+1420]
  0029f	b9 02 00 00 00	 mov	 ecx, 2
  002a4	6b d1 00	 imul	 edx, ecx, 0
  002a7	0f bf 84 10 a0
	03 00 00	 movsx	 eax, WORD PTR [eax+edx+928]
  002af	50		 push	 eax
  002b0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002b5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@GCGuildWar:

; 12813: 				}
; 12814: 			}
; 12815: 		}
; 12816: 		return;

  002b8	e9 2e 08 00 00	 jmp	 $LN1@GCGuildWar
$LN14@GCGuildWar:

; 12817: 	}
; 12818: 
; 12819: 	if( lpMyNode->WarDeclareState == 1 )	//      ..

  002bd	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  002c0	0f b6 88 90 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1424]
  002c7	83 f9 01	 cmp	 ecx, 1
  002ca	0f 85 1b 08 00
	00		 jne	 $LN1@GCGuildWar

; 12820: 	{   //  ?
; 12821: 		if( lpMyNode->lpTargetGuildNode != NULL )

  002d0	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  002d3	83 b8 8c 05 00
	00 00		 cmp	 DWORD PTR [eax+1420], 0
  002da	0f 84 0b 08 00
	00		 je	 $LN1@GCGuildWar

; 12822: 		{
; 12823: 			if( lpMyNode->lpTargetGuildNode->WarDeclareState == 1 )

  002e0	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  002e3	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  002e9	0f b6 91 90 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1424]
  002f0	83 fa 01	 cmp	 edx, 1
  002f3	0f 85 f2 07 00
	00		 jne	 $LN1@GCGuildWar

; 12824: 			{	
; 12825: 				PMSG_TELEPORT pTeleportMsg;
; 12826: 				if( lpMyNode->WarType == BTT_SOCCER )

  002f9	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  002fc	0f b6 88 92 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1426]
  00303	83 f9 01	 cmp	 ecx, 1
  00306	0f 85 72 01 00
	00		 jne	 $LN21@GCGuildWar

; 12827: 				{
; 12828: 					PMSG_GUILDWARREQUEST_RESULT	pResult;
; 12829: 					
; 12830: 					lpMyNode->BattleGroundIndex = gCheckBlankBattleGround();

  0030c	e8 00 00 00 00	 call	 ?gCheckBlankBattleGround@@YAHXZ ; gCheckBlankBattleGround
  00311	8b 4d e0	 mov	 ecx, DWORD PTR _lpMyNode$[ebp]
  00314	88 81 93 05 00
	00		 mov	 BYTE PTR [ecx+1427], al

; 12831: 					//lpMyNode->BattleGroundIndex = 0;//gCheckBlankBattleGround();
; 12832: 					switch( lpMyNode->BattleGroundIndex )

  0031a	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  0031d	8a 88 93 05 00
	00		 mov	 cl, BYTE PTR [eax+1427]
  00323	88 8d 64 fe ff
	ff		 mov	 BYTE PTR tv207[ebp], cl
  00329	80 bd 64 fe ff
	ff ff		 cmp	 BYTE PTR tv207[ebp], 255 ; 000000ffH
  00330	74 02		 je	 SHORT $LN22@GCGuildWar
  00332	eb 6e		 jmp	 SHORT $LN23@GCGuildWar
$LN22@GCGuildWar:

; 12833: 					{
; 12834: 					case 0xFF :	//  .
; 12835: 
; 12836: 						lpMyNode->WarDeclareState					= 0;

  00334	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00337	c6 80 90 05 00
	00 00		 mov	 BYTE PTR [eax+1424], 0

; 12837: 						lpMyNode->WarState							= 0;

  0033e	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00341	c6 80 91 05 00
	00 00		 mov	 BYTE PTR [eax+1425], 0

; 12838: 						lpMyNode->lpTargetGuildNode->WarDeclareState= 0;

  00348	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  0034b	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00351	c6 81 90 05 00
	00 00		 mov	 BYTE PTR [ecx+1424], 0

; 12839: 						lpMyNode->lpTargetGuildNode->WarState		= 0;

  00358	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  0035b	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00361	c6 81 91 05 00
	00 00		 mov	 BYTE PTR [ecx+1425], 0

; 12840: 
; 12841: 						PHeadSetB((LPBYTE)&pResult, 0x60, sizeof( pResult ));

  00368	6a 04		 push	 4
  0036a	6a 60		 push	 96			; 00000060H
  0036c	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$5[ebp]
  00372	50		 push	 eax
  00373	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00378	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12842: 
; 12843: 						pResult.Result		= 0x04;

  0037b	c6 85 bb fe ff
	ff 04		 mov	 BYTE PTR _pResult$5[ebp+3], 4

; 12844: 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00382	0f b6 85 b9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$5[ebp+1]
  00389	50		 push	 eax
  0038a	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _pResult$5[ebp]
  00390	51		 push	 ecx
  00391	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00394	52		 push	 edx
  00395	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0039a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12845: 						return;

  0039d	e9 49 07 00 00	 jmp	 $LN1@GCGuildWar
$LN23@GCGuildWar:

; 12846: 						//case 0 :	pTeleportMsg.MoveNumber = 51;	
; 12847: 						//			gBSGround[0]->Enable(TRUE);
; 12848: 						//	break;
; 12849: 					default:	pTeleportMsg.MoveNumber = 51;	

  003a2	c6 85 bf fe ff
	ff 33		 mov	 BYTE PTR _pTeleportMsg$6[ebp+3], 51 ; 00000033H

; 12850: 						lpMyNode->lpTargetGuildNode->BattleGroundIndex = lpMyNode->BattleGroundIndex;

  003a9	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  003ac	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  003b2	8b 55 e0	 mov	 edx, DWORD PTR _lpMyNode$[ebp]
  003b5	8a 82 93 05 00
	00		 mov	 al, BYTE PTR [edx+1427]
  003bb	88 81 93 05 00
	00		 mov	 BYTE PTR [ecx+1427], al

; 12851: 						
; 12852: 						//  
; 12853: 						if( gBSGround[0]->m_BallIndex >= 0 )

  003c1	b8 04 00 00 00	 mov	 eax, 4
  003c6	6b c8 00	 imul	 ecx, eax, 0
  003c9	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?gBSGround@@3PAPAVCBattleSoccer@@A[ecx]
  003cf	83 7a 64 00	 cmp	 DWORD PTR [edx+100], 0
  003d3	7c 24		 jl	 SHORT $LN24@GCGuildWar

; 12854: 							gObjMonsterRegen(&gObj[gBSGround[0]->m_BallIndex]);

  003d5	b8 04 00 00 00	 mov	 eax, 4
  003da	6b c8 00	 imul	 ecx, eax, 0
  003dd	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?gBSGround@@3PAPAVCBattleSoccer@@A[ecx]
  003e3	69 42 64 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+100], 7072
  003ea	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f0	50		 push	 eax
  003f1	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterRegen
  003f6	83 c4 04	 add	 esp, 4
$LN24@GCGuildWar:

; 12855: 
; 12856: 						BattleSoccerGoalEnd(0);

  003f9	6a 00		 push	 0
  003fb	e8 00 00 00 00	 call	 ?BattleSoccerGoalEnd@@YAXH@Z ; BattleSoccerGoalEnd
  00400	83 c4 04	 add	 esp, 4

; 12857: 						
; 12858: 						lpMyNode->PlayScore = 0;

  00403	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00406	c6 80 95 05 00
	00 00		 mov	 BYTE PTR [eax+1429], 0

; 12859: 						lpMyNode->lpTargetGuildNode->PlayScore = 0;

  0040d	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00410	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00416	c6 81 95 05 00
	00 00		 mov	 BYTE PTR [ecx+1429], 0

; 12860: 
; 12861: 						gBattleGroundEnable(lpMyNode->BattleGroundIndex, TRUE);

  0041d	6a 01		 push	 1
  0041f	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00422	0f b6 88 93 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1427]
  00429	51		 push	 ecx
  0042a	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable
  0042f	83 c4 08	 add	 esp, 8

; 12862: 						gSetBattleTeamMaster(lpMyNode->BattleGroundIndex, 0, lpMyNode->Name, lpMyNode);

  00432	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00435	50		 push	 eax
  00436	8b 4d e0	 mov	 ecx, DWORD PTR _lpMyNode$[ebp]
  00439	83 c1 04	 add	 ecx, 4
  0043c	51		 push	 ecx
  0043d	6a 00		 push	 0
  0043f	8b 55 e0	 mov	 edx, DWORD PTR _lpMyNode$[ebp]
  00442	0f b6 82 93 05
	00 00		 movzx	 eax, BYTE PTR [edx+1427]
  00449	50		 push	 eax
  0044a	e8 00 00 00 00	 call	 ?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z ; gSetBattleTeamMaster
  0044f	83 c4 10	 add	 esp, 16			; 00000010H

; 12863: 						gSetBattleTeamMaster(lpMyNode->BattleGroundIndex, 1, lpMyNode->lpTargetGuildNode->Name, lpMyNode->lpTargetGuildNode);

  00452	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00455	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0045b	51		 push	 ecx
  0045c	8b 55 e0	 mov	 edx, DWORD PTR _lpMyNode$[ebp]
  0045f	8b 82 8c 05 00
	00		 mov	 eax, DWORD PTR [edx+1420]
  00465	83 c0 04	 add	 eax, 4
  00468	50		 push	 eax
  00469	6a 01		 push	 1
  0046b	8b 4d e0	 mov	 ecx, DWORD PTR _lpMyNode$[ebp]
  0046e	0f b6 91 93 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1427]
  00475	52		 push	 edx
  00476	e8 00 00 00 00	 call	 ?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z ; gSetBattleTeamMaster
  0047b	83 c4 10	 add	 esp, 16			; 00000010H
$LN21@GCGuildWar:

; 12864: 						break;
; 12865: 					}
; 12866: 				}
; 12867: 				
; 12868: 				lpMyNode->WarDeclareState					= 2;

  0047e	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00481	c6 80 90 05 00
	00 02		 mov	 BYTE PTR [eax+1424], 2

; 12869: 				lpMyNode->WarState							= 1;

  00488	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  0048b	c6 80 91 05 00
	00 01		 mov	 BYTE PTR [eax+1425], 1

; 12870: 				lpMyNode->lpTargetGuildNode->WarDeclareState= 2;

  00492	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00495	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0049b	c6 81 90 05 00
	00 02		 mov	 BYTE PTR [ecx+1424], 2

; 12871: 				lpMyNode->lpTargetGuildNode->WarState		= 1;

  004a2	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  004a5	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  004ab	c6 81 91 05 00
	00 01		 mov	 BYTE PTR [ecx+1425], 1

; 12872: 				lpMyNode->PlayScore							= 0;

  004b2	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  004b5	c6 80 95 05 00
	00 00		 mov	 BYTE PTR [eax+1429], 0

; 12873: 				lpMyNode->lpTargetGuildNode->PlayScore		= 0;

  004bc	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  004bf	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  004c5	c6 81 95 05 00
	00 00		 mov	 BYTE PTR [ecx+1429], 0

; 12874: 								
; 12875: 				lpMyNode->BattleTeamCode					= 0;

  004cc	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  004cf	c6 80 94 05 00
	00 00		 mov	 BYTE PTR [eax+1428], 0

; 12876: 				lpMyNode->lpTargetGuildNode->BattleTeamCode = 1;

  004d6	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  004d9	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  004df	c6 81 94 05 00
	00 01		 mov	 BYTE PTR [ecx+1428], 1

; 12877: 
; 12878: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 12879: 				lpMyNode->GuildWarTickCount	 = GetTickCount();
; 12880: 				lpMyNode->lpTargetGuildNode->GuildWarTickCount	 = GetTickCount();
; 12881: #endif
; 12882: 						
; 12883: 				memset( pMsg.GuildName, 0, MAX_GUILDNAMESTRING);

  004e6	6a 08		 push	 8
  004e8	6a 00		 push	 0
  004ea	8d 45 ef	 lea	 eax, DWORD PTR _pMsg$[ebp+3]
  004ed	50		 push	 eax
  004ee	e8 00 00 00 00	 call	 _memset
  004f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12884: 				memcpy( pMsg.GuildName, lpMyNode->lpTargetGuildNode->Name, MAX_GUILDNAMESTRING);

  004f6	6a 08		 push	 8
  004f8	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  004fb	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00501	83 c1 04	 add	 ecx, 4
  00504	51		 push	 ecx
  00505	8d 55 ef	 lea	 edx, DWORD PTR _pMsg$[ebp+3]
  00508	52		 push	 edx
  00509	e8 00 00 00 00	 call	 _memcpy
  0050e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12885: 
; 12886: 				pMsg.TeamCode	= lpMyNode->BattleTeamCode;

  00511	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00514	8a 88 94 05 00
	00		 mov	 cl, BYTE PTR [eax+1428]
  0051a	88 4d f8	 mov	 BYTE PTR _pMsg$[ebp+12], cl

; 12887: 				count = 0;

  0051d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 12888: 				for( int n=0; n<MAX_GUILD; n++)

  00524	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$4[ebp], 0
  0052e	eb 0f		 jmp	 SHORT $LN6@GCGuildWar
$LN4@GCGuildWar:
  00530	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  00536	83 c0 01	 add	 eax, 1
  00539	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _n$4[ebp], eax
$LN6@GCGuildWar:
  0053f	83 bd b4 fe ff
	ff 50		 cmp	 DWORD PTR _n$4[ebp], 80	; 00000050H
  00546	0f 8d 20 02 00
	00		 jge	 $LN5@GCGuildWar

; 12889: 				{
; 12890: 					if( lpMyNode->Use[n] )

  0054c	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  0054f	03 85 b4 fe ff
	ff		 add	 eax, DWORD PTR _n$4[ebp]
  00555	0f b6 88 40 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1088]
  0055c	85 c9		 test	 ecx, ecx
  0055e	0f 84 03 02 00
	00		 je	 $LN25@GCGuildWar

; 12891: 					{
; 12892: 						if( lpMyNode->Index[n] >= 0 )

  00564	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0056a	8b 4d e0	 mov	 ecx, DWORD PTR _lpMyNode$[ebp]
  0056d	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00575	85 d2		 test	 edx, edx
  00577	0f 8c ea 01 00
	00		 jl	 $LN25@GCGuildWar

; 12893: 						{
; 12894: 							g_call = 0;

  0057d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _g_call$[ebp], 0

; 12895: 
; 12896: 							//    .
; 12897: 							if( n > 0 )

  00584	83 bd b4 fe ff
	ff 00		 cmp	 DWORD PTR _n$4[ebp], 0
  0058b	0f 8e 96 00 00
	00		 jle	 $LN27@GCGuildWar

; 12898: 							{
; 12899: 								if( lpMyNode->WarType == BTT_SOCCER )

  00591	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00594	0f b6 88 92 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1426]
  0059b	83 f9 01	 cmp	 ecx, 1
  0059e	75 7e		 jne	 SHORT $LN29@GCGuildWar

; 12900: 								{
; 12901: 									if( gObj[lpMyNode->Index[0]].PartyNumber >= 0 )

  005a0	b8 02 00 00 00	 mov	 eax, 2
  005a5	6b c8 00	 imul	 ecx, eax, 0
  005a8	8b 55 e0	 mov	 edx, DWORD PTR _lpMyNode$[ebp]
  005ab	0f bf 84 0a a0
	03 00 00	 movsx	 eax, WORD PTR [edx+ecx+928]
  005b3	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  005b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005bf	83 bc 0a 88 02
	00 00 00	 cmp	 DWORD PTR [edx+ecx+648], 0
  005c7	7c 53		 jl	 SHORT $LN31@GCGuildWar

; 12902: 									{
; 12903: 										if( gObj[lpMyNode->Index[0]].PartyNumber == gObj[lpMyNode->Index[n]].PartyNumber )

  005c9	b8 02 00 00 00	 mov	 eax, 2
  005ce	6b c8 00	 imul	 ecx, eax, 0
  005d1	8b 55 e0	 mov	 edx, DWORD PTR _lpMyNode$[ebp]
  005d4	0f bf 84 0a a0
	03 00 00	 movsx	 eax, WORD PTR [edx+ecx+928]
  005dc	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  005e2	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _n$4[ebp]
  005e8	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  005eb	0f bf 94 50 a0
	03 00 00	 movsx	 edx, WORD PTR [eax+edx*2+928]
  005f3	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  005f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ff	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00605	8b 8c 0a 88 02
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+648]
  0060c	3b 8c 06 88 02
	00 00		 cmp	 ecx, DWORD PTR [esi+eax+648]
  00613	75 07		 jne	 SHORT $LN31@GCGuildWar

; 12904: 										{
; 12905: 											g_call = 1;

  00615	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _g_call$[ebp], 1
$LN31@GCGuildWar:

; 12906: 										}
; 12907: 									}
; 12908: 								}

  0061c	eb 07		 jmp	 SHORT $LN30@GCGuildWar
$LN29@GCGuildWar:

; 12909: 								else
; 12910: 								{
; 12911: 									g_call = 1;

  0061e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _g_call$[ebp], 1
$LN30@GCGuildWar:

; 12912: 								}
; 12913: 							}

  00625	eb 10		 jmp	 SHORT $LN28@GCGuildWar
$LN27@GCGuildWar:

; 12914: 							else if( n == 0 )

  00627	83 bd b4 fe ff
	ff 00		 cmp	 DWORD PTR _n$4[ebp], 0
  0062e	75 07		 jne	 SHORT $LN28@GCGuildWar

; 12915: 							{
; 12916: 								g_call = 1;

  00630	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _g_call$[ebp], 1
$LN28@GCGuildWar:

; 12917: 							}
; 12918: 							if( g_call ) 

  00637	83 7d e4 00	 cmp	 DWORD PTR _g_call$[ebp], 0
  0063b	0f 84 26 01 00
	00		 je	 $LN25@GCGuildWar

; 12919: 							{
; 12920: 								DataSend( lpMyNode->Index[n], (LPBYTE)&pMsg, pMsg.h.size);

  00641	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00645	50		 push	 eax
  00646	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00649	51		 push	 ecx
  0064a	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _n$4[ebp]
  00650	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00653	0f bf 8c 50 a0
	03 00 00	 movsx	 ecx, WORD PTR [eax+edx*2+928]
  0065b	51		 push	 ecx
  0065c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00661	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12921: 								LogAddTD(lMsg.Get(494),lpMyNode->Name);

  00664	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00667	83 c0 04	 add	 eax, 4
  0066a	50		 push	 eax
  0066b	68 ee 01 00 00	 push	 494			; 000001eeH
  00670	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00675	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0067b	50		 push	 eax
  0067c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00682	83 c4 08	 add	 esp, 8

; 12922: 								GCGuildWarScore(lpMyNode->Index[n]);

  00685	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  0068b	8b 4d e0	 mov	 ecx, DWORD PTR _lpMyNode$[ebp]
  0068e	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00696	52		 push	 edx
  00697	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore
  0069c	83 c4 04	 add	 esp, 4

; 12923: 						
; 12924: 								int x=60;								

  0069f	c7 85 b0 fe ff
	ff 3c 00 00 00	 mov	 DWORD PTR _x$3[ebp], 60	; 0000003cH

; 12925: 								if( lpMyNode->WarType == BTT_SOCCER )

  006a9	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  006ac	0f b6 88 92 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1426]
  006b3	83 f9 01	 cmp	 ecx, 1
  006b6	0f 85 ab 00 00
	00		 jne	 $LN25@GCGuildWar

; 12926: 								{
; 12927: 									gObj[lpMyNode->Index[n]].IsInBattleGround = TRUE;

  006bc	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  006c2	8b 4d e0	 mov	 ecx, DWORD PTR _lpMyNode$[ebp]
  006c5	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  006cd	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  006d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006d9	c6 84 01 7a 0e
	00 00 01	 mov	 BYTE PTR [ecx+eax+3706], 1

; 12928: 
; 12929: 									pTeleportMsg.MoveNumber = 51;

  006e1	c6 85 bf fe ff
	ff 33		 mov	 BYTE PTR _pTeleportMsg$6[ebp+3], 51 ; 00000033H

; 12930: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 12931: 									if( gPkLimitFree || gObj[lpMyNode->Index[n]].m_PK_Level < 6 )

  006e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  006ef	75 2a		 jne	 SHORT $LN37@GCGuildWar
  006f1	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _n$4[ebp]
  006f7	8b 4d e0	 mov	 ecx, DWORD PTR _lpMyNode$[ebp]
  006fa	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00702	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  00708	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0070e	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00716	83 fa 06	 cmp	 edx, 6
  00719	7d 4c		 jge	 SHORT $LN25@GCGuildWar
$LN37@GCGuildWar:

; 12932: #else
; 12933: 									if( gObj[lpMyNode->Index[n]].m_PK_Level < 6 )
; 12934: #endif
; 12935: 									{	//     
; 12936: 										gObjTeleport(lpMyNode->Index[n], 6, x++, 153);

  0071b	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _x$3[ebp]
  00721	89 85 64 fe ff
	ff		 mov	 DWORD PTR tv396[ebp], eax
  00727	68 99 00 00 00	 push	 153			; 00000099H
  0072c	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR tv396[ebp]
  00732	51		 push	 ecx
  00733	6a 06		 push	 6
  00735	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _n$4[ebp]
  0073b	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  0073e	0f bf 8c 50 a0
	03 00 00	 movsx	 ecx, WORD PTR [eax+edx*2+928]
  00746	51		 push	 ecx
  00747	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  0074c	83 c4 10	 add	 esp, 16			; 00000010H
  0074f	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR _x$3[ebp]
  00755	83 c2 01	 add	 edx, 1
  00758	89 95 b0 fe ff
	ff		 mov	 DWORD PTR _x$3[ebp], edx

; 12937: 										count++;

  0075e	8b 45 e8	 mov	 eax, DWORD PTR _count$[ebp]
  00761	83 c0 01	 add	 eax, 1
  00764	89 45 e8	 mov	 DWORD PTR _count$[ebp], eax
$LN25@GCGuildWar:

; 12938: 									}
; 12939: 								}
; 12940: 							}							
; 12941: 						}
; 12942: 					}
; 12943: 				}

  00767	e9 c4 fd ff ff	 jmp	 $LN4@GCGuildWar
$LN5@GCGuildWar:

; 12944: 				memset( pMsg.GuildName, 0, MAX_GUILDNAMESTRING);

  0076c	6a 08		 push	 8
  0076e	6a 00		 push	 0
  00770	8d 45 ef	 lea	 eax, DWORD PTR _pMsg$[ebp+3]
  00773	50		 push	 eax
  00774	e8 00 00 00 00	 call	 _memset
  00779	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12945: 				memcpy( pMsg.GuildName, lpMyNode->Name, MAX_GUILDNAMESTRING);

  0077c	6a 08		 push	 8
  0077e	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00781	83 c0 04	 add	 eax, 4
  00784	50		 push	 eax
  00785	8d 4d ef	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  00788	51		 push	 ecx
  00789	e8 00 00 00 00	 call	 _memcpy
  0078e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12946: 
; 12947: 
; 12948: 				pMsg.TeamCode	= lpMyNode->lpTargetGuildNode->BattleTeamCode;

  00791	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00794	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0079a	8a 91 94 05 00
	00		 mov	 dl, BYTE PTR [ecx+1428]
  007a0	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+12], dl

; 12949: 				count = 0;

  007a3	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 12950: 				for( int n=0; n<MAX_GUILD; n++)

  007aa	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$2[ebp], 0
  007b4	eb 0f		 jmp	 SHORT $LN9@GCGuildWar
$LN7@GCGuildWar:
  007b6	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _n$2[ebp]
  007bc	83 c0 01	 add	 eax, 1
  007bf	89 85 ac fe ff
	ff		 mov	 DWORD PTR _n$2[ebp], eax
$LN9@GCGuildWar:
  007c5	83 bd ac fe ff
	ff 50		 cmp	 DWORD PTR _n$2[ebp], 80	; 00000050H
  007cc	0f 8d 65 02 00
	00		 jge	 $LN8@GCGuildWar

; 12951: 				{
; 12952: 					if( lpMyNode->lpTargetGuildNode->Use[n] )

  007d2	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  007d5	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  007db	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _n$2[ebp]
  007e1	0f b6 84 11 40
	04 00 00	 movzx	 eax, BYTE PTR [ecx+edx+1088]
  007e9	85 c0		 test	 eax, eax
  007eb	0f 84 41 02 00
	00		 je	 $LN38@GCGuildWar

; 12953: 					{
; 12954: 						if( lpMyNode->lpTargetGuildNode->Index[n] >= 0 )

  007f1	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  007f4	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  007fa	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _n$2[ebp]
  00800	0f bf 84 51 a0
	03 00 00	 movsx	 eax, WORD PTR [ecx+edx*2+928]
  00808	85 c0		 test	 eax, eax
  0080a	0f 8c 22 02 00
	00		 jl	 $LN38@GCGuildWar

; 12955: 						{
; 12956: 							g_call = 0;

  00810	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _g_call$[ebp], 0

; 12957: 
; 12958: 							//    .
; 12959: 							if( n > 0 )

  00817	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR _n$2[ebp], 0
  0081e	0f 8e ab 00 00
	00		 jle	 $LN40@GCGuildWar

; 12960: 							{
; 12961: 								if( lpMyNode->WarType == BTT_SOCCER )

  00824	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00827	0f b6 88 92 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1426]
  0082e	83 f9 01	 cmp	 ecx, 1
  00831	0f 85 8f 00 00
	00		 jne	 $LN42@GCGuildWar

; 12962: 								{
; 12963: 									if( gObj[lpMyNode->lpTargetGuildNode->Index[0]].PartyNumber >= 0 )

  00837	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  0083a	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00840	ba 02 00 00 00	 mov	 edx, 2
  00845	6b c2 00	 imul	 eax, edx, 0
  00848	0f bf 8c 01 a0
	03 00 00	 movsx	 ecx, WORD PTR [ecx+eax+928]
  00850	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00856	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0085b	83 bc 10 88 02
	00 00 00	 cmp	 DWORD PTR [eax+edx+648], 0
  00863	7c 5f		 jl	 SHORT $LN44@GCGuildWar

; 12964: 									{
; 12965: 										if( gObj[lpMyNode->lpTargetGuildNode->Index[0]].PartyNumber == gObj[lpMyNode->lpTargetGuildNode->Index[n]].PartyNumber )

  00865	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00868	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0086e	ba 02 00 00 00	 mov	 edx, 2
  00873	6b c2 00	 imul	 eax, edx, 0
  00876	0f bf 8c 01 a0
	03 00 00	 movsx	 ecx, WORD PTR [ecx+eax+928]
  0087e	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00884	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00887	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0088d	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _n$2[ebp]
  00893	0f bf 8c 41 a0
	03 00 00	 movsx	 ecx, WORD PTR [ecx+eax*2+928]
  0089b	69 c1 a0 1b 00
	00		 imul	 eax, ecx, 7072
  008a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008a7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008ad	8b 94 11 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+edx+648]
  008b4	3b 94 06 88 02
	00 00		 cmp	 edx, DWORD PTR [esi+eax+648]
  008bb	75 07		 jne	 SHORT $LN44@GCGuildWar

; 12966: 										{
; 12967: 											g_call = 1;

  008bd	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _g_call$[ebp], 1
$LN44@GCGuildWar:

; 12968: 										}
; 12969: 									}
; 12970: 								}

  008c4	eb 07		 jmp	 SHORT $LN43@GCGuildWar
$LN42@GCGuildWar:

; 12971: 								else
; 12972: 								{
; 12973: 									g_call = 1;

  008c6	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _g_call$[ebp], 1
$LN43@GCGuildWar:

; 12974: 								}
; 12975: 							}

  008cd	eb 10		 jmp	 SHORT $LN41@GCGuildWar
$LN40@GCGuildWar:

; 12976: 							else if( n == 0 )

  008cf	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR _n$2[ebp], 0
  008d6	75 07		 jne	 SHORT $LN41@GCGuildWar

; 12977: 							{
; 12978: 								g_call = 1;

  008d8	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _g_call$[ebp], 1
$LN41@GCGuildWar:

; 12979: 							}
; 12980: 							if( g_call ) 

  008df	83 7d e4 00	 cmp	 DWORD PTR _g_call$[ebp], 0
  008e3	0f 84 49 01 00
	00		 je	 $LN38@GCGuildWar

; 12981: 							{
; 12982: 								DataSend( lpMyNode->lpTargetGuildNode->Index[n], (LPBYTE)&pMsg, pMsg.h.size);

  008e9	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  008ed	50		 push	 eax
  008ee	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  008f1	51		 push	 ecx
  008f2	8b 55 e0	 mov	 edx, DWORD PTR _lpMyNode$[ebp]
  008f5	8b 82 8c 05 00
	00		 mov	 eax, DWORD PTR [edx+1420]
  008fb	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR _n$2[ebp]
  00901	0f bf 94 48 a0
	03 00 00	 movsx	 edx, WORD PTR [eax+ecx*2+928]
  00909	52		 push	 edx
  0090a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0090f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12983: 								LogAddTD(lMsg.Get(494), lpMyNode->lpTargetGuildNode->Name);

  00912	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00915	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0091b	83 c1 04	 add	 ecx, 4
  0091e	51		 push	 ecx
  0091f	68 ee 01 00 00	 push	 494			; 000001eeH
  00924	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00929	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0092f	50		 push	 eax
  00930	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00936	83 c4 08	 add	 esp, 8

; 12984: 								GCGuildWarScore(lpMyNode->lpTargetGuildNode->Index[n]);

  00939	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  0093c	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00942	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _n$2[ebp]
  00948	0f bf 84 51 a0
	03 00 00	 movsx	 eax, WORD PTR [ecx+edx*2+928]
  00950	50		 push	 eax
  00951	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore
  00956	83 c4 04	 add	 esp, 4

; 12985: 
; 12986: 								int x=59;

  00959	c7 85 a8 fe ff
	ff 3b 00 00 00	 mov	 DWORD PTR _x$1[ebp], 59	; 0000003bH

; 12987: 								if( lpMyNode->lpTargetGuildNode->WarType == BTT_SOCCER )

  00963	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00966	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0096c	0f b6 91 92 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1426]
  00973	83 fa 01	 cmp	 edx, 1
  00976	0f 85 b6 00 00
	00		 jne	 $LN38@GCGuildWar

; 12988: 								{	
; 12989: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 12990: 									if( gPkLimitFree || gObj[lpMyNode->lpTargetGuildNode->Index[n]].m_PK_Level < 6 )

  0097c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00983	75 30		 jne	 SHORT $LN50@GCGuildWar
  00985	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00988	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0098e	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _n$2[ebp]
  00994	0f bf 84 51 a0
	03 00 00	 movsx	 eax, WORD PTR [ecx+edx*2+928]
  0099c	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  009a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009a8	0f be 84 0a fd
	00 00 00	 movsx	 eax, BYTE PTR [edx+ecx+253]
  009b0	83 f8 06	 cmp	 eax, 6
  009b3	7d 7d		 jge	 SHORT $LN38@GCGuildWar
$LN50@GCGuildWar:

; 12991: #else
; 12992: 									if( gObj[lpMyNode->lpTargetGuildNode->Index[n]].m_PK_Level < 6 )
; 12993: #endif
; 12994: 									{	//     
; 12995: 										gObj[lpMyNode->lpTargetGuildNode->Index[n]].IsInBattleGround = TRUE;

  009b5	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  009b8	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  009be	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _n$2[ebp]
  009c4	0f bf 84 51 a0
	03 00 00	 movsx	 eax, WORD PTR [ecx+edx*2+928]
  009cc	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  009d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009d8	c6 84 0a 7a 0e
	00 00 01	 mov	 BYTE PTR [edx+ecx+3706], 1

; 12996: 
; 12997: 										gObjTeleport(lpMyNode->lpTargetGuildNode->Index[n], 6, x++, 164);

  009e0	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _x$1[ebp]
  009e6	89 85 64 fe ff
	ff		 mov	 DWORD PTR tv507[ebp], eax
  009ec	68 a4 00 00 00	 push	 164			; 000000a4H
  009f1	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR tv507[ebp]
  009f7	51		 push	 ecx
  009f8	6a 06		 push	 6
  009fa	8b 55 e0	 mov	 edx, DWORD PTR _lpMyNode$[ebp]
  009fd	8b 82 8c 05 00
	00		 mov	 eax, DWORD PTR [edx+1420]
  00a03	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR _n$2[ebp]
  00a09	0f bf 94 48 a0
	03 00 00	 movsx	 edx, WORD PTR [eax+ecx*2+928]
  00a11	52		 push	 edx
  00a12	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  00a17	83 c4 10	 add	 esp, 16			; 00000010H
  00a1a	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _x$1[ebp]
  00a20	83 c0 01	 add	 eax, 1
  00a23	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _x$1[ebp], eax

; 12998: 										//pTeleportMsg.MoveNumber = 52;
; 12999: 										//CGTeleportRecv(&pTeleportMsg, lpMyNode->lpTargetGuildNode->Index[n]);
; 13000: 										count++;

  00a29	8b 45 e8	 mov	 eax, DWORD PTR _count$[ebp]
  00a2c	83 c0 01	 add	 eax, 1
  00a2f	89 45 e8	 mov	 DWORD PTR _count$[ebp], eax
$LN38@GCGuildWar:

; 13001: 									}
; 13002: 								}
; 13003: 							}
; 13004: 						}
; 13005: 					}			
; 13006: 				}

  00a32	e9 7f fd ff ff	 jmp	 $LN7@GCGuildWar
$LN8@GCGuildWar:

; 13007: 				cManager.BattleInfoSend(GetBattleTeamName(0, 0), GetBattleTeamScore(0, 0), GetBattleTeamName(0, 1), GetBattleTeamScore(0, 1));

  00a37	6a 01		 push	 1
  00a39	6a 00		 push	 0
  00a3b	e8 00 00 00 00	 call	 ?GetBattleTeamScore@@YAHHH@Z ; GetBattleTeamScore
  00a40	83 c4 08	 add	 esp, 8
  00a43	50		 push	 eax
  00a44	6a 01		 push	 1
  00a46	6a 00		 push	 0
  00a48	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  00a4d	83 c4 08	 add	 esp, 8
  00a50	50		 push	 eax
  00a51	6a 00		 push	 0
  00a53	6a 00		 push	 0
  00a55	e8 00 00 00 00	 call	 ?GetBattleTeamScore@@YAHHH@Z ; GetBattleTeamScore
  00a5a	83 c4 08	 add	 esp, 8
  00a5d	50		 push	 eax
  00a5e	6a 00		 push	 0
  00a60	6a 00		 push	 0
  00a62	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  00a67	83 c4 08	 add	 esp, 8
  00a6a	50		 push	 eax
  00a6b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  00a70	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend

; 13008: 				
; 13009: 				if( lpMyNode->WarType == BTT_SOCCER )

  00a75	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00a78	0f b6 88 92 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1426]
  00a7f	83 f9 01	 cmp	 ecx, 1
  00a82	75 67		 jne	 SHORT $LN1@GCGuildWar

; 13010: 				{
; 13011: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 13012: 					gObjAddMsgSendDelay(&gObj[aIndex], MSG_BSSTART, aIndex, 1000*15);
; 13013: #else
; 13014: 					gObjAddMsgSendDelay(&gObj[aIndex], MSG_BSSTART, aIndex, 1000*10);

  00a84	6a 00		 push	 0
  00a86	68 10 27 00 00	 push	 10000			; 00002710H
  00a8b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a8e	50		 push	 eax
  00a8f	6a 05		 push	 5
  00a91	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00a98	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a9e	51		 push	 ecx
  00a9f	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00aa4	83 c4 14	 add	 esp, 20			; 00000014H

; 13015: #endif
; 13016: 				
; 13017: 					//   3   .
; 13018: 					GCServerMsgStringSendGuild(lpMyNode->lpTargetGuildNode, lMsg.Get(1154), 1);

  00aa7	6a 01		 push	 1
  00aa9	68 82 04 00 00	 push	 1154			; 00000482H
  00aae	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00ab3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00ab9	50		 push	 eax
  00aba	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00abd	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00ac3	51		 push	 ecx
  00ac4	e8 00 00 00 00	 call	 ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
  00ac9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13019: 					GCServerMsgStringSendGuild(lpMyNode, lMsg.Get(1154), 1);

  00acc	6a 01		 push	 1
  00ace	68 82 04 00 00	 push	 1154			; 00000482H
  00ad3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00ad8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00ade	50		 push	 eax
  00adf	8b 45 e0	 mov	 eax, DWORD PTR _lpMyNode$[ebp]
  00ae2	50		 push	 eax
  00ae3	e8 00 00 00 00	 call	 ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
  00ae8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildWar:

; 13020: 				}
; 13021: 			}		
; 13022: 		}
; 13023: 	}
; 13024: }

  00aeb	5f		 pop	 edi
  00aec	5e		 pop	 esi
  00aed	5b		 pop	 ebx
  00aee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00af1	33 cd		 xor	 ecx, ebp
  00af3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00af8	8b e5		 mov	 esp, ebp
  00afa	5d		 pop	 ebp
  00afb	c3		 ret	 0
?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ENDP ; GCGuildWarRequestSendRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGGuildMasterCreateCancel@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGGuildMasterCreateCancel@@YAXH@Z PROC			; CGGuildMasterCreateCancel, COMDAT

; 12253: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12254: 	if( gObj[aIndex].GuildNumber > 0 ) return;

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	83 bc 01 90 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+656], 0
  0001e	7e 02		 jle	 SHORT $LN2@CGGuildMas
  00020	eb 6b		 jmp	 SHORT $LN1@CGGuildMas
$LN2@CGGuildMas:

; 12255: 	if( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_GUILDCREATE )

  00022	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002f	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00036	80 e2 03	 and	 dl, 3
  00039	0f b6 c2	 movzx	 eax, dl
  0003c	85 c0		 test	 eax, eax
  0003e	74 4d		 je	 SHORT $LN1@CGGuildMas
  00040	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00054	c0 ea 04	 shr	 dl, 4
  00057	80 e2 0f	 and	 dl, 15			; 0000000fH
  0005a	0f b6 c2	 movzx	 eax, dl
  0005d	83 f8 05	 cmp	 eax, 5
  00060	75 2b		 jne	 SHORT $LN1@CGGuildMas

; 12256: 		gObj[aIndex].m_IfState.use    = 0;

  00062	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006f	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00076	80 e2 fc	 and	 dl, 252			; 000000fcH
  00079	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00086	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN1@CGGuildMas:

; 12257: }

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?CGGuildMasterCreateCancel@@YAXH@Z ENDP			; CGGuildMasterCreateCancel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z
_TEXT	SEGMENT
_pMsg$ = -48						; size = 4
_guildname$ = -44					; size = 11
_memberid$ = -32					; size = 11
_joomin$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z PROC	; CGGuildDelUser, COMDAT

; 12008: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 12009: #ifdef UPDATE_USERPASSWORD_LENGTH_20090424	
; 12010: 	char joomin[MAX_JOOMINNUMBER_LENGTH+1] = "";
; 12011: #else	// UPDATE_USERPASSWORD_LENGTH_20090424	
; 12012: 	char joomin[14];
; 12013: #endif	// UPDATE_USERPASSWORD_LENGTH_20090424	
; 12014: 
; 12015: 	char memberid[MAX_IDSTRING+1];
; 12016: 	char guildname[MAX_IDSTRING+1];
; 12017: 
; 12018: 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;

  00013	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN2@CGGuildDel
  0002d	e9 dd 02 00 00	 jmp	 $LN1@CGGuildDel
$LN2@CGGuildDel:

; 12019: 
; 12020: 
; 12021: #ifdef EXDB_APPLY_CASTLEUPDATE_01_20050111
; 12022: #ifdef GAMESERVER_TO_CASTLESIEGESERVER
; 12023: 	//       
; 12024: 	if (g_CastleSiegeSync.GetCastleState() == CASTLESIEGE_SYNC_STATE_STARTSIEGE) 
; 12025: 	{
; 12026: 		MsgOutput( aIndex, lMsg.Get(1731) ); // "    ."
; 12027: 		return;
; 12028: 	}
; 12029: #endif
; 12030: #endif
; 12031: 
; 12032: 	PMSG_GUILDDELUSER_RESULT	pMsg;
; 12033: 
; 12034: 	//   .
; 12035: 	if( gObj[aIndex].GuildNumber < 1 ) return;

  00032	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003f	83 bc 01 90 02
	00 00 01	 cmp	 DWORD PTR [ecx+eax+656], 1
  00047	7d 05		 jge	 SHORT $LN3@CGGuildDel
  00049	e9 c1 02 00 00	 jmp	 $LN1@CGGuildDel
$LN3@CGGuildDel:

; 12036: 
; 12037: 	PHeadSetB((LPBYTE)&pMsg, 0x53, sizeof( pMsg ));

  0004e	6a 04		 push	 4
  00050	6a 53		 push	 83			; 00000053H
  00052	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12038: 	pMsg.Result		= 0x03;

  0005e	c6 45 d3 03	 mov	 BYTE PTR _pMsg$[ebp+3], 3

; 12039: 
; 12040: 	if ( gGuildDestroy == 0 )

  00062	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGuildDestroy@@3HA, 0 ; gGuildDestroy
  00069	75 1a		 jne	 SHORT $LN4@CGGuildDel

; 12041: 	{
; 12042: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0006b	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0006f	50		 push	 eax
  00070	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00073	51		 push	 ecx
  00074	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12043: 		return;

  00080	e9 8a 02 00 00	 jmp	 $LN1@CGGuildDel
$LN4@CGGuildDel:

; 12044: 	}
; 12045: 	memset(memberid, 0, MAX_IDSTRING+1);

  00085	6a 0b		 push	 11			; 0000000bH
  00087	6a 00		 push	 0
  00089	8d 45 e0	 lea	 eax, DWORD PTR _memberid$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _memset
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12046: 	memset(guildname, 0, MAX_IDSTRING+1);

  00095	6a 0b		 push	 11			; 0000000bH
  00097	6a 00		 push	 0
  00099	8d 45 d4	 lea	 eax, DWORD PTR _guildname$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _memset
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12047: 
; 12048: 	memcpy(memberid, lpMsg->Name, MAX_IDSTRING);

  000a5	6a 0a		 push	 10			; 0000000aH
  000a7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000aa	83 c0 03	 add	 eax, 3
  000ad	50		 push	 eax
  000ae	8d 4d e0	 lea	 ecx, DWORD PTR _memberid$[ebp]
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 _memcpy
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12049: 	strcpy(guildname, gObj[aIndex].lpGuild->Name);

  000ba	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  000ce	83 c2 04	 add	 edx, 4
  000d1	52		 push	 edx
  000d2	8d 45 d4	 lea	 eax, DWORD PTR _guildname$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _strcpy
  000db	83 c4 08	 add	 esp, 8

; 12050: 
; 12051: 	//   ??
; 12052: 	if( strcmp(gObj[aIndex].lpGuild->Names[0], gObj[aIndex].Name) == 0 )

  000de	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000eb	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000ef	52		 push	 edx
  000f0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fd	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  00104	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00109	6b c8 00	 imul	 ecx, eax, 0
  0010c	8d 54 0a 2f	 lea	 edx, DWORD PTR [edx+ecx+47]
  00110	52		 push	 edx
  00111	e8 00 00 00 00	 call	 _strcmp
  00116	83 c4 08	 add	 esp, 8
  00119	85 c0		 test	 eax, eax
  0011b	0f 85 07 01 00
	00		 jne	 $LN5@CGGuildDel

; 12053: 	{	
; 12054: #ifdef UPDATE_USERPASSWORD_LENGTH_20090424
; 12055: 		memset(joomin, 0, MAX_JOOMINNUMBER_LENGTH+1);		
; 12056: 		memcpy(joomin, lpMsg->JoominNumber, MAX_JOOMINNUMBER_LENGTH);
; 12057: #else	// UPDATE_USERPASSWORD_LENGTH_20090424
; 12058: 		memset(joomin, 0, 14);		

  00121	6a 0e		 push	 14			; 0000000eH
  00123	6a 00		 push	 0
  00125	8d 45 ec	 lea	 eax, DWORD PTR _joomin$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _memset
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12059: 		memcpy(joomin, lpMsg->JoominNumber, 10);

  00131	6a 0a		 push	 10			; 0000000aH
  00133	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00136	83 c0 0d	 add	 eax, 13			; 0000000dH
  00139	50		 push	 eax
  0013a	8d 4d ec	 lea	 ecx, DWORD PTR _joomin$[ebp]
  0013d	51		 push	 ecx
  0013e	e8 00 00 00 00	 call	 _memcpy
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12060: #endif	// UPDATE_USERPASSWORD_LENGTH_20090424
; 12061: 
; 12062: 		//if( strcmp( joomin, gObj[aIndex].LastJoominNumber) == 0 )
; 12063: 
; 12064: #ifdef FOR_TAIWAN
; 12065: 		if( gObjTaiwanJoominCheck(aIndex, joomin) == TRUE )
; 12066: #else
; 12067: 		if( gObjJoominCheck(aIndex, joomin) == TRUE )

  00146	8d 45 ec	 lea	 eax, DWORD PTR _joomin$[ebp]
  00149	50		 push	 eax
  0014a	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00153	83 c4 08	 add	 esp, 8
  00156	83 f8 01	 cmp	 eax, 1
  00159	0f 85 a6 00 00
	00		 jne	 $LN7@CGGuildDel

; 12068: #endif
; 12069: 		{
; 12070: 			if( strcmp(memberid, gObj[aIndex].Name) == 0 ) //  ..   ?

  0015f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016c	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00170	52		 push	 edx
  00171	8d 45 e0	 lea	 eax, DWORD PTR _memberid$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _strcmp
  0017a	83 c4 08	 add	 esp, 8
  0017d	85 c0		 test	 eax, eax
  0017f	75 38		 jne	 SHORT $LN9@CGGuildDel

; 12071: 			{
; 12072: #ifdef MODIFY_CASTLE_OWNER_GUILD_DESTROY_LIMIT_20060418
; 12073: 	#ifdef GAMESERVER_TO_CASTLESIEGESERVER			
; 12074: 				if( g_bCastleGuildDestoyLimit )
; 12075: 				{
; 12076: 					//      .					
; 12077: 					if( strcmp( gObj[aIndex].lpGuild->Name, g_CastleSiege.GetCastleOwnerGuild() ) == 0 )
; 12078: 					{												
; 12079: 						MsgOutput( aIndex, lMsg.Get( 1725 ) ); // "   ."
; 12080: 						return;
; 12081: 					}
; 12082: 				}
; 12083: 	#endif // GAMESERVER_TO_CASTLESIEGESERVER			
; 12084: #endif	// #ifdef MODIFY_CASTLE_OWNER_GUILD_DESTROY_LIMIT_20060418
; 12085: 				
; 12086: #ifdef BUGFIX_GUILD_DESTROY_WAR_BLOCK_20040922
; 12087: 				//      .
; 12088: 				gObjGuildWarMasterClose(&gObj[aIndex]);
; 12089: #endif				
; 12090: #ifdef _NEW_EXDB_
; 12091: 				GDGuildDestroySend(aIndex, gObj[aIndex].lpGuild->Name, gObj[aIndex].Name);

  00181	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018e	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00192	52		 push	 edx
  00193	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a0	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  001a7	83 c2 04	 add	 edx, 4
  001aa	52		 push	 edx
  001ab	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?GDGuildDestroySend@@YAXHPAD0@Z ; GDGuildDestroySend
  001b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12092: #endif
; 12093: 			}

  001b7	eb 14		 jmp	 SHORT $LN10@CGGuildDel
$LN9@CGGuildDel:

; 12094: 			else //  ?	
; 12095: 			{
; 12096: #ifdef _NEW_EXDB_
; 12097: 				GDGuildMemberDel(aIndex, guildname, memberid);

  001b9	8d 45 e0	 lea	 eax, DWORD PTR _memberid$[ebp]
  001bc	50		 push	 eax
  001bd	8d 4d d4	 lea	 ecx, DWORD PTR _guildname$[ebp]
  001c0	51		 push	 ecx
  001c1	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001c4	52		 push	 edx
  001c5	e8 00 00 00 00	 call	 ?GDGuildMemberDel@@YAXHPAD0@Z ; GDGuildMemberDel
  001ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@CGGuildDel:

; 12098: #endif
; 12099: 			}
; 12100: 			
; 12101: 			LogAddTD("[%s][%s] Guild Request - Dismiss All : %s", gObj[aIndex].AccountID, gObj[aIndex].Name, guildname);

  001cd	8d 45 d4	 lea	 eax, DWORD PTR _guildname$[ebp]
  001d0	50		 push	 eax
  001d1	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001de	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  001e2	50		 push	 eax
  001e3	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f0	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  001f4	50		 push	 eax
  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismis@
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00200	83 c4 10	 add	 esp, 16			; 00000010H

; 12102: 		}

  00203	eb 1e		 jmp	 SHORT $LN8@CGGuildDel
$LN7@CGGuildDel:

; 12103: 		else
; 12104: 		{
; 12105: 			pMsg.Result = 0x00;

  00205	c6 45 d3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 12106: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00209	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0020d	50		 push	 eax
  0020e	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00211	51		 push	 ecx
  00212	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00215	52		 push	 edx
  00216	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0021b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12107: 			return;

  0021e	e9 ec 00 00 00	 jmp	 $LN1@CGGuildDel
$LN8@CGGuildDel:

; 12108: 		}
; 12109: 	}

  00223	e9 e7 00 00 00	 jmp	 $LN1@CGGuildDel
$LN5@CGGuildDel:

; 12110: 	else 
; 12111: 	{
; 12112: 
; 12113: #ifdef ADD_NAMECHECK_DISMISS_GUILDMEMBER_20041129
; 12114: 		//      ..
; 12115: 		if( strncmp(memberid, gObj[aIndex].Name, MAX_IDSTRING) != 0 ) 

  00228	6a 0a		 push	 10			; 0000000aH
  0022a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00231	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00237	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0023b	52		 push	 edx
  0023c	8d 45 e0	 lea	 eax, DWORD PTR _memberid$[ebp]
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 _strncmp
  00245	83 c4 0c	 add	 esp, 12			; 0000000cH
  00248	85 c0		 test	 eax, eax
  0024a	74 1e		 je	 SHORT $LN11@CGGuildDel

; 12116: 		{
; 12117: 			pMsg.Result = 0x00;

  0024c	c6 45 d3 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 12118: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00250	0f b6 45 d1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00254	50		 push	 eax
  00255	8d 4d d0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00258	51		 push	 ecx
  00259	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0025c	52		 push	 edx
  0025d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12119: 			return;

  00265	e9 a5 00 00 00	 jmp	 $LN1@CGGuildDel
$LN11@CGGuildDel:

; 12120: 		}
; 12121: #endif
; 12122: 
; 12123: #ifdef UPDATE_USERPASSWORD_LENGTH_20090424
; 12124: 		memset(joomin, 0, MAX_JOOMINNUMBER_LENGTH+1);
; 12125: 		memcpy(joomin, lpMsg->JoominNumber, MAX_JOOMINNUMBER_LENGTH);
; 12126: #else	// UPDATE_USERPASSWORD_LENGTH_20090424
; 12127: 		memset(joomin, 0, 14);

  0026a	6a 0e		 push	 14			; 0000000eH
  0026c	6a 00		 push	 0
  0026e	8d 45 ec	 lea	 eax, DWORD PTR _joomin$[ebp]
  00271	50		 push	 eax
  00272	e8 00 00 00 00	 call	 _memset
  00277	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12128: 		memcpy(joomin, lpMsg->JoominNumber, 10);

  0027a	6a 0a		 push	 10			; 0000000aH
  0027c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0027f	83 c0 0d	 add	 eax, 13			; 0000000dH
  00282	50		 push	 eax
  00283	8d 4d ec	 lea	 ecx, DWORD PTR _joomin$[ebp]
  00286	51		 push	 ecx
  00287	e8 00 00 00 00	 call	 _memcpy
  0028c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12129: #endif	// UPDATE_USERPASSWORD_LENGTH_20090424
; 12130: 		//if( strcmp( joomin, gObj[aIndex].LastJoominNumber) == 0 )
; 12131: 
; 12132: #ifdef FOR_TAIWAN
; 12133: 		if( gObjTaiwanJoominCheck(aIndex, joomin) == TRUE )
; 12134: #else
; 12135: 		if( gObjJoominCheck(aIndex, joomin) == TRUE )

  0028f	8d 45 ec	 lea	 eax, DWORD PTR _joomin$[ebp]
  00292	50		 push	 eax
  00293	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00296	51		 push	 ecx
  00297	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  0029c	83 c4 08	 add	 esp, 8
  0029f	83 f8 01	 cmp	 eax, 1
  002a2	75 16		 jne	 SHORT $LN12@CGGuildDel

; 12136: #endif
; 12137: 		{
; 12138: #ifdef _NEW_EXDB_
; 12139: 			//   y .
; 12140: 			GDGuildMemberDel(aIndex, guildname, memberid);

  002a4	8d 45 e0	 lea	 eax, DWORD PTR _memberid$[ebp]
  002a7	50		 push	 eax
  002a8	8d 4d d4	 lea	 ecx, DWORD PTR _guildname$[ebp]
  002ab	51		 push	 ecx
  002ac	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002af	52		 push	 edx
  002b0	e8 00 00 00 00	 call	 ?GDGuildMemberDel@@YAXHPAD0@Z ; GDGuildMemberDel
  002b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12141: #endif
; 12142: 		}

  002b8	eb 1f		 jmp	 SHORT $LN13@CGGuildDel
$LN12@CGGuildDel:

; 12143: 		else GCServerMsgStringSend(lMsg.Get(1132), aIndex, 1);

  002ba	6a 01		 push	 1
  002bc	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002bf	50		 push	 eax
  002c0	68 6c 04 00 00	 push	 1132			; 0000046cH
  002c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002d0	50		 push	 eax
  002d1	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002d6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@CGGuildDel:

; 12144: 
; 12145: 		LogAddTD("[%s][%s] Guild Request - Leave : %s", gObj[aIndex].AccountID, gObj[aIndex].Name, guildname);

  002d9	8d 45 d4	 lea	 eax, DWORD PTR _guildname$[ebp]
  002dc	50		 push	 eax
  002dd	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ea	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  002ee	50		 push	 eax
  002ef	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002fc	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00300	50		 push	 eax
  00301	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5@
  00306	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0030c	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@CGGuildDel:

; 12146: 	}
; 12147: }

  0030f	5f		 pop	 edi
  00310	5e		 pop	 esi
  00311	5b		 pop	 ebx
  00312	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00315	33 cd		 xor	 ecx, ebp
  00317	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031c	8b e5		 mov	 esp, ebp
  0031e	5d		 pop	 ebp
  0031f	c3		 ret	 0
?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z ENDP	; CGGuildDelUser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildMasterManagerRun@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCGuildMasterManagerRun@@YAXH@Z PROC			; GCGuildMasterManagerRun, COMDAT

; 12203: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12204: 	PMSG_GUILDMASTERMANAGER_RUN	pMsg;
; 12205: 
; 12206: 	PHeadSetB((LPBYTE)&pMsg, 0x55, sizeof( pMsg ));

  00009	6a 03		 push	 3
  0000b	6a 55		 push	 85			; 00000055H
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12207: 
; 12208: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00019	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001d	50		 push	 eax
  0001e	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12209: }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?GCGuildMasterManagerRun@@YAXH@Z ENDP			; GCGuildMasterManagerRun
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z
_TEXT	SEGMENT
$T1 = -92						; size = 4
_pMsg$2 = -24						; size = 4
_len$ = -20						; size = 4
_GuildName$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z PROC ; CGGuildMasterInfoSave, COMDAT

; 12213: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 12214: 	char GuildName[MAX_GUILDNAMESTRING+1];
; 12215: 	int len;
; 12216: 
; 12217: 	GuildName[MAX_GUILDNAMESTRING] = '\0';

  00013	b8 01 00 00 00	 mov	 eax, 1
  00018	c1 e0 03	 shl	 eax, 3
  0001b	89 45 a4	 mov	 DWORD PTR $T1[ebp], eax
  0001e	83 7d a4 09	 cmp	 DWORD PTR $T1[ebp], 9
  00022	73 02		 jae	 SHORT $LN7@CGGuildMas
  00024	eb 05		 jmp	 SHORT $LN8@CGGuildMas
$LN7@CGGuildMas:
  00026	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN8@CGGuildMas:
  0002b	8b 4d a4	 mov	 ecx, DWORD PTR $T1[ebp]
  0002e	c6 44 0d f0 00	 mov	 BYTE PTR _GuildName$[ebp+ecx], 0

; 12218: 	memcpy(GuildName, lpMsg->GuildName, MAX_GUILDNAMESTRING);

  00033	6a 08		 push	 8
  00035	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00038	83 c0 03	 add	 eax, 3
  0003b	50		 push	 eax
  0003c	8d 4d f0	 lea	 ecx, DWORD PTR _GuildName$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _memcpy
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12219: 	
; 12220: 	len = strlen(GuildName);

  00048	8d 45 f0	 lea	 eax, DWORD PTR _GuildName$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _strlen
  00051	83 c4 04	 add	 esp, 4
  00054	89 45 ec	 mov	 DWORD PTR _len$[ebp], eax

; 12221: 
; 12222: 	if( len <= 2 || len > 8 )

  00057	83 7d ec 02	 cmp	 DWORD PTR _len$[ebp], 2
  0005b	7e 0a		 jle	 SHORT $LN3@CGGuildMas
  0005d	83 7d ec 08	 cmp	 DWORD PTR _len$[ebp], 8
  00061	0f 8e 99 00 00
	00		 jle	 $LN2@CGGuildMas
$LN3@CGGuildMas:

; 12223: 	{
; 12224: 		PMSG_GUILDCREATED_RESULT	pMsg;
; 12225: 		
; 12226: 		PHeadSetB((LPBYTE)&pMsg, 0x56, sizeof( pMsg ));

  00067	6a 04		 push	 4
  00069	6a 56		 push	 86			; 00000056H
  0006b	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$2[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12227: 
; 12228: 		pMsg.Result		= 0x02;

  00077	c6 45 eb 02	 mov	 BYTE PTR _pMsg$2[ebp+3], 2

; 12229: 
; 12230: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0007b	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$2[ebp+1]
  0007f	50		 push	 eax
  00080	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$2[ebp]
  00083	51		 push	 ecx
  00084	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00087	52		 push	 edx
  00088	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12231: 
; 12232: 		if( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_GUILDCREATE )

  00090	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009d	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000a4	80 e2 03	 and	 dl, 3
  000a7	0f b6 c2	 movzx	 eax, dl
  000aa	85 c0		 test	 eax, eax
  000ac	74 4d		 je	 SHORT $LN4@CGGuildMas
  000ae	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bb	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000c2	c0 ea 04	 shr	 dl, 4
  000c5	80 e2 0f	 and	 dl, 15			; 0000000fH
  000c8	0f b6 c2	 movzx	 eax, dl
  000cb	83 f8 05	 cmp	 eax, 5
  000ce	75 2b		 jne	 SHORT $LN4@CGGuildMas

; 12233: 		{
; 12234: 			gObj[aIndex].m_IfState.use    = 0;

  000d0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000dd	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000e4	80 e2 fc	 and	 dl, 252			; 000000fcH
  000e7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f4	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN4@CGGuildMas:

; 12235: 		}
; 12236: 		return;

  000fb	e9 94 00 00 00	 jmp	 $LN6@CGGuildMas
$LN2@CGGuildMas:

; 12237: 	}
; 12238: #ifdef _NEW_EXDB_
; 12239: 	//  
; 12240: #ifdef ADD_NEW_GUILD_02_20040922
; 12241: 	GDGuildCreateSend(aIndex, GuildName, gObj[aIndex].Name, lpMsg->Mark, lpMsg->btGuildType);
; 12242: #else
; 12243: 	GDGuildCreateSend(aIndex, GuildName, gObj[aIndex].Name, lpMsg->Mark);

  00100	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00103	83 c0 0b	 add	 eax, 11			; 0000000bH
  00106	50		 push	 eax
  00107	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0010e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00114	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00118	50		 push	 eax
  00119	8d 4d f0	 lea	 ecx, DWORD PTR _GuildName$[ebp]
  0011c	51		 push	 ecx
  0011d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 ?GDGuildCreateSend@@YAXHPAD0PAE@Z ; GDGuildCreateSend
  00126	83 c4 10	 add	 esp, 16			; 00000010H

; 12244: #endif
; 12245: #endif
; 12246: 	
; 12247: 	if( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_GUILDCREATE )

  00129	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00136	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0013d	80 e2 03	 and	 dl, 3
  00140	0f b6 c2	 movzx	 eax, dl
  00143	85 c0		 test	 eax, eax
  00145	74 4d		 je	 SHORT $LN6@CGGuildMas
  00147	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00154	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0015b	c0 ea 04	 shr	 dl, 4
  0015e	80 e2 0f	 and	 dl, 15			; 0000000fH
  00161	0f b6 c2	 movzx	 eax, dl
  00164	83 f8 05	 cmp	 eax, 5
  00167	75 2b		 jne	 SHORT $LN6@CGGuildMas

; 12248: 		gObj[aIndex].m_IfState.use    = 0;

  00169	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00176	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0017d	80 e2 fc	 and	 dl, 252			; 000000fcH
  00180	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00187	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018d	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN6@CGGuildMas:

; 12249: }

  00194	5f		 pop	 edi
  00195	5e		 pop	 esi
  00196	5b		 pop	 ebx
  00197	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019a	33 cd		 xor	 ecx, ebp
  0019c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c3		 ret	 0
?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ENDP ; CGGuildMasterInfoSave
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGGuildListAll@@YAXH@Z
_TEXT	SEGMENT
_guildmaster$ = -1548					; size = 4
_n$ = -1544						; size = 4
_number$ = -1540					; size = 4
_lOfs$ = -1536						; size = 4
_sendbuf$ = -1532					; size = 1500
_pList$ = -32						; size = 12
_pCount$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_pnumber$ = 8						; size = 4
?CGGuildListAll@@YAXH@Z PROC				; CGGuildListAll, COMDAT

; 11912: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 07 00
	00		 sub	 esp, 1804		; 0000070cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 11913: 
; 11914: #ifdef ADD_NEW_UNION_01_20041006
; 11915: 	if( gObj[pnumber].lpGuild == NULL )
; 11916: 		return;
; 11917: #endif
; 11918: 
; 11919: 	PMSG_GUILDLISTCOUNT		pCount;
; 11920: 	PMSG_GUILDLIST			pList;
; 11921: 	
; 11922: #ifdef DARKLORD_WORK
; 11923: 	char sendbuf[1500];
; 11924: #else
; 11925: 	char sendbuf[512];
; 11926: #endif
; 11927: 
; 11928: 	int  lOfs=0;

  00016	c7 85 00 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 11929: 	int  number;
; 11930: 	int  n;
; 11931: 	BOOL guildmaster=FALSE;

  00020	c7 85 f4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _guildmaster$[ebp], 0

; 11932: 		
; 11933: 	PHeadSetW((LPBYTE)&pCount, 0x52, 0);

  0002a	6a 00		 push	 0
  0002c	6a 52		 push	 82			; 00000052H
  0002e	8d 45 ec	 lea	 eax, DWORD PTR _pCount$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11934: 
; 11935: 	pCount.Result       = 0x00;

  0003a	c6 45 f0 00	 mov	 BYTE PTR _pCount$[ebp+4], 0

; 11936: 	pCount.Count		= 0;

  0003e	c6 45 f1 00	 mov	 BYTE PTR _pCount$[ebp+5], 0

; 11937: 	
; 11938: 	lOfs += sizeof(pCount);

  00042	8b 85 00 fa ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00048	83 c0 10	 add	 eax, 16			; 00000010H
  0004b	89 85 00 fa ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 11939: 
; 11940: 	pCount.h.sizeH = HIBYTE(lOfs);

  00051	8b 85 00 fa ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00057	c1 e8 08	 shr	 eax, 8
  0005a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005f	88 45 ed	 mov	 BYTE PTR _pCount$[ebp+1], al

; 11941: 	pCount.h.sizeL = LOBYTE(lOfs);

  00062	8b 85 00 fa ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00068	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0006d	88 45 ee	 mov	 BYTE PTR _pCount$[ebp+2], al

; 11942: 	if( gObj[pnumber].GuildNumber < 1 ) 

  00070	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _pnumber$[ebp], 7072
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007d	83 bc 01 90 02
	00 00 01	 cmp	 DWORD PTR [ecx+eax+656], 1
  00085	7d 1c		 jge	 SHORT $LN5@CGGuildLis

; 11943: 	{
; 11944: 		DataSend(pnumber, (LPBYTE)&pCount, lOfs);

  00087	8b 85 00 fa ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0008d	50		 push	 eax
  0008e	8d 4d ec	 lea	 ecx, DWORD PTR _pCount$[ebp]
  00091	51		 push	 ecx
  00092	8b 55 08	 mov	 edx, DWORD PTR _pnumber$[ebp]
  00095	52		 push	 edx
  00096	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11945: 		return;

  0009e	e9 12 02 00 00	 jmp	 $LN1@CGGuildLis
$LN5@CGGuildLis:

; 11946: 	}
; 11947: 
; 11948: 	pCount.Count		= gObj[pnumber].lpGuild->Count;

  000a3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _pnumber$[ebp], 7072
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b0	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  000b7	8a 42 2d	 mov	 al, BYTE PTR [edx+45]
  000ba	88 45 f1	 mov	 BYTE PTR _pCount$[ebp+5], al

; 11949: 	pCount.TotalScore   = gObj[pnumber].lpGuild->TotalScore;

  000bd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _pnumber$[ebp], 7072
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ca	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  000d1	8b 82 98 05 00
	00		 mov	 eax, DWORD PTR [edx+1432]
  000d7	89 45 f4	 mov	 DWORD PTR _pCount$[ebp+8], eax

; 11950: 	pCount.Score        = gObj[pnumber].lpGuild->PlayScore;

  000da	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _pnumber$[ebp], 7072
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e7	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  000ee	8a 82 95 05 00
	00		 mov	 al, BYTE PTR [edx+1429]
  000f4	88 45 f8	 mov	 BYTE PTR _pCount$[ebp+12], al

; 11951: 
; 11952: #ifdef ADD_NEW_UNION_01_20041006
; 11953: 	ZeroMemory( pCount.szRivalGuild, MAX_GUILDNAMESTRING + 1 );
; 11954: 
; 11955: 	if( gObj[pnumber].lpGuild->iGuildRival != G_RELATIONSHIP_NONE )
; 11956: 	{	
; 11957: 		//    .
; 11958: 		memcpy( pCount.szRivalGuild, gObj[pnumber].lpGuild->szGuildRivalName, MAX_GUILDNAMESTRING );
; 11959: 	}
; 11960: #endif
; 11961: 	
; 11962: 	pCount.Result = 0x01;

  000f7	c6 45 f0 01	 mov	 BYTE PTR _pCount$[ebp+4], 1

; 11963: 
; 11964: 	//if( strcmp(gObj[pnumber].Name, gObj[pnumber].lpGuild->Names[0]) == 0)
; 11965: 	{
; 11966: 		guildmaster = TRUE;

  000fb	c7 85 f4 f9 ff
	ff 01 00 00 00	 mov	 DWORD PTR _guildmaster$[ebp], 1

; 11967: 	}
; 11968: 	if( pCount.Count == 0 ) return;

  00105	0f b6 45 f1	 movzx	 eax, BYTE PTR _pCount$[ebp+5]
  00109	85 c0		 test	 eax, eax
  0010b	75 05		 jne	 SHORT $LN6@CGGuildLis
  0010d	e9 a3 01 00 00	 jmp	 $LN1@CGGuildLis
$LN6@CGGuildLis:

; 11969: 	
; 11970: 	pCount.Count = 0;

  00112	c6 45 f1 00	 mov	 BYTE PTR _pCount$[ebp+5], 0

; 11971: 	for( n=0; n<MAX_GUILD; n++)

  00116	c7 85 f8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00120	eb 0f		 jmp	 SHORT $LN4@CGGuildLis
$LN2@CGGuildLis:
  00122	8b 85 f8 f9 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00128	83 c0 01	 add	 eax, 1
  0012b	89 85 f8 f9 ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LN4@CGGuildLis:
  00131	83 bd f8 f9 ff
	ff 50		 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  00138	0f 8d 29 01 00
	00		 jge	 $LN3@CGGuildLis

; 11972: 	{			
; 11973: 		number = gObj[pnumber].lpGuild->Use[n];

  0013e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _pnumber$[ebp], 7072
  00145	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014b	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  00152	8b 85 f8 f9 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00158	0f b6 8c 02 40
	04 00 00	 movzx	 ecx, BYTE PTR [edx+eax+1088]
  00160	89 8d fc f9 ff
	ff		 mov	 DWORD PTR _number$[ebp], ecx

; 11974: 		if( number > 0 )

  00166	83 bd fc f9 ff
	ff 00		 cmp	 DWORD PTR _number$[ebp], 0
  0016d	0f 8e ef 00 00
	00		 jle	 $LN7@CGGuildLis

; 11975: 		{			
; 11976: 			memset(&pList, 0, sizeof(pList));

  00173	6a 0c		 push	 12			; 0000000cH
  00175	6a 00		 push	 0
  00177	8d 45 e0	 lea	 eax, DWORD PTR _pList$[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 _memset
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11977: 			memcpy(pList.Name,  gObj[pnumber].lpGuild->Names[n], MAX_IDSTRING);

  00183	6a 0a		 push	 10			; 0000000aH
  00185	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _pnumber$[ebp], 7072
  0018c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00192	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  00199	6b 85 f8 f9 ff
	ff 0b		 imul	 eax, DWORD PTR _n$[ebp], 11
  001a0	8d 4c 02 2f	 lea	 ecx, DWORD PTR [edx+eax+47]
  001a4	51		 push	 ecx
  001a5	8d 55 e0	 lea	 edx, DWORD PTR _pList$[ebp]
  001a8	52		 push	 edx
  001a9	e8 00 00 00 00	 call	 _memcpy
  001ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11978: 			pList.Number    = gObj[pnumber].lpGuild->pServer[n];

  001b1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _pnumber$[ebp], 7072
  001b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001be	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  001c5	8b 85 f8 f9 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  001cb	8a 8c 02 90 04
	00 00		 mov	 cl, BYTE PTR [edx+eax+1168]
  001d2	88 4d ea	 mov	 BYTE PTR _pList$[ebp+10], cl

; 11979: 			pList.ConnectAServer = gObj[pnumber].lpGuild->pServer[n]&0x7F;

  001d5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _pnumber$[ebp], 7072
  001dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e2	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  001e9	8b 85 f8 f9 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  001ef	0f be 8c 02 90
	04 00 00	 movsx	 ecx, BYTE PTR [edx+eax+1168]
  001f7	83 e1 7f	 and	 ecx, 127		; 0000007fH
  001fa	88 4d eb	 mov	 BYTE PTR _pList$[ebp+11], cl

; 11980: 			if( gObj[pnumber].lpGuild->pServer[n] >= 0 )

  001fd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _pnumber$[ebp], 7072
  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0020a	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  00211	8b 85 f8 f9 ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00217	0f be 8c 02 90
	04 00 00	 movsx	 ecx, BYTE PTR [edx+eax+1168]
  0021f	85 c9		 test	 ecx, ecx
  00221	7c 0c		 jl	 SHORT $LN8@CGGuildLis

; 11981: 			{
; 11982: 				pList.ConnectAServer |= 0x80;

  00223	0f b6 45 eb	 movzx	 eax, BYTE PTR _pList$[ebp+11]
  00227	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0022c	88 45 eb	 mov	 BYTE PTR _pList$[ebp+11], al
$LN8@CGGuildLis:

; 11983: 			}
; 11984: 			
; 11985: #ifdef ADD_NEW_GUILD_01_20040913
; 11986: 			pList.btGuildStatus = (BYTE)gObj[pnumber].lpGuild->GuildStatus[n];
; 11987: #endif
; 11988: 			memcpy(sendbuf+lOfs, (char*)&pList, sizeof(PMSG_GUILDLIST));

  0022f	6a 0c		 push	 12			; 0000000cH
  00231	8d 45 e0	 lea	 eax, DWORD PTR _pList$[ebp]
  00234	50		 push	 eax
  00235	8b 8d 00 fa ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  0023b	8d 94 0d 04 fa
	ff ff		 lea	 edx, DWORD PTR _sendbuf$[ebp+ecx]
  00242	52		 push	 edx
  00243	e8 00 00 00 00	 call	 _memcpy
  00248	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11989: 			lOfs += sizeof(PMSG_GUILDLIST);

  0024b	8b 85 00 fa ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00251	83 c0 0c	 add	 eax, 12			; 0000000cH
  00254	89 85 00 fa ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 11990: 			pCount.Count++;

  0025a	8a 45 f1	 mov	 al, BYTE PTR _pCount$[ebp+5]
  0025d	04 01		 add	 al, 1
  0025f	88 45 f1	 mov	 BYTE PTR _pCount$[ebp+5], al
$LN7@CGGuildLis:

; 11991: 		}
; 11992: 	}

  00262	e9 bb fe ff ff	 jmp	 $LN2@CGGuildLis
$LN3@CGGuildLis:

; 11993: 
; 11994: 	pCount.h.sizeH = HIBYTE(lOfs);

  00267	8b 85 00 fa ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0026d	c1 e8 08	 shr	 eax, 8
  00270	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00275	88 45 ed	 mov	 BYTE PTR _pCount$[ebp+1], al

; 11995: 	pCount.h.sizeL = LOBYTE(lOfs);

  00278	8b 85 00 fa ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0027e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00283	88 45 ee	 mov	 BYTE PTR _pCount$[ebp+2], al

; 11996: 	memcpy(sendbuf, (char*)&pCount, sizeof(pCount));

  00286	6a 10		 push	 16			; 00000010H
  00288	8d 45 ec	 lea	 eax, DWORD PTR _pCount$[ebp]
  0028b	50		 push	 eax
  0028c	8d 8d 04 fa ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  00292	51		 push	 ecx
  00293	e8 00 00 00 00	 call	 _memcpy
  00298	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11997: 	
; 11998: 	DataSend(pnumber, (LPBYTE)sendbuf, lOfs);

  0029b	8b 85 00 fa ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  002a1	50		 push	 eax
  002a2	8d 8d 04 fa ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  002a8	51		 push	 ecx
  002a9	8b 55 08	 mov	 edx, DWORD PTR _pnumber$[ebp]
  002ac	52		 push	 edx
  002ad	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGGuildLis:

; 11999: }

  002b5	5f		 pop	 edi
  002b6	5e		 pop	 esi
  002b7	5b		 pop	 ebx
  002b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bb	33 cd		 xor	 ecx, ebp
  002bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c2	8b e5		 mov	 esp, ebp
  002c4	5d		 pop	 ebp
  002c5	c3		 ret	 0
?CGGuildListAll@@YAXH@Z ENDP				; CGGuildListAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z PROC ; CGGuildMasterAnswerRecv, COMDAT

; 12180: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12181: 	if( lpMsg->Result == 0x01 )	//  !

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	0f 85 95 00 00
	00		 jne	 $LN2@CGGuildMas

; 12182: 	{
; 12183: 		if( gObjGuildMasterCapacityTest(&gObj[aIndex]) == FALSE )	//     .

  00019	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00020	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?gObjGuildMasterCapacityTest@@YAHPAVOBJECTSTRUCT@@@Z ; gObjGuildMasterCapacityTest
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	75 6d		 jne	 SHORT $LN4@CGGuildMas

; 12184: 		{
; 12185: 			if( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_GUILDCREATE )

  00033	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00040	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00047	80 e2 03	 and	 dl, 3
  0004a	0f b6 c2	 movzx	 eax, dl
  0004d	85 c0		 test	 eax, eax
  0004f	74 4d		 je	 SHORT $LN5@CGGuildMas
  00051	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005e	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00065	c0 ea 04	 shr	 dl, 4
  00068	80 e2 0f	 and	 dl, 15			; 0000000fH
  0006b	0f b6 c2	 movzx	 eax, dl
  0006e	83 f8 05	 cmp	 eax, 5
  00071	75 2b		 jne	 SHORT $LN5@CGGuildMas

; 12186: 			{
; 12187: 				gObj[aIndex].m_IfState.use = 0;

  00073	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00080	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00087	80 e2 fc	 and	 dl, 252			; 000000fcH
  0008a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00097	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN5@CGGuildMas:

; 12188: 			}
; 12189: 			return;

  0009e	eb 79		 jmp	 SHORT $LN1@CGGuildMas
$LN4@CGGuildMas:

; 12190: 		}
; 12191: 		GCGuildMasterManagerRun(aIndex);

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?GCGuildMasterManagerRun@@YAXH@Z ; GCGuildMasterManagerRun
  000a9	83 c4 04	 add	 esp, 4

; 12192: 	}

  000ac	eb 6b		 jmp	 SHORT $LN1@CGGuildMas
$LN2@CGGuildMas:

; 12193: 	else
; 12194: 	{
; 12195: 		if( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_GUILDCREATE )

  000ae	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bb	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000c2	80 e2 03	 and	 dl, 3
  000c5	0f b6 c2	 movzx	 eax, dl
  000c8	85 c0		 test	 eax, eax
  000ca	74 4d		 je	 SHORT $LN1@CGGuildMas
  000cc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d9	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000e0	c0 ea 04	 shr	 dl, 4
  000e3	80 e2 0f	 and	 dl, 15			; 0000000fH
  000e6	0f b6 c2	 movzx	 eax, dl
  000e9	83 f8 05	 cmp	 eax, 5
  000ec	75 2b		 jne	 SHORT $LN1@CGGuildMas

; 12196: 			gObj[aIndex].m_IfState.use    = 0;

  000ee	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fb	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00102	80 e2 fc	 and	 dl, 252			; 000000fcH
  00105	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0010c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00112	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN1@CGGuildMas:

; 12197: 	}
; 12198: }

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ENDP ; CGGuildMasterAnswerRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z
_TEXT	SEGMENT
_pnumber$ = -12						; size = 4
_result$ = -5						; size = 1
_number$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z PROC ; CGGuildRequestResultRecv, COMDAT

; 11847: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 11848: 	int		number;	
; 11849: 	BYTE	result=0x00;

  00009	c6 45 fb 00	 mov	 BYTE PTR _result$[ebp], 0

; 11850: 	int		pnumber=-1;

  0000d	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _pnumber$[ebp], -1

; 11851: 
; 11852: 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;

  00014	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00027	83 c4 04	 add	 esp, 4
  0002a	85 c0		 test	 eax, eax
  0002c	75 05		 jne	 SHORT $LN2@CGGuildReq
  0002e	e9 50 02 00 00	 jmp	 $LN1@CGGuildReq
$LN2@CGGuildReq:

; 11853: 
; 11854: 	number = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  00033	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00036	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0003a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00040	0f b6 d1	 movzx	 edx, cl
  00043	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00046	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0004a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00050	0f b6 c1	 movzx	 eax, cl
  00053	c1 e0 08	 shl	 eax, 8
  00056	0b d0		 or	 edx, eax
  00058	0f b7 ca	 movzx	 ecx, dx
  0005b	89 4d fc	 mov	 DWORD PTR _number$[ebp], ecx

; 11855: 	if( number < 0 || number > MAX_OBJECT-1 ) return; 

  0005e	83 7d fc 00	 cmp	 DWORD PTR _number$[ebp], 0
  00062	7c 09		 jl	 SHORT $LN4@CGGuildReq
  00064	81 7d fc e7 1c
	00 00		 cmp	 DWORD PTR _number$[ebp], 7399 ; 00001ce7H
  0006b	7e 05		 jle	 SHORT $LN3@CGGuildReq
$LN4@CGGuildReq:
  0006d	e9 11 02 00 00	 jmp	 $LN1@CGGuildReq
$LN3@CGGuildReq:

; 11856: 
; 11857: 	// OK ..
; 11858: 	//   .
; 11859: 	if( gObjIsConnected(&gObj[number]) == FALSE ) 

  00072	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00079	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsConnected
  00085	83 c4 04	 add	 esp, 4
  00088	85 c0		 test	 eax, eax
  0008a	75 12		 jne	 SHORT $LN5@CGGuildReq

; 11860: 	{		
; 11861: 		GCResultSend(aIndex, 0x51, 0x02);	//   .

  0008c	6a 02		 push	 2
  0008e	6a 51		 push	 81			; 00000051H
  00090	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11862: 	}

  0009c	eb 04		 jmp	 SHORT $LN6@CGGuildReq
$LN5@CGGuildReq:

; 11863: 	else result = 0x01;

  0009e	c6 45 fb 01	 mov	 BYTE PTR _result$[ebp], 1
$LN6@CGGuildReq:

; 11864: 
; 11865: #ifdef MODIFY_REQUESTNPC_HACK
; 11866: 	if (gObj[number].Type != OBJTYPE_CHARACTER)

  000a2	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000b4	83 fa 01	 cmp	 edx, 1
  000b7	74 7f		 je	 SHORT $LN7@CGGuildReq

; 11867: 	{
; 11868: 		LogAddC(LOGC_RED,"[HACKTOOL] : NPC-GuildRequest(result) npc:%d ip:%s account:%s name:%s State:%d", 

  000b9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c6	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  000ca	52		 push	 edx
  000cb	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d8	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000dc	52		 push	 edx
  000dd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ea	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000ee	52		 push	 edx
  000ef	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fc	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  00100	52		 push	 edx
  00101	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010e	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00116	52		 push	 edx
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@POEHMBEF@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?$CIr@
  0011c	6a 02		 push	 2
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00124	83 c4 1c	 add	 esp, 28			; 0000001cH

; 11869: 			gObj[number].Class, 
; 11870: 			gObj[aIndex].Ip_addr,
; 11871: 			gObj[aIndex].AccountID, 
; 11872: 			gObj[aIndex].Name, 
; 11873: 			gObj[aIndex].Connected);
; 11874: 		
; 11875: 		CloseClient(aIndex);

  00127	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00130	83 c4 04	 add	 esp, 4

; 11876: 		return;

  00133	e9 4b 01 00 00	 jmp	 $LN1@CGGuildReq
$LN7@CGGuildReq:

; 11877: 	}
; 11878: #endif // MODIFY_REQUESTNPC_HACK
; 11879: 	
; 11880: 	// CANCEL  
; 11881: 	if( lpMsg->Result == 0x00 ) 

  00138	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0013b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0013f	85 c9		 test	 ecx, ecx
  00141	75 14		 jne	 SHORT $LN8@CGGuildReq

; 11882: 	{		
; 11883: 		result = 0x00;

  00143	c6 45 fb 00	 mov	 BYTE PTR _result$[ebp], 0

; 11884: 		GCResultSend(number, 0x51, 0x00);

  00147	6a 00		 push	 0
  00149	6a 51		 push	 81			; 00000051H
  0014b	8b 45 fc	 mov	 eax, DWORD PTR _number$[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CGGuildReq:

; 11885: 	}
; 11886: 
; 11887: #ifdef _NEW_EXDB_
; 11888: 	if( result == 0x01 )

  00157	0f b6 45 fb	 movzx	 eax, BYTE PTR _result$[ebp]
  0015b	83 f8 01	 cmp	 eax, 1
  0015e	75 4d		 jne	 SHORT $LN9@CGGuildReq

; 11889: 	{
; 11890: 		if( gObj[aIndex].GuildNumber > 0 )

  00160	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00167	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016d	83 bc 01 90 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+656], 0
  00175	7e 36		 jle	 SHORT $LN9@CGGuildReq

; 11891: 		{
; 11892: 			GDGuildMemberAdd(number, gObj[aIndex].lpGuild->Name, gObj[number].Name);

  00177	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00184	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00188	52		 push	 edx
  00189	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00196	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  0019d	83 c2 04	 add	 edx, 4
  001a0	52		 push	 edx
  001a1	8b 45 fc	 mov	 eax, DWORD PTR _number$[ebp]
  001a4	50		 push	 eax
  001a5	e8 00 00 00 00	 call	 ?GDGuildMemberAdd@@YAXHPAD0@Z ; GDGuildMemberAdd
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGGuildReq:

; 11893: 		}
; 11894: 	}
; 11895: #endif
; 11896: 	
; 11897: 	if(gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_GUILD )

  001ad	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ba	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  001c1	80 e2 03	 and	 dl, 3
  001c4	0f b6 c2	 movzx	 eax, dl
  001c7	85 c0		 test	 eax, eax
  001c9	74 4d		 je	 SHORT $LN11@CGGuildReq
  001cb	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d8	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  001df	c0 ea 04	 shr	 dl, 4
  001e2	80 e2 0f	 and	 dl, 15			; 0000000fH
  001e5	0f b6 c2	 movzx	 eax, dl
  001e8	83 f8 04	 cmp	 eax, 4
  001eb	75 2b		 jne	 SHORT $LN11@CGGuildReq

; 11898: 	{
; 11899: 		gObj[aIndex].m_IfState.use      = 0;

  001ed	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001fa	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00201	80 e2 fc	 and	 dl, 252			; 000000fcH
  00204	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0020b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00211	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN11@CGGuildReq:

; 11900: 	}
; 11901: 	
; 11902: 	if(gObj[number].m_IfState.use && gObj[number].m_IfState.type == I_GUILD )

  00218	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0021f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00225	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0022c	80 e2 03	 and	 dl, 3
  0022f	0f b6 c2	 movzx	 eax, dl
  00232	85 c0		 test	 eax, eax
  00234	74 4d		 je	 SHORT $LN1@CGGuildReq
  00236	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00243	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0024a	c0 ea 04	 shr	 dl, 4
  0024d	80 e2 0f	 and	 dl, 15			; 0000000fH
  00250	0f b6 c2	 movzx	 eax, dl
  00253	83 f8 04	 cmp	 eax, 4
  00256	75 2b		 jne	 SHORT $LN1@CGGuildReq

; 11903: 	{
; 11904: 		gObj[number].m_IfState.use		= 0;

  00258	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0025f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00265	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0026c	80 e2 fc	 and	 dl, 252			; 000000fcH
  0026f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00276	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027c	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN1@CGGuildReq:

; 11905: 	}
; 11906: }

  00283	5f		 pop	 edi
  00284	5e		 pop	 esi
  00285	5b		 pop	 ebx
  00286	8b e5		 mov	 esp, ebp
  00288	5d		 pop	 ebp
  00289	c3		 ret	 0
?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ENDP ; CGGuildRequestResultRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z
_TEXT	SEGMENT
_MaxGuildMember$1 = -16					; size = 4
_number$ = -12						; size = 4
_pMsg$ = -8						; size = 5
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z PROC	; CGGuildRequestRecv, COMDAT

; 11663: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 11664: 	PMSG_GUILDQUESTSEND pMsg;
; 11665: 	int number;
; 11666: 
; 11667: 	number = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00010	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00016	0f b6 d1	 movzx	 edx, cl
  00019	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00020	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00026	0f b6 c1	 movzx	 eax, cl
  00029	c1 e0 08	 shl	 eax, 8
  0002c	0b d0		 or	 edx, eax
  0002e	0f b7 ca	 movzx	 ecx, dx
  00031	89 4d f4	 mov	 DWORD PTR _number$[ebp], ecx

; 11668: 	if( number < 0 || number > MAX_OBJECT-1 ) return; 

  00034	83 7d f4 00	 cmp	 DWORD PTR _number$[ebp], 0
  00038	7c 09		 jl	 SHORT $LN3@CGGuildReq
  0003a	81 7d f4 e7 1c
	00 00		 cmp	 DWORD PTR _number$[ebp], 7399 ; 00001ce7H
  00041	7e 05		 jle	 SHORT $LN2@CGGuildReq
$LN3@CGGuildReq:
  00043	e9 44 05 00 00	 jmp	 $LN1@CGGuildReq
$LN2@CGGuildReq:

; 11669: 
; 11670: 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;

  00048	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0004f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  0005b	83 c4 04	 add	 esp, 4
  0005e	85 c0		 test	 eax, eax
  00060	75 05		 jne	 SHORT $LN4@CGGuildReq
  00062	e9 25 05 00 00	 jmp	 $LN1@CGGuildReq
$LN4@CGGuildReq:

; 11671: 
; 11672: 
; 11673: #ifdef EXDB_APPLY_CASTLEUPDATE_01_20050111
; 11674: #ifdef GAMESERVER_TO_CASTLESIEGESERVER
; 11675: 	//       
; 11676: 	if (g_CastleSiegeSync.GetCastleState() == CASTLESIEGE_SYNC_STATE_STARTSIEGE) 
; 11677: 	{
; 11678: 		MsgOutput( aIndex, lMsg.Get(1730) ); // "    ."
; 11679: 		return;
; 11680: 	}
; 11681: #endif
; 11682: #endif
; 11683: 
; 11684: #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_6_200708013	//     
; 11685: 	if(CHECK_ILLUSION_TEMPLE(gObj[aIndex].MapNumber))
; 11686: 	{
; 11687: 		MsgOutput( aIndex, lMsg.Get(3398) ); // "  ."
; 11688: 		return;
; 11689: 	}
; 11690: #endif
; 11691: 
; 11692: #ifdef ADD_NEWPVP_PKFIELD
; 11693: 	if ( g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[number]) )
; 11694: 	{
; 11695: 		// "     ."
; 11696: 		GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);
; 11697: 		return;
; 11698: 	}
; 11699: 	
; 11700: 	if ( g_NewPVP.IsObserver(gObj[aIndex]) )
; 11701: 	{
; 11702: 		// "     ."
; 11703: 		GCServerMsgStringSend(lMsg.Get(3427), aIndex, 1);
; 11704: 		return;
; 11705: 	}
; 11706: #endif // ADD_NEWPVP_PKFIELD
; 11707: 
; 11708: 	//   .
; 11709: 	if( gObjIsConnected(&gObj[number]) == FALSE ) 

  00067	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0006e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsConnected
  0007a	83 c4 04	 add	 esp, 4
  0007d	85 c0		 test	 eax, eax
  0007f	75 15		 jne	 SHORT $LN5@CGGuildReq

; 11710: 	{
; 11711: 		GCResultSend(aIndex, 0x51, 0x03);

  00081	6a 03		 push	 3
  00083	6a 51		 push	 81			; 00000051H
  00085	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11712: 		return;

  00091	e9 f6 04 00 00	 jmp	 $LN1@CGGuildReq
$LN5@CGGuildReq:

; 11713: 	}
; 11714: 
; 11715: 	//     
; 11716: 	if( gObj[aIndex].m_IfState.use > 0 ) 

  00096	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a3	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000aa	80 e2 03	 and	 dl, 3
  000ad	0f b6 c2	 movzx	 eax, dl
  000b0	85 c0		 test	 eax, eax
  000b2	7e 15		 jle	 SHORT $LN6@CGGuildReq

; 11717: 	{
; 11718: 		GCResultSend(aIndex, 0x51, 0x06);

  000b4	6a 06		 push	 6
  000b6	6a 51		 push	 81			; 00000051H
  000b8	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11719: 		return;

  000c4	e9 c3 04 00 00	 jmp	 $LN1@CGGuildReq
$LN6@CGGuildReq:

; 11720: 	}
; 11721: 		
; 11722: 	//     
; 11723: 	if( gObj[number].m_IfState.use > 0 ) 

  000c9	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d6	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000dd	80 e2 03	 and	 dl, 3
  000e0	0f b6 c2	 movzx	 eax, dl
  000e3	85 c0		 test	 eax, eax
  000e5	7e 15		 jle	 SHORT $LN7@CGGuildReq

; 11724: 	{
; 11725: 		GCResultSend(aIndex, 0x51, 0x06);

  000e7	6a 06		 push	 6
  000e9	6a 51		 push	 81			; 00000051H
  000eb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11726: 		return;

  000f7	e9 90 04 00 00	 jmp	 $LN1@CGGuildReq
$LN7@CGGuildReq:

; 11727: 	}
; 11728: 	
; 11729: 
; 11730: 	if( gObj[aIndex].Level < 6 )

  000fc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00109	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00111	83 fa 06	 cmp	 edx, 6
  00114	7d 15		 jge	 SHORT $LN8@CGGuildReq

; 11731: 	{
; 11732: 		GCResultSend(aIndex, 0x51, 0x07);

  00116	6a 07		 push	 7
  00118	6a 51		 push	 81			; 00000051H
  0011a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11733: 		return;		

  00126	e9 61 04 00 00	 jmp	 $LN1@CGGuildReq
$LN8@CGGuildReq:

; 11734: 	}
; 11735: 
; 11736: 	
; 11737: 	//     ..
; 11738: 	if( gObj[aIndex].GuildNumber > 0 ) 

  0012b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00138	83 bc 01 90 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+656], 0
  00140	7e 15		 jle	 SHORT $LN9@CGGuildReq

; 11739: 	{
; 11740: 		GCResultSend(aIndex, 0x51, 0x05);

  00142	6a 05		 push	 5
  00144	6a 51		 push	 81			; 00000051H
  00146	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11741: 		return;		

  00152	e9 35 04 00 00	 jmp	 $LN1@CGGuildReq
$LN9@CGGuildReq:

; 11742: 	}
; 11743: 
; 11744: 	if( (gObj[number].m_Option&OPTION_TRADE) != OPTION_TRADE )

  00157	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00164	8b 94 01 c0 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3264]
  0016b	83 e2 01	 and	 edx, 1
  0016e	75 15		 jne	 SHORT $LN10@CGGuildReq

; 11745: 	{
; 11746: 		GCResultSend(aIndex, 0x51, 0x00);

  00170	6a 00		 push	 0
  00172	6a 51		 push	 81			; 00000051H
  00174	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11747: 		return;

  00180	e9 07 04 00 00	 jmp	 $LN1@CGGuildReq
$LN10@CGGuildReq:

; 11748: 	}
; 11749: 
; 11750: #ifdef MODIFY_REQUESTNPC_HACK
; 11751: 	if (gObj[number].Type != OBJTYPE_CHARACTER)

  00185	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0018c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00192	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00197	83 fa 01	 cmp	 edx, 1
  0019a	74 7f		 je	 SHORT $LN11@CGGuildReq

; 11752: 	{
; 11753: 		LogAddC(LOGC_RED,"[HACKTOOL] : NPC-GuildRequest npc:%d ip:%s account:%s name:%s State:%d", 

  0019c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a9	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  001ad	52		 push	 edx
  001ae	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bb	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001bf	52		 push	 edx
  001c0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cd	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001d1	52		 push	 edx
  001d2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001df	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  001e3	52		 push	 edx
  001e4	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  001eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f1	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  001f9	52		 push	 edx
  001fa	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@LLMHNLJP@?$FLHACKTOOL?$FN?5?3?5NPC?9GuildRequest?5n@
  001ff	6a 02		 push	 2
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00207	83 c4 1c	 add	 esp, 28			; 0000001cH

; 11754: 			gObj[number].Class, 
; 11755: 			gObj[aIndex].Ip_addr,
; 11756: 			gObj[aIndex].AccountID, 
; 11757: 			gObj[aIndex].Name, 
; 11758: 			gObj[aIndex].Connected);
; 11759: 		
; 11760: 		CloseClient(aIndex);

  0020a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00213	83 c4 04	 add	 esp, 4

; 11761: 		return;

  00216	e9 71 03 00 00	 jmp	 $LN1@CGGuildReq
$LN11@CGGuildReq:

; 11762: 	}
; 11763: #endif // MODIFY_REQUESTNPC_HACK
; 11764: 
; 11765: 	//   ..   ..
; 11766: 	if( gObj[number].GuildNumber > 0 ) {

  0021b	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00222	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00228	83 bc 01 90 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+656], 0
  00230	0f 8e 45 01 00
	00		 jle	 $LN12@CGGuildReq

; 11767: 		if(strcmp(gObj[number].lpGuild->Names[0], gObj[number].Name)!=0)

  00236	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00243	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00247	52		 push	 edx
  00248	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0024f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00255	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  0025c	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00261	6b c8 00	 imul	 ecx, eax, 0
  00264	8d 54 0a 2f	 lea	 edx, DWORD PTR [edx+ecx+47]
  00268	52		 push	 edx
  00269	e8 00 00 00 00	 call	 _strcmp
  0026e	83 c4 08	 add	 esp, 8
  00271	85 c0		 test	 eax, eax
  00273	74 15		 je	 SHORT $LN14@CGGuildReq

; 11768: 		{
; 11769: 			GCResultSend(aIndex, 0x51, 0x04);	//    .

  00275	6a 04		 push	 4
  00277	6a 51		 push	 81			; 00000051H
  00279	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00282	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11770: 			return;

  00285	e9 02 03 00 00	 jmp	 $LN1@CGGuildReq
$LN14@CGGuildReq:

; 11771: 		}
; 11772: 		if( gObj[number].lpGuild->WarState ) //       .

  0028a	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00291	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00297	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  0029e	0f b6 82 91 05
	00 00		 movzx	 eax, BYTE PTR [edx+1425]
  002a5	85 c0		 test	 eax, eax
  002a7	74 15		 je	 SHORT $LN15@CGGuildReq

; 11773: 		{
; 11774: 			GCResultSend(aIndex, 0x51, 0x06);

  002a9	6a 06		 push	 6
  002ab	6a 51		 push	 81			; 00000051H
  002ad	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11775: 			return;

  002b9	e9 ce 02 00 00	 jmp	 $LN1@CGGuildReq
$LN15@CGGuildReq:

; 11776: 		}
; 11777: #ifdef DARKLORD_WORK
; 11778: 		int	MaxGuildMember;
; 11779: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//   -  
; 11780: 		if( gObj[number].Class == CLASS_DARKLORD )
; 11781: 		{
; 11782: 			MaxGuildMember = ( ( gObj[number].Level + gObj[number].m_nMasterLevel ) /10)+(gObj[number].Leadership/10);
; 11783: 		}
; 11784: 		else
; 11785: 		{
; 11786: 			MaxGuildMember = ( ( gObj[number].Level + gObj[number].m_nMasterLevel ) / 10 );
; 11787: 		}
; 11788: #else
; 11789: 		if( gObj[number].Class == CLASS_DARKLORD )

  002be	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002cb	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  002d3	83 fa 04	 cmp	 edx, 4
  002d6	75 42		 jne	 SHORT $LN16@CGGuildReq

; 11790: 		{
; 11791: 			MaxGuildMember = (gObj[number].Level/10)+(gObj[number].Leadership/10);

  002d8	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e5	0f bf 84 01 a0
	00 00 00	 movsx	 eax, WORD PTR [ecx+eax+160]
  002ed	99		 cdq
  002ee	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  002f3	f7 f9		 idiv	 ecx
  002f5	8b c8		 mov	 ecx, eax
  002f7	69 55 f4 a0 1b
	00 00		 imul	 edx, DWORD PTR _number$[ebp], 7072
  002fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00303	0f b7 84 10 d8
	00 00 00	 movzx	 eax, WORD PTR [eax+edx+216]
  0030b	99		 cdq
  0030c	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  00311	f7 fe		 idiv	 esi
  00313	03 c8		 add	 ecx, eax
  00315	89 4d f0	 mov	 DWORD PTR _MaxGuildMember$1[ebp], ecx

; 11792: 		}

  00318	eb 20		 jmp	 SHORT $LN17@CGGuildReq
$LN16@CGGuildReq:

; 11793: 		else
; 11794: 		{
; 11795: 			MaxGuildMember = (gObj[number].Level/10);

  0031a	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00321	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00327	0f bf 84 01 a0
	00 00 00	 movsx	 eax, WORD PTR [ecx+eax+160]
  0032f	99		 cdq
  00330	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00335	f7 f9		 idiv	 ecx
  00337	89 45 f0	 mov	 DWORD PTR _MaxGuildMember$1[ebp], eax
$LN17@CGGuildReq:

; 11796: 		}
; 11797: #endif	// MASTER_LEVEL_UP_SYSTEM_20070912
; 11798: 
; 11799: 		if( MaxGuildMember > MAX_GUILD )

  0033a	83 7d f0 50	 cmp	 DWORD PTR _MaxGuildMember$1[ebp], 80 ; 00000050H
  0033e	7e 07		 jle	 SHORT $LN18@CGGuildReq

; 11800: 		{
; 11801: 			MaxGuildMember = MAX_GUILD;

  00340	c7 45 f0 50 00
	00 00		 mov	 DWORD PTR _MaxGuildMember$1[ebp], 80 ; 00000050H
$LN18@CGGuildReq:

; 11802: 		}
; 11803: 		
; 11804: 		//   .
; 11805: 		if( gObj[number].lpGuild->TotalCount >= MaxGuildMember )

  00347	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0034e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00354	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  0035b	0f b6 42 2e	 movzx	 eax, BYTE PTR [edx+46]
  0035f	3b 45 f0	 cmp	 eax, DWORD PTR _MaxGuildMember$1[ebp]
  00362	7c 15		 jl	 SHORT $LN19@CGGuildReq

; 11806: 		{
; 11807: 			GCResultSend(aIndex, 0x51, 0x02);

  00364	6a 02		 push	 2
  00366	6a 51		 push	 81			; 00000051H
  00368	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0036b	50		 push	 eax
  0036c	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00371	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11808: 			return;

  00374	e9 13 02 00 00	 jmp	 $LN1@CGGuildReq
$LN19@CGGuildReq:

; 11809: 		}
; 11810: #else
; 11811: 		//   .
; 11812: 		if( gObj[number].lpGuild->TotalCount >= (gObj[number].Level/10) )
; 11813: 		{
; 11814: 			GCResultSend(aIndex, 0x51, 0x02);
; 11815: 			return;
; 11816: 		}
; 11817: #endif
; 11818: 	}

  00379	eb 15		 jmp	 SHORT $LN13@CGGuildReq
$LN12@CGGuildReq:

; 11819: 	else
; 11820: 	{
; 11821: 		GCResultSend(aIndex, 0x51, 0x04);	//    .

  0037b	6a 04		 push	 4
  0037d	6a 51		 push	 81			; 00000051H
  0037f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00382	50		 push	 eax
  00383	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00388	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11822: 		return;

  0038b	e9 fc 01 00 00	 jmp	 $LN1@CGGuildReq
$LN13@CGGuildReq:

; 11823: 	}
; 11824: 	
; 11825: 	gObj[aIndex].m_IfState.use    = 1;

  00390	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00397	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0039d	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  003a4	80 e2 fc	 and	 dl, 252			; 000000fcH
  003a7	80 ca 01	 or	 dl, 1
  003aa	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b7	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11826: 	gObj[aIndex].m_IfState.type   = I_GUILD;

  003be	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003cb	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  003d2	80 e2 0f	 and	 dl, 15			; 0000000fH
  003d5	80 ca 40	 or	 dl, 64			; 00000040H
  003d8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003e5	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11827: 	gObj[aIndex].m_IfState.state  = 0;

  003ec	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f9	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00400	80 e2 f3	 and	 dl, 243			; 000000f3H
  00403	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0040a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00410	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11828: 	gObj[number].m_IfState.use    = 1;

  00417	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0041e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00424	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0042b	80 e2 fc	 and	 dl, 252			; 000000fcH
  0042e	80 ca 01	 or	 dl, 1
  00431	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00438	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0043e	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11829: 	gObj[number].m_IfState.type   = I_GUILD;

  00445	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0044c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00452	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00459	80 e2 0f	 and	 dl, 15			; 0000000fH
  0045c	80 ca 40	 or	 dl, 64			; 00000040H
  0045f	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00466	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0046c	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11830: 	gObj[number].m_IfState.state  = 0;

  00473	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0047a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00480	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00487	80 e2 f3	 and	 dl, 243			; 000000f3H
  0048a	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00491	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00497	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11831: 	gObj[aIndex].TargetNumber     = number;

  0049e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ab	66 8b 55 f4	 mov	 dx, WORD PTR _number$[ebp]
  004af	66 89 94 01 ac
	02 00 00	 mov	 WORD PTR [ecx+eax+684], dx

; 11832: 	gObj[number].TargetNumber     = aIndex;

  004b7	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  004be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004c4	66 8b 55 0c	 mov	 dx, WORD PTR _aIndex$[ebp]
  004c8	66 89 94 01 ac
	02 00 00	 mov	 WORD PTR [ecx+eax+684], dx

; 11833: 	gObj[aIndex].m_InterfaceTime  = GetTickCount();

  004d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  004d6	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  004dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004e3	89 84 0a 58 0c
	00 00		 mov	 DWORD PTR [edx+ecx+3160], eax

; 11834: 	gObj[number].m_InterfaceTime  = GetTickCount();

  004ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  004f0	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  004f7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004fd	89 84 0a 58 0c
	00 00		 mov	 DWORD PTR [edx+ecx+3160], eax

; 11835: 
; 11836: 	PHeadSetB((LPBYTE)&pMsg, 0x50, sizeof( pMsg ));

  00504	6a 05		 push	 5
  00506	6a 50		 push	 80			; 00000050H
  00508	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0050b	50		 push	 eax
  0050c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00511	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11837: 
; 11838: 	pMsg.NumberH    = HIBYTE(aIndex);

  00514	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00517	c1 e8 08	 shr	 eax, 8
  0051a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0051f	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 11839: 	pMsg.NumberL    = LOBYTE(aIndex);

  00522	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00525	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0052a	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 11840: 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  0052d	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00531	50		 push	 eax
  00532	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00535	51		 push	 ecx
  00536	8b 55 f4	 mov	 edx, DWORD PTR _number$[ebp]
  00539	52		 push	 edx
  0053a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0053f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11841: 
; 11842: 	LogAddTD("[%s][%s] Guild Request - Join : %s", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[number].lpGuild->Name);

  00542	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00549	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0054f	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  00556	83 c2 04	 add	 edx, 4
  00559	52		 push	 edx
  0055a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00561	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00567	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0056b	52		 push	 edx
  0056c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00573	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00579	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0057d	52		 push	 edx
  0057e	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3@
  00583	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00589	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@CGGuildReq:

; 11843: }

  0058c	5f		 pop	 edi
  0058d	5e		 pop	 esi
  0058e	5b		 pop	 ebx
  0058f	8b e5		 mov	 esp, ebp
  00591	5d		 pop	 ebp
  00592	c3		 ret	 0
?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z ENDP	; CGGuildRequestRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopAnsDealerClosedShop@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
?CGPShopAnsDealerClosedShop@@YAXHH@Z PROC		; CGPShopAnsDealerClosedShop, COMDAT

; 10920: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10921: 	PMSG_REQ_DEALER_CLOSED_SHOP pMsg;
; 10922: 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x12, sizeof( pMsg ));

  00009	6a 06		 push	 6
  0000b	6a 12		 push	 18			; 00000012H
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00018	83 c4 10	 add	 esp, 16			; 00000010H

; 10923: 
; 10924: 	pMsg.NumberH = HIBYTE(aTargetIndex);

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0001e	c1 e8 08	 shr	 eax, 8
  00021	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00026	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 10925: 	pMsg.NumberL = LOBYTE(aTargetIndex);

  00029	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0002c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00031	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 10926: 
; 10927: 	DataSend (aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00034	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00038	50		 push	 eax
  00039	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 55 08	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10928: }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?CGPShopAnsDealerClosedShop@@YAXHH@Z ENDP		; CGPShopAnsDealerClosedShop
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z PROC ; CGPShopReqCloseDeal, COMDAT

; 10892: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10893: 	if (!gObjIsConnected(aIndex)) {

  00009	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	75 02		 jne	 SHORT $LN2@CGPShopReq

; 10894: 		return;

  00019	eb 4e		 jmp	 SHORT $LN1@CGPShopReq
$LN2@CGPShopReq:

; 10895: 	}
; 10896: 
; 10897: 	gObj[aIndex].m_bPShopWantDeal = false;

  0001b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00028	c6 84 01 20 0d
	00 00 00	 mov	 BYTE PTR [ecx+eax+3360], 0

; 10898: 	gObj[aIndex].m_iPShopDealerIndex = -1;

  00030	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003d	c7 84 01 24 0d
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3364], -1

; 10899: 	memset (gObj[aIndex].m_szPShopDealerName, 0, MAX_IDSTRING);

  00048	6a 0a		 push	 10			; 0000000aH
  0004a	6a 00		 push	 0
  0004c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00059	8d 94 01 28 0d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3368]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _memset
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGPShopReq:

; 10900: }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z ENDP ; CGPShopReqCloseDeal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopAnsSoldItem@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 15
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_iItemPos$ = 16						; size = 4
?CGPShopAnsSoldItem@@YAXHHH@Z PROC			; CGPShopAnsSoldItem, COMDAT

; 10906: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 10907: 	PMSG_ANS_SOLDITEM_FROM_PSHOP pMsg;
; 10908: 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x08, sizeof( pMsg ));

  00013	6a 0f		 push	 15			; 0000000fH
  00015	6a 08		 push	 8
  00017	6a 3f		 push	 63			; 0000003fH
  00019	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 10909: 
; 10910: 	pMsg.btItemPos	= iItemPos;

  00025	8a 45 10	 mov	 al, BYTE PTR _iItemPos$[ebp]
  00028	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 10911: 	memcpy(pMsg.btName, gObj[aTargetIndex].Name, MAX_IDSTRING);

  0002b	6a 0a		 push	 10			; 0000000aH
  0002d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003a	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0003e	52		 push	 edx
  0003f	8d 45 f1	 lea	 eax, DWORD PTR _pMsg$[ebp+5]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _memcpy
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10912: 
; 10913: 	DataSend (aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0004b	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0004f	50		 push	 eax
  00050	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00057	52		 push	 edx
  00058	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10914: }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?CGPShopAnsSoldItem@@YAXHHH@Z ENDP			; CGPShopAnsSoldItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopAnsBuyList@@YAXHHE_N@Z
_TEXT	SEGMENT
_n$1 = -600						; size = 4
_itemcount$2 = -596					; size = 4
_lpTargetObj$3 = -592					; size = 4
_lpSourceObj$4 = -588					; size = 4
_lpSourceObj$5 = -584					; size = 4
_pMsgILSize$ = -580					; size = 4
_sOfs$ = -576						; size = 4
_sendBuf$ = -572					; size = 500
_pMsgIL$ = -72						; size = 12
_pMsgILC$ = -60						; size = 55
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_btResult$ = 16						; size = 1
_bResend$ = 20						; size = 1
?CGPShopAnsBuyList@@YAXHHE_N@Z PROC			; CGPShopAnsBuyList, COMDAT

; 10250: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 02 00
	00		 sub	 esp, 728		; 000002d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 10251: 	// aSourceIndex aTargetIndex  . (aTargetIndex    )
; 10252: 
; 10253: 	if (gDoPShopOpen == 0) {

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0001d	75 05		 jne	 SHORT $LN5@CGPShopAns

; 10254: 		return;

  0001f	e9 ef 02 00 00	 jmp	 $LN1@CGPShopAns
$LN5@CGPShopAns:

; 10255: 	}
; 10256: 
; 10257: 	PMSG_ANS_BUYLIST_FROM_PSHOP	pMsgILC;
; 10258: 	PMSG_BUYLIST_FROM_PSHOP		pMsgIL;
; 10259: #ifdef ITEM_INDEX_EXTEND_20050706
; 10260: 	BYTE						sendBuf[1024];
; 10261: #else
; 10262: 	BYTE						sendBuf[500];
; 10263: #endif
; 10264: 	
; 10265: 	int							sOfs       = sizeof(pMsgILC);

  00024	c7 85 c0 fd ff
	ff 37 00 00 00	 mov	 DWORD PTR _sOfs$[ebp], 55 ; 00000037H

; 10266: 	int							pMsgILSize = sizeof(pMsgIL);

  0002e	c7 85 bc fd ff
	ff 0c 00 00 00	 mov	 DWORD PTR _pMsgILSize$[ebp], 12 ; 0000000cH

; 10267: 
; 10268: 	if (btResult != 1) {		//   (1 )   

  00038	0f b6 45 10	 movzx	 eax, BYTE PTR _btResult$[ebp]
  0003c	83 f8 01	 cmp	 eax, 1
  0003f	0f 84 c3 00 00
	00		 je	 $LN6@CGPShopAns

; 10269: 
; 10270: 		LPOBJECTSTRUCT	lpSourceObj = &gObj[aSourceIndex];

  00045	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  0004c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00052	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _lpSourceObj$5[ebp], eax

; 10271: 
; 10272: 		pMsgILC.h.c			= 0xC2;

  00058	c6 45 c4 c2	 mov	 BYTE PTR _pMsgILC$[ebp], 194 ; 000000c2H

; 10273: 		pMsgILC.h.headcode	= 0x3F;

  0005c	c6 45 c7 3f	 mov	 BYTE PTR _pMsgILC$[ebp+3], 63 ; 0000003fH

; 10274: 		if (bResend == false)

  00060	0f b6 45 14	 movzx	 eax, BYTE PTR _bResend$[ebp]
  00064	85 c0		 test	 eax, eax
  00066	75 06		 jne	 SHORT $LN8@CGPShopAns

; 10275: 			pMsgILC.h.subcode	= 0x05;

  00068	c6 45 c8 05	 mov	 BYTE PTR _pMsgILC$[ebp+4], 5
  0006c	eb 04		 jmp	 SHORT $LN9@CGPShopAns
$LN8@CGPShopAns:

; 10276: 		else
; 10277: 			pMsgILC.h.subcode	= 0x13;

  0006e	c6 45 c8 13	 mov	 BYTE PTR _pMsgILC$[ebp+4], 19 ; 00000013H
$LN9@CGPShopAns:

; 10278: 		pMsgILC.h.sizeH		= HIBYTE( sOfs );

  00072	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _sOfs$[ebp]
  00078	c1 e8 08	 shr	 eax, 8
  0007b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00080	88 45 c5	 mov	 BYTE PTR _pMsgILC$[ebp+1], al

; 10279: 		pMsgILC.h.sizeL		= LOBYTE( sOfs );

  00083	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _sOfs$[ebp]
  00089	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0008e	88 45 c6	 mov	 BYTE PTR _pMsgILC$[ebp+2], al

; 10280: 		pMsgILC.btCount		= 0;

  00091	c6 45 fa 00	 mov	 BYTE PTR _pMsgILC$[ebp+54], 0

; 10281: 		pMsgILC.Result		= btResult;

  00095	8a 45 10	 mov	 al, BYTE PTR _btResult$[ebp]
  00098	88 45 c9	 mov	 BYTE PTR _pMsgILC$[ebp+5], al

; 10282: 		pMsgILC.NumberH		= HIBYTE( aTargetIndex );

  0009b	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0009e	c1 e8 08	 shr	 eax, 8
  000a1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a6	88 45 ca	 mov	 BYTE PTR _pMsgILC$[ebp+6], al

; 10283: 		pMsgILC.NumberL		= LOBYTE( aTargetIndex );

  000a9	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  000ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b1	88 45 cb	 mov	 BYTE PTR _pMsgILC$[ebp+7], al

; 10284: 		memset(pMsgILC.btName, 0, MAX_IDSTRING);

  000b4	6a 0a		 push	 10			; 0000000aH
  000b6	6a 00		 push	 0
  000b8	8d 45 cc	 lea	 eax, DWORD PTR _pMsgILC$[ebp+8]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memset
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10285: 		memset(pMsgILC.szPShopText, 0, MAX_PSHOP_TEXT);

  000c4	6a 24		 push	 36			; 00000024H
  000c6	6a 00		 push	 0
  000c8	8d 45 d6	 lea	 eax, DWORD PTR _pMsgILC$[ebp+18]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _memset
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10286: 		memcpy( sendBuf, (char*)&pMsgILC, sizeof(pMsgILC));

  000d4	6a 37		 push	 55			; 00000037H
  000d6	8d 45 c4	 lea	 eax, DWORD PTR _pMsgILC$[ebp]
  000d9	50		 push	 eax
  000da	8d 8d c4 fd ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 _memcpy
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10287: 		
; 10288: 		DataSend(aSourceIndex, (LPBYTE)sendBuf, sOfs);	

  000e9	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _sOfs$[ebp]
  000ef	50		 push	 eax
  000f0	8d 8d c4 fd ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 08	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10289: 	}

  00103	e9 0b 02 00 00	 jmp	 $LN1@CGPShopAns
$LN6@CGPShopAns:

; 10290: 	else {
; 10291: 		LPOBJECTSTRUCT	lpSourceObj = &gObj[aSourceIndex];

  00108	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  0010f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00115	89 85 b4 fd ff
	ff		 mov	 DWORD PTR _lpSourceObj$4[ebp], eax

; 10292: 		LPOBJECTSTRUCT	lpTargetObj = &gObj[aTargetIndex];

  0011b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  00122	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00128	89 85 b0 fd ff
	ff		 mov	 DWORD PTR _lpTargetObj$3[ebp], eax

; 10293: 
; 10294: 		int itemcount=0;

  0012e	c7 85 ac fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _itemcount$2[ebp], 0

; 10295: 
; 10296: 		for( int n=MAX_INVENTORY; n<MAX_INVENTORY_EXTEND; n++)

  00138	c7 85 a8 fd ff
	ff 4c 00 00 00	 mov	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  00142	eb 0f		 jmp	 SHORT $LN4@CGPShopAns
$LN2@CGPShopAns:
  00144	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  0014a	83 c0 01	 add	 eax, 1
  0014d	89 85 a8 fd ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@CGPShopAns:
  00153	83 bd a8 fd ff
	ff 6c		 cmp	 DWORD PTR _n$1[ebp], 108 ; 0000006cH
  0015a	0f 8d f1 00 00
	00		 jge	 $LN3@CGPShopAns

; 10297: 		{
; 10298: 			if( lpTargetObj->Inventory1[n].IsItem() == TRUE )

  00160	69 8d a8 fd ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0016a	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR _lpTargetObj$3[ebp]
  00170	03 88 6c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3180]
  00176	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0017b	83 f8 01	 cmp	 eax, 1
  0017e	0f 85 c8 00 00
	00		 jne	 $LN10@CGPShopAns

; 10299: 			{
; 10300: 				pMsgIL.Pos = n;

  00184	8a 85 a8 fd ff
	ff		 mov	 al, BYTE PTR _n$1[ebp]
  0018a	88 45 b8	 mov	 BYTE PTR _pMsgIL$[ebp], al

; 10301: 				ItemByteConvert( pMsgIL.ItemInfo, lpTargetObj->Inventory1[n] );

  0018d	69 85 a8 fd ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 168
  00197	8b 8d b0 fd ff
	ff		 mov	 ecx, DWORD PTR _lpTargetObj$3[ebp]
  0019d	8b b1 6c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3180]
  001a3	03 f0		 add	 esi, eax
  001a5	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  001ab	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001b0	8b fc		 mov	 edi, esp
  001b2	f3 a5		 rep movsd
  001b4	8d 55 b9	 lea	 edx, DWORD PTR _pMsgIL$[ebp+1]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  001bd	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 10302: 				pMsgIL.PShopItemValue = lpTargetObj->Inventory1[n].m_iPShopValue;

  001c3	69 85 a8 fd ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 168
  001cd	8b 8d b0 fd ff
	ff		 mov	 ecx, DWORD PTR _lpTargetObj$3[ebp]
  001d3	8b 91 6c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3180]
  001d9	8b 44 02 68	 mov	 eax, DWORD PTR [edx+eax+104]
  001dd	89 45 c0	 mov	 DWORD PTR _pMsgIL$[ebp+8], eax

; 10303: 				memcpy(sendBuf+sOfs, (char*)&pMsgIL, pMsgILSize);

  001e0	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _pMsgILSize$[ebp]
  001e6	50		 push	 eax
  001e7	8d 4d b8	 lea	 ecx, DWORD PTR _pMsgIL$[ebp]
  001ea	51		 push	 ecx
  001eb	8b 95 c0 fd ff
	ff		 mov	 edx, DWORD PTR _sOfs$[ebp]
  001f1	8d 84 15 c4 fd
	ff ff		 lea	 eax, DWORD PTR _sendBuf$[ebp+edx]
  001f8	50		 push	 eax
  001f9	e8 00 00 00 00	 call	 _memcpy
  001fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10304: 				itemcount++;

  00201	8b 85 ac fd ff
	ff		 mov	 eax, DWORD PTR _itemcount$2[ebp]
  00207	83 c0 01	 add	 eax, 1
  0020a	89 85 ac fd ff
	ff		 mov	 DWORD PTR _itemcount$2[ebp], eax

; 10305: 				sOfs += pMsgILSize;

  00210	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _sOfs$[ebp]
  00216	03 85 bc fd ff
	ff		 add	 eax, DWORD PTR _pMsgILSize$[ebp]
  0021c	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _sOfs$[ebp], eax

; 10306: 
; 10307: 				LogAddTD("ITEM TYPE:%d", lpTargetObj->Inventory1[n].m_Type);

  00222	69 85 a8 fd ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 168
  0022c	8b 8d b0 fd ff
	ff		 mov	 ecx, DWORD PTR _lpTargetObj$3[ebp]
  00232	8b 91 6c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3180]
  00238	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0023d	50		 push	 eax
  0023e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OAHJEEKI@ITEM?5TYPE?3?$CFd@
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00249	83 c4 08	 add	 esp, 8
$LN10@CGPShopAns:

; 10308: 			}
; 10309: 		}

  0024c	e9 f3 fe ff ff	 jmp	 $LN2@CGPShopAns
$LN3@CGPShopAns:

; 10310: 		
; 10311: 		pMsgILC.h.c				= 0xC2;

  00251	c6 45 c4 c2	 mov	 BYTE PTR _pMsgILC$[ebp], 194 ; 000000c2H

; 10312: 		pMsgILC.h.headcode		= 0x3F;

  00255	c6 45 c7 3f	 mov	 BYTE PTR _pMsgILC$[ebp+3], 63 ; 0000003fH

; 10313: 		if (bResend == false)

  00259	0f b6 45 14	 movzx	 eax, BYTE PTR _bResend$[ebp]
  0025d	85 c0		 test	 eax, eax
  0025f	75 06		 jne	 SHORT $LN11@CGPShopAns

; 10314: 			pMsgILC.h.subcode	= 0x05;

  00261	c6 45 c8 05	 mov	 BYTE PTR _pMsgILC$[ebp+4], 5
  00265	eb 04		 jmp	 SHORT $LN12@CGPShopAns
$LN11@CGPShopAns:

; 10315: 		else
; 10316: 			pMsgILC.h.subcode	= 0x13;

  00267	c6 45 c8 13	 mov	 BYTE PTR _pMsgILC$[ebp+4], 19 ; 00000013H
$LN12@CGPShopAns:

; 10317: 		pMsgILC.h.sizeH			= HIBYTE( sOfs );

  0026b	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _sOfs$[ebp]
  00271	c1 e8 08	 shr	 eax, 8
  00274	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00279	88 45 c5	 mov	 BYTE PTR _pMsgILC$[ebp+1], al

; 10318: 		pMsgILC.h.sizeL			= LOBYTE( sOfs );

  0027c	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _sOfs$[ebp]
  00282	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00287	88 45 c6	 mov	 BYTE PTR _pMsgILC$[ebp+2], al

; 10319: 		pMsgILC.btCount			= itemcount;

  0028a	8a 85 ac fd ff
	ff		 mov	 al, BYTE PTR _itemcount$2[ebp]
  00290	88 45 fa	 mov	 BYTE PTR _pMsgILC$[ebp+54], al

; 10320: 		pMsgILC.Result			= btResult;

  00293	8a 45 10	 mov	 al, BYTE PTR _btResult$[ebp]
  00296	88 45 c9	 mov	 BYTE PTR _pMsgILC$[ebp+5], al

; 10321: 		pMsgILC.NumberH			= HIBYTE( aTargetIndex );

  00299	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0029c	c1 e8 08	 shr	 eax, 8
  0029f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002a4	88 45 ca	 mov	 BYTE PTR _pMsgILC$[ebp+6], al

; 10322: 		pMsgILC.NumberL			= LOBYTE( aTargetIndex );

  002a7	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  002aa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002af	88 45 cb	 mov	 BYTE PTR _pMsgILC$[ebp+7], al

; 10323: 		memcpy(pMsgILC.btName, lpTargetObj->Name, MAX_IDSTRING);

  002b2	6a 0a		 push	 10			; 0000000aH
  002b4	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR _lpTargetObj$3[ebp]
  002ba	83 c0 73	 add	 eax, 115		; 00000073H
  002bd	50		 push	 eax
  002be	8d 4d cc	 lea	 ecx, DWORD PTR _pMsgILC$[ebp+8]
  002c1	51		 push	 ecx
  002c2	e8 00 00 00 00	 call	 _memcpy
  002c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10324: 		memcpy(pMsgILC.szPShopText, lpTargetObj->m_szPShopText, MAX_PSHOP_TEXT);

  002ca	6a 24		 push	 36			; 00000024H
  002cc	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR _lpTargetObj$3[ebp]
  002d2	05 fc 0c 00 00	 add	 eax, 3324		; 00000cfcH
  002d7	50		 push	 eax
  002d8	8d 4d d6	 lea	 ecx, DWORD PTR _pMsgILC$[ebp+18]
  002db	51		 push	 ecx
  002dc	e8 00 00 00 00	 call	 _memcpy
  002e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10325: 		memcpy( sendBuf, (char*)&pMsgILC, sizeof(pMsgILC));

  002e4	6a 37		 push	 55			; 00000037H
  002e6	8d 45 c4	 lea	 eax, DWORD PTR _pMsgILC$[ebp]
  002e9	50		 push	 eax
  002ea	8d 8d c4 fd ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  002f0	51		 push	 ecx
  002f1	e8 00 00 00 00	 call	 _memcpy
  002f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10326: 
; 10327: 		DataSend(aSourceIndex, (LPBYTE)sendBuf, sOfs);	

  002f9	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _sOfs$[ebp]
  002ff	50		 push	 eax
  00300	8d 8d c4 fd ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  00306	51		 push	 ecx
  00307	8b 55 08	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  0030a	52		 push	 edx
  0030b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00310	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGPShopAns:

; 10328: 	}
; 10329: }

  00313	5f		 pop	 edi
  00314	5e		 pop	 esi
  00315	5b		 pop	 ebx
  00316	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00319	33 cd		 xor	 ecx, ebp
  0031b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00320	8b e5		 mov	 esp, ebp
  00322	5d		 pop	 ebp
  00323	c3		 ret	 0
?CGPShopAnsBuyList@@YAXHHE_N@Z ENDP			; CGPShopAnsBuyList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z
_TEXT	SEGMENT
_lpObj$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aSourceIndex$ = 12					; size = 4
?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z PROC ; CGPShopReqBuyList, COMDAT

; 10112: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10113: 	// aSourceIndex  .
; 10114: 	if (gDoPShopOpen == 0) {

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  00010	75 05		 jne	 SHORT $LN2@CGPShopReq

; 10115: 		return;

  00012	e9 cb 04 00 00	 jmp	 $LN1@CGPShopReq
$LN2@CGPShopReq:

; 10116: 	}
; 10117: 	
; 10118: 	if (!gObjIsConnected(MAKEWORD(lpMsg->NumberL, lpMsg->NumberH))) {

  00017	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0001e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00024	0f b6 d1	 movzx	 edx, cl
  00027	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0002e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00034	0f b6 c1	 movzx	 eax, cl
  00037	c1 e0 08	 shl	 eax, 8
  0003a	0b d0		 or	 edx, eax
  0003c	0f b7 ca	 movzx	 ecx, dx
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00045	83 c4 04	 add	 esp, 4
  00048	85 c0		 test	 eax, eax
  0004a	75 70		 jne	 SHORT $LN3@CGPShopReq

; 10119: 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Seller did Not CONNECTED (%d)",

  0004c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004f	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00053	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00059	0f b6 d1	 movzx	 edx, cl
  0005c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0005f	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00063	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00069	0f b6 c1	 movzx	 eax, cl
  0006c	c1 e0 08	 shl	 eax, 8
  0006f	0b d0		 or	 edx, eax
  00071	0f b7 ca	 movzx	 ecx, dx
  00074	51		 push	 ecx
  00075	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00081	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00085	51		 push	 ecx
  00086	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00092	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00096	51		 push	 ecx
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a2	83 c4 10	 add	 esp, 16			; 00000010H

; 10120: 			gObj[aSourceIndex].AccountID,
; 10121: 			gObj[aSourceIndex].Name,
; 10122: 			MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)
; 10123: 			);
; 10124: 		CGPShopAnsBuyList (aSourceIndex, -1, 2);					//  2 :  

  000a5	6a 00		 push	 0
  000a7	6a 02		 push	 2
  000a9	6a ff		 push	 -1
  000ab	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  000b4	83 c4 10	 add	 esp, 16			; 00000010H

; 10125: 		return;

  000b7	e9 26 04 00 00	 jmp	 $LN1@CGPShopReq
$LN3@CGPShopReq:

; 10126: 	}
; 10127: 	
; 10128: 	LPOBJECTSTRUCT lpObj = &gObj[MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)];

  000bc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000bf	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000c3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000c9	0f b6 d1	 movzx	 edx, cl
  000cc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000cf	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000d3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000d9	0f b6 c1	 movzx	 eax, cl
  000dc	c1 e0 08	 shl	 eax, 8
  000df	0b d0		 or	 edx, eax
  000e1	0f b7 ca	 movzx	 ecx, dx
  000e4	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  000ea	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f0	89 55 fc	 mov	 DWORD PTR _lpObj$[ebp], edx

; 10129: 	if (lpObj->Type != OBJTYPE_CHARACTER) {

  000f3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f6	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000fa	83 f9 01	 cmp	 ecx, 1
  000fd	74 70		 je	 SHORT $LN4@CGPShopReq

; 10130: 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Seller is Not CHARACTER (%d)",

  000ff	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00102	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00106	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0010c	0f b6 d1	 movzx	 edx, cl
  0010f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00112	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00116	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0011c	0f b6 c1	 movzx	 eax, cl
  0011f	c1 e0 08	 shl	 eax, 8
  00122	0b d0		 or	 edx, eax
  00124	0f b7 ca	 movzx	 ecx, dx
  00127	51		 push	 ecx
  00128	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00134	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00138	51		 push	 ecx
  00139	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00140	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00145	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00149	51		 push	 ecx
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00155	83 c4 10	 add	 esp, 16			; 00000010H

; 10131: 			gObj[aSourceIndex].AccountID,
; 10132: 			gObj[aSourceIndex].Name,
; 10133: 			MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)
; 10134: 			);
; 10135: 		CGPShopAnsBuyList (aSourceIndex, -1, 2);					//  2 :  

  00158	6a 00		 push	 0
  0015a	6a 02		 push	 2
  0015c	6a ff		 push	 -1
  0015e	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  00167	83 c4 10	 add	 esp, 16			; 00000010H

; 10136: 		return;	

  0016a	e9 73 03 00 00	 jmp	 $LN1@CGPShopReq
$LN4@CGPShopReq:

; 10137: 	}
; 10138: 
; 10139: #ifdef BUGFIX_PERSONALSHOP_ZENCOPY_20050426
; 10140: 	if (lpObj->CloseCount >= 0) {

  0016f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00172	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  00176	85 c9		 test	 ecx, ecx
  00178	7c 70		 jl	 SHORT $LN5@CGPShopReq

; 10141: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Closing (%d)",

  0017a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0017d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00181	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00187	0f b6 d1	 movzx	 edx, cl
  0018a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0018d	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00191	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00197	0f b6 c1	 movzx	 eax, cl
  0019a	c1 e0 08	 shl	 eax, 8
  0019d	0b d0		 or	 edx, eax
  0019f	0f b7 ca	 movzx	 ecx, dx
  001a2	51		 push	 ecx
  001a3	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  001aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001af	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  001b3	51		 push	 ecx
  001b4	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  001bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c0	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  001c4	51		 push	 ecx
  001c5	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001d0	83 c4 10	 add	 esp, 16			; 00000010H

; 10142: 			gObj[aSourceIndex].AccountID,
; 10143: 			gObj[aSourceIndex].Name,
; 10144: 			MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)
; 10145: 			);
; 10146: 		CGPShopAnsBuyItem (aSourceIndex, -1, 0, 2);					//  2 :  

  001d3	6a 02		 push	 2
  001d5	6a 00		 push	 0
  001d7	6a ff		 push	 -1
  001d9	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  001e2	83 c4 10	 add	 esp, 16			; 00000010H

; 10147: 		return;

  001e5	e9 f8 02 00 00	 jmp	 $LN1@CGPShopReq
$LN5@CGPShopReq:

; 10148: 	}
; 10149: 	
; 10150: 	if (gObj[aSourceIndex].CloseCount >= 0) {

  001ea	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  001f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f7	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  001fc	85 d2		 test	 edx, edx
  001fe	7c 70		 jl	 SHORT $LN6@CGPShopReq

; 10151: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Closing (%d)",

  00200	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00203	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00207	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0020d	0f b6 d1	 movzx	 edx, cl
  00210	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00213	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00217	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0021d	0f b6 c1	 movzx	 eax, cl
  00220	c1 e0 08	 shl	 eax, 8
  00223	0b d0		 or	 edx, eax
  00225	0f b7 ca	 movzx	 ecx, dx
  00228	51		 push	 ecx
  00229	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00230	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00235	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00239	51		 push	 ecx
  0023a	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00241	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00246	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  0024a	51		 push	 ecx
  0024b	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00256	83 c4 10	 add	 esp, 16			; 00000010H

; 10152: 			gObj[aSourceIndex].AccountID,
; 10153: 			gObj[aSourceIndex].Name,
; 10154: 			MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)
; 10155: 			);
; 10156: 		CGPShopAnsBuyItem (aSourceIndex, -1, 0, 2);					//  2 :  

  00259	6a 02		 push	 2
  0025b	6a 00		 push	 0
  0025d	6a ff		 push	 -1
  0025f	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00262	50		 push	 eax
  00263	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00268	83 c4 10	 add	 esp, 16			; 00000010H

; 10157: 		return;

  0026b	e9 72 02 00 00	 jmp	 $LN1@CGPShopReq
$LN6@CGPShopReq:

; 10158: 	}
; 10159: #endif
; 10160: 
; 10161: #ifdef ADD_NEWPVP_PKFIELD
; 10162: 	if ( g_NewPVP.IsDuel(gObj[aSourceIndex]) )
; 10163: 	{
; 10164: 		// "    ."
; 10165: 		GCServerMsgStringSend(lMsg.Get(3429), aSourceIndex, 1);
; 10166: 		return;
; 10167: 	}
; 10168: 
; 10169: 	if (g_NewPVP.IsObserver(gObj[aSourceIndex]))
; 10170: 	{
; 10171: 		// "    ."
; 10172: 		GCServerMsgStringSend(lMsg.Get(3430), aSourceIndex, 1);
; 10173: 		return;
; 10174: 	}
; 10175: #endif  // ADD_NEWPVP_PKFIELD
; 10176: 
; 10177: 	if (lpObj->m_Index == aSourceIndex) {

  00270	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00273	8b 08		 mov	 ecx, DWORD PTR [eax]
  00275	3b 4d 0c	 cmp	 ecx, DWORD PTR _aSourceIndex$[ebp]
  00278	75 49		 jne	 SHORT $LN7@CGPShopReq

; 10178: 		//    .
; 10179: 		LogAddTD("[PShop] [%s][%s] PShop List Requested to Him(/Her)Self",

  0027a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00281	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00287	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0028b	52		 push	 edx
  0028c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00293	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00299	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0029d	52		 push	 edx
  0029e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
  002a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10180: 			gObj[aSourceIndex].AccountID,
; 10181: 			gObj[aSourceIndex].Name
; 10182: 			);
; 10183: 		CGPShopAnsBuyList (aSourceIndex, -1, 2);					//  2 :  

  002ac	6a 00		 push	 0
  002ae	6a 02		 push	 2
  002b0	6a ff		 push	 -1
  002b2	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  002b5	50		 push	 eax
  002b6	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  002bb	83 c4 10	 add	 esp, 16			; 00000010H

; 10184: 		return;	

  002be	e9 1f 02 00 00	 jmp	 $LN1@CGPShopReq
$LN7@CGPShopReq:

; 10185: 	}
; 10186: 	
; 10187: 	if (lpObj->m_bPShopOpen == false) {

  002c3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c6	0f b6 88 f8 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3320]
  002cd	85 c9		 test	 ecx, ecx
  002cf	75 55		 jne	 SHORT $LN8@CGPShopReq

; 10188: 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : [%s][%s] Did not Open PShop",

  002d1	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d4	83 c0 73	 add	 eax, 115		; 00000073H
  002d7	50		 push	 eax
  002d8	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002db	83 c1 68	 add	 ecx, 104		; 00000068H
  002de	51		 push	 ecx
  002df	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  002e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002eb	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  002ef	51		 push	 ecx
  002f0	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  002f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002fc	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00300	51		 push	 ecx
  00301	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
  00306	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0030c	83 c4 14	 add	 esp, 20			; 00000014H

; 10189: 			gObj[aSourceIndex].AccountID,
; 10190: 			gObj[aSourceIndex].Name,
; 10191: 			lpObj->AccountID,
; 10192: 			lpObj->Name
; 10193: 			);
; 10194: 		CGPShopAnsBuyList (aSourceIndex, -1, 3);					//  3 :   

  0030f	6a 00		 push	 0
  00311	6a 03		 push	 3
  00313	6a ff		 push	 -1
  00315	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00318	50		 push	 eax
  00319	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  0031e	83 c4 10	 add	 esp, 16			; 00000010H

; 10195: 	}

  00321	e9 bc 01 00 00	 jmp	 $LN1@CGPShopReq
$LN8@CGPShopReq:

; 10196: 	else {
; 10197: 		if( ((lpObj->Penalty&CTLCODE_ITEMDONTTOUCH) == CTLCODE_ITEMDONTTOUCH) ||

  00326	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00329	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  0032f	83 e1 04	 and	 ecx, 4
  00332	75 0e		 jne	 SHORT $LN12@CGPShopReq
  00334	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00337	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  0033d	83 e1 08	 and	 ecx, 8
  00340	74 5a		 je	 SHORT $LN10@CGPShopReq
$LN12@CGPShopReq:

; 10198: 			((lpObj->Penalty&CTLCODE_ACCOUNTITEMBLOCK) == CTLCODE_ACCOUNTITEMBLOCK)
; 10199: 			)
; 10200: 		{
; 10201: 			LogAddTD("[PShop] [%s][%s] PShop List Request Failed : [%s][%s] is in Item Block",

  00342	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00345	83 c0 73	 add	 eax, 115		; 00000073H
  00348	50		 push	 eax
  00349	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0034c	83 c1 68	 add	 ecx, 104		; 00000068H
  0034f	51		 push	 ecx
  00350	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00357	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0035c	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00360	51		 push	 ecx
  00361	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00368	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0036d	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00371	51		 push	 ecx
  00372	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
  00377	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0037d	83 c4 14	 add	 esp, 20			; 00000014H

; 10202: 				gObj[aSourceIndex].AccountID,
; 10203: 				gObj[aSourceIndex].Name,
; 10204: 				lpObj->AccountID,
; 10205: 				lpObj->Name
; 10206: 				);
; 10207: 			CGPShopAnsBuyList (aSourceIndex, -1, 4);				//  4 :    .

  00380	6a 00		 push	 0
  00382	6a 04		 push	 4
  00384	6a ff		 push	 -1
  00386	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00389	50		 push	 eax
  0038a	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  0038f	83 c4 10	 add	 esp, 16			; 00000010H

; 10208: 			return;

  00392	e9 4b 01 00 00	 jmp	 $LN1@CGPShopReq

; 10209: 		}

  00397	e9 46 01 00 00	 jmp	 $LN1@CGPShopReq
$LN10@CGPShopReq:

; 10210: 		else {
; 10211: 
; 10212: #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719			//    -       
; 10213: 			if (gObjFixInventoryPointer(aSourceIndex) == false) {

  0039c	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  0039f	50		 push	 eax
  003a0	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  003a5	83 c4 04	 add	 esp, 4
  003a8	0f b6 c8	 movzx	 ecx, al
  003ab	85 c9		 test	 ecx, ecx
  003ad	75 1c		 jne	 SHORT $LN13@CGPShopReq

; 10214: 				LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  003af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z@4JA
  003b4	83 c0 66	 add	 eax, 102		; 00000066H
  003b7	50		 push	 eax
  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  003bd	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  003c2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003c8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@CGPShopReq:

; 10215: 			}
; 10216: #endif
; 10217: 
; 10218: #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//        . (       )
; 10219: 			if (gObj[aSourceIndex].pTransaction == 1) {

  003cb	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  003d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d8	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  003e0	83 fa 01	 cmp	 edx, 1
  003e3	75 55		 jne	 SHORT $LN14@CGPShopReq

; 10220: 				LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Requester Transaction == 1, IF_TYPE : %d",

  003e5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  003ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f2	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  003f9	c0 ea 04	 shr	 dl, 4
  003fc	80 e2 0f	 and	 dl, 15			; 0000000fH
  003ff	0f b6 c2	 movzx	 eax, dl
  00402	50		 push	 eax
  00403	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aSourceIndex$[ebp], 7072
  0040a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00410	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00414	50		 push	 eax
  00415	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aSourceIndex$[ebp], 7072
  0041c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00422	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00426	50		 push	 eax
  00427	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Req@
  0042c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00432	83 c4 10	 add	 esp, 16			; 00000010H

; 10221: 					gObj[aSourceIndex].AccountID,
; 10222: 					gObj[aSourceIndex].Name,
; 10223: 					gObj[aSourceIndex].m_IfState.type
; 10224: 					);
; 10225: 				return;

  00435	e9 a8 00 00 00	 jmp	 $LN1@CGPShopReq
$LN14@CGPShopReq:

; 10226: 			}
; 10227: #endif
; 10228: 
; 10229: 			//      .
; 10230: 			LogAddTD("[PShop] [%s][%s] is Receiving PShop List From [%s][%s]",

  0043a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0043d	83 c0 73	 add	 eax, 115		; 00000073H
  00440	50		 push	 eax
  00441	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00444	83 c1 68	 add	 ecx, 104		; 00000068H
  00447	51		 push	 ecx
  00448	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  0044f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00454	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00458	51		 push	 ecx
  00459	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00460	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00465	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00469	51		 push	 ecx
  0046a	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5P@
  0046f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00475	83 c4 14	 add	 esp, 20			; 00000014H

; 10231: 				gObj[aSourceIndex].AccountID,
; 10232: 				gObj[aSourceIndex].Name,
; 10233: 				lpObj->AccountID,
; 10234: 				lpObj->Name
; 10235: 				);
; 10236: 
; 10237: 			gObj[aSourceIndex].m_bPShopWantDeal = true;					//     .

  00478	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  0047f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00485	c6 84 01 20 0d
	00 00 01	 mov	 BYTE PTR [ecx+eax+3360], 1

; 10238: 			gObj[aSourceIndex].m_iPShopDealerIndex = lpObj->m_Index;		

  0048d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00494	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0049a	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0049d	8b 12		 mov	 edx, DWORD PTR [edx]
  0049f	89 94 01 24 0d
	00 00		 mov	 DWORD PTR [ecx+eax+3364], edx

; 10239: 			memcpy (gObj[aSourceIndex].m_szPShopDealerName, lpObj->Name, MAX_IDSTRING);

  004a6	6a 0a		 push	 10			; 0000000aH
  004a8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004ab	83 c0 73	 add	 eax, 115		; 00000073H
  004ae	50		 push	 eax
  004af	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aSourceIndex$[ebp], 7072
  004b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004bc	8d 84 0a 28 0d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3368]
  004c3	50		 push	 eax
  004c4	e8 00 00 00 00	 call	 _memcpy
  004c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10240: 
; 10241: 			CGPShopAnsBuyList (aSourceIndex, lpObj->m_Index, true);

  004cc	6a 00		 push	 0
  004ce	6a 01		 push	 1
  004d0	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  004d5	51		 push	 ecx
  004d6	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  004d9	52		 push	 edx
  004da	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  004df	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@CGPShopReq:

; 10242: 		}
; 10243: 	}
; 10244: }

  004e2	5f		 pop	 edi
  004e3	5e		 pop	 esi
  004e4	5b		 pop	 ebx
  004e5	8b e5		 mov	 esp, ebp
  004e7	5d		 pop	 ebp
  004e8	c3		 ret	 0
?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ENDP ; CGPShopReqBuyList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopReqClose@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGPShopReqClose@@YAXH@Z PROC				; CGPShopReqClose, COMDAT

; 10044: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10045: 	if (!gObjIsConnected(aIndex)) {

  00009	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	75 17		 jne	 SHORT $LN2@CGPShopReq

; 10046: 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  00019	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CO@
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00028	83 c4 08	 add	 esp, 8

; 10047: 		return;

  0002b	e9 a1 00 00 00	 jmp	 $LN1@CGPShopReq
$LN2@CGPShopReq:

; 10048: 	}
; 10049: 
; 10050: 	if (gObj[aIndex].Type != OBJTYPE_CHARACTER) {

  00030	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003d	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00042	83 fa 01	 cmp	 edx, 1
  00045	74 14		 je	 SHORT $LN3@CGPShopReq

; 10051: 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  00047	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CH@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00056	83 c4 08	 add	 esp, 8

; 10052: 		return;

  00059	eb 76		 jmp	 SHORT $LN1@CGPShopReq
$LN3@CGPShopReq:

; 10053: 	}
; 10054: 
; 10055: #ifdef ADD_NEWPVP_PKFIELD
; 10056: 	if ( g_NewPVP.IsDuel(gObj[aIndex]))
; 10057: 	{
; 10058: 		// "    ."
; 10059: 		GCServerMsgStringSend(lMsg.Get(3429), aIndex, 1);
; 10060: 		return;
; 10061: 	}
; 10062: 
; 10063: 	if (g_NewPVP.IsObserver(gObj[aIndex]))
; 10064: 	{
; 10065: 		// "    ."
; 10066: 		GCServerMsgStringSend(lMsg.Get(3430), aIndex, 1);
; 10067: 		return;
; 10068: 	}
; 10069: #endif  // ADD_NEWPVP_PKFIELD
; 10070: 
; 10071: 	LogAddTD("[PShop] [%s][%s] Requested to Close PShop",

  0005b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00068	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0006c	52		 push	 edx
  0006d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007a	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0007e	52		 push	 edx
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5C@
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10072: 		gObj[aIndex].AccountID,
; 10073: 		gObj[aIndex].Name
; 10074: 		);
; 10075: 
; 10076: //	gObj[aIndex].m_IfState.use = 0;			//               .
; 10077: //	gObj[aIndex].m_IfState.state = 0;
; 10078: //	gObj[aIndex].m_IfState.type = 0;
; 10079: 
; 10080: 	gObj[aIndex].m_bPShopOpen = false;

  0008d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009a	c6 84 01 f8 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3320], 0

; 10081: 	memset (gObj[aIndex].m_szPShopText, 0, MAX_PSHOP_TEXT);

  000a2	6a 24		 push	 36			; 00000024H
  000a4	6a 00		 push	 0
  000a6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b3	8d 94 01 fc 0c
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3324]
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 _memset
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10082: 	
; 10083: 	CGPShopAnsClose (aIndex, TRUE);

  000c3	6a 01		 push	 1
  000c5	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?CGPShopAnsClose@@YAXHE@Z ; CGPShopAnsClose
  000ce	83 c4 08	 add	 esp, 8
$LN1@CGPShopReq:

; 10084: }

  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
?CGPShopReqClose@@YAXH@Z ENDP				; CGPShopReqClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z
_TEXT	SEGMENT
tv161 = -132						; size = 4
tv193 = -128						; size = 4
tv162 = -128						; size = 4
_pMsg$1 = -60						; size = 52
_bEnablePShopOpen$ = -5					; size = 1
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z PROC	; CGPShopReqOpen, COMDAT

; 9847 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 9848 : 	if (gDoPShopOpen == 0) {

  00016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0001d	75 05		 jne	 SHORT $LN4@CGPShopReq

; 9849 : 		return;

  0001f	e9 34 05 00 00	 jmp	 $LN1@CGPShopReq
$LN4@CGPShopReq:

; 9850 : 	}
; 9851 : 
; 9852 : 	if (!gObjIsConnected(aIndex)) {

  00024	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c0		 test	 eax, eax
  00032	75 17		 jne	 SHORT $LN5@CGPShopReq

; 9853 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  00034	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00037	50		 push	 eax
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CO@
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00043	83 c4 08	 add	 esp, 8

; 9854 : 		return;

  00046	e9 0d 05 00 00	 jmp	 $LN1@CGPShopReq
$LN5@CGPShopReq:

; 9855 : 	}
; 9856 : 
; 9857 : 	if (gObj[aIndex].Type != OBJTYPE_CHARACTER) {

  0004b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00058	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0005d	83 fa 01	 cmp	 edx, 1
  00060	74 17		 je	 SHORT $LN6@CGPShopReq

; 9858 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  00062	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00065	50		 push	 eax
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CH@
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00071	83 c4 08	 add	 esp, 8

; 9859 : 		return;

  00074	e9 df 04 00 00	 jmp	 $LN1@CGPShopReq
$LN6@CGPShopReq:

; 9860 : 	}
; 9861 : 
; 9862 : #ifdef ADD_NEWPVP_PKFIELD
; 9863 : 	if ( g_NewPVP.IsDuel(gObj[aIndex]) )
; 9864 : 	{
; 9865 : 		// "    ."
; 9866 : 		GCServerMsgStringSend(lMsg.Get(3429), aIndex, 1);
; 9867 : 		return;
; 9868 : 	}
; 9869 : 
; 9870 : 	if (g_NewPVP.IsObserver(gObj[aIndex]))
; 9871 : 	{
; 9872 : 		// "    ."
; 9873 : 		GCServerMsgStringSend(lMsg.Get(3430), aIndex, 1);
; 9874 : 		return;
; 9875 : 	}
; 9876 : #endif  // ADD_NEWPVP_PKFIELD
; 9877 : 	
; 9878 : 	if (gObj[aIndex].Level <= 5) {

  00079	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00086	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  0008e	83 fa 05	 cmp	 edx, 5
  00091	7f 5b		 jg	 SHORT $LN7@CGPShopReq

; 9879 : 		//  5     .
; 9880 : 		LogAddTD("[PShop] [%s][%s] ERROR : Level is Under 6 : %d", 

  00093	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a0	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  000a8	52		 push	 edx
  000a9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b6	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000ba	52		 push	 edx
  000bb	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c8	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000cc	52		 push	 edx
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5@
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000d8	83 c4 10	 add	 esp, 16			; 00000010H

; 9881 : 			gObj[aIndex].AccountID,
; 9882 : 			gObj[aIndex].Name,
; 9883 : 			gObj[aIndex].Level
; 9884 : 			);
; 9885 : 		CGPShopAnsOpen (aIndex, 2);	//  2 :    6 

  000db	6a 02		 push	 2
  000dd	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  000e6	83 c4 08	 add	 esp, 8

; 9886 : 		return;

  000e9	e9 6a 04 00 00	 jmp	 $LN1@CGPShopReq
$LN7@CGPShopReq:

; 9887 : 	}
; 9888 : 
; 9889 : 	if( ((gObj[aIndex].Penalty&CTLCODE_ITEMDONTTOUCH) == CTLCODE_ITEMDONTTOUCH) ||

  000ee	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fb	8b 94 01 a8 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+424]
  00102	83 e2 04	 and	 edx, 4
  00105	75 19		 jne	 SHORT $LN9@CGPShopReq
  00107	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0010e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00114	8b 94 01 a8 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+424]
  0011b	83 e2 08	 and	 edx, 8
  0011e	74 45		 je	 SHORT $LN8@CGPShopReq
$LN9@CGPShopReq:

; 9890 : 		((gObj[aIndex].Penalty&CTLCODE_ACCOUNTITEMBLOCK) == CTLCODE_ACCOUNTITEMBLOCK)
; 9891 : 		)
; 9892 : 	{
; 9893 : 		LogAddTD("[PShop] [%s][%s] ERROR : Cant't Open Shop - Item Block", 

  00120	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00131	52		 push	 edx
  00132	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00139	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013f	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00143	52		 push	 edx
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t@
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9894 : 			gObj[aIndex].AccountID,
; 9895 : 			gObj[aIndex].Name
; 9896 : 			);
; 9897 : 		CGPShopAnsOpen (aIndex, 3);	//  3 :    

  00152	6a 03		 push	 3
  00154	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  0015d	83 c4 08	 add	 esp, 8

; 9898 : 		return;

  00160	e9 f3 03 00 00	 jmp	 $LN1@CGPShopReq
$LN8@CGPShopReq:

; 9899 : 	}
; 9900 : 
; 9901 : #ifdef CHAOSCASTLE_SYSTEM_20040408			//       .
; 9902 : 	if (CHECK_CHAOSCASTLE(gObj[aIndex].MapNumber)) {

  00165	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0016c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00172	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0017a	83 fa 12	 cmp	 edx, 18			; 00000012H
  0017d	7d 09		 jge	 SHORT $LN38@CGPShopReq
  0017f	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv162[ebp], 0
  00186	eb 39		 jmp	 SHORT $LN39@CGPShopReq
$LN38@CGPShopReq:
  00188	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0018f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00195	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0019d	83 fa 17	 cmp	 edx, 23			; 00000017H
  001a0	7e 0c		 jle	 SHORT $LN36@CGPShopReq
  001a2	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv161[ebp], 0
  001ac	eb 0a		 jmp	 SHORT $LN37@CGPShopReq
$LN36@CGPShopReq:
  001ae	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv161[ebp], 1
$LN37@CGPShopReq:
  001b8	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv161[ebp]
  001be	89 45 80	 mov	 DWORD PTR tv162[ebp], eax
$LN39@CGPShopReq:
  001c1	83 7d 80 00	 cmp	 DWORD PTR tv162[ebp], 0
  001c5	74 32		 je	 SHORT $LN10@CGPShopReq

; 9903 : 		GCServerMsgStringSend(lMsg.Get(1221), aIndex, 1);	// "      ."

  001c7	6a 01		 push	 1
  001c9	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001cc	50		 push	 eax
  001cd	68 c5 04 00 00	 push	 1221			; 000004c5H
  001d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9904 : 		CGPShopAnsOpen (aIndex, 0);

  001e6	6a 00		 push	 0
  001e8	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  001f1	83 c4 08	 add	 esp, 8

; 9905 : 		return;

  001f4	e9 5f 03 00 00	 jmp	 $LN1@CGPShopReq
$LN10@CGPShopReq:

; 9906 : 	}
; 9907 : #endif
; 9908 : 
; 9909 : 	bool bEnablePShopOpen = false;

  001f9	c6 45 fb 00	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], 0

; 9910 : 
; 9911 : 	if (gObj[aIndex].m_IfState.use == 0) {

  001fd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0020a	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00211	80 e2 03	 and	 dl, 3
  00214	0f b6 c2	 movzx	 eax, dl
  00217	85 c0		 test	 eax, eax
  00219	75 09		 jne	 SHORT $LN11@CGPShopReq

; 9912 : 		bEnablePShopOpen = true;

  0021b	c6 45 fb 01	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], 1

; 9913 : 	}

  0021f	e9 09 01 00 00	 jmp	 $LN12@CGPShopReq
$LN11@CGPShopReq:

; 9914 : 	else if (gObj[aIndex].m_IfState.use == 1) {

  00224	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00231	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00238	80 e2 03	 and	 dl, 3
  0023b	0f b6 c2	 movzx	 eax, dl
  0023e	83 f8 01	 cmp	 eax, 1
  00241	0f 85 91 00 00
	00		 jne	 $LN13@CGPShopReq

; 9915 : 		switch(gObj[aIndex].m_IfState.type) {

  00247	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0024e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00254	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0025b	c0 ea 04	 shr	 dl, 4
  0025e	80 e2 0f	 and	 dl, 15			; 0000000fH
  00261	88 55 80	 mov	 BYTE PTR tv193[ebp], dl
  00264	80 7d 80 08	 cmp	 BYTE PTR tv193[ebp], 8
  00268	74 10		 je	 SHORT $LN22@CGPShopReq
  0026a	eb 12		 jmp	 SHORT $LN2@CGPShopReq

; 9916 : 		case I_TRADE :				//   
; 9917 : 			break;

  0026c	eb 10		 jmp	 SHORT $LN2@CGPShopReq

; 9918 : 		case I_PARTY :				//   
; 9919 : 			break;

  0026e	eb 0e		 jmp	 SHORT $LN2@CGPShopReq

; 9920 : 		case I_SHOP :				//   
; 9921 : 			break;

  00270	eb 0c		 jmp	 SHORT $LN2@CGPShopReq

; 9922 : 		case I_GUILD :				//   
; 9923 : 			break;

  00272	eb 0a		 jmp	 SHORT $LN2@CGPShopReq

; 9924 : 		case I_GUILDCREATE :		//   
; 9925 : 			break;

  00274	eb 08		 jmp	 SHORT $LN2@CGPShopReq

; 9926 : 		case I_WAREHOUSE :			//   
; 9927 : 			break;

  00276	eb 06		 jmp	 SHORT $LN2@CGPShopReq

; 9928 : 		case I_CHAOSBOX :			//   
; 9929 : 			break;

  00278	eb 04		 jmp	 SHORT $LN2@CGPShopReq
$LN22@CGPShopReq:

; 9930 : 		case I_INVENTORY :			//   
; 9931 : 			bEnablePShopOpen = true;	//      

  0027a	c6 45 fb 01	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], 1
$LN2@CGPShopReq:

; 9932 : 			break;
; 9933 : 		case I_EVENTCHIP :			//   
; 9934 : 			break;
; 9935 : 		case I_QUEST :				//   
; 9936 : 			break;
; 9937 : 		case I_SERVERDIVISION :		//  
; 9938 : 			break;
; 9939 : #ifdef DARKLORD_WORK
; 9940 : 		case I_DARK_TRAINER :
; 9941 : 			break;
; 9942 : #endif
; 9943 : 		default:
; 9944 : 			break;
; 9945 : 		}
; 9946 : 
; 9947 : 		if (bEnablePShopOpen == false) {

  0027e	0f b6 45 fb	 movzx	 eax, BYTE PTR _bEnablePShopOpen$[ebp]
  00282	85 c0		 test	 eax, eax
  00284	75 50		 jne	 SHORT $LN28@CGPShopReq

; 9948 : 			LogAddTD("[PShop] [%s][%s] ERROR : m_IfState.type is Using : %d", 

  00286	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0028d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00293	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0029a	c0 ea 04	 shr	 dl, 4
  0029d	80 e2 0f	 and	 dl, 15			; 0000000fH
  002a0	0f b6 c2	 movzx	 eax, dl
  002a3	50		 push	 eax
  002a4	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b1	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  002b5	50		 push	 eax
  002b6	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c3	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  002c7	50		 push	 eax
  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSt@
  002cd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002d3	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@CGPShopReq:

; 9949 : 				gObj[aIndex].AccountID,
; 9950 : 				gObj[aIndex].Name,
; 9951 : 				gObj[aIndex].m_IfState.type
; 9952 : 				);
; 9953 : 		}
; 9954 : 	}

  002d6	eb 55		 jmp	 SHORT $LN12@CGPShopReq
$LN13@CGPShopReq:

; 9955 : 	else {
; 9956 : 		//     
; 9957 : 		LogAddTD("[PShop] [%s][%s] ERROR : Unknown m_IfState.type : %d", 

  002d8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e5	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  002ec	c0 ea 04	 shr	 dl, 4
  002ef	80 e2 0f	 and	 dl, 15			; 0000000fH
  002f2	0f b6 c2	 movzx	 eax, dl
  002f5	50		 push	 eax
  002f6	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00303	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00307	50		 push	 eax
  00308	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0030f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00315	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00319	50		 push	 eax
  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknow@
  0031f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00325	83 c4 10	 add	 esp, 16			; 00000010H

; 9958 : 			gObj[aIndex].AccountID,
; 9959 : 			gObj[aIndex].Name,
; 9960 : 			gObj[aIndex].m_IfState.type
; 9961 : 			);
; 9962 : 		return;

  00328	e9 2b 02 00 00	 jmp	 $LN1@CGPShopReq
$LN12@CGPShopReq:

; 9963 : 	}
; 9964 : 
; 9965 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719		//    -   
; 9966 : 	if (gObjFixInventoryPointer(aIndex) == false) {

  0032d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00330	50		 push	 eax
  00331	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00336	83 c4 04	 add	 esp, 4
  00339	0f b6 c8	 movzx	 ecx, al
  0033c	85 c9		 test	 ecx, ecx
  0033e	75 1c		 jne	 SHORT $LN29@CGPShopReq

; 9967 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00340	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z@4JA
  00345	83 c0 78	 add	 eax, 120		; 00000078H
  00348	50		 push	 eax
  00349	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0034e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  00353	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00359	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@CGPShopReq:

; 9968 : 	}
; 9969 : #endif
; 9970 : 
; 9971 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//       .
; 9972 : 	if (gObj[aIndex].pTransaction == 1) {

  0035c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00363	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00369	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  00371	83 fa 01	 cmp	 edx, 1
  00374	75 54		 jne	 SHORT $LN30@CGPShopReq

; 9973 : 		LogAddTD("[PShop] [%s][%s] ERROR : Transaction == 1, IF_TYPE : %d", 

  00376	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0037d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00383	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0038a	c0 ea 04	 shr	 dl, 4
  0038d	80 e2 0f	 and	 dl, 15			; 0000000fH
  00390	0f b6 c2	 movzx	 eax, dl
  00393	50		 push	 eax
  00394	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0039b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a1	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  003a5	50		 push	 eax
  003a6	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b3	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  003b7	50		 push	 eax
  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transa@
  003bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003c3	83 c4 10	 add	 esp, 16			; 00000010H

; 9974 : 			gObj[aIndex].AccountID,
; 9975 : 			gObj[aIndex].Name,
; 9976 : 			gObj[aIndex].m_IfState.type
; 9977 : 			);
; 9978 : 		bEnablePShopOpen = false;

  003c6	c6 45 fb 00	 mov	 BYTE PTR _bEnablePShopOpen$[ebp], 0
$LN30@CGPShopReq:

; 9979 : 	}
; 9980 : #endif
; 9981 : 
; 9982 : 	if (bEnablePShopOpen) {

  003ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _bEnablePShopOpen$[ebp]
  003ce	85 c0		 test	 eax, eax
  003d0	0f 84 64 01 00
	00		 je	 $LN31@CGPShopReq

; 9983 : 		if (gObj[aIndex].m_bPShopOpen == false) {

  003d6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003e3	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  003eb	85 d2		 test	 edx, edx
  003ed	75 72		 jne	 SHORT $LN33@CGPShopReq

; 9984 : 			//    
; 9985 : //			gObj[aIndex].m_IfState.use = 1;
; 9986 : //			gObj[aIndex].m_IfState.state = 0;
; 9987 : //			gObj[aIndex].m_IfState.type = I_PSHOP_OPEN;		//       I_INVENTORY   .
; 9988 : 
; 9989 : 			gObj[aIndex].m_bPShopOpen = true;

  003ef	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003fc	c6 84 01 f8 0c
	00 00 01	 mov	 BYTE PTR [ecx+eax+3320], 1

; 9990 : 			memcpy (gObj[aIndex].m_szPShopText, lpMsg->szPShopText, MAX_PSHOP_TEXT);

  00404	6a 24		 push	 36			; 00000024H
  00406	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00409	83 c0 04	 add	 eax, 4
  0040c	50		 push	 eax
  0040d	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00414	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0041a	8d 84 0a fc 0c
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3324]
  00421	50		 push	 eax
  00422	e8 00 00 00 00	 call	 _memcpy
  00427	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9991 : 
; 9992 : 			LogAddTD("[PShop] [%s][%s] Personal Shop Opened", 

  0042a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00431	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00437	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0043b	52		 push	 edx
  0043c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00443	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00449	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0044d	52		 push	 edx
  0044e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5@
  00453	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00459	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9993 : 				gObj[aIndex].AccountID,
; 9994 : 				gObj[aIndex].Name
; 9995 : 				);
; 9996 : 		}

  0045c	e9 d7 00 00 00	 jmp	 $LN34@CGPShopReq
$LN33@CGPShopReq:

; 9997 : 		else {
; 9998 : 			//   .
; 9999 : 			memcpy (gObj[aIndex].m_szPShopText, lpMsg->szPShopText, MAX_PSHOP_TEXT);

  00461	6a 24		 push	 36			; 00000024H
  00463	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00466	83 c0 04	 add	 eax, 4
  00469	50		 push	 eax
  0046a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00471	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00477	8d 84 0a fc 0c
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3324]
  0047e	50		 push	 eax
  0047f	e8 00 00 00 00	 call	 _memcpy
  00484	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10000: 			
; 10001: 			//           .
; 10002: 			PMSG_ANS_PSHOP_TEXT_CHANGED pMsg;
; 10003: 			PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x10, sizeof( pMsg ));

  00487	6a 34		 push	 52			; 00000034H
  00489	6a 10		 push	 16			; 00000010H
  0048b	6a 3f		 push	 63			; 0000003fH
  0048d	8d 45 c4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00490	50		 push	 eax
  00491	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00496	83 c4 10	 add	 esp, 16			; 00000010H

; 10004: 
; 10005: 			pMsg.NumberH = HIBYTE( aIndex );

  00499	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0049c	c1 e8 08	 shr	 eax, 8
  0049f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004a4	88 45 c8	 mov	 BYTE PTR _pMsg$1[ebp+4], al

; 10006: 			pMsg.NumberL = LOBYTE( aIndex );

  004a7	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004aa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004af	88 45 c9	 mov	 BYTE PTR _pMsg$1[ebp+5], al

; 10007: 			memcpy(pMsg.btPShopText, lpMsg->szPShopText, MAX_PSHOP_TEXT);

  004b2	6a 24		 push	 36			; 00000024H
  004b4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004b7	83 c0 04	 add	 eax, 4
  004ba	50		 push	 eax
  004bb	8d 4d ca	 lea	 ecx, DWORD PTR _pMsg$1[ebp+6]
  004be	51		 push	 ecx
  004bf	e8 00 00 00 00	 call	 _memcpy
  004c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10008: 			memcpy(pMsg.btName, gObj[aIndex].Name, MAX_IDSTRING);

  004c7	6a 0a		 push	 10			; 0000000aH
  004c9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004d6	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  004da	52		 push	 edx
  004db	8d 45 ee	 lea	 eax, DWORD PTR _pMsg$1[ebp+42]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 _memcpy
  004e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10009: 
; 10010: 			MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  004e7	0f b6 45 c5	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  004eb	50		 push	 eax
  004ec	8d 4d c4	 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  004ef	51		 push	 ecx
  004f0	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  004f7	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004fd	52		 push	 edx
  004fe	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00503	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10011: 
; 10012: 			LogAddTD("[PShop] [%s][%s] Personal Shop Already Opened - Changing PShop Name", 

  00506	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0050d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00513	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00517	52		 push	 edx
  00518	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0051f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00525	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00529	52		 push	 edx
  0052a	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5@
  0052f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00535	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@CGPShopReq:

; 10013: 				gObj[aIndex].AccountID,
; 10014: 				gObj[aIndex].Name
; 10015: 				);
; 10016: 		}
; 10017: 	}

  00538	eb 10		 jmp	 SHORT $LN32@CGPShopReq
$LN31@CGPShopReq:

; 10018: 	else {
; 10019: 		//   .		
; 10020: 		CGPShopAnsOpen (aIndex, 0);

  0053a	6a 00		 push	 0
  0053c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0053f	50		 push	 eax
  00540	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  00545	83 c4 08	 add	 esp, 8

; 10021: 		return;

  00548	eb 0e		 jmp	 SHORT $LN1@CGPShopReq
$LN32@CGPShopReq:

; 10022: 	}
; 10023: 
; 10024: 	//    
; 10025: 	CGPShopAnsOpen (aIndex, 1);

  0054a	6a 01		 push	 1
  0054c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0054f	50		 push	 eax
  00550	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  00555	83 c4 08	 add	 esp, 8
$LN1@CGPShopReq:

; 10026: }

  00558	5f		 pop	 edi
  00559	5e		 pop	 esi
  0055a	5b		 pop	 ebx
  0055b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0055e	33 cd		 xor	 ecx, ebp
  00560	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00565	8b e5		 mov	 esp, ebp
  00567	5d		 pop	 ebp
  00568	c3		 ret	 0
?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z ENDP	; CGPShopReqOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopAnsSetItemPrice@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
_btItemPos$ = 16					; size = 1
?CGPShopAnsSetItemPrice@@YAXHEE@Z PROC			; CGPShopAnsSetItemPrice, COMDAT

; 9833 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9834 : 	PMSG_ANS_PSHOP_SETITEMPRICE	pMsg;
; 9835 : 
; 9836 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x01, sizeof( pMsg ));

  00009	6a 06		 push	 6
  0000b	6a 01		 push	 1
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00018	83 c4 10	 add	 esp, 16			; 00000010H

; 9837 : 	pMsg.btResult	= btResult;

  0001b	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]
  0001e	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 9838 : 	pMsg.btItemPos	= btItemPos;

  00021	8a 45 10	 mov	 al, BYTE PTR _btItemPos$[ebp]
  00024	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 9839 : 	
; 9840 : 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00027	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0002b	50		 push	 eax
  0002c	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9841 : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?CGPShopAnsSetItemPrice@@YAXHEE@Z ENDP			; CGPShopAnsSetItemPrice
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z
_TEXT	SEGMENT
tv142 = -80						; size = 4
tv143 = -76						; size = 4
_iItemPrice$ = -8					; size = 4
_sitem$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z PROC ; CGPShopReqSetItemPrice, COMDAT

; 9700 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9701 : 	if (gDoPShopOpen == 0) {

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  00010	75 1b		 jne	 SHORT $LN2@CGPShopReq

; 9702 : 		CGPShopAnsSetItemPrice (aIndex, 0, lpMsg->btItemPos);		//  0

  00012	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00015	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00019	51		 push	 ecx
  0001a	6a 00		 push	 0
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9703 : 		return;

  00028	e9 33 05 00 00	 jmp	 $LN1@CGPShopReq
$LN2@CGPShopReq:

; 9704 : 	}
; 9705 : 
; 9706 : 	if (!gObjIsConnected(aIndex)) {

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00036	83 c4 04	 add	 esp, 4
  00039	85 c0		 test	 eax, eax
  0003b	75 17		 jne	 SHORT $LN3@CGPShopReq

; 9707 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CO@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0004c	83 c4 08	 add	 esp, 8

; 9708 : 		return;

  0004f	e9 0c 05 00 00	 jmp	 $LN1@CGPShopReq
$LN3@CGPShopReq:

; 9709 : 	}
; 9710 : 
; 9711 : 	if (gObj[aIndex].Type != OBJTYPE_CHARACTER) {

  00054	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00061	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00066	83 fa 01	 cmp	 edx, 1
  00069	74 17		 je	 SHORT $LN4@CGPShopReq

; 9712 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0006e	50		 push	 eax
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CH@
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0007a	83 c4 08	 add	 esp, 8

; 9713 : 		return;

  0007d	e9 de 04 00 00	 jmp	 $LN1@CGPShopReq
$LN4@CGPShopReq:

; 9714 : 	}
; 9715 : 
; 9716 : 	if (gObj[aIndex].Level <= 5) {

  00082	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008f	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00097	83 fa 05	 cmp	 edx, 5
  0009a	7f 63		 jg	 SHORT $LN5@CGPShopReq

; 9717 : 		//  5     .
; 9718 : 		LogAddTD("[PShop] [%s][%s] ERROR : Level is Under 6 : %d", 

  0009c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a9	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  000b1	52		 push	 edx
  000b2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bf	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000c3	52		 push	 edx
  000c4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d1	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000d5	52		 push	 edx
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5@
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e1	83 c4 10	 add	 esp, 16			; 00000010H

; 9719 : 			gObj[aIndex].AccountID,
; 9720 : 			gObj[aIndex].Name,
; 9721 : 			gObj[aIndex].Level
; 9722 : 			);
; 9723 : 		CGPShopAnsSetItemPrice (aIndex, 5, lpMsg->btItemPos);		//  5 :    6 

  000e4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000e7	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000eb	51		 push	 ecx
  000ec	6a 05		 push	 5
  000ee	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000f1	52		 push	 edx
  000f2	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9724 : 		return;

  000fa	e9 61 04 00 00	 jmp	 $LN1@CGPShopReq
$LN5@CGPShopReq:

; 9725 : 	}
; 9726 : 	
; 9727 : 	if (!CHECK_LIMIT(lpMsg->btItemPos, MAX_INVENTORY_EXTEND)) {

  000ff	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00102	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00106	85 c9		 test	 ecx, ecx
  00108	7d 09		 jge	 SHORT $LN18@CGPShopReq
  0010a	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv143[ebp], 0
  00111	eb 22		 jmp	 SHORT $LN19@CGPShopReq
$LN18@CGPShopReq:
  00113	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00116	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0011a	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  0011d	7e 09		 jle	 SHORT $LN16@CGPShopReq
  0011f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
  00126	eb 07		 jmp	 SHORT $LN17@CGPShopReq
$LN16@CGPShopReq:
  00128	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv142[ebp], 1
$LN17@CGPShopReq:
  0012f	8b 4d b0	 mov	 ecx, DWORD PTR tv142[ebp]
  00132	89 4d b4	 mov	 DWORD PTR tv143[ebp], ecx
$LN19@CGPShopReq:
  00135	83 7d b4 00	 cmp	 DWORD PTR tv143[ebp], 0
  00139	75 53		 jne	 SHORT $LN6@CGPShopReq

; 9728 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Position Out of Bound : %d", 

  0013b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0013e	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00142	51		 push	 ecx
  00143	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0014a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014f	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00153	51		 push	 ecx
  00154	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0015b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00160	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00164	51		 push	 ecx
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5P@
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00170	83 c4 10	 add	 esp, 16			; 00000010H

; 9729 : 			gObj[aIndex].AccountID,
; 9730 : 			gObj[aIndex].Name,
; 9731 : 			lpMsg->btItemPos
; 9732 : 			);
; 9733 : 		CGPShopAnsSetItemPrice (aIndex, 2, lpMsg->btItemPos);		//  2 :     

  00173	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00176	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0017a	51		 push	 ecx
  0017b	6a 02		 push	 2
  0017d	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00180	52		 push	 edx
  00181	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00186	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9734 : 		return;

  00189	e9 d2 03 00 00	 jmp	 $LN1@CGPShopReq
$LN6@CGPShopReq:

; 9735 : 	}
; 9736 : 
; 9737 : 	if( gObj[aIndex].Inventory1[lpMsg->btItemPos].IsItem() == FALSE ) 

  0018e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00198	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  0019c	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  001a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a8	03 8c 02 6c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3180]
  001af	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001b4	85 c0		 test	 eax, eax
  001b6	75 53		 jne	 SHORT $LN7@CGPShopReq

; 9738 : 	{
; 9739 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Does Not Exist : %d", 

  001b8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001bb	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001bf	51		 push	 ecx
  001c0	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cc	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  001d0	51		 push	 ecx
  001d1	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  001d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001dd	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  001e1	51		 push	 ecx
  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5D@
  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001ed	83 c4 10	 add	 esp, 16			; 00000010H

; 9740 : 			gObj[aIndex].AccountID,
; 9741 : 			gObj[aIndex].Name,
; 9742 : 			lpMsg->btItemPos
; 9743 : 			);
; 9744 : 		CGPShopAnsSetItemPrice (aIndex, 3, lpMsg->btItemPos);		//  3 :   

  001f0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001f3	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001f7	51		 push	 ecx
  001f8	6a 03		 push	 3
  001fa	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001fd	52		 push	 edx
  001fe	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00203	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9745 : 		return;

  00206	e9 55 03 00 00	 jmp	 $LN1@CGPShopReq
$LN7@CGPShopReq:

; 9746 : 	}
; 9747 : 
; 9748 : 	CItem * sitem = &gObj[aIndex].Inventory1[lpMsg->btItemPos];

  0020b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00212	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00215	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00219	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  0021f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00225	03 8c 02 6c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3180]
  0022c	89 4d fc	 mov	 DWORD PTR _sitem$[ebp], ecx

; 9749 : 	INT iItemPrice = MAKELONG (MAKEWORD(lpMsg->sItemPrice1,lpMsg->sItemPrice2), MAKEWORD(lpMsg->sItemPrice3,lpMsg->sItemPrice4));

  0022f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00232	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00236	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0023c	0f b6 d1	 movzx	 edx, cl
  0023f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00242	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00246	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0024c	0f b6 c1	 movzx	 eax, cl
  0024f	c1 e0 08	 shl	 eax, 8
  00252	0b d0		 or	 edx, eax
  00254	0f b7 ca	 movzx	 ecx, dx
  00257	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0025d	0f b7 d1	 movzx	 edx, cx
  00260	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00263	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00267	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0026d	0f b6 c1	 movzx	 eax, cl
  00270	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00273	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00277	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0027d	0f b6 c9	 movzx	 ecx, cl
  00280	c1 e1 08	 shl	 ecx, 8
  00283	0b c1		 or	 eax, ecx
  00285	0f b7 c0	 movzx	 eax, ax
  00288	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0028d	0f b7 c8	 movzx	 ecx, ax
  00290	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00293	0b d1		 or	 edx, ecx
  00295	89 55 f8	 mov	 DWORD PTR _iItemPrice$[ebp], edx

; 9750 : 
; 9751 : #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202	
; 9752 : 	if( gObjCheckSerial0ItemList(sitem) )

  00298	8b 45 fc	 mov	 eax, DWORD PTR _sitem$[ebp]
  0029b	50		 push	 eax
  0029c	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  002a1	83 c4 04	 add	 esp, 4
  002a4	85 c0		 test	 eax, eax
  002a6	0f 84 90 00 00
	00		 je	 $LN8@CGPShopReq

; 9753 : 	{
; 9754 : 		// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 9755 : 		MsgOutput( aIndex, lMsg.Get(3354) );			// "  .  ."

  002ac	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  002b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002bc	50		 push	 eax
  002bd	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002c0	50		 push	 eax
  002c1	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  002c6	83 c4 08	 add	 esp, 8

; 9756 : #ifdef ADD_SHIELD_POINT_01_20060403
; 9757 : 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 9758 : #else
; 9759 : 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  002c9	6a 01		 push	 1
  002cb	68 fd 00 00 00	 push	 253			; 000000fdH
  002d0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002dd	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  002e6	0f b7 c2	 movzx	 eax, dx
  002e9	50		 push	 eax
  002ea	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002ed	51		 push	 ecx
  002ee	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  002f3	83 c4 10	 add	 esp, 16			; 00000010H

; 9760 : #endif
; 9761 : 		LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop] (%s)(%s) Item(%s) Pos(%d)", 

  002f6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002f9	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  002fd	51		 push	 ecx
  002fe	8b 4d fc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00301	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00306	50		 push	 eax
  00307	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0030e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00313	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00317	51		 push	 ecx
  00318	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0031f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00324	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00328	51		 push	 ecx
  00329	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSh@
  0032e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00334	83 c4 14	 add	 esp, 20			; 00000014H

; 9762 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->GetName(), lpMsg->btItemPos);
; 9763 : 		return;

  00337	e9 24 02 00 00	 jmp	 $LN1@CGPShopReq
$LN8@CGPShopReq:

; 9764 : 	}
; 9765 : #endif
; 9766 : 	
; 9767 : 	// *> .        .
; 9768 : #ifdef PERSONAL_SHOP_CHECK_COPYITEM_200406016
; 9769 : 	if( gObjInventorySearchSerialNumber(&gObj[aIndex], sitem->GetNumber()) == FALSE )

  0033c	8b 4d fc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  0033f	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00344	50		 push	 eax
  00345	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0034c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00352	50		 push	 eax
  00353	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00358	83 c4 08	 add	 esp, 8
  0035b	85 c0		 test	 eax, eax
  0035d	75 72		 jne	 SHORT $LN9@CGPShopReq

; 9770 : 	{
; 9771 : #ifdef ADD_SHIELD_POINT_01_20060403
; 9772 : 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 9773 : #else
; 9774 : 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  0035f	6a 01		 push	 1
  00361	68 fd 00 00 00	 push	 253			; 000000fdH
  00366	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0036d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00373	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  0037c	0f b7 c2	 movzx	 eax, dx
  0037f	50		 push	 eax
  00380	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00383	51		 push	 ecx
  00384	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00389	83 c4 10	 add	 esp, 16			; 00000010H

; 9775 : #endif
; 9776 : 		LogAdd("error-L2 : CopyItem [%s][%s] return %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  0038c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z@4JA
  00391	83 c0 4c	 add	 eax, 76			; 0000004cH
  00394	50		 push	 eax
  00395	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0039a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a7	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  003ab	50		 push	 eax
  003ac	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b9	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  003bd	50		 push	 eax
  003be	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5re@
  003c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003c9	83 c4 14	 add	 esp, 20			; 00000014H

; 9777 : 		return;

  003cc	e9 8f 01 00 00	 jmp	 $LN1@CGPShopReq
$LN9@CGPShopReq:

; 9778 : 	}
; 9779 : #endif
; 9780 : 	
; 9781 : 	if (iItemPrice <= 0) {

  003d1	83 7d f8 00	 cmp	 DWORD PTR _iItemPrice$[ebp], 0
  003d5	7f 57		 jg	 SHORT $LN10@CGPShopReq

; 9782 : 		LogAddTD("[PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d", 

  003d7	8b 45 fc	 mov	 eax, DWORD PTR _sitem$[ebp]
  003da	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  003dd	51		 push	 ecx
  003de	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  003e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ea	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  003ee	51		 push	 ecx
  003ef	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  003f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003fb	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  003ff	51		 push	 ecx
  00400	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPICNFPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Person@
  00405	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0040b	83 c4 10	 add	 esp, 16			; 00000010H

; 9783 : 			gObj[aIndex].AccountID,
; 9784 : 			gObj[aIndex].Name,
; 9785 : 			sitem->m_iPShopValue
; 9786 : 			);
; 9787 : 		CGPShopAnsSetItemPrice (aIndex, 4, lpMsg->btItemPos);			//  4 :   0 .

  0040e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00411	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00415	51		 push	 ecx
  00416	6a 04		 push	 4
  00418	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0041b	52		 push	 edx
  0041c	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00421	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9788 : 		return;

  00424	e9 37 01 00 00	 jmp	 $LN1@CGPShopReq

; 9789 : 	}

  00429	e9 32 01 00 00	 jmp	 $LN13@CGPShopReq
$LN10@CGPShopReq:

; 9790 : 	else {
; 9791 : 		if( ((gObj[aIndex].Penalty&CTLCODE_ITEMDONTTOUCH) == CTLCODE_ITEMDONTTOUCH) ||

  0042e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00435	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0043b	8b 94 01 a8 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+424]
  00442	83 e2 04	 and	 edx, 4
  00445	75 19		 jne	 SHORT $LN14@CGPShopReq
  00447	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0044e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00454	8b 94 01 a8 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+424]
  0045b	83 e2 08	 and	 edx, 8
  0045e	74 57		 je	 SHORT $LN12@CGPShopReq
$LN14@CGPShopReq:

; 9792 : 			((gObj[aIndex].Penalty&CTLCODE_ACCOUNTITEMBLOCK) == CTLCODE_ACCOUNTITEMBLOCK)
; 9793 : 			)
; 9794 : 		{
; 9795 : 			LogAddTD("[PShop] [%s][%s] ERROR : Item Price Change - Item Block", 

  00460	8b 45 fc	 mov	 eax, DWORD PTR _sitem$[ebp]
  00463	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00466	51		 push	 ecx
  00467	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0046e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00473	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00477	51		 push	 ecx
  00478	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0047f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00484	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00488	51		 push	 ecx
  00489	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5P@
  0048e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00494	83 c4 10	 add	 esp, 16			; 00000010H

; 9796 : 				gObj[aIndex].AccountID,
; 9797 : 				gObj[aIndex].Name,
; 9798 : 				sitem->m_iPShopValue
; 9799 : 				);
; 9800 : 
; 9801 : 			CGPShopAnsSetItemPrice (aIndex, 6, lpMsg->btItemPos);		//  6 :   

  00497	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0049a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0049e	51		 push	 ecx
  0049f	6a 06		 push	 6
  004a1	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  004a4	52		 push	 edx
  004a5	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  004aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9802 : 			return;

  004ad	e9 ae 00 00 00	 jmp	 $LN1@CGPShopReq

; 9803 : 		}

  004b2	e9 a9 00 00 00	 jmp	 $LN13@CGPShopReq
$LN12@CGPShopReq:

; 9804 : 		else {
; 9805 : 			//    
; 9806 : 			sitem->m_iPShopValue = iItemPrice;

  004b7	8b 45 fc	 mov	 eax, DWORD PTR _sitem$[ebp]
  004ba	8b 4d f8	 mov	 ecx, DWORD PTR _iItemPrice$[ebp]
  004bd	89 48 68	 mov	 DWORD PTR [eax+104], ecx

; 9807 : 			ItemAttribute[sitem->m_Type].Name[sizeof(ItemAttribute[sitem->m_Type].Name)-1] = 0;

  004c0	8b 45 fc	 mov	 eax, DWORD PTR _sitem$[ebp]
  004c3	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  004c7	6b d1 6c	 imul	 edx, ecx, 108
  004ca	b8 01 00 00 00	 mov	 eax, 1
  004cf	6b c8 1f	 imul	 ecx, eax, 31
  004d2	c6 84 0a 00 00
	00 00 00	 mov	 BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[edx+ecx], 0

; 9808 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 9809 : 			LogAddTD("[PShop] [%s][%s] Changing Item Price : %d (Type:%d (%s), Lev:%d, Serial:%u, Dur:%d", 
; 9810 : #else
; 9811 : 			LogAddTD("[PShop] [%s][%s] Changing Item Price : %d (Type:%d (%s), Lev:%d, Serial:%d, Dur:%d", 

  004da	8b 45 fc	 mov	 eax, DWORD PTR _sitem$[ebp]
  004dd	f3 0f 5a 40 24	 cvtss2sd xmm0, DWORD PTR [eax+36]
  004e2	83 ec 08	 sub	 esp, 8
  004e5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004ea	8b 4d fc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  004ed	8b 11		 mov	 edx, DWORD PTR [ecx]
  004ef	52		 push	 edx
  004f0	8b 45 fc	 mov	 eax, DWORD PTR _sitem$[ebp]
  004f3	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  004f7	51		 push	 ecx
  004f8	8b 55 fc	 mov	 edx, DWORD PTR _sitem$[ebp]
  004fb	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  004ff	6b c8 6c	 imul	 ecx, eax, 108
  00502	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00508	51		 push	 ecx
  00509	8b 55 fc	 mov	 edx, DWORD PTR _sitem$[ebp]
  0050c	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  00510	50		 push	 eax
  00511	8b 4d fc	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00514	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00517	52		 push	 edx
  00518	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0051f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00525	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00529	52		 push	 edx
  0052a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00531	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00537	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0053b	52		 push	 edx
  0053c	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@OAAFOEHL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5@
  00541	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00547	83 c4 28	 add	 esp, 40			; 00000028H

; 9812 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 9813 : 				gObj[aIndex].AccountID,
; 9814 : 				gObj[aIndex].Name,
; 9815 : 				sitem->m_iPShopValue,
; 9816 : 				sitem->m_Type,
; 9817 : 				ItemAttribute[sitem->m_Type].Name,
; 9818 : 				sitem->m_Level,
; 9819 : 				sitem->m_Number,
; 9820 : 				sitem->m_Durability
; 9821 : 				);
; 9822 : 
; 9823 : 			CGPShopAnsSetItemPrice (aIndex, true, lpMsg->btItemPos);

  0054a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0054d	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00551	51		 push	 ecx
  00552	6a 01		 push	 1
  00554	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00557	52		 push	 edx
  00558	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  0055d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@CGPShopReq:
$LN1@CGPShopReq:

; 9824 : 		}
; 9825 : 	}
; 9826 : 	
; 9827 : }

  00560	5f		 pop	 edi
  00561	5e		 pop	 esi
  00562	5b		 pop	 ebx
  00563	8b e5		 mov	 esp, ebp
  00565	5d		 pop	 ebp
  00566	c3		 ret	 0
?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ENDP ; CGPShopReqSetItemPrice
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z
_TEXT	SEGMENT
tv181 = -348						; size = 4
tv182 = -344						; size = 4
_addresult$1 = -276					; size = 4
_pnumber$ = -272					; size = 4
_szTemp$ = -268						; size = 256
_result$ = -9						; size = 1
_number$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z PROC ; CGPartyRequestResultRecv, COMDAT

; 11163: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 11164: 	int number;	
; 11165: 	BYTE result=0x00;

  00016	c6 45 f7 00	 mov	 BYTE PTR _result$[ebp], 0

; 11166: 	char szTemp[256];
; 11167: 	int pnumber=-1;

  0001a	c7 85 f0 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _pnumber$[ebp], -1

; 11168: 
; 11169: 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;

  00024	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00037	83 c4 04	 add	 esp, 4
  0003a	85 c0		 test	 eax, eax
  0003c	75 05		 jne	 SHORT $LN2@CGPartyReq
  0003e	e9 3c 06 00 00	 jmp	 $LN1@CGPartyReq
$LN2@CGPartyReq:

; 11170: 
; 11171: 	number = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00046	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0004a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00050	0f b6 d1	 movzx	 edx, cl
  00053	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00056	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0005a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00060	0f b6 c1	 movzx	 eax, cl
  00063	c1 e0 08	 shl	 eax, 8
  00066	0b d0		 or	 edx, eax
  00068	0f b7 ca	 movzx	 ecx, dx
  0006b	89 4d f8	 mov	 DWORD PTR _number$[ebp], ecx

; 11172: 	if( number < 0 || number > MAX_OBJECT-1 ) return; 

  0006e	83 7d f8 00	 cmp	 DWORD PTR _number$[ebp], 0
  00072	7c 09		 jl	 SHORT $LN4@CGPartyReq
  00074	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _number$[ebp], 7399 ; 00001ce7H
  0007b	7e 05		 jle	 SHORT $LN3@CGPartyReq
$LN4@CGPartyReq:
  0007d	e9 fd 05 00 00	 jmp	 $LN1@CGPartyReq
$LN3@CGPartyReq:

; 11173: 
; 11174: 	//     .
; 11175: 	if( gObjIsConnected(&gObj[aIndex]) == FALSE ) 

  00082	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00089	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsConnected
  00095	83 c4 04	 add	 esp, 4
  00098	85 c0		 test	 eax, eax
  0009a	75 05		 jne	 SHORT $LN5@CGPartyReq

; 11176: 	{
; 11177: 		return;

  0009c	e9 de 05 00 00	 jmp	 $LN1@CGPartyReq
$LN5@CGPartyReq:

; 11178: 	}
; 11179: 	// OK ..
; 11180: 	//   .
; 11181: 	if( gObjIsConnected(&gObj[number]) == FALSE ) 

  000a1	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000a8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsConnected
  000b4	83 c4 04	 add	 esp, 4
  000b7	85 c0		 test	 eax, eax
  000b9	75 12		 jne	 SHORT $LN6@CGPartyReq

; 11182: 	{		
; 11183: 		GCResultSend(aIndex, 0x41, 0x04);	//   .

  000bb	6a 04		 push	 4
  000bd	6a 41		 push	 65			; 00000041H
  000bf	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11184: 	}

  000cb	eb 04		 jmp	 SHORT $LN7@CGPartyReq
$LN6@CGPartyReq:

; 11185: 	else result = 0x01;

  000cd	c6 45 f7 01	 mov	 BYTE PTR _result$[ebp], 1
$LN7@CGPartyReq:

; 11186: 
; 11187: #ifdef MODIFY_REQUESTNPC_HACK
; 11188: 	if (gObj[number].Type != OBJTYPE_CHARACTER)

  000d1	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000de	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000e3	83 fa 01	 cmp	 edx, 1
  000e6	74 7f		 je	 SHORT $LN8@CGPartyReq

; 11189: 	{
; 11190: 		LogAddC(LOGC_RED,"[HACKTOOL] : NPC-TradeRequest(Result) npc:%d ip:%s account:%s name:%s State:%d", 

  000e8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f5	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  000f9	52		 push	 edx
  000fa	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00101	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00107	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0010b	52		 push	 edx
  0010c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00119	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0011d	52		 push	 edx
  0011e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00125	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012b	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0012f	52		 push	 edx
  00130	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013d	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00145	52		 push	 edx
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@FDAKNNLI@?$FLHACKTOOL?$FN?5?3?5NPC?9TradeRequest?$CIR@
  0014b	6a 02		 push	 2
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00153	83 c4 1c	 add	 esp, 28			; 0000001cH

; 11191: 			gObj[number].Class, 
; 11192: 			gObj[aIndex].Ip_addr,
; 11193: 			gObj[aIndex].AccountID, 
; 11194: 			gObj[aIndex].Name, 
; 11195: 			gObj[aIndex].Connected);
; 11196: 		
; 11197: 		CloseClient(aIndex);

  00156	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0015f	83 c4 04	 add	 esp, 4

; 11198: 		return;

  00162	e9 18 05 00 00	 jmp	 $LN1@CGPartyReq
$LN8@CGPartyReq:

; 11199: 	}
; 11200: #endif // MODIFY_REQUESTNPC_HACK
; 11201: 
; 11202: #ifdef MODIFY_CHAOSCASTLE_BUGFIX_20060919		//      
; 11203: 	//         .
; 11204: 	if( gObj[number].MapNumber != gObj[aIndex].MapNumber )

  00167	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00174	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0017c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00183	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00189	0f b6 84 01 09
	01 00 00	 movzx	 eax, BYTE PTR [ecx+eax+265]
  00191	3b d0		 cmp	 edx, eax
  00193	74 14		 je	 SHORT $LN9@CGPartyReq

; 11205: 	{
; 11206: 		result = 0x00;

  00195	c6 45 f7 00	 mov	 BYTE PTR _result$[ebp], 0

; 11207: 		GCResultSend( number, 0x41, 0x00 );

  00199	6a 00		 push	 0
  0019b	6a 41		 push	 65			; 00000041H
  0019d	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGPartyReq:

; 11208: 	}
; 11209: 
; 11210: 	//        .
; 11211: 	if( CHECK_CHAOSCASTLE( gObj[aIndex].MapNumber ) )  

  001a9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b6	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001be	83 fa 12	 cmp	 edx, 18			; 00000012H
  001c1	7d 0c		 jge	 SHORT $LN30@CGPartyReq
  001c3	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv182[ebp], 0
  001cd	eb 3c		 jmp	 SHORT $LN31@CGPartyReq
$LN30@CGPartyReq:
  001cf	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001dc	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001e4	83 fa 17	 cmp	 edx, 23			; 00000017H
  001e7	7e 0c		 jle	 SHORT $LN28@CGPartyReq
  001e9	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv181[ebp], 0
  001f3	eb 0a		 jmp	 SHORT $LN29@CGPartyReq
$LN28@CGPartyReq:
  001f5	c7 85 a4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv181[ebp], 1
$LN29@CGPartyReq:
  001ff	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv181[ebp]
  00205	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv182[ebp], eax
$LN31@CGPartyReq:
  0020b	83 bd a8 fe ff
	ff 00		 cmp	 DWORD PTR tv182[ebp], 0
  00212	74 33		 je	 SHORT $LN10@CGPartyReq

; 11212: 	{
; 11213: 		GCServerMsgStringSend( lMsg.Get( 1222 ), aIndex, 1 );		// "      ."

  00214	6a 01		 push	 1
  00216	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00219	50		 push	 eax
  0021a	68 c6 04 00 00	 push	 1222			; 000004c6H
  0021f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0022a	50		 push	 eax
  0022b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00230	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11214: 		result = 0x00;

  00233	c6 45 f7 00	 mov	 BYTE PTR _result$[ebp], 0

; 11215: 		GCResultSend( number, 0x41, 0x00 );

  00237	6a 00		 push	 0
  00239	6a 41		 push	 65			; 00000041H
  0023b	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0023e	50		 push	 eax
  0023f	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@CGPartyReq:

; 11216: 	}
; 11217: #endif
; 11218: 	
; 11219: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//      
; 11220: 	if( CHECK_ILLUSION_TEMPLE( gObj[aIndex].MapNumber) )
; 11221: 	{
; 11222: 		result = 0x00;
; 11223: 		GCResultSend( number, 0x41, 0x00 );
; 11224: 	}
; 11225: #endif
; 11226: 
; 11227: 	// CANCEL  
; 11228: 	if( lpMsg->Result == 0x00 ) 

  00247	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0024a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0024e	85 c9		 test	 ecx, ecx
  00250	75 14		 jne	 SHORT $LN11@CGPartyReq

; 11229: 	{		
; 11230: 		result = 0x00;

  00252	c6 45 f7 00	 mov	 BYTE PTR _result$[ebp], 0

; 11231: 		GCResultSend(number, 0x41, 0x01);

  00256	6a 01		 push	 1
  00258	6a 41		 push	 65			; 00000041H
  0025a	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0025d	50		 push	 eax
  0025e	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00263	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@CGPartyReq:

; 11232: 	}
; 11233: 
; 11234: 	//    ..
; 11235: 	if( gObj[number].m_IfState.use == 0 || gObj[number].m_IfState.type != I_PARTY )

  00266	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0026d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00273	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0027a	80 e2 03	 and	 dl, 3
  0027d	0f b6 c2	 movzx	 eax, dl
  00280	85 c0		 test	 eax, eax
  00282	74 22		 je	 SHORT $LN13@CGPartyReq
  00284	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0028b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00291	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00298	c0 ea 04	 shr	 dl, 4
  0029b	80 e2 0f	 and	 dl, 15			; 0000000fH
  0029e	0f b6 c2	 movzx	 eax, dl
  002a1	83 f8 02	 cmp	 eax, 2
  002a4	74 14		 je	 SHORT $LN12@CGPartyReq
$LN13@CGPartyReq:

; 11236: 	{
; 11237: 		result = 0x00;

  002a6	c6 45 f7 00	 mov	 BYTE PTR _result$[ebp], 0

; 11238: 		GCResultSend(number, 0x41, 0x00);

  002aa	6a 00		 push	 0
  002ac	6a 41		 push	 65			; 00000041H
  002ae	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  002b1	50		 push	 eax
  002b2	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@CGPartyReq:

; 11239: 		//LogAddL("%s   .", gObj[number].Name);
; 11240: 	}
; 11241: 	
; 11242: 	//    ..
; 11243: 	if( gObj[aIndex].m_IfState.use == 0 || gObj[aIndex].m_IfState.type != I_PARTY )

  002ba	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c7	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  002ce	80 e2 03	 and	 dl, 3
  002d1	0f b6 c2	 movzx	 eax, dl
  002d4	85 c0		 test	 eax, eax
  002d6	74 22		 je	 SHORT $LN15@CGPartyReq
  002d8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e5	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  002ec	c0 ea 04	 shr	 dl, 4
  002ef	80 e2 0f	 and	 dl, 15			; 0000000fH
  002f2	0f b6 c2	 movzx	 eax, dl
  002f5	83 f8 02	 cmp	 eax, 2
  002f8	74 14		 je	 SHORT $LN14@CGPartyReq
$LN15@CGPartyReq:

; 11244: 	{
; 11245: 		result = 0x00;

  002fa	c6 45 f7 00	 mov	 BYTE PTR _result$[ebp], 0

; 11246: 		GCResultSend(number, 0x41, 0x00);

  002fe	6a 00		 push	 0
  00300	6a 41		 push	 65			; 00000041H
  00302	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00305	50		 push	 eax
  00306	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0030b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@CGPartyReq:

; 11247: 		//LogAddL("%s   .", gObj[aIndex].Name);
; 11248: 	}
; 11249: 
; 11250: 	if( result == 0x01 )

  0030e	0f b6 45 f7	 movzx	 eax, BYTE PTR _result$[ebp]
  00312	83 f8 01	 cmp	 eax, 1
  00315	0f 85 46 02 00
	00		 jne	 $LN16@CGPartyReq

; 11251: 	{		
; 11252: 		//      .
; 11253: 		if( gObj[number].PartyNumber < 0 ) 

  0031b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00322	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00328	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  00330	7d 4a		 jge	 SHORT $LN17@CGPartyReq

; 11254: 		{
; 11255: 			gObj[number].PartyNumber = gParty.Create(number, gObj[number].DBNumber, gObj[number].Level);

  00332	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00339	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0033f	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00347	52		 push	 edx
  00348	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0034f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00355	8b 54 01 2c	 mov	 edx, DWORD PTR [ecx+eax+44]
  00359	52		 push	 edx
  0035a	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0035d	50		 push	 eax
  0035e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00363	e8 00 00 00 00	 call	 ?Create@PartyClass@@QAEHHHH@Z ; PartyClass::Create
  00368	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  0036f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00375	89 84 0a 88 02
	00 00		 mov	 DWORD PTR [edx+ecx+648], eax
$LN17@CGPartyReq:

; 11256: 		}
; 11257: 
; 11258: 		//    ..  .
; 11259: 		if( gObj[number].PartyNumber >= 0 ) 

  0037c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00383	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00389	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  00391	0f 8c ca 01 00
	00		 jl	 $LN16@CGPartyReq

; 11260: 		{
; 11261: 			pnumber = gObj[number].PartyNumber;

  00397	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0039e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a4	8b 94 01 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+648]
  003ab	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _pnumber$[ebp], edx

; 11262: 			int addresult = gParty.Add(gObj[number].PartyNumber, aIndex, gObj[aIndex].DBNumber, gObj[aIndex].Level);

  003b1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003be	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  003c6	52		 push	 edx
  003c7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d4	8b 54 01 2c	 mov	 edx, DWORD PTR [ecx+eax+44]
  003d8	52		 push	 edx
  003d9	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003dc	50		 push	 eax
  003dd	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  003e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ea	8b 84 0a 88 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+648]
  003f1	50		 push	 eax
  003f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  003f7	e8 00 00 00 00	 call	 ?Add@PartyClass@@QAEHHHHH@Z ; PartyClass::Add
  003fc	89 85 ec fe ff
	ff		 mov	 DWORD PTR _addresult$1[ebp], eax

; 11263: 
; 11264: 			if( addresult >= 0 )

  00402	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _addresult$1[ebp], 0
  00409	0f 8c d2 00 00
	00		 jl	 $LN19@CGPartyReq

; 11265: 			{
; 11266: 				gObj[aIndex].PartyNumber = gObj[number].PartyNumber;

  0040f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00416	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0041d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00423	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00429	8b 84 06 88 02
	00 00		 mov	 eax, DWORD PTR [esi+eax+648]
  00430	89 84 0a 88 02
	00 00		 mov	 DWORD PTR [edx+ecx+648], eax

; 11267: 				result = 0x01;

  00437	c6 45 f7 01	 mov	 BYTE PTR _result$[ebp], 1

; 11268: 
; 11269: 				wsprintf(szTemp, lMsg.Get(1107), gObj[aIndex].Name);

  0043b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00442	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00448	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0044c	52		 push	 edx
  0044d	68 53 04 00 00	 push	 1107			; 00000453H
  00452	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00457	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0045d	50		 push	 eax
  0045e	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00464	50		 push	 eax
  00465	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0046b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11270: 				GCServerMsgStringSend(szTemp, number, 1);

  0046e	6a 01		 push	 1
  00470	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00473	50		 push	 eax
  00474	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0047a	51		 push	 ecx
  0047b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00480	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11271: 				wsprintf(szTemp, lMsg.Get(1107), gObj[number].Name);

  00483	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0048a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00490	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00494	52		 push	 edx
  00495	68 53 04 00 00	 push	 1107			; 00000453H
  0049a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0049f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  004a5	50		 push	 eax
  004a6	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  004ac	50		 push	 eax
  004ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  004b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11272: 				GCServerMsgStringSend(szTemp, aIndex, 1);

  004b6	6a 01		 push	 1
  004b8	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004bb	50		 push	 eax
  004bc	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  004c2	51		 push	 ecx
  004c3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11273: 				gParty.Paint(pnumber);				

  004cb	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pnumber$[ebp]
  004d1	50		 push	 eax
  004d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  004d7	e8 00 00 00 00	 call	 ?Paint@PartyClass@@QAEXH@Z ; PartyClass::Paint

; 11274: 			}

  004dc	e9 80 00 00 00	 jmp	 $LN16@CGPartyReq
$LN19@CGPartyReq:

; 11275: 			else if( addresult == -1 )	//  

  004e1	83 bd ec fe ff
	ff ff		 cmp	 DWORD PTR _addresult$1[ebp], -1
  004e8	75 22		 jne	 SHORT $LN21@CGPartyReq

; 11276: 			{				
; 11277: 				GCResultSend(number, 0x41, 0x02);

  004ea	6a 02		 push	 2
  004ec	6a 41		 push	 65			; 00000041H
  004ee	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  004f1	50		 push	 eax
  004f2	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  004f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11278: 				GCResultSend(aIndex, 0x41, 0x02);

  004fa	6a 02		 push	 2
  004fc	6a 41		 push	 65			; 00000041H
  004fe	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00501	50		 push	 eax
  00502	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00507	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11279: 			}

  0050a	eb 55		 jmp	 SHORT $LN16@CGPartyReq
$LN21@CGPartyReq:

; 11280: 			else if( addresult == -2 )	//   

  0050c	83 bd ec fe ff
	ff fe		 cmp	 DWORD PTR _addresult$1[ebp], -2 ; fffffffeH
  00513	75 4c		 jne	 SHORT $LN16@CGPartyReq

; 11281: 			{
; 11282: 				result = 0x02;

  00515	c6 45 f7 02	 mov	 BYTE PTR _result$[ebp], 2

; 11283: 				wsprintf(szTemp, lMsg.Get(1108), gObj[aIndex].Name);

  00519	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00520	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00526	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0052a	52		 push	 edx
  0052b	68 54 04 00 00	 push	 1108			; 00000454H
  00530	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00535	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0053b	50		 push	 eax
  0053c	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00542	50		 push	 eax
  00543	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00549	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11284: 				GCServerMsgStringSend(szTemp, aIndex, 1);

  0054c	6a 01		 push	 1
  0054e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00551	50		 push	 eax
  00552	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00558	51		 push	 ecx
  00559	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0055e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@CGPartyReq:

; 11285: 			}
; 11286: 		}		
; 11287: 	}
; 11288: 	
; 11289: 	//   
; 11290: 	if( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == I_PARTY )

  00561	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00568	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0056e	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00575	80 e2 03	 and	 dl, 3
  00578	0f b6 c2	 movzx	 eax, dl
  0057b	85 c0		 test	 eax, eax
  0057d	74 65		 je	 SHORT $LN24@CGPartyReq
  0057f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00586	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0058c	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00593	c0 ea 04	 shr	 dl, 4
  00596	80 e2 0f	 and	 dl, 15			; 0000000fH
  00599	0f b6 c2	 movzx	 eax, dl
  0059c	83 f8 02	 cmp	 eax, 2
  0059f	75 43		 jne	 SHORT $LN24@CGPartyReq

; 11291: 	{
; 11292: 		gObj[aIndex].m_IfState.use      = 0;

  005a1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ae	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  005b5	80 e2 fc	 and	 dl, 252			; 000000fcH
  005b8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c5	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11293: 		gObj[aIndex].PartyTargetUser	= -1;		

  005cc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005d9	c7 84 01 8c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+652], -1
$LN24@CGPartyReq:

; 11294: 		
; 11295: 		//LogAddL("%s   ", gObj[aIndex].Name);
; 11296: 	}
; 11297: 	
; 11298: 	//   
; 11299: 	if( gObj[number].m_IfState.use && gObj[number].m_IfState.type == I_PARTY )

  005e4	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  005eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005f1	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  005f8	80 e2 03	 and	 dl, 3
  005fb	0f b6 c2	 movzx	 eax, dl
  005fe	85 c0		 test	 eax, eax
  00600	74 65		 je	 SHORT $LN25@CGPartyReq
  00602	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00609	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0060f	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00616	c0 ea 04	 shr	 dl, 4
  00619	80 e2 0f	 and	 dl, 15			; 0000000fH
  0061c	0f b6 c2	 movzx	 eax, dl
  0061f	83 f8 02	 cmp	 eax, 2
  00622	75 43		 jne	 SHORT $LN25@CGPartyReq

; 11300: 	{
; 11301: 		gObj[number].m_IfState.use		= 0;

  00624	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0062b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00631	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00638	80 e2 fc	 and	 dl, 252			; 000000fcH
  0063b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00642	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00648	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11302: 		gObj[number].PartyTargetUser	= -1;

  0064f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00656	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0065c	c7 84 01 8c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+652], -1
$LN25@CGPartyReq:

; 11303: 		
; 11304: 		//LogAddL("%s   ", gObj[number].Name);
; 11305: 	}
; 11306: 	
; 11307: 	if( pnumber >= 0 ) CGPartyListAll(pnumber);

  00667	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR _pnumber$[ebp], 0
  0066e	7c 0f		 jl	 SHORT $LN1@CGPartyReq
  00670	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pnumber$[ebp]
  00676	50		 push	 eax
  00677	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  0067c	83 c4 04	 add	 esp, 4
$LN1@CGPartyReq:

; 11308: }

  0067f	5f		 pop	 edi
  00680	5e		 pop	 esi
  00681	5b		 pop	 ebx
  00682	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00685	33 cd		 xor	 ecx, ebp
  00687	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0068c	8b e5		 mov	 esp, ebp
  0068e	5d		 pop	 ebp
  0068f	c3		 ret	 0
?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ENDP ; CGPartyRequestResultRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPartyListAll@@YAXH@Z
_TEXT	SEGMENT
_n$ = -560						; size = 4
_number$ = -556						; size = 4
_lOfs$ = -552						; size = 4
_sendbuf$ = -548					; size = 512
_pList$ = -36						; size = 24
_pCount$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_pnumber$ = 8						; size = 4
?CGPartyListAll@@YAXH@Z PROC				; CGPartyListAll, COMDAT

; 11369: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 02 00
	00		 sub	 esp, 688		; 000002b0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 11370: 	PMSG_PARTYLISTCOUNT	pCount;
; 11371: 	PMSG_PARTYLIST		pList;
; 11372: 	char sendbuf[512];
; 11373: 	int  lOfs=0;

  00016	c7 85 d8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 11374: 	int  number;
; 11375: 	int  n;
; 11376: 	
; 11377: 	//   
; 11378: 	//int pnumber = gObj[aIndex].PartyNumber;
; 11379: 	if( pnumber < 0 ) return;

  00020	83 7d 08 00	 cmp	 DWORD PTR _pnumber$[ebp], 0
  00024	7d 05		 jge	 SHORT $LN8@CGPartyLis
  00026	e9 4f 02 00 00	 jmp	 $LN1@CGPartyLis
$LN8@CGPartyLis:

; 11380: 	if( gParty.IsParty(pnumber) == FALSE ) return;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _pnumber$[ebp]
  0002e	50		 push	 eax
  0002f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00034	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  00039	85 c0		 test	 eax, eax
  0003b	75 05		 jne	 SHORT $LN9@CGPartyLis
  0003d	e9 38 02 00 00	 jmp	 $LN1@CGPartyLis
$LN9@CGPartyLis:

; 11381: 
; 11382: 	PHeadSetB((LPBYTE)&pCount, 0x42, sizeof( pCount ));

  00042	6a 05		 push	 5
  00044	6a 42		 push	 66			; 00000042H
  00046	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11383: 
; 11384: 	pCount.Result       = 0x00;

  00052	c6 45 f7 00	 mov	 BYTE PTR _pCount$[ebp+3], 0

; 11385: 	pCount.Count		= gParty.GetCount(pnumber);

  00056	8b 45 08	 mov	 eax, DWORD PTR _pnumber$[ebp]
  00059	50		 push	 eax
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0005f	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  00064	88 45 f8	 mov	 BYTE PTR _pCount$[ebp+4], al

; 11386: 	if( pCount.Count == 0 ) return;

  00067	0f b6 45 f8	 movzx	 eax, BYTE PTR _pCount$[ebp+4]
  0006b	85 c0		 test	 eax, eax
  0006d	75 05		 jne	 SHORT $LN10@CGPartyLis
  0006f	e9 06 02 00 00	 jmp	 $LN1@CGPartyLis
$LN10@CGPartyLis:

; 11387: 
; 11388: 	pCount.Result = 0x01;

  00074	c6 45 f7 01	 mov	 BYTE PTR _pCount$[ebp+3], 1

; 11389: 	lOfs += sizeof(pCount);

  00078	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0007e	83 c0 05	 add	 eax, 5
  00081	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 11390: 	for( n=0; n<MAX_PARTYUSER; n++)

  00087	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00091	eb 0f		 jmp	 SHORT $LN4@CGPartyLis
$LN2@CGPartyLis:
  00093	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LN4@CGPartyLis:
  000a2	83 bd d0 fd ff
	ff 05		 cmp	 DWORD PTR _n$[ebp], 5
  000a9	0f 8d 4a 01 00
	00		 jge	 $LN3@CGPartyLis

; 11391: 	{			
; 11392: 		number = gParty.m_PartyS[pnumber].Number[n];

  000af	6b 45 08 30	 imul	 eax, DWORD PTR _pnumber$[ebp], 48
  000b3	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  000b9	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  000c0	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _number$[ebp], edx

; 11393: 		if( number >= 0 )

  000c6	83 bd d4 fd ff
	ff 00		 cmp	 DWORD PTR _number$[ebp], 0
  000cd	0f 8c 21 01 00
	00		 jl	 $LN12@CGPartyLis

; 11394: 		{
; 11395: 			if( gObjIsConnected(&gObj[number], gParty.m_PartyS[pnumber].DbNumber[n]) == TRUE ) 

  000d3	6b 45 08 30	 imul	 eax, DWORD PTR _pnumber$[ebp], 48
  000d7	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  000dd	8b 94 88 20 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+32]
  000e4	52		 push	 edx
  000e5	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  000ef	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjIsConnected
  000fb	83 c4 08	 add	 esp, 8
  000fe	83 f8 01	 cmp	 eax, 1
  00101	0f 85 ed 00 00
	00		 jne	 $LN12@CGPartyLis

; 11396: 			{
; 11397: 				memset(&pList, 0, sizeof(pList));

  00107	6a 18		 push	 24			; 00000018H
  00109	6a 00		 push	 0
  0010b	8d 45 dc	 lea	 eax, DWORD PTR _pList$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _memset
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11398: 				memcpy(pList.szId,  gObj[number].Name, MAX_IDSTRING);

  00117	6a 0a		 push	 10			; 0000000aH
  00119	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  00123	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00129	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0012d	52		 push	 edx
  0012e	8d 45 dc	 lea	 eax, DWORD PTR _pList$[ebp]
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 _memcpy
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11399: 				pList.Number    = n;

  0013a	8a 85 d0 fd ff
	ff		 mov	 al, BYTE PTR _n$[ebp]
  00140	88 45 e6	 mov	 BYTE PTR _pList$[ebp+10], al

; 11400: 				pList.MapNumber = gObj[number].MapNumber;

  00143	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00153	8a 94 01 09 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+265]
  0015a	88 55 e7	 mov	 BYTE PTR _pList$[ebp+11], dl

; 11401: 				pList.X			= (BYTE)gObj[number].X;

  0015d	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  00167	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016d	8a 94 01 04 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+260]
  00174	88 55 e8	 mov	 BYTE PTR _pList$[ebp+12], dl

; 11402: 				pList.Y			= (BYTE)gObj[number].Y;

  00177	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  00181	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00187	8a 94 01 06 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+262]
  0018e	88 55 e9	 mov	 BYTE PTR _pList$[ebp+13], dl

; 11403: 				pList.Life		= (int)gObj[number].Life;

  00191	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  0019b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a1	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  001aa	89 55 ec	 mov	 DWORD PTR _pList$[ebp+16], edx

; 11404: 				pList.MaxLife	= (int)gObj[number].MaxLife;

  001ad	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  001b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bd	f3 0f 2c 94 01
	c0 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+192]
  001c6	89 55 f0	 mov	 DWORD PTR _pList$[ebp+20], edx

; 11405: 				memcpy(sendbuf+lOfs, (char*)&pList, sizeof(PMSG_PARTYLIST));

  001c9	6a 18		 push	 24			; 00000018H
  001cb	8d 45 dc	 lea	 eax, DWORD PTR _pList$[ebp]
  001ce	50		 push	 eax
  001cf	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  001d5	8d 94 0d dc fd
	ff ff		 lea	 edx, DWORD PTR _sendbuf$[ebp+ecx]
  001dc	52		 push	 edx
  001dd	e8 00 00 00 00	 call	 _memcpy
  001e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11406: 				lOfs += sizeof(PMSG_PARTYLIST);

  001e5	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  001eb	83 c0 18	 add	 eax, 24			; 00000018H
  001ee	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax
$LN12@CGPartyLis:

; 11407: 			}
; 11408: 		}
; 11409: 	}

  001f4	e9 9a fe ff ff	 jmp	 $LN2@CGPartyLis
$LN3@CGPartyLis:

; 11410: 	pCount.h.size = lOfs;

  001f9	8a 85 d8 fd ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  001ff	88 45 f5	 mov	 BYTE PTR _pCount$[ebp+1], al

; 11411: 	memcpy(sendbuf, (char*)&pCount, sizeof(pCount));

  00202	6a 05		 push	 5
  00204	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  00207	50		 push	 eax
  00208	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 _memcpy
  00214	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11412: 
; 11413: 	for( n=0; n<MAX_PARTYUSER; n++)

  00217	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00221	eb 0f		 jmp	 SHORT $LN7@CGPartyLis
$LN5@CGPartyLis:
  00223	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00229	83 c0 01	 add	 eax, 1
  0022c	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LN7@CGPartyLis:
  00232	83 bd d0 fd ff
	ff 05		 cmp	 DWORD PTR _n$[ebp], 5
  00239	7d 3f		 jge	 SHORT $LN6@CGPartyLis

; 11414: 	{			
; 11415: 		number = gParty.m_PartyS[pnumber].Number[n];

  0023b	6b 45 08 30	 imul	 eax, DWORD PTR _pnumber$[ebp], 48
  0023f	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  00245	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  0024c	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _number$[ebp], edx

; 11416: 		if( number >= 0 )

  00252	83 bd d4 fd ff
	ff 00		 cmp	 DWORD PTR _number$[ebp], 0
  00259	7c 1d		 jl	 SHORT $LN13@CGPartyLis

; 11417: 		{
; 11418: 			DataSend(number, (LPBYTE)sendbuf, lOfs);

  0025b	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00261	50		 push	 eax
  00262	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  00268	51		 push	 ecx
  00269	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _number$[ebp]
  0026f	52		 push	 edx
  00270	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00275	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@CGPartyLis:

; 11419: 		}
; 11420: 	}

  00278	eb a9		 jmp	 SHORT $LN5@CGPartyLis
$LN6@CGPartyLis:
$LN1@CGPartyLis:

; 11421: }

  0027a	5f		 pop	 edi
  0027b	5e		 pop	 esi
  0027c	5b		 pop	 ebx
  0027d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00280	33 cd		 xor	 ecx, ebp
  00282	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00287	8b e5		 mov	 esp, ebp
  00289	5d		 pop	 ebp
  0028a	c3		 ret	 0
?CGPartyListAll@@YAXH@Z ENDP				; CGPartyListAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPartyList@@YAXH@Z
_TEXT	SEGMENT
_n$1 = -564						; size = 4
_pnumber$ = -560					; size = 4
_number$ = -556						; size = 4
_lOfs$ = -552						; size = 4
_sendbuf$ = -548					; size = 512
_pList$ = -36						; size = 24
_pCount$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?CGPartyList@@YAXH@Z PROC				; CGPartyList, COMDAT

; 11313: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 02 00
	00		 sub	 esp, 692		; 000002b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 11314: 	PMSG_PARTYLISTCOUNT	pCount;
; 11315: 	PMSG_PARTYLIST		pList;
; 11316: 	char sendbuf[512];
; 11317: 	int  lOfs=0;

  00016	c7 85 d8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 11318: 	int  number;
; 11319: 
; 11320: 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;

  00020	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00027	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	75 05		 jne	 SHORT $LN5@CGPartyLis
  0003a	e9 3b 02 00 00	 jmp	 $LN1@CGPartyLis
$LN5@CGPartyLis:

; 11321: 	
; 11322: 	PHeadSetB((LPBYTE)&pCount, 0x42, sizeof( pCount ));

  0003f	6a 05		 push	 5
  00041	6a 42		 push	 66			; 00000042H
  00043	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11323: 
; 11324: 	pCount.Count        = 0;

  0004f	c6 45 f8 00	 mov	 BYTE PTR _pCount$[ebp+4], 0

; 11325: 	pCount.Result       = 0x00;

  00053	c6 45 f7 00	 mov	 BYTE PTR _pCount$[ebp+3], 0

; 11326: 
; 11327: 	//   
; 11328: 	int pnumber = gObj[aIndex].PartyNumber;

  00057	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00064	8b 94 01 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+648]
  0006b	89 95 d0 fd ff
	ff		 mov	 DWORD PTR _pnumber$[ebp], edx

; 11329: 	if( pnumber >= 0 )

  00071	83 bd d0 fd ff
	ff 00		 cmp	 DWORD PTR _pnumber$[ebp], 0
  00078	7c 14		 jl	 SHORT $LN6@CGPartyLis

; 11330: 	{
; 11331: 		pCount.Count = gParty.GetCount(pnumber);

  0007a	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _pnumber$[ebp]
  00080	50		 push	 eax
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00086	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  0008b	88 45 f8	 mov	 BYTE PTR _pCount$[ebp+4], al
$LN6@CGPartyLis:

; 11332: 	}
; 11333: 
; 11334: 	lOfs += sizeof(pCount);

  0008e	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00094	83 c0 05	 add	 eax, 5
  00097	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 11335: 	if( pCount.Count )

  0009d	0f b6 45 f8	 movzx	 eax, BYTE PTR _pCount$[ebp+4]
  000a1	85 c0		 test	 eax, eax
  000a3	0f 84 99 01 00
	00		 je	 $LN7@CGPartyLis

; 11336: 	{
; 11337: 		for( int n=0; n<MAX_PARTYUSER; n++)

  000a9	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1[ebp], 0
  000b3	eb 0f		 jmp	 SHORT $LN4@CGPartyLis
$LN2@CGPartyLis:
  000b5	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  000bb	83 c0 01	 add	 eax, 1
  000be	89 85 cc fd ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@CGPartyLis:
  000c4	83 bd cc fd ff
	ff 05		 cmp	 DWORD PTR _n$1[ebp], 5
  000cb	0f 8d 6d 01 00
	00		 jge	 $LN3@CGPartyLis

; 11338: 		{			
; 11339: 			number = gParty.m_PartyS[pnumber].Number[n];

  000d1	6b 85 d0 fd ff
	ff 30		 imul	 eax, DWORD PTR _pnumber$[ebp], 48
  000d8	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _n$1[ebp]
  000de	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  000e5	89 95 d4 fd ff
	ff		 mov	 DWORD PTR _number$[ebp], edx

; 11340: 			if( number >= 0 )

  000eb	83 bd d4 fd ff
	ff 00		 cmp	 DWORD PTR _number$[ebp], 0
  000f2	0f 8c 41 01 00
	00		 jl	 $LN9@CGPartyLis

; 11341: 			{
; 11342: 				if( gObjIsConnected(&gObj[number], gParty.m_PartyS[pnumber].DbNumber[n]) == TRUE ) 

  000f8	6b 85 d0 fd ff
	ff 30		 imul	 eax, DWORD PTR _pnumber$[ebp], 48
  000ff	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _n$1[ebp]
  00105	8b 94 88 20 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+32]
  0010c	52		 push	 edx
  0010d	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  00117	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjIsConnected
  00123	83 c4 08	 add	 esp, 8
  00126	83 f8 01	 cmp	 eax, 1
  00129	0f 85 0a 01 00
	00		 jne	 $LN9@CGPartyLis

; 11343: 				{
; 11344: 					memset(&pList, 0, sizeof(pList));

  0012f	6a 18		 push	 24			; 00000018H
  00131	6a 00		 push	 0
  00133	8d 45 dc	 lea	 eax, DWORD PTR _pList$[ebp]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _memset
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11345: 					memcpy(pList.szId,  gObj[number].Name, MAX_IDSTRING);

  0013f	6a 0a		 push	 10			; 0000000aH
  00141	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  0014b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00151	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00155	52		 push	 edx
  00156	8d 45 dc	 lea	 eax, DWORD PTR _pList$[ebp]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _memcpy
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11346: 					pList.Number    = n;

  00162	8a 85 cc fd ff
	ff		 mov	 al, BYTE PTR _n$1[ebp]
  00168	88 45 e6	 mov	 BYTE PTR _pList$[ebp+10], al

; 11347: 					pList.MapNumber = gObj[number].MapNumber;

  0016b	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  00175	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017b	8a 94 01 09 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+265]
  00182	88 55 e7	 mov	 BYTE PTR _pList$[ebp+11], dl

; 11348: 					pList.X			= (BYTE)gObj[number].X;

  00185	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  0018f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00195	8a 94 01 04 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+260]
  0019c	88 55 e8	 mov	 BYTE PTR _pList$[ebp+12], dl

; 11349: 					pList.Y			= (BYTE)gObj[number].Y;

  0019f	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001af	8a 94 01 06 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+262]
  001b6	88 55 e9	 mov	 BYTE PTR _pList$[ebp+13], dl

; 11350: 
; 11351: 					pList.Life		= (int)gObj[number].Life;

  001b9	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c9	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  001d2	89 55 ec	 mov	 DWORD PTR _pList$[ebp+16], edx

; 11352: 					pList.MaxLife	= (int)(gObj[number].MaxLife+gObj[number].AddLife);

  001d5	69 85 d4 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$[ebp], 7072
  001df	69 8d d4 fd ff
	ff a0 1b 00 00	 imul	 ecx, DWORD PTR _number$[ebp], 7072
  001e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ef	f3 0f 2a 84 0a
	0c 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+268]
  001f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001fe	f3 0f 58 84 01
	c0 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+192]
  00207	f3 0f 2c d0	 cvttss2si edx, xmm0
  0020b	89 55 f0	 mov	 DWORD PTR _pList$[ebp+20], edx

; 11353: 					memcpy(sendbuf+lOfs, (char*)&pList, sizeof(PMSG_PARTYLIST));

  0020e	6a 18		 push	 24			; 00000018H
  00210	8d 45 dc	 lea	 eax, DWORD PTR _pList$[ebp]
  00213	50		 push	 eax
  00214	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  0021a	8d 94 0d dc fd
	ff ff		 lea	 edx, DWORD PTR _sendbuf$[ebp+ecx]
  00221	52		 push	 edx
  00222	e8 00 00 00 00	 call	 _memcpy
  00227	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11354: 					lOfs += sizeof(PMSG_PARTYLIST);

  0022a	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00230	83 c0 18	 add	 eax, 24			; 00000018H
  00233	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax
$LN9@CGPartyLis:

; 11355: 				}
; 11356: 			}
; 11357: 		}

  00239	e9 77 fe ff ff	 jmp	 $LN2@CGPartyLis
$LN3@CGPartyLis:

; 11358: 		pCount.Result = 0x01;

  0023e	c6 45 f7 01	 mov	 BYTE PTR _pCount$[ebp+3], 1
$LN7@CGPartyLis:

; 11359: 	}
; 11360: 	pCount.h.size = lOfs;

  00242	8a 85 d8 fd ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  00248	88 45 f5	 mov	 BYTE PTR _pCount$[ebp+1], al

; 11361: 	memcpy(sendbuf, (char*)&pCount, sizeof(pCount));

  0024b	6a 05		 push	 5
  0024d	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  00250	50		 push	 eax
  00251	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  00257	51		 push	 ecx
  00258	e8 00 00 00 00	 call	 _memcpy
  0025d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11362: 
; 11363: 	DataSend(aIndex, (LPBYTE)sendbuf, lOfs);

  00260	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00266	50		 push	 eax
  00267	8d 8d dc fd ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  0026d	51		 push	 ecx
  0026e	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00271	52		 push	 edx
  00272	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00277	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGPartyLis:

; 11364: }

  0027a	5f		 pop	 edi
  0027b	5e		 pop	 esi
  0027c	5b		 pop	 ebx
  0027d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00280	33 cd		 xor	 ecx, ebp
  00282	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00287	8b e5		 mov	 esp, ebp
  00289	5d		 pop	 ebp
  0028a	c3		 ret	 0
?CGPartyList@@YAXH@Z ENDP				; CGPartyList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z
_TEXT	SEGMENT
tv74 = -112						; size = 4
tv75 = -108						; size = 4
_usebp$1 = -40						; size = 4
_usemana$2 = -36					; size = 4
_pTeleportResult$3 = -32				; size = 8
_pAttack$4 = -24					; size = 8
_y$5 = -14						; size = 1
_x$6 = -13						; size = 1
_lpMagic$7 = -12					; size = 4
_pTeleportResult$8 = -8					; size = 8
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z PROC		; CGTeleportRecv, COMDAT

; 15720: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15721: 
; 15722: #ifdef ADD_NEW_SKILL_FOR_CASTLE_02_20050531
; 15723: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )
; 15724: 		return;
; 15725: 
; 15726: 	//       .
; 15727: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 15728: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  
; 15729: 	if( gObjCheckUsedBuffEffect( &gObj[aIndex], BUFFTYPE_STUN ) == true 
; 15730: 		|| ( gObjCheckUsedBuffEffect( &gObj[aIndex], BUFFTYPE_SLEEP ) == true ))
; 15731: #else
; 15732: 	if( gObjCheckUsedBuffEffect( &gObj[aIndex], BUFFTYPE_STUN ) == true )
; 15733: #endif
; 15734: #else
; 15735: 	if( gObj[aIndex].m_iSkillStunTime > 0 )
; 15736: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 15737: #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_6_200708013
; 15738: 	{
; 15739: 		//  ..   
; 15740: 		PMSG_TELEPORT_RESULT		pTeleportResult;
; 15741: 		pTeleportResult.h.c			= PMHCE_BYTE;
; 15742: 		pTeleportResult.h.size		= sizeof( pTeleportResult );
; 15743: 		pTeleportResult.h.headcode	= 0x1C;
; 15744: 		pTeleportResult.MoveNumber	= 0;
; 15745: 		pTeleportResult.MapNumber	= gObj[aIndex].MapNumber;
; 15746: 		pTeleportResult.MapX		= gObj[aIndex].X;
; 15747: 		pTeleportResult.MapY		= gObj[aIndex].Y;
; 15748: 		pTeleportResult.Dir			= gObj[aIndex].Dir;			
; 15749: 		
; 15750: 		DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);	
; 15751: 		return;
; 15752: 	}
; 15753: #else
; 15754: 		return;
; 15755: #endif	// MODIFY_ILLUSIONTEMPLE_BUGFIX_6_200708013
; 15756: 
; 15757: #endif
; 15758: 
; 15759: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//     ,  
; 15760: 	if(CHECK_ILLUSION_TEMPLE(gObj[aIndex].MapNumber) 
; 15761: 		&& g_IllusionTempleEvent.GetIllusionTempleState(gObj[aIndex].MapNumber) == ILLUSION_TEMPLE_STATE_PLAYING)
; 15762: 	{
; 15763: 		if(g_IllusionTempleEvent.CheckRelics(aIndex))
; 15764: 		{
; 15765: 			//  ..   
; 15766: 			PMSG_TELEPORT_RESULT		pTeleportResult;
; 15767: 			pTeleportResult.h.c			= PMHCE_BYTE;
; 15768: 			pTeleportResult.h.size		= sizeof( pTeleportResult );
; 15769: 			pTeleportResult.h.headcode	= 0x1C;
; 15770: 			pTeleportResult.MoveNumber	= 0;
; 15771: 			pTeleportResult.MapNumber	= gObj[aIndex].MapNumber;
; 15772: 			pTeleportResult.MapX		= gObj[aIndex].X;
; 15773: 			pTeleportResult.MapY		= gObj[aIndex].Y;
; 15774: 			pTeleportResult.Dir			= gObj[aIndex].Dir;			
; 15775: 
; 15776: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);	
; 15777: 			
; 15778: 			return;
; 15779: 		}
; 15780: 
; 15781: 		//     
; 15782: #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_4_20070802
; 15783: 		if(g_IllusionTempleEvent.CheckSkillRestraint(gObj[aIndex].m_iIllusionTempleIndex, gObj[aIndex].MapNumber))
; 15784: #else
; 15785: 		if((gObj[aIndex].m_ViewSkillState & STATE_ILLUSION_TEMPLE_RESTRAINT) == STATE_ILLUSION_TEMPLE_RESTRAINT)
; 15786: #endif
; 15787: 		{
; 15788: 			//  ..   
; 15789: 			PMSG_TELEPORT_RESULT		pTeleportResult;
; 15790: 			pTeleportResult.h.c			= PMHCE_BYTE;
; 15791: 			pTeleportResult.h.size		= sizeof( pTeleportResult );
; 15792: 			pTeleportResult.h.headcode	= 0x1C;
; 15793: 			pTeleportResult.MoveNumber	= 0;
; 15794: 			pTeleportResult.MapNumber	= gObj[aIndex].MapNumber;
; 15795: 			pTeleportResult.MapX		= gObj[aIndex].X;
; 15796: 			pTeleportResult.MapY		= gObj[aIndex].Y;
; 15797: 			pTeleportResult.Dir			= gObj[aIndex].Dir;			
; 15798: 
; 15799: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);	
; 15800: 			
; 15801: 			return;
; 15802: 		}
; 15803: 	}
; 15804: #endif
; 15805: 
; 15806: #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_3_20070731	//     
; 15807: 	if(CHECK_ILLUSION_TEMPLE(gObj[aIndex].MapNumber) 
; 15808: 		&& g_IllusionTempleEvent.GetIllusionTempleState(gObj[aIndex].MapNumber) == ILLUSION_TEMPLE_STATE_READY)
; 15809: 	{
; 15810: 		//  ..   
; 15811: 		PMSG_TELEPORT_RESULT		pTeleportResult;
; 15812: 		pTeleportResult.h.c			= PMHCE_BYTE;
; 15813: 		pTeleportResult.h.size		= sizeof( pTeleportResult );
; 15814: 		pTeleportResult.h.headcode	= 0x1C;
; 15815: 		pTeleportResult.MoveNumber	= 0;
; 15816: 		pTeleportResult.MapNumber	= gObj[aIndex].MapNumber;
; 15817: 		pTeleportResult.MapX		= gObj[aIndex].X;
; 15818: 		pTeleportResult.MapY		= gObj[aIndex].Y;
; 15819: 		pTeleportResult.Dir			= gObj[aIndex].Dir;			
; 15820: 		
; 15821: 		DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);	
; 15822: 		
; 15823: 		return;
; 15824: 	}
; 15825: #endif
; 15826: 	
; 15827: #ifdef MODIFY_DONT_TELEPORT_EVNET_ENDING_IN_EVENTMAP_20081118
; 15828: 	//      
; 15829: 	if( CHECK_CHAOSCASTLE( gObj[aIndex].MapNumber )
; 15830: 		&& g_ChaosCastle.GetCurrentState(gObj[aIndex].m_cChaosCastleIndex) == CHAOSCASTLE_STATE_PLAYEND

  00009	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0001e	83 fa 12	 cmp	 edx, 18			; 00000012H
  00021	7d 09		 jge	 SHORT $LN15@CGTeleport
  00023	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  0002a	eb 30		 jmp	 SHORT $LN16@CGTeleport
$LN15@CGTeleport:
  0002c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00039	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00041	83 fa 17	 cmp	 edx, 23			; 00000017H
  00044	7e 09		 jle	 SHORT $LN13@CGTeleport
  00046	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  0004d	eb 07		 jmp	 SHORT $LN14@CGTeleport
$LN13@CGTeleport:
  0004f	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$LN14@CGTeleport:
  00056	8b 45 90	 mov	 eax, DWORD PTR tv74[ebp]
  00059	89 45 94	 mov	 DWORD PTR tv75[ebp], eax
$LN16@CGTeleport:
  0005c	83 7d 94 00	 cmp	 DWORD PTR tv75[ebp], 0
  00060	0f 84 af 00 00
	00		 je	 $LN2@CGTeleport
  00066	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00073	0f be 94 01 d9
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3289]
  0007b	52		 push	 edx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00081	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  00086	83 f8 03	 cmp	 eax, 3
  00089	0f 85 86 00 00
	00		 jne	 $LN2@CGTeleport

; 15831: 		)
; 15832: 	{
; 15833: 		//  ..   
; 15834: 		PMSG_TELEPORT_RESULT		pTeleportResult;
; 15835: 		pTeleportResult.h.c			= PMHCE_BYTE;

  0008f	c6 45 f8 c3	 mov	 BYTE PTR _pTeleportResult$8[ebp], 195 ; 000000c3H

; 15836: 		pTeleportResult.h.size		= sizeof( pTeleportResult );

  00093	c6 45 f9 08	 mov	 BYTE PTR _pTeleportResult$8[ebp+1], 8

; 15837: 		pTeleportResult.h.headcode	= 0x1C;

  00097	c6 45 fa 1c	 mov	 BYTE PTR _pTeleportResult$8[ebp+2], 28 ; 0000001cH

; 15838: 		pTeleportResult.MoveNumber	= 0;

  0009b	c6 45 fb 00	 mov	 BYTE PTR _pTeleportResult$8[ebp+3], 0

; 15839: 		pTeleportResult.MapNumber	= gObj[aIndex].MapNumber;

  0009f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ac	8a 94 01 09 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+265]
  000b3	88 55 fc	 mov	 BYTE PTR _pTeleportResult$8[ebp+4], dl

; 15840: 		pTeleportResult.MapX		= gObj[aIndex].X;

  000b6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c3	8a 94 01 04 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+260]
  000ca	88 55 fd	 mov	 BYTE PTR _pTeleportResult$8[ebp+5], dl

; 15841: 		pTeleportResult.MapY		= gObj[aIndex].Y;

  000cd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000da	8a 94 01 06 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+262]
  000e1	88 55 fe	 mov	 BYTE PTR _pTeleportResult$8[ebp+6], dl

; 15842: 		pTeleportResult.Dir			= gObj[aIndex].Dir;			

  000e4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f1	8a 94 01 08 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+264]
  000f8	88 55 ff	 mov	 BYTE PTR _pTeleportResult$8[ebp+7], dl

; 15843: 		
; 15844: 		DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);	

  000fb	0f b6 45 f9	 movzx	 eax, BYTE PTR _pTeleportResult$8[ebp+1]
  000ff	50		 push	 eax
  00100	8d 4d f8	 lea	 ecx, DWORD PTR _pTeleportResult$8[ebp]
  00103	51		 push	 ecx
  00104	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00107	52		 push	 edx
  00108	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15845: 		
; 15846: 		return;

  00110	e9 61 03 00 00	 jmp	 $LN1@CGTeleport
$LN2@CGTeleport:

; 15847: 	}
; 15848: #endif // MODIFY_DONT_TELEPORT_EVNET_ENDING_IN_EVENTMAP_20081118
; 15849: 
; 15850: 	//LogAdd("   Recv %s %d", gObj[aIndex].Name, lpMsg->MoveNumber);
; 15851: 	if( lpMsg->MoveNumber == 0 )	//  

  00115	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00118	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0011c	85 c9		 test	 ecx, ecx
  0011e	0f 85 93 02 00
	00		 jne	 $LN3@CGTeleport

; 15852: 	{
; 15853: 		CMagicInf *lpMagic;
; 15854: 		BYTE x, y;
; 15855: 		
; 15856: 		PMSG_MAGICATTACK_RESULT	pAttack;
; 15857: 		
; 15858: 		PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof( pAttack));

  00124	6a 08		 push	 8
  00126	6a 19		 push	 25			; 00000019H
  00128	8d 45 e8	 lea	 eax, DWORD PTR _pAttack$4[ebp]
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15859: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD 
; 15860: 		pAttack.MagicNumberH   = HIBYTE( AT_SKILL_TELEPORT );
; 15861: 		pAttack.MagicNumberL   = LOBYTE( AT_SKILL_TELEPORT );
; 15862: #else
; 15863: 		pAttack.MagicNumber   = AT_SKILL_TELEPORT;

  00134	c6 45 eb 06	 mov	 BYTE PTR _pAttack$4[ebp+3], 6

; 15864: #endif
; 15865: 		pAttack.SourceNumberH = HIBYTE(aIndex);

  00138	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0013b	c1 e8 08	 shr	 eax, 8
  0013e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00143	88 45 ec	 mov	 BYTE PTR _pAttack$4[ebp+4], al

; 15866: 		pAttack.SourceNumberL = LOBYTE(aIndex);	

  00146	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00149	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0014e	88 45 ed	 mov	 BYTE PTR _pAttack$4[ebp+5], al

; 15867: 		pAttack.TargetNumberH = HIBYTE(aIndex);

  00151	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00154	c1 e8 08	 shr	 eax, 8
  00157	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0015c	88 45 ee	 mov	 BYTE PTR _pAttack$4[ebp+6], al

; 15868: 		pAttack.TargetNumberL = LOBYTE(aIndex);	

  0015f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00162	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00167	88 45 ef	 mov	 BYTE PTR _pAttack$4[ebp+7], al

; 15869: 
; 15870: 		lpMagic  = gObjGetMagicSearch(&gObj[aIndex], AT_SKILL_TELEPORT);

  0016a	6a 06		 push	 6
  0016c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00173	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  0017f	83 c4 08	 add	 esp, 8
  00182	89 45 f4	 mov	 DWORD PTR _lpMagic$7[ebp], eax

; 15871: 
; 15872: 		x = lpMsg->MapX;

  00185	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00188	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0018b	88 4d f3	 mov	 BYTE PTR _x$6[ebp], cl

; 15873: 		y = lpMsg->MapY;

  0018e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00191	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  00194	88 4d f2	 mov	 BYTE PTR _y$5[ebp], cl

; 15874: 
; 15875: #ifndef WORLD_TOURNAMENT_EVENT_SETTING
; 15876: 		if( !gObjCheckTeleportArea(aIndex, x, y) )

  00197	0f b6 45 f2	 movzx	 eax, BYTE PTR _y$5[ebp]
  0019b	50		 push	 eax
  0019c	0f b6 4d f3	 movzx	 ecx, BYTE PTR _x$6[ebp]
  001a0	51		 push	 ecx
  001a1	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ad	85 c0		 test	 eax, eax
  001af	0f 85 c2 00 00
	00		 jne	 $LN5@CGTeleport

; 15877: 		{
; 15878: 			LogAddC(LOGC_RED, "[%s][%s] Try Teleport Not Move Area [%d,%d]", 

  001b5	0f b6 45 f2	 movzx	 eax, BYTE PTR _y$5[ebp]
  001b9	50		 push	 eax
  001ba	0f b6 4d f3	 movzx	 ecx, BYTE PTR _x$6[ebp]
  001be	51		 push	 ecx
  001bf	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  001c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cb	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  001cf	51		 push	 ecx
  001d0	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  001d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001dc	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  001e0	51		 push	 ecx
  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5@
  001e6	6a 02		 push	 2
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001ee	83 c4 18	 add	 esp, 24			; 00000018H

; 15879: 				   gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);
; 15880: 
; 15881: #ifdef AUTH_GAMESERVER_CHECKKEY
; 15882: 			if( szAuthKey[5] != AUTH_CHECK_05 )
; 15883: 				DestroyGIocp();
; 15884: #endif
; 15885: 			//  ..   
; 15886: 			PMSG_TELEPORT_RESULT		pTeleportResult;
; 15887: 			pTeleportResult.h.c			= PMHCE_BYTE;

  001f1	c6 45 e0 c3	 mov	 BYTE PTR _pTeleportResult$3[ebp], 195 ; 000000c3H

; 15888: 			pTeleportResult.h.size		= sizeof( pTeleportResult );

  001f5	c6 45 e1 08	 mov	 BYTE PTR _pTeleportResult$3[ebp+1], 8

; 15889: 			pTeleportResult.h.headcode	= 0x1C;

  001f9	c6 45 e2 1c	 mov	 BYTE PTR _pTeleportResult$3[ebp+2], 28 ; 0000001cH

; 15890: 			pTeleportResult.MoveNumber	= 0;

  001fd	c6 45 e3 00	 mov	 BYTE PTR _pTeleportResult$3[ebp+3], 0

; 15891: 			pTeleportResult.MapNumber	= gObj[aIndex].MapNumber;

  00201	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0020e	8a 94 01 09 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+265]
  00215	88 55 e4	 mov	 BYTE PTR _pTeleportResult$3[ebp+4], dl

; 15892: 			pTeleportResult.MapX		= gObj[aIndex].X;

  00218	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0021f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00225	8a 94 01 04 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+260]
  0022c	88 55 e5	 mov	 BYTE PTR _pTeleportResult$3[ebp+5], dl

; 15893: 			pTeleportResult.MapY		= gObj[aIndex].Y;

  0022f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023c	8a 94 01 06 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+262]
  00243	88 55 e6	 mov	 BYTE PTR _pTeleportResult$3[ebp+6], dl

; 15894: 			pTeleportResult.Dir			= gObj[aIndex].Dir;			

  00246	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0024d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00253	8a 94 01 08 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+264]
  0025a	88 55 e7	 mov	 BYTE PTR _pTeleportResult$3[ebp+7], dl

; 15895: 
; 15896: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);	

  0025d	0f b6 45 e1	 movzx	 eax, BYTE PTR _pTeleportResult$3[ebp+1]
  00261	50		 push	 eax
  00262	8d 4d e0	 lea	 ecx, DWORD PTR _pTeleportResult$3[ebp]
  00265	51		 push	 ecx
  00266	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00269	52		 push	 edx
  0026a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0026f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15897: 			return;

  00272	e9 ff 01 00 00	 jmp	 $LN1@CGTeleport
$LN5@CGTeleport:

; 15898: 		}
; 15899: #endif
; 15900: 
; 15901: #ifdef CASTLE_MAIN_SCHEDULER_20041111		//       .
; 15902: 		if (gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE) {
; 15903: 			if (g_CastleSiege.CheckTeleportMagicAxisY(gObj[aIndex].Y, x, y) == FALSE) {
; 15904: 				y						= gObj[aIndex].Y;
; 15905: 			}
; 15906: 		}
; 15907: #endif
; 15908: 
; 15909: 		if( lpMagic != NULL )

  00277	83 7d f4 00	 cmp	 DWORD PTR _lpMagic$7[ebp], 0
  0027b	0f 84 31 01 00
	00		 je	 $LN8@CGTeleport

; 15910: 		{
; 15911: 			//  . (  ... )
; 15912: 			int usemana;
; 15913: 			usemana = gObjMagicManaUse(&gObj[aIndex], lpMagic);

  00281	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$7[ebp]
  00284	50		 push	 eax
  00285	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0028c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00292	51		 push	 ecx
  00293	e8 00 00 00 00	 call	 ?gObjMagicManaUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
  00298	83 c4 08	 add	 esp, 8
  0029b	89 45 dc	 mov	 DWORD PTR _usemana$2[ebp], eax

; 15914: 			if( usemana >= 0 )

  0029e	83 7d dc 00	 cmp	 DWORD PTR _usemana$2[ebp], 0
  002a2	0f 8c 0a 01 00
	00		 jl	 $LN8@CGTeleport

; 15915: 			{
; 15916: #ifdef NEW_FORSKYLAND2
; 15917: 				int usebp = gObjMagicBPUse(&gObj[aIndex], lpMagic);

  002a8	8b 45 f4	 mov	 eax, DWORD PTR _lpMagic$7[ebp]
  002ab	50		 push	 eax
  002ac	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002b3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b9	51		 push	 ecx
  002ba	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  002bf	83 c4 08	 add	 esp, 8
  002c2	89 45 d8	 mov	 DWORD PTR _usebp$1[ebp], eax

; 15918: 				if( usebp >= 0 )

  002c5	83 7d d8 00	 cmp	 DWORD PTR _usebp$1[ebp], 0
  002c9	0f 8c e3 00 00
	00		 jl	 $LN8@CGTeleport

; 15919: 				{		
; 15920: #endif
; 15921: 					if( gObj[aIndex].Type == OBJTYPE_CHARACTER )

  002cf	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002dc	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  002e1	83 fa 01	 cmp	 edx, 1
  002e4	75 15		 jne	 SHORT $LN9@CGTeleport

; 15922: 						DataSend(aIndex, (LPBYTE)&pAttack, pAttack.h.size);

  002e6	0f b6 45 e9	 movzx	 eax, BYTE PTR _pAttack$4[ebp+1]
  002ea	50		 push	 eax
  002eb	8d 4d e8	 lea	 ecx, DWORD PTR _pAttack$4[ebp]
  002ee	51		 push	 ecx
  002ef	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002f2	52		 push	 edx
  002f3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002f8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGTeleport:

; 15923: 
; 15924: 					MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  002fb	0f b6 45 e9	 movzx	 eax, BYTE PTR _pAttack$4[ebp+1]
  002ff	50		 push	 eax
  00300	8d 4d e8	 lea	 ecx, DWORD PTR _pAttack$4[ebp]
  00303	51		 push	 ecx
  00304	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0030b	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00311	52		 push	 edx
  00312	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00317	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15925: 					gObjTeleportMagicUse(aIndex, x, y);

  0031a	0f b6 45 f2	 movzx	 eax, BYTE PTR _y$5[ebp]
  0031e	50		 push	 eax
  0031f	0f b6 4d f3	 movzx	 ecx, BYTE PTR _x$6[ebp]
  00323	51		 push	 ecx
  00324	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00327	52		 push	 edx
  00328	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15926: 					gObj[aIndex].Mana = (float)usemana;

  00330	f3 0f 2a 45 dc	 cvtsi2ss xmm0, DWORD PTR _usemana$2[ebp]
  00335	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0033c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00342	f3 0f 11 84 01
	d0 00 00 00	 movss	 DWORD PTR [ecx+eax+208], xmm0

; 15927: #ifdef NEW_FORSKYLAND2
; 15928: 					gObj[aIndex].BP = usebp;

  0034b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00352	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00358	8b 55 d8	 mov	 edx, DWORD PTR _usebp$1[ebp]
  0035b	89 94 01 e8 00
	00 00		 mov	 DWORD PTR [ecx+eax+232], edx

; 15929: 					GCManaSend(gObj[aIndex].m_Index, (short)gObj[aIndex].Mana, 0xFF, 0, gObj[aIndex].BP);

  00362	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00369	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0036f	0f b7 94 01 e8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+232]
  00377	52		 push	 edx
  00378	6a 00		 push	 0
  0037a	68 ff 00 00 00	 push	 255			; 000000ffH
  0037f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00386	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0038c	f3 0f 2c 94 01
	d0 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+208]
  00395	0f b7 c2	 movzx	 eax, dx
  00398	50		 push	 eax
  00399	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a6	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  003a9	50		 push	 eax
  003aa	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  003af	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@CGTeleport:

; 15930: 				}
; 15931: #else
; 15932: 					GCManaSend(gObj[aIndex].m_Index, (short)gObj[aIndex].Mana, 0xFF, 0, 0);
; 15933: #endif
; 15934: 			}
; 15935: 		}
; 15936: 	}

  003b2	e9 bf 00 00 00	 jmp	 $LN11@CGTeleport
$LN3@CGTeleport:

; 15937: 	else 
; 15938: 	{
; 15939: 		if( gGateC.IsInGate(aIndex, lpMsg->MoveNumber) ) 

  003b7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003ba	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  003be	51		 push	 ecx
  003bf	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  003c2	52		 push	 edx
  003c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  003c8	e8 00 00 00 00	 call	 ?IsInGate@CGate@@QAEHHH@Z ; CGate::IsInGate
  003cd	85 c0		 test	 eax, eax
  003cf	74 19		 je	 SHORT $LN10@CGTeleport

; 15940: 			gObjMoveGate(aIndex, lpMsg->MoveNumber);

  003d1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003d4	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  003d8	51		 push	 ecx
  003d9	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  003dc	52		 push	 edx
  003dd	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  003e2	83 c4 08	 add	 esp, 8
  003e5	e9 8c 00 00 00	 jmp	 $LN11@CGTeleport
$LN10@CGTeleport:

; 15941: 		else
; 15942: 		{
; 15943: 			gObjClearViewport(&gObj[aIndex]);

  003ea	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003f1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f7	50		 push	 eax
  003f8	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  003fd	83 c4 04	 add	 esp, 4

; 15944: 			GCTeleportSend(&gObj[aIndex], lpMsg->MoveNumber, gObj[aIndex].MapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00400	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00407	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0040d	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  00415	52		 push	 edx
  00416	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0041d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00423	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  0042b	52		 push	 edx
  0042c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00433	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00439	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00441	52		 push	 edx
  00442	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00449	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0044f	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00457	52		 push	 edx
  00458	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0045b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0045f	51		 push	 ecx
  00460	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00467	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0046d	52		 push	 edx
  0046e	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00473	83 c4 18	 add	 esp, 24			; 00000018H
$LN11@CGTeleport:
$LN1@CGTeleport:

; 15945: 
; 15946: #ifdef CASTLE_MAIN_SCHEDULER_20041111		//        
; 15947: 			if (gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 15948: 				g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE
; 15949: 				)
; 15950: 			{
; 15951: 				g_CastleSiege.NotifySelfCsJoinSide (aIndex);
; 15952: 				g_CastleSiege.NotifyCsSelfLeftTime (aIndex);
; 15953: 			}
; 15954: #endif
; 15955: 		}
; 15956: 	}
; 15957: }

  00476	5f		 pop	 edi
  00477	5e		 pop	 esi
  00478	5b		 pop	 ebx
  00479	8b e5		 mov	 esp, ebp
  0047b	5d		 pop	 ebp
  0047c	c3		 ret	 0
?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z ENDP		; CGTeleportRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z
_TEXT	SEGMENT
tv86 = -84						; size = 4
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z PROC	; CGLevelUpPointAdd, COMDAT

; 3834 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3835 : 	//    .
; 3836 : 	if( gObjIsConnected(aIndex) == FALSE )

  00013	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	75 11		 jne	 SHORT $LN4@CGLevelUpP

; 3837 : 	{
; 3838 : 		CloseClient ( aIndex );

  00023	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0002c	83 c4 04	 add	 esp, 4

; 3839 : 		return;

  0002f	e9 22 01 00 00	 jmp	 $LN1@CGLevelUpP
$LN4@CGLevelUpP:

; 3840 : 	}
; 3841 : 
; 3842 : 	PMSG_LVPOINTADDRESULT	pMsg;
; 3843 : 		
; 3844 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x06, sizeof( pMsg ) );

  00034	6a 0a		 push	 10			; 0000000aH
  00036	6a 06		 push	 6
  00038	68 f3 00 00 00	 push	 243			; 000000f3H
  0003d	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00046	83 c4 10	 add	 esp, 16			; 00000010H

; 3845 : 
; 3846 : 	pMsg.ResultType	= 0;

  00049	c6 45 f4 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 3847 : 	if( gObjLevelUpPointAdd(lpMsg->Type, &gObj[aIndex])==TRUE)

  0004d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00054	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005a	50		 push	 eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0005e	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ?gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z ; gObjLevelUpPointAdd
  00068	83 c4 08	 add	 esp, 8
  0006b	83 f8 01	 cmp	 eax, 1
  0006e	0f 85 cd 00 00
	00		 jne	 $LN5@CGLevelUpP

; 3848 : 	{
; 3849 : 		pMsg.ResultType	= (0x01<<4);

  00074	c6 45 f4 10	 mov	 BYTE PTR _pMsg$[ebp+4], 16 ; 00000010H

; 3850 : 		pMsg.ResultType += lpMsg->Type;

  00078	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0007b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0007f	0f b6 55 f4	 movzx	 edx, BYTE PTR _pMsg$[ebp+4]
  00083	03 d1		 add	 edx, ecx
  00085	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+4], dl

; 3851 : 		switch( lpMsg->Type )

  00088	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008b	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0008e	88 4d ac	 mov	 BYTE PTR tv86[ebp], cl
  00091	80 7d ac 02	 cmp	 BYTE PTR tv86[ebp], 2
  00095	74 08		 je	 SHORT $LN6@CGLevelUpP
  00097	80 7d ac 03	 cmp	 BYTE PTR tv86[ebp], 3
  0009b	74 38		 je	 SHORT $LN7@CGLevelUpP
  0009d	eb 6a		 jmp	 SHORT $LN2@CGLevelUpP
$LN6@CGLevelUpP:

; 3852 : 		{
; 3853 : 		case 2 : //  
; 3854 : 			pMsg.MaxLifeAndMana = (WORD)(gObj[aIndex].MaxLife+gObj[aIndex].AddLife);

  0009f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a6	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b3	f3 0f 2a 84 0a
	0c 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+268]
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c2	f3 0f 58 84 01
	c0 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+192]
  000cb	f3 0f 2c d0	 cvttss2si edx, xmm0
  000cf	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx

; 3855 : 			break;

  000d3	eb 34		 jmp	 SHORT $LN2@CGLevelUpP
$LN7@CGLevelUpP:

; 3856 : 		case 3 : // 
; 3857 : #ifdef MODIFY_SHIELD_MANA_CHANGEMAXVALUE_20060526
; 3858 : 			pMsg.MaxLifeAndMana = (WORD)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana);

  000d5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000dc	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e9	f3 0f 2a 84 0a
	10 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+272]
  000f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f8	f3 0f 58 84 01
	d4 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+212]
  00101	f3 0f 2c d0	 cvttss2si edx, xmm0
  00105	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx
$LN2@CGLevelUpP:

; 3859 : #else
; 3860 : 			pMsg.MaxLifeAndMana = (WORD)(gObj[aIndex].MaxMana);
; 3861 : #endif // MODIFY_SHIELD_MANA_CHANGEMAXVALUE_20060526
; 3862 : 			break;
; 3863 : 		}
; 3864 : 
; 3865 : #ifdef AUTH_GAMESERVER_CHECKKEY
; 3866 : 	if( szAuthKey[9] != AUTH_CHECK_09 )
; 3867 : 		DestroyGIocp();
; 3868 : #endif
; 3869 : 
; 3870 : #ifdef ADD_SHIELD_POINT_01_20060403
; 3871 : 	pMsg.wMaxShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 3872 : #endif
; 3873 : 
; 3874 : #ifdef NEW_FORSKYLAND2
; 3875 : 		gObjSetBP(aIndex);

  00109	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  00112	83 c4 04	 add	 esp, 4

; 3876 : 		pMsg.MaxBP = gObj[aIndex].MaxBP+gObj[aIndex].AddBP;

  00115	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0011c	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00123	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00129	8b 84 02 ec 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+236]
  00130	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00136	03 84 0a f0 00
	00 00		 add	 eax, DWORD PTR [edx+ecx+240]
  0013d	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+8], ax
$LN5@CGLevelUpP:

; 3877 : #endif
; 3878 : 	}
; 3879 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00141	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00145	50		 push	 eax
  00146	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00149	51		 push	 ecx
  0014a	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0014d	52		 push	 edx
  0014e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGLevelUpP:

; 3880 : }

  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx
  00159	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015c	33 cd		 xor	 ecx, ebp
  0015e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z ENDP	; CGLevelUpPointAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_pResult$ = -12						; size = 8
_lpObj$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z PROC ; CGModifyRequestItem, COMDAT

; 8696 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8697 : 	LPOBJECTSTRUCT lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00009	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 8698 : 	PMSG_ITEMDURREPAIR_RESULT pResult;
; 8699 : 	
; 8700 : 	PHeadSetB((LPBYTE)&pResult, 0x34, sizeof( pResult));	

  00019	6a 08		 push	 8
  0001b	6a 34		 push	 52			; 00000034H
  0001d	8d 45 f4	 lea	 eax, DWORD PTR _pResult$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8701 : 
; 8702 : 	pResult.Money = 0;

  00029	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0

; 8703 : 
; 8704 : 	// ..
; 8705 : 	if( gObj[aIndex].CloseType != -1 )

  00030	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003d	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  00042	83 fa ff	 cmp	 edx, -1
  00045	74 1a		 je	 SHORT $LN5@CGModifyRe

; 8706 : 	{
; 8707 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00047	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0004b	50		 push	 eax
  0004c	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8708 : 		return;

  0005c	e9 b4 02 00 00	 jmp	 $LN1@CGModifyRe
$LN5@CGModifyRe:

; 8709 : 	}
; 8710 : 	/*//       
; 8711 : 	if( lpObj->m_IfState.use > 0 )
; 8712 : 	{
; 8713 : 		if( lpObj->m_IfState.type != I_SHOP )
; 8714 : 		{
; 8715 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 8716 : 			return;
; 8717 : 		}		
; 8718 : 	}*/
; 8719 : 	if( PacketCheckTime(lpObj) == FALSE ) {

  00061	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  0006a	83 c4 04	 add	 esp, 4
  0006d	85 c0		 test	 eax, eax
  0006f	75 1a		 jne	 SHORT $LN6@CGModifyRe

; 8720 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00071	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00075	50		 push	 eax
  00076	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8721 : 		return;

  00086	e9 8a 02 00 00	 jmp	 $LN1@CGModifyRe
$LN6@CGModifyRe:

; 8722 : 	}
; 8723 : 
; 8724 : 	if( lpMsg->Requestpos == 1 && gObj[aIndex].Level < 50 )

  0008b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008e	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00092	83 f9 01	 cmp	 ecx, 1
  00095	75 3b		 jne	 SHORT $LN7@CGModifyRe
  00097	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a4	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  000ac	83 fa 32	 cmp	 edx, 50			; 00000032H
  000af	7d 21		 jge	 SHORT $LN7@CGModifyRe

; 8725 : 	{	//     50  
; 8726 : 		//LogAdd("[%s][%s]  50  ", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 8727 : 		pResult.Money = 0;

  000b1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0

; 8728 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000b8	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000bc	50		 push	 eax
  000bd	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000c0	51		 push	 ecx
  000c1	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8729 : 		return;

  000cd	e9 43 02 00 00	 jmp	 $LN1@CGModifyRe
$LN7@CGModifyRe:

; 8730 : 	}
; 8731 : 	
; 8732 : 	if( lpMsg->Position == 255 )

  000d2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000d5	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000d9	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  000df	0f 85 1b 01 00
	00		 jne	 $LN8@CGModifyRe

; 8733 : 	{	//   
; 8734 : 		for( int n=0; n<MAX_INVENTORY; n++)

  000e5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  000ec	eb 09		 jmp	 SHORT $LN4@CGModifyRe
$LN2@CGModifyRe:
  000ee	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  000f1	83 c0 01	 add	 eax, 1
  000f4	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@CGModifyRe:
  000f7	83 7d f0 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  000fb	0f 8d ec 00 00
	00		 jge	 $LN3@CGModifyRe

; 8735 : 		{
; 8736 : 			if( lpObj->pInventory[n].IsItem() )

  00101	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00108	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010b	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00111	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00116	85 c0		 test	 eax, eax
  00118	0f 84 ca 00 00
	00		 je	 $LN10@CGModifyRe

; 8737 : 			{
; 8738 : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 8739 : 				//     
; 8740 : 				if( IsCashItem( lpObj->pInventory[n].m_Type ) == TRUE )
; 8741 : 				{
; 8742 : 					continue;
; 8743 : 				}
; 8744 : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 8745 : #ifdef PREMIUMITEM_20090106
; 8746 : 				//     
; 8747 : 				if(	IsPremiumItem( lpObj->pInventory[n].m_Type ) == TRUE )
; 8748 : 				{
; 8749 : 					continue;
; 8750 : 				}
; 8751 : #endif // PREMIUMITEM_20090106
; 8752 : #ifndef FOR_KOREA
; 8753 : 	#ifdef ADD_PREMIUMITEM_PANDA
; 8754 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM( 13, 76)	// 
; 8755 : 					|| lpObj->pInventory[n].m_Type == MAKE_ITEMNUM( 13, 80)	// 
; 8756 : 					)
; 8757 : 				{	//     .
; 8758 : 					continue;
; 8759 : 				}
; 8760 : 	#endif // ADD_PREMIUMITEM_PANDA
; 8761 : #endif // NOT_FOR_KOREA
; 8762 : #ifdef RING_EVENT_ITEMBOX_20031124			//  -   (  )
; 8763 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,20) &&

  0011e	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00125	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00128	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0012e	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00133	6a 14		 push	 20			; 00000014H
  00135	6a 0d		 push	 13			; 0000000dH
  00137	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013c	83 c4 08	 add	 esp, 8
  0013f	3b f0		 cmp	 esi, eax
  00141	75 38		 jne	 SHORT $LN11@CGModifyRe
  00143	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  0014a	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0014d	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00153	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00158	85 c0		 test	 eax, eax
  0015a	74 1a		 je	 SHORT $LN12@CGModifyRe
  0015c	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00163	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00166	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0016c	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00171	83 f8 01	 cmp	 eax, 1
  00174	75 05		 jne	 SHORT $LN11@CGModifyRe
$LN12@CGModifyRe:

; 8764 : 					(lpObj->pInventory[n].m_Level == 0	||	//  
; 8765 : 					 lpObj->pInventory[n].m_Level == 1		//  
; 8766 : 					))
; 8767 : 				{	//     .
; 8768 : 					continue;

  00176	e9 73 ff ff ff	 jmp	 $LN2@CGModifyRe
$LN11@CGModifyRe:

; 8769 : 				}
; 8770 : #endif
; 8771 : #ifdef FRIENDSHIP_EVENT_RING_BOX_20040211	//    -      
; 8772 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,20) &&

  0017b	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00182	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00185	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0018b	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00190	6a 14		 push	 20			; 00000014H
  00192	6a 0d		 push	 13			; 0000000dH
  00194	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00199	83 c4 08	 add	 esp, 8
  0019c	3b f0		 cmp	 esi, eax
  0019e	75 1f		 jne	 SHORT $LN13@CGModifyRe
  001a0	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  001a7	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001aa	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001b0	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  001b5	83 f8 02	 cmp	 eax, 2
  001b8	75 05		 jne	 SHORT $LN13@CGModifyRe

; 8773 : 					lpObj->pInventory[n].m_Level == 2		//  
; 8774 : 					)
; 8775 : 				{	//     .
; 8776 : 					continue;

  001ba	e9 2f ff ff ff	 jmp	 $LN2@CGModifyRe
$LN13@CGModifyRe:

; 8777 : 				}
; 8778 : #endif
; 8779 : #ifdef MU_CHN_THANKS_RING_EVENT_20040908	//   -   
; 8780 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,20) &&
; 8781 : 					lpObj->pInventory[n].m_Level == 3		//  
; 8782 : 					)
; 8783 : 				{	//     .
; 8784 : 					continue;
; 8785 : 				}
; 8786 : #endif
; 8787 : #ifdef DARKLORD_WORK
; 8788 : #ifndef UPDATE_DARKROAD_PET_ITEMREPAIR_20090109	
; 8789 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,4) || lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,5) )
; 8790 : 				{	// ,     
; 8791 : 					continue;
; 8792 : 				}
; 8793 : #endif	// UPDATE_DARKROAD_PET_ITEMREPAIR_20090109
; 8794 : #endif
; 8795 : #ifdef MODIFY_FENRIR_ZEN_REPAIR_20060124
; 8796 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,37) )
; 8797 : 				{
; 8798 : 					//    
; 8799 : 					continue;
; 8800 : 				}
; 8801 : #endif
; 8802 : #ifdef KANTURU_MOONSTONEPENDANT_20060804	
; 8803 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM( 13,38 ) )
; 8804 : 				{	//    
; 8805 : 					continue;
; 8806 : 				}
; 8807 : #endif
; 8808 : #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 8809 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 8810 : 				{
; 8811 : 					continue;
; 8812 : 				}
; 8813 : #endif
; 8814 : #ifdef HIDDEN_TREASUREBOX_EVENT_20050804	//       
; 8815 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(12,26) &&
; 8816 : 					(lpObj->pInventory[n].m_Level == 1 ||	// 
; 8817 : 					lpObj->pInventory[n].m_Level == 2 ||	// 
; 8818 : 					lpObj->pInventory[n].m_Level == 3 ||	// 
; 8819 : 					lpObj->pInventory[n].m_Level == 4 ||	//  
; 8820 : 					lpObj->pInventory[n].m_Level == 5		//  ( )
; 8821 : 					))
; 8822 : 				{
; 8823 : 					continue;
; 8824 : 				}
; 8825 : #endif
; 8826 : 
; 8827 : #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 8828 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM( 13, 40 ) )	//      
; 8829 : 				{
; 8830 : 					continue;
; 8831 : 				}
; 8832 : #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 8833 : 
; 8834 : 
; 8835 : #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 8836 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM( 13, 41 ) ) //    
; 8837 : 				{
; 8838 : 					continue;
; 8839 : 				}
; 8840 : #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 8841 : 
; 8842 : #ifdef UPDATE_GM_FUNCTION_20070228
; 8843 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM( 13, 42 ) ) // GM   
; 8844 : 				{
; 8845 : 					continue;
; 8846 : 				}
; 8847 : #endif 
; 8848 : 
; 8849 : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_1_20070723	//   
; 8850 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13, 51) )
; 8851 : 				{
; 8852 : 					//    
; 8853 : 					continue;
; 8854 : 				}
; 8855 : #endif
; 8856 : 
; 8857 : //------------->
; 8858 : //20080930  5  ,   (grooving)
; 8859 : #ifdef ADD_TELEPORT_CHARM_ITEM_20080930
; 8860 : 				if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM(13, 70) )
; 8861 : 				{
; 8862 : 					//    
; 8863 : 					continue;
; 8864 : 				}
; 8865 : #endif
; 8866 : //<-------------
; 8867 : 
; 8868 : #ifdef MODIFY_SANTACLAUSVILLAGE_INVITATION
; 8869 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13, 66) )
; 8870 : 				{
; 8871 : 					//     
; 8872 : 					continue;
; 8873 : 				}
; 8874 : #endif // MODIFY_SANTACLAUSVILLAGE_INVITATION
; 8875 : 
; 8876 : #ifdef MODIFY_XMASEVENTITEM_REPAIR
; 8877 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13, 67) || lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13, 68) )
; 8878 : 				{
; 8879 : 					// ,    
; 8880 : 					continue;
; 8881 : 				}
; 8882 : #endif // MODIFY_XMASEVENTITEM_REPAIR
; 8883 : 				
; 8884 : #ifdef ADD_UNICORN_PET_20090915
; 8885 : 				if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13, 106)
; 8886 : 					)
; 8887 : 				{
; 8888 : 					//    
; 8889 : 					continue;
; 8890 : 				}
; 8891 : #endif // ADD_UNICORN_PET_20090915
; 8892 : 				
; 8893 : 				ItemDurRepaire(lpObj, &lpObj->pInventory[n], n, lpMsg->Requestpos);				

  001bf	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001c2	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001c6	51		 push	 ecx
  001c7	8b 55 f0	 mov	 edx, DWORD PTR _n$1[ebp]
  001ca	52		 push	 edx
  001cb	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  001d2	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d5	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  001db	50		 push	 eax
  001dc	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001df	52		 push	 edx
  001e0	e8 00 00 00 00	 call	 ?ItemDurRepaire@@YAXPAVOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire
  001e5	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@CGModifyRe:

; 8894 : 			}
; 8895 : 		}

  001e8	e9 01 ff ff ff	 jmp	 $LN2@CGModifyRe
$LN3@CGModifyRe:

; 8896 : 		gObjCalCharacter(lpObj->m_Index);

  001ed	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f2	51		 push	 ecx
  001f3	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  001f8	83 c4 04	 add	 esp, 4

; 8897 : 	}

  001fb	e9 15 01 00 00	 jmp	 $LN1@CGModifyRe
$LN8@CGModifyRe:

; 8898 : 	else if( lpMsg->Position > MAX_INVENTORY-1 ) 

  00200	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00203	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00207	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  0020a	7e 0c		 jle	 SHORT $LN14@CGModifyRe

; 8899 : 	{		
; 8900 : 		pResult.Money = 0;

  0020c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0

; 8901 : 	}

  00213	e9 fd 00 00 00	 jmp	 $LN1@CGModifyRe
$LN14@CGModifyRe:

; 8902 : 	else 
; 8903 : 	{
; 8904 : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 8905 : 		if( IsCashItem( lpObj->pInventory[lpMsg->Position].m_Type ) == TRUE )
; 8906 : 		{
; 8907 : 			return;
; 8908 : 		}
; 8909 : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 8910 : #ifdef PREMIUMITEM_20090106
; 8911 : 		//     
; 8912 : 		if(	IsPremiumItem( lpObj->pInventory[lpMsg->Position].m_Type ) == TRUE )
; 8913 : 		{
; 8914 : 			return;
; 8915 : 		}
; 8916 : #endif // PREMIUMITEM_20090106
; 8917 : #ifndef FOR_KOREA
; 8918 : 	#ifdef ADD_PREMIUMITEM_PANDA
; 8919 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM( 13, 76)		// 
; 8920 : 			|| lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM( 13, 80)	// 
; 8921 : 			)
; 8922 : 		{	//     .
; 8923 : 			return;
; 8924 : 		}
; 8925 : 	#endif // ADD_PREMIUMITEM_PANDA
; 8926 : #endif // NOT_FOR_KOREA
; 8927 : #ifdef RING_EVENT_ITEMBOX_20031124			//  -  
; 8928 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM(13,20) &&

  00218	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0021b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0021f	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00225	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00228	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0022e	0f bf 74 11 06	 movsx	 esi, WORD PTR [ecx+edx+6]
  00233	6a 14		 push	 20			; 00000014H
  00235	6a 0d		 push	 13			; 0000000dH
  00237	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0023c	83 c4 08	 add	 esp, 8
  0023f	3b f0		 cmp	 esi, eax
  00241	75 44		 jne	 SHORT $LN16@CGModifyRe
  00243	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00246	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0024a	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00250	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00253	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00259	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  0025e	85 d2		 test	 edx, edx
  00260	74 20		 je	 SHORT $LN17@CGModifyRe
  00262	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00265	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00269	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0026f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00272	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00278	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  0027d	83 fa 01	 cmp	 edx, 1
  00280	75 05		 jne	 SHORT $LN16@CGModifyRe
$LN17@CGModifyRe:

; 8929 : 			(lpObj->pInventory[lpMsg->Position].m_Level == 0	||	//  
; 8930 : 			 lpObj->pInventory[lpMsg->Position].m_Level == 1		//  
; 8931 : 			))
; 8932 : 		{	//     .
; 8933 : 			return;

  00282	e9 8e 00 00 00	 jmp	 $LN1@CGModifyRe
$LN16@CGModifyRe:

; 8934 : 		}
; 8935 : #endif
; 8936 : #ifdef FRIENDSHIP_EVENT_RING_BOX_20040211	//    -      
; 8937 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM(13,20) &&

  00287	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0028a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0028e	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00294	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00297	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0029d	0f bf 74 11 06	 movsx	 esi, WORD PTR [ecx+edx+6]
  002a2	6a 14		 push	 20			; 00000014H
  002a4	6a 0d		 push	 13			; 0000000dH
  002a6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002ab	83 c4 08	 add	 esp, 8
  002ae	3b f0		 cmp	 esi, eax
  002b0	75 22		 jne	 SHORT $LN18@CGModifyRe
  002b2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002b5	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  002b9	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  002bf	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c2	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  002c8	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  002cd	83 fa 02	 cmp	 edx, 2
  002d0	75 02		 jne	 SHORT $LN18@CGModifyRe

; 8938 : 			lpObj->pInventory[lpMsg->Position].m_Level == 2			//  
; 8939 : 			)
; 8940 : 		{	//     .
; 8941 : 			return;

  002d2	eb 41		 jmp	 SHORT $LN1@CGModifyRe
$LN18@CGModifyRe:

; 8942 : 		}
; 8943 : #endif
; 8944 : #ifdef MU_CHN_THANKS_RING_EVENT_20040908	//   -   
; 8945 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM(13,20) &&
; 8946 : 			lpObj->pInventory[lpMsg->Position].m_Level == 2			//  
; 8947 : 			)
; 8948 : 		{	//     .
; 8949 : 			return;
; 8950 : 		}
; 8951 : #endif
; 8952 : #ifdef MODIFY_FENRIR_ZEN_REPAIR_20060124
; 8953 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM(13,37) )
; 8954 : 		{	//    .
; 8955 : 			return;
; 8956 : 		}
; 8957 : #endif
; 8958 : #ifdef KANTURU_MOONSTONEPENDANT_20060804	
; 8959 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM( 13,38 ) )
; 8960 : 		{	//    .
; 8961 : 			return;
; 8962 : 		}
; 8963 : #endif		
; 8964 : 		
; 8965 : #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 8966 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 8967 : 		{
; 8968 : 			//      
; 8969 : 			return;
; 8970 : 		}
; 8971 : #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 8972 : 
; 8973 : 
; 8974 : #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 8975 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 8976 : 		{
; 8977 : 			//    
; 8978 : 			return;
; 8979 : 		}
; 8980 : #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 8981 : 
; 8982 : #ifdef UPDATE_GM_FUNCTION_20070228
; 8983 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM( 13, 42 ) ) 
; 8984 : 		{
; 8985 : 			// GM   
; 8986 : 			return;
; 8987 : 		}
; 8988 : #endif 
; 8989 : 
; 8990 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//   
; 8991 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM(13, 51) )
; 8992 : 		{
; 8993 : 			//    
; 8994 : 			return;
; 8995 : 		}
; 8996 : #endif
; 8997 : //------------->
; 8998 : //20080930  5  ,   (grooving)
; 8999 : #ifdef ADD_TELEPORT_CHARM_ITEM_20080930
; 9000 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM(13, 70) )
; 9001 : 		{
; 9002 : 			//    
; 9003 : 			return;
; 9004 : 		}
; 9005 : #endif
; 9006 : //<-------------
; 9007 : #ifdef MODIFY_SANTACLAUSVILLAGE_INVITATION
; 9008 : 		if( lpObj->pInventory[lpMsg->Position].m_Type == MAKE_ITEMNUM(13, 66) )
; 9009 : 		{
; 9010 : 			//     
; 9011 : 			return;
; 9012 : 		}
; 9013 : #endif // MODIFY_SANTACLAUSVILLAGE_INVITATION
; 9014 : 
; 9015 : 		ItemDurRepaire(lpObj, &lpObj->pInventory[lpMsg->Position], lpMsg->Position, lpMsg->Requestpos);

  002d4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002d7	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  002db	51		 push	 ecx
  002dc	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  002df	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  002e3	50		 push	 eax
  002e4	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002e7	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  002eb	69 c2 a8 00 00
	00		 imul	 eax, edx, 168
  002f1	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002f4	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  002fa	50		 push	 eax
  002fb	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002fe	52		 push	 edx
  002ff	e8 00 00 00 00	 call	 ?ItemDurRepaire@@YAXPAVOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire
  00304	83 c4 10	 add	 esp, 16			; 00000010H

; 9016 : 		gObjCalCharacter(lpObj->m_Index);

  00307	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030c	51		 push	 ecx
  0030d	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00312	83 c4 04	 add	 esp, 4
$LN1@CGModifyRe:

; 9017 : 	}		
; 9018 : }

  00315	5f		 pop	 edi
  00316	5e		 pop	 esi
  00317	5b		 pop	 ebx
  00318	8b e5		 mov	 esp, ebp
  0031a	5d		 pop	 ebp
  0031b	c3		 ret	 0
?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ENDP ; CGModifyRequestItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z
_TEXT	SEGMENT
_type$1 = -36						; size = 4
_sellmoney$2 = -32					; size = 4
_NewOption$3 = -28					; size = 8
_tShop$ = -20						; size = 4
_lpObj$ = -16						; size = 4
_pResult$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z PROC	; CGSellRequestRecv, COMDAT

; 8051 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 8052 : 
; 8053 : 	PMSG_SELLRESULT	pResult;
; 8054 : 	LPOBJECTSTRUCT lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00013	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00020	89 45 f0	 mov	 DWORD PTR _lpObj$[ebp], eax

; 8055 : 		
; 8056 : 	PHeadSetB((LPBYTE)&pResult, 0x33, sizeof( pResult));

  00023	6a 08		 push	 8
  00025	6a 33		 push	 51			; 00000033H
  00027	8d 45 f4	 lea	 eax, DWORD PTR _pResult$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8057 : 
; 8058 : 	pResult.Result		= 0;

  00033	c6 45 f7 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 8059 : 	pResult.Money		= 0;

  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0

; 8060 : 
; 8061 : 	// ..
; 8062 : 	if( gObj[aIndex].CloseType != -1 )

  0003e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004b	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  00050	83 fa ff	 cmp	 edx, -1
  00053	74 1a		 je	 SHORT $LN2@CGSellRequ

; 8063 : 	{
; 8064 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00055	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00059	50		 push	 eax
  0005a	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8065 : 		return;

  0006a	e9 80 07 00 00	 jmp	 $LN1@CGSellRequ
$LN2@CGSellRequ:

; 8066 : 	}
; 8067 : 
; 8068 : 	//       
; 8069 : 	if( lpObj->m_IfState.use > 0 )

  0006f	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00072	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00078	80 e1 03	 and	 cl, 3
  0007b	0f b6 d1	 movzx	 edx, cl
  0007e	85 d2		 test	 edx, edx
  00080	7e 31		 jle	 SHORT $LN4@CGSellRequ

; 8070 : 	{
; 8071 : 		if( lpObj->m_IfState.type != I_SHOP )

  00082	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00085	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0008b	c0 e9 04	 shr	 cl, 4
  0008e	80 e1 0f	 and	 cl, 15			; 0000000fH
  00091	0f b6 d1	 movzx	 edx, cl
  00094	83 fa 03	 cmp	 edx, 3
  00097	74 1a		 je	 SHORT $LN4@CGSellRequ

; 8072 : 		{
; 8073 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00099	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0009d	50		 push	 eax
  0009e	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8074 : 			return;

  000ae	e9 3c 07 00 00	 jmp	 $LN1@CGSellRequ
$LN4@CGSellRequ:

; 8075 : 		}		
; 8076 : 	}
; 8077 : 		
; 8078 : 	if( PacketCheckTime(lpObj) == FALSE )

  000b3	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  000bc	83 c4 04	 add	 esp, 4
  000bf	85 c0		 test	 eax, eax
  000c1	75 1a		 jne	 SHORT $LN5@CGSellRequ

; 8079 : 	{
; 8080 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000c3	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000c7	50		 push	 eax
  000c8	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000cb	51		 push	 ecx
  000cc	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8081 : 		return;

  000d8	e9 12 07 00 00	 jmp	 $LN1@CGSellRequ
$LN5@CGSellRequ:

; 8082 : 	}
; 8083 : 
; 8084 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719		//    - NPC   
; 8085 : 	if (gObjFixInventoryPointer(aIndex) == false) {

  000dd	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  000e6	83 c4 04	 add	 esp, 4
  000e9	0f b6 c8	 movzx	 ecx, al
  000ec	85 c9		 test	 ecx, ecx
  000ee	75 1c		 jne	 SHORT $LN6@CGSellRequ

; 8086 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z@4JA
  000f5	83 c0 23	 add	 eax, 35			; 00000023H
  000f8	50		 push	 eax
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CGSellRequ:

; 8087 : 	}
; 8088 : #endif
; 8089 : 
; 8090 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//    NPC    .
; 8091 : 	if (gObj[aIndex].pTransaction == 1) {

  0010c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00119	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  00121	83 fa 01	 cmp	 edx, 1
  00124	75 55		 jne	 SHORT $LN7@CGSellRequ

; 8092 : 		LogAddTD("[%s][%s] CGSellRequestRecv() Failed : Transaction == 1, IF_TYPE : %d",

  00126	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00133	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0013a	c0 ea 04	 shr	 dl, 4
  0013d	80 e2 0f	 and	 dl, 15			; 0000000fH
  00140	0f b6 c2	 movzx	 eax, dl
  00143	50		 push	 eax
  00144	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0014b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00151	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00155	50		 push	 eax
  00156	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0015d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00163	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00167	50		 push	 eax
  00168	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fa@
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00173	83 c4 10	 add	 esp, 16			; 00000010H

; 8093 : 			gObj[aIndex].AccountID,
; 8094 : 			gObj[aIndex].Name,
; 8095 : 			gObj[aIndex].m_IfState.type
; 8096 : 			);
; 8097 : 		return;

  00176	e9 74 06 00 00	 jmp	 $LN1@CGSellRequ
$LN7@CGSellRequ:

; 8098 : 	}
; 8099 : #endif
; 8100 : 
; 8101 : 	int tShop = lpObj->TargetShopNumber;

  0017b	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017e	0f bf 88 ae 02
	00 00		 movsx	 ecx, WORD PTR [eax+686]
  00185	89 4d ec	 mov	 DWORD PTR _tShop$[ebp], ecx

; 8102 : 	if( tShop < 0 || (tShop > MAX_SHOP-1) ) 

  00188	83 7d ec 00	 cmp	 DWORD PTR _tShop$[ebp], 0
  0018c	7c 06		 jl	 SHORT $LN9@CGSellRequ
  0018e	83 7d ec 0c	 cmp	 DWORD PTR _tShop$[ebp], 12 ; 0000000cH
  00192	7e 1a		 jle	 SHORT $LN8@CGSellRequ
$LN9@CGSellRequ:

; 8103 : 	{
; 8104 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00194	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00198	50		 push	 eax
  00199	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0019c	51		 push	 ecx
  0019d	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001a0	52		 push	 edx
  001a1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8105 : 		return;

  001a9	e9 41 06 00 00	 jmp	 $LN1@CGSellRequ
$LN8@CGSellRequ:

; 8106 : 	}
; 8107 : 
; 8108 : 	if( gObjCanItemTouch(lpObj, I_SHOP) == FALSE )	//    

  001ae	6a 03		 push	 3
  001b0	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  001b9	83 c4 08	 add	 esp, 8
  001bc	85 c0		 test	 eax, eax
  001be	75 1a		 jne	 SHORT $LN10@CGSellRequ

; 8109 : 	{
; 8110 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001c0	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001c4	50		 push	 eax
  001c5	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001c8	51		 push	 ecx
  001c9	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001cc	52		 push	 edx
  001cd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8111 : 		return;

  001d5	e9 15 06 00 00	 jmp	 $LN1@CGSellRequ
$LN10@CGSellRequ:

; 8112 : 	}
; 8113 : 
; 8114 : 	//   ...
; 8115 : 	//       .
; 8116 : 	if( lpMsg->Pos > MAX_INVENTORY-1 )

  001da	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001dd	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  001e1	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  001e4	7e 3c		 jle	 SHORT $LN11@CGSellRequ

; 8117 : 	{
; 8118 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001e6	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001ea	50		 push	 eax
  001eb	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001ee	51		 push	 ecx
  001ef	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001f2	52		 push	 edx
  001f3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8119 : 		LogAdd(lMsg.Get(483),lpMsg->Pos);

  001fb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001fe	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00202	51		 push	 ecx
  00203	68 e3 01 00 00	 push	 483			; 000001e3H
  00208	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0020d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00213	50		 push	 eax
  00214	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0021a	83 c4 08	 add	 esp, 8

; 8120 : 		return;

  0021d	e9 cd 05 00 00	 jmp	 $LN1@CGSellRequ
$LN11@CGSellRequ:

; 8121 : 	}	
; 8122 : 
; 8123 : #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202
; 8124 : 	if( gObjCheckSerial0ItemList(&lpObj->pInventory[lpMsg->Pos]) )

  00222	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00225	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00229	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0022f	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00232	03 90 5c 0c 00
	00		 add	 edx, DWORD PTR [eax+3164]
  00238	52		 push	 edx
  00239	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  0023e	83 c4 04	 add	 esp, 4
  00241	85 c0		 test	 eax, eax
  00243	74 77		 je	 SHORT $LN12@CGSellRequ

; 8125 : 	{
; 8126 : 		// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 8127 : 		MsgOutput( aIndex, lMsg.Get(3354) );			// "  .  ."

  00245	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0024a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00255	50		 push	 eax
  00256	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0025f	83 c4 08	 add	 esp, 8

; 8128 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00262	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00266	50		 push	 eax
  00267	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0026a	51		 push	 ecx
  0026b	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0026e	52		 push	 edx
  0026f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00274	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8129 : 		LogAddTD("[ANTI-HACK][Serial 0 Item] [Sell Item] (%s)(%s) Item(%s) Pos(%d)", 

  00277	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0027a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0027e	51		 push	 ecx
  0027f	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00282	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00286	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0028c	8b 55 f0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0028f	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00295	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0029a	50		 push	 eax
  0029b	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029e	83 c0 73	 add	 eax, 115		; 00000073H
  002a1	50		 push	 eax
  002a2	8b 4d f0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002a5	83 c1 68	 add	 ecx, 104		; 00000068H
  002a8	51		 push	 ecx
  002a9	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSel@
  002ae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002b4	83 c4 14	 add	 esp, 20			; 00000014H

; 8130 : 			lpObj->AccountID, lpObj->Name, lpObj->pInventory[lpMsg->Pos].GetName(), lpMsg->Pos);
; 8131 : 		return;

  002b7	e9 33 05 00 00	 jmp	 $LN1@CGSellRequ
$LN12@CGSellRequ:

; 8132 : 	}
; 8133 : #endif
; 8134 : 	
; 8135 : 	if( lpObj->pInventory[lpMsg->Pos].m_Type == MAKE_ITEMNUM(14,11) ) //   ..

  002bc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002bf	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  002c3	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  002c9	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cc	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  002d2	0f bf 74 11 06	 movsx	 esi, WORD PTR [ecx+edx+6]
  002d7	6a 0b		 push	 11			; 0000000bH
  002d9	6a 0e		 push	 14			; 0000000eH
  002db	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002e0	83 c4 08	 add	 esp, 8
  002e3	3b f0		 cmp	 esi, eax
  002e5	75 1a		 jne	 SHORT $LN13@CGSellRequ

; 8136 : 	{
; 8137 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  002e7	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002eb	50		 push	 eax
  002ec	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  002ef	51		 push	 ecx
  002f0	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002f3	52		 push	 edx
  002f4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8138 : 		return;

  002fc	e9 ee 04 00 00	 jmp	 $LN1@CGSellRequ
$LN13@CGSellRequ:

; 8139 : 	}
; 8140 : 
; 8141 : #ifndef MODIFY_QUEST_MONSTER_KILL_COUNT_BUGFIX_20070704	//       .
; 8142 : #ifdef NEW_SKILL_FORSKYLAND	
; 8143 : 	if( lpObj->pInventory[lpMsg->Pos].m_QuestItem )

  00301	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00304	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00308	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0030e	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00311	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00317	0f b6 94 11 91
	00 00 00	 movzx	 edx, BYTE PTR [ecx+edx+145]
  0031f	85 d2		 test	 edx, edx
  00321	74 1a		 je	 SHORT $LN14@CGSellRequ

; 8144 : 	{	//    
; 8145 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00323	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00327	50		 push	 eax
  00328	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0032b	51		 push	 ecx
  0032c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0032f	52		 push	 edx
  00330	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00335	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8146 : 		return;

  00338	e9 b2 04 00 00	 jmp	 $LN1@CGSellRequ
$LN14@CGSellRequ:

; 8147 : 	}
; 8148 : #endif
; 8149 : #endif
; 8150 : 
; 8151 : #ifdef ADD_NOT_SELL_EQUIPITEM_20080625
; 8152 : 	if( IS_EQUIPITEM(lpMsg->Pos) ) 
; 8153 : 	{
; 8154 : 		pResult.Result = 0xFF; //EERROR::E_NOT_SELL_EQUIPITEM;
; 8155 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 8156 : 		return;
; 8157 : 	}
; 8158 : #endif // ADD_NOT_SELL_EQUIPITEM_20080625
; 8159 : 
; 8160 : #ifdef FOR_BLOODCASTLE3
; 8161 : /*	
; 8162 : 	if( lpObj->pInventory[lpMsg->Pos].m_Type == MAKE_ITEMNUM(14,21) &&
; 8163 : 		lpObj->pInventory[lpMsg->Pos].m_Level == 2
; 8164 : 		) //  .
; 8165 : 	{
; 8166 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 8167 : 		return;
; 8168 : 	}
; 8169 : */
; 8170 : #endif
; 8171 : 
; 8172 : #ifdef RING_EVENT_ITEMBOX_20031124				//  -  
; 8173 : 	if( lpObj->pInventory[lpMsg->Pos].m_Type == MAKE_ITEMNUM(13,20) &&

  0033d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00340	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00344	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0034a	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034d	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00353	0f bf 74 11 06	 movsx	 esi, WORD PTR [ecx+edx+6]
  00358	6a 14		 push	 20			; 00000014H
  0035a	6a 0d		 push	 13			; 0000000dH
  0035c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00361	83 c4 08	 add	 esp, 8
  00364	3b f0		 cmp	 esi, eax
  00366	75 3a		 jne	 SHORT $LN15@CGSellRequ
  00368	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0036b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0036f	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00375	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00378	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0037e	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  00383	83 fa 01	 cmp	 edx, 1
  00386	75 1a		 jne	 SHORT $LN15@CGSellRequ

; 8174 : 		lpObj->pInventory[lpMsg->Pos].m_Level == 1			//  
; 8175 : 		) //     .
; 8176 : 	{
; 8177 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00388	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0038c	50		 push	 eax
  0038d	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00390	51		 push	 ecx
  00391	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00394	52		 push	 edx
  00395	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0039a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8178 : 		return;

  0039d	e9 4d 04 00 00	 jmp	 $LN1@CGSellRequ
$LN15@CGSellRequ:

; 8179 : 	}
; 8180 : #endif
; 8181 : 
; 8182 : #ifdef FRIENDSHIP_EVENT_RING_BOX_20040211		//   -     
; 8183 : 	if( lpObj->pInventory[lpMsg->Pos].m_Type == MAKE_ITEMNUM(13,20) &&

  003a2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003a5	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  003a9	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  003af	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b2	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  003b8	0f bf 74 11 06	 movsx	 esi, WORD PTR [ecx+edx+6]
  003bd	6a 14		 push	 20			; 00000014H
  003bf	6a 0d		 push	 13			; 0000000dH
  003c1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003c6	83 c4 08	 add	 esp, 8
  003c9	3b f0		 cmp	 esi, eax
  003cb	75 3a		 jne	 SHORT $LN16@CGSellRequ
  003cd	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003d0	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  003d4	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  003da	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003dd	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  003e3	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  003e8	83 fa 02	 cmp	 edx, 2
  003eb	75 1a		 jne	 SHORT $LN16@CGSellRequ

; 8184 : 		lpObj->pInventory[lpMsg->Pos].m_Level == 2			//  
; 8185 : 		) //     .
; 8186 : 	{
; 8187 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  003ed	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  003f1	50		 push	 eax
  003f2	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  003f5	51		 push	 ecx
  003f6	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  003f9	52		 push	 edx
  003fa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8188 : 		return;

  00402	e9 e8 03 00 00	 jmp	 $LN1@CGSellRequ
$LN16@CGSellRequ:

; 8189 : 	}
; 8190 : #endif
; 8191 : 
; 8192 : #ifdef HIDDEN_TREASUREBOX_EVENT_20050804		//       
; 8193 : 	if( lpObj->pInventory[lpMsg->Pos].m_Type == MAKE_ITEMNUM(12,26) &&
; 8194 : 		(lpObj->pInventory[lpMsg->Pos].m_Level == 1 ||			// 
; 8195 : 		lpObj->pInventory[lpMsg->Pos].m_Level == 2 ||			// 
; 8196 : 		lpObj->pInventory[lpMsg->Pos].m_Level == 3 ||			// 
; 8197 : 		lpObj->pInventory[lpMsg->Pos].m_Level == 4 ||			//  
; 8198 : 		lpObj->pInventory[lpMsg->Pos].m_Level == 5				//  ( )
; 8199 : 		))
; 8200 : 	{
; 8201 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 8202 : 		return;
; 8203 : 	}
; 8204 : #endif
; 8205 : 
; 8206 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 8207 : 	//     
; 8208 : 	if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony( &lpObj->pInventory[lpMsg->Pos] ) == TRUE )
; 8209 : 	{
; 8210 : #ifdef ADD_JEWEL_OF_HARMONY_WTFMESSAGE_20060818
; 8211 : 		GCServerMsgStringSend(lMsg.Get(3365), lpObj->m_Index, 1); //     .
; 8212 : #endif
; 8213 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 8214 : 		return;
; 8215 : 	}
; 8216 : #endif
; 8217 : 
; 8218 : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117 
; 8219 : 	if( IsCashItem( lpObj->pInventory[lpMsg->Pos].m_Type ) == TRUE )
; 8220 : 	{
; 8221 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 8222 : 
; 8223 : 		return;
; 8224 : 	}
; 8225 : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 8226 : 
; 8227 : #ifdef PREMIUMITEM_20090106
; 8228 : 	//    
; 8229 : 	if(	IsPremiumItem( lpObj->pInventory[lpMsg->Pos].m_Type ) == TRUE )
; 8230 : 	{
; 8231 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 8232 : 
; 8233 : 		return;
; 8234 : 	}
; 8235 : #endif // PREMIUMITEM_20090106
; 8236 : 
; 8237 : #ifndef FOR_KOREA
; 8238 : #ifdef ADD_PREMIUMITEM_PANDA
; 8239 : 	if( lpObj->pInventory[lpMsg->Pos].m_Type == MAKE_ITEMNUM( 13, 76)	// 
; 8240 : 	|| lpObj->pInventory[lpMsg->Pos].m_Type == MAKE_ITEMNUM( 13, 80)	// 
; 8241 : 	)
; 8242 : 	{
; 8243 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 8244 : 	
; 8245 : 		return;
; 8246 : 	}
; 8247 : #endif // ADD_PREMIUMITEM_PANDA
; 8248 : #endif // NOT_FOR_KOREA
; 8249 : 	
; 8250 : 	if( lpObj->pInventory[lpMsg->Pos].m_Type == MAKE_ITEMNUM(14,12) ) //   ..

  00407	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0040a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0040e	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00414	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00417	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0041d	0f bf 74 11 06	 movsx	 esi, WORD PTR [ecx+edx+6]
  00422	6a 0c		 push	 12			; 0000000cH
  00424	6a 0e		 push	 14			; 0000000eH
  00426	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0042b	83 c4 08	 add	 esp, 8
  0042e	3b f0		 cmp	 esi, eax
  00430	75 7e		 jne	 SHORT $LN18@CGSellRequ

; 8251 : 	{
; 8252 : 		if( lpObj->pInventory[lpMsg->Pos].m_Level == 1 )	//  

  00432	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00435	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00439	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0043f	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00442	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00448	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  0044d	83 fa 01	 cmp	 edx, 1
  00450	75 5e		 jne	 SHORT $LN18@CGSellRequ

; 8253 : 		{
; 8254 : 			pResult.Result = 1;

  00452	c6 45 f7 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 8255 : 			pResult.Money  = lpObj->Money;		

  00456	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00459	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0045f	89 4d f8	 mov	 DWORD PTR _pResult$[ebp+4], ecx

; 8256 : 			gObjInventoryItemSet(aIndex, lpMsg->Pos, 0xFF);

  00462	68 ff 00 00 00	 push	 255			; 000000ffH
  00467	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0046a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0046e	51		 push	 ecx
  0046f	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00472	52		 push	 edx
  00473	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00478	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8257 : 			lpObj->pInventory[lpMsg->Pos].Clear();

  0047b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0047e	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00482	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00488	8b 55 f0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0048b	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00491	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 8258 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00496	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0049a	50		 push	 eax
  0049b	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0049e	51		 push	 ecx
  0049f	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  004a2	52		 push	 edx
  004a3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8259 : 
; 8260 : 			// # REMOVE_LOVELOVE_EVENT_COUPLING_WITH_JOINSERVER_20060319
; 8261 : 			// #        (apple)
; 8262 : 			//		-          .
; 8263 : 			//		-     DB  .
; 8264 : 			//		-       .
; 8265 : 			//LoveHeartEventSend(aIndex, gObj[aIndex].AccountID, gObj[aIndex].Name );
; 8266 : 			return;

  004ab	e9 3f 03 00 00	 jmp	 $LN1@CGSellRequ
$LN18@CGSellRequ:

; 8267 : 		}
; 8268 : 	}	
; 8269 : 
; 8270 : 	if( lpObj->pInventory[lpMsg->Pos].IsItem() == FALSE )

  004b0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004b3	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  004b7	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  004bd	8b 55 f0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004c0	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  004c6	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  004cb	85 c0		 test	 eax, eax
  004cd	75 7f		 jne	 SHORT $LN19@CGSellRequ

; 8271 : 	{	//   ..  		
; 8272 : 		pResult.Result = 0;

  004cf	c6 45 f7 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 8273 : 		pResult.Money  = lpObj->Money;

  004d3	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d6	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  004dc	89 4d f8	 mov	 DWORD PTR _pResult$[ebp+4], ecx

; 8274 : 		LogAdd(lMsg.Get(484), __FILE__, __LINE__, lpObj->Name, lpMsg->Pos);

  004df	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004e2	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  004e6	51		 push	 ecx
  004e7	8b 55 f0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004ea	83 c2 73	 add	 edx, 115		; 00000073H
  004ed	52		 push	 edx
  004ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z@4JA
  004f3	05 df 00 00 00	 add	 eax, 223		; 000000dfH
  004f8	50		 push	 eax
  004f9	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  004fe	68 e4 01 00 00	 push	 484			; 000001e4H
  00503	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00508	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0050e	50		 push	 eax
  0050f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00515	83 c4 14	 add	 esp, 20			; 00000014H

; 8275 : 		LogAdd("ID:%s CharID:%s ", lpObj->AccountID, lpObj->Name);

  00518	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0051b	83 c0 73	 add	 eax, 115		; 00000073H
  0051e	50		 push	 eax
  0051f	8b 4d f0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00522	83 c1 68	 add	 ecx, 104		; 00000068H
  00525	51		 push	 ecx
  00526	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5@
  0052b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00531	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8276 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00534	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00538	50		 push	 eax
  00539	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0053c	51		 push	 ecx
  0053d	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00540	52		 push	 edx
  00541	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00546	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8277 : 	}

  00549	e9 8c 02 00 00	 jmp	 $LN20@CGSellRequ
$LN19@CGSellRequ:

; 8278 : 	else //    ...   ?? 
; 8279 : 	{
; 8280 : 		//  20021230		
; 8281 : 		BYTE NewOption[8];
; 8282 : 		int sellmoney = 0;

  0054e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _sellmoney$2[ebp], 0

; 8283 : 		int type = lpObj->pInventory[lpMsg->Pos].m_Type;

  00555	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00558	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0055c	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00562	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00565	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0056b	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  00570	89 55 dc	 mov	 DWORD PTR _type$1[ebp], edx

; 8284 : 
; 8285 : #ifdef BUGFIX_SELL_PRICE_OF_DARKLOAD_PETS_20050310 // coder: u4us, date: 2005. 03. 10.	
; 8286 : 		if(type == MAKE_ITEMNUM(13,4) || type == MAKE_ITEMNUM(13,5))
; 8287 : 			lpObj->pInventory[lpMsg->Pos].PetValue();
; 8288 : 		else
; 8289 : #endif // BUGFIX_SELL_PRICE_OF_DARKLOAD_PETS_20050310
; 8290 : 			lpObj->pInventory[lpMsg->Pos].Value();

  00573	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00576	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0057a	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00580	8b 55 f0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00583	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00589	e8 00 00 00 00	 call	 ?Value@CItem@@QAEXXZ	; CItem::Value

; 8291 : 		
; 8292 : 		sellmoney = lpObj->pInventory[lpMsg->Pos].m_SellMoney;

  0058e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00591	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00595	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0059b	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0059e	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  005a4	8b 54 11 60	 mov	 edx, DWORD PTR [ecx+edx+96]
  005a8	89 55 e0	 mov	 DWORD PTR _sellmoney$2[ebp], edx

; 8293 : 
; 8294 : 
; 8295 : 		
; 8296 : 		/*
; 8297 : 		if( type == MAKE_ITEMNUM(4,7) || type == MAKE_ITEMNUM(4,15) )
; 8298 : 		{	// ,     
; 8299 : 			
; 8300 : 		}
; 8301 : 		else
; 8302 : 		{			
; 8303 : 			if( HasItemDurability(type) )
; 8304 : 			{	//   
; 8305 : 				CItem* DurItem = &lpObj->pInventory[lpMsg->Pos];
; 8306 : 				float ItemDurability = DurItem->m_Durability;
; 8307 : 
; 8308 : 				float  persent = 1.f - DurItem->m_Durability/DurItem->m_BaseDurability;
; 8309 : 				sellmoney = DurItem->m_SellMoney * 0.6 * persent;
; 8310 : 
; 8311 : 				if(sellmoney>= 1000)
; 8312 : 					sellmoney = sellmoney/100*100;
; 8313 : 				else if(sellmoney >= 100)
; 8314 : 					sellmoney = sellmoney/10*10;
; 8315 : 			}
; 8316 : 			else
; 8317 : 			{
; 8318 : 				sellmoney = lpObj->pInventory[lpMsg->Pos].m_SellMoney;
; 8319 : 			}
; 8320 : 		}
; 8321 : 		*/
; 8322 : 		
; 8323 : #ifdef MODIFY_ZEN_MAX_20040414
; 8324 : 		if( !gObjCheckMaxZen( aIndex, sellmoney ) )

  005ab	8b 45 e0	 mov	 eax, DWORD PTR _sellmoney$2[ebp]
  005ae	50		 push	 eax
  005af	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  005b2	51		 push	 ecx
  005b3	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  005b8	83 c4 08	 add	 esp, 8
  005bb	85 c0		 test	 eax, eax
  005bd	75 1a		 jne	 SHORT $LN21@CGSellRequ

; 8325 : 		{
; 8326 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  005bf	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  005c3	50		 push	 eax
  005c4	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  005c7	51		 push	 ecx
  005c8	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005cb	52		 push	 edx
  005cc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8327 : 			return;

  005d4	e9 16 02 00 00	 jmp	 $LN1@CGSellRequ
$LN21@CGSellRequ:

; 8328 : 		}
; 8329 : #endif
; 8330 : 		lpObj->Money += sellmoney;

  005d9	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005dc	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  005e2	03 4d e0	 add	 ecx, DWORD PTR _sellmoney$2[ebp]
  005e5	8b 55 f0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005e8	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 8331 : 		pResult.Result = 1;

  005ee	c6 45 f7 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 8332 : 		pResult.Money = lpObj->Money;

  005f2	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f5	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  005fb	89 4d f8	 mov	 DWORD PTR _pResult$[ebp+4], ecx

; 8333 : 
; 8334 : 		ItemIsBufExOption(NewOption, &lpObj->pInventory[lpMsg->Pos]);

  005fe	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00601	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00605	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0060b	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0060e	03 90 5c 0c 00
	00		 add	 edx, DWORD PTR [eax+3164]
  00614	52		 push	 edx
  00615	8d 4d e4	 lea	 ecx, DWORD PTR _NewOption$3[ebp]
  00618	51		 push	 ecx
  00619	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  0061e	83 c4 08	 add	 esp, 8

; 8335 : 		
; 8336 : 		/*LogAddTD(lMsg.Get(485),
; 8337 : 			lpObj->AccountID, 
; 8338 : 			lpObj->Name,
; 8339 : 			lpObj->Money, 
; 8340 : 			lpObj->pInventory[lpMsg->Pos].GetName(),
; 8341 : 			lpObj->pInventory[lpMsg->Pos].m_Level,
; 8342 : 			lpObj->pInventory[lpMsg->Pos].m_Option1,
; 8343 : 			lpObj->pInventory[lpMsg->Pos].m_Option2,
; 8344 : 			lpObj->pInventory[lpMsg->Pos].m_Option3,
; 8345 : 			lpObj->pInventory[lpMsg->Pos].m_Number		
; 8346 : 			);
; 8347 : 			*/
; 8348 : 
; 8349 : #ifdef EXTEND_LOG_SYSTEM_07_20070320
; 8350 : 		LogAddTD(lMsg.Get(485),
; 8351 : 			lpObj->AccountID, 
; 8352 : 			lpObj->Name,
; 8353 : 			tShop,		//   
; 8354 : 			sellmoney, 
; 8355 : 			lpObj->pInventory[lpMsg->Pos].GetName(),
; 8356 : 			lpObj->pInventory[lpMsg->Pos].m_Level,
; 8357 : 			lpObj->pInventory[lpMsg->Pos].m_Option1,
; 8358 : 			lpObj->pInventory[lpMsg->Pos].m_Option2,
; 8359 : 			lpObj->pInventory[lpMsg->Pos].m_Option3,
; 8360 : 			lpObj->pInventory[lpMsg->Pos].m_Number,
; 8361 : 			(int)lpObj->pInventory[lpMsg->Pos].m_Durability,
; 8362 : 			NewOption[0],
; 8363 : 			NewOption[1],
; 8364 : 			NewOption[2],
; 8365 : 			NewOption[3],
; 8366 : 			NewOption[4],
; 8367 : 			NewOption[5],
; 8368 : 			NewOption[6],
; 8369 : 			lpObj->pInventory[lpMsg->Pos].m_SetOption,
; 8370 : 			lpObj->pInventory[lpMsg->Pos].m_ItemOptionEx>>7,										// 380 
; 8371 : 			g_kJewelOfHarmonySystem.GetItemStrengthenOption( &lpObj->pInventory[lpMsg->Pos] ),		// 
; 8372 : 			g_kJewelOfHarmonySystem.GetItemOptionLevel( &lpObj->pInventory[lpMsg->Pos] )			// 
; 8373 : 			);
; 8374 : #else
; 8375 : 		LogAddTD(lMsg.Get(485),

  00621	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00624	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00628	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0062e	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00631	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00637	0f b6 94 11 92
	00 00 00	 movzx	 edx, BYTE PTR [ecx+edx+146]
  0063f	52		 push	 edx
  00640	b8 01 00 00 00	 mov	 eax, 1
  00645	6b c8 06	 imul	 ecx, eax, 6
  00648	0f b6 54 0d e4	 movzx	 edx, BYTE PTR _NewOption$3[ebp+ecx]
  0064d	52		 push	 edx
  0064e	b8 01 00 00 00	 mov	 eax, 1
  00653	6b c8 05	 imul	 ecx, eax, 5
  00656	0f b6 54 0d e4	 movzx	 edx, BYTE PTR _NewOption$3[ebp+ecx]
  0065b	52		 push	 edx
  0065c	b8 01 00 00 00	 mov	 eax, 1
  00661	c1 e0 02	 shl	 eax, 2
  00664	0f b6 4c 05 e4	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00669	51		 push	 ecx
  0066a	ba 01 00 00 00	 mov	 edx, 1
  0066f	6b c2 03	 imul	 eax, edx, 3
  00672	0f b6 4c 05 e4	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00677	51		 push	 ecx
  00678	ba 01 00 00 00	 mov	 edx, 1
  0067d	d1 e2		 shl	 edx, 1
  0067f	0f b6 44 15 e4	 movzx	 eax, BYTE PTR _NewOption$3[ebp+edx]
  00684	50		 push	 eax
  00685	b9 01 00 00 00	 mov	 ecx, 1
  0068a	c1 e1 00	 shl	 ecx, 0
  0068d	0f b6 54 0d e4	 movzx	 edx, BYTE PTR _NewOption$3[ebp+ecx]
  00692	52		 push	 edx
  00693	b8 01 00 00 00	 mov	 eax, 1
  00698	6b c8 00	 imul	 ecx, eax, 0
  0069b	0f b6 54 0d e4	 movzx	 edx, BYTE PTR _NewOption$3[ebp+ecx]
  006a0	52		 push	 edx
  006a1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006a4	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  006a8	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  006ae	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b1	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  006b7	f3 0f 2c 54 11
	24		 cvttss2si edx, DWORD PTR [ecx+edx+36]
  006bd	52		 push	 edx
  006be	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006c1	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  006c5	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  006cb	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ce	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  006d4	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  006d7	52		 push	 edx
  006d8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006db	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  006df	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  006e5	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006e8	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  006ee	0f b6 54 11 7a	 movzx	 edx, BYTE PTR [ecx+edx+122]
  006f3	52		 push	 edx
  006f4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006f7	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  006fb	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00701	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00704	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0070a	0f b6 54 11 79	 movzx	 edx, BYTE PTR [ecx+edx+121]
  0070f	52		 push	 edx
  00710	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00713	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00717	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0071d	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00720	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00726	0f b6 54 11 78	 movzx	 edx, BYTE PTR [ecx+edx+120]
  0072b	52		 push	 edx
  0072c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0072f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00733	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00739	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0073c	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00742	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  00747	52		 push	 edx
  00748	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0074b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0074f	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00755	8b 55 f0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00758	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0075e	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00763	50		 push	 eax
  00764	8b 45 e0	 mov	 eax, DWORD PTR _sellmoney$2[ebp]
  00767	50		 push	 eax
  00768	8b 4d ec	 mov	 ecx, DWORD PTR _tShop$[ebp]
  0076b	51		 push	 ecx
  0076c	8b 55 f0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0076f	83 c2 73	 add	 edx, 115		; 00000073H
  00772	52		 push	 edx
  00773	8b 45 f0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00776	83 c0 68	 add	 eax, 104		; 00000068H
  00779	50		 push	 eax
  0077a	68 e5 01 00 00	 push	 485			; 000001e5H
  0077f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00784	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0078a	50		 push	 eax
  0078b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00791	83 c4 50	 add	 esp, 80			; 00000050H

; 8376 : 			lpObj->AccountID, 
; 8377 : 			lpObj->Name,
; 8378 : 			tShop,		//   
; 8379 : 			sellmoney, 
; 8380 : 			lpObj->pInventory[lpMsg->Pos].GetName(),
; 8381 : 			lpObj->pInventory[lpMsg->Pos].m_Level,
; 8382 : 			lpObj->pInventory[lpMsg->Pos].m_Option1,
; 8383 : 			lpObj->pInventory[lpMsg->Pos].m_Option2,
; 8384 : 			lpObj->pInventory[lpMsg->Pos].m_Option3,
; 8385 : 			lpObj->pInventory[lpMsg->Pos].m_Number,
; 8386 : 			(int)lpObj->pInventory[lpMsg->Pos].m_Durability,
; 8387 : 			NewOption[0],
; 8388 : 			NewOption[1],
; 8389 : 			NewOption[2],
; 8390 : 			NewOption[3],
; 8391 : 			NewOption[4],
; 8392 : 			NewOption[5],
; 8393 : 			NewOption[6],
; 8394 : 			lpObj->pInventory[lpMsg->Pos].m_SetOption
; 8395 : 			);
; 8396 : #endif // EXTEND_LOG_SYSTEM_07_20070320
; 8397 : 				
; 8398 : 		//lpObj->pInventory[lpMsg->Pos].Clear();
; 8399 : 		gObjInventoryDeleteItem(aIndex, lpMsg->Pos);

  00794	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00797	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0079b	51		 push	 ecx
  0079c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0079f	52		 push	 edx
  007a0	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  007a5	83 c4 08	 add	 esp, 8

; 8400 : 
; 8401 : 		if( lpMsg->Pos == EQUIPMENT_RING_RIGHT || lpMsg->Pos == EQUIPMENT_RING_LEFT)

  007a8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007ab	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  007af	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  007b2	74 0c		 je	 SHORT $LN23@CGSellRequ
  007b4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007b7	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  007bb	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  007be	75 0e		 jne	 SHORT $LN22@CGSellRequ
$LN23@CGSellRequ:

; 8402 : 		{
; 8403 : 			gObjUseSkill.SkillChangeUse(aIndex);			

  007c0	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007c3	50		 push	 eax
  007c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  007c9	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN22@CGSellRequ:

; 8404 : 		}
; 8405 : 		gObjMakePreviewCharSet(aIndex);

  007ce	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007d1	50		 push	 eax
  007d2	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  007d7	83 c4 04	 add	 esp, 4
$LN20@CGSellRequ:

; 8406 : 
; 8407 : 	}
; 8408 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  007da	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  007de	50		 push	 eax
  007df	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  007e2	51		 push	 ecx
  007e3	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  007e6	52		 push	 edx
  007e7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  007ec	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGSellRequ:

; 8409 : }

  007ef	5f		 pop	 edi
  007f0	5e		 pop	 esi
  007f1	5b		 pop	 ebx
  007f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007f5	33 cd		 xor	 ecx, ebp
  007f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007fc	8b e5		 mov	 esp, ebp
  007fe	5d		 pop	 ebp
  007ff	c3		 ret	 0
?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z ENDP	; CGSellRequestRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z
_TEXT	SEGMENT
_lc64$1 = -36						; size = 4
_dur$2 = -32						; size = 4
_bNoItem$3 = -28					; size = 4
_tShop$ = -24						; size = 4
_pResult$ = -20						; size = 9
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z PROC	; CGBuyRequestRecv, COMDAT

; 7921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 7922 : 	LPOBJECTSTRUCT lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00013	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00020	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 7923 : 	
; 7924 : 	PMSG_BUYRESULT pResult;
; 7925 : 
; 7926 : 	PHeadSetB((LPBYTE)&pResult, 0x32, sizeof(pResult));

  00023	6a 09		 push	 9
  00025	6a 32		 push	 50			; 00000032H
  00027	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7927 : 	pResult.Result = -1;

  00033	c6 45 ef ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 7928 : 
; 7929 : 
; 7930 : 	if (!PacketCheckTime(lpObj))

  00037	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00040	83 c4 04	 add	 esp, 4
  00043	85 c0		 test	 eax, eax
  00045	75 1a		 jne	 SHORT $LN2@CGBuyReque

; 7931 : 	{
; 7932 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00047	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0004b	50		 push	 eax
  0004c	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7933 : 		return;

  0005c	e9 7e 05 00 00	 jmp	 $LN1@CGBuyReque
$LN2@CGBuyReque:

; 7934 : 	}
; 7935 : 
; 7936 : 	if (gObj[aIndex].CloseType != -1)

  00061	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006e	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  00073	83 fa ff	 cmp	 edx, -1
  00076	74 1a		 je	 SHORT $LN3@CGBuyReque

; 7937 : 	{
; 7938 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00078	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0007c	50		 push	 eax
  0007d	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7939 : 		return;

  0008d	e9 4d 05 00 00	 jmp	 $LN1@CGBuyReque
$LN3@CGBuyReque:

; 7940 : 	}
; 7941 : 
; 7942 : 	if (!::gObjFixInventoryPointer(aIndex))

  00092	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0009b	83 c4 04	 add	 esp, 4
  0009e	0f b6 c8	 movzx	 ecx, al
  000a1	85 c9		 test	 ecx, ecx
  000a3	75 1c		 jne	 SHORT $LN4@CGBuyReque

; 7943 : 	{
; 7944 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z@4JA
  000aa	83 c0 17	 add	 eax, 23			; 00000017H
  000ad	50		 push	 eax
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@CGBuyReque:

; 7945 : 	}
; 7946 : 
; 7947 : 
; 7948 : 	if (gObj[aIndex].m_ShopTime == 0)

  000c1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ce	0f b6 94 01 ec
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+492]
  000d6	85 d2		 test	 edx, edx
  000d8	75 15		 jne	 SHORT $LN5@CGBuyReque

; 7949 : 		gObj[aIndex].m_ShopTime = 1;

  000da	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e7	c6 84 01 ec 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+492], 1
$LN5@CGBuyReque:

; 7950 : 
; 7951 : 	if (gObj[aIndex].m_ShopTime > 60)

  000ef	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fc	0f b6 94 01 ec
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+492]
  00104	83 fa 3c	 cmp	 edx, 60			; 0000003cH
  00107	7e 7b		 jle	 SHORT $LN6@CGBuyReque

; 7952 : 	{
; 7953 : 		if (lpObj->m_IfState.use != 0 && lpObj->m_IfState.type == 3)

  00109	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00112	80 e1 03	 and	 cl, 3
  00115	0f b6 d1	 movzx	 edx, cl
  00118	85 d2		 test	 edx, edx
  0011a	74 4e		 je	 SHORT $LN7@CGBuyReque
  0011c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011f	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00125	c0 e9 04	 shr	 cl, 4
  00128	80 e1 0f	 and	 cl, 15			; 0000000fH
  0012b	0f b6 d1	 movzx	 edx, cl
  0012e	83 fa 03	 cmp	 edx, 3
  00131	75 37		 jne	 SHORT $LN7@CGBuyReque

; 7954 : 		{
; 7955 : 			lpObj->TargetShopNumber = -1;

  00133	83 c8 ff	 or	 eax, -1
  00136	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00139	66 89 81 ae 02
	00 00		 mov	 WORD PTR [ecx+686], ax

; 7956 : 			lpObj->m_IfState.use = 0;

  00140	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00143	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00149	80 e1 fc	 and	 cl, 252			; 000000fcH
  0014c	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0014f	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 7957 : 			lpObj->m_IfState.type = 0;

  00155	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00158	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0015e	80 e1 0f	 and	 cl, 15			; 0000000fH
  00161	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00164	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl
$LN7@CGBuyReque:

; 7958 : 		}
; 7959 : 
; 7960 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0016a	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0016e	50		 push	 eax
  0016f	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00172	51		 push	 ecx
  00173	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0017c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7961 : 		return;

  0017f	e9 5b 04 00 00	 jmp	 $LN1@CGBuyReque
$LN6@CGBuyReque:

; 7962 : 	}
; 7963 : 
; 7964 : 	if (lpObj->m_IfState.use > 0)

  00184	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00187	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0018d	80 e1 03	 and	 cl, 3
  00190	0f b6 d1	 movzx	 edx, cl
  00193	85 d2		 test	 edx, edx
  00195	7e 31		 jle	 SHORT $LN9@CGBuyReque

; 7965 : 	{
; 7966 : 		if (lpObj->m_IfState.type != 3)

  00197	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019a	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  001a0	c0 e9 04	 shr	 cl, 4
  001a3	80 e1 0f	 and	 cl, 15			; 0000000fH
  001a6	0f b6 d1	 movzx	 edx, cl
  001a9	83 fa 03	 cmp	 edx, 3
  001ac	74 1a		 je	 SHORT $LN9@CGBuyReque

; 7967 : 		{
; 7968 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001ae	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001b2	50		 push	 eax
  001b3	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001b6	51		 push	 ecx
  001b7	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001ba	52		 push	 edx
  001bb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7969 : 			return;

  001c3	e9 17 04 00 00	 jmp	 $LN1@CGBuyReque
$LN9@CGBuyReque:

; 7970 : 		}
; 7971 : 	}
; 7972 : 
; 7973 : 	int tShop = lpObj->TargetShopNumber;

  001c8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001cb	0f bf 88 ae 02
	00 00		 movsx	 ecx, WORD PTR [eax+686]
  001d2	89 4d e8	 mov	 DWORD PTR _tShop$[ebp], ecx

; 7974 : 
; 7975 : 	if (tShop < 0 || tShop > MAX_SHOP - 1)

  001d5	83 7d e8 00	 cmp	 DWORD PTR _tShop$[ebp], 0
  001d9	7c 06		 jl	 SHORT $LN11@CGBuyReque
  001db	83 7d e8 0c	 cmp	 DWORD PTR _tShop$[ebp], 12 ; 0000000cH
  001df	7e 1a		 jle	 SHORT $LN10@CGBuyReque
$LN11@CGBuyReque:

; 7976 : 	{
; 7977 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001e1	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001e5	50		 push	 eax
  001e6	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001e9	51		 push	 ecx
  001ea	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001ed	52		 push	 edx
  001ee	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7978 : 		return;

  001f6	e9 e4 03 00 00	 jmp	 $LN1@CGBuyReque
$LN10@CGBuyReque:

; 7979 : 	}
; 7980 : 
; 7981 : 	if (lpMsg->Pos > MAX_SHOPITEM - 1)

  001fb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001fe	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00202	83 f9 77	 cmp	 ecx, 119		; 00000077H
  00205	7e 1a		 jle	 SHORT $LN12@CGBuyReque

; 7982 : 	{
; 7983 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00207	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0020b	50		 push	 eax
  0020c	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0020f	51		 push	 ecx
  00210	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00213	52		 push	 edx
  00214	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00219	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7984 : 		return;

  0021c	e9 be 03 00 00	 jmp	 $LN1@CGBuyReque
$LN12@CGBuyReque:

; 7985 : 	}
; 7986 : 
; 7987 : 	if (ShopC[tShop].m_item[lpMsg->Pos].IsItem() == TRUE)

  00221	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  00228	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0022b	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0022f	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00235	8d 8c 08 80 00
	00 00		 lea	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+128]
  0023c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00241	83 f8 01	 cmp	 eax, 1
  00244	0f 85 80 03 00
	00		 jne	 $LN23@CGBuyReque

; 7988 : 	{
; 7989 : 
; 7990 : 		if (lpObj->Money < ShopC[tShop].m_item[lpMsg->Pos].m_BuyMoney)

  0024a	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  00251	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00254	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00258	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  0025e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00261	8b 92 b0 00 00
	00		 mov	 edx, DWORD PTR [edx+176]
  00267	3b 94 08 e4 00
	00 00		 cmp	 edx, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+228]
  0026e	73 09		 jae	 SHORT $LN14@CGBuyReque

; 7991 : 			pResult.Result = -1;

  00270	c6 45 ef ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00274	e9 51 03 00 00	 jmp	 $LN23@CGBuyReque
$LN14@CGBuyReque:

; 7992 : 		else
; 7993 : 		{
; 7994 : 			BOOL bNoItem = TRUE;

  00279	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bNoItem$3[ebp], 1

; 7995 : 
; 7996 : 			if ((ShopC[tShop].m_item[lpMsg->Pos].m_Type >= MAKE_ITEMNUM(14, 0) && ShopC[tShop].m_item[lpMsg->Pos].m_Type <= MAKE_ITEMNUM(14, 8)) ||

  00280	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  00287	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0028a	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0028e	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00294	0f bf b4 08 86
	00 00 00	 movsx	 esi, WORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+134]
  0029c	6a 00		 push	 0
  0029e	6a 0e		 push	 14			; 0000000eH
  002a0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002a5	83 c4 08	 add	 esp, 8
  002a8	3b f0		 cmp	 esi, eax
  002aa	7c 2c		 jl	 SHORT $LN18@CGBuyReque
  002ac	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  002b3	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002b6	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  002ba	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  002c0	0f bf b4 08 86
	00 00 00	 movsx	 esi, WORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+134]
  002c8	6a 08		 push	 8
  002ca	6a 0e		 push	 14			; 0000000eH
  002cc	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002d1	83 c4 08	 add	 esp, 8
  002d4	3b f0		 cmp	 esi, eax
  002d6	7e 60		 jle	 SHORT $LN17@CGBuyReque
$LN18@CGBuyReque:
  002d8	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  002df	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002e2	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  002e6	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  002ec	0f bf b4 08 86
	00 00 00	 movsx	 esi, WORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+134]
  002f4	6a 23		 push	 35			; 00000023H
  002f6	6a 0e		 push	 14			; 0000000eH
  002f8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002fd	83 c4 08	 add	 esp, 8
  00300	3b f0		 cmp	 esi, eax
  00302	0f 8c ec 00 00
	00		 jl	 $LN20@CGBuyReque
  00308	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  0030f	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00312	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00316	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  0031c	0f bf b4 08 86
	00 00 00	 movsx	 esi, WORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+134]
  00324	6a 28		 push	 40			; 00000028H
  00326	6a 0e		 push	 14			; 0000000eH
  00328	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0032d	83 c4 08	 add	 esp, 8
  00330	3b f0		 cmp	 esi, eax
  00332	0f 8f bc 00 00
	00		 jg	 $LN20@CGBuyReque
$LN17@CGBuyReque:

; 7997 : 				(ShopC[tShop].m_item[lpMsg->Pos].m_Type >= MAKE_ITEMNUM(14, 35) && ShopC[tShop].m_item[lpMsg->Pos].m_Type <= MAKE_ITEMNUM(14, 40)))
; 7998 : 			{
; 7999 : 				int dur = ShopC[tShop].m_item[lpMsg->Pos].m_Durability;

  00338	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  0033f	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00342	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00346	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  0034c	f3 0f 2c 94 08
	a4 00 00 00	 cvttss2si edx, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+164]
  00355	89 55 e0	 mov	 DWORD PTR _dur$2[ebp], edx

; 8000 : 
; 8001 : 				if (dur == 0)

  00358	83 7d e0 00	 cmp	 DWORD PTR _dur$2[ebp], 0
  0035c	75 07		 jne	 SHORT $LN19@CGBuyReque

; 8002 : 					dur = 1;

  0035e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _dur$2[ebp], 1
$LN19@CGBuyReque:

; 8003 : 
; 8004 : 				if (::gObjSearchItem(&gObj[aIndex], ShopC[tShop].m_item[lpMsg->Pos].m_Type, dur, ShopC[tShop].m_item[lpMsg->Pos].m_Level) == TRUE)

  00365	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  0036c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0036f	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00373	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00379	0f bf 94 08 88
	00 00 00	 movsx	 edx, WORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+136]
  00381	52		 push	 edx
  00382	8b 45 e0	 mov	 eax, DWORD PTR _dur$2[ebp]
  00385	50		 push	 eax
  00386	69 4d e8 14 52
	00 00		 imul	 ecx, DWORD PTR _tShop$[ebp], 21012
  0038d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00390	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00394	69 d0 a8 00 00
	00		 imul	 edx, eax, 168
  0039a	0f bf 84 11 86
	00 00 00	 movsx	 eax, WORD PTR ?ShopC@@3PAVCShop@@A[ecx+edx+134]
  003a2	50		 push	 eax
  003a3	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003aa	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b0	51		 push	 ecx
  003b1	e8 00 00 00 00	 call	 ?gObjSearchItem@@YAHPAVOBJECTSTRUCT@@HHH@Z ; gObjSearchItem
  003b6	83 c4 10	 add	 esp, 16			; 00000010H
  003b9	83 f8 01	 cmp	 eax, 1
  003bc	75 36		 jne	 SHORT $LN20@CGBuyReque

; 8005 : 				{
; 8006 : 					bNoItem = FALSE;

  003be	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bNoItem$3[ebp], 0

; 8007 : 					
; 8008 : 					if (lpObj->Money < 0)

  003c5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c8	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  003cf	7d 0d		 jge	 SHORT $LN21@CGBuyReque

; 8009 : 						lpObj->Money = 0;

  003d1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d4	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0
$LN21@CGBuyReque:

; 8010 : 
; 8011 : 
; 8012 : 					::GCMoneySend(aIndex, lpObj->Money);

  003de	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e1	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  003e7	51		 push	 ecx
  003e8	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  003eb	52		 push	 edx
  003ec	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  003f1	83 c4 08	 add	 esp, 8
$LN20@CGBuyReque:

; 8013 : 				}
; 8014 : 			}
; 8015 : 
; 8016 : 			if (bNoItem != FALSE)

  003f4	83 7d e4 00	 cmp	 DWORD PTR _bNoItem$3[ebp], 0
  003f8	0f 84 cc 01 00
	00		 je	 $LN23@CGBuyReque

; 8017 : 			{
; 8018 : 				pResult.Result = gObjShopBuyInventoryInsertItem(aIndex, ShopC[tShop].m_item[lpMsg->Pos]);

  003fe	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  00405	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00408	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0040c	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00412	8d b4 08 80 00
	00 00		 lea	 esi, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+128]
  00419	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0041f	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00424	8b fc		 mov	 edi, esp
  00426	f3 a5		 rep movsd
  00428	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0042b	52		 push	 edx
  0042c	e8 00 00 00 00	 call	 ?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjShopBuyInventoryInsertItem
  00431	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00437	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+3], al

; 8019 : 
; 8020 : 				if (pResult.Result != 0xFF)

  0043a	0f b6 45 ef	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  0043e	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00443	0f 84 81 01 00
	00		 je	 $LN23@CGBuyReque

; 8021 : 				{
; 8022 : 					ItemByteConvert((LPBYTE)&pResult.ItemInfo, ShopC[tShop].m_item[lpMsg->Pos]);

  00449	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  00450	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00453	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00457	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  0045d	8d b4 08 80 00
	00 00		 lea	 esi, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+128]
  00464	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0046a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0046f	8b fc		 mov	 edi, esp
  00471	f3 a5		 rep movsd
  00473	8d 55 f0	 lea	 edx, DWORD PTR _pResult$[ebp+4]
  00476	52		 push	 edx
  00477	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  0047c	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 8023 : 					int lc64 = ShopC[tShop].m_item[lpMsg->Pos].m_BuyMoney;

  00482	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  00489	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0048c	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00490	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00496	8b 94 08 e4 00
	00 00		 mov	 edx, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+228]
  0049d	89 55 dc	 mov	 DWORD PTR _lc64$1[ebp], edx

; 8024 : 
; 8025 : 					if (lpObj->Money < 0)

  004a0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004a3	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  004aa	7d 0d		 jge	 SHORT $LN24@CGBuyReque

; 8026 : 						lpObj->Money = 0;

  004ac	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004af	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0
$LN24@CGBuyReque:

; 8027 : 
; 8028 : 					if (lpObj->Money < 0) lpObj->Money = 0;

  004b9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004bc	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  004c3	7d 0d		 jge	 SHORT $LN25@CGBuyReque
  004c5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004c8	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0
$LN25@CGBuyReque:

; 8029 : 					GCMoneySend(aIndex, lpObj->Money);

  004d2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d5	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  004db	51		 push	 ecx
  004dc	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  004df	52		 push	 edx
  004e0	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  004e5	83 c4 08	 add	 esp, 8

; 8030 : 
; 8031 : 					LogAddTD("[%s][%s] (%d) Shop buy [%d][%d][%d][%s] LEV:%d, DUR:%d, OP:[%d][%d][%d]",

  004e8	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  004ef	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  004f2	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  004f6	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  004fc	0f b6 94 08 fa
	00 00 00	 movzx	 edx, BYTE PTR ?ShopC@@3PAVCShop@@A[eax+ecx+250]
  00504	52		 push	 edx
  00505	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  0050c	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0050f	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00513	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00519	0f b6 94 08 f9
	00 00 00	 movzx	 edx, BYTE PTR ?ShopC@@3PAVCShop@@A[eax+ecx+249]
  00521	52		 push	 edx
  00522	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  00529	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0052c	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00530	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00536	0f b6 94 08 f8
	00 00 00	 movzx	 edx, BYTE PTR ?ShopC@@3PAVCShop@@A[eax+ecx+248]
  0053e	52		 push	 edx
  0053f	69 45 e8 14 52
	00 00		 imul	 eax, DWORD PTR _tShop$[ebp], 21012
  00546	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00549	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0054d	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00553	f3 0f 5a 84 08
	a4 00 00 00	 cvtss2sd xmm0, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+ecx+164]
  0055c	83 ec 08	 sub	 esp, 8
  0055f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00564	69 55 e8 14 52
	00 00		 imul	 edx, DWORD PTR _tShop$[ebp], 21012
  0056b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0056e	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00572	69 c1 a8 00 00
	00		 imul	 eax, ecx, 168
  00578	0f bf 8c 02 88
	00 00 00	 movsx	 ecx, WORD PTR ?ShopC@@3PAVCShop@@A[edx+eax+136]
  00580	51		 push	 ecx
  00581	69 55 e8 14 52
	00 00		 imul	 edx, DWORD PTR _tShop$[ebp], 21012
  00588	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0058b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0058f	69 c1 a8 00 00
	00		 imul	 eax, ecx, 168
  00595	8d 8c 02 80 00
	00 00		 lea	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[edx+eax+128]
  0059c	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  005a1	50		 push	 eax
  005a2	6a 00		 push	 0
  005a4	6a 00		 push	 0
  005a6	8b 4d dc	 mov	 ecx, DWORD PTR _lc64$1[ebp]
  005a9	51		 push	 ecx
  005aa	8b 55 e8	 mov	 edx, DWORD PTR _tShop$[ebp]
  005ad	52		 push	 edx
  005ae	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b1	83 c0 73	 add	 eax, 115		; 00000073H
  005b4	50		 push	 eax
  005b5	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005b8	83 c1 68	 add	 ecx, 104		; 00000068H
  005bb	51		 push	 ecx
  005bc	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN@
  005c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005c7	83 c4 38	 add	 esp, 56			; 00000038H
$LN23@CGBuyReque:

; 8032 : 						lpObj->AccountID, lpObj->Name, tShop, lc64, 0, 0, ShopC[tShop].m_item[lpMsg->Pos].GetName(),
; 8033 : 						ShopC[tShop].m_item[lpMsg->Pos].m_Level, ShopC[tShop].m_item[lpMsg->Pos].m_Durability,
; 8034 : 						ShopC[tShop].m_item[lpMsg->Pos].m_Option1, ShopC[tShop].m_item[lpMsg->Pos].m_Option2,
; 8035 : 						ShopC[tShop].m_item[lpMsg->Pos].m_Option3);
; 8036 : 
; 8037 : 
; 8038 : 				}
; 8039 : 			}
; 8040 : 		}
; 8041 : 				}
; 8042 : 
; 8043 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  005ca	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  005ce	50		 push	 eax
  005cf	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  005d2	51		 push	 ecx
  005d3	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005d6	52		 push	 edx
  005d7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGBuyReque:

; 8044 : }

  005df	5f		 pop	 edi
  005e0	5e		 pop	 esi
  005e1	5b		 pop	 ebx
  005e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e5	33 cd		 xor	 ecx, ebp
  005e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005ec	8b e5		 mov	 esp, ebp
  005ee	5d		 pop	 ebp
  005ef	c3		 ret	 0
?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z ENDP	; CGBuyRequestRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z
_TEXT	SEGMENT
_size$1 = -1064						; size = 4
_ShopNum$ = -1060					; size = 4
_lOfs$ = -1056						; size = 4
_SendByte$ = -1052					; size = 1024
_pShopItemCount$ = -28					; size = 6
_pResult$ = -20						; size = 8
_DealerNumber$ = -12					; size = 4
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z PROC	; CGTalkRequestRecv, COMDAT

; 7556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 04 00
	00		 sub	 esp, 1256		; 000004e8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 7557 : 	LPOBJECTSTRUCT lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00016	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 7558 : 
; 7559 : 	if( PacketCheckTime(lpObj) == FALSE ) return;

  00026	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	75 05		 jne	 SHORT $LN2@CGTalkRequ
  00036	e9 ec 06 00 00	 jmp	 $LN1@CGTalkRequ
$LN2@CGTalkRequ:

; 7560 : 
; 7561 : 	//   ..
; 7562 : 	if( gObj[aIndex].CloseType != -1 )

  0003b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00048	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  0004d	83 fa ff	 cmp	 edx, -1
  00050	74 05		 je	 SHORT $LN3@CGTalkRequ

; 7563 : 	{
; 7564 : 		return;

  00052	e9 d0 06 00 00	 jmp	 $LN1@CGTalkRequ
$LN3@CGTalkRequ:

; 7565 : 	}
; 7566 : 	
; 7567 : #ifdef MODIFY_NPCTALK_REQUIREMENT_20051212
; 7568 : 	if( gObjIsConnectedGP(aIndex) == FALSE )

  00057	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00060	83 c4 04	 add	 esp, 4
  00063	85 c0		 test	 eax, eax
  00065	75 37		 jne	 SHORT $LN4@CGTalkRequ

; 7569 : 	{
; 7570 : 		LogAddTD("[ANTI-HACK][NPC Talk] Couldn't talk.. (%s)(%s)", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00067	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00074	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00078	52		 push	 edx
  00079	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00086	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0008a	52		 push	 edx
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5@
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7571 : 		return;

  00099	e9 89 06 00 00	 jmp	 $LN1@CGTalkRequ
$LN4@CGTalkRequ:

; 7572 : 	}
; 7573 : #endif
; 7574 : 
; 7575 : 	int					DealerNumber;
; 7576 : 	PMSG_TALKRESULT		pResult;
; 7577 : 	PMSG_SHOPITEMCOUNT	pShopItemCount;
; 7578 : 	BYTE				SendByte[1024];
; 7579 : 	int					lOfs=0;

  0009e	c7 85 e0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 7580 : 
; 7581 : 	//     
; 7582 : 	if( lpObj->m_IfState.use > 0 )

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ab	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000b1	80 e1 03	 and	 cl, 3
  000b4	0f b6 d1	 movzx	 edx, cl
  000b7	85 d2		 test	 edx, edx
  000b9	7e 05		 jle	 SHORT $LN5@CGTalkRequ

; 7583 : 	{
; 7584 : 		return;

  000bb	e9 67 06 00 00	 jmp	 $LN1@CGTalkRequ
$LN5@CGTalkRequ:

; 7585 : 	}
; 7586 : 	DealerNumber = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  000c0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000c3	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000c7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000cd	0f b6 d1	 movzx	 edx, cl
  000d0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000d3	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000d7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000dd	0f b6 c1	 movzx	 eax, cl
  000e0	c1 e0 08	 shl	 eax, 8
  000e3	0b d0		 or	 edx, eax
  000e5	0f b7 ca	 movzx	 ecx, dx
  000e8	89 4d f4	 mov	 DWORD PTR _DealerNumber$[ebp], ecx

; 7587 : 	
; 7588 : 	if( (DealerNumber < 0) || (DealerNumber > MAX_OBJECT-1) )

  000eb	83 7d f4 00	 cmp	 DWORD PTR _DealerNumber$[ebp], 0
  000ef	7c 09		 jl	 SHORT $LN7@CGTalkRequ
  000f1	81 7d f4 e7 1c
	00 00		 cmp	 DWORD PTR _DealerNumber$[ebp], 7399 ; 00001ce7H
  000f8	7e 05		 jle	 SHORT $LN6@CGTalkRequ
$LN7@CGTalkRequ:

; 7589 : 	{
; 7590 : 		//MsgBox(":   !! %s %d", __FILE__, __LINE__);
; 7591 : 		return;

  000fa	e9 28 06 00 00	 jmp	 $LN1@CGTalkRequ
$LN6@CGTalkRequ:

; 7592 : 	}
; 7593 : 
; 7594 : 	//    
; 7595 : 	if( lpObj->MapNumber != gObj[DealerNumber].MapNumber ) return;

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00102	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00109	69 55 f4 a0 1b
	00 00		 imul	 edx, DWORD PTR _DealerNumber$[ebp], 7072
  00110	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00115	0f b6 94 10 09
	01 00 00	 movzx	 edx, BYTE PTR [eax+edx+265]
  0011d	3b ca		 cmp	 ecx, edx
  0011f	74 05		 je	 SHORT $LN8@CGTalkRequ
  00121	e9 01 06 00 00	 jmp	 $LN1@CGTalkRequ
$LN8@CGTalkRequ:

; 7596 : 	
; 7597 : 	//      .
; 7598 : #ifdef ADD_KANTURU_20060627		//   NPC    
; 7599 : 	//   NPC      .
; 7600 : 	if( gObj[DealerNumber].Class  == NPC_KANTURU_MACHINE )
; 7601 : 	{
; 7602 : 		if( ( lpObj->X < gObj[DealerNumber].X - 5 ) || ( lpObj->X > gObj[DealerNumber].X + 5 ) || 
; 7603 : 			( lpObj->Y < gObj[DealerNumber].Y - 10 ) || ( lpObj->Y > gObj[DealerNumber].Y + 5 ) )
; 7604 : 			return;
; 7605 : 	}
; 7606 : 	else
; 7607 : #endif	
; 7608 : 	if( (lpObj->X < gObj[DealerNumber].X-5) || (lpObj->X > gObj[DealerNumber].X+5) || 
; 7609 : 		(lpObj->Y < gObj[DealerNumber].Y-5) || (lpObj->Y > gObj[DealerNumber].Y+5))

  00126	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00129	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00130	69 55 f4 a0 1b
	00 00		 imul	 edx, DWORD PTR _DealerNumber$[ebp], 7072
  00137	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013c	0f bf 94 10 04
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+260]
  00144	83 ea 05	 sub	 edx, 5
  00147	3b ca		 cmp	 ecx, edx
  00149	7c 6f		 jl	 SHORT $LN10@CGTalkRequ
  0014b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00155	69 55 f4 a0 1b
	00 00		 imul	 edx, DWORD PTR _DealerNumber$[ebp], 7072
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00161	0f bf 94 10 04
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+260]
  00169	83 c2 05	 add	 edx, 5
  0016c	3b ca		 cmp	 ecx, edx
  0016e	7f 4a		 jg	 SHORT $LN10@CGTalkRequ
  00170	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00173	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0017a	69 55 f4 a0 1b
	00 00		 imul	 edx, DWORD PTR _DealerNumber$[ebp], 7072
  00181	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00186	0f bf 94 10 06
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+262]
  0018e	83 ea 05	 sub	 edx, 5
  00191	3b ca		 cmp	 ecx, edx
  00193	7c 25		 jl	 SHORT $LN10@CGTalkRequ
  00195	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00198	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0019f	69 55 f4 a0 1b
	00 00		 imul	 edx, DWORD PTR _DealerNumber$[ebp], 7072
  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ab	0f bf 94 10 06
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+262]
  001b3	83 c2 05	 add	 edx, 5
  001b6	3b ca		 cmp	 ecx, edx
  001b8	7e 05		 jle	 SHORT $LN9@CGTalkRequ
$LN10@CGTalkRequ:

; 7610 : 	{
; 7611 : 		return;

  001ba	e9 68 05 00 00	 jmp	 $LN1@CGTalkRequ
$LN9@CGTalkRequ:

; 7612 : 	}
; 7613 : 	//  
; 7614 : 	//
; 7615 : 	int ShopNum = gObj[DealerNumber].ShopNumber;

  001bf	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _DealerNumber$[ebp], 7072
  001c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cc	0f bf 94 01 b0
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+688]
  001d4	89 95 dc fb ff
	ff		 mov	 DWORD PTR _ShopNum$[ebp], edx

; 7616 : 
; 7617 : 	if( gObj[DealerNumber].Type == OBJTYPE_NPC )

  001da	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _DealerNumber$[ebp], 7072
  001e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e7	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  001ec	83 fa 03	 cmp	 edx, 3
  001ef	75 24		 jne	 SHORT $LN11@CGTalkRequ

; 7618 : 	{
; 7619 : 		if( NpcTalk(&gObj[DealerNumber], lpObj) == 1 ) return;

  001f1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f4	50		 push	 eax
  001f5	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _DealerNumber$[ebp], 7072
  001fc	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 ?NpcTalk@@YAHPAVOBJECTSTRUCT@@0@Z ; NpcTalk
  00208	83 c4 08	 add	 esp, 8
  0020b	83 f8 01	 cmp	 eax, 1
  0020e	75 05		 jne	 SHORT $LN11@CGTalkRequ
  00210	e9 12 05 00 00	 jmp	 $LN1@CGTalkRequ
$LN11@CGTalkRequ:

; 7620 : 	}
; 7621 : 
; 7622 : 	//   /    
; 7623 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719		//    -  ,  ,   
; 7624 : 	if (gObjFixInventoryPointer(aIndex) == false) {

  00215	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0021e	83 c4 04	 add	 esp, 4
  00221	0f b6 c8	 movzx	 ecx, al
  00224	85 c9		 test	 ecx, ecx
  00226	75 1c		 jne	 SHORT $LN13@CGTalkRequ

; 7625 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00228	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z@4JA
  0022d	83 c0 45	 add	 eax, 69			; 00000045H
  00230	50		 push	 eax
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00236	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00241	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@CGTalkRequ:

; 7626 : 	}
; 7627 : #endif
; 7628 : 
; 7629 : #ifdef GAMESERVER_DIVISION
; 7630 : 	if( gObj[DealerNumber].Class == 234 )
; 7631 : 	{
; 7632 : 		pResult.h.c				= PMHCE_BYTE;
; 7633 : 		pResult.h.headcode		= 0x30;
; 7634 : 		pResult.h.size			= sizeof( pResult );
; 7635 : 		pResult.result			= 0x00;
; 7636 : 		pResult.result			= 0x05;		
; 7637 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 7638 : 		return;
; 7639 : 	}
; 7640 : #endif
; 7641 : 
; 7642 : 	if( (gObj[DealerNumber].Type == OBJTYPE_NPC) && (ShopNum < 0) ) 

  00244	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _DealerNumber$[ebp], 7072
  0024b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00251	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00256	83 fa 03	 cmp	 edx, 3
  00259	75 0e		 jne	 SHORT $LN14@CGTalkRequ
  0025b	83 bd dc fb ff
	ff 00		 cmp	 DWORD PTR _ShopNum$[ebp], 0
  00262	7d 05		 jge	 SHORT $LN14@CGTalkRequ

; 7643 : 	{	//  ..
; 7644 : 		return;

  00264	e9 be 04 00 00	 jmp	 $LN1@CGTalkRequ
$LN14@CGTalkRequ:

; 7645 : 	}
; 7646 : 
; 7647 : #ifdef ADD_SHOP_11_12
; 7648 : 	if( ShopNum < MAX_SHOP )	//  ..	

  00269	83 bd dc fb ff
	ff 0d		 cmp	 DWORD PTR _ShopNum$[ebp], 13 ; 0000000dH
  00270	0f 8d 13 01 00
	00		 jge	 $LN15@CGTalkRequ

; 7649 : #else
; 7650 : 	if( ShopNum < 11 )	//  ..
; 7651 : #endif
; 7652 : 	{
; 7653 : 		//   
; 7654 : 		if( ShopC[ShopNum].ItemCount < 1 ) 

  00276	69 85 dc fb ff
	ff 14 52 00 00	 imul	 eax, DWORD PTR _ShopNum$[ebp], 21012
  00280	83 b8 7c 00 00
	00 01		 cmp	 DWORD PTR ?ShopC@@3PAVCShop@@A[eax+124], 1
  00287	7d 72		 jge	 SHORT $LN16@CGTalkRequ

; 7655 : 		{
; 7656 : 			if( rand()%2 )

  00289	e8 00 00 00 00	 call	 _rand
  0028e	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00293	79 05		 jns	 SHORT $LN40@CGTalkRequ
  00295	48		 dec	 eax
  00296	83 c8 fe	 or	 eax, -2			; fffffffeH
  00299	40		 inc	 eax
$LN40@CGTalkRequ:
  0029a	85 c0		 test	 eax, eax
  0029c	74 2d		 je	 SHORT $LN17@CGTalkRequ

; 7657 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(1143), aIndex);	//   ~

  0029e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002a1	50		 push	 eax
  002a2	68 77 04 00 00	 push	 1143			; 00000477H
  002a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002b2	50		 push	 eax
  002b3	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _DealerNumber$[ebp], 7072
  002ba	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c0	51		 push	 ecx
  002c1	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  002c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c9	eb 2b		 jmp	 SHORT $LN18@CGTalkRequ
$LN17@CGTalkRequ:

; 7658 : 			else ChatTargetSend(&gObj[DealerNumber], lMsg.Get(1144), aIndex);	//    

  002cb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002ce	50		 push	 eax
  002cf	68 78 04 00 00	 push	 1144			; 00000478H
  002d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002df	50		 push	 eax
  002e0	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _DealerNumber$[ebp], 7072
  002e7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ed	51		 push	 ecx
  002ee	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  002f3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CGTalkRequ:

; 7659 : 			return;

  002f6	e9 2c 04 00 00	 jmp	 $LN1@CGTalkRequ
$LN16@CGTalkRequ:

; 7660 : 		}
; 7661 : 		
; 7662 : 
; 7663 : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 7664 : 		if (!gPkLimitFree) {

  002fb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00302	0f 85 81 00 00
	00		 jne	 $LN15@CGTalkRequ

; 7665 : #endif
; 7666 : 		// PK ..
; 7667 : #ifdef UPDATE_PK_SYSTEM_20070302	//   
; 7668 : 		BOOL	PKFlag = FALSE;
; 7669 : 		if(lpObj->PartyNumber >= 0)	//  
; 7670 : 		{
; 7671 : 			if( gParty.GetPKPartyPenalty(lpObj->PartyNumber) > PK_LEVEL_DEFAULT+1)
; 7672 : 			{
; 7673 : 				PKFlag = TRUE;
; 7674 : 			}
; 7675 : 		}
; 7676 : 		else
; 7677 : 		{
; 7678 : 			if(lpObj->m_PK_Level > PK_LEVEL_DEFAULT+1)
; 7679 : 			{
; 7680 : 				PKFlag = TRUE;
; 7681 : 			}
; 7682 : 		}
; 7683 : 		
; 7684 : 		if(PKFlag == TRUE)
; 7685 : #else
; 7686 : 		if( lpObj->m_PK_Level > PK_LEVEL_DEFAULT+1 )

  00308	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030b	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00312	83 f9 04	 cmp	 ecx, 4
  00315	7e 72		 jle	 SHORT $LN15@CGTalkRequ

; 7687 : #endif
; 7688 : 		{
; 7689 : 			if( rand()%2 )

  00317	e8 00 00 00 00	 call	 _rand
  0031c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00321	79 05		 jns	 SHORT $LN41@CGTalkRequ
  00323	48		 dec	 eax
  00324	83 c8 fe	 or	 eax, -2			; fffffffeH
  00327	40		 inc	 eax
$LN41@CGTalkRequ:
  00328	85 c0		 test	 eax, eax
  0032a	74 2d		 je	 SHORT $LN21@CGTalkRequ

; 7690 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(1145), aIndex);	//    ..

  0032c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0032f	50		 push	 eax
  00330	68 79 04 00 00	 push	 1145			; 00000479H
  00335	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0033a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00340	50		 push	 eax
  00341	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _DealerNumber$[ebp], 7072
  00348	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0034e	51		 push	 ecx
  0034f	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  00354	83 c4 0c	 add	 esp, 12			; 0000000cH
  00357	eb 2b		 jmp	 SHORT $LN22@CGTalkRequ
$LN21@CGTalkRequ:

; 7691 : 			else ChatTargetSend(&gObj[DealerNumber], lMsg.Get(1146), aIndex);	//    ..   

  00359	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0035c	50		 push	 eax
  0035d	68 7a 04 00 00	 push	 1146			; 0000047aH
  00362	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00367	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0036d	50		 push	 eax
  0036e	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _DealerNumber$[ebp], 7072
  00375	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0037b	51		 push	 ecx
  0037c	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  00381	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@CGTalkRequ:

; 7692 : 			return;

  00384	e9 9e 03 00 00	 jmp	 $LN1@CGTalkRequ
$LN15@CGTalkRequ:

; 7693 : 		}
; 7694 : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 7695 : 		}
; 7696 : #endif
; 7697 : 	}
; 7698 : 
; 7699 : 
; 7700 : 	if( gMerryXMasNpcEvent == 1)

  00389	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gMerryXMasNpcEvent@@3HA, 1 ; gMerryXMasNpcEvent
  00390	75 3c		 jne	 SHORT $LN23@CGTalkRequ

; 7701 : 	{
; 7702 : 		if( rand()%6 == 0 )

  00392	e8 00 00 00 00	 call	 _rand
  00397	99		 cdq
  00398	b9 06 00 00 00	 mov	 ecx, 6
  0039d	f7 f9		 idiv	 ecx
  0039f	85 d2		 test	 edx, edx
  003a1	75 2b		 jne	 SHORT $LN23@CGTalkRequ

; 7703 : 			ChatTargetSend(&gObj[DealerNumber], lMsg.Get(1147), aIndex);	//  !!

  003a3	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003a6	50		 push	 eax
  003a7	68 7b 04 00 00	 push	 1147			; 0000047bH
  003ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003b7	50		 push	 eax
  003b8	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _DealerNumber$[ebp], 7072
  003bf	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003c5	51		 push	 ecx
  003c6	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  003cb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN23@CGTalkRequ:

; 7704 : 	}
; 7705 : 	
; 7706 : 	if( gHappyNewYearNpcEvent == 1 )

  003ce	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gHappyNewYearNpcEvent@@3HA, 1 ; gHappyNewYearNpcEvent
  003d5	75 3c		 jne	 SHORT $LN25@CGTalkRequ

; 7707 : 	{
; 7708 : 		if( rand()%6 == 0 )

  003d7	e8 00 00 00 00	 call	 _rand
  003dc	99		 cdq
  003dd	b9 06 00 00 00	 mov	 ecx, 6
  003e2	f7 f9		 idiv	 ecx
  003e4	85 d2		 test	 edx, edx
  003e6	75 2b		 jne	 SHORT $LN25@CGTalkRequ

; 7709 : 			ChatTargetSend(&gObj[DealerNumber], lMsg.Get(1148), aIndex);	//    ~

  003e8	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003eb	50		 push	 eax
  003ec	68 7c 04 00 00	 push	 1148			; 0000047cH
  003f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003fc	50		 push	 eax
  003fd	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _DealerNumber$[ebp], 7072
  00404	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0040a	51		 push	 ecx
  0040b	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  00410	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@CGTalkRequ:

; 7710 : 	}
; 7711 : 		
; 7712 : 	lpObj->TargetShopNumber = ShopNum;

  00413	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00416	66 8b 8d dc fb
	ff ff		 mov	 cx, WORD PTR _ShopNum$[ebp]
  0041d	66 89 88 ae 02
	00 00		 mov	 WORD PTR [eax+686], cx

; 7713 : 	lpObj->m_IfState.use    = 1;

  00424	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00427	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0042d	80 e1 fc	 and	 cl, 252			; 000000fcH
  00430	80 c9 01	 or	 cl, 1
  00433	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00436	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 7714 : 	lpObj->m_IfState.type   = I_SHOP;

  0043c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0043f	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00445	80 e1 0f	 and	 cl, 15			; 0000000fH
  00448	80 c9 30	 or	 cl, 48			; 00000030H
  0044b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0044e	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 7715 : 	lpObj->m_ShopTime		= 0;

  00454	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00457	c6 80 ec 01 00
	00 00		 mov	 BYTE PTR [eax+492], 0

; 7716 : 
; 7717 : 	pResult.h.c				= PMHCE_BYTE;

  0045e	c6 45 ec c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 7718 : 	pResult.h.headcode		= 0x30;

  00462	c6 45 ee 30	 mov	 BYTE PTR _pResult$[ebp+2], 48 ; 00000030H

; 7719 : 	pResult.h.size			= sizeof( pResult );

  00466	c6 45 ed 08	 mov	 BYTE PTR _pResult$[ebp+1], 8

; 7720 : 	
; 7721 : #ifdef ADD_GAMBLING_20090120
; 7722 : 	if( ShopNum == 18 )		//    0x22
; 7723 : 		pResult.result		= 0x22;
; 7724 : 	else					//   0x00
; 7725 : 		pResult.result		= 0x00;
; 7726 : #else // ADD_GAMBLING_20090120
; 7727 : 	pResult.result			= 0x00;

  0046a	c6 45 ef 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 7728 : #endif // ADD_GAMBLING_20090120
; 7729 : 	
; 7730 : #ifdef ADD_IS_ENABLED_GAMBLING_20090504
; 7731 : 	if( ShopNum == 18 && g_bGamblingSystem == FALSE )
; 7732 : 	{	//      
; 7733 : 		return;
; 7734 : 	}
; 7735 : #endif // ADD_IS_ENABLED_GAMBLING_20090504
; 7736 : 
; 7737 : #ifdef ADD_SHOP_11_12
; 7738 : 	if( ShopNum == 100 )	//  

  0046e	83 bd dc fb ff
	ff 64		 cmp	 DWORD PTR _ShopNum$[ebp], 100 ; 00000064H
  00475	75 65		 jne	 SHORT $LN27@CGTalkRequ

; 7739 : #else
; 7740 : 	if( ShopNum == 11 )		//  
; 7741 : #endif
; 7742 : 	{
; 7743 : #ifdef WAREHOUSE_ITEMCOPY_BUG_FIX
; 7744 : 		if( gObj[aIndex].m_ReqWarehouseOpen )

  00477	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0047e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00484	0f b6 94 01 24
	0f 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3876]
  0048c	85 d2		 test	 edx, edx
  0048e	74 05		 je	 SHORT $LN29@CGTalkRequ

; 7745 : 			return;			//         

  00490	e9 92 02 00 00	 jmp	 $LN1@CGTalkRequ
$LN29@CGTalkRequ:

; 7746 : 		
; 7747 : 		gObj[aIndex].m_ReqWarehouseOpen = 1;

  00495	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0049c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004a2	c6 84 01 24 0f
	00 00 01	 mov	 BYTE PTR [ecx+eax+3876], 1

; 7748 : #endif
; 7749 : 		
; 7750 : 		lpObj->m_IfState.type   = I_WAREHOUSE;

  004aa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004ad	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  004b3	80 e1 0f	 and	 cl, 15			; 0000000fH
  004b6	80 c9 60	 or	 cl, 96			; 00000060H
  004b9	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004bc	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 7751 : 		lpObj->m_IfState.state	= 0;

  004c2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004c5	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  004cb	80 e1 f3	 and	 cl, 243			; 000000f3H
  004ce	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004d1	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 7752 : 	}

  004d7	e9 34 01 00 00	 jmp	 $LN28@CGTalkRequ
$LN27@CGTalkRequ:

; 7753 : #ifdef ADD_SHOP_11_12
; 7754 : 	else if( ShopNum == 101 )	//   12 -> 101 

  004dc	83 bd dc fb ff
	ff 65		 cmp	 DWORD PTR _ShopNum$[ebp], 101 ; 00000065H
  004e3	0f 85 12 01 00
	00		 jne	 $LN30@CGTalkRequ

; 7755 : #else
; 7756 : 	else if( ShopNum == 12 )
; 7757 : #endif
; 7758 : 	{	//  
; 7759 : 		if( bCanChaosBox == TRUE )

  004e9	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanChaosBox@@3HA, 1 ; bCanChaosBox
  004f0	0f 85 03 01 00
	00		 jne	 $LN33@CGTalkRequ

; 7760 : 		{
; 7761 : #ifdef PERSONAL_SHOP_20040113		//         .
; 7762 : 			if (lpObj->m_bPShopOpen == true) {

  004f6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f9	0f b6 88 f8 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3320]
  00500	83 f9 01	 cmp	 ecx, 1
  00503	75 42		 jne	 SHORT $LN34@CGTalkRequ

; 7763 : 				LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed", lpObj->AccountID, lpObj->Name);

  00505	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00508	83 c0 73	 add	 eax, 115		; 00000073H
  0050b	50		 push	 eax
  0050c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0050f	83 c1 68	 add	 ecx, 104		; 00000068H
  00512	51		 push	 ecx
  00513	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSh@
  00518	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0051e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7764 : 				GCServerMsgStringSend(lMsg.Get(1218), lpObj->m_Index, 1);		// "       ."

  00521	6a 01		 push	 1
  00523	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00526	8b 08		 mov	 ecx, DWORD PTR [eax]
  00528	51		 push	 ecx
  00529	68 c2 04 00 00	 push	 1218			; 000004c2H
  0052e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00533	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00539	50		 push	 eax
  0053a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0053f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7765 : 				return;

  00542	e9 e0 01 00 00	 jmp	 $LN1@CGTalkRequ
$LN34@CGTalkRequ:

; 7766 : 			}
; 7767 : #endif
; 7768 : 
; 7769 : 			lpObj->m_IfState.type   = I_CHAOSBOX;

  00547	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0054a	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00550	80 e1 0f	 and	 cl, 15			; 0000000fH
  00553	80 c9 70	 or	 cl, 112			; 00000070H
  00556	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00559	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 7770 : 			lpObj->m_IfState.state	= 0;

  0055f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00562	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00568	80 e1 f3	 and	 cl, 243			; 000000f3H
  0056b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0056e	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 7771 : 
; 7772 : 			pResult.result     = 0x03;

  00574	c6 45 ef 03	 mov	 BYTE PTR _pResult$[ebp+3], 3

; 7773 : #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 7774 : 			if (gObj[DealerNumber].Class == NPC_CHERRY)
; 7775 : 				pResult.result     = 0x16;
; 7776 : #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 7777 : 
; 7778 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029
; 7779 : 			if (gObj[DealerNumber].Class == NPC_DELGADO)
; 7780 : 				pResult.result     = 0x20;
; 7781 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029
; 7782 : 			
; 7783 : #ifdef CHAOS_MIX_TRANSACTION_BUXFIX_20040610
; 7784 : 			lpObj->bIsChaosMixCompleted = false;			//    '   '   

  00578	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057b	c6 80 81 10 00
	00 00		 mov	 BYTE PTR [eax+4225], 0

; 7785 : #endif
; 7786 : 
; 7787 : 			//     
; 7788 : 			pResult.level1	= gDQChaosSuccessRateLevel1;

  00582	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel1@@3HA
  00587	88 45 f0	 mov	 BYTE PTR _pResult$[ebp+4], al

; 7789 : 			pResult.level2	= gDQChaosSuccessRateLevel2;

  0058a	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel2@@3HA
  0058f	88 45 f1	 mov	 BYTE PTR _pResult$[ebp+5], al

; 7790 : 			pResult.level3	= gDQChaosSuccessRateLevel3;

  00592	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel3@@3HA
  00597	88 45 f2	 mov	 BYTE PTR _pResult$[ebp+6], al

; 7791 : 			pResult.level4	= gDQChaosSuccessRateLevel4;

  0059a	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel4@@3HA
  0059f	88 45 f3	 mov	 BYTE PTR _pResult$[ebp+7], al

; 7792 : #ifdef DEVILSQUARE_EXTEND_20050221		// !!! .  ->   
; 7793 : 			pResult.level5	= gDQChaosSuccessRateLevel5;
; 7794 : 			pResult.level6	= gDQChaosSuccessRateLevel6;
; 7795 : #endif
; 7796 : #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010	// PMSG_TALKRESULT 7  
; 7797 : 			pResult.level7	= gDQChaosSuccessRateLevel7;
; 7798 : #endif
; 7799 : 
; 7800 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  005a2	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  005a6	50		 push	 eax
  005a7	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  005aa	51		 push	 ecx
  005ab	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005ae	52		 push	 edx
  005af	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7801 : 
; 7802 : 			gObjInventoryTrans(lpObj->m_Index);

  005b7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  005bc	51		 push	 ecx
  005bd	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  005c2	83 c4 04	 add	 esp, 4

; 7803 : 			LogAddTD("[%s][%s] Open Chaos Box", lpObj->AccountID, lpObj->Name);

  005c5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005c8	83 c0 73	 add	 eax, 115		; 00000073H
  005cb	50		 push	 eax
  005cc	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005cf	83 c1 68	 add	 ecx, 104		; 00000068H
  005d2	51		 push	 ecx
  005d3	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box@
  005d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7804 : 			gObjItemTextSave(lpObj);

  005e1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005e4	50		 push	 eax
  005e5	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAVOBJECTSTRUCT@@@Z ; gObjItemTextSave
  005ea	83 c4 04	 add	 esp, 4

; 7805 : 			gObjWarehouseTextSave(lpObj);

  005ed	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f0	50		 push	 eax
  005f1	e8 00 00 00 00	 call	 ?gObjWarehouseTextSave@@YAXPAVOBJECTSTRUCT@@@Z ; gObjWarehouseTextSave
  005f6	83 c4 04	 add	 esp, 4
$LN33@CGTalkRequ:

; 7806 : 
; 7807 : #ifdef MU_CASTLESIEGE_TAX_SYSTEM_20041219		//    ()  .
; 7808 : #ifdef MU_CASTLESIEGE_SERVER_SYNC_20041130
; 7809 : 			GCAnsCsMapSvrTaxInfo (lpObj->m_Index, 1, g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index));
; 7810 : #endif
; 7811 : #endif
; 7812 : 		}
; 7813 : 		else 
; 7814 : 		{
; 7815 : 		}
; 7816 : 	}	

  005f9	eb 15		 jmp	 SHORT $LN28@CGTalkRequ
$LN30@CGTalkRequ:

; 7817 : 	else 
; 7818 : 	{
; 7819 : 		//  ...   .. 
; 7820 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  005fb	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  005ff	50		 push	 eax
  00600	8d 4d ec	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00603	51		 push	 ecx
  00604	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00607	52		 push	 edx
  00608	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0060d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@CGTalkRequ:

; 7821 : 	}
; 7822 : 	
; 7823 : #ifdef ADD_SHOP_11_12
; 7824 : 	if( ShopNum == 100 )	//     .

  00610	83 bd dc fb ff
	ff 64		 cmp	 DWORD PTR _ShopNum$[ebp], 100 ; 00000064H
  00617	75 38		 jne	 SHORT $LN35@CGTalkRequ

; 7825 : #else
; 7826 : 	if( ShopNum == 11 )	//     .
; 7827 : #endif
; 7828 : 	{
; 7829 : 		gObj[aIndex].WarehouseCount = 0;		//     

  00619	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00620	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00626	c6 84 01 9c 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3228], 0

; 7830 : 		GDGetWarehouseList(aIndex, gObj[aIndex].AccountID);

  0062e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00635	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0063b	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0063f	52		 push	 edx
  00640	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00643	50		 push	 eax
  00644	e8 00 00 00 00	 call	 ?GDGetWarehouseList@@YAXHPAD@Z ; GDGetWarehouseList
  00649	83 c4 08	 add	 esp, 8

; 7831 : 	}

  0064c	e9 d6 00 00 00	 jmp	 $LN1@CGTalkRequ
$LN35@CGTalkRequ:

; 7832 : #ifdef ADD_SHOP_11_12
; 7833 : 	else if( ShopNum == 101 )

  00651	83 bd dc fb ff
	ff 65		 cmp	 DWORD PTR _ShopNum$[ebp], 101 ; 00000065H
  00658	75 05		 jne	 SHORT $LN37@CGTalkRequ

; 7834 : #else
; 7835 : 	else if( ShopNum == 12 )
; 7836 : #endif
; 7837 : 	{	
; 7838 : 	}

  0065a	e9 c8 00 00 00	 jmp	 $LN1@CGTalkRequ
$LN37@CGTalkRequ:

; 7839 : 	else
; 7840 : 	{
; 7841 : 		//    .
; 7842 : 		lOfs  = 0;

  0065f	c7 85 e0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 7843 : 		lOfs += sizeof( pShopItemCount );

  00669	8b 85 e0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0066f	83 c0 06	 add	 eax, 6
  00672	89 85 e0 fb ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 7844 : 		int size = lOfs+ShopC[ShopNum].SendItemDataLen;

  00678	69 85 dc fb ff
	ff 14 52 00 00	 imul	 eax, DWORD PTR _ShopNum$[ebp], 21012
  00682	8b 8d e0 fb ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00688	03 88 10 52 00
	00		 add	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+21008]
  0068e	89 8d d8 fb ff
	ff		 mov	 DWORD PTR _size$1[ebp], ecx

; 7845 : 				
; 7846 : 		PHeadSetW((LPBYTE)&pShopItemCount, 0x31, size);

  00694	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _size$1[ebp]
  0069a	50		 push	 eax
  0069b	6a 31		 push	 49			; 00000031H
  0069d	8d 4d e4	 lea	 ecx, DWORD PTR _pShopItemCount$[ebp]
  006a0	51		 push	 ecx
  006a1	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  006a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7847 : 
; 7848 : 		pShopItemCount.Type			= 0;

  006a9	c6 45 e8 00	 mov	 BYTE PTR _pShopItemCount$[ebp+4], 0

; 7849 : 		pShopItemCount.count		= ShopC[ShopNum].ItemCount;

  006ad	69 85 dc fb ff
	ff 14 52 00 00	 imul	 eax, DWORD PTR _ShopNum$[ebp], 21012
  006b7	8a 88 7c 00 00
	00		 mov	 cl, BYTE PTR ?ShopC@@3PAVCShop@@A[eax+124]
  006bd	88 4d e9	 mov	 BYTE PTR _pShopItemCount$[ebp+5], cl

; 7850 : 		memcpy(SendByte, &pShopItemCount, sizeof( pShopItemCount ));

  006c0	6a 06		 push	 6
  006c2	8d 45 e4	 lea	 eax, DWORD PTR _pShopItemCount$[ebp]
  006c5	50		 push	 eax
  006c6	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  006cc	51		 push	 ecx
  006cd	e8 00 00 00 00	 call	 _memcpy
  006d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7851 : 		memcpy(SendByte+lOfs, ShopC[ShopNum].SendItemData, ShopC[ShopNum].SendItemDataLen);

  006d5	69 85 dc fb ff
	ff 14 52 00 00	 imul	 eax, DWORD PTR _ShopNum$[ebp], 21012
  006df	8b 88 10 52 00
	00		 mov	 ecx, DWORD PTR ?ShopC@@3PAVCShop@@A[eax+21008]
  006e5	51		 push	 ecx
  006e6	69 95 dc fb ff
	ff 14 52 00 00	 imul	 edx, DWORD PTR _ShopNum$[ebp], 21012
  006f0	81 c2 40 4f 00
	00		 add	 edx, OFFSET ?ShopC@@3PAVCShop@@A+20288
  006f6	52		 push	 edx
  006f7	8b 85 e0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  006fd	8d 8c 05 e4 fb
	ff ff		 lea	 ecx, DWORD PTR _SendByte$[ebp+eax]
  00704	51		 push	 ecx
  00705	e8 00 00 00 00	 call	 _memcpy
  0070a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7852 : 
; 7853 : 		DataSend(aIndex, (LPBYTE)SendByte, size);

  0070d	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _size$1[ebp]
  00713	50		 push	 eax
  00714	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  0071a	51		 push	 ecx
  0071b	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0071e	52		 push	 edx
  0071f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00724	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGTalkRequ:

; 7854 : 
; 7855 : #ifdef MU_CASTLESIEGE_TAX_SYSTEM_20041219		//    ()  .
; 7856 : #ifdef MU_CASTLESIEGE_SERVER_SYNC_20041130
; 7857 : 		GCAnsCsMapSvrTaxInfo (lpObj->m_Index, 2, g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index));
; 7858 : #endif
; 7859 : #endif
; 7860 : 	}
; 7861 : }

  00727	5f		 pop	 edi
  00728	5e		 pop	 esi
  00729	5b		 pop	 ebx
  0072a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0072d	33 cd		 xor	 ecx, ebp
  0072f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00734	8b e5		 mov	 esp, ebp
  00736	5d		 pop	 ebp
  00737	c3		 ret	 0
?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z ENDP	; CGTalkRequestRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z
_TEXT	SEGMENT
_pCRequest$ = -44					; size = 28
__name$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z PROC ; CGPCharacterMapJoinRequest, COMDAT

; 3695 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3696 : 	char _name[MAX_IDSTRING+1];
; 3697 : 
; 3698 : 	//        
; 3699 : #ifdef MODIFY_CASTLE_MAP_MOVE_TRACE_LOG_20080418
; 3700 : 	LogAddTD( "[BUGTRACE][CGPCharacterMapJoinRequest] (%d) ID : %s, Name : %s(%s), MapMove : %d, MapIndex : %d, ConnectState : %d",
; 3701 : 		aIndex, gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->Name, gObj[aIndex].m_bMapSvrMoveReq, gObj[aIndex].MapNumber, gObj[aIndex].Connected );
; 3702 : #endif // MODIFY_CASTLE_MAP_MOVE_TRACE_LOG_20080418	
; 3703 : 
; 3704 : 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;

  00013	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN2@CGPCharact
  0002d	e9 2e 01 00 00	 jmp	 $LN1@CGPCharact
$LN2@CGPCharact:

; 3705 : 	if( gObjIsAccontConnect(aIndex,gObj[aIndex].AccountID)  == FALSE ) return;

  00032	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003f	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00043	52		 push	 edx
  00044	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0004d	83 c4 08	 add	 esp, 8
  00050	85 c0		 test	 eax, eax
  00052	75 05		 jne	 SHORT $LN3@CGPCharact
  00054	e9 07 01 00 00	 jmp	 $LN1@CGPCharact
$LN3@CGPCharact:

; 3706 : 	if( gObj[aIndex].Connected == CSS_GAMEPLAYING )	//

  00059	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00066	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0006b	75 05		 jne	 SHORT $LN4@CGPCharact

; 3707 : 	{
; 3708 : 		return;

  0006d	e9 ee 00 00 00	 jmp	 $LN1@CGPCharact
$LN4@CGPCharact:

; 3709 : 	}
; 3710 : 
; 3711 : #ifdef UPDATE_RESEND_GETCHARlIST_DISABLE_20090605
; 3712 : 	if( gObj[aIndex].m_bRequestPaket == TRUE )
; 3713 : 	{
; 3714 : 		//LogAdd("ReSend CharacterList (%s)", gObj[aIndex].Name);
; 3715 : 		gObj[aIndex].m_nRequestPacketCnt++;
; 3716 : 		if(gObj[aIndex].m_nRequestPacketCnt > 7)
; 3717 : 		{
; 3718 : 			//   
; 3719 : 			//GJRequestBlockIp(gObj[aIndex].Ip_addr);
; 3720 : 			
; 3721 : 			//  
; 3722 : 			LogAdd("ReSend JoinMap CloseUser (%s)", gObj[aIndex].Name);
; 3723 : 			CloseClient ( aIndex );
; 3724 : 			return;
; 3725 : 		}
; 3726 : 	}
; 3727 : 	
; 3728 : 	gObj[aIndex].m_bRequestPaket = TRUE;
; 3729 : #endif	// UPDATE_RESEND_GETCHARlIST_DISABLE_20090605
; 3730 : 	
; 3731 : #ifdef BLOCK_INVALID_CHARACTER_DELETE_01_20060327
; 3732 : 	gObj[aIndex].bEnableDelCharacter = FALSE;

  00072	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007f	c7 44 01 0c 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+12], 0

; 3733 : #endif
; 3734 : 
; 3735 : 	SDHP_DBCHARINFOREQUEST	pCRequest;
; 3736 : 
; 3737 : 	PHeadSetB((LPBYTE)&pCRequest, 0x06, sizeof( pCRequest ));

  00087	6a 1c		 push	 28			; 0000001cH
  00089	6a 06		 push	 6
  0008b	8d 45 d4	 lea	 eax, DWORD PTR _pCRequest$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3738 : 	
; 3739 : 	memset(_name, 0, MAX_IDSTRING);

  00097	6a 0a		 push	 10			; 0000000aH
  00099	6a 00		 push	 0
  0009b	8d 45 f0	 lea	 eax, DWORD PTR __name$[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 _memset
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3740 : 	memcpy(_name, lpMsg->Name, MAX_IDSTRING);

  000a7	6a 0a		 push	 10			; 0000000aH
  000a9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000ac	83 c0 04	 add	 eax, 4
  000af	50		 push	 eax
  000b0	8d 4d f0	 lea	 ecx, DWORD PTR __name$[ebp]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 _memcpy
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3741 : 	BuxConvert(_name, MAX_IDSTRING);

  000bc	6a 0a		 push	 10			; 0000000aH
  000be	8d 45 f0	 lea	 eax, DWORD PTR __name$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  000c7	83 c4 08	 add	 esp, 8

; 3742 : 	memcpy(pCRequest.Name, _name, MAX_IDSTRING);

  000ca	6a 0a		 push	 10			; 0000000aH
  000cc	8d 45 f0	 lea	 eax, DWORD PTR __name$[ebp]
  000cf	50		 push	 eax
  000d0	8d 4d e2	 lea	 ecx, DWORD PTR _pCRequest$[ebp+14]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 _memcpy
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3743 : 	strcpy(pCRequest.AccountID, gObj[aIndex].AccountID);

  000dc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e9	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000ed	52		 push	 edx
  000ee	8d 45 d7	 lea	 eax, DWORD PTR _pCRequest$[ebp+3]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _strcpy
  000f7	83 c4 08	 add	 esp, 8

; 3744 : 
; 3745 : 
; 3746 : #ifdef MODIFY_CASTLE_MAP_MOVE_TRACE_LOG_20080418
; 3747 : 	LogAddTD( "[BUGTRACE][CGPCharacterMapJoinRequest] (%d) ID : %s, Name : %s(%s) Send Request",
; 3748 : 		aIndex, gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->Name );
; 3749 : #endif // MODIFY_CASTLE_MAP_MOVE_TRACE_LOG_20080418
; 3750 : 	
; 3751 : 	pCRequest.Number = aIndex;	

  000fa	66 8b 45 0c	 mov	 ax, WORD PTR _aIndex$[ebp]
  000fe	66 89 45 ee	 mov	 WORD PTR _pCRequest$[ebp+26], ax

; 3752 : 	//wsDataCli.DataSend((char*)&pCRequest, pCRequest.h.size);
; 3753 : 
; 3754 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 3755 : 	//     
; 3756 : 	LogAddTD_TempLog(", [G->D Req MapJoin] CharSelected, Account [%s], IP [%s], Name[%s](%s)", 

  00102	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00105	83 c0 04	 add	 eax, 4
  00108	50		 push	 eax
  00109	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00110	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00116	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0011a	50		 push	 eax
  0011b	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00122	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00128	8d 44 0a 18	 lea	 eax, DWORD PTR [edx+ecx+24]
  0012c	50		 push	 eax
  0012d	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00134	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013a	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0013e	50		 push	 eax
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@JPGCOFPC@?0?5?$FLG?9?$DOD?5Req?5MapJoin?$FN?5CharSelect@
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  0014a	83 c4 14	 add	 esp, 20			; 00000014H

; 3757 : 		gObj[aIndex].AccountID, gObj[aIndex].Ip_addr, gObj[aIndex].Name, lpMsg->Name);
; 3758 : #endif
; 3759 : 
; 3760 : 	cDBSMng.Send((char*)&pCRequest, pCRequest.h.size);

  0014d	0f b6 45 d5	 movzx	 eax, BYTE PTR _pCRequest$[ebp+1]
  00151	50		 push	 eax
  00152	8d 4d d4	 lea	 ecx, DWORD PTR _pCRequest$[ebp]
  00155	51		 push	 ecx
  00156	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0015b	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@CGPCharact:

; 3761 : }

  00160	5f		 pop	 edi
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx
  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	33 cd		 xor	 ecx, ebp
  00168	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ENDP ; CGPCharacterMapJoinRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z
_TEXT	SEGMENT
$T1 = -172						; size = 4
$T2 = -168						; size = 4
_szTemp2$ = -100					; size = 20
_szTemp$ = -80						; size = 20
_szJoomin$ = -60					; size = 11
_pResult$ = -48						; size = 5
_pCDel$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z PROC		; CGPCharDel, COMDAT

; 3545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3546 : 	SDHP_CHARDELETE	pCDel;
; 3547 : 	PMSG_RESULT		pResult;
; 3548 : 
; 3549 : 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;

  00016	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00029	83 c4 04	 add	 esp, 4
  0002c	85 c0		 test	 eax, eax
  0002e	75 05		 jne	 SHORT $LN2@CGPCharDel
  00030	e9 32 03 00 00	 jmp	 $LN13@CGPCharDel
$LN2@CGPCharDel:

; 3550 : 
; 3551 : 	//    .
; 3552 : 	if( gObj[aIndex].Connected < 2 ) 

  00035	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00042	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00047	7d 11		 jge	 SHORT $LN3@CGPCharDel

; 3553 : 	{
; 3554 : 		CloseClient ( aIndex );

  00049	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00052	83 c4 04	 add	 esp, 4

; 3555 : 		return;

  00055	e9 0d 03 00 00	 jmp	 $LN13@CGPCharDel
$LN3@CGPCharDel:

; 3556 : 	}
; 3557 : 	
; 3558 : #ifdef MODIFY_CHARACTER_DELETE_IN_MAP_20051121
; 3559 : 	if( gObj[aIndex].Connected == CSS_GAMEPLAYING )

  0005a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00067	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0006c	75 43		 jne	 SHORT $LN4@CGPCharDel

; 3560 : 	{
; 3561 : 		LogAddTD( "[Anti-HACK][CGPCharDel] Attempted Character Delete during GamePlay. [%s][%s]",

  0006e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007b	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0007f	52		 push	 edx
  00080	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008d	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00091	52		 push	 edx
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempt@
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3562 : 			gObj[aIndex].AccountID, gObj[aIndex].Name );
; 3563 : 		CloseClient ( aIndex );

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000a9	83 c4 04	 add	 esp, 4

; 3564 : 		return;

  000ac	e9 b6 02 00 00	 jmp	 $LN13@CGPCharDel
$LN4@CGPCharDel:

; 3565 : 	}
; 3566 : 
; 3567 : #endif
; 3568 : 	
; 3569 : #ifdef BLOCK_INVALID_CHARACTER_DELETE_01_20060327
; 3570 : 	if( gObj[aIndex].bEnableDelCharacter == FALSE )

  000b1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000be	83 7c 01 0c 00	 cmp	 DWORD PTR [ecx+eax+12], 0
  000c3	75 43		 jne	 SHORT $LN5@CGPCharDel

; 3571 : 	{
; 3572 : 		LogAddTD( "[Anti-HACK][CGPCharDel] Attempted Character Delete during Prevented Time. [%s][%s]",

  000c5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d2	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000d6	52		 push	 edx
  000d7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e4	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000e8	52		 push	 edx
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempt@
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3573 : 			gObj[aIndex].AccountID, gObj[aIndex].Name );
; 3574 : 		CloseClient ( aIndex );

  000f7	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00100	83 c4 04	 add	 esp, 4

; 3575 : 		return;

  00103	e9 5f 02 00 00	 jmp	 $LN13@CGPCharDel
$LN5@CGPCharDel:

; 3576 : 	}
; 3577 : #endif
; 3578 : 
; 3579 : 	PHeadSubSetB((LPBYTE)&pResult, 0xF3, 0x02, sizeof( pResult ) );

  00108	6a 05		 push	 5
  0010a	6a 02		 push	 2
  0010c	68 f3 00 00 00	 push	 243			; 000000f3H
  00111	8d 45 d0	 lea	 eax, DWORD PTR _pResult$[ebp]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0011a	83 c4 10	 add	 esp, 16			; 00000010H

; 3580 : 	pResult.result	   = 0x00;

  0011d	c6 45 d4 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 3581 : 
; 3582 : 	if( gObj[aIndex].m_cAccountItemBlock )

  00121	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012e	0f b6 94 01 ac
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+428]
  00136	85 d2		 test	 edx, edx
  00138	74 1e		 je	 SHORT $LN6@CGPCharDel

; 3583 : 	{	//     
; 3584 : 		pResult.result	   = 0x03;

  0013a	c6 45 d4 03	 mov	 BYTE PTR _pResult$[ebp+4], 3

; 3585 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0013e	0f b6 45 d1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00142	50		 push	 eax
  00143	8d 4d d0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00146	51		 push	 ecx
  00147	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0014a	52		 push	 edx
  0014b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3586 : 		return;

  00153	e9 0f 02 00 00	 jmp	 $LN13@CGPCharDel
$LN6@CGPCharDel:

; 3587 : 	}
; 3588 : 
; 3589 : 	if ( gGuildDestroy == 0 )

  00158	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGuildDestroy@@3HA, 0 ; gGuildDestroy
  0015f	75 1e		 jne	 SHORT $LN7@CGPCharDel

; 3590 : 	{
; 3591 : 		pResult.result	   = 0x00;

  00161	c6 45 d4 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 3592 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00165	0f b6 45 d1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00169	50		 push	 eax
  0016a	8d 4d d0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0016d	51		 push	 ecx
  0016e	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00171	52		 push	 edx
  00172	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00177	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3593 : 		return;

  0017a	e9 e8 01 00 00	 jmp	 $LN13@CGPCharDel
$LN7@CGPCharDel:

; 3594 : 	}
; 3595 : 
; 3596 : 
; 3597 : ////////////////////////////////////////////////////////////////////////
; 3598 : // DEL_CODE_LIMIT_OF_DEL_CHARACTER_LEVEL_20050215
; 3599 : //
; 3600 : //  . :     
; 3601 : //      .
; 3602 : //	if( gObj[aIndex].Level >= gCharacterDeleteMinLevel )
; 3603 : //	{
; 3604 : //		pResult.result	   = 0x00;
; 3605 : //		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3606 : //		return;
; 3607 : // 	}
; 3608 : ////////////////////////////////////////////////////////////////////////
; 3609 : 
; 3610 : 
; 3611 : 
; 3612 : 	//     .
; 3613 : #ifdef UPDATE_USERPASSWORD_LENGTH_20090424	
; 3614 : 	char szJoomin[MAX_JOOMINNUMBER_LENGTH+1];
; 3615 : 	
; 3616 : 	
; 3617 : 	memset( szJoomin, 0 , MAX_JOOMINNUMBER_LENGTH+1);
; 3618 : 	memcpy( szJoomin, lpMsg->LastJoominNumber, MAX_JOOMINNUMBER_LENGTH);
; 3619 : 	
; 3620 : 	if( gObjJoominCheck(aIndex, szJoomin) == FALSE )
; 3621 : 	{
; 3622 : 		pResult.result	   = 0x02;
; 3623 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3624 : 		return;
; 3625 : 	}
; 3626 : #else	// UPDATE_USERPASSWORD_LENGTH_20090424
; 3627 : 	char szJoomin[11];
; 3628 : 
; 3629 : 
; 3630 : 	memset( szJoomin, 0 , 11);

  0017f	6a 0b		 push	 11			; 0000000bH
  00181	6a 00		 push	 0
  00183	8d 45 c4	 lea	 eax, DWORD PTR _szJoomin$[ebp]
  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 _memset
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3631 : 	memcpy( szJoomin, lpMsg->LastJoominNumber, 10);

  0018f	6a 0a		 push	 10			; 0000000aH
  00191	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00194	83 c0 0e	 add	 eax, 14			; 0000000eH
  00197	50		 push	 eax
  00198	8d 4d c4	 lea	 ecx, DWORD PTR _szJoomin$[ebp]
  0019b	51		 push	 ecx
  0019c	e8 00 00 00 00	 call	 _memcpy
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3632 : 	
; 3633 : 	if( gObjJoominCheck(aIndex, szJoomin) == FALSE )

  001a4	8d 45 c4	 lea	 eax, DWORD PTR _szJoomin$[ebp]
  001a7	50		 push	 eax
  001a8	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001ab	51		 push	 ecx
  001ac	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  001b1	83 c4 08	 add	 esp, 8
  001b4	85 c0		 test	 eax, eax
  001b6	75 1e		 jne	 SHORT $LN8@CGPCharDel

; 3634 : 	//if( strcmp(lpMsg->LastJoominNumber, gObj[aIndex].LastJoominNumber) != 0 )
; 3635 : 	{
; 3636 : 		pResult.result	   = 0x02;

  001b8	c6 45 d4 02	 mov	 BYTE PTR _pResult$[ebp+4], 2

; 3637 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001bc	0f b6 45 d1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001c0	50		 push	 eax
  001c1	8d 4d d0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001c4	51		 push	 ecx
  001c5	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001c8	52		 push	 edx
  001c9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3638 : 		return;

  001d1	e9 91 01 00 00	 jmp	 $LN13@CGPCharDel
$LN8@CGPCharDel:

; 3639 : 	}
; 3640 : #endif	// UPDATE_USERPASSWORD_LENGTH_20090424
; 3641 : 
; 3642 : 	PHeadSetB((LPBYTE)&pCDel, 0x05, sizeof( pCDel ));

  001d6	6a 24		 push	 36			; 00000024H
  001d8	6a 05		 push	 5
  001da	8d 45 d8	 lea	 eax, DWORD PTR _pCDel$[ebp]
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  001e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3643 : 
; 3644 : 	pCDel.Number     = aIndex;

  001e6	66 8b 45 0c	 mov	 ax, WORD PTR _aIndex$[ebp]
  001ea	66 89 45 dc	 mov	 WORD PTR _pCDel$[ebp+4], ax

; 3645 : 	memcpy(pCDel.AccountID, gObj[aIndex].AccountID, MAX_IDSTRING);

  001ee	6a 0a		 push	 10			; 0000000aH
  001f0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001fd	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00201	52		 push	 edx
  00202	8d 45 de	 lea	 eax, DWORD PTR _pCDel$[ebp+6]
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 _memcpy
  0020b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3646 : 	memcpy(pCDel.Name, lpMsg->Name, MAX_IDSTRING);

  0020e	6a 0a		 push	 10			; 0000000aH
  00210	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00213	83 c0 04	 add	 eax, 4
  00216	50		 push	 eax
  00217	8d 4d e8	 lea	 ecx, DWORD PTR _pCDel$[ebp+16]
  0021a	51		 push	 ecx
  0021b	e8 00 00 00 00	 call	 _memcpy
  00220	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3647 : 	pCDel.Guild		 = 0;

  00223	c6 45 f2 00	 mov	 BYTE PTR _pCDel$[ebp+26], 0

; 3648 : 	if( gObj[aIndex].GuildNumber > 0 )

  00227	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00234	83 bc 01 90 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+656], 0
  0023c	0f 8e 86 00 00
	00		 jle	 $LN9@CGPCharDel

; 3649 : 	{
; 3650 : 		if( gObj[aIndex].lpGuild != NULL )

  00242	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00249	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024f	83 bc 01 94 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+660], 0
  00257	74 6f		 je	 SHORT $LN9@CGPCharDel

; 3651 : 		{
; 3652 : 			if( strcmp(gObj[aIndex].Name, gObj[aIndex].lpGuild->Names[0]) == 0 )	// .. .

  00259	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00266	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  0026d	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00272	6b c8 00	 imul	 ecx, eax, 0
  00275	8d 54 0a 2f	 lea	 edx, DWORD PTR [edx+ecx+47]
  00279	52		 push	 edx
  0027a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00281	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00287	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0028b	52		 push	 edx
  0028c	e8 00 00 00 00	 call	 _strcmp
  00291	83 c4 08	 add	 esp, 8
  00294	85 c0		 test	 eax, eax
  00296	75 06		 jne	 SHORT $LN11@CGPCharDel

; 3653 : 			{
; 3654 : 				pCDel.Guild = 1;	//    .

  00298	c6 45 f2 01	 mov	 BYTE PTR _pCDel$[ebp+26], 1

; 3655 : 			}			

  0029c	eb 04		 jmp	 SHORT $LN12@CGPCharDel
$LN11@CGPCharDel:

; 3656 : 			else pCDel.Guild = 2;	//    

  0029e	c6 45 f2 02	 mov	 BYTE PTR _pCDel$[ebp+26], 2
$LN12@CGPCharDel:

; 3657 : 			memcpy(pCDel.GuildName, gObj[aIndex].lpGuild->Name,MAX_GUILDNAMESTRING);

  002a2	6a 08		 push	 8
  002a4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b1	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  002b8	83 c2 04	 add	 edx, 4
  002bb	52		 push	 edx
  002bc	8d 45 f3	 lea	 eax, DWORD PTR _pCDel$[ebp+27]
  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 _memcpy
  002c5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGPCharDel:

; 3658 : 		}
; 3659 : 	}
; 3660 : 
; 3661 : #ifdef MODIFY_PERIOD_ITEM_SYSTEM_BUGFIX_20070326
; 3662 : 	g_CashItemPeriodSystem.GDReqPeriodItemDelete( &gObj[aIndex], lpMsg->Name );
; 3663 : #endif // MODIFY_PERIOD_ITEM_SYSTEM_BUGFIX_20070326
; 3664 : 
; 3665 : 	char szTemp[20], szTemp2[20];
; 3666 : 	szTemp[MAX_IDSTRING] = '\0';

  002c8	b8 01 00 00 00	 mov	 eax, 1
  002cd	6b c8 0a	 imul	 ecx, eax, 10
  002d0	89 8d 58 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  002d6	83 bd 58 ff ff
	ff 14		 cmp	 DWORD PTR $T2[ebp], 20	; 00000014H
  002dd	73 02		 jae	 SHORT $LN14@CGPCharDel
  002df	eb 05		 jmp	 SHORT $LN15@CGPCharDel
$LN14@CGPCharDel:
  002e1	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN15@CGPCharDel:
  002e6	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  002ec	c6 44 15 b0 00	 mov	 BYTE PTR _szTemp$[ebp+edx], 0

; 3667 : 	szTemp2[MAX_IDSTRING] = '\0';

  002f1	b8 01 00 00 00	 mov	 eax, 1
  002f6	6b c8 0a	 imul	 ecx, eax, 10
  002f9	89 8d 54 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  002ff	83 bd 54 ff ff
	ff 14		 cmp	 DWORD PTR $T1[ebp], 20	; 00000014H
  00306	73 02		 jae	 SHORT $LN16@CGPCharDel
  00308	eb 05		 jmp	 SHORT $LN17@CGPCharDel
$LN16@CGPCharDel:
  0030a	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN17@CGPCharDel:
  0030f	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00315	c6 44 15 9c 00	 mov	 BYTE PTR _szTemp2$[ebp+edx], 0

; 3668 : 	memcpy(szTemp, pCDel.Name, MAX_IDSTRING);

  0031a	6a 0a		 push	 10			; 0000000aH
  0031c	8d 45 e8	 lea	 eax, DWORD PTR _pCDel$[ebp+16]
  0031f	50		 push	 eax
  00320	8d 4d b0	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00323	51		 push	 ecx
  00324	e8 00 00 00 00	 call	 _memcpy
  00329	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3669 : 	memcpy(szTemp2, pCDel.AccountID, MAX_IDSTRING);

  0032c	6a 0a		 push	 10			; 0000000aH
  0032e	8d 45 de	 lea	 eax, DWORD PTR _pCDel$[ebp+6]
  00331	50		 push	 eax
  00332	8d 4d 9c	 lea	 ecx, DWORD PTR _szTemp2$[ebp]
  00335	51		 push	 ecx
  00336	e8 00 00 00 00	 call	 _memcpy
  0033b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3670 : 	
; 3671 : 	LogAddTD("Character delete : %s,%s", szTemp2, szTemp);

  0033e	8d 45 b0	 lea	 eax, DWORD PTR _szTemp$[ebp]
  00341	50		 push	 eax
  00342	8d 4d 9c	 lea	 ecx, DWORD PTR _szTemp2$[ebp]
  00345	51		 push	 ecx
  00346	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs@
  0034b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00351	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3672 : 	//wsDataCli.DataSend((char*)&pCDel, pCDel.h.size);
; 3673 : 	cDBSMng.Send((char*)&pCDel, pCDel.h.size);

  00354	0f b6 45 d9	 movzx	 eax, BYTE PTR _pCDel$[ebp+1]
  00358	50		 push	 eax
  00359	8d 4d d8	 lea	 ecx, DWORD PTR _pCDel$[ebp]
  0035c	51		 push	 ecx
  0035d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00362	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN13@CGPCharDel:

; 3674 : 
; 3675 : #ifdef MODIFY_MATCHDB_UPDATE_DELETED_CHARACTER_20060810
; 3676 : 	//        0 .
; 3677 : 	gObj[aIndex].Level = 0;
; 3678 : #endif
; 3679 : 	
; 3680 : #ifdef NOTIFY_CHARACTER_DELETE_FROM_GS_TO_JS_20060322
; 3681 : 	//      .
; 3682 : 	// DataServer  0x05 
; 3683 : 	// JoinServer  0x15  
; 3684 : 	pCDel.h.headcode = 0x15;
; 3685 : 	wsJServerCli.DataSend((char*)&pCDel, pCDel.h.size);
; 3686 : #endif
; 3687 : 	
; 3688 : }

  00367	5f		 pop	 edi
  00368	5e		 pop	 esi
  00369	5b		 pop	 ebx
  0036a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0036d	33 cd		 xor	 ecx, ebp
  0036f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00374	8b e5		 mov	 esp, ebp
  00376	5d		 pop	 ebp
  00377	c3		 ret	 0
?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z ENDP		; CGPCharDel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z
_TEXT	SEGMENT
$T1 = -152						; size = 4
$T2 = -148						; size = 4
_szTemp2$ = -80						; size = 20
_szTemp$ = -60						; size = 20
_sCreate$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z PROC	; CGPCharacterCreate, COMDAT

; 3424 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3425 : 	SDHP_CREATECHAR		sCreate;
; 3426 : 	
; 3427 : 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) 

  00016	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00029	83 c4 04	 add	 esp, 4
  0002c	85 c0		 test	 eax, eax
  0002e	75 18		 jne	 SHORT $LN2@CGPCharact

; 3428 : 	{
; 3429 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00030	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00033	83 c0 04	 add	 eax, 4
  00036	50		 push	 eax
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  00040	83 c4 08	 add	 esp, 8

; 3430 : 		return;

  00043	e9 f3 02 00 00	 jmp	 $LN13@CGPCharact
$LN2@CGPCharact:

; 3431 : 	}
; 3432 : 
; 3433 : 	//    .
; 3434 : 	if( gObj[aIndex].Connected < 2 ) 

  00048	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00055	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0005a	7d 41		 jge	 SHORT $LN3@CGPCharact

; 3435 : 	{
; 3436 : 		//wsGServer.Close(gObj[aIndex].m_socket);
; 3437 : 		LogAdd(lMsg.Get(476), aIndex, gObj[aIndex].Ip_addr);

  0005c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00069	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0006d	52		 push	 edx
  0006e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00071	50		 push	 eax
  00072	68 dc 01 00 00	 push	 476			; 000001dcH
  00077	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00082	50		 push	 eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3438 : 		CloseClient ( aIndex );

  0008c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00095	83 c4 04	 add	 esp, 4

; 3439 : 		return;

  00098	e9 9e 02 00 00	 jmp	 $LN13@CGPCharact
$LN3@CGPCharact:

; 3440 : 	}
; 3441 : 	
; 3442 : 
; 3443 : #ifdef MODIFY_CHARACTER_DELETE_IN_MAP_20051121
; 3444 : 	if( gObj[aIndex].Connected == CSS_GAMEPLAYING )

  0009d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000aa	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  000af	75 43		 jne	 SHORT $LN4@CGPCharact

; 3445 : 	{
; 3446 : 		LogAddTD( "[Anti-HACK][CGPCharacterCreate] Attempted Character Create during GamePlay. [%s][%s]",

  000b1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000be	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000c2	52		 push	 edx
  000c3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d0	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000d4	52		 push	 edx
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN@
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3447 : 			gObj[aIndex].AccountID, gObj[aIndex].Name );
; 3448 : 		CloseClient ( aIndex );

  000e3	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000ec	83 c4 04	 add	 esp, 4

; 3449 : 		return;

  000ef	e9 47 02 00 00	 jmp	 $LN13@CGPCharact
$LN4@CGPCharact:

; 3450 : 	}
; 3451 : 
; 3452 : #endif
; 3453 : 	
; 3454 : 	//   ..
; 3455 : 	if( !gCreateCharacter )

  000f4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCreateCharacter@@3HA, 0 ; gCreateCharacter
  000fb	75 2b		 jne	 SHORT $LN5@CGPCharact

; 3456 : 	{
; 3457 : 		GCServerMsgStringSend("    ", aIndex, 1);	

  000fd	6a 01		 push	 1
  000ff	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00102	50		 push	 eax
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@BLKDKNKC@?$LM?$KN?$LJ?v?$LK?P?G?R?5?$LB?b?$LA?$KD?$LP?$KB?$LE?B?5?D?$LD?$LI?$KP?E?M?$LI?$KG?5?$LL?$PN?$LM?$LK@
  00108	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3458 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00110	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00113	83 c0 04	 add	 eax, 4
  00116	50		 push	 eax
  00117	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0011a	51		 push	 ecx
  0011b	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  00120	83 c4 08	 add	 esp, 8

; 3459 : 		return;

  00123	e9 13 02 00 00	 jmp	 $LN13@CGPCharact
$LN5@CGPCharact:

; 3460 : 	}
; 3461 : 
; 3462 : 	//     .
; 3463 : 	if( lpMsg->ClassSkin == 0 ||
; 3464 : 		lpMsg->ClassSkin == 16 ||
; 3465 : 		lpMsg->ClassSkin == 32 ||
; 3466 : 		lpMsg->ClassSkin == 48 
; 3467 : #ifdef DARKLORD_WORK
; 3468 : 		|| lpMsg->ClassSkin == 64 

  00128	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0012b	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0012f	85 c9		 test	 ecx, ecx
  00131	74 30		 je	 SHORT $LN8@CGPCharact
  00133	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00136	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0013a	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0013d	74 24		 je	 SHORT $LN8@CGPCharact
  0013f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00142	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00146	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00149	74 18		 je	 SHORT $LN8@CGPCharact
  0014b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0014e	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00152	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00155	74 0c		 je	 SHORT $LN8@CGPCharact
  00157	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0015a	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0015e	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00161	75 02		 jne	 SHORT $LN6@CGPCharact
$LN8@CGPCharact:

; 3469 : #endif
; 3470 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 3471 : 		|| lpMsg->ClassSkin == 80	// 
; 3472 : #endif
; 3473 : 		)
; 3474 : 	{
; 3475 : 		//  .
; 3476 : 	}

  00163	eb 18		 jmp	 SHORT $LN7@CGPCharact
$LN6@CGPCharact:

; 3477 : 	else 
; 3478 : 	{
; 3479 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00165	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00168	83 c0 04	 add	 eax, 4
  0016b	50		 push	 eax
  0016c	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0016f	51		 push	 ecx
  00170	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  00175	83 c4 08	 add	 esp, 8

; 3480 : 		return;

  00178	e9 be 01 00 00	 jmp	 $LN13@CGPCharact
$LN7@CGPCharact:

; 3481 : 	}
; 3482 : 
; 3483 : #ifdef ADD_CHARCARD_SUMMONER_20080313
; 3484 : 	if (lpMsg->ClassSkin == 80 && gObj[aIndex].m_bCharCardSummoner != TRUE) 
; 3485 : 	{
; 3486 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 3487 : 		return;
; 3488 : 	}
; 3489 : #endif // ADD_CHARCARD_SUMMONER_20080313
; 3490 : 
; 3491 : 	//        .
; 3492 : 	if( lpMsg->ClassSkin == 48 )

  0017d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00180	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00184	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00187	75 50		 jne	 SHORT $LN9@CGPCharact

; 3493 : 	{
; 3494 : 		if( gObj[aIndex].Magumsa == 0 ) 

  00189	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00196	0f b6 54 01 30	 movzx	 edx, BYTE PTR [ecx+eax+48]
  0019b	85 d2		 test	 edx, edx
  0019d	75 3a		 jne	 SHORT $LN9@CGPCharact

; 3495 : 		{
; 3496 : 			LogAddC(LOGC_RED,"error-L1: Magumsa Character create error [%s]", gObj[aIndex].AccountID);

  0019f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ac	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001b0	52		 push	 edx
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5cre@
  001b6	6a 02		 push	 2
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3497 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  001c1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001c4	83 c0 04	 add	 eax, 4
  001c7	50		 push	 eax
  001c8	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001cb	51		 push	 ecx
  001cc	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  001d1	83 c4 08	 add	 esp, 8

; 3498 : 			return;

  001d4	e9 62 01 00 00	 jmp	 $LN13@CGPCharact
$LN9@CGPCharact:

; 3499 : 		}
; 3500 : 	}
; 3501 : 	
; 3502 : 	if( lpMsg->ClassSkin == 64 )

  001d9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001dc	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  001e0	83 f9 40	 cmp	 ecx, 64			; 00000040H
  001e3	75 51		 jne	 SHORT $LN11@CGPCharact

; 3503 : 	{
; 3504 : 		if( gObj[aIndex].Magumsa != 2 ) 

  001e5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f2	0f b6 54 01 30	 movzx	 edx, BYTE PTR [ecx+eax+48]
  001f7	83 fa 02	 cmp	 edx, 2
  001fa	74 3a		 je	 SHORT $LN11@CGPCharact

; 3505 : 		{
; 3506 : 			LogAddC(LOGC_RED,"error-L1: Darklord Character create error [%s]", gObj[aIndex].AccountID);

  001fc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00203	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00209	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0020d	52		 push	 edx
  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cr@
  00213	6a 02		 push	 2
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0021b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3507 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  0021e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00221	83 c0 04	 add	 eax, 4
  00224	50		 push	 eax
  00225	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  0022e	83 c4 08	 add	 esp, 8

; 3508 : 			return;

  00231	e9 05 01 00 00	 jmp	 $LN13@CGPCharact
$LN11@CGPCharact:

; 3509 : 		}
; 3510 : 	}
; 3511 : 	
; 3512 : 	memset(&sCreate, 0, sizeof(sCreate));

  00236	6a 24		 push	 36			; 00000024H
  00238	6a 00		 push	 0
  0023a	8d 45 d8	 lea	 eax, DWORD PTR _sCreate$[ebp]
  0023d	50		 push	 eax
  0023e	e8 00 00 00 00	 call	 _memset
  00243	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3513 : 	
; 3514 : 	PHeadSetB((LPBYTE)&sCreate, 0x04, sizeof( sCreate ));

  00246	6a 24		 push	 36			; 00000024H
  00248	6a 04		 push	 4
  0024a	8d 45 d8	 lea	 eax, DWORD PTR _sCreate$[ebp]
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00253	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3515 : 
; 3516 : 	sCreate.ClassSkin  = lpMsg->ClassSkin;

  00256	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00259	8a 48 0e	 mov	 cl, BYTE PTR [eax+14]
  0025c	88 4d fa	 mov	 BYTE PTR _sCreate$[ebp+34], cl

; 3517 : 	sCreate.Number     = aIndex;

  0025f	66 8b 45 0c	 mov	 ax, WORD PTR _aIndex$[ebp]
  00263	66 89 45 e4	 mov	 WORD PTR _sCreate$[ebp+12], ax

; 3518 : 	
; 3519 : 	memcpy(sCreate.AccountId, gObj[aIndex].AccountID, MAX_IDSTRING);

  00267	6a 0a		 push	 10			; 0000000aH
  00269	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00270	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00276	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0027a	52		 push	 edx
  0027b	8d 45 e6	 lea	 eax, DWORD PTR _sCreate$[ebp+14]
  0027e	50		 push	 eax
  0027f	e8 00 00 00 00	 call	 _memcpy
  00284	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3520 : 	memcpy(sCreate.Name, lpMsg->Name, MAX_IDSTRING);

  00287	6a 0a		 push	 10			; 0000000aH
  00289	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0028c	83 c0 04	 add	 eax, 4
  0028f	50		 push	 eax
  00290	8d 4d f0	 lea	 ecx, DWORD PTR _sCreate$[ebp+24]
  00293	51		 push	 ecx
  00294	e8 00 00 00 00	 call	 _memcpy
  00299	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3521 : 	
; 3522 : #if _DEBUG
; 3523 : 	char szTmpID[MAX_IDSTRING+1];
; 3524 : 	szTmpID[MAX_IDSTRING] = '\0';
; 3525 : 	memcpy(szTmpID, lpMsg->Name, MAX_IDSTRING);
; 3526 : 	LogAdd("Create Character: %s %s", gObj[aIndex].AccountID, szTmpID);
; 3527 : #endif
; 3528 : 		
; 3529 : 	//     .
; 3530 : 	char szTemp[20], szTemp2[20];
; 3531 : 	szTemp[MAX_IDSTRING] = '\0';

  0029c	b8 01 00 00 00	 mov	 eax, 1
  002a1	6b c8 0a	 imul	 ecx, eax, 10
  002a4	89 8d 6c ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  002aa	83 bd 6c ff ff
	ff 14		 cmp	 DWORD PTR $T2[ebp], 20	; 00000014H
  002b1	73 02		 jae	 SHORT $LN14@CGPCharact
  002b3	eb 05		 jmp	 SHORT $LN15@CGPCharact
$LN14@CGPCharact:
  002b5	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN15@CGPCharact:
  002ba	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  002c0	c6 44 15 c4 00	 mov	 BYTE PTR _szTemp$[ebp+edx], 0

; 3532 : 	szTemp2[MAX_IDSTRING] = '\0';

  002c5	b8 01 00 00 00	 mov	 eax, 1
  002ca	6b c8 0a	 imul	 ecx, eax, 10
  002cd	89 8d 68 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  002d3	83 bd 68 ff ff
	ff 14		 cmp	 DWORD PTR $T1[ebp], 20	; 00000014H
  002da	73 02		 jae	 SHORT $LN16@CGPCharact
  002dc	eb 05		 jmp	 SHORT $LN17@CGPCharact
$LN16@CGPCharact:
  002de	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN17@CGPCharact:
  002e3	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  002e9	c6 44 15 b0 00	 mov	 BYTE PTR _szTemp2$[ebp+edx], 0

; 3533 : 	memcpy(szTemp, sCreate.Name, MAX_IDSTRING);

  002ee	6a 0a		 push	 10			; 0000000aH
  002f0	8d 45 f0	 lea	 eax, DWORD PTR _sCreate$[ebp+24]
  002f3	50		 push	 eax
  002f4	8d 4d c4	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  002f7	51		 push	 ecx
  002f8	e8 00 00 00 00	 call	 _memcpy
  002fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3534 : 	memcpy(szTemp2, sCreate.AccountId, MAX_IDSTRING);

  00300	6a 0a		 push	 10			; 0000000aH
  00302	8d 45 e6	 lea	 eax, DWORD PTR _sCreate$[ebp+14]
  00305	50		 push	 eax
  00306	8d 4d b0	 lea	 ecx, DWORD PTR _szTemp2$[ebp]
  00309	51		 push	 ecx
  0030a	e8 00 00 00 00	 call	 _memcpy
  0030f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3535 : 	LogAddTD("Character create : %s,%s", szTemp2, szTemp);

  00312	8d 45 c4	 lea	 eax, DWORD PTR _szTemp$[ebp]
  00315	50		 push	 eax
  00316	8d 4d b0	 lea	 ecx, DWORD PTR _szTemp2$[ebp]
  00319	51		 push	 ecx
  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs@
  0031f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00325	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3536 : 	//wsDataCli.DataSend((char*)&sCreate, sCreate.h.size);
; 3537 : 	cDBSMng.Send((char*)&sCreate, sCreate.h.size);

  00328	0f b6 45 d9	 movzx	 eax, BYTE PTR _sCreate$[ebp+1]
  0032c	50		 push	 eax
  0032d	8d 4d d8	 lea	 ecx, DWORD PTR _sCreate$[ebp]
  00330	51		 push	 ecx
  00331	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00336	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN13@CGPCharact:

; 3538 : }

  0033b	5f		 pop	 edi
  0033c	5e		 pop	 esi
  0033d	5b		 pop	 ebx
  0033e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00341	33 cd		 xor	 ecx, ebp
  00343	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00348	8b e5		 mov	 esp, ebp
  0034a	5d		 pop	 ebp
  0034b	c3		 ret	 0
?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z ENDP	; CGPCharacterCreate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z
_TEXT	SEGMENT
$T1 = -156						; size = 4
$T2 = -152						; size = 4
_spMsg$ = -84						; size = 44
_lpObj$ = -40						; size = 4
_id$ = -36						; size = 11
_serial$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z PROC	; CSPJoinIdPassRequest, COMDAT

; 3056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3057 : 	BYTE serial[17];
; 3058 : 	char id[MAX_IDSTRING+1];
; 3059 : 
; 3060 : 	//   
; 3061 : 	if( (lpMsg->CliVersion[0] != szClientVersion[0]) ||
; 3062 : 		(lpMsg->CliVersion[1] != szClientVersion[1]) ||
; 3063 : 		(lpMsg->CliVersion[2] != szClientVersion[2]) ||
; 3064 : 		(lpMsg->CliVersion[3] != szClientVersion[3]) ||

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00021	0f b6 44 0a 1c	 movzx	 eax, BYTE PTR [edx+ecx+28]
  00026	b9 01 00 00 00	 mov	 ecx, 1
  0002b	6b d1 00	 imul	 edx, ecx, 0
  0002e	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA[edx]
  00035	3b c1		 cmp	 eax, ecx
  00037	0f 85 8a 00 00
	00		 jne	 $LN3@CSPJoinIdP
  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	c1 e0 00	 shl	 eax, 0
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00048	0f b6 54 01 1c	 movzx	 edx, BYTE PTR [ecx+eax+28]
  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	c1 e0 00	 shl	 eax, 0
  00055	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA[eax]
  0005c	3b d1		 cmp	 edx, ecx
  0005e	75 67		 jne	 SHORT $LN3@CSPJoinIdP
  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	d1 e0		 shl	 eax, 1
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0006a	0f b6 54 01 1c	 movzx	 edx, BYTE PTR [ecx+eax+28]
  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	d1 e0		 shl	 eax, 1
  00076	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA[eax]
  0007d	3b d1		 cmp	 edx, ecx
  0007f	75 46		 jne	 SHORT $LN3@CSPJoinIdP
  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	6b c8 03	 imul	 ecx, eax, 3
  00089	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0008c	0f b6 44 0a 1c	 movzx	 eax, BYTE PTR [edx+ecx+28]
  00091	b9 01 00 00 00	 mov	 ecx, 1
  00096	6b d1 03	 imul	 edx, ecx, 3
  00099	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA[edx]
  000a0	3b c1		 cmp	 eax, ecx
  000a2	75 23		 jne	 SHORT $LN3@CSPJoinIdP
  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	c1 e0 02	 shl	 eax, 2
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000af	0f b6 54 01 1c	 movzx	 edx, BYTE PTR [ecx+eax+28]
  000b4	b8 01 00 00 00	 mov	 eax, 1
  000b9	c1 e0 02	 shl	 eax, 2
  000bc	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ?szClientVersion@@3PADA[eax]
  000c3	3b d1		 cmp	 edx, ecx
  000c5	74 3d		 je	 SHORT $LN2@CSPJoinIdP
$LN3@CSPJoinIdP:

; 3065 : 		(lpMsg->CliVersion[4] != szClientVersion[4]) )
; 3066 : 	{
; 3067 : 		LogAddC(LOGC_PURPLE, "JOIN ERROR - VERSION: %s SERIAL: %s", lpMsg->CliVersion, lpMsg->CliSerial);

  000c7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000ca	83 c0 21	 add	 eax, 33			; 00000021H
  000cd	50		 push	 eax
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000d1	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000d4	51		 push	 ecx
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NFIPADMP@JOIN?5ERROR?5?9?5VERSION?3?5?$CFs?5SERIAL@
  000da	6a 07		 push	 7
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000e2	83 c4 10	 add	 esp, 16			; 00000010H

; 3068 : 		GCJoinResult(0x06, aIndex);

  000e5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000e8	50		 push	 eax
  000e9	6a 06		 push	 6
  000eb	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult
  000f0	83 c4 08	 add	 esp, 8

; 3069 : 		CloseClient ( aIndex );

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000fc	83 c4 04	 add	 esp, 4

; 3070 : 		return;

  000ff	e9 ee 03 00 00	 jmp	 $LN12@CSPJoinIdP
$LN2@CSPJoinIdP:

; 3071 : 	}
; 3072 : 
; 3073 : 	serial[16] = '\0';

  00104	b8 01 00 00 00	 mov	 eax, 1
  00109	c1 e0 04	 shl	 eax, 4
  0010c	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00112	83 bd 68 ff ff
	ff 11		 cmp	 DWORD PTR $T2[ebp], 17	; 00000011H
  00119	73 02		 jae	 SHORT $LN13@CSPJoinIdP
  0011b	eb 05		 jmp	 SHORT $LN14@CSPJoinIdP
$LN13@CSPJoinIdP:
  0011d	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN14@CSPJoinIdP:
  00122	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00128	c6 44 0d e8 00	 mov	 BYTE PTR _serial$[ebp+ecx], 0

; 3074 : 	memcpy(serial, lpMsg->CliSerial, 16);

  0012d	6a 10		 push	 16			; 00000010H
  0012f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00132	83 c0 21	 add	 eax, 33			; 00000021H
  00135	50		 push	 eax
  00136	8d 4d e8	 lea	 ecx, DWORD PTR _serial$[ebp]
  00139	51		 push	 ecx
  0013a	e8 00 00 00 00	 call	 _memcpy
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3075 : 
; 3076 : 	id[MAX_IDSTRING] = '\0';

  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	6b c8 0a	 imul	 ecx, eax, 10
  0014a	89 8d 64 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00150	83 bd 64 ff ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00157	73 02		 jae	 SHORT $LN15@CSPJoinIdP
  00159	eb 05		 jmp	 SHORT $LN16@CSPJoinIdP
$LN15@CSPJoinIdP:
  0015b	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN16@CSPJoinIdP:
  00160	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00166	c6 44 15 dc 00	 mov	 BYTE PTR _id$[ebp+edx], 0

; 3077 : 	memcpy(id, lpMsg->Id, MAX_IDSTRING);

  0016b	6a 0a		 push	 10			; 0000000aH
  0016d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00170	83 c0 04	 add	 eax, 4
  00173	50		 push	 eax
  00174	8d 4d dc	 lea	 ecx, DWORD PTR _id$[ebp]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 _memcpy
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3078 : 	BuxConvert(id, MAX_IDSTRING);

  00180	6a 0a		 push	 10			; 0000000aH
  00182	8d 45 dc	 lea	 eax, DWORD PTR _id$[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  0018b	83 c4 08	 add	 esp, 8

; 3079 : 	
; 3080 : #if ( LOCALCONNECT == 0 )
; 3081 : 	//      
; 3082 : 	if( strcmp((char*)serial, szGameServerExeSerial) != 0 )

  0018e	68 00 00 00 00	 push	 OFFSET ?szGameServerExeSerial@@3PADA ; szGameServerExeSerial
  00193	8d 45 e8	 lea	 eax, DWORD PTR _serial$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _strcmp
  0019c	83 c4 08	 add	 esp, 8
  0019f	85 c0		 test	 eax, eax
  001a1	74 37		 je	 SHORT $LN4@CSPJoinIdP

; 3083 : 	{		
; 3084 : 		LogAddC(LOGC_RED,"error-L1: Serial error [%s] [%s]", id, serial);

  001a3	8d 45 e8	 lea	 eax, DWORD PTR _serial$[ebp]
  001a6	50		 push	 eax
  001a7	8d 4d dc	 lea	 ecx, DWORD PTR _id$[ebp]
  001aa	51		 push	 ecx
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs@
  001b0	6a 02		 push	 2
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001b8	83 c4 10	 add	 esp, 16			; 00000010H

; 3085 : 		GCJoinResult(0x06, aIndex);

  001bb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001be	50		 push	 eax
  001bf	6a 06		 push	 6
  001c1	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult
  001c6	83 c4 08	 add	 esp, 8

; 3086 : 		CloseClient ( aIndex );

  001c9	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  001d2	83 c4 04	 add	 esp, 4

; 3087 : 		return;

  001d5	e9 18 03 00 00	 jmp	 $LN12@CSPJoinIdP
$LN4@CSPJoinIdP:

; 3088 : 	}
; 3089 : #endif
; 3090 : 
; 3091 : 	if( bCanConnectMember == 1 )

  001da	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanConnectMember@@3HA, 1 ; bCanConnectMember
  001e1	75 25		 jne	 SHORT $LN5@CSPJoinIdP

; 3092 : 	{
; 3093 : 		if( ConMember.IsMember(id) == FALSE )

  001e3	8d 45 dc	 lea	 eax, DWORD PTR _id$[ebp]
  001e6	50		 push	 eax
  001e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?ConMember@@3VCConMember@@A ; ConMember
  001ec	e8 00 00 00 00	 call	 ?IsMember@CConMember@@QAEHPAD@Z ; CConMember::IsMember
  001f1	85 c0		 test	 eax, eax
  001f3	75 13		 jne	 SHORT $LN5@CSPJoinIdP

; 3094 : 		{
; 3095 : 			GCJoinResult(0x02, aIndex);

  001f5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001f8	50		 push	 eax
  001f9	6a 02		 push	 2
  001fb	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult
  00200	83 c4 08	 add	 esp, 8

; 3096 : 			return;

  00203	e9 ea 02 00 00	 jmp	 $LN12@CSPJoinIdP
$LN5@CSPJoinIdP:

; 3097 : 		}
; 3098 : 	}
; 3099 : 
; 3100 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00208	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0020f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00215	89 45 d8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 3101 : 	if( PacketCheckTime(lpObj) == FALSE ) //  ..

  00218	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00221	83 c4 04	 add	 esp, 4
  00224	85 c0		 test	 eax, eax
  00226	75 33		 jne	 SHORT $LN7@CSPJoinIdP

; 3102 : 	{
; 3103 : 		LogAdd(lMsg.Get(473), aIndex, id);

  00228	8d 45 dc	 lea	 eax, DWORD PTR _id$[ebp]
  0022b	50		 push	 eax
  0022c	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0022f	51		 push	 ecx
  00230	68 d9 01 00 00	 push	 473			; 000001d9H
  00235	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0023a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00240	50		 push	 eax
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00247	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3104 : 		CloseClient ( aIndex );

  0024a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00253	83 c4 04	 add	 esp, 4

; 3105 : 		return;

  00256	e9 97 02 00 00	 jmp	 $LN12@CSPJoinIdP
$LN7@CSPJoinIdP:

; 3106 : 	}
; 3107 : 	//DevGamesX 01/05/2018 - OffExp
; 3108 : 	OffExp.Close(id);

  0025b	8d 45 dc	 lea	 eax, DWORD PTR _id$[ebp]
  0025e	50		 push	 eax
  0025f	b9 00 00 00 00	 mov	 ecx, OFFSET ?OffExp@@3VcOffExp@@A ; OffExp
  00264	e8 00 00 00 00	 call	 ?Close@cOffExp@@QAEXPAD@Z ; cOffExp::Close

; 3109 : 	OFFSystem.Closeoffafk(id);

  00269	8d 45 dc	 lea	 eax, DWORD PTR _id$[ebp]
  0026c	50		 push	 eax
  0026d	b9 00 00 00 00	 mov	 ecx, OFFSET ?OFFSystem@@3VCOFFSystem@@A ; OFFSystem
  00272	e8 00 00 00 00	 call	 ?Closeoffafk@COFFSystem@@QAEXPAD@Z ; COFFSystem::Closeoffafk

; 3110 : 	OFFtrade.Closeofftrade(id);

  00277	8d 45 dc	 lea	 eax, DWORD PTR _id$[ebp]
  0027a	50		 push	 eax
  0027b	b9 00 00 00 00	 mov	 ecx, OFFSET ?OFFtrade@@3VCOFFtrade@@A ; OFFtrade
  00280	e8 00 00 00 00	 call	 ?Closeofftrade@COFFtrade@@QAEXPAD@Z ; COFFtrade::Closeofftrade

; 3111 : 
; 3112 : 
; 3113 : 	if( gObj[aIndex].Connected != CSS_LOGIN ) 

  00285	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0028c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00292	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  00297	74 33		 je	 SHORT $LN8@CSPJoinIdP

; 3114 : 	{
; 3115 : 		LogAdd(lMsg.Get(474), aIndex, id);

  00299	8d 45 dc	 lea	 eax, DWORD PTR _id$[ebp]
  0029c	50		 push	 eax
  0029d	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002a0	51		 push	 ecx
  002a1	68 da 01 00 00	 push	 474			; 000001daH
  002a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002b1	50		 push	 eax
  002b2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3116 : 		CloseClient ( aIndex );

  002bb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002c4	83 c4 04	 add	 esp, 4

; 3117 : 		return;

  002c7	e9 26 02 00 00	 jmp	 $LN12@CSPJoinIdP
$LN8@CSPJoinIdP:

; 3118 : 	}
; 3119 : 	if( gObj[aIndex].LoginMsgSnd != 0 )

  002cc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d9	0f be 54 01 08	 movsx	 edx, BYTE PTR [ecx+eax+8]
  002de	85 d2		 test	 edx, edx
  002e0	0f 84 81 00 00
	00		 je	 $LN9@CSPJoinIdP

; 3120 : 	{
; 3121 : 		if( gObj[aIndex].LoginMsgSnd == 1 )

  002e6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f3	0f be 54 01 08	 movsx	 edx, BYTE PTR [ecx+eax+8]
  002f8	83 fa 01	 cmp	 edx, 1
  002fb	75 36		 jne	 SHORT $LN10@CSPJoinIdP

; 3122 : 		{
; 3123 : 			LogAdd(lMsg.Get(475), aIndex, id, gObj[aIndex].Ip_addr);

  002fd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00304	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0030a	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0030e	52		 push	 edx
  0030f	8d 45 dc	 lea	 eax, DWORD PTR _id$[ebp]
  00312	50		 push	 eax
  00313	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00316	51		 push	 ecx
  00317	68 db 01 00 00	 push	 475			; 000001dbH
  0031c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00327	50		 push	 eax
  00328	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0032e	83 c4 10	 add	 esp, 16			; 00000010H

; 3124 : 		}

  00331	eb 2f		 jmp	 SHORT $LN11@CSPJoinIdP
$LN10@CSPJoinIdP:

; 3125 : 		else {
; 3126 : 			LogAdd("error : %d %s %d",gObj[aIndex].LoginMsgSnd, __FILE__, __LINE__);

  00333	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z@4JA
  00338	83 c0 46	 add	 eax, 70			; 00000046H
  0033b	50		 push	 eax
  0033c	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00341	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00348	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0034e	0f be 44 0a 08	 movsx	 eax, BYTE PTR [edx+ecx+8]
  00353	50		 push	 eax
  00354	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd@
  00359	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0035f	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@CSPJoinIdP:

; 3127 : 		}
; 3128 : 		return;

  00362	e9 8b 01 00 00	 jmp	 $LN12@CSPJoinIdP
$LN9@CSPJoinIdP:

; 3129 : 	}
; 3130 : 	SDHP_IDPASS	spMsg;
; 3131 : 
; 3132 : 	PHeadSetB((LPBYTE)&spMsg, 0x01, sizeof( spMsg ));

  00367	6a 2c		 push	 44			; 0000002cH
  00369	6a 01		 push	 1
  0036b	8d 45 ac	 lea	 eax, DWORD PTR _spMsg$[ebp]
  0036e	50		 push	 eax
  0036f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00374	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3133 : 
; 3134 : 	spMsg.Number     = aIndex;

  00377	66 8b 45 0c	 mov	 ax, WORD PTR _aIndex$[ebp]
  0037b	66 89 45 c4	 mov	 WORD PTR _spMsg$[ebp+24], ax

; 3135 : 	memcpy(spMsg.Id,   lpMsg->Id,   MAX_IDSTRING);

  0037f	6a 0a		 push	 10			; 0000000aH
  00381	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00384	83 c0 04	 add	 eax, 4
  00387	50		 push	 eax
  00388	8d 4d af	 lea	 ecx, DWORD PTR _spMsg$[ebp+3]
  0038b	51		 push	 ecx
  0038c	e8 00 00 00 00	 call	 _memcpy
  00391	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3136 : #ifdef PW_KUZIMO
; 3137 : 	memcpy(spMsg.Pass, lpMsg->Pass, MAX_IDSTRING);//MAX_PASSWORD_LENGTH);
; 3138 : #else
; 3139 : 	memcpy(spMsg.Pass, lpMsg->Pass, MAX_IDSTRING);

  00394	6a 0a		 push	 10			; 0000000aH
  00396	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00399	83 c0 0e	 add	 eax, 14			; 0000000eH
  0039c	50		 push	 eax
  0039d	8d 4d b9	 lea	 ecx, DWORD PTR _spMsg$[ebp+13]
  003a0	51		 push	 ecx
  003a1	e8 00 00 00 00	 call	 _memcpy
  003a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3140 : #endif
; 3141 : 	strcpy(spMsg.IpAddress, gObj[aIndex].Ip_addr);

  003a9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b6	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  003ba	52		 push	 edx
  003bb	8d 45 c6	 lea	 eax, DWORD PTR _spMsg$[ebp+26]
  003be	50		 push	 eax
  003bf	e8 00 00 00 00	 call	 _strcpy
  003c4	83 c4 08	 add	 esp, 8

; 3142 : 
; 3143 : 
; 3144 : #if (TESTSERVER==1)
; 3145 : 	//     IP    .
; 3146 : 	//strcpy(spMsg.IpAddress, "61.35.132.2");
; 3147 : #endif
; 3148 : 	
; 3149 : 	gObj[aIndex].CheckTick				 = lpMsg->TickCount;

  003c7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d4	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  003d7	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  003da	89 54 01 3c	 mov	 DWORD PTR [ecx+eax+60], edx

; 3150 : 	gObj[aIndex].CheckTick2				 = GetTickCount();

  003de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  003e4	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f1	89 44 0a 44	 mov	 DWORD PTR [edx+ecx+68], eax

; 3151 : 	gObj[aIndex].ConnectCheckTime		 = GetTickCount();

  003f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  003fb	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00402	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00408	89 44 0a 38	 mov	 DWORD PTR [edx+ecx+56], eax

; 3152 : 	gObj[aIndex].CheckSpeedHack			 = 1;

  0040c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00413	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00419	c6 44 01 40 01	 mov	 BYTE PTR [ecx+eax+64], 1

; 3153 : 	gObj[aIndex].ConnectCheckTime 		 = GetTickCount();

  0041e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00424	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0042b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00431	89 44 0a 38	 mov	 DWORD PTR [edx+ecx+56], eax

; 3154 : 	gObj[aIndex].LoginMsgSnd			 = 1;

  00435	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0043c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00442	c6 44 01 08 01	 mov	 BYTE PTR [ecx+eax+8], 1

; 3155 : 	gObj[aIndex].LoginMsgCount++;

  00447	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0044e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00454	8a 54 01 09	 mov	 dl, BYTE PTR [ecx+eax+9]
  00458	80 c2 01	 add	 dl, 1
  0045b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00462	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00468	88 54 01 09	 mov	 BYTE PTR [ecx+eax+9], dl

; 3156 : 	gObj[aIndex].AccountID[MAX_IDSTRING] = '\0';

  0046c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00473	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00479	b9 01 00 00 00	 mov	 ecx, 1
  0047e	6b d1 0a	 imul	 edx, ecx, 10
  00481	c6 44 10 68 00	 mov	 BYTE PTR [eax+edx+104], 0

; 3157 : 	memcpy(gObj[aIndex].AccountID, id, MAX_IDSTRING);

  00486	6a 0a		 push	 10			; 0000000aH
  00488	8d 45 dc	 lea	 eax, DWORD PTR _id$[ebp]
  0048b	50		 push	 eax
  0048c	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00493	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00499	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0049d	50		 push	 eax
  0049e	e8 00 00 00 00	 call	 _memcpy
  004a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3158 : 
; 3159 : 	gObj[aIndex].m_cAccountItemBlock = FALSE;

  004a6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004b3	c6 84 01 ac 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+428], 0

; 3160 : 
; 3161 : #ifdef FOR_THAILAND	
; 3162 : 	gObj[aIndex].m_AuthAdult = 0;
; 3163 : 	gObj[aIndex].m_DisplayTeenLogOutMsg = FALSE;
; 3164 : #endif
; 3165 : 	
; 3166 : #ifdef ADD_PROTOCOL_PCBANG_GUID	
; 3167 : 	gObj[aIndex].PcBangGuid = 0;
; 3168 : #endif
; 3169 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  004bb	0f b6 45 ad	 movzx	 eax, BYTE PTR _spMsg$[ebp+1]
  004bf	50		 push	 eax
  004c0	8d 4d ac	 lea	 ecx, DWORD PTR _spMsg$[ebp]
  004c3	51		 push	 ecx
  004c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  004c9	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 3170 : 	LogAddTD("join send : (%d)%s", aIndex, gObj[aIndex].AccountID);

  004ce	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004db	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  004df	52		 push	 edx
  004e0	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004e3	50		 push	 eax
  004e4	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs@
  004e9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004ef	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@CSPJoinIdP:

; 3171 : 	
; 3172 : #ifdef MAP_SERVER_WORK_20041030			//     
; 3173 : 	lpObj->m_bMapSvrMoveReq				= false;
; 3174 : 	lpObj->m_sPrevMapSvrCode			= -1;
; 3175 : 	lpObj->m_sDestMapNumber				= -1;
; 3176 : 	lpObj->m_btDestX					= 0;
; 3177 : 	lpObj->m_btDestY					= 0;
; 3178 : #endif
; 3179 : 
; 3180 : #ifdef CHN_PLAYTIME_LIMIT_SYSTEM_20050818
; 3181 : 	lpObj->m_iPlayTimeLimit				= 0;
; 3182 : 	lpObj->m_iPlayNoticeTick			= 0;
; 3183 : 	lpObj->m_dwPlayTick					= GetTickCount();
; 3184 : #endif
; 3185 : 	
; 3186 : #ifdef VTM_PLAYTIME_LIMIT_SYSTEM_20060626
; 3187 : 	lpObj->m_iPlayTimeLimit				= 0;
; 3188 : 	lpObj->m_iPlayRestTime				= 0;
; 3189 : 	lpObj->m_iPlayNoticeTick			= 0;
; 3190 : 	lpObj->m_dwPlayTick					= GetTickCount();
; 3191 : #endif
; 3192 : }

  004f2	5f		 pop	 edi
  004f3	5e		 pop	 esi
  004f4	5b		 pop	 ebx
  004f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f8	33 cd		 xor	 ecx, ebp
  004fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ff	8b e5		 mov	 esp, ebp
  00501	5d		 pop	 ebp
  00502	c3		 ret	 0
?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z ENDP	; CSPJoinIdPassRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?PEchoProc@@YAXPAEHF@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_aMsg$ = 8						; size = 4
_aLen$ = 12						; size = 4
_aIndex$ = 16						; size = 2
?PEchoProc@@YAXPAEHF@Z PROC				; PEchoProc, COMDAT

; 2184 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2185 : 	for( int n=0; n<MAX_OBJECT; n++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@PEchoProc
$LN2@PEchoProc:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@PEchoProc:
  0001b	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00022	7d 2a		 jge	 SHORT $LN1@PEchoProc

; 2186 : 	{
; 2187 : 		if( gObj[n].Connected >= 1 )

  00024	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00031	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  00036	7c 14		 jl	 SHORT $LN5@PEchoProc

; 2188 : 		{
; 2189 : 			DataSend(n, (LPBYTE)aMsg, aLen);

  00038	8b 45 0c	 mov	 eax, DWORD PTR _aLen$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _aMsg$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 fc	 mov	 edx, DWORD PTR _n$1[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@PEchoProc:

; 2190 : 		}
; 2191 : 	}

  0004c	eb c4		 jmp	 SHORT $LN2@PEchoProc
$LN1@PEchoProc:

; 2192 : 	
; 2193 : 	//MsgSendV2(&gObj[aIndex], (LPBYTE)aMsg, aLen);
; 2194 : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?PEchoProc@@YAXPAEHF@Z ENDP				; PEchoProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z
_TEXT	SEGMENT
_msg$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z PROC		; CGClientMsg, COMDAT

; 3373 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3374 : 	if(gObj[aIndex].m_bShell == true)

  00016	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	0f b6 94 01 7d
	1a 00 00	 movzx	 edx, BYTE PTR [ecx+eax+6781]
  0002b	83 fa 01	 cmp	 edx, 1
  0002e	75 05		 jne	 SHORT $LN2@CGClientMs

; 3375 : 		return;

  00030	e9 40 01 00 00	 jmp	 $LN1@CGClientMs
$LN2@CGClientMs:

; 3376 : 
; 3377 : #ifdef CHANGE_CLIENTHACKCHECK_MSG	
; 3378 : 	if( lpMsg->Flag != 0x00 )

  00035	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00038	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 49		 je	 SHORT $LN3@CGClientMs

; 3379 : 	{
; 3380 : 		LogAddC(LOGC_RED, "error-L1 : HackCheck [%s][%s] 0x%x 0x%x", 

  00040	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00043	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00047	51		 push	 ecx
  00048	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0004b	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0004f	50		 push	 eax
  00050	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00057	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005d	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00061	50		 push	 eax
  00062	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00069	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006f	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50@
  00079	6a 02		 push	 2
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00081	83 c4 18	 add	 esp, 24			; 00000018H

; 3381 : 				gObj[aIndex].AccountID, 
; 3382 : 				gObj[aIndex].Name, 
; 3383 : 				lpMsg->Flag,
; 3384 : 				lpMsg->subFlag);
; 3385 : 	}

  00084	e9 b8 00 00 00	 jmp	 $LN4@CGClientMs
$LN3@CGClientMs:

; 3386 : 	else
; 3387 : 	{		
; 3388 : 		if( (gObj[aIndex].m_ClientHackLogCount < 100 ) )

  00089	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00096	0f b6 94 01 ea
	0e 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3818]
  0009e	83 fa 64	 cmp	 edx, 100		; 00000064H
  000a1	7d 44		 jge	 SHORT $LN5@CGClientMs

; 3389 : 		{
; 3390 : 			LogAddC(LOGC_RED, "error-L1 : HackCheck [%s][%s] 0x%x 0x%x", 

  000a3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000aa	51		 push	 ecx
  000ab	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000ae	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000b2	50		 push	 eax
  000b3	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c0	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  000c4	50		 push	 eax
  000c5	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d2	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50@
  000dc	6a 02		 push	 2
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000e4	83 c4 18	 add	 esp, 24			; 00000018H
$LN5@CGClientMs:

; 3391 : 					gObj[aIndex].AccountID, 
; 3392 : 					gObj[aIndex].Name, 
; 3393 : 					lpMsg->Flag,
; 3394 : 					lpMsg->subFlag);
; 3395 : 		}
; 3396 : 
; 3397 : 		gObj[aIndex].m_ClientHackLogCount++;

  000e7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f4	8a 94 01 ea 0e
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3818]
  000fb	80 c2 01	 add	 dl, 1
  000fe	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010b	88 94 01 ea 0e
	00 00		 mov	 BYTE PTR [ecx+eax+3818], dl

; 3398 : 		if( gObj[aIndex].m_ClientHackLogCount >= 100 )

  00112	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00119	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011f	0f b6 94 01 ea
	0e 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3818]
  00127	83 fa 64	 cmp	 edx, 100		; 00000064H
  0012a	7c 15		 jl	 SHORT $LN4@CGClientMs

; 3399 : 		{
; 3400 : 			gObj[aIndex].m_ClientHackLogCount = 100;

  0012c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00133	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00139	c6 84 01 ea 0e
	00 00 64	 mov	 BYTE PTR [ecx+eax+3818], 100 ; 00000064H
$LN4@CGClientMs:

; 3401 : 		}
; 3402 : 	}	
; 3403 : #else
; 3404 : 	LogAddC(LOGC_RED, "error-L1 : HackCheck [%s][%s] 0x%x", gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->Flag);
; 3405 : #endif
; 3406 : #ifdef HACK_LOG	
; 3407 : 	char msg[255];
; 3408 : 	wsprintf(msg, "Client HackCheck %u", (DWORD)lpMsg->Flag);

  00141	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00144	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00148	51		 push	 ecx
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@EJDMDEO@Client?5HackCheck?5?$CFu@
  0014e	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _msg$[ebp]
  00154	52		 push	 edx
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3409 : 	gSendHackLog.Send(aIndex, 0, msg);

  0015e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00164	50		 push	 eax
  00165	6a 00		 push	 0
  00167	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0016a	51		 push	 ecx
  0016b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSendHackLog@@3VCSendHackLog@@A ; gSendHackLog
  00170	e8 00 00 00 00	 call	 ?Send@CSendHackLog@@QAEXHEPAD@Z ; CSendHackLog::Send
$LN1@CGClientMs:

; 3410 : #endif
; 3411 : 
; 3412 : 	if( lpMsg->Flag == 0x00 )
; 3413 : 	{
; 3414 : 		//gObjCloseSet(aIndex, CL_EXIT);	
; 3415 : 	}
; 3416 : }

  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx
  00178	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017b	33 cd		 xor	 ecx, ebp
  0017d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z ENDP		; CGClientMsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z PROC ; CGCheckMainRecv, COMDAT

; 2119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2120 : #if( TESTSERVER == 1 )	
; 2121 : 	gObj[aIndex].CheckSumTime = 0;
; 2122 : 	gObj[aIndex].m_InWebzen	= 1;
; 2123 : 	return;
; 2124 : #endif
; 2125 : 
; 2126 : #if( LOCALCONNECT == 0 )	
; 2127 : #ifdef MODIFY_WEBZEN_PUBLIC_IPADDRESS_20050822
; 2128 : 	if( strcmp(gObj[aIndex].Ip_addr , WEBZEN_PUBLIC_IPADDRESS) == 0 ) 
; 2129 : #else
; 2130 : 	if( strcmp(gObj[aIndex].Ip_addr , "218.234.76.33") == 0 ) 

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DINGPLDD@218?4234?476?433@
  0000e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001b	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 _strcmp
  00025	83 c4 08	 add	 esp, 8
  00028	85 c0		 test	 eax, eax
  0002a	75 2f		 jne	 SHORT $LN2@CGCheckMai

; 2131 : #endif	
; 2132 : 	{
; 2133 : 		gObj[aIndex].CheckSumTime = 0;

  0002c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00039	c7 44 01 60 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+96], 0

; 2134 : 		gObj[aIndex].m_InWebzen	= 1;

  00041	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	c6 84 01 e8 0e
	00 00 01	 mov	 BYTE PTR [ecx+eax+3816], 1

; 2135 : 		return;

  00056	e9 17 01 00 00	 jmp	 $LN1@CGCheckMai
$LN2@CGCheckMai:

; 2136 : 	}
; 2137 : #endif
; 2138 : 
; 2139 : #ifdef CHECKSUM_REMOVE
; 2140 : 	gObj[aIndex].CheckSumTime = 0;
; 2141 : 	return;
; 2142 : #endif
; 2143 : 
; 2144 : 	if(g_GlobalConfig.m_bEnableChecksum == TRUE)

  0005b	83 3d 38 00 00
	00 01		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+56, 1
  00062	0f 85 f5 00 00
	00		 jne	 $LN3@CGCheckMai

; 2145 : 	{
; 2146 : 		//LogAddL("error-L1 :   key : %d %d", gObj[aIndex].CheckSumTableNum, lpMsg->m_dwKey);
; 2147 : 
; 2148 : 		if( gObj[aIndex].CheckSumTableNum < 0 || gObj[aIndex].CheckSumTableNum > 1023 )

  00068	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00075	0f bf 54 01 5c	 movsx	 edx, WORD PTR [ecx+eax+92]
  0007a	85 d2		 test	 edx, edx
  0007c	7c 1a		 jl	 SHORT $LN5@CGCheckMai
  0007e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008b	0f bf 54 01 5c	 movsx	 edx, WORD PTR [ecx+eax+92]
  00090	81 fa ff 03 00
	00		 cmp	 edx, 1023		; 000003ffH
  00096	7e 43		 jle	 SHORT $LN4@CGCheckMai
$LN5@CGCheckMai:

; 2149 : 		{
; 2150 : 			LogAdd("error-L1 : [%s][%s] CheckSum-Exe error ", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00098	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a5	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000a9	52		 push	 edx
  000aa	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b7	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000bb	52		 push	 edx
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PHFKNJAD@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSum?9Ex@
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2151 : 			CloseClient(aIndex);

  000ca	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000d3	83 c4 04	 add	 esp, 4

; 2152 : 			return;

  000d6	e9 97 00 00 00	 jmp	 $LN1@CGCheckMai
$LN4@CGCheckMai:

; 2153 : 		}
; 2154 : 	
; 2155 : #ifdef MULTI_CHECKSUM
; 2156 : 		if( !g_MultiChecksum.CompareCheckSum(aIndex, gObj[aIndex].CheckSumTableNum, lpMsg->m_dwKey ) )
; 2157 : 		{
; 2158 : 			LogAddC(LOGC_RED,"error-L1 : CheckSum-Exe error %d %d [%s]",
; 2159 : 					 lpMsg->m_dwKey, 
; 2160 : 					 gObj[aIndex].CheckSumTableNum, 
; 2161 : 					 gObj[aIndex].AccountID);
; 2162 : 			CloseClient(aIndex);
; 2163 : 			return;
; 2164 : 		}
; 2165 : #else
; 2166 : 		if( dwgCheckSum[gObj[aIndex].CheckSumTableNum] != lpMsg->m_dwKey )

  000db	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e8	0f bf 54 01 5c	 movsx	 edx, WORD PTR [ecx+eax+92]
  000ed	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000f0	8b 0c 95 00 00
	00 00		 mov	 ecx, DWORD PTR ?dwgCheckSum@@3PAKA[edx*4]
  000f7	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000fa	74 61		 je	 SHORT $LN3@CGCheckMai

; 2167 : 		{
; 2168 : 			LogAddTD("error-L1 : CheckSum-Exe error %d %d %d [%s]", 

  000fc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00109	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0010d	52		 push	 edx
  0010e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00115	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011b	0f bf 54 01 5c	 movsx	 edx, WORD PTR [ecx+eax+92]
  00120	52		 push	 edx
  00121	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00124	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00127	51		 push	 ecx
  00128	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00134	0f bf 4c 10 5c	 movsx	 ecx, WORD PTR [eax+edx+92]
  00139	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?dwgCheckSum@@3PAKA[ecx*4]
  00140	52		 push	 edx
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@ECHKHDMC@error?9L1?5?3?5CheckSum?9Exe?5error?5?$CF@
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0014c	83 c4 14	 add	 esp, 20			; 00000014H

; 2169 : 					 dwgCheckSum[gObj[aIndex].CheckSumTableNum] , 
; 2170 : 					 lpMsg->m_dwKey, 
; 2171 : 					 gObj[aIndex].CheckSumTableNum, 
; 2172 : 					 gObj[aIndex].AccountID);
; 2173 : 			CloseClient(aIndex);

  0014f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00158	83 c4 04	 add	 esp, 4

; 2174 : 			return;

  0015b	eb 15		 jmp	 SHORT $LN1@CGCheckMai
$LN3@CGCheckMai:

; 2175 : 		}
; 2176 : #endif
; 2177 : 	}
; 2178 : 	gObj[aIndex].CheckSumTime		= 0;

  0015d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00164	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016a	c7 44 01 60 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+96], 0
$LN1@CGCheckMai:

; 2179 : }

  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ENDP ; CGCheckMainRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z
_TEXT	SEGMENT
_checktime$1 = -12					; size = 4
_usertick$2 = -8					; size = 4
_systemtick$3 = -4					; size = 4
_lpClientTime$ = 8					; size = 4
_aIndex$ = 12						; size = 2
?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z PROC		; CGLiveClient, COMDAT

; 1975 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1976 : 	
; 1977 : #ifdef MODIFY_CONNECTTIME_CHECK_20060424
; 1978 : 	//     ConnectCheckTime    .
; 1979 : 	if( gObj[aIndex].Connected > CSS_LOGIN )

  00009	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0000d	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00013	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00019	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  0001e	7e 1a		 jle	 SHORT $LN2@CGLiveClie

; 1980 : 	{
; 1981 : 		gObj[aIndex].ConnectCheckTime = GetTickCount();

  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00026	0f bf 4d 0c	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  0002a	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00036	89 44 11 38	 mov	 DWORD PTR [ecx+edx+56], eax
$LN2@CGLiveClie:

; 1982 : 	}
; 1983 : #else
; 1984 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();
; 1985 : #endif
; 1986 : 
; 1987 : 	//    10  
; 1988 : #if (SPEEDHACK_CHECK == 0) 
; 1989 : 	return;
; 1990 : #endif
; 1991 : #if (TESTSERVER == 1 )
; 1992 : 	return;
; 1993 : #endif
; 1994 : 
; 1995 : 	if(gObj[aIndex].m_bShell == true)

  0003a	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0003e	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00044	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004a	0f b6 84 0a 7d
	1a 00 00	 movzx	 eax, BYTE PTR [edx+ecx+6781]
  00052	83 f8 01	 cmp	 eax, 1
  00055	75 05		 jne	 SHORT $LN3@CGLiveClie

; 1996 : 		return;

  00057	e9 2f 01 00 00	 jmp	 $LN1@CGLiveClie
$LN3@CGLiveClie:

; 1997 : 	
; 1998 : 	//   .
; 1999 : 	if( gObj[aIndex].CheckSpeedHack )

  0005c	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00060	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00066	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006c	0f b6 44 0a 40	 movzx	 eax, BYTE PTR [edx+ecx+64]
  00071	85 c0		 test	 eax, eax
  00073	0f 84 12 01 00
	00		 je	 $LN1@CGLiveClie

; 2000 : 	{
; 2001 : 		int systemtick;
; 2002 : 		int usertick;
; 2003 : 		int checktime;
; 2004 : 		systemtick = GetTickCount()-gObj[aIndex].CheckTick2;

  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0007f	0f bf 4d 0c	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00083	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008f	2b 44 11 44	 sub	 eax, DWORD PTR [ecx+edx+68]
  00093	89 45 fc	 mov	 DWORD PTR _systemtick$3[ebp], eax

; 2005 : 		usertick   = (lpClientTime->Time-gObj[aIndex].CheckTick);

  00096	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0009a	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  000a0	8b 55 08	 mov	 edx, DWORD PTR _lpClientTime$[ebp]
  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a8	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000ab	2b 54 08 3c	 sub	 edx, DWORD PTR [eax+ecx+60]
  000af	89 55 f8	 mov	 DWORD PTR _usertick$2[ebp], edx

; 2006 : 		checktime = systemtick-usertick;

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _systemtick$3[ebp]
  000b5	2b 45 f8	 sub	 eax, DWORD PTR _usertick$2[ebp]
  000b8	89 45 f4	 mov	 DWORD PTR _checktime$1[ebp], eax

; 2007 : 		//LogAdd("  : %d system:%d user:%d total:%d (%d %d)", lpClientTime->Time,systemtick, usertick,checktime, gObj[aIndex].CheckTick2, gObj[aIndex].CheckTick);
; 2008 : 		//if( (checktime < -(7*1000)) || (checktime > (7*1000)) ) 
; 2009 : 		//    
; 2010 : 		if( checktime < -(7*1000) ) 

  000bb	81 7d f4 a8 e4
	ff ff		 cmp	 DWORD PTR _checktime$1[ebp], -7000 ; ffffe4a8H
  000c2	7d 54		 jge	 SHORT $LN5@CGLiveClie

; 2011 : 		{
; 2012 : 			LogAddTD(lMsg.Get(470),gObj[aIndex].AccountID, gObj[aIndex].Name, checktime);

  000c4	8b 45 f4	 mov	 eax, DWORD PTR _checktime$1[ebp]
  000c7	50		 push	 eax
  000c8	0f bf 4d 0c	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  000cc	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  000d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d7	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  000db	51		 push	 ecx
  000dc	0f bf 55 0c	 movsx	 edx, WORD PTR _aIndex$[ebp]
  000e0	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  000e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ec	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000f0	52		 push	 edx
  000f1	68 d6 01 00 00	 push	 470			; 000001d6H
  000f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00101	50		 push	 eax
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00108	83 c4 10	 add	 esp, 16			; 00000010H

; 2013 : 			CloseClient(aIndex);

  0010b	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00115	83 c4 04	 add	 esp, 4
$LN5@CGLiveClie:

; 2014 : 		}
; 2015 : 
; 2016 : 		gObj[aIndex].CheckTickCount++;

  00118	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0011c	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00122	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00128	8a 44 0a 48	 mov	 al, BYTE PTR [edx+ecx+72]
  0012c	04 01		 add	 al, 1
  0012e	0f bf 4d 0c	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00132	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013e	88 44 11 48	 mov	 BYTE PTR [ecx+edx+72], al

; 2017 : 		if( gObj[aIndex].CheckTickCount > 45 ) 

  00142	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00146	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0014c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00152	0f b6 44 0a 48	 movzx	 eax, BYTE PTR [edx+ecx+72]
  00157	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0015a	7e 2f		 jle	 SHORT $LN1@CGLiveClie

; 2018 : 		{	// 15        20   , 60..
; 2019 : 			gObj[aIndex].CheckTick = lpClientTime->Time;

  0015c	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00160	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00166	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016c	8b 45 08	 mov	 eax, DWORD PTR _lpClientTime$[ebp]
  0016f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00172	89 44 0a 3c	 mov	 DWORD PTR [edx+ecx+60], eax

; 2020 : 			gObj[aIndex].CheckTickCount = 0;

  00176	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0017a	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00180	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00186	c6 44 0a 48 00	 mov	 BYTE PTR [edx+ecx+72], 0
$LN1@CGLiveClie:

; 2021 : 		}
; 2022 : 		/*
; 2023 : 		if( gObj[aIndex].Connected == CSS_GAMEPLAYING )
; 2024 : 		{			
; 2025 : 			if( gObj[aIndex].pInventory[EQUIPMENT_BOOTS].IsItem() )
; 2026 : 			{
; 2027 : 				if( lpClientTime->BootsLevel > gObj[aIndex].pInventory[EQUIPMENT_BOOTS].GetLevel() )
; 2028 : 				{
; 2029 : 					LogAddTD("[%s][%s]      %d",gObj[aIndex].AccountID, gObj[aIndex].Name, lpClientTime->BootsLevel);
; 2030 : 					CloseClient(aIndex);
; 2031 : 				}
; 2032 : 			}
; 2033 : 		}
; 2034 : 		*/
; 2035 : 	}
; 2036 : 
; 2037 : // 	if( gObj[aIndex].Connected == CSS_GAMEPLAYING )
; 2038 : // 	{
; 2039 : // #ifdef MODIFY_SPEEDHACK_20080605
; 2040 : // 		if (g_bAbilityDebug == TRUE) {
; 2041 : // 			char szMsg[256];
; 2042 : // 			sprintf(szMsg, "AttackSpeed: %d,%d MagicSpeed: %d,%d", gObj[aIndex].m_AttackSpeed, lpClientTime->AttackSpeed, gObj[aIndex].m_MagicSpeed, lpClientTime->MagicSpeed);
; 2043 : // 			GCServerMsgStringSend(szMsg, gObj[aIndex].m_Index, 1);
; 2044 : // 		}
; 2045 : // #endif // MODIFY_SPEEDHACK_20080605
; 2046 : // 
; 2047 : // 		//   -    .
; 2048 : // 		if( gObj[aIndex].m_AttackSpeed < lpClientTime->AttackSpeed || 
; 2049 : // 		gObj[aIndex].m_MagicSpeed < lpClientTime->MagicSpeed )
; 2050 : // 		{
; 2051 : // 			LogAddC(LOGC_RED, "[%s][%s][%s] ClientHack Detected : Editing AttackSpeed [%d][%d] [%d][%d]", 
; 2052 : // 					gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr,
; 2053 : // 					gObj[aIndex].m_AttackSpeed,lpClientTime->AttackSpeed,
; 2054 : // 					gObj[aIndex].m_MagicSpeed,lpClientTime->MagicSpeed);
; 2055 : // 
; 2056 : // #ifdef MODIFY_SPEEDHACK_20080605
; 2057 : // 			LogAddC(LOGC_RED, "[%s][%s][%s] ClientHack Detected CheckSpeedHack : [%s]", 
; 2058 : // 				gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr,
; 2059 : // 				(g_bCheckSpeedHack) ? "TRUE" : "FALSE");
; 2060 : // #endif // MODIFY_SPEEDHACK_20080605
; 2061 : // 
; 2062 : // 			if (!g_bCheckSpeedHack) return;
; 2063 : // 
; 2064 : // 			gObj[aIndex].m_AttackSpeedHackDetectedCount++;
; 2065 : // 
; 2066 : // 			if( gObj[aIndex].m_AttackSpeedHackDetectedCount > 3)
; 2067 : // 			{
; 2068 : // #if 0 // DISABLE THIS SHIT
; 2069 : // 				CloseClient(aIndex);
; 2070 : // #endif
; 2071 : // 			}
; 2072 : // 		}
; 2073 : // 		else
; 2074 : // 		{
; 2075 : // 			gObj[aIndex].m_AttackSpeedHackDetectedCount = 0;
; 2076 : // 		}
; 2077 : // 
; 2078 : // #ifdef AUTH_GAMESERVER_CHECKKEY
; 2079 : // 	if( szAuthKey[10] != AUTH_CHECK_10 )
; 2080 : // 		DestroyGIocp();
; 2081 : // #endif
; 2082 : // 
; 2083 : // #ifdef AUTH_GAMESERVER_CHECKKEY
; 2084 : // 	if( szAuthKey[11] != AUTH_CHECK_11 )
; 2085 : // 		DestroyGIocp();
; 2086 : // #endif
; 2087 : // 	}
; 2088 : }

  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5b		 pop	 ebx
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ENDP		; CGLiveClient
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z
_TEXT	SEGMENT
$T1 = -324						; size = 4
_szTargetNameCount$2 = -256				; size = 4
_pChatMsg$3 = -252					; size = 146
_index$ = -104						; size = 4
_lpObj$ = -100						; size = 4
_len$ = -96						; size = 4
_pWhisper$ = -92					; size = 73
_tid$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z PROC ; CGChatWhisperRecv, COMDAT

; 2936 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2937 : 	char tid[MAX_IDSTRING+1];
; 2938 : 	PMSG_CHATDATA_WHISPER pWhisper;
; 2939 : 	int  len;
; 2940 : 	
; 2941 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00016	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 9c	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2942 : 
; 2943 : 	if( PacketCheckTime(lpObj) == FALSE ) return;

  00026	8b 45 9c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	75 05		 jne	 SHORT $LN2@CGChatWhis
  00036	e9 7a 02 00 00	 jmp	 $LN10@CGChatWhis
$LN2@CGChatWhis:

; 2944 : 
; 2945 : #ifdef DARKLORD_WORK
; 2946 : 	if( lpObj->ChatLitmitTime > 0 )

  0003b	8b 45 9c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003e	0f b7 88 dc 00
	00 00		 movzx	 ecx, WORD PTR [eax+220]
  00045	85 c9		 test	 ecx, ecx
  00047	7e 2f		 jle	 SHORT $LN3@CGChatWhis

; 2947 : 	{
; 2948 : 		//  :  %d
; 2949 : 		MsgOutput(lpObj->m_Index,lMsg.Get(1247), lpObj->ChatLitmitTime);

  00049	8b 45 9c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004c	0f b7 88 dc 00
	00 00		 movzx	 ecx, WORD PTR [eax+220]
  00053	51		 push	 ecx
  00054	68 df 04 00 00	 push	 1247			; 000004dfH
  00059	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00064	50		 push	 eax
  00065	8b 55 9c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00068	8b 02		 mov	 eax, DWORD PTR [edx]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2950 : 		return;

  00073	e9 3d 02 00 00	 jmp	 $LN10@CGChatWhis
$LN3@CGChatWhis:

; 2951 : 	}
; 2952 : #endif
; 2953 : 
; 2954 : 	//  ..
; 2955 : 	if( (lpObj->Penalty&CTLCODE_CHATBAN) == CTLCODE_CHATBAN ) return;

  00078	8b 45 9c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007b	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  00081	83 e1 02	 and	 ecx, 2
  00084	74 05		 je	 SHORT $LN4@CGChatWhis
  00086	e9 2a 02 00 00	 jmp	 $LN10@CGChatWhis
$LN4@CGChatWhis:

; 2956 : 
; 2957 : 	tid[MAX_IDSTRING] = '\0';

  0008b	b8 01 00 00 00	 mov	 eax, 1
  00090	6b c8 0a	 imul	 ecx, eax, 10
  00093	89 8d bc fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00099	83 bd bc fe ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  000a0	73 02		 jae	 SHORT $LN11@CGChatWhis
  000a2	eb 05		 jmp	 SHORT $LN12@CGChatWhis
$LN11@CGChatWhis:
  000a4	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN12@CGChatWhis:
  000a9	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  000af	c6 44 15 f0 00	 mov	 BYTE PTR _tid$[ebp+edx], 0

; 2958 : 	memcpy(tid, lpMsg->id, MAX_IDSTRING);

  000b4	6a 0a		 push	 10			; 0000000aH
  000b6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000b9	83 c0 03	 add	 eax, 3
  000bc	50		 push	 eax
  000bd	8d 4d f0	 lea	 ecx, DWORD PTR _tid$[ebp]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _memcpy
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2959 : 
; 2960 : 	int index = WhisperCash.AddCash(tid);

  000c9	8d 45 f0	 lea	 eax, DWORD PTR _tid$[ebp]
  000cc	50		 push	 eax
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?WhisperCash@@3VCWhisperCash@@A ; WhisperCash
  000d2	e8 00 00 00 00	 call	 ?AddCash@CWhisperCash@@QAEHPAD@Z ; CWhisperCash::AddCash
  000d7	89 45 98	 mov	 DWORD PTR _index$[ebp], eax

; 2961 : 	
; 2962 : 	//  ..
; 2963 : 	if( index < 0 )

  000da	83 7d 98 00	 cmp	 DWORD PTR _index$[ebp], 0
  000de	7d 13		 jge	 SHORT $LN5@CGChatWhis

; 2964 : 	{
; 2965 : 		GCServerMsgSend(0, aIndex);

  000e0	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000e3	50		 push	 eax
  000e4	6a 00		 push	 0
  000e6	e8 00 00 00 00	 call	 ?GCServerMsgSend@@YAXEH@Z ; GCServerMsgSend
  000eb	83 c4 08	 add	 esp, 8

; 2966 : 	}

  000ee	e9 c2 01 00 00	 jmp	 $LN10@CGChatWhis
$LN5@CGChatWhis:

; 2967 : 	else 
; 2968 : 	{	//    .
; 2969 : 		PHeadSetB((LPBYTE)&pWhisper, 0x02, sizeof( pWhisper ));

  000f3	6a 49		 push	 73			; 00000049H
  000f5	6a 02		 push	 2
  000f7	8d 45 a4	 lea	 eax, DWORD PTR _pWhisper$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2970 : 		strcpy(pWhisper.id, gObj[aIndex].Name);

  00103	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00110	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00114	52		 push	 edx
  00115	8d 45 a7	 lea	 eax, DWORD PTR _pWhisper$[ebp+3]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 _strcpy
  0011e	83 c4 08	 add	 esp, 8

; 2971 : 		memcpy(pWhisper.chatmsg, lpMsg->chatmsg, MAX_CHAT);

  00121	6a 3c		 push	 60			; 0000003cH
  00123	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00126	83 c0 0d	 add	 eax, 13			; 0000000dH
  00129	50		 push	 eax
  0012a	8d 4d b1	 lea	 ecx, DWORD PTR _pWhisper$[ebp+13]
  0012d	51		 push	 ecx
  0012e	e8 00 00 00 00	 call	 _memcpy
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2972 : #ifdef UNICODE_MODE_20050718
; 2973 : 		pWhisper.chatmsg[MAX_CHAT-2] = '\0';
; 2974 : 		pWhisper.chatmsg[MAX_CHAT-1] = '\0';
; 2975 : 		len = wcslen((WCHAR*)pWhisper.chatmsg);
; 2976 : #else
; 2977 : 		len = strlen(pWhisper.chatmsg);

  00136	8d 45 b1	 lea	 eax, DWORD PTR _pWhisper$[ebp+13]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _strlen
  0013f	83 c4 04	 add	 esp, 4
  00142	89 45 a0	 mov	 DWORD PTR _len$[ebp], eax

; 2978 : #endif
; 2979 : 		if( len > 0 )

  00145	83 7d a0 00	 cmp	 DWORD PTR _len$[ebp], 0
  00149	0f 8e 66 01 00
	00		 jle	 $LN10@CGChatWhis

; 2980 : 		{
; 2981 : 			pWhisper.h.size -= MAX_CHAT;

  0014f	0f b6 45 a5	 movzx	 eax, BYTE PTR _pWhisper$[ebp+1]
  00153	83 e8 3c	 sub	 eax, 60			; 0000003cH
  00156	88 45 a5	 mov	 BYTE PTR _pWhisper$[ebp+1], al

; 2982 : #ifdef UNICODE_MODE_20050718
; 2983 : 			pWhisper.h.size += len*2+2;
; 2984 : 			if (pWhisper.h.size > sizeof(PMSG_CHATDATA_WHISPER))
; 2985 : 				pWhisper.h.size = sizeof(PMSG_CHATDATA_WHISPER);
; 2986 : #else
; 2987 : 			pWhisper.h.size += len+1;

  00159	0f b6 45 a5	 movzx	 eax, BYTE PTR _pWhisper$[ebp+1]
  0015d	8b 4d a0	 mov	 ecx, DWORD PTR _len$[ebp]
  00160	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  00164	88 55 a5	 mov	 BYTE PTR _pWhisper$[ebp+1], dl

; 2988 : #endif
; 2989 : 			DataSend(index, (LPBYTE)&pWhisper, pWhisper.h.size);

  00167	0f b6 45 a5	 movzx	 eax, BYTE PTR _pWhisper$[ebp+1]
  0016b	50		 push	 eax
  0016c	8d 4d a4	 lea	 ecx, DWORD PTR _pWhisper$[ebp]
  0016f	51		 push	 ecx
  00170	8b 55 98	 mov	 edx, DWORD PTR _index$[ebp]
  00173	52		 push	 edx
  00174	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2990 : 
; 2991 : 			CHAT_LOG_DATA	pChatMsg;			
; 2992 : 			int				szTargetNameCount = 0;			

  0017c	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _szTargetNameCount$2[ebp], 0

; 2993 : 
; 2994 : 			if( gWriteChatLog )

  00186	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  0018d	0f 84 22 01 00
	00		 je	 $LN10@CGChatWhis

; 2995 : 			{
; 2996 : 				pChatMsg.h.c = PMHC_BYTE;

  00193	c6 85 04 ff ff
	ff c1		 mov	 BYTE PTR _pChatMsg$3[ebp], 193 ; 000000c1H

; 2997 : 				pChatMsg.h.headcode = 0x02;

  0019a	c6 85 06 ff ff
	ff 02		 mov	 BYTE PTR _pChatMsg$3[ebp+2], 2

; 2998 : 
; 2999 : 				memcpy(pChatMsg.AccountID, gObj[aIndex].AccountID, MAX_IDSTRING);

  001a1	6a 0a		 push	 10			; 0000000aH
  001a3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b0	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001b4	52		 push	 edx
  001b5	8d 85 0a ff ff
	ff		 lea	 eax, DWORD PTR _pChatMsg$3[ebp+6]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 _memcpy
  001c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3000 : 				memcpy(pChatMsg.Name, gObj[aIndex].Name, MAX_IDSTRING);

  001c4	6a 0a		 push	 10			; 0000000aH
  001c6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d3	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001d7	52		 push	 edx
  001d8	8d 85 15 ff ff
	ff		 lea	 eax, DWORD PTR _pChatMsg$3[ebp+17]
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 _memcpy
  001e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3001 : 				pChatMsg.AccountID[MAX_IDSTRING] = NULL;

  001e7	b8 01 00 00 00	 mov	 eax, 1
  001ec	6b c8 0a	 imul	 ecx, eax, 10
  001ef	c6 84 0d 0a ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$3[ebp+ecx+6], 0

; 3002 : 				pChatMsg.Name[MAX_IDSTRING] = NULL;

  001f7	b8 01 00 00 00	 mov	 eax, 1
  001fc	6b c8 0a	 imul	 ecx, eax, 10
  001ff	c6 84 0d 15 ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$3[ebp+ecx+17], 0

; 3003 : 				pChatMsg.wServer = gGameServerCode;

  00207	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0020d	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _pChatMsg$3[ebp+4], ax

; 3004 : 
; 3005 : 				memcpy(pChatMsg.szChatMsg, lpMsg->chatmsg, MAX_CHAT);

  00214	6a 3c		 push	 60			; 0000003cH
  00216	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00219	83 c0 0d	 add	 eax, 13			; 0000000dH
  0021c	50		 push	 eax
  0021d	8d 8d 21 ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$3[ebp+29]
  00223	51		 push	 ecx
  00224	e8 00 00 00 00	 call	 _memcpy
  00229	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3006 : 				pChatMsg.szChatMsg[MAX_CHAT] = NULL;

  0022c	b8 01 00 00 00	 mov	 eax, 1
  00231	6b c8 3c	 imul	 ecx, eax, 60
  00234	c6 84 0d 21 ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$3[ebp+ecx+29], 0

; 3007 : 				pChatMsg.btType = 5;	//  

  0023c	c6 85 20 ff ff
	ff 05		 mov	 BYTE PTR _pChatMsg$3[ebp+28], 5

; 3008 : 
; 3009 : 				strcpy(pChatMsg.szTargetName[szTargetNameCount], gObj[index].Name);

  00243	69 45 98 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00250	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00254	52		 push	 edx
  00255	6b 85 00 ff ff
	ff 0b		 imul	 eax, DWORD PTR _szTargetNameCount$2[ebp], 11
  0025c	8d 8c 05 5e ff
	ff ff		 lea	 ecx, DWORD PTR _pChatMsg$3[ebp+eax+90]
  00263	51		 push	 ecx
  00264	e8 00 00 00 00	 call	 _strcpy
  00269	83 c4 08	 add	 esp, 8

; 3010 : 				szTargetNameCount++;

  0026c	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _szTargetNameCount$2[ebp]
  00272	83 c0 01	 add	 eax, 1
  00275	89 85 00 ff ff
	ff		 mov	 DWORD PTR _szTargetNameCount$2[ebp], eax

; 3011 : 				
; 3012 : 				if( szTargetNameCount != 0 )

  0027b	74 18		 je	 SHORT $LN9@CGChatWhis

; 3013 : 				{
; 3014 : 					pChatMsg.btType |= (szTargetNameCount<<4);				

  0027d	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR _szTargetNameCount$2[ebp]
  00283	c1 e0 04	 shl	 eax, 4
  00286	0f b6 8d 20 ff
	ff ff		 movzx	 ecx, BYTE PTR _pChatMsg$3[ebp+28]
  0028d	0b c8		 or	 ecx, eax
  0028f	88 8d 20 ff ff
	ff		 mov	 BYTE PTR _pChatMsg$3[ebp+28], cl
$LN9@CGChatWhis:

; 3015 : 				}
; 3016 : 
; 3017 : 				pChatMsg.h.size = sizeof(pChatMsg);

  00295	c6 85 05 ff ff
	ff 92		 mov	 BYTE PTR _pChatMsg$3[ebp+1], 146 ; 00000092H

; 3018 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);

  0029c	0f b6 85 05 ff
	ff ff		 movzx	 eax, BYTE PTR _pChatMsg$3[ebp+1]
  002a3	50		 push	 eax
  002a4	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$3[ebp]
  002aa	51		 push	 ecx
  002ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSendHackLog@@3VCSendHackLog@@A ; gSendHackLog
  002b0	e8 00 00 00 00	 call	 ?SendData@CSendHackLog@@QAEHPAEK@Z ; CSendHackLog::SendData
$LN10@CGChatWhis:

; 3019 : 			}
; 3020 : 		}
; 3021 : 	}
; 3022 : }

  002b5	5f		 pop	 edi
  002b6	5e		 pop	 esi
  002b7	5b		 pop	 ebx
  002b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bb	33 cd		 xor	 ecx, ebp
  002bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c2	8b e5		 mov	 esp, ebp
  002c4	5d		 pop	 ebp
  002c5	c3		 ret	 0
?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ENDP ; CGChatWhisperRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z
_TEXT	SEGMENT
_lpObj$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z PROC	; CGChatRecv, COMDAT

; 2838 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2839 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00009	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2840 : 	
; 2841 : 	if( PacketCheckTime(lpObj) == FALSE ) return;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	75 02		 jne	 SHORT $LN2@CGChatRecv
  00029	eb 30		 jmp	 SHORT $LN1@CGChatRecv
$LN2@CGChatRecv:

; 2842 : 
; 2843 : 	DataSend(aIndex, (LPBYTE)lpMsg, lpMsg->h.size);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0002e	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00036	52		 push	 edx
  00037	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2844 : 	MsgSendV2(lpObj, (LPBYTE)lpMsg, lpMsg->h.size);

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00046	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0004a	51		 push	 ecx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGChatRecv:

; 2845 : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z ENDP	; CGChatRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z
_TEXT	SEGMENT
tv147 = -520						; size = 4
$T1 = -516						; size = 4
_count$2 = -448						; size = 4
_partycount$3 = -444					; size = 4
_szGlobalMsg$4 = -440					; size = 255
_szTargetNameCount$ = -184				; size = 4
_pChatMsg$ = -180					; size = 146
_szId$ = -32						; size = 11
_slen$ = -20						; size = 4
_number$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpChat$ = 8						; size = 4
_aIndex$ = 12						; size = 2
?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z PROC		; PChatProc, COMDAT

; 2349 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2350 : 	int n;
; 2351 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00016	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0001a	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00020	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00026	89 4d f4	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 2352 : 	int	number;
; 2353 : 
; 2354 : #ifdef UNICODE_MODE_20050718
; 2355 : 	int slen = wcslen((WCHAR*)lpChat->chatmsg);
; 2356 : #else
; 2357 : 	int slen = strlen(lpChat->chatmsg);

  00029	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  0002c	83 c0 0d	 add	 eax, 13			; 0000000dH
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _strlen
  00035	83 c4 04	 add	 esp, 4
  00038	89 45 ec	 mov	 DWORD PTR _slen$[ebp], eax

; 2358 : #endif
; 2359 : 	char szId[MAX_IDSTRING+1];
; 2360 : 
; 2361 : 	if( slen < 1 ) return;

  0003b	83 7d ec 01	 cmp	 DWORD PTR _slen$[ebp], 1
  0003f	7d 05		 jge	 SHORT $LN10@PChatProc
  00041	e9 f0 07 00 00	 jmp	 $LN50@PChatProc
$LN10@PChatProc:

; 2362 : 	//if( PacketCheckTime(lpObj) == FALSE ) return;
; 2363 : 
; 2364 : 
; 2365 : #ifdef PREVENT_117_CHATTING_MSG_BUG_20051114
; 2366 : 	if( slen > MAX_CHAT - 1 )

  00046	83 7d ec 3b	 cmp	 DWORD PTR _slen$[ebp], 59 ; 0000003bH
  0004a	7e 25		 jle	 SHORT $LN11@PChatProc

; 2367 : 	{
; 2368 : 		LogAddTD("[Anti-HACK][PChatProc][%s][%s] Chat Message Len : %d", lpObj->AccountID, lpObj->Name, slen);

  0004c	8b 45 ec	 mov	 eax, DWORD PTR _slen$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00053	83 c1 73	 add	 ecx, 115		; 00000073H
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005a	83 c2 68	 add	 edx, 104		; 00000068H
  0005d	52		 push	 edx
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00069	83 c4 10	 add	 esp, 16			; 00000010H

; 2369 : 		return;

  0006c	e9 c5 07 00 00	 jmp	 $LN50@PChatProc
$LN11@PChatProc:

; 2370 : 	}
; 2371 : #endif
; 2372 : 
; 2373 : 	szId[MAX_IDSTRING] = '\0';

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	6b c8 0a	 imul	 ecx, eax, 10
  00079	89 8d fc fd ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0007f	83 bd fc fd ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00086	73 02		 jae	 SHORT $LN51@PChatProc
  00088	eb 05		 jmp	 SHORT $LN52@PChatProc
$LN51@PChatProc:
  0008a	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN52@PChatProc:
  0008f	8b 95 fc fd ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00095	c6 44 15 e0 00	 mov	 BYTE PTR _szId$[ebp+edx], 0

; 2374 : 	memcpy(szId, gObj[aIndex].Name, MAX_IDSTRING);

  0009a	6a 0a		 push	 10			; 0000000aH
  0009c	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  000a0	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  000a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ac	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  000b0	50		 push	 eax
  000b1	8d 4d e0	 lea	 ecx, DWORD PTR _szId$[ebp]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2375 : 	memcpy(lpChat->chatid, szId, MAX_IDSTRING);

  000bd	6a 0a		 push	 10			; 0000000aH
  000bf	8d 45 e0	 lea	 eax, DWORD PTR _szId$[ebp]
  000c2	50		 push	 eax
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _lpChat$[ebp]
  000c6	83 c1 03	 add	 ecx, 3
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 _memcpy
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2376 : 
; 2377 : 	CHAT_LOG_DATA	pChatMsg;	
; 2378 : 	int				szTargetNameCount = 0;

  000d2	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _szTargetNameCount$[ebp], 0

; 2379 : 
; 2380 : 	if( gWriteChatLog )

  000dc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  000e3	0f 84 8e 00 00
	00		 je	 $LN12@PChatProc

; 2381 : 	{
; 2382 : 		pChatMsg.h.c = PMHC_BYTE;

  000e9	c6 85 4c ff ff
	ff c1		 mov	 BYTE PTR _pChatMsg$[ebp], 193 ; 000000c1H

; 2383 : 		pChatMsg.h.headcode = 0x02;

  000f0	c6 85 4e ff ff
	ff 02		 mov	 BYTE PTR _pChatMsg$[ebp+2], 2

; 2384 : 
; 2385 : 		memcpy(pChatMsg.AccountID, gObj[aIndex].AccountID, MAX_IDSTRING);

  000f7	6a 0a		 push	 10			; 0000000aH
  000f9	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  000fd	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00109	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0010d	50		 push	 eax
  0010e	8d 8d 52 ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$[ebp+6]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 _memcpy
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2386 : 		memcpy(pChatMsg.Name, gObj[aIndex].Name, MAX_IDSTRING);

  0011d	6a 0a		 push	 10			; 0000000aH
  0011f	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00123	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00129	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012f	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00133	50		 push	 eax
  00134	8d 8d 5d ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$[ebp+17]
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _memcpy
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2387 : 		pChatMsg.AccountID[MAX_IDSTRING] = NULL;

  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	6b c8 0a	 imul	 ecx, eax, 10
  0014b	c6 84 0d 52 ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$[ebp+ecx+6], 0

; 2388 : 		pChatMsg.Name[MAX_IDSTRING] = NULL;

  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	6b c8 0a	 imul	 ecx, eax, 10
  0015b	c6 84 0d 5d ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$[ebp+ecx+17], 0

; 2389 : 		pChatMsg.wServer = gGameServerCode;

  00163	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00169	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _pChatMsg$[ebp+4], ax

; 2390 : 
; 2391 : 		pChatMsg.btType = 0xFF;

  00170	c6 85 68 ff ff
	ff ff		 mov	 BYTE PTR _pChatMsg$[ebp+28], 255 ; 000000ffH
$LN12@PChatProc:

; 2392 : 	}
; 2393 : 
; 2394 : 	switch( lpChat->chatmsg[0] )

  00177	b8 01 00 00 00	 mov	 eax, 1
  0017c	6b c8 00	 imul	 ecx, eax, 0
  0017f	8b 55 08	 mov	 edx, DWORD PTR _lpChat$[ebp]
  00182	8a 44 0a 0d	 mov	 al, BYTE PTR [edx+ecx+13]
  00186	88 85 f8 fd ff
	ff		 mov	 BYTE PTR tv147[ebp], al
  0018c	80 bd f8 fd ff
	ff 21		 cmp	 BYTE PTR tv147[ebp], 33	; 00000021H
  00193	74 12		 je	 SHORT $LN13@PChatProc
  00195	80 bd f8 fd ff
	ff 2f		 cmp	 BYTE PTR tv147[ebp], 47	; 0000002fH
  0019c	0f 84 5e 01 00
	00		 je	 $LN19@PChatProc
  001a2	e9 ae 01 00 00	 jmp	 $LN2@PChatProc
$LN13@PChatProc:

; 2395 : 	{
; 2396 : 	case '!' :	// 
; 2397 : 		if( slen > 2 

  001a7	83 7d ec 02	 cmp	 DWORD PTR _slen$[ebp], 2
  001ab	0f 8e 4d 01 00
	00		 jle	 $LN14@PChatProc

; 2398 : #ifdef UNICODE_MODE_20050718
; 2399 : 			&& lpChat->chatmsg[1] == 0x00
; 2400 : #endif
; 2401 : 			)
; 2402 : 		{
; 2403 : //			if( (lpObj->AuthorityCode&AUTHORITY_CODE_NOTICE) == AUTHORITY_CODE_NOTICE )
; 2404 : //#ifdef GMCOMMAND_EX_1ST_BUGFIX
; 2405 : 			if(CheckAuthority(AUTHORITY_EVENT_GM | AUTHORITY_SUPER_ADMIN | AUTHORITY_ADMIN, lpObj) == true)

  001b1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b4	50		 push	 eax
  001b5	6a 62		 push	 98			; 00000062H
  001b7	e8 00 00 00 00	 call	 ?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z ; CheckAuthority
  001bc	83 c4 08	 add	 esp, 8
  001bf	0f b6 c8	 movzx	 ecx, al
  001c2	83 f9 01	 cmp	 ecx, 1
  001c5	0f 85 0f 01 00
	00		 jne	 $LN15@PChatProc

; 2406 : //#else
; 2407 : //			if(CheckAuthority(AUTHORITY_EVENT_GM | AUTHORITY_SUPER_ADMIN, lpObj) == true)
; 2408 : //#endif // GMCOMMAND_EX_1ST_BUGFIX
; 2409 : 			{
; 2410 : 				DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);

  001cb	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  001ce	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001d2	51		 push	 ecx
  001d3	8b 55 08	 mov	 edx, DWORD PTR _lpChat$[ebp]
  001d6	52		 push	 edx
  001d7	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  001db	50		 push	 eax
  001dc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2411 : 
; 2412 : 				char szGlobalMsg[255];
; 2413 : 
; 2414 : 				ZeroMemory(szGlobalMsg,sizeof(szGlobalMsg));

  001e4	68 ff 00 00 00	 push	 255			; 000000ffH
  001e9	6a 00		 push	 0
  001eb	8d 85 48 fe ff
	ff		 lea	 eax, DWORD PTR _szGlobalMsg$4[ebp]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _memset
  001f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2415 : 				
; 2416 : #ifdef UNICODE_MODE_20050718
; 2417 : 				PMSG_NOTICE	pNotice;
; 2418 : 				TNotice::MakeNoticeMsgUnicode( &pNotice, 0, lpChat->chatmsg+2, MAX_CHAT-2);
; 2419 : 
; 2420 : 				for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)
; 2421 : 				{
; 2422 : 					if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) )
; 2423 : 					{
; 2424 : 						DataSend(n, (LPBYTE)&pNotice, pNotice.h.size);
; 2425 : 					}
; 2426 : 				}
; 2427 : //				LogAddTD(lMsg.Get(471), gObj[aIndex].AccountID, gObj[aIndex].Name, szCmdMsg);
; 2428 : #else
; 2429 : 				if(g_GlobalConfig.m_bGlobalNick == TRUE)

  001fa	83 3d 40 00 00
	00 01		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+64, 1
  00201	75 29		 jne	 SHORT $LN17@PChatProc

; 2430 : 				{
; 2431 : 					sprintf(szGlobalMsg,"[%s]: ",gObj[aIndex].Name);

  00203	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00207	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0020d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00213	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00217	50		 push	 eax
  00218	68 00 00 00 00	 push	 OFFSET ??_C@_06CPENAAMN@?$FL?$CFs?$FN?3?5@
  0021d	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR _szGlobalMsg$4[ebp]
  00223	51		 push	 ecx
  00224	e8 00 00 00 00	 call	 _sprintf
  00229	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@PChatProc:

; 2432 : 				}
; 2433 : 
; 2434 : 				strcat(szGlobalMsg,lpChat->chatmsg+1);

  0022c	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  0022f	83 c0 0e	 add	 eax, 14			; 0000000eH
  00232	50		 push	 eax
  00233	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR _szGlobalMsg$4[ebp]
  00239	51		 push	 ecx
  0023a	e8 00 00 00 00	 call	 _strcat
  0023f	83 c4 08	 add	 esp, 8

; 2435 : 
; 2436 : 				AllSendServerMsg(szGlobalMsg);

  00242	8d 85 48 fe ff
	ff		 lea	 eax, DWORD PTR _szGlobalMsg$4[ebp]
  00248	50		 push	 eax
  00249	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  0024e	83 c4 04	 add	 esp, 4

; 2437 : 				LogAddTD(lMsg.Get(471), gObj[aIndex].AccountID, gObj[aIndex].Name, lpChat->chatmsg+1);

  00251	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  00254	83 c0 0e	 add	 eax, 14			; 0000000eH
  00257	50		 push	 eax
  00258	0f bf 4d 0c	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  0025c	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00262	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00267	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0026b	51		 push	 ecx
  0026c	0f bf 55 0c	 movsx	 edx, WORD PTR _aIndex$[ebp]
  00270	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  00276	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027c	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00280	52		 push	 edx
  00281	68 d7 01 00 00	 push	 471			; 000001d7H
  00286	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0028b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00291	50		 push	 eax
  00292	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00298	83 c4 10	 add	 esp, 16			; 00000010H

; 2438 : #endif
; 2439 : 
; 2440 : 				if( gWriteChatLog )

  0029b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  002a2	74 2f		 je	 SHORT $LN18@PChatProc

; 2441 : 				{
; 2442 : 					memcpy(pChatMsg.szChatMsg, lpChat->chatmsg+1, MAX_CHAT-1);

  002a4	6a 3b		 push	 59			; 0000003bH
  002a6	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  002a9	83 c0 0e	 add	 eax, 14			; 0000000eH
  002ac	50		 push	 eax
  002ad	8d 8d 69 ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$[ebp+29]
  002b3	51		 push	 ecx
  002b4	e8 00 00 00 00	 call	 _memcpy
  002b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2443 : 					pChatMsg.szChatMsg[MAX_CHAT] = NULL;

  002bc	b8 01 00 00 00	 mov	 eax, 1
  002c1	6b c8 3c	 imul	 ecx, eax, 60
  002c4	c6 84 0d 69 ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$[ebp+ecx+29], 0

; 2444 : 					pChatMsg.btType = 3;	// 

  002cc	c6 85 68 ff ff
	ff 03		 mov	 BYTE PTR _pChatMsg$[ebp+28], 3
$LN18@PChatProc:

; 2445 : 				}
; 2446 : 				return;

  002d3	e9 5e 05 00 00	 jmp	 $LN50@PChatProc

; 2447 : 			}

  002d8	eb 24		 jmp	 SHORT $LN14@PChatProc
$LN15@PChatProc:

; 2448 : 			else
; 2449 : 			{
; 2450 : 				g_PostSystem.SendPostMessage(aIndex,&lpChat->chatmsg[1]);

  002da	b8 01 00 00 00	 mov	 eax, 1
  002df	c1 e0 00	 shl	 eax, 0
  002e2	8b 4d 08	 mov	 ecx, DWORD PTR _lpChat$[ebp]
  002e5	8d 54 01 0d	 lea	 edx, DWORD PTR [ecx+eax+13]
  002e9	52		 push	 edx
  002ea	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  002ee	50		 push	 eax
  002ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PostSystem@@3VCPostSystem@@A ; g_PostSystem
  002f4	e8 00 00 00 00	 call	 ?SendPostMessage@CPostSystem@@QAEXHPAD@Z ; CPostSystem::SendPostMessage

; 2451 : 				return;

  002f9	e9 38 05 00 00	 jmp	 $LN50@PChatProc
$LN14@PChatProc:

; 2452 : 			}
; 2453 : 		}
; 2454 : 		break;

  002fe	eb 55		 jmp	 SHORT $LN2@PChatProc
$LN19@PChatProc:

; 2455 : 
; 2456 : 			
; 2457 : #if TESTSERVER == 1
; 2458 : 	case '`' :	// 
; 2459 : 		if( slen > 2 
; 2460 : #ifdef UNICODE_MODE_20050718
; 2461 : 			&& lpChat->chatmsg[1] == 0x00
; 2462 : #endif
; 2463 : 			)
; 2464 : 		{
; 2465 : #ifdef UNICODE_MODE_20050718
; 2466 : 			if( lpChat->chatmsg[2] == '!' && lpChat->chatmsg[3] == 0x00 )	//  .
; 2467 : #else
; 2468 : 			if( lpChat->chatmsg[1] == '!' )	//  .
; 2469 : #endif
; 2470 : 			{
; 2471 : //				DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 2472 : 				AllSendServerMsg(lpChat->chatmsg+2);
; 2473 : 				LogAddTD(lMsg.Get(471), gObj[aIndex].AccountID, gObj[aIndex].Name, lpChat->chatmsg+1);
; 2474 : 				
; 2475 : 				if( gWriteChatLog )
; 2476 : 				{
; 2477 : 					memcpy(pChatMsg.szChatMsg, lpChat->chatmsg+1, MAX_CHAT-1);
; 2478 : 					pChatMsg.szChatMsg[MAX_CHAT] = NULL;
; 2479 : 					pChatMsg.btType = 3;	// 
; 2480 : 				}
; 2481 : 				return;
; 2482 : 			}
; 2483 : 		}
; 2484 : 		break;
; 2485 : #endif
; 2486 : 		
; 2487 : 	case '/' :	// 
; 2488 : 		if( slen > 2 

  00300	83 7d ec 02	 cmp	 DWORD PTR _slen$[ebp], 2
  00304	7e 4f		 jle	 SHORT $LN2@PChatProc

; 2489 : #ifdef UNICODE_MODE_20050718
; 2490 : 			&& lpChat->chatmsg[1] == 0x00
; 2491 : #endif
; 2492 : 			)
; 2493 : 		{
; 2494 : #ifndef PCBANG_FREE_KALIMA_EVENT_20060124
; 2495 : 			if ((strcmp(&lpChat->chatmsg[1], " ") == 0)

  00306	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JGNMDCCD@?$MA?L?$LF?$LP?5?D?$KO?$LI?$KO?$LI?$LG@
  0030b	b8 01 00 00 00	 mov	 eax, 1
  00310	c1 e0 00	 shl	 eax, 0
  00313	8b 4d 08	 mov	 ecx, DWORD PTR _lpChat$[ebp]
  00316	8d 54 01 0d	 lea	 edx, DWORD PTR [ecx+eax+13]
  0031a	52		 push	 edx
  0031b	e8 00 00 00 00	 call	 _strcmp
  00320	83 c4 08	 add	 esp, 8

; 2496 : 	#if defined(FOR_TAIWAN) && defined(PCBANG_ADVANTAGE)
; 2497 : 				|| (stricmp(&lpChat->chatmsg[1], "move kalima") == 0) 
; 2498 : 	#endif
; 2499 : 				)
; 2500 : 			{			
; 2501 : 			#ifdef HAPPY_POUCH
; 2502 : 				if (lpObj->m_lFreeKalimaTime)
; 2503 : 				{				
; 2504 : 					if (gMoveCommand.MoveFree2Kalima(lpObj))
; 2505 : 					{
; 2506 : 						//##LOG happycat@20050214
; 2507 : 						LogAddTD("[%s][%s] Use [/ ] POUCH", lpObj->AccountID, lpObj->Name);
; 2508 : 						return;
; 2509 : 					}
; 2510 : 				}
; 2511 : 			#endif//HAPPY_POUCH
; 2512 : 			#ifdef PCBANG_ADVANTAGE
; 2513 : 				#ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 2514 : 				if( IsOKPCBangBenefitAll(lpObj) )
; 2515 : 				#else
; 2516 : 				if (lpObj->m_bPCBangUser)
; 2517 : 				#endif // PCBANG_ADVANTAGE_EXPAND_20060919
; 2518 : 				{				
; 2519 : 					if (gMoveCommand.MoveFree2Kalima(lpObj))
; 2520 : 					{
; 2521 : 						//##LOG happycat@20050214
; 2522 : 						LogAddTD("[%s][%s] Use [/ ] PCBANG", lpObj->AccountID, lpObj->Name);
; 2523 : 						return;
; 2524 : 					}
; 2525 : 				}
; 2526 : 			#endif
; 2527 : 			}
; 2528 : 			 gs_cmd.ChatRecv(lpChat,aIndex);

  00323	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00327	50		 push	 eax
  00328	8b 4d 08	 mov	 ecx, DWORD PTR _lpChat$[ebp]
  0032b	51		 push	 ecx
  0032c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cmd@@3VCHAT_COMMANDS@@A ; gs_cmd
  00331	e8 00 00 00 00	 call	 ?ChatRecv@CHAT_COMMANDS@@QAE_NPAUPMSG_CHATDATA@@H@Z ; CHAT_COMMANDS::ChatRecv

; 2529 : #endif
; 2530 : 				//PICKUP
; 2531 : 	#ifdef PICKUP_SYSTEM
; 2532 : 			//if (!memcmp(lpChat->chatmsg, "/pickup", strlen("/pickup")))
; 2533 : 			//	s_PickUp.IsPickAddCommand(lpObj, lpChat);
; 2534 : 
; 2535 : 			//if (!memcmp(lpChat->chatmsg, "/picklist", strlen("/picklist")))
; 2536 : 			//	s_PickUp.IsPickList(lpObj);
; 2537 : 
; 2538 : #endif
; 2539 : 			//if( (lpObj->Authority&AUTHORITY_USER) != AUTHORITY_USER )	//      .
; 2540 : 			{
; 2541 : #ifdef UPDATE_PK_SYSTEM_20070302	//      
; 2542 : #ifdef MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221	//   60
; 2543 : 				if( GetTickCount()-lpObj->MySelfDefenseTime  < (1000*60) )
; 2544 : #else	// MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221
; 2545 : 				if( GetTickCount()-lpObj->MySelfDefenseTime  < (1000*90) )
; 2546 : #endif	// MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221
; 2547 : 				{
; 2548 : 					GCServerMsgStringSend(lMsg.Get(1133), lpObj->m_Index, 1);
; 2549 : 					return;
; 2550 : 				}
; 2551 : #endif
; 2552 : 
; 2553 : #ifdef UNICODE_MODE_20050718
; 2554 : 				char szCmdMsg[4096] = {0,};
; 2555 : 				WideCharToMultiByte(DEFAULT_CODEPAGE, 0, (WCHAR*)lpChat->chatmsg, slen, szCmdMsg, sizeof(szCmdMsg), NULL, NULL);
; 2556 : 				cManager.ManagementProc(lpObj, szCmdMsg, aIndex);
; 2557 : #else
; 2558 : 				cManager.ManagementProc(lpObj, lpChat->chatmsg, aIndex);

  00336	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0033a	50		 push	 eax
  0033b	8b 4d 08	 mov	 ecx, DWORD PTR _lpChat$[ebp]
  0033e	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00341	51		 push	 ecx
  00342	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00345	52		 push	 edx
  00346	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  0034b	e8 00 00 00 00	 call	 ?ManagementProc@CGMMng@@QAEHPAVOBJECTSTRUCT@@PADH@Z ; CGMMng::ManagementProc

; 2559 : #endif
; 2560 : 				return;

  00350	e9 e1 04 00 00	 jmp	 $LN50@PChatProc
$LN2@PChatProc:

; 2561 : 			}
; 2562 : 		}
; 2563 : 		break;
; 2564 : 	}
; 2565 : 
; 2566 : 
; 2567 : #ifdef DARKLORD_WORK
; 2568 : 	if( lpObj->ChatLitmitTime > 0 )

  00355	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00358	0f b7 88 dc 00
	00 00		 movzx	 ecx, WORD PTR [eax+220]
  0035f	85 c9		 test	 ecx, ecx
  00361	7e 2f		 jle	 SHORT $LN22@PChatProc

; 2569 : 	{
; 2570 : 		//  :  %d
; 2571 : 		MsgOutput(lpObj->m_Index,lMsg.Get(1247), lpObj->ChatLitmitTime);

  00363	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00366	0f b7 88 dc 00
	00 00		 movzx	 ecx, WORD PTR [eax+220]
  0036d	51		 push	 ecx
  0036e	68 df 04 00 00	 push	 1247			; 000004dfH
  00373	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00378	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0037e	50		 push	 eax
  0037f	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00382	8b 02		 mov	 eax, DWORD PTR [edx]
  00384	50		 push	 eax
  00385	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0038a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2572 : 		return;

  0038d	e9 a4 04 00 00	 jmp	 $LN50@PChatProc
$LN22@PChatProc:

; 2573 : 	}
; 2574 : #endif
; 2575 : 
; 2576 : 	//  ..
; 2577 : 	if( (lpObj->Penalty&CTLCODE_CHATBAN) == CTLCODE_CHATBAN ) return;

  00392	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00395	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  0039b	83 e1 02	 and	 ecx, 2
  0039e	74 05		 je	 SHORT $LN23@PChatProc
  003a0	e9 91 04 00 00	 jmp	 $LN50@PChatProc
$LN23@PChatProc:

; 2578 : 
; 2579 : #ifdef FOR_JAPAN
; 2580 : 	if( (lpChat->chatmsg[0] == '~' || lpChat->chatmsg[0] == ']' )
; 2581 : #ifdef UNICODE_MODE_20050718
; 2582 : 		&& lpChat->chatmsg[1] == 0x00
; 2583 : #endif
; 2584 : 		)	//  
; 2585 : #else
; 2586 : 	if( lpChat->chatmsg[0] == '~' 

  003a5	b8 01 00 00 00	 mov	 eax, 1
  003aa	6b c8 00	 imul	 ecx, eax, 0
  003ad	8b 55 08	 mov	 edx, DWORD PTR _lpChat$[ebp]
  003b0	0f be 44 0a 0d	 movsx	 eax, BYTE PTR [edx+ecx+13]
  003b5	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  003b8	0f 85 04 01 00
	00		 jne	 $LN24@PChatProc

; 2587 : #ifdef UNICODE_MODE_20050718
; 2588 : 		&& lpChat->chatmsg[1] == 0x00
; 2589 : #endif
; 2590 : 		)	//  
; 2591 : #endif
; 2592 : 	{
; 2593 : 		if( lpObj->PartyNumber >= 0 )

  003be	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c1	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  003c8	0f 8c ef 00 00
	00		 jl	 $LN26@PChatProc

; 2594 : 		{
; 2595 : 			int partycount = gParty.GetPartyCount(lpObj->PartyNumber);

  003ce	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d1	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  003d7	51		 push	 ecx
  003d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  003dd	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount
  003e2	89 85 44 fe ff
	ff		 mov	 DWORD PTR _partycount$3[ebp], eax

; 2596 : 			if( partycount >= 0 )

  003e8	83 bd 44 fe ff
	ff 00		 cmp	 DWORD PTR _partycount$3[ebp], 0
  003ef	0f 8c c8 00 00
	00		 jl	 $LN26@PChatProc

; 2597 : 			{
; 2598 : 				if( gWriteChatLog )

  003f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  003fc	74 2f		 je	 SHORT $LN28@PChatProc

; 2599 : 				{
; 2600 : #ifdef UNICODE_MODE_20050718
; 2601 : 					memcpy(pChatMsg.szChatMsg, lpChat->chatmsg+2, MAX_CHAT-2);
; 2602 : 					pChatMsg.szChatMsg[MAX_CHAT-1] = '\0';
; 2603 : 					pChatMsg.szChatMsg[MAX_CHAT] = '\0';
; 2604 : #else
; 2605 : 					memcpy(pChatMsg.szChatMsg, lpChat->chatmsg+1, MAX_CHAT-1);

  003fe	6a 3b		 push	 59			; 0000003bH
  00400	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  00403	83 c0 0e	 add	 eax, 14			; 0000000eH
  00406	50		 push	 eax
  00407	8d 8d 69 ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$[ebp+29]
  0040d	51		 push	 ecx
  0040e	e8 00 00 00 00	 call	 _memcpy
  00413	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2606 : 					pChatMsg.szChatMsg[MAX_CHAT] = NULL;

  00416	b8 01 00 00 00	 mov	 eax, 1
  0041b	6b c8 3c	 imul	 ecx, eax, 60
  0041e	c6 84 0d 69 ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$[ebp+ecx+29], 0

; 2607 : #endif
; 2608 : 					pChatMsg.btType = 1;	//  

  00426	c6 85 68 ff ff
	ff 01		 mov	 BYTE PTR _pChatMsg$[ebp+28], 1
$LN28@PChatProc:

; 2609 : 				}
; 2610 : 
; 2611 : 				for( n=0; n<MAX_PARTYUSER; n++)

  0042d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00434	eb 09		 jmp	 SHORT $LN6@PChatProc
$LN4@PChatProc:
  00436	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00439	83 c0 01	 add	 eax, 1
  0043c	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN6@PChatProc:
  0043f	83 7d f8 05	 cmp	 DWORD PTR _n$[ebp], 5
  00443	7d 78		 jge	 SHORT $LN26@PChatProc

; 2612 : 				{
; 2613 : 					number = gParty.m_PartyS[lpObj->PartyNumber].Number[n];

  00445	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00448	6b 88 88 02 00
	00 30		 imul	 ecx, DWORD PTR [eax+648], 48
  0044f	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00452	8b 84 91 0c 00
	00 00		 mov	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[ecx+edx*4+12]
  00459	89 45 f0	 mov	 DWORD PTR _number$[ebp], eax

; 2614 : 					if( number >= 0 )

  0045c	83 7d f0 00	 cmp	 DWORD PTR _number$[ebp], 0
  00460	7c 56		 jl	 SHORT $LN29@PChatProc

; 2615 : 					{
; 2616 : 						DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  00462	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  00465	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00469	51		 push	 ecx
  0046a	8b 55 08	 mov	 edx, DWORD PTR _lpChat$[ebp]
  0046d	52		 push	 edx
  0046e	8b 45 f0	 mov	 eax, DWORD PTR _number$[ebp]
  00471	50		 push	 eax
  00472	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00477	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2617 : 
; 2618 : 						if( gWriteChatLog )

  0047a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  00481	74 35		 je	 SHORT $LN29@PChatProc

; 2619 : 						{
; 2620 : 							strcpy(pChatMsg.szTargetName[szTargetNameCount], gObj[number].Name);

  00483	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0048a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00490	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00494	52		 push	 edx
  00495	6b 85 48 ff ff
	ff 0b		 imul	 eax, DWORD PTR _szTargetNameCount$[ebp], 11
  0049c	8d 4c 05 a6	 lea	 ecx, DWORD PTR _pChatMsg$[ebp+eax+90]
  004a0	51		 push	 ecx
  004a1	e8 00 00 00 00	 call	 _strcpy
  004a6	83 c4 08	 add	 esp, 8

; 2621 : 							szTargetNameCount++;

  004a9	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _szTargetNameCount$[ebp]
  004af	83 c0 01	 add	 eax, 1
  004b2	89 85 48 ff ff
	ff		 mov	 DWORD PTR _szTargetNameCount$[ebp], eax
$LN29@PChatProc:

; 2622 : 						}
; 2623 : 					}
; 2624 : 				}

  004b8	e9 79 ff ff ff	 jmp	 $LN4@PChatProc
$LN26@PChatProc:

; 2625 : 			}
; 2626 : 		}
; 2627 : 	}

  004bd	e9 08 03 00 00	 jmp	 $LN25@PChatProc
$LN24@PChatProc:

; 2628 : 	else if( lpChat->chatmsg[0] == '@' 

  004c2	b8 01 00 00 00	 mov	 eax, 1
  004c7	6b c8 00	 imul	 ecx, eax, 0
  004ca	8b 55 08	 mov	 edx, DWORD PTR _lpChat$[ebp]
  004cd	0f be 44 0a 0d	 movsx	 eax, BYTE PTR [edx+ecx+13]
  004d2	83 f8 40	 cmp	 eax, 64			; 00000040H
  004d5	0f 85 86 02 00
	00		 jne	 $LN31@PChatProc

; 2629 : #ifdef UNICODE_MODE_20050718
; 2630 : 		&& lpChat->chatmsg[1] == 0x00
; 2631 : #endif
; 2632 : 		)	//  
; 2633 : 	{
; 2634 : 		//DataSend(aIndex, (char*)lpChat, lpChat->h.size);
; 2635 : 		if( lpObj->GuildNumber > 0 )	//  ?

  004db	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004de	83 b8 90 02 00
	00 00		 cmp	 DWORD PTR [eax+656], 0
  004e5	0f 8e 74 02 00
	00		 jle	 $LN33@PChatProc

; 2636 : 		{
; 2637 : 			// 1. >   .
; 2638 : #ifdef UNICODE_MODE_20050718
; 2639 : 			if( lpChat->chatmsg[2] == '>' && lpChat->chatmsg[3] == 0x00 )
; 2640 : #else
; 2641 : 			if( lpChat->chatmsg[1] == '>' )	//   .

  004eb	b8 01 00 00 00	 mov	 eax, 1
  004f0	c1 e0 00	 shl	 eax, 0
  004f3	8b 4d 08	 mov	 ecx, DWORD PTR _lpChat$[ebp]
  004f6	0f be 54 01 0d	 movsx	 edx, BYTE PTR [ecx+eax+13]
  004fb	83 fa 3e	 cmp	 edx, 62			; 0000003eH
  004fe	0f 85 ed 00 00
	00		 jne	 $LN34@PChatProc

; 2642 : #endif
; 2643 : 			{
; 2644 : 				if( lpObj->Name[0] == lpObj->lpGuild->Names[0][0] )

  00504	b8 01 00 00 00	 mov	 eax, 1
  00509	6b c8 00	 imul	 ecx, eax, 0
  0050c	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0050f	0f be 44 0a 73	 movsx	 eax, BYTE PTR [edx+ecx+115]
  00514	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00517	8b 91 94 02 00
	00		 mov	 edx, DWORD PTR [ecx+660]
  0051d	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00522	6b c9 00	 imul	 ecx, ecx, 0
  00525	8d 54 0a 2f	 lea	 edx, DWORD PTR [edx+ecx+47]
  00529	b9 01 00 00 00	 mov	 ecx, 1
  0052e	6b c9 00	 imul	 ecx, ecx, 0
  00531	0f be 14 0a	 movsx	 edx, BYTE PTR [edx+ecx]
  00535	3b c2		 cmp	 eax, edx
  00537	0f 85 af 00 00
	00		 jne	 $LN36@PChatProc

; 2645 : 				{
; 2646 : 					if( strcmp(lpObj->Name, lpObj->lpGuild->Names[0] ) == 0 )	//   

  0053d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00540	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00546	ba 0b 00 00 00	 mov	 edx, 11			; 0000000bH
  0054b	6b c2 00	 imul	 eax, edx, 0
  0054e	8d 4c 01 2f	 lea	 ecx, DWORD PTR [ecx+eax+47]
  00552	51		 push	 ecx
  00553	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00556	83 c2 73	 add	 edx, 115		; 00000073H
  00559	52		 push	 edx
  0055a	e8 00 00 00 00	 call	 _strcmp
  0055f	83 c4 08	 add	 esp, 8
  00562	85 c0		 test	 eax, eax
  00564	0f 85 82 00 00
	00		 jne	 $LN36@PChatProc

; 2647 : 					{
; 2648 : #ifdef UNICODE_MODE_20050718
; 2649 : 						GDGuildNoticeSave(lpObj->lpGuild->Name, lpChat->chatmsg+4);
; 2650 : #elif defined(_NEW_EXDB_)
; 2651 : 						GDGuildNoticeSave(lpObj->lpGuild->Name, lpChat->chatmsg+2);

  0056a	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  0056d	83 c0 0f	 add	 eax, 15			; 0000000fH
  00570	50		 push	 eax
  00571	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00574	8b 91 94 02 00
	00		 mov	 edx, DWORD PTR [ecx+660]
  0057a	83 c2 04	 add	 edx, 4
  0057d	52		 push	 edx
  0057e	e8 00 00 00 00	 call	 ?GDGuildNoticeSave@@YAXPAD0@Z ; GDGuildNoticeSave
  00583	83 c4 08	 add	 esp, 8

; 2652 : 						LogAdd(lMsg.Get(472),lpObj->lpGuild->Name, lpChat->chatmsg);

  00586	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  00589	83 c0 0d	 add	 eax, 13			; 0000000dH
  0058c	50		 push	 eax
  0058d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00590	8b 91 94 02 00
	00		 mov	 edx, DWORD PTR [ecx+660]
  00596	83 c2 04	 add	 edx, 4
  00599	52		 push	 edx
  0059a	68 d8 01 00 00	 push	 472			; 000001d8H
  0059f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  005aa	50		 push	 eax
  005ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  005b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2653 : #endif
; 2654 : 
; 2655 : 						if( gWriteChatLog )

  005b4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  005bb	74 2f		 je	 SHORT $LN36@PChatProc

; 2656 : 						{
; 2657 : #ifdef UNICODE_MODE_20050718
; 2658 : 							memcpy(pChatMsg.szChatMsg, lpChat->chatmsg+4, MAX_CHAT-4);
; 2659 : 							pChatMsg.szChatMsg[MAX_CHAT-1] = '\0';
; 2660 : 							pChatMsg.szChatMsg[MAX_CHAT] = '\0';
; 2661 : #else
; 2662 : 							memcpy(pChatMsg.szChatMsg, lpChat->chatmsg+2, MAX_CHAT-2);

  005bd	6a 3a		 push	 58			; 0000003aH
  005bf	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  005c2	83 c0 0f	 add	 eax, 15			; 0000000fH
  005c5	50		 push	 eax
  005c6	8d 8d 69 ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$[ebp+29]
  005cc	51		 push	 ecx
  005cd	e8 00 00 00 00	 call	 _memcpy
  005d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2663 : 							pChatMsg.szChatMsg[MAX_CHAT] = NULL;

  005d5	b8 01 00 00 00	 mov	 eax, 1
  005da	6b c8 3c	 imul	 ecx, eax, 60
  005dd	c6 84 0d 69 ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$[ebp+ecx+29], 0

; 2664 : #endif
; 2665 : 							pChatMsg.btType = 4;	// 

  005e5	c6 85 68 ff ff
	ff 04		 mov	 BYTE PTR _pChatMsg$[ebp+28], 4
$LN36@PChatProc:

; 2666 : 						}
; 2667 : 					}
; 2668 : 				}
; 2669 : 			}

  005ec	e9 39 01 00 00	 jmp	 $LN35@PChatProc
$LN34@PChatProc:

; 2670 : 
; 2671 : #ifdef ADD_UNION_CHATTING_01_20041201
; 2672 : 			// 2. >  .
; 2673 : #ifdef UNICODE_MODE_20050718
; 2674 : 			else if( lpChat->chatmsg[2] == '@' && lpChat->chatmsg[3] == 0x00 && (lpObj->lpGuild->iGuildUnion!=G_RELATIONSHIP_NONE) )
; 2675 : #else
; 2676 : 			else if( lpChat->chatmsg[1] == '@' && (lpObj->lpGuild->iGuildUnion!=G_RELATIONSHIP_NONE) )	
; 2677 : #endif
; 2678 : 			{
; 2679 : 				INT iGuildCount = 0;
; 2680 : 				INT iGuildList[MAX_RELATIONSHIP_COUNT] = { 0, };
; 2681 : 
; 2682 : 				if( UnionManager.GetGuildUnionMemberList( lpObj->lpGuild->iGuildUnion, iGuildCount, iGuildList ) == 1 )
; 2683 : 				{
; 2684 : 					for( INT i=0; i<iGuildCount; i++ )
; 2685 : 					{
; 2686 : 						LPGUILD_INFO lpGuildInfo = Guild.SearchGuild_Number(iGuildList[i]);
; 2687 : 
; 2688 : 						if( lpGuildInfo == NULL )
; 2689 : 							continue;
; 2690 : 
; 2691 : 						for( n=0; n<MAX_GUILD; n++)
; 2692 : 						{
; 2693 : 							if( lpGuildInfo->Use[n] )
; 2694 : 							{
; 2695 : 								number = lpGuildInfo->Index[n];
; 2696 : 
; 2697 : 								if( number >= 0 )
; 2698 : 								{
; 2699 : 									if( lpGuildInfo->Names[n][0] ==  gObj[number].Name[0] )
; 2700 : 									{
; 2701 : 										if( strcmp(lpGuildInfo->Names[n], gObj[number].Name) == 0 )
; 2702 : 										{
; 2703 : 											DataSend(number, (LPBYTE)lpChat, lpChat->h.size);
; 2704 : 										}
; 2705 : 									} 
; 2706 : 
; 2707 : 								}
; 2708 : 
; 2709 : 							}
; 2710 : 						}
; 2711 : 					}		
; 2712 : 				}
; 2713 : 				
; 2714 : #ifdef ADD_SERVERGROUP_CHATTING_FOR_GUILD_UNION_01_20050706
; 2715 : 				// 2.1 >   ExDB  .
; 2716 : 				if( g_iServerGroupUnionChatting == 1 )
; 2717 : 					GDUnionServerGroupChattingSend( lpObj->lpGuild->iGuildUnion, lpChat );
; 2718 : #endif 
; 2719 : 
; 2720 : 
; 2721 : 			}
; 2722 : #endif // ADD_UNION_CHATTING_01_20041201
; 2723 : 
; 2724 : 
; 2725 : 			// 3. >  .
; 2726 : 			else
; 2727 : 			{
; 2728 : 				int count = lpObj->lpGuild->Count;

  005f1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f4	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  005fa	0f b6 51 2d	 movzx	 edx, BYTE PTR [ecx+45]
  005fe	89 95 40 fe ff
	ff		 mov	 DWORD PTR _count$2[ebp], edx

; 2729 : 				if( count >= 0 )

  00604	83 bd 40 fe ff
	ff 00		 cmp	 DWORD PTR _count$2[ebp], 0
  0060b	0f 8c e1 00 00
	00		 jl	 $LN39@PChatProc

; 2730 : 				{
; 2731 : 					for( n=0; n<MAX_GUILD; n++)

  00611	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00618	eb 09		 jmp	 SHORT $LN9@PChatProc
$LN7@PChatProc:
  0061a	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0061d	83 c0 01	 add	 eax, 1
  00620	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN9@PChatProc:
  00623	83 7d f8 50	 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  00627	0f 8d c5 00 00
	00		 jge	 $LN39@PChatProc

; 2732 : 					{
; 2733 : 						if( lpObj->lpGuild->Use[n] )

  0062d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00630	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00636	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00639	0f b6 84 11 40
	04 00 00	 movzx	 eax, BYTE PTR [ecx+edx+1088]
  00641	85 c0		 test	 eax, eax
  00643	0f 84 a4 00 00
	00		 je	 $LN40@PChatProc

; 2734 : 						{
; 2735 : 							number = lpObj->lpGuild->Index[n];

  00649	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0064c	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00652	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00655	0f bf 84 51 a0
	03 00 00	 movsx	 eax, WORD PTR [ecx+edx*2+928]
  0065d	89 45 f0	 mov	 DWORD PTR _number$[ebp], eax

; 2736 : 							if( number >= 0 )

  00660	83 7d f0 00	 cmp	 DWORD PTR _number$[ebp], 0
  00664	0f 8c 83 00 00
	00		 jl	 $LN40@PChatProc

; 2737 : 							{
; 2738 : 								if( lpObj->lpGuild->Names[n][0] ==  gObj[number].Name[0] )

  0066a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0066d	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00673	6b 55 f8 0b	 imul	 edx, DWORD PTR _n$[ebp], 11
  00677	8d 44 11 2f	 lea	 eax, DWORD PTR [ecx+edx+47]
  0067b	b9 01 00 00 00	 mov	 ecx, 1
  00680	6b d1 00	 imul	 edx, ecx, 0
  00683	0f be 04 10	 movsx	 eax, BYTE PTR [eax+edx]
  00687	69 4d f0 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  0068e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00694	ba 01 00 00 00	 mov	 edx, 1
  00699	6b d2 00	 imul	 edx, edx, 0
  0069c	0f be 4c 11 73	 movsx	 ecx, BYTE PTR [ecx+edx+115]
  006a1	3b c1		 cmp	 eax, ecx
  006a3	75 48		 jne	 SHORT $LN40@PChatProc

; 2739 : 								{
; 2740 : 									if( strcmp(lpObj->lpGuild->Names[n], gObj[number].Name) == 0 )

  006a5	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  006ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006b2	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  006b6	52		 push	 edx
  006b7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ba	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  006c0	6b 55 f8 0b	 imul	 edx, DWORD PTR _n$[ebp], 11
  006c4	8d 44 11 2f	 lea	 eax, DWORD PTR [ecx+edx+47]
  006c8	50		 push	 eax
  006c9	e8 00 00 00 00	 call	 _strcmp
  006ce	83 c4 08	 add	 esp, 8
  006d1	85 c0		 test	 eax, eax
  006d3	75 18		 jne	 SHORT $LN40@PChatProc

; 2741 : 									{
; 2742 : 										DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  006d5	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  006d8	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  006dc	51		 push	 ecx
  006dd	8b 55 08	 mov	 edx, DWORD PTR _lpChat$[ebp]
  006e0	52		 push	 edx
  006e1	8b 45 f0	 mov	 eax, DWORD PTR _number$[ebp]
  006e4	50		 push	 eax
  006e5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006ea	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN40@PChatProc:

; 2743 : 										//LogAdd("%d %s     ", number, gObj[number].Name);
; 2744 : 									}
; 2745 : 								}
; 2746 : 							}
; 2747 : 						}
; 2748 : 					}

  006ed	e9 28 ff ff ff	 jmp	 $LN7@PChatProc
$LN39@PChatProc:

; 2749 : 				}
; 2750 : 
; 2751 : #ifdef ADD_SERVERGROUP_CHATTING_FOR_GUILD_UNION_01_20050706
; 2752 : 				// 3.1 >   ExDB  .
; 2753 : 				if( g_iServerGroupGuildChatting == 1 )
; 2754 : 				{
; 2755 : 					//  1  . ^^
; 2756 : 					if( lpObj->lpGuild->Count > 1 )
; 2757 : 						GDGuildServerGroupChattingSend( lpObj->lpGuild->Number, lpChat );
; 2758 : 				}
; 2759 : #endif 
; 2760 : 
; 2761 : 				if( gWriteChatLog )

  006f2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  006f9	74 2f		 je	 SHORT $LN35@PChatProc

; 2762 : 				{
; 2763 : #ifdef UNICODE_MODE_20050718
; 2764 : 					memcpy(pChatMsg.szChatMsg, lpChat->chatmsg+2, MAX_CHAT-2);
; 2765 : 					pChatMsg.szChatMsg[MAX_CHAT-1] = '\0';
; 2766 : 					pChatMsg.szChatMsg[MAX_CHAT] = '\0';
; 2767 : #else
; 2768 : 					memcpy(pChatMsg.szChatMsg, lpChat->chatmsg+1, MAX_CHAT-1);

  006fb	6a 3b		 push	 59			; 0000003bH
  006fd	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  00700	83 c0 0e	 add	 eax, 14			; 0000000eH
  00703	50		 push	 eax
  00704	8d 8d 69 ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$[ebp+29]
  0070a	51		 push	 ecx
  0070b	e8 00 00 00 00	 call	 _memcpy
  00710	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2769 : 					pChatMsg.szChatMsg[MAX_CHAT] = NULL;

  00713	b8 01 00 00 00	 mov	 eax, 1
  00718	6b c8 3c	 imul	 ecx, eax, 60
  0071b	c6 84 0d 69 ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$[ebp+ecx+29], 0

; 2770 : #endif
; 2771 : 					pChatMsg.btType = 2;	// 

  00723	c6 85 68 ff ff
	ff 02		 mov	 BYTE PTR _pChatMsg$[ebp+28], 2
$LN35@PChatProc:

; 2772 : 				}
; 2773 : 			}
; 2774 : 
; 2775 : 			if( gWriteChatLog )

  0072a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  00731	74 2c		 je	 SHORT $LN33@PChatProc

; 2776 : 			{
; 2777 : 				strcpy(pChatMsg.szTargetName[szTargetNameCount], lpObj->GuildName);

  00733	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00736	05 98 02 00 00	 add	 eax, 664		; 00000298H
  0073b	50		 push	 eax
  0073c	6b 8d 48 ff ff
	ff 0b		 imul	 ecx, DWORD PTR _szTargetNameCount$[ebp], 11
  00743	8d 54 0d a6	 lea	 edx, DWORD PTR _pChatMsg$[ebp+ecx+90]
  00747	52		 push	 edx
  00748	e8 00 00 00 00	 call	 _strcpy
  0074d	83 c4 08	 add	 esp, 8

; 2778 : 				szTargetNameCount++;

  00750	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _szTargetNameCount$[ebp]
  00756	83 c0 01	 add	 eax, 1
  00759	89 85 48 ff ff
	ff		 mov	 DWORD PTR _szTargetNameCount$[ebp], eax
$LN33@PChatProc:

; 2779 : 			}
; 2780 : 		}
; 2781 : 	}	

  0075f	eb 69		 jmp	 SHORT $LN25@PChatProc
$LN31@PChatProc:

; 2782 : 	else
; 2783 : 	{
; 2784 : #ifdef UPDATE_GM_FUNCTION_20070228	// GM      
; 2785 : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2786 : 		if( ( ( lpObj->Authority & AUTHORITY_EVENT_GM ) == AUTHORITY_EVENT_GM )
; 2787 : 	#ifdef MODIFY_BUFFSYSTEM_BUGFIX_05_20071220
; 2788 : 			&& ( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_INVISABLE ) ) )
; 2789 : 	#else
; 2790 : 			&& ( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_GM_MARK ) ) )
; 2791 : 	#endif // MODIFY_BUFFSYSTEM_BUGFIX_05_20071220
; 2792 : 
; 2793 : 	#else
; 2794 : 		if( ( (lpObj->Authority&AUTHORITY_EVENT_GM) == AUTHORITY_EVENT_GM ) 
; 2795 : 			&& ( (lpObj->m_ViewSkillState&STATE_CLOAKING) == STATE_CLOAKING ) )
; 2796 : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2797 : 			return;
; 2798 : #endif
; 2799 : //		LogAdd("chat:%s] %s", gObj[aIndex].Name, lpChat->chatmsg);
; 2800 : #ifdef ADD_NEWPVP_PKFIELD
; 2801 : 		//      .
; 2802 : 		if (g_NewPVP.IsDuel(*lpObj) || g_NewPVP.IsObserver(*lpObj))
; 2803 : 		{
; 2804 : 			g_NewPVP.ChatMsgSend(*lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 2805 : 		}
; 2806 : 		else
; 2807 : 		{
; 2808 : 			DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 2809 : 			MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 2810 : 		}
; 2811 : #else
; 2812 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);

  00761	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  00764	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00768	51		 push	 ecx
  00769	8b 55 08	 mov	 edx, DWORD PTR _lpChat$[ebp]
  0076c	52		 push	 edx
  0076d	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00771	50		 push	 eax
  00772	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00777	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2813 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);

  0077a	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  0077d	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00781	51		 push	 ecx
  00782	8b 55 08	 mov	 edx, DWORD PTR _lpChat$[ebp]
  00785	52		 push	 edx
  00786	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00789	50		 push	 eax
  0078a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0078f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2814 : #endif // ADD_NEWPVP_PKFIELD
; 2815 : 
; 2816 : 		if( gWriteChatLog )

  00792	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  00799	74 2f		 je	 SHORT $LN25@PChatProc

; 2817 : 		{
; 2818 : 			memcpy(pChatMsg.szChatMsg, lpChat->chatmsg, MAX_CHAT);

  0079b	6a 3c		 push	 60			; 0000003cH
  0079d	8b 45 08	 mov	 eax, DWORD PTR _lpChat$[ebp]
  007a0	83 c0 0d	 add	 eax, 13			; 0000000dH
  007a3	50		 push	 eax
  007a4	8d 8d 69 ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$[ebp+29]
  007aa	51		 push	 ecx
  007ab	e8 00 00 00 00	 call	 _memcpy
  007b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2819 : 			pChatMsg.szChatMsg[MAX_CHAT] = NULL;

  007b3	b8 01 00 00 00	 mov	 eax, 1
  007b8	6b c8 3c	 imul	 ecx, eax, 60
  007bb	c6 84 0d 69 ff
	ff ff 00	 mov	 BYTE PTR _pChatMsg$[ebp+ecx+29], 0

; 2820 : 			pChatMsg.btType = 0;	// 

  007c3	c6 85 68 ff ff
	ff 00		 mov	 BYTE PTR _pChatMsg$[ebp+28], 0
$LN25@PChatProc:

; 2821 : 		}
; 2822 : 	}
; 2823 : 
; 2824 : 	if( gWriteChatLog )

  007ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  007d1	74 63		 je	 SHORT $LN50@PChatProc

; 2825 : 	{
; 2826 : 		if( pChatMsg.btType != 0xFF )

  007d3	0f b6 85 68 ff
	ff ff		 movzx	 eax, BYTE PTR _pChatMsg$[ebp+28]
  007da	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  007df	74 55		 je	 SHORT $LN50@PChatProc

; 2827 : 		{
; 2828 : 			pChatMsg.btType |= (szTargetNameCount<<4);

  007e1	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _szTargetNameCount$[ebp]
  007e7	c1 e0 04	 shl	 eax, 4
  007ea	0f b6 8d 68 ff
	ff ff		 movzx	 ecx, BYTE PTR _pChatMsg$[ebp+28]
  007f1	0b c8		 or	 ecx, eax
  007f3	88 8d 68 ff ff
	ff		 mov	 BYTE PTR _pChatMsg$[ebp+28], cl

; 2829 : 			pChatMsg.h.size = sizeof(pChatMsg)-(5-szTargetNameCount)-1;

  007f9	b8 05 00 00 00	 mov	 eax, 5
  007fe	2b 85 48 ff ff
	ff		 sub	 eax, DWORD PTR _szTargetNameCount$[ebp]
  00804	b9 92 00 00 00	 mov	 ecx, 146		; 00000092H
  00809	2b c8		 sub	 ecx, eax
  0080b	83 e9 01	 sub	 ecx, 1
  0080e	88 8d 4d ff ff
	ff		 mov	 BYTE PTR _pChatMsg$[ebp+1], cl

; 2830 : 			if( gWriteChatLog )

  00814	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteChatLog@@3HA, 0 ; gWriteChatLog
  0081b	74 19		 je	 SHORT $LN50@PChatProc

; 2831 : 				gSendHackLog.SendData((LPBYTE)&pChatMsg, pChatMsg.h.size);

  0081d	0f b6 85 4d ff
	ff ff		 movzx	 eax, BYTE PTR _pChatMsg$[ebp+1]
  00824	50		 push	 eax
  00825	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _pChatMsg$[ebp]
  0082b	51		 push	 ecx
  0082c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSendHackLog@@3VCSendHackLog@@A ; gSendHackLog
  00831	e8 00 00 00 00	 call	 ?SendData@CSendHackLog@@QAEHPAEK@Z ; CSendHackLog::SendData
$LN50@PChatProc:

; 2832 : 		}
; 2833 : 	}
; 2834 : }

  00836	5f		 pop	 edi
  00837	5e		 pop	 esi
  00838	5b		 pop	 ebx
  00839	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0083c	33 cd		 xor	 ecx, ebp
  0083e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00843	8b e5		 mov	 esp, ebp
  00845	5d		 pop	 ebp
  00846	c3		 ret	 0
?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z ENDP		; PChatProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.h
;	COMDAT ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ PROC		; CQeustNpcTeleport::TalkRefDel, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : 		EnterCriticalSection(&CsRef);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 147  : 		RefCount--;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	83 e9 01	 sub	 ecx, 1
  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	89 0a		 mov	 DWORD PTR [edx], ecx

; 148  : 		if( RefCount < 0 )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	7d 09		 jge	 SHORT $LN2@TalkRefDel

; 149  : 		{
; 150  : 			RefCount = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN2@TalkRefDel:

; 151  : 		}
; 152  : 		LogAdd("QeustNpc RefCount Dec= %d", RefCount);

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	51		 push	 ecx
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00048	83 c4 08	 add	 esp, 8

; 153  : 		LeaveCriticalSection(&CsRef);

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 c0 04	 add	 eax, 4
  00051	50		 push	 eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 154  : 	}	

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ENDP		; CQeustNpcTeleport::TalkRefDel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\QuestInfo.h
;	COMDAT ?GetQeustCount@CQuestInfo@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetQeustCount@CQuestInfo@@QAEHXZ PROC			; CQuestInfo::GetQeustCount, COMDAT
; _this$ = ecx

; 132  : 	int		GetQeustCount(){return m_QuestCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetQeustCount@CQuestInfo@@QAEHXZ ENDP			; CQuestInfo::GetQeustCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1  - 

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1  - 

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2  - 

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2  - 

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3  - 

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3  - 

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4  - 

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4  - 

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5  - 

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5  - 

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6  - 

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6  - 

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.h
;	COMDAT ?GetRemainTime@CDevilSquare@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRemainTime@CDevilSquare@@QAEHXZ PROC		; CDevilSquare::GetRemainTime, COMDAT
; _this$ = ecx

; 128  : 	int			GetRemainTime(){return m_iRemainTime;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetRemainTime@CDevilSquare@@QAEHXZ ENDP		; CDevilSquare::GetRemainTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DevilSquare.h
;	COMDAT ?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ PROC ; CDevilSquare::GetState, COMDAT
; _this$ = ecx

; 121  : 	eDevilSquareState		GetState(){return m_eState;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ENDP ; CDevilSquare::GetState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TerrainManager.h
;	COMDAT ?Size@CTerrainManager@@QAE?BHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Size@CTerrainManager@@QAE?BHXZ PROC			; CTerrainManager::Size, COMDAT
; _this$ = ecx

; 22   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 		return m_iSize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 24   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Size@CTerrainManager@@QAE?BHXZ ENDP			; CTerrainManager::Size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TNotice.h
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 8    : inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b) { return (a << 24) + (b << 16) + (g << 8) + (r); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  0000d	c1 e0 18	 shl	 eax, 24			; 00000018H
  00010	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  00014	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00017	03 c1		 add	 eax, ecx
  00019	0f b6 55 10	 movzx	 edx, BYTE PTR _g$[ebp]
  0001d	c1 e2 08	 shl	 edx, 8
  00020	03 c2		 add	 eax, edx
  00022	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  00026	03 c1		 add	 eax, ecx
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z
_TEXT	SEGMENT
tv1075 = -104						; size = 4
tv1060 = -104						; size = 4
tv1045 = -104						; size = 4
tv936 = -104						; size = 4
tv1076 = -100						; size = 4
tv1061 = -100						; size = 4
tv1046 = -100						; size = 4
tv937 = -100						; size = 4
tv487 = -100						; size = 4
tv358 = -100						; size = 4
_level$1 = -32						; size = 4
_addskill$2 = -28					; size = 4
_skillnumber$3 = -21					; size = 1
_tMana$4 = -20						; size = 4
_nAddRate$5 = -16					; size = 4
_tLife$6 = -12						; size = 4
_citem$ = -8						; size = 4
_pos$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z PROC		; CGUseItemRecv, COMDAT

; 16903: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16904: 	int pos;
; 16905: 	CItem * citem;
; 16906: 
; 16907: #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 16908: 	//     
; 16909: 	int iItemUseType = lpMsg->btItemUseType;
; 16910: #endif
; 16911: 
; 16912: 	//      .
; 16913: 	if( gObj[aIndex].m_IfState.use ) 

  00009	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0001d	80 e2 03	 and	 dl, 3
  00020	0f b6 c2	 movzx	 eax, dl
  00023	85 c0		 test	 eax, eax
  00025	0f 84 94 00 00
	00		 je	 $LN7@CGUseItemR

; 16914: 	{
; 16915: 		if( gObj[aIndex].m_IfState.type != I_SHOP )

  0002b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00038	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0003f	c0 ea 04	 shr	 dl, 4
  00042	80 e2 0f	 and	 dl, 15			; 0000000fH
  00045	0f b6 c2	 movzx	 eax, dl
  00048	83 f8 03	 cmp	 eax, 3
  0004b	74 72		 je	 SHORT $LN7@CGUseItemR

; 16916: 		{
; 16917: #ifdef ADD_SHIELD_POINT_01_20060403
; 16918: 			GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 16919: #else
; 16920: 			GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  0004d	6a 01		 push	 1
  0004f	68 fd 00 00 00	 push	 253			; 000000fdH
  00054	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00061	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  0006a	0f b7 c2	 movzx	 eax, dx
  0006d	50		 push	 eax
  0006e	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00077	83 c4 10	 add	 esp, 16			; 00000010H

; 16921: #endif
; 16922: 			LogAdd("[%s][%s] CGUseItemRecv()_If return %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
  0007f	83 c0 13	 add	 eax, 19			; 00000013H
  00082	50		 push	 eax
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00088	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0008f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00095	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00099	50		 push	 eax
  0009a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a7	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  000ab	50		 push	 eax
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5ret@
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000b7	83 c4 14	 add	 esp, 20			; 00000014H

; 16923: 			return;

  000ba	e9 d1 16 00 00	 jmp	 $LN1@CGUseItemR
$LN7@CGUseItemR:

; 16924: 		}
; 16925: 	}
; 16926: 	//    
; 16927: 	if( gObj[aIndex].CloseType != -1 ) 

  000bf	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cc	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  000d1	83 fa ff	 cmp	 edx, -1
  000d4	74 72		 je	 SHORT $LN8@CGUseItemR

; 16928: 	{		
; 16929: #ifdef ADD_SHIELD_POINT_01_20060403
; 16930: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 16931: #else
; 16932: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  000d6	6a 01		 push	 1
  000d8	68 fd 00 00 00	 push	 253			; 000000fdH
  000dd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ea	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  000f3	0f b7 c2	 movzx	 eax, dx
  000f6	50		 push	 eax
  000f7	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000fa	51		 push	 ecx
  000fb	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00100	83 c4 10	 add	 esp, 16			; 00000010H

; 16933: #endif
; 16934: 		LogAdd("[%s][%s] CGUseItemRecv()_CloseType return %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  00103	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
  00108	83 c0 1f	 add	 eax, 31			; 0000001fH
  0010b	50		 push	 eax
  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00111	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00118	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011e	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00122	50		 push	 eax
  00123	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0012a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00130	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00134	50		 push	 eax
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseT@
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00140	83 c4 14	 add	 esp, 20			; 00000014H

; 16935: 		return;

  00143	e9 48 16 00 00	 jmp	 $LN1@CGUseItemR
$LN8@CGUseItemR:

; 16936: 	}
; 16937: 
; 16938: #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719			//    -   
; 16939: 	if (gObjFixInventoryPointer(aIndex) == false) {

  00148	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00151	83 c4 04	 add	 esp, 4
  00154	0f b6 c8	 movzx	 ecx, al
  00157	85 c9		 test	 ecx, ecx
  00159	75 1c		 jne	 SHORT $LN9@CGUseItemR

; 16940: 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0015b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
  00160	83 c0 25	 add	 eax, 37			; 00000025H
  00163	50		 push	 eax
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGUseItemR:

; 16941: 	}
; 16942: #endif
; 16943: 
; 16944: #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//       .
; 16945: 	if (gObj[aIndex].pTransaction == 1) {

  00177	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00184	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  0018c	83 fa 01	 cmp	 edx, 1
  0018f	75 55		 jne	 SHORT $LN10@CGUseItemR

; 16946: 		LogAddTD("[%s][%s] CGUseItemRecv() Failed : Transaction == 1, IF_TYPE : %d",

  00191	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00198	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019e	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  001a5	c0 ea 04	 shr	 dl, 4
  001a8	80 e2 0f	 and	 dl, 15			; 0000000fH
  001ab	0f b6 c2	 movzx	 eax, dl
  001ae	50		 push	 eax
  001af	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bc	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  001c0	50		 push	 eax
  001c1	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ce	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  001d2	50		 push	 eax
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed@
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001de	83 c4 10	 add	 esp, 16			; 00000010H

; 16947: 			gObj[aIndex].AccountID,
; 16948: 			gObj[aIndex].Name,
; 16949: 			gObj[aIndex].m_IfState.type
; 16950: 			);
; 16951: 		return;

  001e1	e9 aa 15 00 00	 jmp	 $LN1@CGUseItemR
$LN10@CGUseItemR:

; 16952: 	}
; 16953: #endif
; 16954: 
; 16955: #ifdef ADD_NEWPVP_PKFIELD
; 16956: 	if ( g_NewPVP.IsObserver(gObj[aIndex]) )
; 16957: 	{
; 16958: 		// "   ."
; 16959: 		GCServerMsgStringSend(lMsg.Get(3428), aIndex, 1);
; 16960: 		return;
; 16961: 	}
; 16962: #endif // ADD_NEWPVP_PKFIELD
; 16963: 
; 16964: 	pos = lpMsg->inventoryPos;

  001e6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001e9	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  001ed	89 4d fc	 mov	 DWORD PTR _pos$[ebp], ecx

; 16965: 
; 16966: 	if( pos > MAX_INVENTORY-1 ) 

  001f0	83 7d fc 4b	 cmp	 DWORD PTR _pos$[ebp], 75 ; 0000004bH
  001f4	0f 8e 9a 00 00
	00		 jle	 $LN11@CGUseItemR

; 16967: 	{
; 16968: 		LogAdd(lMsg.Get(497), __FILE__, __LINE__);

  001fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
  001ff	83 c0 41	 add	 eax, 65			; 00000041H
  00202	50		 push	 eax
  00203	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00208	68 f1 01 00 00	 push	 497			; 000001f1H
  0020d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00218	50		 push	 eax
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16969: #ifdef ADD_SHIELD_POINT_01_20060403
; 16970: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 16971: #else
; 16972: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  00222	6a 01		 push	 1
  00224	68 fd 00 00 00	 push	 253			; 000000fdH
  00229	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00236	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  0023f	0f b7 c2	 movzx	 eax, dx
  00242	50		 push	 eax
  00243	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00246	51		 push	 ecx
  00247	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  0024c	83 c4 10	 add	 esp, 16			; 00000010H

; 16973: #endif
; 16974: 		LogAdd("[%s][%s] CGUseItemRecv()_Inventory return %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  0024f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
  00254	83 c0 47	 add	 eax, 71			; 00000047H
  00257	50		 push	 eax
  00258	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0025d	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00264	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0026a	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0026e	50		 push	 eax
  0026f	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00276	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027c	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00280	50		 push	 eax
  00281	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invent@
  00286	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0028c	83 c4 14	 add	 esp, 20			; 00000014H

; 16975: 		return;

  0028f	e9 fc 14 00 00	 jmp	 $LN1@CGUseItemR
$LN11@CGUseItemR:

; 16976: 	}
; 16977: 	
; 16978: 	//    
; 16979: 	if( lpMsg->inventoryPos == lpMsg->invenrotyTarget ) 

  00294	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00297	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0029b	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0029e	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  002a2	3b c8		 cmp	 ecx, eax
  002a4	75 72		 jne	 SHORT $LN12@CGUseItemR

; 16980: 	{
; 16981: #ifdef ADD_SHIELD_POINT_01_20060403
; 16982: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 16983: #else
; 16984: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  002a6	6a 01		 push	 1
  002a8	68 fd 00 00 00	 push	 253			; 000000fdH
  002ad	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ba	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  002c3	0f b7 c2	 movzx	 eax, dx
  002c6	50		 push	 eax
  002c7	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  002ca	51		 push	 ecx
  002cb	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  002d0	83 c4 10	 add	 esp, 16			; 00000010H

; 16985: #endif
; 16986: 		LogAdd("error-L1 : [%s][%s] CGUseItemRecv()_Pos return %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  002d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
  002d8	83 c0 53	 add	 eax, 83			; 00000053H
  002db	50		 push	 eax
  002dc	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  002e1	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ee	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  002f2	50		 push	 eax
  002f3	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00300	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00304	50		 push	 eax
  00305	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRe@
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00310	83 c4 14	 add	 esp, 20			; 00000014H

; 16987: 		return;

  00313	e9 78 14 00 00	 jmp	 $LN1@CGUseItemR
$LN12@CGUseItemR:

; 16988: 	}
; 16989: 
; 16990: 	citem = (CItem*)&gObj[aIndex].pInventory[pos];

  00318	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0031f	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00326	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0032c	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00333	89 4d f8	 mov	 DWORD PTR _citem$[ebp], ecx

; 16991: 
; 16992: #ifdef HAPPY_POUCH // happycat@20050201 () -   
; 16993: 	if (citem->m_Type == MAKE_ITEMNUM(14,11))
; 16994: 	{
; 16995: 		if (citem->m_Level == 14) //BLUE POUCH
; 16996: 		{
; 16997: 			gObj[aIndex].m_btLifeInc		= 50;
; 16998: 			gObj[aIndex].m_lLifeIncTime		= 600;	// 10 minutes
; 16999: 			
; 17000: 			if( gObj[aIndex].m_bPCBangUser == FALSE )	// apple20050203 PC   .
; 17001: 			{
; 17002: 				gObj[aIndex].m_lFreeKalimaTime	= 600;	// 10 minutes, alicecat@
; 17003: 			}
; 17004: 			gObjCalCharacter(aIndex);
; 17005: 
; 17006: #ifndef ADD_SHIELD_POINT_01_20060403	// not define  : gObjCalCharacter   .
; 17007: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0 );
; 17008: #endif
; 17009: 
; 17010: 
; 17011: 			//alicecat@
; 17012: 			PMSG_NOTICE	pNotice;						
; 17013: 			TNotice::MakeNoticeMsgEx( &pNotice, 1, "  10      .");
; 17014: 			DataSend(aIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 17015: 			
; 17016: 			GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17017: 			gObjInventoryDeleteItem(aIndex, pos);
; 17018: 
; 17019: #ifdef UPDATE_ADD_LOG_20080117
; 17020: 			LogAddTD( "[UseItem] (%s)(%s) Used Box Luck Item ",	gObj[aIndex].AccountID, gObj[aIndex].Name );
; 17021: 			return;	//        
; 17022: #endif
; 17023: 		}		
; 17024: 	}
; 17025: #endif//HAPPY_POUCH	
; 17026: 
; 17027: 
; 17028: 	//  ?
; 17029: 	if( citem->IsItem() )

  00336	8b 4d f8	 mov	 ecx, DWORD PTR _citem$[ebp]
  00339	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0033e	85 c0		 test	 eax, eax
  00340	0f 84 e8 13 00
	00		 je	 $LN13@CGUseItemR

; 17030: 	{
; 17031: 
; 17032: #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202
; 17033: 		if( gObjCheckSerial0ItemList(citem) )

  00346	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  0034f	83 c4 04	 add	 esp, 4
  00352	85 c0		 test	 eax, eax
  00354	0f 84 8e 00 00
	00		 je	 $LN15@CGUseItemR

; 17034: 		{
; 17035: 			// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 17036: 			MsgOutput( aIndex, lMsg.Get(3354) );			// "  .  ."

  0035a	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0035f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00364	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0036a	50		 push	 eax
  0036b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0036e	50		 push	 eax
  0036f	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00374	83 c4 08	 add	 esp, 8

; 17037: #ifdef ADD_SHIELD_POINT_01_20060403
; 17038: 			GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17039: #else
; 17040: 			GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  00377	6a 01		 push	 1
  00379	68 fd 00 00 00	 push	 253			; 000000fdH
  0037e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00385	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0038b	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  00394	0f b7 c2	 movzx	 eax, dx
  00397	50		 push	 eax
  00398	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0039b	51		 push	 ecx
  0039c	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  003a1	83 c4 10	 add	 esp, 16			; 00000010H

; 17041: #endif
; 17042: 			LogAddTD( "[ANTI-HACK][Serial 0 Item] [UseItem] (%s)(%s) Item(%s) Pos(%d)",

  003a4	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  003a7	50		 push	 eax
  003a8	8b 4d f8	 mov	 ecx, DWORD PTR _citem$[ebp]
  003ab	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  003b0	50		 push	 eax
  003b1	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003be	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  003c2	50		 push	 eax
  003c3	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d0	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  003d4	50		 push	 eax
  003d5	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUse@
  003da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003e0	83 c4 14	 add	 esp, 20			; 00000014H

; 17043: 				gObj[aIndex].AccountID, gObj[aIndex].Name, citem->GetName(), pos );
; 17044: 			return;

  003e3	e9 a8 13 00 00	 jmp	 $LN1@CGUseItemR
$LN15@CGUseItemR:

; 17045: 		}
; 17046: #endif
; 17047: 
; 17048: 		//     ..
; 17049: 		if( gObjInventorySearchSerialNumber(&gObj[aIndex], citem->GetNumber()) == FALSE )

  003e8	8b 4d f8	 mov	 ecx, DWORD PTR _citem$[ebp]
  003eb	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  003f0	50		 push	 eax
  003f1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003f8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003fe	50		 push	 eax
  003ff	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00404	83 c4 08	 add	 esp, 8
  00407	85 c0		 test	 eax, eax
  00409	75 74		 jne	 SHORT $LN16@CGUseItemR

; 17050: 		{
; 17051: #ifdef ADD_SHIELD_POINT_01_20060403
; 17052: 			GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17053: #else
; 17054: 			GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  0040b	6a 01		 push	 1
  0040d	68 fd 00 00 00	 push	 253			; 000000fdH
  00412	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00419	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0041f	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  00428	0f b7 c2	 movzx	 eax, dx
  0042b	50		 push	 eax
  0042c	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0042f	51		 push	 ecx
  00430	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00435	83 c4 10	 add	 esp, 16			; 00000010H

; 17055: #endif
; 17056: 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  00438	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
  0043d	05 99 00 00 00	 add	 eax, 153		; 00000099H
  00442	50		 push	 eax
  00443	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00448	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0044f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00455	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00459	50		 push	 eax
  0045a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00461	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00467	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0046b	50		 push	 eax
  0046c	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5re@
  00471	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00477	83 c4 14	 add	 esp, 20			; 00000014H

; 17057: 			return;

  0047a	e9 11 13 00 00	 jmp	 $LN1@CGUseItemR
$LN16@CGUseItemR:

; 17058: 		}
; 17059: 
; 17060: 		if( citem->m_serial )

  0047f	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00482	0f be 48 04	 movsx	 ecx, BYTE PTR [eax+4]
  00486	85 c9		 test	 ecx, ecx
  00488	74 4e		 je	 SHORT $LN18@CGUseItemR

; 17061: 		{	
; 17062: 			if( !gObjCanItemTouch(&gObj[aIndex], 1) )

  0048a	6a 01		 push	 1
  0048c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00493	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00499	50		 push	 eax
  0049a	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  0049f	83 c4 08	 add	 esp, 8
  004a2	85 c0		 test	 eax, eax
  004a4	75 32		 jne	 SHORT $LN18@CGUseItemR

; 17063: 			{	//       
; 17064: #ifdef ADD_SHIELD_POINT_01_20060403
; 17065: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17066: #else
; 17067: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  004a6	6a 01		 push	 1
  004a8	68 fd 00 00 00	 push	 253			; 000000fdH
  004ad	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ba	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  004c3	0f b7 c2	 movzx	 eax, dx
  004c6	50		 push	 eax
  004c7	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  004ca	51		 push	 ecx
  004cb	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  004d0	83 c4 10	 add	 esp, 16			; 00000010H

; 17068: #endif
; 17069: 				return;

  004d3	e9 b8 12 00 00	 jmp	 $LN1@CGUseItemR
$LN18@CGUseItemR:

; 17070: 			}
; 17071: 		}
; 17072: 
; 17073: 		//  ?
; 17074: 		if( citem->m_Type == MAKE_ITEMNUM(14,0) || 
; 17075: 			citem->m_Type == MAKE_ITEMNUM(14,1) ||
; 17076: 			citem->m_Type == MAKE_ITEMNUM(14,2) ||

  004d8	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  004db	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  004df	6a 00		 push	 0
  004e1	6a 0e		 push	 14			; 0000000eH
  004e3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  004e8	83 c4 08	 add	 esp, 8
  004eb	3b f0		 cmp	 esi, eax
  004ed	74 49		 je	 SHORT $LN21@CGUseItemR
  004ef	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  004f2	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  004f6	6a 01		 push	 1
  004f8	6a 0e		 push	 14			; 0000000eH
  004fa	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  004ff	83 c4 08	 add	 esp, 8
  00502	3b f0		 cmp	 esi, eax
  00504	74 32		 je	 SHORT $LN21@CGUseItemR
  00506	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00509	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0050d	6a 02		 push	 2
  0050f	6a 0e		 push	 14			; 0000000eH
  00511	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00516	83 c4 08	 add	 esp, 8
  00519	3b f0		 cmp	 esi, eax
  0051b	74 1b		 je	 SHORT $LN21@CGUseItemR
  0051d	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00520	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00524	6a 03		 push	 3
  00526	6a 0e		 push	 14			; 0000000eH
  00528	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0052d	83 c4 08	 add	 esp, 8
  00530	3b f0		 cmp	 esi, eax
  00532	0f 85 d6 02 00
	00		 jne	 $LN19@CGUseItemR
$LN21@CGUseItemR:

; 17077: 			citem->m_Type == MAKE_ITEMNUM(14,3) )	//   ..
; 17078: 		{
; 17079: 			int tLife = citem->m_Value*10-(gObj[aIndex].Level*2);

  00538	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  0053b	6b 48 5c 0a	 imul	 ecx, DWORD PTR [eax+92], 10
  0053f	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00546	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0054b	0f bf 94 10 a0
	00 00 00	 movsx	 edx, WORD PTR [eax+edx+160]
  00553	d1 e2		 shl	 edx, 1
  00555	2b ca		 sub	 ecx, edx
  00557	89 4d f4	 mov	 DWORD PTR _tLife$6[ebp], ecx

; 17080: 			if( tLife < 0 ) tLife = 0;

  0055a	79 07		 jns	 SHORT $LN22@CGUseItemR
  0055c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _tLife$6[ebp], 0
$LN22@CGUseItemR:

; 17081: 
; 17082: #ifdef ADD_HP_POTION_LEVEL1_20040401
; 17083: 			int nAddRate = 0;

  00563	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _nAddRate$5[ebp], 0

; 17084: 			
; 17085: 			switch(citem->m_Type)

  0056a	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  0056d	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00571	89 4d 9c	 mov	 DWORD PTR tv358[ebp], ecx
  00574	8b 55 9c	 mov	 edx, DWORD PTR tv358[ebp]
  00577	81 ea c0 01 00
	00		 sub	 edx, 448		; 000001c0H
  0057d	89 55 9c	 mov	 DWORD PTR tv358[ebp], edx
  00580	83 7d 9c 03	 cmp	 DWORD PTR tv358[ebp], 3
  00584	77 30		 ja	 SHORT $LN2@CGUseItemR
  00586	8b 45 9c	 mov	 eax, DWORD PTR tv358[ebp]
  00589	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN114@CGUseItemR[eax*4]
$LN23@CGUseItemR:

; 17086: 			{
; 17087: 			case MAKE_ITEMNUM2(14,0):
; 17088: 				nAddRate = g_GlobalConfig.m_iApple_Potion;

  00590	a1 9c 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+156
  00595	89 45 f0	 mov	 DWORD PTR _nAddRate$5[ebp], eax

; 17089: 				break;

  00598	eb 1c		 jmp	 SHORT $LN2@CGUseItemR
$LN24@CGUseItemR:

; 17090: 			case MAKE_ITEMNUM2(14,1):
; 17091: 				nAddRate = g_GlobalConfig.m_iSmallHP_Potion;

  0059a	a1 a0 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+160
  0059f	89 45 f0	 mov	 DWORD PTR _nAddRate$5[ebp], eax

; 17092: 				break;

  005a2	eb 12		 jmp	 SHORT $LN2@CGUseItemR
$LN25@CGUseItemR:

; 17093: 			case MAKE_ITEMNUM2(14,2):
; 17094: 				nAddRate = g_GlobalConfig.m_iMediumHP_Potion;

  005a4	a1 a4 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+164
  005a9	89 45 f0	 mov	 DWORD PTR _nAddRate$5[ebp], eax

; 17095: 				break;

  005ac	eb 08		 jmp	 SHORT $LN2@CGUseItemR
$LN26@CGUseItemR:

; 17096: 			case MAKE_ITEMNUM2(14,3):
; 17097: 				nAddRate = g_GlobalConfig.m_iLargeHP_Potion;

  005ae	a1 a8 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+168
  005b3	89 45 f0	 mov	 DWORD PTR _nAddRate$5[ebp], eax
$LN2@CGUseItemR:

; 17098: 				break;
; 17099: 			}
; 17100: 
; 17101: 			if( citem->m_Level == 1 )

  005b6	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  005b9	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  005bd	83 f9 01	 cmp	 ecx, 1
  005c0	75 09		 jne	 SHORT $LN27@CGUseItemR

; 17102: 				nAddRate += 5;

  005c2	8b 45 f0	 mov	 eax, DWORD PTR _nAddRate$5[ebp]
  005c5	83 c0 05	 add	 eax, 5
  005c8	89 45 f0	 mov	 DWORD PTR _nAddRate$5[ebp], eax
$LN27@CGUseItemR:

; 17103: 
; 17104: 			tLife += (int)gObj[aIndex].MaxLife*nAddRate/100;

  005cb	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005d8	f3 0f 2c 84 01
	c0 00 00 00	 cvttss2si eax, DWORD PTR [ecx+eax+192]
  005e1	0f af 45 f0	 imul	 eax, DWORD PTR _nAddRate$5[ebp]
  005e5	99		 cdq
  005e6	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  005eb	f7 f9		 idiv	 ecx
  005ed	03 45 f4	 add	 eax, DWORD PTR _tLife$6[ebp]
  005f0	89 45 f4	 mov	 DWORD PTR _tLife$6[ebp], eax

; 17105: #else
; 17106: 			switch(citem->m_Type)
; 17107: 			{
; 17108: 			case MAKE_ITEMNUM2(14,0):
; 17109: 				tLife += (int)gObj[aIndex].MaxLife*g_GlobalConfig.m_iApple_Potion/100;
; 17110: 				break;
; 17111: 			case MAKE_ITEMNUM2(14,1):
; 17112: 				tLife += (int)gObj[aIndex].MaxLife*g_GlobalConfig.m_iSmallHP_Potion/100;
; 17113: 				break;
; 17114: 			case MAKE_ITEMNUM2(14,2):
; 17115: 				tLife += (int)gObj[aIndex].MaxLife*g_GlobalConfig.m_iMediumHP_Potion/100;
; 17116: 				break;
; 17117: 			case MAKE_ITEMNUM2(14,3):
; 17118: 				tLife += (int)gObj[aIndex].MaxLife*g_GlobalConfig.m_iLargeHP_Potion/100;
; 17119: 				break;
; 17120: 			}
; 17121: #endif
; 17122: 			
; 17123: #ifdef IMMEDIATELY_HP_MP_AG_RECUPERATION_20050614
; 17124: 			if( citem->m_Type == MAKE_ITEMNUM(14,0) ) {
; 17125: 				if( citem->m_Level < 2) {
; 17126: 					gObj[aIndex].FillLife += tLife;
; 17127: 					tLife = 0; //  HP     
; 17128: 				}
; 17129: 			}
; 17130: #endif
; 17131: 
; 17132: #ifdef USE_PREV_HP_POTION
; 17133: 			if( gObj[aIndex].FillLife > 0.f )

  005f3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00600	f3 0f 10 84 01
	c8 00 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+200]
  00609	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00610	0f 86 1d 01 00
	00		 jbe	 $LN28@CGUseItemR

; 17134: 			{
; 17135: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  00616	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0061d	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00624	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0062a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00630	f3 0f 10 84 02
	bc 00 00 00	 movss	 xmm0, DWORD PTR [edx+eax+188]
  00639	f3 0f 58 84 0e
	c8 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+200]
  00642	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00649	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0064f	f3 0f 11 84 01
	bc 00 00 00	 movss	 DWORD PTR [ecx+eax+188], xmm0

; 17136: 				if( gObj[aIndex].Life > (gObj[aIndex].MaxLife+gObj[aIndex].AddLife) ) 

  00658	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0065f	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00666	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0066d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00673	f3 0f 2a 84 16
	0c 01 00 00	 cvtsi2ss xmm0, DWORD PTR [esi+edx+268]
  0067c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00682	f3 0f 58 84 0a
	c0 00 00 00	 addss	 xmm0, DWORD PTR [edx+ecx+192]
  0068b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00691	f3 0f 10 8c 01
	bc 00 00 00	 movss	 xmm1, DWORD PTR [ecx+eax+188]
  0069a	0f 2f c8	 comiss	 xmm1, xmm0
  0069d	76 5a		 jbe	 SHORT $LN29@CGUseItemR

; 17137: 				{
; 17138: 					gObj[aIndex].Life = (gObj[aIndex].MaxLife+gObj[aIndex].AddLife);

  0069f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006a6	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  006ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006b3	f3 0f 2a 84 0a
	0c 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+268]
  006bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006c2	f3 0f 58 84 01
	c0 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+192]
  006cb	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  006d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006d7	f3 0f 11 84 10
	bc 00 00 00	 movss	 DWORD PTR [eax+edx+188], xmm0

; 17139: 					gObj[aIndex].FillLife = 0;	//    .

  006e0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006ed	0f 57 c0	 xorps	 xmm0, xmm0
  006f0	f3 0f 11 84 01
	c8 00 00 00	 movss	 DWORD PTR [ecx+eax+200], xmm0
$LN29@CGUseItemR:

; 17140: 				}
; 17141: #ifdef ADD_SHIELD_POINT_01_20060403
; 17142: 				GCReFillSend(gObj[aIndex].m_Index, (WORD)gObj[aIndex].Life, 0xFF, 0, (WORD)gObj[aIndex].iShield);
; 17143: #else
; 17144: 				GCReFillSend(gObj[aIndex].m_Index, (WORD)gObj[aIndex].Life, 0xFF, 0);

  006f9	6a 00		 push	 0
  006fb	68 ff 00 00 00	 push	 255			; 000000ffH
  00700	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00707	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0070d	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  00716	0f b7 c2	 movzx	 eax, dx
  00719	50		 push	 eax
  0071a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00721	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00727	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0072a	50		 push	 eax
  0072b	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00730	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@CGUseItemR:

; 17145: #endif
; 17146: 			}
; 17147: #endif		
; 17148: 			gObj[aIndex].FillLifeMax = (float)tLife;

  00733	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _tLife$6[ebp]
  00738	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0073f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00745	f3 0f 11 84 01
	cc 00 00 00	 movss	 DWORD PTR [ecx+eax+204], xmm0

; 17149: 			gObj[aIndex].FillLife	 = (float)tLife;

  0074e	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _tLife$6[ebp]
  00753	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0075a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00760	f3 0f 11 84 01
	c8 00 00 00	 movss	 DWORD PTR [ecx+eax+200], xmm0

; 17150: 
; 17151: 
; 17152: #ifndef IMMEDIATELY_HP_MP_AG_RECUPERATION_20050614
; 17153: 	#ifdef ADD_HP_POTION_LEVEL1_20040401
; 17154: 				//   1    2
; 17155: 				if( citem->m_Level == 1 )

  00769	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  0076c	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00770	83 f9 01	 cmp	 ecx, 1
  00773	75 17		 jne	 SHORT $LN30@CGUseItemR

; 17156: 					gObj[aIndex].FillLifeCount = 2;

  00775	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0077c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00782	c6 84 01 df 00
	00 00 02	 mov	 BYTE PTR [ecx+eax+223], 2
  0078a	eb 15		 jmp	 SHORT $LN31@CGUseItemR
$LN30@CGUseItemR:

; 17157: 				else
; 17158: 					gObj[aIndex].FillLifeCount = 3;

  0078c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00793	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00799	c6 84 01 df 00
	00 00 03	 mov	 BYTE PTR [ecx+eax+223], 3
$LN31@CGUseItemR:

; 17159: 	#endif
; 17160: #endif
; 17161: 
; 17162: #ifdef IMMEDIATELY_HP_MP_AG_RECUPERATION_20050614
; 17163: 			if( citem->m_Type == MAKE_ITEMNUM(14,0) && citem->m_Level < 2) {
; 17164: 				gObj[aIndex].FillLifeCount = 0;
; 17165: 			}
; 17166: 			else {
; 17167: 				if( citem->m_Level == 1 )
; 17168: 					gObj[aIndex].FillLifeCount = 2;
; 17169: 				else
; 17170: 					gObj[aIndex].FillLifeCount = 3;
; 17171: 			} 
; 17172: #endif
; 17173: 
; 17174: #ifdef ADD_EFFECT_POTION_20040401
; 17175: 			GCSendEffectInfo( aIndex, EFFECT_POTION_HP );
; 17176: #endif
; 17177: 			
; 17178: 			//gObj[aIndex].Life     += tLife;
; 17179: 			//if( gObj[aIndex].Life > gObj[aIndex].MaxLife-1 ) gObj[aIndex].Life = gObj[aIndex].MaxLife;
; 17180: 			
; 17181: 			//GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, pos, 1);
; 17182: 			//LogAdd("%s(%d)   : %d %f %f %f", gObj[aIndex].Name, aIndex, tLife, gObj[aIndex].MaxLife, gObj[aIndex].FillLifeMax, gObj[aIndex].FillLife);
; 17183: 			
; 17184: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )

  007a1	6a 01		 push	 1
  007a3	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  007a6	50		 push	 eax
  007a7	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  007ae	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007b4	51		 push	 ecx
  007b5	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  007ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  007bd	85 c0		 test	 eax, eax
  007bf	75 48		 jne	 SHORT $LN32@CGUseItemR

; 17185: 			{
; 17186: 				gObjInventoryItemSet(aIndex, pos, 0xFF);

  007c1	68 ff 00 00 00	 push	 255			; 000000ffH
  007c6	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  007c9	50		 push	 eax
  007ca	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  007cd	51		 push	 ecx
  007ce	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  007d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17187: 				gObj[aIndex].pInventory[pos].Clear();

  007d6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007dd	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  007e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007ea	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  007f1	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17188: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  007f6	6a 01		 push	 1
  007f8	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  007fc	50		 push	 eax
  007fd	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00800	51		 push	 ecx
  00801	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00806	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN32@CGUseItemR:

; 17189: 			}
; 17190: 		}

  00809	e9 1e 0f 00 00	 jmp	 $LN96@CGUseItemR
$LN19@CGUseItemR:

; 17191: 		else if( citem->m_Type == MAKE_ITEMNUM(14,4) || 
; 17192: 				 citem->m_Type == MAKE_ITEMNUM(14,5) || 

  0080e	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00811	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00815	6a 04		 push	 4
  00817	6a 0e		 push	 14			; 0000000eH
  00819	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0081e	83 c4 08	 add	 esp, 8
  00821	3b f0		 cmp	 esi, eax
  00823	74 32		 je	 SHORT $LN35@CGUseItemR
  00825	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00828	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0082c	6a 05		 push	 5
  0082e	6a 0e		 push	 14			; 0000000eH
  00830	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00835	83 c4 08	 add	 esp, 8
  00838	3b f0		 cmp	 esi, eax
  0083a	74 1b		 je	 SHORT $LN35@CGUseItemR
  0083c	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  0083f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00843	6a 06		 push	 6
  00845	6a 0e		 push	 14			; 0000000eH
  00847	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0084c	83 c4 08	 add	 esp, 8
  0084f	3b f0		 cmp	 esi, eax
  00851	0f 85 aa 02 00
	00		 jne	 $LN33@CGUseItemR
$LN35@CGUseItemR:

; 17193: 				 citem->m_Type == MAKE_ITEMNUM(14,6) )
; 17194: 
; 17195: 		{
; 17196: 			int tMana = citem->m_Value*10-(gObj[aIndex].Level);

  00857	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  0085a	6b 48 5c 0a	 imul	 ecx, DWORD PTR [eax+92], 10
  0085e	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00865	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0086a	0f bf 94 10 a0
	00 00 00	 movsx	 edx, WORD PTR [eax+edx+160]
  00872	2b ca		 sub	 ecx, edx
  00874	89 4d ec	 mov	 DWORD PTR _tMana$4[ebp], ecx

; 17197: 			if( tMana < 0 ) tMana = 0;

  00877	79 07		 jns	 SHORT $LN36@CGUseItemR
  00879	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tMana$4[ebp], 0
$LN36@CGUseItemR:

; 17198: 			switch(citem->m_Type)

  00880	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00883	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00887	89 4d 9c	 mov	 DWORD PTR tv487[ebp], ecx
  0088a	81 7d 9c c4 01
	00 00		 cmp	 DWORD PTR tv487[ebp], 452 ; 000001c4H
  00891	74 1b		 je	 SHORT $LN37@CGUseItemR
  00893	81 7d 9c c5 01
	00 00		 cmp	 DWORD PTR tv487[ebp], 453 ; 000001c5H
  0089a	74 5c		 je	 SHORT $LN38@CGUseItemR
  0089c	81 7d 9c c6 01
	00 00		 cmp	 DWORD PTR tv487[ebp], 454 ; 000001c6H
  008a3	0f 84 96 00 00
	00		 je	 $LN39@CGUseItemR
  008a9	e9 d6 00 00 00	 jmp	 $LN4@CGUseItemR
$LN37@CGUseItemR:

; 17199: 			{
; 17200: 			case MAKE_ITEMNUM2(14,4):
; 17201: 				tMana += (int)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana)*g_GlobalConfig.m_iSmallMP_Potion/100;

  008ae	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  008b5	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  008bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008c2	f3 0f 2a 84 0a
	10 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+272]
  008cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008d1	f3 0f 58 84 01
	d4 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+212]
  008da	f3 0f 2c c0	 cvttss2si eax, xmm0
  008de	0f af 05 ac 00
	00 00		 imul	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+172
  008e5	99		 cdq
  008e6	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  008eb	f7 f9		 idiv	 ecx
  008ed	03 45 ec	 add	 eax, DWORD PTR _tMana$4[ebp]
  008f0	89 45 ec	 mov	 DWORD PTR _tMana$4[ebp], eax

; 17202: 				break;

  008f3	e9 8c 00 00 00	 jmp	 $LN4@CGUseItemR
$LN38@CGUseItemR:

; 17203: 			case MAKE_ITEMNUM2(14,5):
; 17204: 				tMana += (int)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana)*g_GlobalConfig.m_iMediumMP_Potion/100;

  008f8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  008ff	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00906	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0090c	f3 0f 2a 84 0a
	10 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+272]
  00915	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0091b	f3 0f 58 84 01
	d4 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+212]
  00924	f3 0f 2c c0	 cvttss2si eax, xmm0
  00928	0f af 05 b0 00
	00 00		 imul	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+176
  0092f	99		 cdq
  00930	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00935	f7 f9		 idiv	 ecx
  00937	03 45 ec	 add	 eax, DWORD PTR _tMana$4[ebp]
  0093a	89 45 ec	 mov	 DWORD PTR _tMana$4[ebp], eax

; 17205: 				break;

  0093d	eb 45		 jmp	 SHORT $LN4@CGUseItemR
$LN39@CGUseItemR:

; 17206: 			case MAKE_ITEMNUM2(14,6):
; 17207: 				tMana += (int)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana)*g_GlobalConfig.m_iLargeMP_Potion/100;

  0093f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00946	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0094d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00953	f3 0f 2a 84 0a
	10 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+272]
  0095c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00962	f3 0f 58 84 01
	d4 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+212]
  0096b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0096f	0f af 05 b4 00
	00 00		 imul	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+180
  00976	99		 cdq
  00977	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0097c	f7 f9		 idiv	 ecx
  0097e	03 45 ec	 add	 eax, DWORD PTR _tMana$4[ebp]
  00981	89 45 ec	 mov	 DWORD PTR _tMana$4[ebp], eax
$LN4@CGUseItemR:

; 17208: 				break;
; 17209: 			}
; 17210: 			gObj[aIndex].Mana += tMana;

  00984	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0098b	f3 0f 2a 45 ec	 cvtsi2ss xmm0, DWORD PTR _tMana$4[ebp]
  00990	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00996	f3 0f 58 84 01
	d0 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+208]
  0099f	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  009a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009ab	f3 0f 11 84 10
	d0 00 00 00	 movss	 DWORD PTR [eax+edx+208], xmm0

; 17211: 			if( gObj[aIndex].Mana > (gObj[aIndex].MaxMana+gObj[aIndex].AddMana)-1 ) gObj[aIndex].Mana = (gObj[aIndex].MaxMana+gObj[aIndex].AddMana);

  009b4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  009bb	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  009c2	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  009c9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009cf	f3 0f 2a 84 16
	10 01 00 00	 cvtsi2ss xmm0, DWORD PTR [esi+edx+272]
  009d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009de	f3 0f 58 84 0a
	d4 00 00 00	 addss	 xmm0, DWORD PTR [edx+ecx+212]
  009e7	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  009ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009f5	f3 0f 10 8c 01
	d0 00 00 00	 movss	 xmm1, DWORD PTR [ecx+eax+208]
  009fe	0f 2f c8	 comiss	 xmm1, xmm0
  00a01	76 41		 jbe	 SHORT $LN40@CGUseItemR
  00a03	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a0a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00a11	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a17	f3 0f 2a 84 0a
	10 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+272]
  00a20	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a26	f3 0f 58 84 01
	d4 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+212]
  00a2f	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00a36	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a3b	f3 0f 11 84 10
	d0 00 00 00	 movss	 DWORD PTR [eax+edx+208], xmm0
$LN40@CGUseItemR:

; 17212: 
; 17213: #ifdef NEW_FORSKYLAND2
; 17214: 			GCManaSend(gObj[aIndex].m_Index, (short)gObj[aIndex].Mana, 0xFF, 0, gObj[aIndex].BP);

  00a44	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a4b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a51	0f b7 94 01 e8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+232]
  00a59	52		 push	 edx
  00a5a	6a 00		 push	 0
  00a5c	68 ff 00 00 00	 push	 255			; 000000ffH
  00a61	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a68	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a6e	f3 0f 2c 94 01
	d0 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+208]
  00a77	0f b7 c2	 movzx	 eax, dx
  00a7a	50		 push	 eax
  00a7b	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00a82	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a88	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00a8b	50		 push	 eax
  00a8c	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  00a91	83 c4 14	 add	 esp, 20			; 00000014H

; 17215: #else
; 17216: 			GCManaSend(gObj[aIndex].m_Index, (short)gObj[aIndex].Mana, 0xFF, 0, 0);
; 17217: #endif
; 17218: 
; 17219: #ifdef ADD_EFFECT_POTION_20040401
; 17220: 			//GCSendEffectInfo( aIndex, EFFECT_POTION_MP );
; 17221: #endif
; 17222: 
; 17223: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )

  00a94	6a 01		 push	 1
  00a96	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00a99	50		 push	 eax
  00a9a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00aa1	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00aa7	51		 push	 ecx
  00aa8	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00aad	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ab0	85 c0		 test	 eax, eax
  00ab2	75 48		 jne	 SHORT $LN41@CGUseItemR

; 17224: 			{
; 17225: 				gObjInventoryItemSet(aIndex, pos, 0xFF);

  00ab4	68 ff 00 00 00	 push	 255			; 000000ffH
  00ab9	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00abc	50		 push	 eax
  00abd	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00ac0	51		 push	 ecx
  00ac1	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00ac6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17226: 				gObj[aIndex].pInventory[pos].Clear();

  00ac9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ad0	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00ad7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00add	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00ae4	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17227: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00ae9	6a 01		 push	 1
  00aeb	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  00aef	50		 push	 eax
  00af0	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00af3	51		 push	 ecx
  00af4	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00af9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@CGUseItemR:

; 17228: 			}
; 17229: 
; 17230: 		}

  00afc	e9 2b 0c 00 00	 jmp	 $LN96@CGUseItemR
$LN33@CGUseItemR:

; 17231: 
; 17232: #ifdef ADD_SHIELD_POINT_01_20060403
; 17233: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 38 ) ) //  
; 17234: 		{
; 17235: 			// CODEREVIEW_SHIELD : iAddShield , iAddLife 
; 17236: 			int iShieldGage = ( ( gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield ) * 5 / 100 );
; 17237: 			int iHPGage = ( ( gObj[aIndex].MaxLife+gObj[aIndex].AddLife ) * 10 / 100 );
; 17238: 
; 17239: 			if( gObj[aIndex].iShield < 0 )
; 17240: 			{
; 17241: 				gObj[aIndex].iShield = 0;
; 17242: 			}
; 17243: 
; 17244: 			if( gObj[aIndex].FillLife > 0 )
; 17245: 			{
; 17246: 				gObj[aIndex].Life = gObj[aIndex].Life + gObj[aIndex].FillLife;
; 17247: 				if( gObj[aIndex].Life > ( gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )
; 17248: 				{
; 17249: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;
; 17250: 				}
; 17251: 			}
; 17252: 
; 17253: 			// CODEREVIEW_SHIELD : Max  
; 17254: 			if( gObj[aIndex].iFillShield > 0 )
; 17255: 			{
; 17256: 				gObj[aIndex].iShield = gObj[aIndex].iShield + gObj[aIndex].iFillShield;
; 17257: 				if( gObj[aIndex].iShield > ( gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 17258: 				{
; 17259: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 17260: 				}
; 17261: 			}
; 17262: 
; 17263: 			gObj[aIndex].FillLife			= iHPGage;
; 17264: 			gObj[aIndex].FillLifeMax		= iHPGage;
; 17265: 			gObj[aIndex].FillLifeCount		= 4;
; 17266: 			gObj[aIndex].iFillShield		= iShieldGage;
; 17267: 			gObj[aIndex].iFillShieldMax		= iShieldGage;
; 17268: 			gObj[aIndex].iFillShieldCount	= 4;
; 17269: 
; 17270: 			//     ( )
; 17271: 			GCSendEffectInfo( aIndex, EFFECT_POTION_SD );
; 17272: 
; 17273: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )
; 17274: 			{
; 17275: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 17276: 				gObj[aIndex].pInventory[pos].Clear();
; 17277: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17278: 			}
; 17279: 			
; 17280: 	#ifdef EXTEND_LOG_SYSTEM_02_20060516
; 17281: 			LogAddTD("[%s][%s]Use Compound Potion Lv1 - SD[%d] HP[%f] -> SD[%d] HP[%f]",
; 17282: 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 17283: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 17284: 				gObj[aIndex].iShield+iShieldGage, gObj[aIndex].Life+iHPGage);
; 17285: 	#endif
; 17286: 		}
; 17287: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 39 ) ) //  
; 17288: 		{
; 17289: 			int iShieldGage = ( ( gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield ) * 10 / 100 );
; 17290: 			int iHPGage = ( ( gObj[aIndex].MaxLife+gObj[aIndex].AddLife ) * 25 / 100 );
; 17291: 
; 17292: 			if( gObj[aIndex].iShield < 0 )
; 17293: 			{
; 17294: 				gObj[aIndex].iShield = 0;
; 17295: 			}
; 17296: 
; 17297: 			if( gObj[aIndex].FillLife > 0 )
; 17298: 			{
; 17299: 				gObj[aIndex].Life = gObj[aIndex].Life + gObj[aIndex].FillLife;
; 17300: 				if( gObj[aIndex].Life > ( gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )
; 17301: 				{
; 17302: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;
; 17303: 				}
; 17304: 			}
; 17305: 
; 17306: 			if( gObj[aIndex].iFillShield > 0 )
; 17307: 			{
; 17308: 				gObj[aIndex].iShield = gObj[aIndex].iShield + gObj[aIndex].iFillShield;
; 17309: 				if( gObj[aIndex].iShield > ( gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 17310: 				{
; 17311: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 17312: 				}
; 17313: 			}
; 17314: 
; 17315: 			gObj[aIndex].FillLife = iHPGage;
; 17316: 			gObj[aIndex].FillLifeMax = iHPGage;
; 17317: 			gObj[aIndex].FillLifeCount = 4;
; 17318: 			gObj[aIndex].iFillShield = iShieldGage;
; 17319: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 17320: 			gObj[aIndex].iFillShieldCount = 4;
; 17321: 
; 17322: 			//     ( )
; 17323: 			GCSendEffectInfo( aIndex, EFFECT_POTION_SD );
; 17324: 			
; 17325: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )
; 17326: 			{
; 17327: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 17328: 				gObj[aIndex].pInventory[pos].Clear();
; 17329: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17330: 			}
; 17331: 	#ifdef EXTEND_LOG_SYSTEM_02_20060516
; 17332: 			LogAddTD("[%s][%s]Use Compound Potion Lv2 - SD[%d] HP[%f] -> SD[%d] HP[%f]",
; 17333: 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 17334: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 17335: 				gObj[aIndex].iShield+iShieldGage, gObj[aIndex].Life+iHPGage);
; 17336: 	#endif
; 17337: 		}
; 17338: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 40 ) ) //  
; 17339: 		{
; 17340: 			int iShieldGage = ( ( gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield ) * 20 / 100 );
; 17341: 			int iHPGage = ( ( gObj[aIndex].MaxLife+gObj[aIndex].AddLife ) * 45 / 100 );
; 17342: 
; 17343: 			if( gObj[aIndex].iShield < 0 )
; 17344: 			{
; 17345: 				gObj[aIndex].iShield = 0;
; 17346: 			}
; 17347: 
; 17348: 			if( gObj[aIndex].FillLife > 0 )
; 17349: 			{
; 17350: 				gObj[aIndex].Life = gObj[aIndex].Life + gObj[aIndex].FillLife;
; 17351: 				if( gObj[aIndex].Life > ( gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )
; 17352: 				{
; 17353: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;
; 17354: 				}
; 17355: 			}
; 17356: 
; 17357: 			if( gObj[aIndex].iFillShield > 0 )
; 17358: 			{
; 17359: 				gObj[aIndex].iShield = gObj[aIndex].iShield + gObj[aIndex].iFillShield;
; 17360: 				if( gObj[aIndex].iShield > ( gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 17361: 				{
; 17362: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 17363: 				}
; 17364: 			}
; 17365: 
; 17366: 			gObj[aIndex].FillLife = iHPGage;
; 17367: 			gObj[aIndex].FillLifeMax = iHPGage;
; 17368: 			gObj[aIndex].FillLifeCount = 4;
; 17369: 			gObj[aIndex].iFillShield = iShieldGage;
; 17370: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 17371: 			gObj[aIndex].iFillShieldCount = 4;
; 17372: 
; 17373: 
; 17374: 			//     ( )
; 17375: 			GCSendEffectInfo( aIndex, EFFECT_POTION_SD );
; 17376: 			
; 17377: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )
; 17378: 			{
; 17379: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 17380: 				gObj[aIndex].pInventory[pos].Clear();
; 17381: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17382: 			}
; 17383: 
; 17384: 	#ifdef EXTEND_LOG_SYSTEM_02_20060516
; 17385: 			LogAddTD("[%s][%s]Use Compound Potion Lv3 - SD[%d] HP[%f] -> SD[%d] HP[%f]",
; 17386: 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 17387: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 17388: 				gObj[aIndex].iShield+iShieldGage, gObj[aIndex].Life+iHPGage);
; 17389: 	#endif
; 17390: 
; 17391: 		}
; 17392: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 35 ) ) //  SD  
; 17393: 		{
; 17394: 			int iShieldGage = ( ( gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield ) * 25 / 100 );
; 17395: 
; 17396: 			if( gObj[aIndex].iShield < 0 )
; 17397: 			{
; 17398: 				gObj[aIndex].iShield = 0;
; 17399: 			}
; 17400: 
; 17401: 			if( gObj[aIndex].iFillShield > 0 )
; 17402: 			{
; 17403: 				gObj[aIndex].iShield = gObj[aIndex].iShield + gObj[aIndex].iFillShield;
; 17404: 				if( gObj[aIndex].iShield > ( gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 17405: 				{
; 17406: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 17407: 				}
; 17408: 			}
; 17409: 
; 17410: 			gObj[aIndex].iFillShieldCount = 2;
; 17411: 			gObj[aIndex].iFillShield = iShieldGage;
; 17412: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 17413: 
; 17414: 			//     ( )
; 17415: 			GCSendEffectInfo( aIndex, EFFECT_POTION_SD );
; 17416: 
; 17417: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )
; 17418: 			{
; 17419: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 17420: 				gObj[aIndex].pInventory[pos].Clear();
; 17421: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17422: 			}
; 17423: 		}
; 17424: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 36 ) ) //  SD 
; 17425: 		{
; 17426: 			int iShieldGage = ( ( gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield ) * 35 / 100 );
; 17427: 
; 17428: 			if( gObj[aIndex].iShield < 0 )
; 17429: 			{
; 17430: 				gObj[aIndex].iShield = 0;
; 17431: 			}
; 17432: 
; 17433: 			if( gObj[aIndex].iFillShield > 0 )
; 17434: 			{
; 17435: 				gObj[aIndex].iShield = gObj[aIndex].iShield + gObj[aIndex].iFillShield;
; 17436: 				if( gObj[aIndex].iShield > ( gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 17437: 				{
; 17438: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 17439: 				}
; 17440: 			}
; 17441: 
; 17442: 			gObj[aIndex].iFillShieldCount = 2;
; 17443: 			gObj[aIndex].iFillShield = iShieldGage;
; 17444: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 17445: 
; 17446: 			//     ( )
; 17447: 			GCSendEffectInfo( aIndex, EFFECT_POTION_SD );
; 17448: 
; 17449: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )
; 17450: 			{
; 17451: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 17452: 				gObj[aIndex].pInventory[pos].Clear();
; 17453: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17454: 			}
; 17455: 		}
; 17456: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 37 ) ) //  SD 
; 17457: 		{
; 17458: 			int iShieldGage = ( ( gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield ) * 45 / 100 );
; 17459: 
; 17460: 			if( gObj[aIndex].iShield < 0 )
; 17461: 			{
; 17462: 				gObj[aIndex].iShield = 0;
; 17463: 			}
; 17464: 
; 17465: 			if( gObj[aIndex].iFillShield > 0 )
; 17466: 			{
; 17467: 				gObj[aIndex].iShield = gObj[aIndex].iShield + gObj[aIndex].iFillShield;
; 17468: 				if( gObj[aIndex].iShield > ( gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 17469: 				{
; 17470: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 17471: 				}
; 17472: 			}
; 17473: 
; 17474: 			gObj[aIndex].iFillShieldCount = 2;
; 17475: 			gObj[aIndex].iFillShield = iShieldGage;
; 17476: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 17477: 
; 17478: 			//     ( )
; 17479: 			GCSendEffectInfo( aIndex, EFFECT_POTION_SD );
; 17480: 
; 17481: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )
; 17482: 			{
; 17483: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 17484: 				gObj[aIndex].pInventory[pos].Clear();
; 17485: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17486: 			}
; 17487: 		}
; 17488: #endif
; 17489: 		else if( citem->m_Type == MAKE_ITEMNUM(14,8) )	//  

  00b01	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00b04	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00b08	6a 08		 push	 8
  00b0a	6a 0e		 push	 14			; 0000000eH
  00b0c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00b11	83 c4 08	 add	 esp, 8
  00b14	3b f0		 cmp	 esi, eax
  00b16	0f 85 6b 01 00
	00		 jne	 $LN42@CGUseItemR

; 17490: 		{
; 17491: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )

  00b1c	6a 01		 push	 1
  00b1e	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00b21	50		 push	 eax
  00b22	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00b29	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b2f	51		 push	 ecx
  00b30	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00b35	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b38	85 c0		 test	 eax, eax
  00b3a	75 48		 jne	 SHORT $LN44@CGUseItemR

; 17492: 			{
; 17493: 				gObjInventoryItemSet(aIndex, pos, 0xFF);

  00b3c	68 ff 00 00 00	 push	 255			; 000000ffH
  00b41	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00b44	50		 push	 eax
  00b45	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00b48	51		 push	 ecx
  00b49	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00b4e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17494: 				gObj[aIndex].pInventory[pos].Clear();

  00b51	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b58	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00b5f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b65	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00b6c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17495: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00b71	6a 01		 push	 1
  00b73	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  00b77	50		 push	 eax
  00b78	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00b7b	51		 push	 ecx
  00b7c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00b81	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN44@CGUseItemR:

; 17496: 			}
; 17497: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17498: 			if( gObjCheckUsedBuffEffect( &gObj[aIndex], BUFFTYPE_POISON ) == true )
; 17499: 			{
; 17500: 				gObjRemoveBuffEffect( &gObj[aIndex], BUFFTYPE_POISON );
; 17501: 				gObj[aIndex].lpAttackObj = NULL;
; 17502: 				GCMagicCancelSend(&gObj[aIndex], AT_SKILL_POISON);
; 17503: 			}
; 17504: 			else if( gObjCheckUsedBuffEffect( &gObj[aIndex], BUFFTYPE_FREEZE ) == true )
; 17505: 			{
; 17506: 				gObjRemoveBuffEffect( &gObj[aIndex], BUFFTYPE_FREEZE );
; 17507: 				gObj[aIndex].DelayActionTime	= 0;
; 17508: 				gObj[aIndex].DelayLevel			= 0;
; 17509: 				gObj[aIndex].lpAttackObj		= NULL;
; 17510: 				GCMagicCancelSend(&gObj[aIndex], AT_SKILL_SLOW);
; 17511: 			}
; 17512: #else
; 17513: 			if( gObj[aIndex].m_PoisonBeattackCount ) 

  00b84	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b8b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b91	0f be 94 01 18
	1a 00 00	 movsx	 edx, BYTE PTR [ecx+eax+6680]
  00b99	85 d2		 test	 edx, edx
  00b9b	74 5a		 je	 SHORT $LN45@CGUseItemR

; 17514: 			{
; 17515: #ifdef ADD_SKILL_WITH_COMBO
; 17516: 				gObj[aIndex].m_PoisonType = 0;

  00b9d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ba4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00baa	c6 84 01 21 02
	00 00 00	 mov	 BYTE PTR [ecx+eax+545], 0

; 17517: #endif
; 17518: 				gObj[aIndex].m_PoisonBeattackCount	= 0;

  00bb2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00bb9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bbf	c6 84 01 18 1a
	00 00 00	 mov	 BYTE PTR [ecx+eax+6680], 0

; 17519: 				gObj[aIndex].lpAttackObj			= NULL;

  00bc7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00bce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bd4	c7 84 01 30 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+560], 0

; 17520: 				GCMagicCancelSend(&gObj[aIndex], AT_SKILL_POISON);

  00bdf	6a 01		 push	 1
  00be1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00be8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bee	50		 push	 eax
  00bef	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00bf4	83 c4 08	 add	 esp, 8
$LN45@CGUseItemR:

; 17521: 			}
; 17522: 			if( gObj[aIndex].m_ColdBeattackCount) 

  00bf7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00bfe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c04	0f be 94 01 19
	1a 00 00	 movsx	 edx, BYTE PTR [ecx+eax+6681]
  00c0c	85 d2		 test	 edx, edx
  00c0e	74 72		 je	 SHORT $LN46@CGUseItemR

; 17523: 			{
; 17524: 				gObj[aIndex].m_ColdBeattackCount= 0;

  00c10	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c17	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c1d	c6 84 01 19 1a
	00 00 00	 mov	 BYTE PTR [ecx+eax+6681], 0

; 17525: 				gObj[aIndex].DelayActionTime	= 0;

  00c25	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c2c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c32	c7 84 01 1c 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+540], 0

; 17526: 				gObj[aIndex].DelayLevel			= 0;

  00c3d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c4a	c6 84 01 20 02
	00 00 00	 mov	 BYTE PTR [ecx+eax+544], 0

; 17527: 				gObj[aIndex].lpAttackObj		= NULL;

  00c52	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c59	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c5f	c7 84 01 30 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+560], 0

; 17528: 				GCMagicCancelSend(&gObj[aIndex], AT_SKILL_SLOW);

  00c6a	6a 07		 push	 7
  00c6c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c73	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c79	50		 push	 eax
  00c7a	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00c7f	83 c4 08	 add	 esp, 8
$LN46@CGUseItemR:

; 17529: 			}
; 17530: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17531: 		}

  00c82	e9 a5 0a 00 00	 jmp	 $LN96@CGUseItemR
$LN42@CGUseItemR:

; 17532: 
; 17533: #ifdef ITEM_ADD_OPTION_20061019
; 17534: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 46 ) )		//     ( )
; 17535: 		{
; 17536: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )
; 17537: 			{
; 17538: 				gObjInventoryItemSet( aIndex, pos, 0xFF );
; 17539: 				gObj[aIndex].pInventory[pos].Clear();
; 17540: 				GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 17541: 			}
; 17542: 
; 17543: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17544: 			gObjAddBuffEffect( &gObj[aIndex], BUFFTYPE_HALLOWEEN_BLESS );
; 17545: #else
; 17546: 			g_ItemAddOption.SetItemEffect( &gObj[aIndex], MAKE_ITEMNUM( 14, 46 ) );
; 17547: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17548: #ifndef MODIFY_JOL_BLESS_POTION_USE_EFFECT_20061030
; 17549: #ifdef ADD_SHIELD_POINT_01_20060403
; 17550: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0, (WORD)(gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield));
; 17551: #else
; 17552: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0);
; 17553: #endif
; 17554: 			GCManaSend( aIndex, (short)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana), 0xFE, 0, gObj[aIndex].MaxBP+gObj[aIndex].AddBP);		
; 17555: #endif	
; 17556: 		}
; 17557: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 47 ) )		//     ( )
; 17558: 		{
; 17559: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )
; 17560: 			{
; 17561: 				gObjInventoryItemSet( aIndex, pos, 0xFF );
; 17562: 				gObj[aIndex].pInventory[pos].Clear();
; 17563: 				GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 17564: 			}
; 17565: 
; 17566: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17567: 			gObjAddBuffEffect( &gObj[aIndex], BUFFTYPE_HALLOWEEN_ANGER );
; 17568: #else
; 17569: 			g_ItemAddOption.SetItemEffect( &gObj[aIndex], MAKE_ITEMNUM( 14, 47 ) );
; 17570: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17571: #ifndef MODIFY_JOL_BLESS_POTION_USE_EFFECT_20061030
; 17572: #ifdef ADD_SHIELD_POINT_01_20060403
; 17573: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0, (WORD)(gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield));
; 17574: #else
; 17575: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0);
; 17576: #endif
; 17577: 			GCManaSend( aIndex, (short)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana), 0xFE, 0, gObj[aIndex].MaxBP+gObj[aIndex].AddBP);		
; 17578: #endif	
; 17579: 		}
; 17580: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 48 ) )		//     ( )
; 17581: 		{
; 17582: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )
; 17583: 			{
; 17584: 				gObjInventoryItemSet( aIndex, pos, 0xFF );
; 17585: 				gObj[aIndex].pInventory[pos].Clear();
; 17586: 				GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 17587: 			}
; 17588: 
; 17589: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17590: 			gObjAddBuffEffect( &gObj[aIndex], BUFFTYPE_HALLOWEEN_CRY );
; 17591: #else
; 17592: 			g_ItemAddOption.SetItemEffect( &gObj[aIndex], MAKE_ITEMNUM( 14, 48 ) );
; 17593: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17594: #ifndef MODIFY_JOL_BLESS_POTION_USE_EFFECT_20061030
; 17595: #ifdef ADD_SHIELD_POINT_01_20060403
; 17596: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0, (WORD)(gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield));
; 17597: #else
; 17598: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0);
; 17599: #endif
; 17600: 			GCManaSend( aIndex, (short)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana), 0xFE, 0, gObj[aIndex].MaxBP+gObj[aIndex].AddBP);		
; 17601: #endif	
; 17602: 		}
; 17603: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 49 ) )		//     ( HP)
; 17604: 		{
; 17605: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )
; 17606: 			{
; 17607: 				gObjInventoryItemSet( aIndex, pos, 0xFF );
; 17608: 				gObj[aIndex].pInventory[pos].Clear();
; 17609: 				GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 17610: 			}
; 17611: 
; 17612: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17613: 			gObjAddBuffEffect( &gObj[aIndex], BUFFTYPE_HALLOWEEN_FOOD );
; 17614: #else
; 17615: 			g_ItemAddOption.SetItemEffect( &gObj[aIndex], MAKE_ITEMNUM( 14, 49 ) );
; 17616: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17617: #ifndef MODIFY_JOL_BLESS_POTION_USE_EFFECT_20061030
; 17618: #ifdef ADD_SHIELD_POINT_01_20060403
; 17619: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0, (WORD)(gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield));
; 17620: #else
; 17621: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0);
; 17622: #endif
; 17623: 			GCManaSend( aIndex, (short)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana), 0xFE, 0, gObj[aIndex].MaxBP+gObj[aIndex].AddBP);		
; 17624: #endif	
; 17625: 		}
; 17626: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 50 ) )		//     ( MP)
; 17627: 		{
; 17628: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )
; 17629: 			{
; 17630: 				gObjInventoryItemSet( aIndex, pos, 0xFF );
; 17631: 				gObj[aIndex].pInventory[pos].Clear();
; 17632: 				GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 17633: 			}
; 17634: 
; 17635: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17636: 			gObjAddBuffEffect( &gObj[aIndex], BUFFTYPE_HALLOWEEN_DRINK );
; 17637: #else
; 17638: 			g_ItemAddOption.SetItemEffect( &gObj[aIndex], MAKE_ITEMNUM( 14, 50 ) );
; 17639: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 17640: #ifndef MODIFY_JOL_BLESS_POTION_USE_EFFECT_20061030
; 17641: #ifdef ADD_SHIELD_POINT_01_20060403
; 17642: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0, (WORD)(gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield));
; 17643: #else
; 17644: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0);
; 17645: #endif
; 17646: 			GCManaSend( aIndex, (short)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana), 0xFE, 0, gObj[aIndex].MaxBP+gObj[aIndex].AddBP);		
; 17647: #endif	
; 17648: 		}
; 17649: #endif // ITEM_ADD_OPTION_20061019
; 17650: 
; 17651: #ifdef ADD_PCS_FULL_RECOVERY_POTION_20070508
; 17652: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 63 )
; 17653: 			|| citem->m_Type == MAKE_ITEMNUM( 14, 64 )
; 17654: 			   )
; 17655: 		{
; 17656: 			// 1.     HP Mana 
; 17657: 			// 1-2.  HP  
; 17658: 			switch( citem->m_Type )
; 17659: 			{
; 17660: 			case MAKE_ITEMNUM2( 14, 63 ):
; 17661: 				gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;
; 17662: 				GCReFillSend( aIndex, (WORD)(gObj[aIndex].Life), 0xFF, 0, (WORD)(gObj[aIndex].iShield) );
; 17663: 				break;
; 17664: 			case MAKE_ITEMNUM2( 14, 64 ):
; 17665: 				gObj[aIndex].Mana = gObj[aIndex].MaxMana + gObj[aIndex].AddMana;
; 17666: 				GCManaSend( aIndex, (WORD)(gObj[aIndex].Mana), 0xFF, 0, gObj[aIndex].BP );
; 17667: 				break;
; 17668: 			}
; 17669: 
; 17670: 			// 3.    .
; 17671: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )
; 17672: 			{
; 17673: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 17674: 				gObj[aIndex].pInventory[pos].Clear();
; 17675: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17676: 			}
; 17677: 		}
; 17678: #endif // ADD_PCS_FULL_RECOVERY_POTION_20070508
; 17679: 
; 17680: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530	
; 17681: 		//   
; 17682: 		else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity(citem->m_Type) == TRUE		// ()  
; 17683: 	#ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_03_20080704
; 17684: 			&& ( g_SocketOptionSystem.IsSocketItem( &gObj[aIndex].pInventory[lpMsg->invenrotyTarget] ) == false )	//       
; 17685: 	#endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_03_20080704
; 17686: 			)
; 17687: 		{
; 17688: 			if ( g_kJewelOfHarmonySystem.StrengthenItemByJewelOfHarmony(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE ) 
; 17689: 			{
; 17690: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 17691: 				gObj[aIndex].pInventory[pos].Clear();
; 17692: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 17693: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17694: 			}
; 17695: 			else
; 17696: 			{
; 17697: 				// .      .
; 17698: 		#ifdef ADD_SHIELD_POINT_01_20060403
; 17699: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17700: 		#endif
; 17701: 			}
; 17702: 		}
; 17703: 		//    : / 
; 17704: 		else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonySmeltingItems(citem->m_Type) == TRUE ) // /   
; 17705: 		{
; 17706: 			if ( g_kJewelOfHarmonySystem.SmeltItemBySmeltingStone(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE ) 
; 17707: 			{
; 17708: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 17709: 				gObj[aIndex].pInventory[pos].Clear();
; 17710: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 17711: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 17712: 			}
; 17713: 			else
; 17714: 			{
; 17715: 				// .      .
; 17716: #ifdef ADD_SHIELD_POINT_01_20060403
; 17717: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17718: #endif
; 17719: 			}
; 17720: 		}
; 17721: #endif //ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 17722: 		else if( citem->m_Type == MAKE_ITEMNUM(14,13) )	// 

  00c87	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00c8a	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00c8e	6a 0d		 push	 13			; 0000000dH
  00c90	6a 0e		 push	 14			; 0000000eH
  00c92	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00c97	83 c4 08	 add	 esp, 8
  00c9a	3b f0		 cmp	 esi, eax
  00c9c	0f 85 8c 00 00
	00		 jne	 $LN47@CGUseItemR

; 17723: 		{
; 17724: 			if( gObjItemLevelUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  00ca2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00ca5	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00ca9	51		 push	 ecx
  00caa	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00cad	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00cb1	50		 push	 eax
  00cb2	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00cb9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00cbf	51		 push	 ecx
  00cc0	e8 00 00 00 00	 call	 ?gObjItemLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjItemLevelUp
  00cc5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cc8	83 f8 01	 cmp	 eax, 1
  00ccb	75 5c		 jne	 SHORT $LN49@CGUseItemR

; 17725: 			{
; 17726: 				gObjInventoryItemSet(aIndex, pos, 0xFF);

  00ccd	68 ff 00 00 00	 push	 255			; 000000ffH
  00cd2	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00cd5	50		 push	 eax
  00cd6	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00cd9	51		 push	 ecx
  00cda	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00cdf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17727: 				gObj[aIndex].pInventory[pos].Clear();

  00ce2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ce9	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00cf0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00cf6	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00cfd	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17728: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  00d02	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00d05	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00d09	51		 push	 ecx
  00d0a	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00d0d	52		 push	 edx
  00d0e	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  00d13	83 c4 08	 add	 esp, 8

; 17729: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00d16	6a 01		 push	 1
  00d18	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  00d1c	50		 push	 eax
  00d1d	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00d20	51		 push	 ecx
  00d21	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00d26	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN49@CGUseItemR:

; 17730: 			}			
; 17731: 		}

  00d29	e9 fe 09 00 00	 jmp	 $LN96@CGUseItemR
$LN47@CGUseItemR:

; 17732: 		else if( citem->m_Type == MAKE_ITEMNUM(14,14) )	// 

  00d2e	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00d31	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00d35	6a 0e		 push	 14			; 0000000eH
  00d37	6a 0e		 push	 14			; 0000000eH
  00d39	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00d3e	83 c4 08	 add	 esp, 8
  00d41	3b f0		 cmp	 esi, eax
  00d43	0f 85 8c 00 00
	00		 jne	 $LN50@CGUseItemR

; 17733: 		{			
; 17734: 			if( gObjItemRandomLevelUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  00d49	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00d4c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00d50	51		 push	 ecx
  00d51	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00d54	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00d58	50		 push	 eax
  00d59	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00d60	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d66	51		 push	 ecx
  00d67	e8 00 00 00 00	 call	 ?gObjItemRandomLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjItemRandomLevelUp
  00d6c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d6f	83 f8 01	 cmp	 eax, 1
  00d72	75 5c		 jne	 SHORT $LN52@CGUseItemR

; 17735: 			{
; 17736: 				gObjInventoryItemSet(aIndex, pos, 0xFF);

  00d74	68 ff 00 00 00	 push	 255			; 000000ffH
  00d79	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00d7c	50		 push	 eax
  00d7d	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00d80	51		 push	 ecx
  00d81	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00d86	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17737: 				gObj[aIndex].pInventory[pos].Clear();

  00d89	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00d90	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00d97	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d9d	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00da4	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17738: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  00da9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00dac	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00db0	51		 push	 ecx
  00db1	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00db4	52		 push	 edx
  00db5	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  00dba	83 c4 08	 add	 esp, 8

; 17739: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00dbd	6a 01		 push	 1
  00dbf	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  00dc3	50		 push	 eax
  00dc4	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00dc7	51		 push	 ecx
  00dc8	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00dcd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN52@CGUseItemR:

; 17740: 			}
; 17741: 		}

  00dd0	e9 57 09 00 00	 jmp	 $LN96@CGUseItemR
$LN50@CGUseItemR:

; 17742: 		else if( citem->m_Type == MAKE_ITEMNUM(14,16) )	//  

  00dd5	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00dd8	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00ddc	6a 10		 push	 16			; 00000010H
  00dde	6a 0e		 push	 14			; 0000000eH
  00de0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00de5	83 c4 08	 add	 esp, 8
  00de8	3b f0		 cmp	 esi, eax
  00dea	0f 85 bb 00 00
	00		 jne	 $LN53@CGUseItemR

; 17743: 		{	
; 17744: 			if( gObjItemRandomOption3Up(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  00df0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00df3	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00df7	51		 push	 ecx
  00df8	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00dfb	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00dff	50		 push	 eax
  00e00	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00e07	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e0d	51		 push	 ecx
  00e0e	e8 00 00 00 00	 call	 ?gObjItemRandomOption3Up@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjItemRandomOption3Up
  00e13	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e16	83 f8 01	 cmp	 eax, 1
  00e19	75 5e		 jne	 SHORT $LN55@CGUseItemR

; 17745: 			{
; 17746: 				gObjInventoryItemSet(aIndex, pos, 0xFF);

  00e1b	68 ff 00 00 00	 push	 255			; 000000ffH
  00e20	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00e23	50		 push	 eax
  00e24	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00e27	51		 push	 ecx
  00e28	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00e2d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17747: 				gObj[aIndex].pInventory[pos].Clear();

  00e30	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e37	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00e3e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e44	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00e4b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17748: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  00e50	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00e53	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00e57	51		 push	 ecx
  00e58	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00e5b	52		 push	 edx
  00e5c	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  00e61	83 c4 08	 add	 esp, 8

; 17749: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00e64	6a 01		 push	 1
  00e66	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  00e6a	50		 push	 eax
  00e6b	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00e6e	51		 push	 ecx
  00e6f	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00e74	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17750: 			}

  00e77	eb 2d		 jmp	 SHORT $LN56@CGUseItemR
$LN55@CGUseItemR:

; 17751: 			else 
; 17752: 			{
; 17753: #ifdef ADD_SHIELD_POINT_01_20060403
; 17754: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17755: #else
; 17756: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  00e79	6a 01		 push	 1
  00e7b	68 fd 00 00 00	 push	 253			; 000000fdH
  00e80	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e87	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e8d	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  00e96	0f b7 c2	 movzx	 eax, dx
  00e99	50		 push	 eax
  00e9a	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00e9d	51		 push	 ecx
  00e9e	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00ea3	83 c4 10	 add	 esp, 16			; 00000010H
$LN56@CGUseItemR:

; 17757: #endif
; 17758: 			}
; 17759: 		}

  00ea6	e9 81 08 00 00	 jmp	 $LN96@CGUseItemR
$LN53@CGUseItemR:

; 17760: 		else if( (citem->m_Type >= MAKE_ITEMNUM(15,0)) ||  //   
; 17761:                  (citem->m_Type == MAKE_ITEMNUM(12,7)) ||  //    

  00eab	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00eae	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00eb2	6a 00		 push	 0
  00eb4	6a 0f		 push	 15			; 0000000fH
  00eb6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00ebb	83 c4 08	 add	 esp, 8
  00ebe	3b f0		 cmp	 esi, eax
  00ec0	7d 4d		 jge	 SHORT $LN59@CGUseItemR
  00ec2	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00ec5	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00ec9	6a 07		 push	 7
  00ecb	6a 0c		 push	 12			; 0000000cH
  00ecd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00ed2	83 c4 08	 add	 esp, 8
  00ed5	3b f0		 cmp	 esi, eax
  00ed7	74 36		 je	 SHORT $LN59@CGUseItemR
  00ed9	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00edc	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00ee0	6a 08		 push	 8
  00ee2	6a 0c		 push	 12			; 0000000cH
  00ee4	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00ee9	83 c4 08	 add	 esp, 8
  00eec	3b f0		 cmp	 esi, eax
  00eee	0f 8c 72 02 00
	00		 jl	 $LN57@CGUseItemR
  00ef4	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00ef7	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00efb	6a 18		 push	 24			; 00000018H
  00efd	6a 0c		 push	 12			; 0000000cH
  00eff	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00f04	83 c4 08	 add	 esp, 8
  00f07	3b f0		 cmp	 esi, eax
  00f09	0f 8f 57 02 00
	00		 jg	 $LN57@CGUseItemR
$LN59@CGUseItemR:

; 17762: 
; 17763: #ifdef ADD_SKILL_DARKLOAD_FIRESCREAM_20060601	//    
; 17764: 				 ( (citem->m_Type >= MAKE_ITEMNUM(12,8) ) && (citem->m_Type <= MAKE_ITEMNUM(12,24)) )
; 17765: 				|| ( citem->m_Type == MAKE_ITEMNUM( 12, 35 ) )	//  
; 17766: #else	// #ifdef ADD_SKILL_DARKLOAD_FIRESCREAM_20060601
; 17767: 	#ifdef DARKLORD_WORK
; 17768: 					 ( (citem->m_Type >= MAKE_ITEMNUM(12,8) ) && (citem->m_Type <= MAKE_ITEMNUM(12,24)) )
; 17769: 	#else
; 17770: 					 ( (citem->m_Type >= MAKE_ITEMNUM(12,8) ) && (citem->m_Type <= MAKE_ITEMNUM(12,21)) )
; 17771: 	#endif  // #ifdef DARKLORD_WORK
; 17772: #endif	// #ifdef ADD_SKILL_DARKLOAD_FIRESCREAM_20060601
; 17773: #ifdef ADD_SEASON4_NEW_SKILL_20080522	//   
; 17774: 					 || ( citem->m_Type == MAKE_ITEMNUM( 12, 44 ) )	//   
; 17775: 					 || ( citem->m_Type == MAKE_ITEMNUM( 12, 45 ) )	//  
; 17776: 					 || ( citem->m_Type == MAKE_ITEMNUM( 12, 46 ) )	//  
; 17777: 					 || ( citem->m_Type == MAKE_ITEMNUM( 12, 47 ) )	//   
; 17778: 					 || ( citem->m_Type == MAKE_ITEMNUM( 12, 48 ) )	//   
; 17779: #endif	// ADD_SEASON4_NEW_SKILL_20080522
; 17780: 				 )	//   
; 17781: 		{
; 17782: #ifdef NEW_FORSKYLAND2
; 17783: 			if( gObj[aIndex].Strength+gObj[aIndex].AddStrength < citem->m_RequireStrength )

  00f0f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f16	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f1c	0f b7 94 01 b4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+180]
  00f24	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f2b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f31	0f b7 84 01 e0
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+224]
  00f39	03 d0		 add	 edx, eax
  00f3b	8b 4d f8	 mov	 ecx, DWORD PTR _citem$[ebp]
  00f3e	0f b7 41 42	 movzx	 eax, WORD PTR [ecx+66]
  00f42	3b d0		 cmp	 edx, eax
  00f44	7d 32		 jge	 SHORT $LN60@CGUseItemR

; 17784: 			{	// 
; 17785: #ifdef ADD_SHIELD_POINT_01_20060403
; 17786: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17787: #else
; 17788: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  00f46	6a 01		 push	 1
  00f48	68 fd 00 00 00	 push	 253			; 000000fdH
  00f4d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f54	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f5a	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  00f63	0f b7 c2	 movzx	 eax, dx
  00f66	50		 push	 eax
  00f67	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00f6a	51		 push	 ecx
  00f6b	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00f70	83 c4 10	 add	 esp, 16			; 00000010H

; 17789: #endif
; 17790: 				return;

  00f73	e9 18 08 00 00	 jmp	 $LN1@CGUseItemR
$LN60@CGUseItemR:

; 17791: 			}	
; 17792: 
; 17793: 			if( gObj[aIndex].Dexterity+gObj[aIndex].AddDexterity < citem->m_RequireDexterity )

  00f78	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f7f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f85	0f b7 94 01 b6
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+182]
  00f8d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f94	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f9a	0f b7 84 01 e2
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+226]
  00fa2	03 d0		 add	 edx, eax
  00fa4	8b 4d f8	 mov	 ecx, DWORD PTR _citem$[ebp]
  00fa7	0f b7 41 44	 movzx	 eax, WORD PTR [ecx+68]
  00fab	3b d0		 cmp	 edx, eax
  00fad	7d 32		 jge	 SHORT $LN61@CGUseItemR

; 17794: 			{	// 
; 17795: #ifdef ADD_SHIELD_POINT_01_20060403
; 17796: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17797: #else
; 17798: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  00faf	6a 01		 push	 1
  00fb1	68 fd 00 00 00	 push	 253			; 000000fdH
  00fb6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00fbd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00fc3	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  00fcc	0f b7 c2	 movzx	 eax, dx
  00fcf	50		 push	 eax
  00fd0	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00fd3	51		 push	 ecx
  00fd4	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00fd9	83 c4 10	 add	 esp, 16			; 00000010H

; 17799: #endif
; 17800: 				return;

  00fdc	e9 af 07 00 00	 jmp	 $LN1@CGUseItemR
$LN61@CGUseItemR:

; 17801: 			}	
; 17802: #endif
; 17803: 
; 17804: #ifdef ADD_SKILL_WITH_COMBO
; 17805: 			if( citem->m_Type == MAKE_ITEMNUM(15,18) )

  00fe1	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  00fe4	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00fe8	6a 12		 push	 18			; 00000012H
  00fea	6a 0f		 push	 15			; 0000000fH
  00fec	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00ff1	83 c4 08	 add	 esp, 8
  00ff4	3b f0		 cmp	 esi, eax
  00ff6	75 51		 jne	 SHORT $LN63@CGUseItemR

; 17806: 			{	//   3     
; 17807: 				if( g_QuestInfo.GetQuestState(&gObj[aIndex], 2) != QS_CLEAR )

  00ff8	6a 02		 push	 2
  00ffa	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01001	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01007	50		 push	 eax
  01008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0100d	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  01012	83 f8 02	 cmp	 eax, 2
  01015	74 32		 je	 SHORT $LN63@CGUseItemR

; 17808: 				{
; 17809: #ifdef ADD_SHIELD_POINT_01_20060403
; 17810: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17811: #else
; 17812: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  01017	6a 01		 push	 1
  01019	68 fd 00 00 00	 push	 253			; 000000fdH
  0101e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0102b	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  01034	0f b7 c2	 movzx	 eax, dx
  01037	50		 push	 eax
  01038	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0103b	51		 push	 ecx
  0103c	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  01041	83 c4 10	 add	 esp, 16			; 00000010H

; 17813: #endif
; 17814: 					return;

  01044	e9 47 07 00 00	 jmp	 $LN1@CGUseItemR
$LN63@CGUseItemR:

; 17815: 				}
; 17816: 			}
; 17817: #endif
; 17818: 
; 17819: #ifdef ADD_CHECKING_LEVEL_TO_LEARN_MAGIC_20041115
; 17820: 			//  
; 17821: 			if( (citem->m_Type >= MAKE_ITEMNUM(12,8) ) && (citem->m_Type <= MAKE_ITEMNUM(12,24) ) )
; 17822: 			{
; 17823: 				if( gObj[aIndex].Level < citem->m_RequireLevel )
; 17824: 				{
; 17825: #ifdef ADD_SHIELD_POINT_01_20060403
; 17826: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 17827: #else
; 17828: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);
; 17829: #endif
; 17830: 					return;
; 17831: 				}
; 17832: 			}
; 17833: #endif
; 17834: 
; 17835: 			BYTE skillnumber;
; 17836: 			//  ... ()
; 17837: #ifdef ADD_THIRD_WING_20070525	// IsClass 
; 17838: 			if( citem->IsClass( gObj[aIndex].Class, gObj[aIndex].ChangeUP, gObj[aIndex].ThirdChangeUp ) == FALSE ) 
; 17839: #else
; 17840: #ifdef NEW_SKILL_FORSKYLAND
; 17841: 			if( citem->IsClass(gObj[aIndex].Class, gObj[aIndex].ChangeUP) == FALSE ) 

  01049	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01056	0f b6 94 01 9f
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+159]
  0105e	52		 push	 edx
  0105f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0106c	0f b6 94 01 9c
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+156]
  01074	52		 push	 edx
  01075	8b 4d f8	 mov	 ecx, DWORD PTR _citem$[ebp]
  01078	e8 00 00 00 00	 call	 ?IsClass@CItem@@QAEHDH@Z ; CItem::IsClass
  0107d	85 c0		 test	 eax, eax
  0107f	75 18		 jne	 SHORT $LN64@CGUseItemR

; 17842: #else
; 17843: 			if( citem->IsClass(gObj[aIndex].Class) == FALSE ) 
; 17844: #endif
; 17845: #endif	// ADD_THIRD_WING_20070525
; 17846: 			{
; 17847: 				GCInventoryItemDeleteSend(aIndex, 0xFF, 1);

  01081	6a 01		 push	 1
  01083	68 ff 00 00 00	 push	 255			; 000000ffH
  01088	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0108b	50		 push	 eax
  0108c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17848: 			}

  01094	e9 c8 00 00 00	 jmp	 $LN67@CGUseItemR
$LN64@CGUseItemR:

; 17849: 			else
; 17850: 			{				
; 17851: 				int addskill = gObjMagicAdd(&gObj[aIndex], (citem->m_Type>>ITEM_BITSHIFT), (citem->m_Type%MAX_ITEM_INDEX), (BYTE)citem->m_Level, skillnumber);

  01099	8d 45 eb	 lea	 eax, DWORD PTR _skillnumber$3[ebp]
  0109c	50		 push	 eax
  0109d	8b 4d f8	 mov	 ecx, DWORD PTR _citem$[ebp]
  010a0	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  010a4	52		 push	 edx
  010a5	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  010a8	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  010ac	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  010b2	79 05		 jns	 SHORT $LN115@CGUseItemR
  010b4	49		 dec	 ecx
  010b5	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  010b8	41		 inc	 ecx
$LN115@CGUseItemR:
  010b9	51		 push	 ecx
  010ba	8b 55 f8	 mov	 edx, DWORD PTR _citem$[ebp]
  010bd	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  010c1	c1 f8 05	 sar	 eax, 5
  010c4	50		 push	 eax
  010c5	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  010cc	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  010d2	51		 push	 ecx
  010d3	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z ; gObjMagicAdd
  010d8	83 c4 14	 add	 esp, 20			; 00000014H
  010db	89 45 e4	 mov	 DWORD PTR _addskill$2[ebp], eax

; 17852: 				if( addskill >= 0 )

  010de	83 7d e4 00	 cmp	 DWORD PTR _addskill$2[ebp], 0
  010e2	7c 6a		 jl	 SHORT $LN66@CGUseItemR

; 17853: 				{
; 17854: 					gObjInventoryItemSet(aIndex, pos, 0xFF);

  010e4	68 ff 00 00 00	 push	 255			; 000000ffH
  010e9	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  010ec	50		 push	 eax
  010ed	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  010f0	51		 push	 ecx
  010f1	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  010f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17855: 					GCMagicListOneSend(aIndex, addskill, skillnumber, (BYTE)citem->m_Level, 0);

  010f9	6a 00		 push	 0
  010fb	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  010fe	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  01102	51		 push	 ecx
  01103	0f b6 55 eb	 movzx	 edx, BYTE PTR _skillnumber$3[ebp]
  01107	52		 push	 edx
  01108	0f b6 45 e4	 movzx	 eax, BYTE PTR _addskill$2[ebp]
  0110c	50		 push	 eax
  0110d	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01110	51		 push	 ecx
  01111	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDEEE@Z ; GCMagicListOneSend
  01116	83 c4 14	 add	 esp, 20			; 00000014H

; 17856: 					gObj[aIndex].pInventory[pos].Clear();

  01119	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01120	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  01127	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0112d	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  01134	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17857: 					GCInventoryItemDeleteSend(aIndex, pos, 1);

  01139	6a 01		 push	 1
  0113b	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  0113f	50		 push	 eax
  01140	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01143	51		 push	 ecx
  01144	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01149	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17858: 				}

  0114c	eb 13		 jmp	 SHORT $LN67@CGUseItemR
$LN66@CGUseItemR:

; 17859: 				else {
; 17860: 					// ..
; 17861: 					GCInventoryItemDeleteSend(aIndex, 0xFF, 1);

  0114e	6a 01		 push	 1
  01150	68 ff 00 00 00	 push	 255			; 000000ffH
  01155	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01158	50		 push	 eax
  01159	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0115e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN67@CGUseItemR:

; 17862: 				}
; 17863: 			}
; 17864: 		}

  01161	e9 c6 05 00 00	 jmp	 $LN96@CGUseItemR
$LN57@CGUseItemR:

; 17865: 		else if( citem->m_Type == MAKE_ITEMNUM(14,10) )	//   

  01166	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  01169	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0116d	6a 0a		 push	 10			; 0000000aH
  0116f	6a 0e		 push	 14			; 0000000eH
  01171	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01176	83 c4 08	 add	 esp, 8
  01179	3b f0		 cmp	 esi, eax
  0117b	0f 85 13 04 00
	00		 jne	 $LN68@CGUseItemR

; 17866: 		{
; 17867: 
; 17868: 			LogAddTD( "[Using Item] [Return Scroll] [%s][%s] - Current Map:[%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].MapNumber );

  01181	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0118e	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  01196	52		 push	 edx
  01197	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0119e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  011a4	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  011a8	52		 push	 edx
  011a9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  011b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  011b6	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  011ba	52		 push	 edx
  011bb	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CF@
  011c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  011c6	83 c4 10	 add	 esp, 16			; 00000010H

; 17869: 
; 17870: #ifdef FOR_BLOODCASTLE
; 17871: 			if (CHECK_BLOODCASTLE(gObj[aIndex].MapNumber))	//    =>     .

  011c9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  011d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  011d6	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  011de	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  011e1	7d 09		 jge	 SHORT $LN100@CGUseItemR
  011e3	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv937[ebp], 0
  011ea	eb 30		 jmp	 SHORT $LN101@CGUseItemR
$LN100@CGUseItemR:
  011ec	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  011f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  011f9	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  01201	83 fa 11	 cmp	 edx, 17			; 00000011H
  01204	7e 09		 jle	 SHORT $LN98@CGUseItemR
  01206	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv936[ebp], 0
  0120d	eb 07		 jmp	 SHORT $LN99@CGUseItemR
$LN98@CGUseItemR:
  0120f	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv936[ebp], 1
$LN99@CGUseItemR:
  01216	8b 45 98	 mov	 eax, DWORD PTR tv936[ebp]
  01219	89 45 9c	 mov	 DWORD PTR tv937[ebp], eax
$LN101@CGUseItemR:
  0121c	83 7d 9c 00	 cmp	 DWORD PTR tv937[ebp], 0
  01220	74 46		 je	 SHORT $LN72@CGUseItemR

; 17872: 			{
; 17873: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 17874: 				int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( gObj[aIndex].MapNumber );
; 17875: 				if (g_BloodCastle.GetCurrentState( iBridgeIndex ) == BLOODCASTLE_STATE_PLAYING) {
; 17876: #else
; 17877: 				if (g_BloodCastle.GetCurrentState(gObj[aIndex].MapNumber - MAP_INDEX_BLOODCASTLE1) == BLOODCASTLE_STATE_PLAYING) {

  01222	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0122f	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  01237	83 ea 0b	 sub	 edx, 11			; 0000000bH
  0123a	52		 push	 edx
  0123b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01240	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  01245	83 f8 02	 cmp	 eax, 2
  01248	75 10		 jne	 SHORT $LN71@CGUseItemR

; 17878: #endif
; 17879: 					//      .
; 17880: 					g_BloodCastle.SearchUserDropQuestItem(aIndex);

  0124a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0124d	50		 push	 eax
  0124e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01253	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem

; 17881: 				}

  01258	eb 0e		 jmp	 SHORT $LN72@CGUseItemR
$LN71@CGUseItemR:

; 17882: 				else {
; 17883: 					//       .
; 17884: 					g_BloodCastle.SearchUserDeleteQuestItem(aIndex);

  0125a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0125d	50		 push	 eax
  0125e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01263	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN72@CGUseItemR:

; 17885: 				}
; 17886: 			}
; 17887: #endif
; 17888: 
; 17889: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		//      
; 17890: 			if(CHECK_ILLUSION_TEMPLE(gObj[aIndex].MapNumber))
; 17891: 			{
; 17892: 				g_IllusionTempleEvent.DropRelicsItem(gObj[aIndex].MapNumber, aIndex);
; 17893: 			}
; 17894: #endif
; 17895: 
; 17896: 			if( gObj[aIndex].m_IfState.use ) 

  01268	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0126f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01275	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0127c	80 e2 03	 and	 dl, 3
  0127f	0f b6 c2	 movzx	 eax, dl
  01282	85 c0		 test	 eax, eax
  01284	0f 84 90 00 00
	00		 je	 $LN74@CGUseItemR

; 17897: 			{
; 17898: 				if( gObj[aIndex].m_IfState.type == I_SHOP )	//  ..

  0128a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01291	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01297	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0129e	c0 ea 04	 shr	 dl, 4
  012a1	80 e2 0f	 and	 dl, 15			; 0000000fH
  012a4	0f b6 c2	 movzx	 eax, dl
  012a7	83 f8 03	 cmp	 eax, 3
  012aa	75 6e		 jne	 SHORT $LN74@CGUseItemR

; 17899: 				{
; 17900: 					gObj[aIndex].TargetShopNumber = -1;		//  .

  012ac	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  012b3	83 c9 ff	 or	 ecx, -1
  012b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  012bc	66 89 8c 02 ae
	02 00 00	 mov	 WORD PTR [edx+eax+686], cx

; 17901: 					gObj[aIndex].m_IfState.type   = 0;

  012c4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  012cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  012d1	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  012d8	80 e2 0f	 and	 dl, 15			; 0000000fH
  012db	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  012e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  012e8	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 17902: 					gObj[aIndex].m_IfState.use    = 0;

  012ef	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  012f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  012fc	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  01303	80 e2 fc	 and	 dl, 252			; 000000fcH
  01306	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0130d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01313	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl
$LN74@CGUseItemR:

; 17903: 				}
; 17904: 			}
; 17905: 
; 17906: 
; 17907: 
; 17908: 			gObjInventoryItemSet(aIndex, pos, 0xFF);

  0131a	68 ff 00 00 00	 push	 255			; 000000ffH
  0131f	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  01322	50		 push	 eax
  01323	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01326	51		 push	 ecx
  01327	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  0132c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17909: 			gObj[aIndex].pInventory[pos].Clear();

  0132f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01336	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  0133d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01343	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0134a	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17910: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  0134f	6a 01		 push	 1
  01351	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  01355	50		 push	 eax
  01356	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01359	51		 push	 ecx
  0135a	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0135f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17911: 
; 17912: 
; 17913: 			
; 17914: 			if( gObj[aIndex].MapNumber == 2 )		//    ..

  01362	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01369	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0136f	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  01377	83 fa 02	 cmp	 edx, 2
  0137a	75 13		 jne	 SHORT $LN75@CGUseItemR

; 17915: 			{
; 17916: 				gObjMoveGate(aIndex, 22);

  0137c	6a 16		 push	 22			; 00000016H
  0137e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01381	50		 push	 eax
  01382	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  01387	83 c4 08	 add	 esp, 8

; 17917: 			}

  0138a	e9 00 02 00 00	 jmp	 $LN90@CGUseItemR
$LN75@CGUseItemR:

; 17918: 			else if( gObj[aIndex].MapNumber == 3 )	//    

  0138f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01396	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0139c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  013a4	83 fa 03	 cmp	 edx, 3
  013a7	75 13		 jne	 SHORT $LN77@CGUseItemR

; 17919: 			{
; 17920: 				gObjMoveGate(aIndex, 27);

  013a9	6a 1b		 push	 27			; 0000001bH
  013ab	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  013ae	50		 push	 eax
  013af	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  013b4	83 c4 08	 add	 esp, 8

; 17921: 			}

  013b7	e9 d3 01 00 00	 jmp	 $LN90@CGUseItemR
$LN77@CGUseItemR:

; 17922: 			else if( gObj[aIndex].MapNumber == 4 )	// 1  

  013bc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  013c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  013c9	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  013d1	83 fa 04	 cmp	 edx, 4
  013d4	75 13		 jne	 SHORT $LN79@CGUseItemR

; 17923: 			{
; 17924: 				gObjMoveGate(aIndex, 42);

  013d6	6a 2a		 push	 42			; 0000002aH
  013d8	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  013db	50		 push	 eax
  013dc	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  013e1	83 c4 08	 add	 esp, 8

; 17925: 			}

  013e4	e9 a6 01 00 00	 jmp	 $LN90@CGUseItemR
$LN79@CGUseItemR:

; 17926: 			else if( gObj[aIndex].MapNumber == 7 )	//   

  013e9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  013f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  013f6	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  013fe	83 fa 07	 cmp	 edx, 7
  01401	75 13		 jne	 SHORT $LN81@CGUseItemR

; 17927: 			{
; 17928: 				gObjMoveGate(aIndex, 49);

  01403	6a 31		 push	 49			; 00000031H
  01405	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01408	50		 push	 eax
  01409	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0140e	83 c4 08	 add	 esp, 8

; 17929: 			}

  01411	e9 79 01 00 00	 jmp	 $LN90@CGUseItemR
$LN81@CGUseItemR:

; 17930: 			else if( gObj[aIndex].MapNumber == 8 )	//   

  01416	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0141d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01423	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0142b	83 fa 08	 cmp	 edx, 8
  0142e	75 13		 jne	 SHORT $LN83@CGUseItemR

; 17931: 			{
; 17932: 				gObjMoveGate(aIndex, 57);

  01430	6a 39		 push	 57			; 00000039H
  01432	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01435	50		 push	 eax
  01436	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0143b	83 c4 08	 add	 esp, 8

; 17933: 			}

  0143e	e9 4c 01 00 00	 jmp	 $LN90@CGUseItemR
$LN83@CGUseItemR:

; 17934: #ifdef FOR_BLOODCASTLE
; 17935: 			else if(CHECK_BLOODCASTLE(gObj[aIndex].MapNumber))	//    

  01443	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0144a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01450	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  01458	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0145b	7d 09		 jge	 SHORT $LN104@CGUseItemR
  0145d	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv1046[ebp], 0
  01464	eb 30		 jmp	 SHORT $LN105@CGUseItemR
$LN104@CGUseItemR:
  01466	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0146d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01473	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0147b	83 fa 11	 cmp	 edx, 17			; 00000011H
  0147e	7e 09		 jle	 SHORT $LN102@CGUseItemR
  01480	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv1045[ebp], 0
  01487	eb 07		 jmp	 SHORT $LN103@CGUseItemR
$LN102@CGUseItemR:
  01489	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv1045[ebp], 1
$LN103@CGUseItemR:
  01490	8b 45 98	 mov	 eax, DWORD PTR tv1045[ebp]
  01493	89 45 9c	 mov	 DWORD PTR tv1046[ebp], eax
$LN105@CGUseItemR:
  01496	83 7d 9c 00	 cmp	 DWORD PTR tv1046[ebp], 0
  0149a	74 13		 je	 SHORT $LN85@CGUseItemR

; 17936: 			{
; 17937: 				gObjMoveGate(aIndex, 22);

  0149c	6a 16		 push	 22			; 00000016H
  0149e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  014a1	50		 push	 eax
  014a2	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  014a7	83 c4 08	 add	 esp, 8

; 17938: 			}

  014aa	e9 e0 00 00 00	 jmp	 $LN90@CGUseItemR
$LN85@CGUseItemR:

; 17939: #endif
; 17940: #ifdef CHAOSCASTLE_SYSTEM_20040408
; 17941: 			else if(CHECK_CHAOSCASTLE(gObj[aIndex].MapNumber))	//    

  014af	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  014b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  014bc	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  014c4	83 fa 12	 cmp	 edx, 18			; 00000012H
  014c7	7d 09		 jge	 SHORT $LN108@CGUseItemR
  014c9	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv1061[ebp], 0
  014d0	eb 30		 jmp	 SHORT $LN109@CGUseItemR
$LN108@CGUseItemR:
  014d2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  014d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  014df	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  014e7	83 fa 17	 cmp	 edx, 23			; 00000017H
  014ea	7e 09		 jle	 SHORT $LN106@CGUseItemR
  014ec	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv1060[ebp], 0
  014f3	eb 07		 jmp	 SHORT $LN107@CGUseItemR
$LN106@CGUseItemR:
  014f5	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv1060[ebp], 1
$LN107@CGUseItemR:
  014fc	8b 45 98	 mov	 eax, DWORD PTR tv1060[ebp]
  014ff	89 45 9c	 mov	 DWORD PTR tv1061[ebp], eax
$LN109@CGUseItemR:
  01502	83 7d 9c 00	 cmp	 DWORD PTR tv1061[ebp], 0
  01506	74 10		 je	 SHORT $LN87@CGUseItemR

; 17942: 			{
; 17943: 				gObjMoveGate(aIndex, 22);

  01508	6a 16		 push	 22			; 00000016H
  0150a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0150d	50		 push	 eax
  0150e	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  01513	83 c4 08	 add	 esp, 8

; 17944: 			}

  01516	eb 77		 jmp	 SHORT $LN90@CGUseItemR
$LN87@CGUseItemR:

; 17945: #endif
; 17946: #ifdef ADD_NEW_MAP_KALIMA_20040518
; 17947: 			else if(CHECK_KALIMAMAP(gObj[aIndex].MapNumber))	//   

  01518	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0151f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01525	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0152d	83 fa 18	 cmp	 edx, 24			; 00000018H
  01530	7d 09		 jge	 SHORT $LN112@CGUseItemR
  01532	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv1076[ebp], 0
  01539	eb 30		 jmp	 SHORT $LN113@CGUseItemR
$LN112@CGUseItemR:
  0153b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01542	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01548	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  01550	83 fa 1d	 cmp	 edx, 29			; 0000001dH
  01553	7e 09		 jle	 SHORT $LN110@CGUseItemR
  01555	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv1075[ebp], 0
  0155c	eb 07		 jmp	 SHORT $LN111@CGUseItemR
$LN110@CGUseItemR:
  0155e	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv1075[ebp], 1
$LN111@CGUseItemR:
  01565	8b 45 98	 mov	 eax, DWORD PTR tv1075[ebp]
  01568	89 45 9c	 mov	 DWORD PTR tv1076[ebp], eax
$LN113@CGUseItemR:
  0156b	83 7d 9c 00	 cmp	 DWORD PTR tv1076[ebp], 0
  0156f	74 10		 je	 SHORT $LN89@CGUseItemR

; 17948: 			{
; 17949: 				gObjMoveGate(aIndex, 22);

  01571	6a 16		 push	 22			; 00000016H
  01573	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01576	50		 push	 eax
  01577	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0157c	83 c4 08	 add	 esp, 8

; 17950: 			}

  0157f	eb 0e		 jmp	 SHORT $LN90@CGUseItemR
$LN89@CGUseItemR:

; 17951: #endif
; 17952: #ifdef ADD_NEW_MAP_AIDA_20050617
; 17953: 			else if( gObj[aIndex].MapNumber == MAP_INDEX_AIDA )
; 17954: 			{
; 17955: 				gObjMoveGate(aIndex, 27);						//   
; 17956: 			}
; 17957: #endif
; 17958: #ifdef ADD_NEW_MAP_CRYWOLF_FIRSTZONE_20050414
; 17959: 			else if( gObj[aIndex].MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE )
; 17960: 			{
; 17961: 				gObjMoveGate(aIndex, 27);						//  1  
; 17962: 			}
; 17963: #endif
; 17964: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912				//   
; 17965: 			else if( gObj[aIndex].MapNumber == MAP_INDEX_ELBELAND )
; 17966: 			{
; 17967: 				gObjMoveGate(aIndex, 267);
; 17968: 			}
; 17969: #endif		
; 17970: #ifdef UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108					//   
; 17971: 			else if( gObj[aIndex].MapNumber == MAP_INDEX_SWAMP_OF_CALMNESS )	
; 17972: 			{
; 17973: 				gObjMoveGate(aIndex, 273);
; 17974: 			}
; 17975: #endif				
; 17976: #ifdef ADD_RAKLION_20080408										//   
; 17977: 			else if( gObj[aIndex].MapNumber == MAP_INDEX_RAKLION_FIELD )	
; 17978: 			{
; 17979: 				gObjMoveGate(aIndex, 286);
; 17980: 			}
; 17981: #endif // ADD_RAKLION_20080408
; 17982: #ifdef ADD_NEWPVP_PKFIELD										//    
; 17983: 			else if( g_NewPVP.IsVulcanusMap(gObj[aIndex].MapNumber) )
; 17984: 			{
; 17985: #ifdef FOR_JAPAN
; 17986: 				gObjMoveGate(aIndex, LORENCIA_DEFAULT_REGEN_MAP_GATE);
; 17987: #else // FOR_JAPAN
; 17988: 				gObjMoveGate(aIndex, NEWPVP_DEFAULT_REGEN_MAP_GATE);
; 17989: #endif // FOR_JAPAN
; 17990: 			}
; 17991: 			else if( g_NewPVP.IsPKFieldMap(gObj[aIndex].MapNumber) )
; 17992: 			{
; 17993: 				g_NewPVP.Reset(gObj[aIndex]);
; 17994: #ifdef FOR_JAPAN
; 17995: 				gObjMoveGate(aIndex, LORENCIA_DEFAULT_REGEN_MAP_GATE);
; 17996: #else // FOR_JAPAN
; 17997: 				gObjMoveGate(aIndex, NEWPVP_DEFAULT_REGEN_MAP_GATE);
; 17998: #endif // FOR_JAPAN
; 17999: 			}
; 18000: #endif // ADD_NEWPVP_PKFIELD
; 18001: #ifdef CASTLE_MAIN_SCHEDULER_20041111		//       
; 18002: 			else if (gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE) {
; 18003: 				if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 18004: 					if (gObj[aIndex].m_btCsJoinSide == CS_SIEGESIDE_DEFEND) {
; 18005: 						gObjMoveGate(aIndex, 101);
; 18006: 					}
; 18007: 					else {
; 18008: 						gObjMoveGate(aIndex, 100);
; 18009: 					}
; 18010: 				}
; 18011: 				else {
; 18012: 					if (g_CastleSiege.CheckCastleOwnerMember(aIndex) == TRUE ||
; 18013: 						g_CastleSiege.CheckCastleOwnerUnionMember(aIndex) == TRUE
; 18014: 						) {
; 18015: 						gObjMoveGate(aIndex, 101);
; 18016: 					}
; 18017: 					else {
; 18018: 						gObjMoveGate(aIndex, 100);
; 18019: 					}
; 18020: 				}
; 18021: 			}
; 18022: #endif
; 18023: 			
; 18024: 			else gObjMoveGate(aIndex, 17);

  01581	6a 11		 push	 17			; 00000011H
  01583	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01586	50		 push	 eax
  01587	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0158c	83 c4 08	 add	 esp, 8
$LN90@CGUseItemR:

; 18025: 		}

  0158f	e9 98 01 00 00	 jmp	 $LN96@CGUseItemR
$LN68@CGUseItemR:

; 18026: 		else if( citem->m_Type == MAKE_ITEMNUM(14,9) )	//  ..

  01594	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  01597	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0159b	6a 09		 push	 9
  0159d	6a 0e		 push	 14			; 0000000eH
  0159f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  015a4	83 c4 08	 add	 esp, 8
  015a7	3b f0		 cmp	 esi, eax
  015a9	75 71		 jne	 SHORT $LN91@CGUseItemR

; 18027: 		{
; 18028: 			int level = citem->m_Level;

  015ab	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  015ae	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  015b2	89 4d e0	 mov	 DWORD PTR _level$1[ebp], ecx

; 18029: 
; 18030: 			gObjInventoryItemSet(aIndex, pos, 0xFF);

  015b5	68 ff 00 00 00	 push	 255			; 000000ffH
  015ba	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  015bd	50		 push	 eax
  015be	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  015c1	51		 push	 ecx
  015c2	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  015c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18031: 			gObj[aIndex].pInventory[pos].Clear();

  015ca	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  015d1	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  015d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  015de	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  015e5	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 18032: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  015ea	6a 01		 push	 1
  015ec	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  015f0	50		 push	 eax
  015f1	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  015f4	51		 push	 ecx
  015f5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  015fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18033: 			gObjUseDrink(&gObj[aIndex], level);

  015fd	8b 45 e0	 mov	 eax, DWORD PTR _level$1[ebp]
  01600	50		 push	 eax
  01601	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  01608	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0160e	51		 push	 ecx
  0160f	e8 00 00 00 00	 call	 ?gObjUseDrink@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjUseDrink
  01614	83 c4 08	 add	 esp, 8

; 18034: 		}

  01617	e9 10 01 00 00	 jmp	 $LN96@CGUseItemR
$LN91@CGUseItemR:

; 18035: 		else if( citem->m_Type == MAKE_ITEMNUM(14,20) )	//  

  0161c	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  0161f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  01623	6a 14		 push	 20			; 00000014H
  01625	6a 0e		 push	 14			; 0000000eH
  01627	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0162c	83 c4 08	 add	 esp, 8
  0162f	3b f0		 cmp	 esi, eax
  01631	75 65		 jne	 SHORT $LN93@CGUseItemR

; 18036: 		{
; 18037: #ifdef JAPAN_1ST_ANIVERSARY_BOX_20040531				//    +1 ~ +6     .
; 18038: 			if (citem->m_Level == 0) {
; 18039: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 18040: 				gObj[aIndex].pInventory[pos].Clear();
; 18041: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 18042: 				gObjUseDrink(&gObj[aIndex], 2);
; 18043: 			}
; 18044: #else
; 18045: 			gObjInventoryItemSet(aIndex, pos, 0xFF);

  01633	68 ff 00 00 00	 push	 255			; 000000ffH
  01638	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  0163b	50		 push	 eax
  0163c	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0163f	51		 push	 ecx
  01640	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  01645	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18046: 			gObj[aIndex].pInventory[pos].Clear();

  01648	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0164f	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  01656	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0165c	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  01663	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 18047: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  01668	6a 01		 push	 1
  0166a	0f b6 45 fc	 movzx	 eax, BYTE PTR _pos$[ebp]
  0166e	50		 push	 eax
  0166f	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01672	51		 push	 ecx
  01673	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01678	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18048: 			gObjUseDrink(&gObj[aIndex], 2);

  0167b	6a 02		 push	 2
  0167d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01684	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0168a	50		 push	 eax
  0168b	e8 00 00 00 00	 call	 ?gObjUseDrink@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjUseDrink
  01690	83 c4 08	 add	 esp, 8

; 18049: #endif
; 18050: 		}

  01693	e9 94 00 00 00	 jmp	 $LN96@CGUseItemR
$LN93@CGUseItemR:

; 18051: 		else if( citem->m_Type == MAKE_ITEMNUM(13,15) )	// ..

  01698	8b 45 f8	 mov	 eax, DWORD PTR _citem$[ebp]
  0169b	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0169f	6a 0f		 push	 15			; 0000000fH
  016a1	6a 0d		 push	 13			; 0000000dH
  016a3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  016a8	83 c4 08	 add	 esp, 8
  016ab	3b f0		 cmp	 esi, eax
  016ad	75 12		 jne	 SHORT $LN95@CGUseItemR

; 18052: 		{
; 18053: #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 18054: // * Circle    . ^^
; 18055: 
; 18056: 			// 0)   
; 18057: 			if( iItemUseType == 0x00 )
; 18058: 				gObjUsePlusStatFruit(aIndex, pos);
; 18059: 			// 1)   
; 18060: 			else if( iItemUseType == 0x01)
; 18061: 				gObjUseMinusStatFruit(aIndex, pos);
; 18062: #else
; 18063: 			gObjUseCircle(aIndex, pos);

  016af	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  016b2	50		 push	 eax
  016b3	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  016b6	51		 push	 ecx
  016b7	e8 00 00 00 00	 call	 ?gObjUseCircle@@YAXHH@Z	; gObjUseCircle
  016bc	83 c4 08	 add	 esp, 8

; 18064: #endif
; 18065: 		}

  016bf	eb 6b		 jmp	 SHORT $LN96@CGUseItemR
$LN95@CGUseItemR:

; 18066: 
; 18067: #ifdef ADD_PCS_FRUITS_POINT_EXTENTION_20070430
; 18068: 		else if( citem->m_Type == MAKE_ITEMNUM( 13, 54 )		//   
; 18069: 			|| citem->m_Type == MAKE_ITEMNUM( 13, 55 )			//   
; 18070: 			|| citem->m_Type == MAKE_ITEMNUM( 13, 56 )			//   
; 18071: 			|| citem->m_Type == MAKE_ITEMNUM( 13, 57 )			//   
; 18072: 			|| citem->m_Type == MAKE_ITEMNUM( 13, 58 )			//   
; 18073: 			   )		//  
; 18074: 		{
; 18075: 			gObjUseExMinusFruit( &gObj[aIndex], pos );
; 18076: 		}
; 18077: #endif // ADD_PCS_FRUITS_POINT_EXTENTION_20070430
; 18078: 
; 18079: #ifdef ADD_PCS_IMPROVE_POTION_20070718
; 18080: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 78 )
; 18081: 			|| citem->m_Type == MAKE_ITEMNUM( 14, 79 )
; 18082: 			|| citem->m_Type == MAKE_ITEMNUM( 14, 80 )
; 18083: 			|| citem->m_Type == MAKE_ITEMNUM( 14, 81 )
; 18084: 			|| citem->m_Type == MAKE_ITEMNUM( 14, 82 )
; 18085: 				)
; 18086: 		{
; 18087: 			gObjUseImprovePotion( &gObj[aIndex], pos );
; 18088: 		}
; 18089: #endif // ADD_PCS_IMPROVE_POTION_20070718
; 18090: 
; 18091: #ifdef ADD_PCS_INDULGENCE_20070504
; 18092: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 72 ) )		// 
; 18093: 		{
; 18094: 			gObjUseIndulgence( &gObj[aIndex], pos );
; 18095: 		}
; 18096: #endif // ADD_PCS_INDULGENCE_20070504
; 18097: 
; 18098: #ifdef ADD_FULL_RECOVERY_POTION_20070719
; 18099: 		else if( citem->m_Type == MAKE_ITEMNUM( 14, 70 )
; 18100: 			|| citem->m_Type == MAKE_ITEMNUM( 14, 71 )
; 18101: 				)
; 18102: 		{
; 18103: 			gObjUseFullRecoveryPotion( &gObj[aIndex], pos );
; 18104: 		}
; 18105: #endif // ADD_FULL_RECOVERY_POTION_20070719
; 18106: 
; 18107: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 18108: 		else if ( citem->m_Type == MAKE_ITEMNUM( 14, 94 )		// 
; 18109: 			)
; 18110: 		{
; 18111: 			gObjUseRecoveryPotion( &gObj[aIndex], pos, (float)0.65 );
; 18112: 		}
; 18113: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 18114: 
; 18115: #ifndef GAME_VERSION == G_V_99B
; 18116: #ifdef ADD_ELITE_SD_POTION_20090918
; 18117: 		else if ( citem->m_Type == MAKE_ITEMNUM( 14, 133 )		//  SD  
; 18118: 			)
; 18119: 		{
; 18120: 			gObjUseRecoveryPotion( &gObj[aIndex], pos, (float)0.65 );
; 18121: 		}
; 18122: #endif // ADD_ELITE_SD_POTION_20090918
; 18123: #endif // GAME_VERSION (99B) CHECK
; 18124: 
; 18125: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312		//  
; 18126: 		else if ( citem->m_Type == MAKE_ITEMNUM( 14, 85 )
; 18127: 			|| citem->m_Type == MAKE_ITEMNUM( 14, 86 )
; 18128: 			|| citem->m_Type == MAKE_ITEMNUM( 14, 87 )
; 18129: 			)
; 18130: 		{
; 18131: 			int iBuffType = BUFFTYPE_NONE;
; 18132: 			if( citem->m_Type == MAKE_ITEMNUM( 14, 85 ) )		iBuffType = BUFFTYPE_CHERRYBLOSSOM_DRINK;	//
; 18133: 			else if( citem->m_Type == MAKE_ITEMNUM( 14, 86 ) )	iBuffType = BUFFTYPE_CHERRYBLOSSOM_DUMPLING;// 
; 18134: 			else if( citem->m_Type == MAKE_ITEMNUM( 14, 87 ) )	iBuffType = BUFFTYPE_CHERRYBLOSSOM_PETAL;	// 
; 18135: 
; 18136: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )
; 18137: 			{
; 18138: 				gObjInventoryItemSet( aIndex, pos, 0xFF );
; 18139: 				gObj[aIndex].pInventory[pos].Clear();
; 18140: 				GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 18141: 			}
; 18142: 
; 18143: 			gObjAddBuffEffect( &gObj[aIndex], iBuffType);
; 18144: #ifndef MODIFY_JOL_BLESS_POTION_USE_EFFECT_20061030
; 18145: 			GCReFillSend( aIndex, (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife), 0xFE, 0, (WORD)(gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield));
; 18146: 			GCManaSend( aIndex, (short)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana), 0xFE, 0, gObj[aIndex].MaxBP+gObj[aIndex].AddBP);
; 18147: #endif	
; 18148: 		}
; 18149: #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 18150: 
; 18151: #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 18152: 		else if( citem->m_Type == MAKE_ITEMNUM(14,7) ) //  ,    .
; 18153: 		{
; 18154: 			//       - riverstyx
; 18155: 			int iLevel = citem->m_Level;
; 18156: 			int iSerial = citem->GetNumber();
; 18157: 			int iDur = citem->m_Durability;
; 18158: 
; 18159: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1) == FALSE )
; 18160: 			{
; 18161: 				gObjInventoryItemSet(aIndex, pos, 0xFF);
; 18162: 				gObj[aIndex].pInventory[pos].Clear();
; 18163: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 18164: 			}
; 18165: 
; 18166: #ifdef EXTEND_LOG_SYSTEM_03_20060816
; 18167: 			if( gObj[aIndex].lpGuild != NULL )
; 18168: 			{
; 18169: 				LogAddTD("[CastleSiege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s][%s] - (Guild : %s)", 
; 18170: 					iLevel, iSerial, iDur, gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].lpGuild->Name);
; 18171: 			}
; 18172: 			else
; 18173: 			{
; 18174: 				LogAddTD("[CastleSiege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s][%s]", 
; 18175: 					iLevel, iSerial, iDur, gObj[aIndex].AccountID, gObj[aIndex].Name );
; 18176: 			}
; 18177: #else
; 18178: 			LogAddTD("[CastleSiege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s][%s]", 
; 18179: 				iLevel, iSerial, iDur, gObj[aIndex].AccountID, gObj[aIndex].Name );
; 18180: #endif // EXTEND_LOG_SYSTEM_03_20060816
; 18181: 
; 18182: 			if( iLevel == 0 ) //   
; 18183: 			{
; 18184: 				gObjUseBlessAndSoulPotion( aIndex, iLevel );
; 18185: 			}
; 18186: 			else if( iLevel == 1 ) //  
; 18187: 			{
; 18188: 				gObjUseBlessAndSoulPotion( aIndex, iLevel );
; 18189: 			}
; 18190: 		}
; 18191: #endif
; 18192: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18193: 		//   
; 18194: 		else if( citem->m_Type == MAKE_ITEMNUM( 13, 48 ) )
; 18195: 		{
; 18196: 			if( ( gObj[aIndex].MapNumber < MAP_INDEX_KALIMA1 || gObj[aIndex].MapNumber > MAP_INDEX_KALIMA6 )
; 18197: 				&& gObj[aIndex].MapNumber != MAP_INDEX_KALIMA7 )
; 18198: 			{
; 18199: 				int iLevel = g_KalimaGate.GetKalimaGateLevel2( aIndex );
; 18200: 				int iSerial = citem->GetNumber();
; 18201: 				int iDuration = citem->m_Durability;
; 18202: 				BOOL bKalimaGateCreateResult = FALSE;
; 18203: 				int iKalimaGateX = 0;
; 18204: 				int iKalimaGateY = 0;
; 18205: 
; 18206: 				iLevel = iLevel + 1;
; 18207: 
; 18208: 				//   3   .
; 18209: 				iKalimaGateX = ( gObj[aIndex].X - 2 ) + ( rand() % 6 );
; 18210: 				iKalimaGateY = ( gObj[aIndex].Y - 2 ) + ( rand() % 6 );
; 18211: 
; 18212: 				bKalimaGateCreateResult = g_KalimaGate.CreateKalimaGate( aIndex, iLevel, iKalimaGateX, iKalimaGateY );
; 18213: 				if( bKalimaGateCreateResult == TRUE )
; 18214: 				{
; 18215: 					//   
; 18216: 					if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )
; 18217: 					{
; 18218: 						gObjInventoryItemSet( aIndex, pos, 0xFF );
; 18219: 						gObj[aIndex].pInventory[pos].Clear();
; 18220: 						GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 18221: 					}
; 18222: 
; 18223: 					LogAddTD("[PCS] Use Free Kalima Ticket Success");
; 18224: 				}
; 18225: 				else
; 18226: 				{
; 18227: 					//    
; 18228: 	#ifdef MODIFY_KALIMA_FREETICKET_USE_RESULT_20070830
; 18229: 					GCItemDurSend( aIndex, pos, gObj[aIndex].pInventory[pos].m_Durability, 1 );
; 18230: 	#endif // MODIFY_KALIMA_FREETICKET_USE_RESULT_20070830
; 18231: 					LogAddTD("[PCS] Use Free Kalima Ticket Failed");
; 18232: 				}
; 18233: 			}
; 18234: 		}
; 18235: 		//------------->
; 18236: 		//20080930  5  ,   (grooving)
; 18237: 	#ifdef ADD_TELEPORT_CHARM_ITEM_20080930	
; 18238: 		else if( citem->m_Type == MAKE_ITEMNUM(13, 69) )//  
; 18239: 		{
; 18240: 			BOOL bCheckEquipmentToMove = gMoveCommand.CheckEquipmentToMove( &gObj[aIndex], gObj[aIndex].m_siDieRegenMapIndex );
; 18241: 
; 18242: 			if ( !CHECK_BLOODCASTLE(gObj[aIndex].MapNumber) && !CHECK_CHAOSCASTLE(gObj[aIndex].MapNumber) 
; 18243: 				&& !CHECK_KALIMAMAP(gObj[aIndex].MapNumber) && !CHECK_DEVILSQUARE(gObj[aIndex].MapNumber)
; 18244: 				&& !CHECK_ILLUSION_TEMPLE(gObj[aIndex].MapNumber) 
; 18245: 				&& (gObj[aIndex].MapNumber != MAP_INDEX_CASTLESIEGE) &&  (gObj[aIndex].MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 18246: 				&& TRUE == bCheckEquipmentToMove
; 18247: 				)
; 18248: 			{
; 18249: 				gObjTeleport( aIndex, gObj[aIndex].m_siDieRegenMapIndex, gObj[aIndex].m_siDieRegenX, gObj[aIndex].m_siDieRegenY );
; 18250: 				
; 18251: 				gObjInventoryItemSet( aIndex, pos, 0xFF );
; 18252: 				gObj[aIndex].pInventory[pos].Clear();
; 18253: 				GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 18254: 
; 18255: 				LogAddTD("[Using Item] [Charm of Raise] [%s][%s] Die Position Map:[%d] X:[%d] Y:[%d]", 
; 18256: 				gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_siDieRegenMapIndex, gObj[aIndex].m_siDieRegenX, gObj[aIndex].m_siDieRegenY);
; 18257: 				gObj[aIndex].m_siDieRegenMapIndex	=	0;
; 18258: 				gObj[aIndex].m_siDieRegenX			=	0;
; 18259: 				gObj[aIndex].m_siDieRegenY			=	0;
; 18260: 
; 18261: 				GCServerCmd(aIndex, 60, 0, 0);
; 18262: 			}
; 18263: 			else
; 18264: 			{
; 18265: 				char msg[255];						
; 18266: 				wsprintf(msg, lMsg.Get(1252));	//  
; 18267: 				GCServerMsgStringSend(msg, aIndex, 1);
; 18268: 			}
; 18269: 		}						
; 18270: 		else if( citem->m_Type == MAKE_ITEMNUM(13, 70) )//
; 18271: 		{
; 18272: 			BOOL bCheckEquipmentToMove = gMoveCommand.CheckEquipmentToMove( &gObj[aIndex], gObj[aIndex].m_siMoveMapIndex );
; 18273: 
; 18274: 			if( gIsMoveCharmEnable(gObj[aIndex].MapNumber) == TRUE && 
; 18275: 				TRUE == bCheckEquipmentToMove
; 18276: 				)
; 18277: 			{		
; 18278: 				if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )//     
; 18279: 				{
; 18280: 					gObjTeleport( aIndex, gObj[aIndex].m_siMoveMapIndex, gObj[aIndex].m_siMoveX, gObj[aIndex].m_siMoveY );
; 18281: 					
; 18282: 					gObjInventoryItemSet( aIndex, pos, 0xFF );
; 18283: 					gObj[aIndex].pInventory[pos].Clear();
; 18284: 					GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 18285: 
; 18286: 					gObj[aIndex].m_siMoveX		=		0;
; 18287: 					gObj[aIndex].m_siMoveY		=		0;
; 18288: 					gObj[aIndex].m_siMoveMapIndex =		0;	
; 18289: 					
; 18290: 					GCServerCmd(aIndex, 61, 0, 0);
; 18291: 					LogAddTD("[Using Item] [Charm of Move] [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 18292: 				}
; 18293: 				else//    
; 18294: 				{
; 18295: 					gObj[aIndex].m_siMoveX			=	gObj[aIndex].X;
; 18296: 					gObj[aIndex].m_siMoveY			=	gObj[aIndex].Y;
; 18297: 					gObj[aIndex].m_siMoveMapIndex	=	gObj[aIndex].MapNumber;
; 18298: 
; 18299: 					LogAddTD("[Using Item] [Charm of Move - SavePosition] [%s][%s] Map:[%d] X:[%d] Y:[%d]",
; 18300: 						gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_siMoveMapIndex, gObj[aIndex].m_siMoveX, gObj[aIndex].m_siMoveY );
; 18301: 				}				
; 18302: 			}
; 18303: 			else
; 18304: 			{
; 18305: 				char msg[255];						
; 18306: 				wsprintf(msg, lMsg.Get(1252));	//  
; 18307: 				GCServerMsgStringSend(msg, aIndex, 1);
; 18308: 			}
; 18309: 		}	
; 18310: 	#endif //ADD_TELEPORT_CHARM_ITEM_20080930
; 18311: 		//<-------------
; 18312: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 18313: 
; 18314: 		//------------->
; 18315: 		//20081013    -   (grooving)
; 18316: #ifdef UPDATE_XMASEVENT_MAP_20080930
; 18317: 		else if( citem->m_Type == MAKE_ITEMNUM(13, 66) )// 
; 18318: 		{
; 18319: #ifdef MODIFY_SANTACLAUSVILLAGE_VISITLEVEL
; 18320: 			if (gObj[aIndex].Level < 15)
; 18321: 			{
; 18322: 				GCServerMsgStringSend(lMsg.Get(2613), aIndex, 1);
; 18323: 			} 
; 18324: 			else
; 18325: 			{
; 18326: 				gObjTeleport( aIndex, MAP_INDEX_XMASEVENT, 220, 20 );
; 18327: 				
; 18328: 				if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )
; 18329: 				{
; 18330: 					gObjInventoryItemSet( aIndex, pos, 0xFF );
; 18331: 					gObj[aIndex].pInventory[pos].Clear();
; 18332: 					GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 18333: 				}
; 18334: 			}
; 18335: #else
; 18336: 			gObjTeleport( aIndex, MAP_INDEX_XMASEVENT, 220, 20 );
; 18337: 			
; 18338: 			if( gObjSearchItemMinus( &gObj[aIndex], pos, 1 ) == FALSE )
; 18339: 			{
; 18340: 				gObjInventoryItemSet( aIndex, pos, 0xFF );
; 18341: 				gObj[aIndex].pInventory[pos].Clear();
; 18342: 				GCInventoryItemDeleteSend( aIndex, pos, 1 );
; 18343: 			}
; 18344: #endif // MODIFY_SANTACLAUSVILLAGE_VISITLEVEL
; 18345: 		}
; 18346: #endif	//UPDATE_XMASEVENT_MAP_20080930
; 18347: 		//<-------------
; 18348: #ifdef ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 18349: 		else if( citem->m_Type == MAKE_ITEMNUM(13, 81) ) { //  6  ( ,    . 			
; 18350: #ifdef MODIFY_CHARM_GUARDIAN_CHARM_PROTECTITEM_NON_DUPLICATION_20090720
; 18351: 			for( int iBuffIndex = 0 ; iBuffIndex < gObj[aIndex].m_BuffEffectCount ; iBuffIndex++ )
; 18352: 			{
; 18353: 				//     
; 18354: 				if( gObj[aIndex].m_BuffEffectList[iBuffIndex].BuffIndex == BUFFTYPE_CHARM_GUARDIAN )
; 18355: 				{
; 18356: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 18357: 					return;
; 18358: 				}
; 18359: 			}
; 18360: #endif // MODIFY_CHARM_GUARDIAN_CHARM_PROTECTITEM_NON_DUPLICATION_20090720
; 18361: 
; 18362: 			g_CashItemPeriodSystem.GDReqPeriodItemInsert(&gObj[aIndex],citem->m_Type,ITEM_EFFECTDATE_USE_FILE);
; 18363: 			
; 18364: 			gObjInventoryItemSet( aIndex, pos, 0xFF );
; 18365: 			gObj[aIndex].pInventory[pos].Clear();
; 18366: 			GCInventoryItemDeleteSend( aIndex, pos, 1);			
; 18367: 		} else if( citem->m_Type == MAKE_ITEMNUM(13, 82) ) {			
; 18368: #ifdef MODIFY_CHARM_GUARDIAN_CHARM_PROTECTITEM_NON_DUPLICATION_20090720
; 18369: 			for( int iBuffIndex = 0 ; iBuffIndex < gObj[aIndex].m_BuffEffectCount ; iBuffIndex++ )
; 18370: 			{
; 18371: 				//     
; 18372: 				if( gObj[aIndex].m_BuffEffectList[iBuffIndex].BuffIndex == BUFFTYPE_CHARM_PROTECTITEM )
; 18373: 				{
; 18374: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 18375: 					return;
; 18376: 				}
; 18377: 			}
; 18378: #endif // MODIFY_CHARM_GUARDIAN_CHARM_PROTECTITEM_NON_DUPLICATION_20090720
; 18379: 
; 18380: 			g_CashItemPeriodSystem.GDReqPeriodItemInsert(&gObj[aIndex],citem->m_Type,ITEM_EFFECTDATE_USE_FILE);
; 18381: 			
; 18382: 			gObjInventoryItemSet( aIndex, pos, 0xFF );
; 18383: 			gObj[aIndex].pInventory[pos].Clear();
; 18384: 			GCInventoryItemDeleteSend( aIndex, pos, 1);			
; 18385: 		}
; 18386: #endif
; 18387: 		else
; 18388: 		{
; 18389: 			LogAdd("error-L3 : %s return %s %d %d %s", gObj[aIndex].Name, __FILE__, __LINE__, pos, citem->GetName());

  016c1	8b 4d f8	 mov	 ecx, DWORD PTR _citem$[ebp]
  016c4	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  016c9	50		 push	 eax
  016ca	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  016cd	50		 push	 eax
  016ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
  016d4	81 c1 ce 05 00
	00		 add	 ecx, 1486		; 000005ceH
  016da	51		 push	 ecx
  016db	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  016e0	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  016e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  016ec	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  016f0	51		 push	 ecx
  016f1	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CF@
  016f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  016fc	83 c4 18	 add	 esp, 24			; 00000018H

; 18390: 
; 18391: 
; 18392: #ifdef ADD_SHIELD_POINT_01_20060403
; 18393: 			GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 18394: #else
; 18395: 			GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  016ff	6a 01		 push	 1
  01701	68 fd 00 00 00	 push	 253			; 000000fdH
  01706	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0170d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01713	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  0171c	0f b7 c2	 movzx	 eax, dx
  0171f	50		 push	 eax
  01720	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01723	51		 push	 ecx
  01724	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  01729	83 c4 10	 add	 esp, 16			; 00000010H
$LN96@CGUseItemR:

; 18396: #endif
; 18397: 			
; 18398: 			//char szTemp[256];
; 18399: 			//wsprintf(szTemp, " %d    ", pos);
; 18400: 			//GCServerMsgStringSend(szTemp, aIndex, 1);
; 18401: 		}
; 18402: 	}

  0172c	eb 62		 jmp	 SHORT $LN14@CGUseItemR
$LN13@CGUseItemR:

; 18403: 	else
; 18404: 	{
; 18405: #ifdef ADD_SHIELD_POINT_01_20060403
; 18406: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, (WORD)gObj[aIndex].iShield);
; 18407: #else
; 18408: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1);

  0172e	6a 01		 push	 1
  01730	68 fd 00 00 00	 push	 253			; 000000fdH
  01735	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0173c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01742	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  0174b	0f b7 c2	 movzx	 eax, dx
  0174e	50		 push	 eax
  0174f	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01752	51		 push	 ecx
  01753	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  01758	83 c4 10	 add	 esp, 16			; 00000010H

; 18409: #endif
; 18410: 
; 18411: 		LogAdd("error-L3 : %s return %s %d %d", gObj[aIndex].Name, __FILE__, __LINE__, pos);

  0175b	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  0175e	50		 push	 eax
  0175f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z@4JA
  01765	81 c1 e4 05 00
	00		 add	 ecx, 1508		; 000005e4H
  0176b	51		 push	 ecx
  0176c	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  01771	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  01778	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0177d	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  01781	51		 push	 ecx
  01782	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd@
  01787	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0178d	83 c4 14	 add	 esp, 20			; 00000014H
$LN14@CGUseItemR:
$LN1@CGUseItemR:

; 18412: 		//char szTemp[256];
; 18413: 		//wsprintf(szTemp, " %d    ", pos);
; 18414: 		//GCServerMsgStringSend(szTemp, aIndex, 1);
; 18415: 	}
; 18416: }

  01790	5f		 pop	 edi
  01791	5e		 pop	 esi
  01792	5b		 pop	 ebx
  01793	8b e5		 mov	 esp, ebp
  01795	5d		 pop	 ebp
  01796	c3		 ret	 0
  01797	90		 npad	 1
$LN114@CGUseItemR:
  01798	00 00 00 00	 DD	 $LN23@CGUseItemR
  0179c	00 00 00 00	 DD	 $LN24@CGUseItemR
  017a0	00 00 00 00	 DD	 $LN25@CGUseItemR
  017a4	00 00 00 00	 DD	 $LN26@CGUseItemR
?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ENDP		; CGUseItemRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCSendEffectInfo@@YAXHE@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
_pMsg$ = -12						; size = 6
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_btType$ = 12						; size = 1
?GCSendEffectInfo@@YAXHE@Z PROC				; GCSendEffectInfo, COMDAT

; 22050: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 22051: 	if(!CHECK_LIMIT(aIndex, MAX_OBJECT)) 

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN6@GCSendEffe
  0000f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN7@GCSendEffe
$LN6@GCSendEffe:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN4@GCSendEffe
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN5@GCSendEffe
$LN4@GCSendEffe:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN5@GCSendEffe:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN7@GCSendEffe:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 02		 jne	 SHORT $LN2@GCSendEffe

; 22052: 		return;

  0003d	eb 50		 jmp	 SHORT $LN1@GCSendEffe
$LN2@GCSendEffe:

; 22053: 
; 22054: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  0003f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00046	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004c	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 22055: 
; 22056: 	PMSG_EFFECTINFO	pMsg;
; 22057: 	pMsg.h.c		= PMHC_BYTE;

  0004f	c6 45 f4 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 22058: 	pMsg.h.headcode	= 0x48;

  00053	c6 45 f6 48	 mov	 BYTE PTR _pMsg$[ebp+2], 72 ; 00000048H

; 22059: 	pMsg.h.size		= sizeof(PMSG_EFFECTINFO);

  00057	c6 45 f5 06	 mov	 BYTE PTR _pMsg$[ebp+1], 6

; 22060: 	pMsg.NumberH	= HIBYTE(aIndex);

  0005b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0005e	c1 e8 08	 shr	 eax, 8
  00061	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00066	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 22061: 	pMsg.NumberL	= LOBYTE(aIndex);		

  00069	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0006c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00071	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 22062: 
; 22063: 	pMsg.btType		= btType;

  00074	8a 45 0c	 mov	 al, BYTE PTR _btType$[ebp]
  00077	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 22064: 
; 22065: #ifdef ADD_SHIELD_POINT_01_20060403
; 22066: 	if ( btType == EFFECT_SHIELDBROKE )
; 22067: 	{
; 22068: 		//     .
; 22069: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 22070: 	}
; 22071: #endif // ADD_SHIELD_POINT_01_20060403
; 22072: 
; 22073: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  0007a	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0007e	50		 push	 eax
  0007f	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00082	51		 push	 ecx
  00083	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendEffe:

; 22074: }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
?GCSendEffectInfo@@YAXHE@Z ENDP				; GCSendEffectInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z
_TEXT	SEGMENT
tv1001 = -356						; size = 4
tv577 = -356						; size = 4
tv214 = -356						; size = 4
tv191 = -356						; size = 4
tv1024 = -352						; size = 4
tv1002 = -352						; size = 4
tv907 = -352						; size = 4
tv592 = -352						; size = 4
tv578 = -352						; size = 4
tv303 = -352						; size = 4
tv215 = -352						; size = 4
tv192 = -352						; size = 4
$T1 = -348						; size = 4
_szWEAPON_NAME$2 = -280					; size = 128
_NewOption$3 = -152					; size = 8
_Ret$4 = -141						; size = 1
_iDurGap$5 = -140					; size = 4
_NewOption$6 = -136					; size = 8
_iInventoryIndex$7 = -128				; size = 4
_iLoop$8 = -124						; size = 4
_loWord$9 = -120					; size = 2
_hiWord$10 = -116					; size = 2
_loWord$11 = -112					; size = 2
_hiWord$12 = -108					; size = 2
_itemcnt$13 = -104					; size = 4
_itemcnt$14 = -100					; size = 4
_lpItem$ = -96						; size = 4
_szItemName$ = -92					; size = 50
_Noption$ = -40						; size = 4
_special$ = -36						; size = 4
_level$ = -32						; size = 4
_type$ = -28						; size = 4
_pResult$ = -24						; size = 9
_map_num$ = -12						; size = 4
_item_num$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z PROC	; CGItemGetRequest, COMDAT

; 4372 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 4373 : 	int  item_num;
; 4374 : 	int  map_num;
; 4375 : 	PMSG_ITEMGETRESULT	pResult;
; 4376 : 
; 4377 : 	pResult.h.c        = PMHCE_BYTE;

  00016	c6 45 e8 c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 4378 : 	pResult.h.headcode = 0x22;

  0001a	c6 45 ea 22	 mov	 BYTE PTR _pResult$[ebp+2], 34 ; 00000022H

; 4379 : 	pResult.h.size     = sizeof( pResult );

  0001e	c6 45 e9 09	 mov	 BYTE PTR _pResult$[ebp+1], 9

; 4380 : 	pResult.result     = 0xFF;

  00022	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4381 : 
; 4382 : 	if( gObjIsConnected(aIndex) == FALSE )

  00026	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	75 11		 jne	 SHORT $LN9@CGItemGetR

; 4383 : 	{
; 4384 : 		CloseClient ( aIndex );

  00036	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0003f	83 c4 04	 add	 esp, 4

; 4385 : 		return;

  00042	e9 2c 11 00 00	 jmp	 $LN1@CGItemGetR
$LN9@CGItemGetR:

; 4386 : 	}
; 4387 : 
; 4388 : 	//    
; 4389 : 	if( gObj[aIndex].CloseType != -1 ) 

  00047	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00054	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  00059	83 fa ff	 cmp	 edx, -1
  0005c	74 05		 je	 SHORT $LN10@CGItemGetR

; 4390 : 	{
; 4391 : 		return;

  0005e	e9 10 11 00 00	 jmp	 $LN1@CGItemGetR
$LN10@CGItemGetR:

; 4392 : 	}
; 4393 : 	
; 4394 : #ifdef USER_DIE_ITEMGET_BUG_PATCH_20040322
; 4395 : 	//     
; 4396 : 	if( gObj[aIndex].DieRegen ) 

  00063	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00070	0f be 94 01 fe
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+510]
  00078	85 d2		 test	 edx, edx
  0007a	74 28		 je	 SHORT $LN11@CGItemGetR

; 4397 : 	{
; 4398 : 		pResult.result = 0xFF;

  0007c	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4399 : 		pResult.h.size -= ITEM_BUFFER_SIZE;

  00080	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00084	83 e8 05	 sub	 eax, 5
  00087	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4400 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0008a	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0008e	50		 push	 eax
  0008f	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00092	51		 push	 ecx
  00093	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4401 : 		return;

  0009f	e9 cf 10 00 00	 jmp	 $LN1@CGItemGetR
$LN11@CGItemGetR:

; 4402 : 	}
; 4403 : #endif
; 4404 : 	
; 4405 : #ifdef ADD_NEWPVP_PKFIELD
; 4406 : 	if ( g_NewPVP.IsObserver(gObj[aIndex]) )
; 4407 : 	{
; 4408 : 		pResult.result = 0xFF;
; 4409 : 		pResult.h.size -= ITEM_BUFFER_SIZE;
; 4410 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4411 : 		return;
; 4412 : 	}
; 4413 : #endif // ADD_NEWPVP_PKFIELD
; 4414 : 	
; 4415 : 	// &&...        ..
; 4416 : 	if( gObj[aIndex].m_IfState.use )

  000a4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b1	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000b8	80 e2 03	 and	 dl, 3
  000bb	0f b6 c2	 movzx	 eax, dl
  000be	85 c0		 test	 eax, eax
  000c0	74 69		 je	 SHORT $LN13@CGItemGetR

; 4417 : 	{
; 4418 : 		if( gObj[aIndex].m_IfState.type != I_SHOP )

  000c2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cf	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000d6	c0 ea 04	 shr	 dl, 4
  000d9	80 e2 0f	 and	 dl, 15			; 0000000fH
  000dc	0f b6 c2	 movzx	 eax, dl
  000df	83 f8 03	 cmp	 eax, 3
  000e2	74 47		 je	 SHORT $LN13@CGItemGetR

; 4419 : 		{
; 4420 : 			GCServerMsgStringSend(lMsg.Get(1118), aIndex, 1);

  000e4	6a 01		 push	 1
  000e6	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000e9	50		 push	 eax
  000ea	68 5e 04 00 00	 push	 1118			; 0000045eH
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4421 : 			pResult.result = 0xFF;

  00103	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4422 : 
; 4423 : 			pResult.h.size -= ITEM_BUFFER_SIZE;

  00107	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0010b	83 e8 05	 sub	 eax, 5
  0010e	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4424 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00111	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00115	50		 push	 eax
  00116	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00119	51		 push	 ecx
  0011a	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0011d	52		 push	 edx
  0011e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4425 : 			return;

  00126	e9 48 10 00 00	 jmp	 $LN1@CGItemGetR
$LN13@CGItemGetR:

; 4426 : 		}
; 4427 : 	}
; 4428 : 
; 4429 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719		//    -   
; 4430 : 	if (gObjFixInventoryPointer(aIndex) == false) {

  0012b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00134	83 c4 04	 add	 esp, 4
  00137	0f b6 c8	 movzx	 ecx, al
  0013a	85 c9		 test	 ecx, ecx
  0013c	75 1c		 jne	 SHORT $LN14@CGItemGetR

; 4431 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0013e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z@4JA
  00143	83 c0 3b	 add	 eax, 59			; 0000003bH
  00146	50		 push	 eax
  00147	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00157	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@CGItemGetR:

; 4432 : 	}
; 4433 : #endif
; 4434 : 
; 4435 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//       .
; 4436 : 	if (gObj[aIndex].pTransaction == 1) {

  0015a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00161	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00167	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  0016f	83 fa 01	 cmp	 edx, 1
  00172	75 55		 jne	 SHORT $LN15@CGItemGetR

; 4437 : 		LogAddTD("[%s][%s] CGItemGetRequest() Failed : Transaction == 1, IF_TYPE : %d",

  00174	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0017b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00181	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00188	c0 ea 04	 shr	 dl, 4
  0018b	80 e2 0f	 and	 dl, 15			; 0000000fH
  0018e	0f b6 c2	 movzx	 eax, dl
  00191	50		 push	 eax
  00192	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00199	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019f	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  001a3	50		 push	 eax
  001a4	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b1	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  001b5	50		 push	 eax
  001b6	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fai@
  001bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c1	83 c4 10	 add	 esp, 16			; 00000010H

; 4438 : 			gObj[aIndex].AccountID,
; 4439 : 			gObj[aIndex].Name,
; 4440 : 			gObj[aIndex].m_IfState.type
; 4441 : 			);
; 4442 : 		return;

  001c4	e9 aa 0f 00 00	 jmp	 $LN1@CGItemGetR
$LN15@CGItemGetR:

; 4443 : 	}
; 4444 : #endif
; 4445 : 
; 4446 : 	//if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;
; 4447 : 
; 4448 : 	item_num = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  001c9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001cc	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001d0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001d6	0f b6 d1	 movzx	 edx, cl
  001d9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001dc	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  001e0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001e6	0f b6 c1	 movzx	 eax, cl
  001e9	c1 e0 08	 shl	 eax, 8
  001ec	0b d0		 or	 edx, eax
  001ee	0f b7 ca	 movzx	 ecx, dx
  001f1	89 4d f8	 mov	 DWORD PTR _item_num$[ebp], ecx

; 4449 : 	if( !CHECK_LIMIT(item_num, MAX_MAPITEM ) ) 

  001f4	83 7d f8 00	 cmp	 DWORD PTR _item_num$[ebp], 0
  001f8	7d 0c		 jge	 SHORT $LN56@CGItemGetR
  001fa	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv192[ebp], 0
  00204	eb 2b		 jmp	 SHORT $LN57@CGItemGetR
$LN56@CGItemGetR:
  00206	81 7d f8 2b 01
	00 00		 cmp	 DWORD PTR _item_num$[ebp], 299 ; 0000012bH
  0020d	7e 0c		 jle	 SHORT $LN54@CGItemGetR
  0020f	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv191[ebp], 0
  00219	eb 0a		 jmp	 SHORT $LN55@CGItemGetR
$LN54@CGItemGetR:
  0021b	c7 85 9c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv191[ebp], 1
$LN55@CGItemGetR:
  00225	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv191[ebp]
  0022b	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv192[ebp], eax
$LN57@CGItemGetR:
  00231	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv192[ebp], 0
  00238	75 44		 jne	 SHORT $LN16@CGItemGetR

; 4450 : 	{
; 4451 : 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);		

  0023a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z@4JA
  0023f	83 c0 4f	 add	 eax, 79			; 0000004fH
  00242	50		 push	 eax
  00243	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@
  0024d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00253	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4452 : 		pResult.result = 0xFF;

  00256	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4453 : 		pResult.h.size -= ITEM_BUFFER_SIZE;

  0025a	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0025e	83 e8 05	 sub	 eax, 5
  00261	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4454 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00264	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00268	50		 push	 eax
  00269	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0026c	51		 push	 ecx
  0026d	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00270	52		 push	 edx
  00271	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00276	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4455 : 		return;

  00279	e9 f5 0e 00 00	 jmp	 $LN1@CGItemGetR
$LN16@CGItemGetR:

; 4456 : 	}
; 4457 : 
; 4458 : 	map_num = gObj[aIndex].MapNumber;

  0027e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00285	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0028b	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00293	89 55 f4	 mov	 DWORD PTR _map_num$[ebp], edx

; 4459 : 	if( !CHECK_LIMIT(map_num, g_TerrainManager.Size() ) ) 

  00296	83 7d f4 00	 cmp	 DWORD PTR _map_num$[ebp], 0
  0029a	7d 0c		 jge	 SHORT $LN60@CGItemGetR
  0029c	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv215[ebp], 0
  002a6	eb 34		 jmp	 SHORT $LN61@CGItemGetR
$LN60@CGItemGetR:
  002a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  002ad	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  002b2	83 e8 01	 sub	 eax, 1
  002b5	39 45 f4	 cmp	 DWORD PTR _map_num$[ebp], eax
  002b8	7e 0c		 jle	 SHORT $LN58@CGItemGetR
  002ba	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv214[ebp], 0
  002c4	eb 0a		 jmp	 SHORT $LN59@CGItemGetR
$LN58@CGItemGetR:
  002c6	c7 85 9c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv214[ebp], 1
$LN59@CGItemGetR:
  002d0	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv214[ebp]
  002d6	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv215[ebp], eax
$LN61@CGItemGetR:
  002dc	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv215[ebp], 0
  002e3	75 44		 jne	 SHORT $LN17@CGItemGetR

; 4460 : 	{
; 4461 : 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  002e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z@4JA
  002ea	83 c0 59	 add	 eax, 89			; 00000059H
  002ed	50		 push	 eax
  002ee	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  002f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4462 : 		//return;
; 4463 : 		pResult.result = 0xFF;

  00301	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4464 : 		pResult.h.size -= ITEM_BUFFER_SIZE;

  00305	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00309	83 e8 05	 sub	 eax, 5
  0030c	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4465 : 
; 4466 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0030f	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00313	50		 push	 eax
  00314	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00317	51		 push	 ecx
  00318	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0031b	52		 push	 edx
  0031c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00321	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4467 : 		return;

  00324	e9 4a 0e 00 00	 jmp	 $LN1@CGItemGetR
$LN17@CGItemGetR:

; 4468 : 	}
; 4469 : 
; 4470 : 	int type, level, special, Noption;
; 4471 : 	char szItemName[50];
; 4472 : 
; 4473 : 	CMapItem * lpItem = (CMapItem*)(&MapC[map_num].m_cItem[item_num]);

  00329	69 45 f4 8c 04
	05 00		 imul	 eax, DWORD PTR _map_num$[ebp], 328844
  00330	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00336	69 4d f8 48 04
	00 00		 imul	 ecx, DWORD PTR _item_num$[ebp], 1096
  0033d	8d 54 08 20	 lea	 edx, DWORD PTR [eax+ecx+32]
  00341	89 55 a0	 mov	 DWORD PTR _lpItem$[ebp], edx

; 4474 : 
; 4475 : 
; 4476 : 	//  ..
; 4477 : 	if( lpItem->IsItem() == TRUE 
; 4478 : #ifdef ITEM_GET_BUGFIX_20050406
; 4479 : 		&& (lpItem->Give == 0 && lpItem->live == 1)

  00344	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00347	83 c1 04	 add	 ecx, 4
  0034a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0034f	83 f8 01	 cmp	 eax, 1
  00352	0f 85 fc 0d 00
	00		 jne	 $LN18@CGItemGetR
  00358	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0035b	0f b6 88 af 00
	00 00		 movzx	 ecx, BYTE PTR [eax+175]
  00362	85 c9		 test	 ecx, ecx
  00364	0f 85 ea 0d 00
	00		 jne	 $LN18@CGItemGetR
  0036a	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0036d	0f b6 88 ae 00
	00 00		 movzx	 ecx, BYTE PTR [eax+174]
  00374	83 f9 01	 cmp	 ecx, 1
  00377	0f 85 d7 0d 00
	00		 jne	 $LN18@CGItemGetR

; 4480 : #endif
; 4481 : 		)
; 4482 : 	{
; 4483 : #ifdef MODIFY_QUEST_MONSTER_KILL_COUNT_BUGFIX_20070704	//    
; 4484 : 		if( lpItem->m_QuestItem )
; 4485 : 		{	//  
; 4486 : 			// 1.   ?
; 4487 : 			BOOL bIsGetItem = g_QuestInfo.GetQuestItem( aIndex, lpItem->m_Type, lpItem->m_Level );
; 4488 : 			if( bIsGetItem == FALSE )
; 4489 : 			{
; 4490 : 				pResult.result = 0xFF;
; 4491 : 				pResult.h.size -= ITEM_BUFFER_SIZE;
; 4492 : 				
; 4493 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4494 : 				return;
; 4495 : 			}
; 4496 : 		}
; 4497 : #else
; 4498 : 	
; 4499 : #ifdef NEW_SKILL_FORSKYLAND
; 4500 : 		if( lpItem->m_QuestItem )

  0037d	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00380	0f b6 88 95 00
	00 00		 movzx	 ecx, BYTE PTR [eax+149]
  00387	85 c9		 test	 ecx, ecx
  00389	0f 84 87 00 00
	00		 je	 $LN21@CGItemGetR

; 4501 : 		{	//  
; 4502 : 			int itemcnt = gObjGetItemCountInIventory(aIndex, lpItem->m_Type);

  0038f	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00392	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00396	51		 push	 ecx
  00397	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0039a	52		 push	 edx
  0039b	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHH@Z ; gObjGetItemCountInIventory
  003a0	83 c4 08	 add	 esp, 8
  003a3	89 45 9c	 mov	 DWORD PTR _itemcnt$14[ebp], eax

; 4503 : 			if( itemcnt > 0 )

  003a6	83 7d 9c 00	 cmp	 DWORD PTR _itemcnt$14[ebp], 0
  003aa	7e 6a		 jle	 SHORT $LN21@CGItemGetR

; 4504 : 			{
; 4505 : 				LogAdd("[Quest] Too many have quest item [%s][%s] (%s) %d", 

  003ac	8b 45 9c	 mov	 eax, DWORD PTR _itemcnt$14[ebp]
  003af	50		 push	 eax
  003b0	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  003b3	83 c1 04	 add	 ecx, 4
  003b6	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  003bb	50		 push	 eax
  003bc	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003c9	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  003cd	50		 push	 eax
  003ce	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003db	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  003df	50		 push	 eax
  003e0	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@DNFDPMM@?$FLQuest?$FN?5Too?5many?5have?5quest?5ite@
  003e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003eb	83 c4 14	 add	 esp, 20			; 00000014H

; 4506 : 						gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), itemcnt);
; 4507 : 				//GCServerMsgStringSend("    ", aIndex, 1);
; 4508 : 				pResult.result = 0xFF;

  003ee	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4509 : 				pResult.h.size -= ITEM_BUFFER_SIZE;

  003f2	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  003f6	83 e8 05	 sub	 eax, 5
  003f9	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4510 : 				
; 4511 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  003fc	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00400	50		 push	 eax
  00401	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00404	51		 push	 ecx
  00405	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00408	52		 push	 edx
  00409	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0040e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4512 : 				return;

  00411	e9 5d 0d 00 00	 jmp	 $LN1@CGItemGetR
$LN21@CGItemGetR:

; 4513 : 			}
; 4514 : 		}
; 4515 : #endif
; 4516 : #endif	// MODIFY_QUEST_MONSTER_KILL_COUNT_BUGFIX_20070704
; 4517 : 
; 4518 : #ifdef RING_EVENT_ITEMBOX_20031124		//  -  (-, -1)
; 4519 : 
; 4520 : 	#ifndef FOR_ONAIR
; 4521 : 	#if TESTSERVER != 1
; 4522 : 		if ( lpItem->m_Type == MAKE_ITEMNUM(13, 20) ) {

  00416	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00419	0f bf 70 0a	 movsx	 esi, WORD PTR [eax+10]
  0041d	6a 14		 push	 20			; 00000014H
  0041f	6a 0d		 push	 13			; 0000000dH
  00421	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00426	83 c4 08	 add	 esp, 8
  00429	3b f0		 cmp	 esi, eax
  0042b	0f 85 21 01 00
	00		 jne	 $LN2@CGItemGetR

; 4523 : 			switch(lpItem->m_Level) {

  00431	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00434	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00438	89 8d a0 fe ff
	ff		 mov	 DWORD PTR tv303[ebp], ecx
  0043e	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv303[ebp], 0
  00445	74 12		 je	 SHORT $LN23@CGItemGetR
  00447	83 bd a0 fe ff
	ff 01		 cmp	 DWORD PTR tv303[ebp], 1
  0044e	0f 84 d6 00 00
	00		 je	 $LN25@CGItemGetR
  00454	e9 f9 00 00 00	 jmp	 $LN2@CGItemGetR
$LN23@CGItemGetR:

; 4524 : 			case 0 :	//  
; 4525 : 				{
; 4526 : #ifdef MODIFY_MAGICIARINGRING_TRADE_BUGFIX_20070328	//     
; 4527 : 					int itemcnt = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_ITEM_INDEX, lpItem->m_Type%MAX_ITEM_INDEX, lpItem->m_Level);

  00459	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0045c	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00460	51		 push	 ecx
  00461	8b 55 a0	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00464	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  00468	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0046d	79 05		 jns	 SHORT $LN76@CGItemGetR
  0046f	48		 dec	 eax
  00470	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00473	40		 inc	 eax
$LN76@CGItemGetR:
  00474	50		 push	 eax
  00475	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00478	0f bf 41 0a	 movsx	 eax, WORD PTR [ecx+10]
  0047c	99		 cdq
  0047d	83 e2 1f	 and	 edx, 31			; 0000001fH
  00480	03 c2		 add	 eax, edx
  00482	c1 f8 05	 sar	 eax, 5
  00485	50		 push	 eax
  00486	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00489	52		 push	 edx
  0048a	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  0048f	83 c4 10	 add	 esp, 16			; 00000010H
  00492	89 45 98	 mov	 DWORD PTR _itemcnt$13[ebp], eax

; 4528 : 					if( itemcnt > 0 )

  00495	83 7d 98 00	 cmp	 DWORD PTR _itemcnt$13[ebp], 0
  00499	0f 8e 89 00 00
	00		 jle	 $LN24@CGItemGetR

; 4529 : 					{
; 4530 : 						LogAdd("[Ring Event] Too many have Magician's Ring [%s][%s] (Name:%s, Count:%d)", 

  0049f	8b 45 98	 mov	 eax, DWORD PTR _itemcnt$13[ebp]
  004a2	50		 push	 eax
  004a3	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  004a6	83 c1 04	 add	 ecx, 4
  004a9	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  004ae	50		 push	 eax
  004af	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  004b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004bc	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  004c0	50		 push	 eax
  004c1	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  004c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ce	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  004d2	50		 push	 eax
  004d3	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magi@
  004d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004de	83 c4 14	 add	 esp, 20			; 00000014H

; 4531 : 								gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), itemcnt);
; 4532 : 						pResult.result = 0xFF;

  004e1	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4533 : 						pResult.h.size -= ITEM_BUFFER_SIZE;

  004e5	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  004e9	83 e8 05	 sub	 eax, 5
  004ec	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4534 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  004ef	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  004f3	50		 push	 eax
  004f4	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  004f7	51		 push	 ecx
  004f8	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  004fb	52		 push	 edx
  004fc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00501	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4535 : 
; 4536 : 						GCServerMsgStringSend(lMsg.Get(1210), aIndex, 1);		// "        ."

  00504	6a 01		 push	 1
  00506	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00509	50		 push	 eax
  0050a	68 ba 04 00 00	 push	 1210			; 000004baH
  0050f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00514	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0051a	50		 push	 eax
  0051b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00520	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4537 : 						return;

  00523	e9 4b 0c 00 00	 jmp	 $LN1@CGItemGetR
$LN24@CGItemGetR:

; 4538 : 					}
; 4539 : 				}
; 4540 : #endif
; 4541 : 				break;

  00528	eb 28		 jmp	 SHORT $LN2@CGItemGetR
$LN25@CGItemGetR:

; 4542 : 			case 1 :	//  
; 4543 : 				{
; 4544 : #ifndef FOR_ONAIR
; 4545 : #if TESTSERVER != 1
; 4546 : 					
; 4547 : 					pResult.result = 0xFF;

  0052a	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4548 : 					pResult.h.size -= ITEM_BUFFER_SIZE;

  0052e	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00532	83 e8 05	 sub	 eax, 5
  00535	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4549 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00538	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0053c	50		 push	 eax
  0053d	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00540	51		 push	 ecx
  00541	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00544	52		 push	 edx
  00545	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0054a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4550 : 					return;

  0054d	e9 21 0c 00 00	 jmp	 $LN1@CGItemGetR
$LN2@CGItemGetR:

; 4551 : #endif
; 4552 : #endif
; 4553 : 				}
; 4554 : 				break;
; 4555 : 			}
; 4556 : 		}
; 4557 : 	#endif
; 4558 : 	#endif
; 4559 : #endif
; 4560 : 
; 4561 : 		
; 4562 : #ifdef MU_CHN_THANKS_RING_EVENT_20040908	//   -   
; 4563 : 	#ifndef FOR_ONAIR
; 4564 : 	#if TESTSERVER != 1
; 4565 : 		if ( lpItem->m_Type == MAKE_ITEMNUM(13, 20) ) {
; 4566 : 			switch(lpItem->m_Level) {
; 4567 : 			case 3 :	//  
; 4568 : 				{
; 4569 : 					int itemcnt = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_ITEM_INDEX, lpItem->m_Type%MAX_ITEM_INDEX, lpItem->m_Level);
; 4570 : 					if( itemcnt > 0 )
; 4571 : 					{
; 4572 : 						LogAdd("[China Ring Event] Too many have Ring of Glory [%s][%s] (Name:%s, Count:%d)", 
; 4573 : 								gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), itemcnt);
; 4574 : 						pResult.result = 0xFF;
; 4575 : 						pResult.h.size -= ITEM_BUFFER_SIZE;
; 4576 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4577 : 
; 4578 : 						GCServerMsgStringSend(lMsg.Get(1210), aIndex, 1);		// "        ."
; 4579 : 						return;
; 4580 : 					}
; 4581 : 				}
; 4582 : 				break;
; 4583 : 			}
; 4584 : 		}
; 4585 : 	#endif
; 4586 : 	#endif
; 4587 : #endif
; 4588 : 
; 4589 : 
; 4590 : #ifdef FRIENDSHIP_EVENT_RING_BOX_20040211		//   -     
; 4591 : 	#ifndef FOR_ONAIR
; 4592 : 	#if TESTSERVER != 1
; 4593 : 
; 4594 : 		if (lpItem->m_Type == MAKE_ITEMNUM(13, 20) &&

  00552	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00555	0f bf 70 0a	 movsx	 esi, WORD PTR [eax+10]
  00559	6a 14		 push	 20			; 00000014H
  0055b	6a 0d		 push	 13			; 0000000dH
  0055d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00562	83 c4 08	 add	 esp, 8
  00565	3b f0		 cmp	 esi, eax
  00567	75 34		 jne	 SHORT $LN26@CGItemGetR
  00569	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0056c	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00570	83 f9 02	 cmp	 ecx, 2
  00573	75 28		 jne	 SHORT $LN26@CGItemGetR

; 4595 : 			lpItem->m_Level == 2
; 4596 : 			) 
; 4597 : 		{
; 4598 : 			pResult.result = 0xFF;

  00575	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4599 : 			pResult.h.size -= ITEM_BUFFER_SIZE;

  00579	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0057d	83 e8 05	 sub	 eax, 5
  00580	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4600 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00583	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00587	50		 push	 eax
  00588	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0058b	51		 push	 ecx
  0058c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0058f	52		 push	 edx
  00590	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00595	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4601 : 			return;

  00598	e9 d6 0b 00 00	 jmp	 $LN1@CGItemGetR
$LN26@CGItemGetR:

; 4602 : 		}
; 4603 : 
; 4604 : 	#endif
; 4605 : 	#endif
; 4606 : #endif
; 4607 : 		
; 4608 : #ifdef KANTURU_MOONSTONEPENDANT_20060804		//  - 1  . 20060823
; 4609 : 		if( lpItem->m_Type == MAKE_ITEMNUM( 13, 38 ) )
; 4610 : 		{	
; 4611 : 			int itemcnt = gObjGetItemCountInIventory( aIndex, lpItem->m_Type / MAX_ITEM_INDEX, lpItem->m_Type % MAX_ITEM_INDEX, lpItem->m_Level );
; 4612 : 			if( itemcnt > 0 )
; 4613 : 			{
; 4614 : 				LogAdd("[ MoonStonePendant ] Too many have MoonStonePendant [%s][%s] ( Name:%s, Count:%d )", 
; 4615 : 						gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), itemcnt);
; 4616 : 				pResult.result = 0xFF;
; 4617 : 				pResult.h.size -= ITEM_BUFFER_SIZE;
; 4618 : 				DataSend( aIndex, ( LPBYTE )&pResult, pResult.h.size );
; 4619 : 
; 4620 : 				GCServerMsgStringSend( lMsg.Get( 3384 ), aIndex, 1 );		// 20060830 WTF  "    ."
; 4621 : 				return;
; 4622 : 			}
; 4623 : 		}
; 4624 : #endif
; 4625 : 		
; 4626 : #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	// 1   
; 4627 : 		if( lpItem->m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 4628 : 		{	
; 4629 : 			int itemcnt = gObjGetItemCountInIventory( aIndex, lpItem->m_Type / MAX_ITEM_INDEX, lpItem->m_Type % MAX_ITEM_INDEX, lpItem->m_Level );
; 4630 : 			if( itemcnt > 0 )
; 4631 : 			{
; 4632 : 				LogAdd("[ ChangeRing ] Too many have ChangeRing [%s][%s] ( Name:%s, Count:%d )", 
; 4633 : 						gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), itemcnt);
; 4634 : 				pResult.result = 0xFF;
; 4635 : 				pResult.h.size -= ITEM_BUFFER_SIZE;
; 4636 : 				DataSend( aIndex, ( LPBYTE )&pResult, pResult.h.size );
; 4637 : 
; 4638 : 				GCServerMsgStringSend( lMsg.Get( 3391 ), aIndex, 1 );		// 20060830 WTF  "    ."
; 4639 : 				return;
; 4640 : 			}
; 4641 : 		}
; 4642 : #endif
; 4643 : 
; 4644 : 		type = lpItem->m_Type;

  0059d	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  005a0	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  005a4	89 4d e4	 mov	 DWORD PTR _type$[ebp], ecx

; 4645 : 		level = lpItem->m_Level;

  005a7	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  005aa	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  005ae	89 4d e0	 mov	 DWORD PTR _level$[ebp], ecx

; 4646 : 		special = lpItem->m_Special[0];

  005b1	b8 01 00 00 00	 mov	 eax, 1
  005b6	6b c8 00	 imul	 ecx, eax, 0
  005b9	8b 55 a0	 mov	 edx, DWORD PTR _lpItem$[ebp]
  005bc	0f b6 44 0a 35	 movzx	 eax, BYTE PTR [edx+ecx+53]
  005c1	89 45 dc	 mov	 DWORD PTR _special$[ebp], eax

; 4647 : 		Noption = lpItem->m_NewOption;

  005c4	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  005c7	0f b6 48 7f	 movzx	 ecx, BYTE PTR [eax+127]
  005cb	89 4d d8	 mov	 DWORD PTR _Noption$[ebp], ecx

; 4648 : 
; 4649 : 		strcpy( szItemName, lpItem->GetName());

  005ce	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  005d1	83 c1 04	 add	 ecx, 4
  005d4	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  005d9	50		 push	 eax
  005da	8d 45 a4	 lea	 eax, DWORD PTR _szItemName$[ebp]
  005dd	50		 push	 eax
  005de	e8 00 00 00 00	 call	 _strcpy
  005e3	83 c4 08	 add	 esp, 8

; 4650 : 
; 4651 : 		// ..
; 4652 : 		if( lpItem->m_Type == GOLD_TYPE_INDEX )

  005e6	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  005e9	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  005ed	81 f9 cf 01 00
	00		 cmp	 ecx, 463		; 000001cfH
  005f3	0f 85 43 02 00
	00		 jne	 $LN27@CGItemGetR

; 4653 : 		{
; 4654 : 			if( MapC[map_num].ItemGive(aIndex, item_num) == TRUE )

  005f9	6a 00		 push	 0
  005fb	8b 45 f8	 mov	 eax, DWORD PTR _item_num$[ebp]
  005fe	50		 push	 eax
  005ff	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00602	51		 push	 ecx
  00603	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _map_num$[ebp], 328844
  0060a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00610	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00615	83 f8 01	 cmp	 eax, 1
  00618	0f 85 04 02 00
	00		 jne	 $LN29@CGItemGetR

; 4655 : 			{
; 4656 : 				
; 4657 : #ifdef MODIFY_ZEN_MAX_20040414
; 4658 : 				if( !gObjCheckMaxZen( aIndex, lpItem->m_BuyMoney ) )

  0061e	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00621	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00624	51		 push	 ecx
  00625	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00628	52		 push	 edx
  00629	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  0062e	83 c4 08	 add	 esp, 8
  00631	85 c0		 test	 eax, eax
  00633	0f 85 16 01 00
	00		 jne	 $LN32@CGItemGetR

; 4659 : 				{
; 4660 : 					if( gObj[aIndex].Money < MAX_ZEN )

  00639	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00640	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00646	81 bc 01 b0 00
	00 00 00 94 35
	77		 cmp	 DWORD PTR [ecx+eax+176], 2000000000 ; 77359400H
  00651	0f 8d d0 00 00
	00		 jge	 $LN31@CGItemGetR

; 4661 : 					{
; 4662 : 						WORD hiWord, loWord;
; 4663 : 						
; 4664 : 						gObj[aIndex].Money = MAX_ZEN;

  00657	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0065e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00664	c7 84 01 b0 00
	00 00 00 94 35
	77		 mov	 DWORD PTR [ecx+eax+176], 2000000000 ; 77359400H

; 4665 : 						pResult.result = 0xFE;

  0066f	c6 45 eb fe	 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH

; 4666 : 						hiWord = HIWORD(gObj[aIndex].Money);

  00673	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0067a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00680	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  00687	c1 ea 10	 shr	 edx, 16			; 00000010H
  0068a	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00690	66 89 55 94	 mov	 WORD PTR _hiWord$12[ebp], dx

; 4667 : 						loWord = LOWORD(gObj[aIndex].Money);

  00694	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0069b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006a1	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  006a8	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  006ae	66 89 55 90	 mov	 WORD PTR _loWord$11[ebp], dx

; 4668 : 						pResult.Data[0] = HIBYTE(hiWord);

  006b2	0f b7 45 94	 movzx	 eax, WORD PTR _hiWord$12[ebp]
  006b6	c1 e8 08	 shr	 eax, 8
  006b9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006be	b9 01 00 00 00	 mov	 ecx, 1
  006c3	6b d1 00	 imul	 edx, ecx, 0
  006c6	88 44 15 ec	 mov	 BYTE PTR _pResult$[ebp+edx+4], al

; 4669 : 						pResult.Data[1] = LOBYTE(hiWord);

  006ca	0f b7 45 94	 movzx	 eax, WORD PTR _hiWord$12[ebp]
  006ce	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006d3	b9 01 00 00 00	 mov	 ecx, 1
  006d8	c1 e1 00	 shl	 ecx, 0
  006db	88 44 0d ec	 mov	 BYTE PTR _pResult$[ebp+ecx+4], al

; 4670 : 						pResult.Data[2] = HIBYTE(loWord);

  006df	0f b7 45 90	 movzx	 eax, WORD PTR _loWord$11[ebp]
  006e3	c1 e8 08	 shr	 eax, 8
  006e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006eb	b9 01 00 00 00	 mov	 ecx, 1
  006f0	d1 e1		 shl	 ecx, 1
  006f2	88 44 0d ec	 mov	 BYTE PTR _pResult$[ebp+ecx+4], al

; 4671 : 						pResult.Data[3] = LOBYTE(loWord);

  006f6	0f b7 45 90	 movzx	 eax, WORD PTR _loWord$11[ebp]
  006fa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006ff	b9 01 00 00 00	 mov	 ecx, 1
  00704	6b d1 03	 imul	 edx, ecx, 3
  00707	88 44 15 ec	 mov	 BYTE PTR _pResult$[ebp+edx+4], al

; 4672 : 
; 4673 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0070b	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0070f	50		 push	 eax
  00710	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00713	51		 push	 ecx
  00714	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00717	52		 push	 edx
  00718	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0071d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4674 : 
; 4675 : 						return;

  00720	e9 4e 0a 00 00	 jmp	 $LN1@CGItemGetR

; 4676 : 					}

  00725	eb 28		 jmp	 SHORT $LN32@CGItemGetR
$LN31@CGItemGetR:

; 4677 : 					else
; 4678 : 					{
; 4679 : 						pResult.result = 0xFF;

  00727	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 4680 : 						pResult.h.size -= ITEM_BUFFER_SIZE;

  0072b	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0072f	83 e8 05	 sub	 eax, 5
  00732	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4681 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00735	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00739	50		 push	 eax
  0073a	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0073d	51		 push	 ecx
  0073e	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00741	52		 push	 edx
  00742	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00747	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4682 : 						return;

  0074a	e9 24 0a 00 00	 jmp	 $LN1@CGItemGetR
$LN32@CGItemGetR:

; 4683 : 					}
; 4684 : 
; 4685 : 				}
; 4686 : #endif
; 4687 : 				WORD hiWord, loWord;
; 4688 : 
; 4689 : 				gObj[aIndex].Money += lpItem->m_BuyMoney;

  0074f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00756	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0075c	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  00763	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00766	03 50 68	 add	 edx, DWORD PTR [eax+104]
  00769	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00770	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00775	89 94 08 b0 00
	00 00		 mov	 DWORD PTR [eax+ecx+176], edx

; 4690 : 				pResult.result = 0xFE;

  0077c	c6 45 eb fe	 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH

; 4691 : 				hiWord = HIWORD(gObj[aIndex].Money);

  00780	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00787	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0078d	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  00794	c1 ea 10	 shr	 edx, 16			; 00000010H
  00797	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0079d	66 89 55 8c	 mov	 WORD PTR _hiWord$10[ebp], dx

; 4692 : 				loWord = LOWORD(gObj[aIndex].Money);

  007a1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007ae	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  007b5	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  007bb	66 89 55 88	 mov	 WORD PTR _loWord$9[ebp], dx

; 4693 : 				pResult.Data[0] = HIBYTE(hiWord);

  007bf	0f b7 45 8c	 movzx	 eax, WORD PTR _hiWord$10[ebp]
  007c3	c1 e8 08	 shr	 eax, 8
  007c6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007cb	b9 01 00 00 00	 mov	 ecx, 1
  007d0	6b d1 00	 imul	 edx, ecx, 0
  007d3	88 44 15 ec	 mov	 BYTE PTR _pResult$[ebp+edx+4], al

; 4694 : 				pResult.Data[1] = LOBYTE(hiWord);

  007d7	0f b7 45 8c	 movzx	 eax, WORD PTR _hiWord$10[ebp]
  007db	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007e0	b9 01 00 00 00	 mov	 ecx, 1
  007e5	c1 e1 00	 shl	 ecx, 0
  007e8	88 44 0d ec	 mov	 BYTE PTR _pResult$[ebp+ecx+4], al

; 4695 : 				pResult.Data[2] = HIBYTE(loWord);

  007ec	0f b7 45 88	 movzx	 eax, WORD PTR _loWord$9[ebp]
  007f0	c1 e8 08	 shr	 eax, 8
  007f3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007f8	b9 01 00 00 00	 mov	 ecx, 1
  007fd	d1 e1		 shl	 ecx, 1
  007ff	88 44 0d ec	 mov	 BYTE PTR _pResult$[ebp+ecx+4], al

; 4696 : 				pResult.Data[3] = LOBYTE(loWord);

  00803	0f b7 45 88	 movzx	 eax, WORD PTR _loWord$9[ebp]
  00807	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0080c	b9 01 00 00 00	 mov	 ecx, 1
  00811	6b d1 03	 imul	 edx, ecx, 3
  00814	88 44 15 ec	 mov	 BYTE PTR _pResult$[ebp+edx+4], al

; 4697 : 
; 4698 : 				pResult.h.size -= (ITEM_BUFFER_SIZE-MONEY_BUFFER_SIZE);

  00818	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0081c	83 e8 01	 sub	 eax, 1
  0081f	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al
$LN29@CGItemGetR:

; 4699 : 
; 4700 : 				//LogAddTD("[%s][%s]   (:%d/%d)",gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->m_BuyMoney, gObj[aIndex].Money);
; 4701 : 			}
; 4702 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00822	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00826	50		 push	 eax
  00827	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0082a	51		 push	 ecx
  0082b	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0082e	52		 push	 edx
  0082f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00834	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4703 : 		}

  00837	e9 16 09 00 00	 jmp	 $LN41@CGItemGetR
$LN27@CGItemGetR:

; 4704 : 		else 
; 4705 : 		{
; 4706 : 
; 4707 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 4708 : 			//       .
; 4709 : 
; 4710 : 			// 1.  
; 4711 : 
; 4712 : 			if ( lpItem->m_Type == MAKE_ITEMNUM(13, 32) ) 
; 4713 : 			{
; 4714 : 				int iInventoryIndex = gObjOverlapItemUsingDur( lpItem, map_num, item_num, aIndex, MAX_OVERLAP_FENRIR_MIX_STUFF_01, MAKE_ITEMNUM(13,32), 0);
; 4715 : 
; 4716 : 				if( CHECK_LIMIT(iInventoryIndex, MAX_INVENTORY) )
; 4717 : 				{
; 4718 : 					//     .
; 4719 : 					pResult.result	= 0xFD;				
; 4720 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4721 : 					gObj[aIndex].pInventory[iInventoryIndex].m_Durability += lpItem->m_Durability;
; 4722 : 					GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);
; 4723 : 
; 4724 : 					return;
; 4725 : 				}
; 4726 : 				else
; 4727 : 				{
; 4728 : 					
; 4729 : 				}
; 4730 : 				
; 4731 : 			}
; 4732 : 			
; 4733 : 			// 2.  
; 4734 : 			if ( lpItem->m_Type == MAKE_ITEMNUM(13, 33) ) 
; 4735 : 			{
; 4736 : 				int iInventoryIndex = gObjOverlapItemUsingDur( lpItem, map_num, item_num, aIndex, MAX_OVERLAP_FENRIR_MIX_STUFF_02, MAKE_ITEMNUM(13,33), 0);
; 4737 : 
; 4738 : 				if( CHECK_LIMIT(iInventoryIndex, MAX_INVENTORY) )
; 4739 : 				{
; 4740 : 					//     .
; 4741 : 					pResult.result	= 0xFD;				
; 4742 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4743 : 					gObj[aIndex].pInventory[iInventoryIndex].m_Durability += lpItem->m_Durability;
; 4744 : 					GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);
; 4745 : 
; 4746 : 					return;
; 4747 : 				}
; 4748 : 				else
; 4749 : 				{
; 4750 : 
; 4751 : 				}
; 4752 : 				
; 4753 : 			}
; 4754 : 
; 4755 : 			// 3.  
; 4756 : 			if ( lpItem->m_Type == MAKE_ITEMNUM(13, 34) ) 
; 4757 : 			{
; 4758 : 				int iInventoryIndex = gObjOverlapItemUsingDur( lpItem, map_num, item_num, aIndex, MAX_OVERLAP_FENRIR_MIX_STUFF_03, MAKE_ITEMNUM(13,34), 0);
; 4759 : 
; 4760 : 				if( CHECK_LIMIT(iInventoryIndex, MAX_INVENTORY) )
; 4761 : 				{
; 4762 : 					//     .
; 4763 : 					pResult.result	= 0xFD;				
; 4764 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4765 : 					gObj[aIndex].pInventory[iInventoryIndex].m_Durability += lpItem->m_Durability;
; 4766 : 					GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);
; 4767 : 
; 4768 : 					return;
; 4769 : 				}
; 4770 : 				else
; 4771 : 				{
; 4772 : 					
; 4773 : 				}
; 4774 : 				
; 4775 : 			}
; 4776 : 
; 4777 : #endif // ADD_ITEM_FENRIR_01_20051110
; 4778 : 
; 4779 : #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 4780 : 			//   
; 4781 : 			if ( lpItem->m_Type == MAKE_ITEMNUM(14, 70)
; 4782 : 				|| lpItem->m_Type == MAKE_ITEMNUM(14, 71)
; 4783 : 				|| lpItem->m_Type == MAKE_ITEMNUM(14, 94)
; 4784 : #ifdef ADD_ELITE_SD_POTION_20090918
; 4785 : 				|| lpItem->m_Type == MAKE_ITEMNUM(14, 133)
; 4786 : #endif // ADD_ELITE_SD_POTION_20090918
; 4787 : 				)
; 4788 : 			{
; 4789 : 				int iInventoryIndex = gObjOverlapItemUsingDur( lpItem, map_num, item_num, aIndex, MAX_OVERLAP_ELITE_POTION, lpItem->m_Type, 0);
; 4790 : 				if( CHECK_LIMIT(iInventoryIndex, MAX_INVENTORY) )
; 4791 : 				{
; 4792 : 					//     .
; 4793 : 					pResult.result	= 0xFD;				
; 4794 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4795 : 					gObj[aIndex].pInventory[iInventoryIndex].m_Durability += lpItem->m_Durability;
; 4796 : 					GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);
; 4797 : 					
; 4798 : 					return;
; 4799 : 				}
; 4800 : 			}
; 4801 : #endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318			
; 4802 : 
; 4803 : #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 4804 : 			// (, , )
; 4805 : 			if ( lpItem->m_Type == MAKE_ITEMNUM(14, 88) 
; 4806 : 				|| lpItem->m_Type == MAKE_ITEMNUM(14, 89) 
; 4807 : 				|| lpItem->m_Type == MAKE_ITEMNUM(14, 90) 
; 4808 : 				|| lpItem->m_Type == MAKE_ITEMNUM(14, 85)	// 
; 4809 : 				|| lpItem->m_Type == MAKE_ITEMNUM(14, 86)	// 
; 4810 : 				|| lpItem->m_Type == MAKE_ITEMNUM(14, 87)	// 
; 4811 : 				)
; 4812 : 			{
; 4813 : 				int nMaxOverlapped = 1;
; 4814 : 				switch (lpItem->m_Type)
; 4815 : 				{
; 4816 : 				case MAKE_ITEMNUM2(14, 88):	nMaxOverlapped = MAX_OVERLAP_CHERRYBLOSSOM_WHITE;	break;
; 4817 : 				case MAKE_ITEMNUM2(14, 89):	nMaxOverlapped = MAX_OVERLAP_CHERRYBLOSSOM_RED;		break;
; 4818 : 				case MAKE_ITEMNUM2(14, 90):	nMaxOverlapped = MAX_OVERLAP_CHERRYBLOSSOM_GOLD;	break;
; 4819 : 				case MAKE_ITEMNUM2(14, 85):	nMaxOverlapped = MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT;	break;
; 4820 : 				case MAKE_ITEMNUM2(14, 86):	nMaxOverlapped = MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT;	break;
; 4821 : 				case MAKE_ITEMNUM2(14, 87):	nMaxOverlapped = MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT;	break;
; 4822 : 				}
; 4823 : 				
; 4824 : 				int iInventoryIndex = gObjOverlapItemUsingDur( lpItem, map_num, item_num, aIndex, nMaxOverlapped, lpItem->m_Type, 0);
; 4825 : 				if( CHECK_LIMIT(iInventoryIndex, MAX_INVENTORY) )
; 4826 : 				{
; 4827 : 					//     .
; 4828 : 					pResult.result	= 0xFD;				
; 4829 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4830 : 					gObj[aIndex].pInventory[iInventoryIndex].m_Durability += lpItem->m_Durability;
; 4831 : 					GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);
; 4832 : 					
; 4833 : 					return;
; 4834 : 				}
; 4835 : 			}
; 4836 : #endif // ADD_EVENT_CHERRYBLOSSOM_20080312				
; 4837 : 
; 4838 : #ifdef ADD_NEW_MAP_KALIMA_20040518					//      .
; 4839 : 			if (lpItem->m_Type == MAKE_ITEMNUM(14, 29)) {

  0083c	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0083f	0f bf 70 0a	 movsx	 esi, WORD PTR [eax+10]
  00843	6a 1d		 push	 29			; 0000001dH
  00845	6a 0e		 push	 14			; 0000000eH
  00847	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0084c	83 c4 08	 add	 esp, 8
  0084f	3b f0		 cmp	 esi, eax
  00851	0f 85 1a 04 00
	00		 jne	 $LN5@CGItemGetR

; 4840 : 
; 4841 : 				for (INT iLoop = 0 ; iLoop < MAX_INVENTORY ; iLoop++) {

  00857	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _iLoop$8[ebp], 0
  0085e	eb 09		 jmp	 SHORT $LN6@CGItemGetR
$LN4@CGItemGetR:
  00860	8b 45 84	 mov	 eax, DWORD PTR _iLoop$8[ebp]
  00863	83 c0 01	 add	 eax, 1
  00866	89 45 84	 mov	 DWORD PTR _iLoop$8[ebp], eax
$LN6@CGItemGetR:
  00869	83 7d 84 4c	 cmp	 DWORD PTR _iLoop$8[ebp], 76 ; 0000004cH
  0086d	0f 8d fe 03 00
	00		 jge	 $LN5@CGItemGetR

; 4842 : 
; 4843 : #ifdef MODIFY_KALIMA_KUNDUNMARK_DROP_01_20040906
; 4844 : 					INT iInventoryIndex = g_KalimaGate.CheckOverlapKundunMark(aIndex, lpItem->m_Level);

  00873	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00876	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  0087a	51		 push	 ecx
  0087b	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0087e	52		 push	 edx
  0087f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  00884	e8 00 00 00 00	 call	 ?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z ; CKalimaGate::CheckOverlapKundunMark
  00889	89 45 80	 mov	 DWORD PTR _iInventoryIndex$7[ebp], eax

; 4845 : #else
; 4846 : 					INT iInventoryIndex = g_KalimaGate.CheckOverlapKundunMark(aIndex);
; 4847 : #endif
; 4848 : 					if (CHECK_LIMIT(iInventoryIndex, MAX_INVENTORY)) {

  0088c	83 7d 80 00	 cmp	 DWORD PTR _iInventoryIndex$7[ebp], 0
  00890	7d 0c		 jge	 SHORT $LN64@CGItemGetR
  00892	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv578[ebp], 0
  0089c	eb 28		 jmp	 SHORT $LN65@CGItemGetR
$LN64@CGItemGetR:
  0089e	83 7d 80 4b	 cmp	 DWORD PTR _iInventoryIndex$7[ebp], 75 ; 0000004bH
  008a2	7e 0c		 jle	 SHORT $LN62@CGItemGetR
  008a4	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv577[ebp], 0
  008ae	eb 0a		 jmp	 SHORT $LN63@CGItemGetR
$LN62@CGItemGetR:
  008b0	c7 85 9c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv577[ebp], 1
$LN63@CGItemGetR:
  008ba	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv577[ebp]
  008c0	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv578[ebp], eax
$LN65@CGItemGetR:
  008c6	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv578[ebp], 0
  008cd	0f 84 97 03 00
	00		 je	 $LN34@CGItemGetR

; 4849 : 						//         () + .
; 4850 : 						if( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  008d3	6a 01		 push	 1
  008d5	8b 45 f8	 mov	 eax, DWORD PTR _item_num$[ebp]
  008d8	50		 push	 eax
  008d9	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  008dc	51		 push	 ecx
  008dd	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _map_num$[ebp], 328844
  008e4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  008ea	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  008ef	83 f8 01	 cmp	 eax, 1
  008f2	0f 85 70 03 00
	00		 jne	 $LN36@CGItemGetR

; 4851 : 						{
; 4852 : 							//     Get   .
; 4853 : 							BYTE NewOption[8];
; 4854 : 
; 4855 : 							ItemIsBufExOption(NewOption, lpItem);

  008f8	83 7d a0 00	 cmp	 DWORD PTR _lpItem$[ebp], 0
  008fc	74 0e		 je	 SHORT $LN66@CGItemGetR
  008fe	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00901	83 c0 04	 add	 eax, 4
  00904	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv592[ebp], eax
  0090a	eb 0a		 jmp	 SHORT $LN67@CGItemGetR
$LN66@CGItemGetR:
  0090c	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv592[ebp], 0
$LN67@CGItemGetR:
  00916	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR tv592[ebp]
  0091c	51		 push	 ecx
  0091d	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _NewOption$6[ebp]
  00923	52		 push	 edx
  00924	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  00929	83 c4 08	 add	 esp, 8

; 4856 : 
; 4857 : #ifdef MODIFY_LOG_SYSTEM_2_3_20060828
; 4858 : 							LogAddTD(lMsg.Get(477),
; 4859 : 								gObj[aIndex].AccountID, 
; 4860 : 								gObj[aIndex].Name, 
; 4861 : 								map_num, 
; 4862 : 								gObj[aIndex].X, 
; 4863 : 								gObj[aIndex].Y, 
; 4864 : 								lpItem->m_Number, 
; 4865 : 								szItemName, 
; 4866 : 								type, 
; 4867 : 								level, 
; 4868 : 								lpItem->m_Option1, 
; 4869 : 								lpItem->m_Option2, 
; 4870 : 								lpItem->m_Option3,
; 4871 : 								(int)lpItem->m_Durability,
; 4872 : 								NewOption[0],
; 4873 : 								NewOption[1],
; 4874 : 								NewOption[2],
; 4875 : 								NewOption[3],
; 4876 : 								NewOption[4],
; 4877 : 								NewOption[5],
; 4878 : 								NewOption[6],
; 4879 : 								lpItem->m_SetOption,
; 4880 : 								lpItem->m_ItemOptionEx>>7,
; 4881 : 								g_kJewelOfHarmonySystem.GetItemStrengthenOption( lpItem ),
; 4882 : 								g_kJewelOfHarmonySystem.GetItemOptionLevel( lpItem )
; 4883 : 								);
; 4884 : #else
; 4885 : 							LogAddTD(lMsg.Get(477),

  0092c	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0092f	0f b6 88 96 00
	00 00		 movzx	 ecx, BYTE PTR [eax+150]
  00936	51		 push	 ecx
  00937	ba 01 00 00 00	 mov	 edx, 1
  0093c	6b c2 06	 imul	 eax, edx, 6
  0093f	0f b6 8c 05 78
	ff ff ff	 movzx	 ecx, BYTE PTR _NewOption$6[ebp+eax]
  00947	51		 push	 ecx
  00948	ba 01 00 00 00	 mov	 edx, 1
  0094d	6b c2 05	 imul	 eax, edx, 5
  00950	0f b6 8c 05 78
	ff ff ff	 movzx	 ecx, BYTE PTR _NewOption$6[ebp+eax]
  00958	51		 push	 ecx
  00959	ba 01 00 00 00	 mov	 edx, 1
  0095e	c1 e2 02	 shl	 edx, 2
  00961	0f b6 84 15 78
	ff ff ff	 movzx	 eax, BYTE PTR _NewOption$6[ebp+edx]
  00969	50		 push	 eax
  0096a	b9 01 00 00 00	 mov	 ecx, 1
  0096f	6b d1 03	 imul	 edx, ecx, 3
  00972	0f b6 84 15 78
	ff ff ff	 movzx	 eax, BYTE PTR _NewOption$6[ebp+edx]
  0097a	50		 push	 eax
  0097b	b9 01 00 00 00	 mov	 ecx, 1
  00980	d1 e1		 shl	 ecx, 1
  00982	0f b6 94 0d 78
	ff ff ff	 movzx	 edx, BYTE PTR _NewOption$6[ebp+ecx]
  0098a	52		 push	 edx
  0098b	b8 01 00 00 00	 mov	 eax, 1
  00990	c1 e0 00	 shl	 eax, 0
  00993	0f b6 8c 05 78
	ff ff ff	 movzx	 ecx, BYTE PTR _NewOption$6[ebp+eax]
  0099b	51		 push	 ecx
  0099c	ba 01 00 00 00	 mov	 edx, 1
  009a1	6b c2 00	 imul	 eax, edx, 0
  009a4	0f b6 8c 05 78
	ff ff ff	 movzx	 ecx, BYTE PTR _NewOption$6[ebp+eax]
  009ac	51		 push	 ecx
  009ad	8b 55 a0	 mov	 edx, DWORD PTR _lpItem$[ebp]
  009b0	0f b6 42 7e	 movzx	 eax, BYTE PTR [edx+126]
  009b4	50		 push	 eax
  009b5	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  009b8	0f b6 51 7d	 movzx	 edx, BYTE PTR [ecx+125]
  009bc	52		 push	 edx
  009bd	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  009c0	0f b6 48 7c	 movzx	 ecx, BYTE PTR [eax+124]
  009c4	51		 push	 ecx
  009c5	8b 55 e0	 mov	 edx, DWORD PTR _level$[ebp]
  009c8	52		 push	 edx
  009c9	8b 45 e4	 mov	 eax, DWORD PTR _type$[ebp]
  009cc	50		 push	 eax
  009cd	8d 4d a4	 lea	 ecx, DWORD PTR _szItemName$[ebp]
  009d0	51		 push	 ecx
  009d1	8b 55 a0	 mov	 edx, DWORD PTR _lpItem$[ebp]
  009d4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  009d7	50		 push	 eax
  009d8	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  009df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009e5	0f bf 84 0a 06
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+262]
  009ed	50		 push	 eax
  009ee	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  009f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009fb	0f bf 84 0a 04
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+260]
  00a03	50		 push	 eax
  00a04	8b 4d f4	 mov	 ecx, DWORD PTR _map_num$[ebp]
  00a07	51		 push	 ecx
  00a08	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00a0f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a14	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00a18	51		 push	 ecx
  00a19	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00a20	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a25	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00a29	51		 push	 ecx
  00a2a	68 dd 01 00 00	 push	 477			; 000001ddH
  00a2f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00a34	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00a3a	50		 push	 eax
  00a3b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a41	83 c4 54	 add	 esp, 84			; 00000054H

; 4886 : 								gObj[aIndex].AccountID, 
; 4887 : 								gObj[aIndex].Name, 
; 4888 : 								map_num, 
; 4889 : 								gObj[aIndex].X, 
; 4890 : 								gObj[aIndex].Y, 
; 4891 : 								lpItem->m_Number, 
; 4892 : 								szItemName, 
; 4893 : 								type, 
; 4894 : 								level, 
; 4895 : 								lpItem->m_Option1, 
; 4896 : 								lpItem->m_Option2, 
; 4897 : 								lpItem->m_Option3,
; 4898 : 								NewOption[0],
; 4899 : 								NewOption[1],
; 4900 : 								NewOption[2],
; 4901 : 								NewOption[3],
; 4902 : 								NewOption[4],
; 4903 : 								NewOption[5],
; 4904 : 								NewOption[6],
; 4905 : 								lpItem->m_SetOption
; 4906 : 								);
; 4907 : #endif // MODIFY_LOG_SYSTEM_2_3_20060828
; 4908 : 
; 4909 : 
; 4910 : //							pResult.result	= iInventoryIndex;
; 4911 : 							pResult.result	= 0xFD;				//     .

  00a44	c6 45 eb fd	 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH

; 4912 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00a48	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00a4c	50		 push	 eax
  00a4d	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00a50	51		 push	 ecx
  00a51	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00a54	52		 push	 edx
  00a55	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00a5a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4913 : 							gObj[aIndex].pInventory[iInventoryIndex].m_Durability += lpItem->m_Durability;

  00a5d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a64	69 4d 80 a8 00
	00 00		 imul	 ecx, DWORD PTR _iInventoryIndex$7[ebp], 168
  00a6b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a71	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00a78	8b 55 a0	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00a7b	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00a81	f3 0f 58 42 28	 addss	 xmm0, DWORD PTR [edx+40]
  00a86	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a8d	69 4d 80 a8 00
	00 00		 imul	 ecx, DWORD PTR _iInventoryIndex$7[ebp], 168
  00a94	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a9a	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00aa1	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0

; 4914 : 
; 4915 : 							if (gObj[aIndex].pInventory[iInventoryIndex].m_Durability >= MAX_KALIMAGATE_STONE_OVERLAP) {

  00aa7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00aae	69 4d 80 a8 00
	00 00		 imul	 ecx, DWORD PTR _iInventoryIndex$7[ebp], 168
  00ab5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00abb	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00ac2	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00ac8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@40a00000
  00acf	0f 82 59 01 00
	00		 jb	 $LN37@CGItemGetR

; 4916 : 								//   20    .
; 4917 : 								// ### 20040906 (apple) 10  
; 4918 : 								INT iDurGap = gObj[aIndex].pInventory[iInventoryIndex].m_Durability - MAX_KALIMAGATE_STONE_OVERLAP;

  00ad5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00adc	69 4d 80 a8 00
	00 00		 imul	 ecx, DWORD PTR _iInventoryIndex$7[ebp], 168
  00ae3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ae9	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00af0	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00af6	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40a00000
  00afe	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00b02	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _iDurGap$5[ebp], ecx

; 4919 : 
; 4920 : 								//   (20)  
; 4921 : 								// ### 20040906 (apple) 10 
; 4922 : 								gObjInventoryItemSet(aIndex, iInventoryIndex, 0xFF);

  00b08	68 ff 00 00 00	 push	 255			; 000000ffH
  00b0d	8b 45 80	 mov	 eax, DWORD PTR _iInventoryIndex$7[ebp]
  00b10	50		 push	 eax
  00b11	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00b14	51		 push	 ecx
  00b15	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00b1a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4923 : 								gObj[aIndex].pInventory[iInventoryIndex].Clear();

  00b1d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b24	69 4d 80 a8 00
	00 00		 imul	 ecx, DWORD PTR _iInventoryIndex$7[ebp], 168
  00b2b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b31	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00b38	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 4924 : 								GCInventoryItemDeleteSend(aIndex, iInventoryIndex, 1);

  00b3d	6a 01		 push	 1
  00b3f	0f b6 45 80	 movzx	 eax, BYTE PTR _iInventoryIndex$7[ebp]
  00b43	50		 push	 eax
  00b44	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00b47	51		 push	 ecx
  00b48	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00b4d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4925 : 
; 4926 : #ifdef MODIFY_KALIMA_KUNDUNMARK_DROP_01_20040906
; 4927 : 								//   .
; 4928 : 								ItemSerialCreateSend(

  00b50	6a 00		 push	 0
  00b52	6a 00		 push	 0
  00b54	6a 00		 push	 0
  00b56	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b59	50		 push	 eax
  00b5a	6a 00		 push	 0
  00b5c	6a 00		 push	 0
  00b5e	6a 00		 push	 0
  00b60	6a 00		 push	 0
  00b62	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00b65	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00b69	52		 push	 edx
  00b6a	6a 1c		 push	 28			; 0000001cH
  00b6c	6a 0e		 push	 14			; 0000000eH
  00b6e	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00b73	83 c4 08	 add	 esp, 8
  00b76	50		 push	 eax
  00b77	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b7e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b84	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00b8c	52		 push	 edx
  00b8d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b94	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b9a	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00ba2	52		 push	 edx
  00ba3	68 eb 00 00 00	 push	 235			; 000000ebH
  00ba8	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00bab	50		 push	 eax
  00bac	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00bb1	83 c4 38	 add	 esp, 56			; 00000038H

; 4929 : 									aIndex, 
; 4930 : 									ITEMMAKE_INVENTORY_1CELL, 
; 4931 : 									(BYTE)gObj[aIndex].X, 
; 4932 : 									(BYTE)gObj[aIndex].Y, 
; 4933 : 									ItemGetNumberMake(14, 28), 
; 4934 : 									lpItem->m_Level
; 4935 : 									, (BYTE)0, 0, 0, 0, aIndex);
; 4936 : #else
; 4937 : 								//   .
; 4938 : 								ItemSerialCreateSend(
; 4939 : 									aIndex, 
; 4940 : 									ITEMMAKE_INVENTORY_1CELL, 
; 4941 : 									(BYTE)gObj[aIndex].X, 
; 4942 : 									(BYTE)gObj[aIndex].Y, 
; 4943 : 									ItemGetNumberMake(14, 28), 
; 4944 : 									0, (BYTE)0, 0, 0, 0, aIndex);
; 4945 : 
; 4946 : #endif
; 4947 : 								LogAddTD("[Kalima] [%s][%s] Make Lost Kalima Map (Left Kundun Mark:%d)", 

  00bb4	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _iDurGap$5[ebp]
  00bba	50		 push	 eax
  00bbb	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00bc2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bc8	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00bcc	50		 push	 eax
  00bcd	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00bd4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bda	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00bde	50		 push	 eax
  00bdf	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kal@
  00be4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00bea	83 c4 10	 add	 esp, 16			; 00000010H

; 4948 : 									gObj[aIndex].AccountID,
; 4949 : 									gObj[aIndex].Name,
; 4950 : 									iDurGap
; 4951 : 									);
; 4952 : 
; 4953 : 								if (iDurGap > 0) {			//       .

  00bed	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _iDurGap$5[ebp], 0
  00bf4	7e 36		 jle	 SHORT $LN39@CGItemGetR

; 4954 : 									lpItem->m_State			= OBJST_PLAYING;

  00bf6	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00bf9	c7 80 b0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+176], 2

; 4955 : 									lpItem->Give			= 0;

  00c03	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00c06	c6 80 af 00 00
	00 00		 mov	 BYTE PTR [eax+175], 0

; 4956 : 									lpItem->live			= 1;

  00c0d	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00c10	c6 80 ae 00 00
	00 01		 mov	 BYTE PTR [eax+174], 1

; 4957 : 									lpItem->m_Durability	= iDurGap;

  00c17	f3 0f 2a 85 74
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _iDurGap$5[ebp]
  00c1f	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00c22	f3 0f 11 40 28	 movss	 DWORD PTR [eax+40], xmm0

; 4958 : 									continue;

  00c27	e9 34 fc ff ff	 jmp	 $LN4@CGItemGetR
$LN39@CGItemGetR:

; 4959 : 								}
; 4960 : 							}

  00c2c	eb 35		 jmp	 SHORT $LN38@CGItemGetR
$LN37@CGItemGetR:

; 4961 : 							else {
; 4962 : 								GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);

  00c2e	6a 00		 push	 0
  00c30	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c37	69 4d 80 a8 00
	00 00		 imul	 ecx, DWORD PTR _iInventoryIndex$7[ebp], 168
  00c3e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c44	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00c4b	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00c51	51		 push	 ecx
  00c52	0f b6 55 80	 movzx	 edx, BYTE PTR _iInventoryIndex$7[ebp]
  00c56	52		 push	 edx
  00c57	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00c5a	50		 push	 eax
  00c5b	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00c60	83 c4 10	 add	 esp, 16			; 00000010H
$LN38@CGItemGetR:

; 4963 : 							}
; 4964 : 							return;

  00c63	e9 0b 05 00 00	 jmp	 $LN1@CGItemGetR
$LN36@CGItemGetR:

; 4965 : 						}
; 4966 : 					}

  00c68	eb 02		 jmp	 SHORT $LN35@CGItemGetR
$LN34@CGItemGetR:

; 4967 : 					else {
; 4968 : 						//          .
; 4969 : 						break;

  00c6a	eb 05		 jmp	 SHORT $LN5@CGItemGetR
$LN35@CGItemGetR:

; 4970 : 					}
; 4971 : 				}

  00c6c	e9 ef fb ff ff	 jmp	 $LN4@CGItemGetR
$LN5@CGItemGetR:

; 4972 : 			}
; 4973 : #endif
; 4974 : 
; 4975 : #ifdef MU_CASTLESIEGE_CS_MARKS_20041214		//      .
; 4976 : 			if ((lpItem->m_Type == MAKE_ITEMNUM(14, 21)) && (lpItem->m_Level == 3)) {
; 4977 : 				for (INT iLoop = 0 ; iLoop < MAX_INVENTORY ; iLoop++) {
; 4978 : 					INT iInventoryIndex	= g_CastleSiegeSync.CheckOverlapCsMarks(aIndex);
; 4979 : 					if (CHECK_LIMIT(iInventoryIndex, MAX_INVENTORY)) {
; 4980 : 						INT iItemDur	= gObj[aIndex].pInventory[iInventoryIndex].m_Durability + lpItem->m_Durability;
; 4981 : 						if (iItemDur <= MAX_CS_SYNC_MARKS_OVERLAP) {
; 4982 : 							//    .
; 4983 : 							if( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )
; 4984 : 							{
; 4985 : 								pResult.result	= 0xFD;				//     .
; 4986 : 								DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4987 : 								gObj[aIndex].pInventory[iInventoryIndex].m_Durability += lpItem->m_Durability;
; 4988 : 
; 4989 : 								GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);
; 4990 : 								return;
; 4991 : 							}
; 4992 : 						}
; 4993 : 						else {
; 4994 : 							//   .
; 4995 : 							lpItem->m_Durability	= iItemDur - MAX_CS_SYNC_MARKS_OVERLAP;
; 4996 : 							gObj[aIndex].pInventory[iInventoryIndex].m_Durability = MAX_CS_SYNC_MARKS_OVERLAP;
; 4997 : 
; 4998 : 							GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);
; 4999 : 						}
; 5000 : 					}
; 5001 : 					else {
; 5002 : 						//          .
; 5003 : 						break;
; 5004 : 					}
; 5005 : 				}
; 5006 : 			}
; 5007 : #endif
; 5008 : 
; 5009 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029	//     
; 5010 : 			if (lpItem->m_Type == MAKE_ITEMNUM(14, 100))
; 5011 : 			{
; 5012 : 				for (INT iLoop = MAX_EQUIPMENT; iLoop < MAX_INVENTORY; iLoop++) 
; 5013 : 				{
; 5014 : 					INT iInventoryIndex = -1;
; 5015 : 					if(gObj[aIndex].pInventory[iLoop].m_Type == MAKE_ITEMNUM(14, 100) &&
; 5016 : 						gObj[aIndex].pInventory[iLoop].m_Durability < MAX_OVERLAP_LUCKY_COIN)
; 5017 : 					{
; 5018 : 						iInventoryIndex = iLoop;
; 5019 : 					}
; 5020 : 
; 5021 : 					if (CHECK_LIMIT(iInventoryIndex, MAX_INVENTORY)) {
; 5022 : 						INT iItemDur	= gObj[aIndex].pInventory[iInventoryIndex].m_Durability + lpItem->m_Durability;
; 5023 : 						if (iItemDur <= MAX_OVERLAP_LUCKY_COIN) {
; 5024 : 							//    .
; 5025 : 							if( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )
; 5026 : 							{
; 5027 : 								pResult.result	= 0xFD;				//     .
; 5028 : 								DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5029 : 								gObj[aIndex].pInventory[iInventoryIndex].m_Durability += lpItem->m_Durability;
; 5030 : 
; 5031 : 								GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);
; 5032 : 								return;
; 5033 : 							}
; 5034 : 						}
; 5035 : 						else 
; 5036 : 						{
; 5037 : 							//   .
; 5038 : 							lpItem->m_Durability	= iItemDur - MAX_OVERLAP_LUCKY_COIN;
; 5039 : 							gObj[aIndex].pInventory[iInventoryIndex].m_Durability = MAX_OVERLAP_LUCKY_COIN;
; 5040 : 
; 5041 : 							GCItemDurSend(aIndex, iInventoryIndex, (int)gObj[aIndex].pInventory[iInventoryIndex].m_Durability, 0);
; 5042 : 						}
; 5043 : 					}
; 5044 : 					else 
; 5045 : 					{
; 5046 : 						//          .
; 5047 : 						//break;
; 5048 : 					}
; 5049 : 				}
; 5050 : 			}
; 5051 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029
; 5052 : 
; 5053 : 			pResult.result = gObjInventoryInsertItemTemp(&gObj[aIndex], lpItem);

  00c71	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00c74	50		 push	 eax
  00c75	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00c7c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c82	51		 push	 ecx
  00c83	e8 00 00 00 00	 call	 ?gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z ; gObjInventoryInsertItemTemp
  00c88	83 c4 08	 add	 esp, 8
  00c8b	88 45 eb	 mov	 BYTE PTR _pResult$[ebp+3], al

; 5054 : 		
; 5055 : 			if( pResult.result != 0xFF ) 

  00c8e	0f b6 45 eb	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  00c92	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00c97	0f 84 92 04 00
	00		 je	 $LN40@CGItemGetR

; 5056 : 			{
; 5057 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 5058 : 				ItemByteConvert(pResult.Data, lpItem->m_Type, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (BYTE)lpItem->m_Level, (BYTE)lpItem->m_Durability, (BYTE)lpItem->m_NewOption, (BYTE)lpItem->m_SetOption, lpItem->m_JewelOfHarmonyOption, lpItem->m_ItemOptionEx, lpItem->m_SocketOption, lpItem->m_BonusSocketOption );
; 5059 : #else
; 5060 : 	#ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 5061 : 		#ifdef ADD_380ITEM_NEWOPTION_20060711
; 5062 : 				ItemByteConvert(pResult.Data, lpItem->m_Type, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (BYTE)lpItem->m_Level, (BYTE)lpItem->m_Durability, (BYTE)lpItem->m_NewOption, (BYTE)lpItem->m_SetOption, lpItem->m_JewelOfHarmonyOption, lpItem->m_ItemOptionEx);
; 5063 : 		#else
; 5064 : 				ItemByteConvert(pResult.Data, lpItem->m_Type, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (BYTE)lpItem->m_Level, (BYTE)lpItem->m_Durability, (BYTE)lpItem->m_NewOption, (BYTE)lpItem->m_SetOption, lpItem->m_JewelOfHarmonyOption);
; 5065 : 		#endif // ADD_380ITEM_NEWOPTION_20060711
; 5066 : 	#else
; 5067 : 		#ifdef ADD_380ITEM_NEWOPTION_20060711
; 5068 : 				ItemByteConvert(pResult.Data, lpItem->m_Type, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (BYTE)lpItem->m_Level, (BYTE)lpItem->m_Durability, (BYTE)lpItem->m_NewOption, (BYTE)lpItem->m_SetOption, lpItem->m_ItemOptionEx);
; 5069 : 		#else
; 5070 : 				ItemByteConvert(pResult.Data, lpItem->m_Type, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (BYTE)lpItem->m_Level, (BYTE)lpItem->m_Durability, (BYTE)lpItem->m_NewOption, (BYTE)lpItem->m_SetOption);

  00c9d	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00ca0	0f b6 88 96 00
	00 00		 movzx	 ecx, BYTE PTR [eax+150]
  00ca7	51		 push	 ecx
  00ca8	8b 55 a0	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00cab	0f b6 42 7f	 movzx	 eax, BYTE PTR [edx+127]
  00caf	50		 push	 eax
  00cb0	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00cb3	f3 0f 2c 51 28	 cvttss2si edx, DWORD PTR [ecx+40]
  00cb8	0f b6 c2	 movzx	 eax, dl
  00cbb	50		 push	 eax
  00cbc	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00cbf	0f b6 51 0c	 movzx	 edx, BYTE PTR [ecx+12]
  00cc3	52		 push	 edx
  00cc4	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00cc7	0f b6 48 7e	 movzx	 ecx, BYTE PTR [eax+126]
  00ccb	51		 push	 ecx
  00ccc	8b 55 a0	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00ccf	0f b6 42 7d	 movzx	 eax, BYTE PTR [edx+125]
  00cd3	50		 push	 eax
  00cd4	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00cd7	0f b6 51 7c	 movzx	 edx, BYTE PTR [ecx+124]
  00cdb	52		 push	 edx
  00cdc	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00cdf	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00ce3	51		 push	 ecx
  00ce4	8d 55 ec	 lea	 edx, DWORD PTR _pResult$[ebp+4]
  00ce7	52		 push	 edx
  00ce8	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEHEEEEEEE@Z ; ItemByteConvert
  00ced	83 c4 24	 add	 esp, 36			; 00000024H

; 5071 : 		#endif // ADD_380ITEM_NEWOPTION_20060711
; 5072 : 	#endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 5073 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 5074 : 
; 5075 : 				if( MapC[map_num].ItemGive(aIndex, item_num) == TRUE )

  00cf0	6a 00		 push	 0
  00cf2	8b 45 f8	 mov	 eax, DWORD PTR _item_num$[ebp]
  00cf5	50		 push	 eax
  00cf6	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00cf9	51		 push	 ecx
  00cfa	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _map_num$[ebp], 328844
  00d01	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00d07	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00d0c	83 f8 01	 cmp	 eax, 1
  00d0f	0f 85 f5 03 00
	00		 jne	 $LN42@CGItemGetR

; 5076 : 				{
; 5077 : 					BYTE Ret = gObjInventoryInsertItem(aIndex, lpItem);

  00d15	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00d18	50		 push	 eax
  00d19	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00d1c	51		 push	 ecx
  00d1d	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z ; gObjInventoryInsertItem
  00d22	83 c4 08	 add	 esp, 8
  00d25	88 85 73 ff ff
	ff		 mov	 BYTE PTR _Ret$4[ebp], al

; 5078 : 					if(Ret == 0xFF)

  00d2b	0f b6 85 73 ff
	ff ff		 movzx	 eax, BYTE PTR _Ret$4[ebp]
  00d32	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00d37	75 04		 jne	 SHORT $LN44@CGItemGetR

; 5079 : 					{
; 5080 : 						pResult.result = 0xFF;

  00d39	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
$LN44@CGItemGetR:

; 5081 : 					}
; 5082 : 					//pResult.h.size -= 1;
; 5083 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00d3d	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00d41	50		 push	 eax
  00d42	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00d45	51		 push	 ecx
  00d46	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00d49	52		 push	 edx
  00d4a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00d4f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5084 : 
; 5085 : 					if( Ret == 0xFF) 

  00d52	0f b6 85 73 ff
	ff ff		 movzx	 eax, BYTE PTR _Ret$4[ebp]
  00d59	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00d5e	75 11		 jne	 SHORT $LN45@CGItemGetR

; 5086 : 					{
; 5087 : 						GCItemListSend(aIndex);

  00d60	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00d63	50		 push	 eax
  00d64	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  00d69	83 c4 04	 add	 esp, 4

; 5088 : 						//GCServerMsgStringSend("     .", aIndex, 1);
; 5089 : 					}

  00d6c	e9 97 03 00 00	 jmp	 $LN48@CGItemGetR
$LN45@CGItemGetR:

; 5090 : 					else
; 5091 : 					{
; 5092 : 						BYTE NewOption[8];
; 5093 : 						
; 5094 : 						ItemIsBufExOption(NewOption, lpItem);

  00d71	83 7d a0 00	 cmp	 DWORD PTR _lpItem$[ebp], 0
  00d75	74 0e		 je	 SHORT $LN68@CGItemGetR
  00d77	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00d7a	83 c0 04	 add	 eax, 4
  00d7d	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv907[ebp], eax
  00d83	eb 0a		 jmp	 SHORT $LN69@CGItemGetR
$LN68@CGItemGetR:
  00d85	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv907[ebp], 0
$LN69@CGItemGetR:
  00d8f	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR tv907[ebp]
  00d95	51		 push	 ecx
  00d96	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _NewOption$3[ebp]
  00d9c	52		 push	 edx
  00d9d	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  00da2	83 c4 08	 add	 esp, 8

; 5095 : 
; 5096 : #ifdef MODIFY_LOG_SYSTEM_2_3_20060828
; 5097 : 						LogAddTD(lMsg.Get(477),
; 5098 : 							gObj[aIndex].AccountID, 
; 5099 : 							gObj[aIndex].Name, 
; 5100 : 							map_num, 
; 5101 : 							gObj[aIndex].X, 
; 5102 : 							gObj[aIndex].Y, 
; 5103 : 							lpItem->m_Number, 
; 5104 : 							szItemName, 
; 5105 : 							type, 
; 5106 : 							level, 
; 5107 : 							lpItem->m_Option1, 
; 5108 : 							lpItem->m_Option2, 
; 5109 : 							lpItem->m_Option3,
; 5110 : 							(int)lpItem->m_Durability,
; 5111 : 							NewOption[0],
; 5112 : 							NewOption[1],
; 5113 : 							NewOption[2],
; 5114 : 							NewOption[3],
; 5115 : 							NewOption[4],
; 5116 : 							NewOption[5],
; 5117 : 							NewOption[6],
; 5118 : 							lpItem->m_SetOption,
; 5119 : 							lpItem->m_ItemOptionEx>>7,
; 5120 : 							g_kJewelOfHarmonySystem.GetItemStrengthenOption( lpItem ),
; 5121 : 							g_kJewelOfHarmonySystem.GetItemOptionLevel( lpItem )
; 5122 : 							);
; 5123 : #else
; 5124 : 						LogAddTD(lMsg.Get(477),

  00da5	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00da8	0f b6 88 96 00
	00 00		 movzx	 ecx, BYTE PTR [eax+150]
  00daf	51		 push	 ecx
  00db0	ba 01 00 00 00	 mov	 edx, 1
  00db5	6b c2 06	 imul	 eax, edx, 6
  00db8	0f b6 8c 05 68
	ff ff ff	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00dc0	51		 push	 ecx
  00dc1	ba 01 00 00 00	 mov	 edx, 1
  00dc6	6b c2 05	 imul	 eax, edx, 5
  00dc9	0f b6 8c 05 68
	ff ff ff	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00dd1	51		 push	 ecx
  00dd2	ba 01 00 00 00	 mov	 edx, 1
  00dd7	c1 e2 02	 shl	 edx, 2
  00dda	0f b6 84 15 68
	ff ff ff	 movzx	 eax, BYTE PTR _NewOption$3[ebp+edx]
  00de2	50		 push	 eax
  00de3	b9 01 00 00 00	 mov	 ecx, 1
  00de8	6b d1 03	 imul	 edx, ecx, 3
  00deb	0f b6 84 15 68
	ff ff ff	 movzx	 eax, BYTE PTR _NewOption$3[ebp+edx]
  00df3	50		 push	 eax
  00df4	b9 01 00 00 00	 mov	 ecx, 1
  00df9	d1 e1		 shl	 ecx, 1
  00dfb	0f b6 94 0d 68
	ff ff ff	 movzx	 edx, BYTE PTR _NewOption$3[ebp+ecx]
  00e03	52		 push	 edx
  00e04	b8 01 00 00 00	 mov	 eax, 1
  00e09	c1 e0 00	 shl	 eax, 0
  00e0c	0f b6 8c 05 68
	ff ff ff	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00e14	51		 push	 ecx
  00e15	ba 01 00 00 00	 mov	 edx, 1
  00e1a	6b c2 00	 imul	 eax, edx, 0
  00e1d	0f b6 8c 05 68
	ff ff ff	 movzx	 ecx, BYTE PTR _NewOption$3[ebp+eax]
  00e25	51		 push	 ecx
  00e26	8b 55 a0	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00e29	0f b6 42 7e	 movzx	 eax, BYTE PTR [edx+126]
  00e2d	50		 push	 eax
  00e2e	8b 4d a0	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00e31	0f b6 51 7d	 movzx	 edx, BYTE PTR [ecx+125]
  00e35	52		 push	 edx
  00e36	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00e39	0f b6 48 7c	 movzx	 ecx, BYTE PTR [eax+124]
  00e3d	51		 push	 ecx
  00e3e	8b 55 e0	 mov	 edx, DWORD PTR _level$[ebp]
  00e41	52		 push	 edx
  00e42	8b 45 e4	 mov	 eax, DWORD PTR _type$[ebp]
  00e45	50		 push	 eax
  00e46	8d 4d a4	 lea	 ecx, DWORD PTR _szItemName$[ebp]
  00e49	51		 push	 ecx
  00e4a	8b 55 a0	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00e4d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00e50	50		 push	 eax
  00e51	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00e58	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e5e	0f bf 84 0a 06
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+262]
  00e66	50		 push	 eax
  00e67	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00e6e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e74	0f bf 84 0a 04
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+260]
  00e7c	50		 push	 eax
  00e7d	8b 4d f4	 mov	 ecx, DWORD PTR _map_num$[ebp]
  00e80	51		 push	 ecx
  00e81	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00e88	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e8d	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00e91	51		 push	 ecx
  00e92	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00e99	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e9e	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00ea2	51		 push	 ecx
  00ea3	68 dd 01 00 00	 push	 477			; 000001ddH
  00ea8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00ead	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00eb3	50		 push	 eax
  00eb4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00eba	83 c4 54	 add	 esp, 84			; 00000054H

; 5125 : 							gObj[aIndex].AccountID, 
; 5126 : 							gObj[aIndex].Name, 
; 5127 : 							map_num, 
; 5128 : 							gObj[aIndex].X, 
; 5129 : 							gObj[aIndex].Y, 
; 5130 : 							lpItem->m_Number, 
; 5131 : 							szItemName, 
; 5132 : 							type, 
; 5133 : 							level, 
; 5134 : 							lpItem->m_Option1, 
; 5135 : 							lpItem->m_Option2, 
; 5136 : 							lpItem->m_Option3,
; 5137 : 							NewOption[0],
; 5138 : 							NewOption[1],
; 5139 : 							NewOption[2],
; 5140 : 							NewOption[3],
; 5141 : 							NewOption[4],
; 5142 : 							NewOption[5],
; 5143 : 							NewOption[6],
; 5144 : 							lpItem->m_SetOption
; 5145 : 							);
; 5146 : #endif // MODIFY_LOG_SYSTEM_2_3_20060828
; 5147 : 
; 5148 : 						#ifdef SEND_GETITEMINFO_FOR_MYPARTY	//  
; 5149 : 							GCSendGetItemInfoForParty(aIndex, lpItem);
; 5150 : 						#endif
; 5151 : 
; 5152 : 
; 5153 : 
; 5154 : #ifdef FOR_BLOODCASTLE
; 5155 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    							
; 5156 : 						if (CHECK_BLOODCASTLE(map_num)) {
; 5157 : 							int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( map_num );
; 5158 : 							if (g_BloodCastle.CheckQuestItemSerial(iBridgeIndex, lpItem)) {
; 5159 : 								//      .
; 5160 : 								g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX = gObj[aIndex].m_Index;
; 5161 : 
; 5162 : 								//       .
; 5163 : 								int iUserBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( gObj[aIndex].MapNumber );
; 5164 : 								CHAR szWEAPON_NAME[128];
; 5165 : 								switch(lpItem->m_Level) {
; 5166 : 								case 0:
; 5167 : 									wsprintf(szWEAPON_NAME, lMsg.Get(1174), gObj[aIndex].Name);		// "%s    ."
; 5168 : 									g_BloodCastle.SendNoticeMessage(iUserBridgeIndex, szWEAPON_NAME);
; 5169 : 									break;
; 5170 : 								case 1:
; 5171 : 									wsprintf(szWEAPON_NAME, lMsg.Get(1175), gObj[aIndex].Name);		// "%s    ."
; 5172 : 									g_BloodCastle.SendNoticeMessage(iUserBridgeIndex, szWEAPON_NAME);
; 5173 : 									break;
; 5174 : 								case 2:
; 5175 : 									wsprintf(szWEAPON_NAME, lMsg.Get(1176), gObj[aIndex].Name);		// "%s    ."
; 5176 : 									g_BloodCastle.SendNoticeMessage(iUserBridgeIndex, szWEAPON_NAME);
; 5177 : 									break;
; 5178 : 								default:
; 5179 : 									szWEAPON_NAME[0] = '\0';
; 5180 : 									break;
; 5181 : 								}
; 5182 : 								
; 5183 : 								LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) picked up Angel King's Weapon (%d)", 
; 5184 : 									iBridgeIndex +1, 
; 5185 : 									gObj[aIndex].AccountID, 
; 5186 : 									gObj[aIndex].Name, 
; 5187 : 									lpItem->m_Level);
; 5188 : 							}
; 5189 : 						}
; 5190 : #else	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010							
; 5191 : 						if (CHECK_BLOODCASTLE(map_num)) {

  00ebd	83 7d f4 0b	 cmp	 DWORD PTR _map_num$[ebp], 11 ; 0000000bH
  00ec1	7d 0c		 jge	 SHORT $LN72@CGItemGetR
  00ec3	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1002[ebp], 0
  00ecd	eb 28		 jmp	 SHORT $LN73@CGItemGetR
$LN72@CGItemGetR:
  00ecf	83 7d f4 11	 cmp	 DWORD PTR _map_num$[ebp], 17 ; 00000011H
  00ed3	7e 0c		 jle	 SHORT $LN70@CGItemGetR
  00ed5	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1001[ebp], 0
  00edf	eb 0a		 jmp	 SHORT $LN71@CGItemGetR
$LN70@CGItemGetR:
  00ee1	c7 85 9c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1001[ebp], 1
$LN71@CGItemGetR:
  00eeb	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv1001[ebp]
  00ef1	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv1002[ebp], eax
$LN73@CGItemGetR:
  00ef7	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv1002[ebp], 0
  00efe	0f 84 04 02 00
	00		 je	 $LN48@CGItemGetR

; 5192 : 							if (g_BloodCastle.CheckQuestItemSerial(map_num - MAP_INDEX_BLOODCASTLE1, lpItem)) {

  00f04	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00f07	50		 push	 eax
  00f08	8b 4d f4	 mov	 ecx, DWORD PTR _map_num$[ebp]
  00f0b	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00f0e	51		 push	 ecx
  00f0f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00f14	e8 00 00 00 00	 call	 ?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ; CBloodCastle::CheckQuestItemSerial
  00f19	0f b6 d0	 movzx	 edx, al
  00f1c	85 d2		 test	 edx, edx
  00f1e	0f 84 e4 01 00
	00		 je	 $LN48@CGItemGetR

; 5193 : 								//      .
; 5194 : 								g_BloodCastle.m_BridgeData[map_num - MAP_INDEX_BLOODCASTLE1].m_iBC_QUEST_ITEM_USER_INDEX = gObj[aIndex].m_Index;

  00f24	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f2b	8b 4d f4	 mov	 ecx, DWORD PTR _map_num$[ebp]
  00f2e	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00f31	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00f37	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f3d	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00f40	89 82 94 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+404], eax

; 5195 : 
; 5196 : 								//       .
; 5197 : 								CHAR szWEAPON_NAME[128];
; 5198 : 								switch(lpItem->m_Level) {

  00f46	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00f49	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  00f4d	89 8d a0 fe ff
	ff		 mov	 DWORD PTR tv1024[ebp], ecx
  00f53	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv1024[ebp], 0
  00f5a	74 1b		 je	 SHORT $LN49@CGItemGetR
  00f5c	83 bd a0 fe ff
	ff 01		 cmp	 DWORD PTR tv1024[ebp], 1
  00f63	74 74		 je	 SHORT $LN50@CGItemGetR
  00f65	83 bd a0 fe ff
	ff 02		 cmp	 DWORD PTR tv1024[ebp], 2
  00f6c	0f 84 c9 00 00
	00		 je	 $LN51@CGItemGetR
  00f72	e9 23 01 00 00	 jmp	 $LN52@CGItemGetR
$LN49@CGItemGetR:

; 5199 : 								case 0:
; 5200 : 									wsprintf(szWEAPON_NAME, lMsg.Get(1174), gObj[aIndex].Name);		// "%s    ."

  00f77	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f7e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f84	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00f88	52		 push	 edx
  00f89	68 96 04 00 00	 push	 1174			; 00000496H
  00f8e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00f93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00f99	50		 push	 eax
  00f9a	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szWEAPON_NAME$2[ebp]
  00fa0	50		 push	 eax
  00fa1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00fa7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5201 : 									g_BloodCastle.SendNoticeMessage(gObj[aIndex].MapNumber - MAP_INDEX_BLOODCASTLE1, szWEAPON_NAME);

  00faa	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szWEAPON_NAME$2[ebp]
  00fb0	50		 push	 eax
  00fb1	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00fb8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00fbe	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  00fc6	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00fc9	50		 push	 eax
  00fca	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00fcf	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 5202 : 									break;

  00fd4	e9 f0 00 00 00	 jmp	 $LN7@CGItemGetR
$LN50@CGItemGetR:

; 5203 : 								case 1:
; 5204 : 									wsprintf(szWEAPON_NAME, lMsg.Get(1175), gObj[aIndex].Name);		// "%s    ."

  00fd9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00fe0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00fe6	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00fea	52		 push	 edx
  00feb	68 97 04 00 00	 push	 1175			; 00000497H
  00ff0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00ff5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00ffb	50		 push	 eax
  00ffc	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szWEAPON_NAME$2[ebp]
  01002	50		 push	 eax
  01003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01009	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5205 : 									g_BloodCastle.SendNoticeMessage(gObj[aIndex].MapNumber - MAP_INDEX_BLOODCASTLE1, szWEAPON_NAME);

  0100c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szWEAPON_NAME$2[ebp]
  01012	50		 push	 eax
  01013	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0101a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01020	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  01028	83 e8 0b	 sub	 eax, 11			; 0000000bH
  0102b	50		 push	 eax
  0102c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01031	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 5206 : 									break;

  01036	e9 8e 00 00 00	 jmp	 $LN7@CGItemGetR
$LN51@CGItemGetR:

; 5207 : 								case 2:
; 5208 : 									wsprintf(szWEAPON_NAME, lMsg.Get(1176), gObj[aIndex].Name);		// "%s    ."

  0103b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01048	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0104c	52		 push	 edx
  0104d	68 98 04 00 00	 push	 1176			; 00000498H
  01052	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0105d	50		 push	 eax
  0105e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szWEAPON_NAME$2[ebp]
  01064	50		 push	 eax
  01065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0106b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5209 : 									g_BloodCastle.SendNoticeMessage(gObj[aIndex].MapNumber - MAP_INDEX_BLOODCASTLE1, szWEAPON_NAME);

  0106e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szWEAPON_NAME$2[ebp]
  01074	50		 push	 eax
  01075	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0107c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01082	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  0108a	83 e8 0b	 sub	 eax, 11			; 0000000bH
  0108d	50		 push	 eax
  0108e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01093	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 5210 : 									break;

  01098	eb 2f		 jmp	 SHORT $LN7@CGItemGetR
$LN52@CGItemGetR:

; 5211 : 								default:
; 5212 : 									szWEAPON_NAME[0] = '\0';

  0109a	b8 01 00 00 00	 mov	 eax, 1
  0109f	6b c8 00	 imul	 ecx, eax, 0
  010a2	89 8d a4 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  010a8	81 bd a4 fe ff
	ff 80 00 00 00	 cmp	 DWORD PTR $T1[ebp], 128	; 00000080H
  010b2	73 02		 jae	 SHORT $LN74@CGItemGetR
  010b4	eb 05		 jmp	 SHORT $LN75@CGItemGetR
$LN74@CGItemGetR:
  010b6	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN75@CGItemGetR:
  010bb	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  010c1	c6 84 15 e8 fe
	ff ff 00	 mov	 BYTE PTR _szWEAPON_NAME$2[ebp+edx], 0
$LN7@CGItemGetR:

; 5213 : 									break;
; 5214 : 								}
; 5215 : 								
; 5216 : 								LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) picked up Angel King's Weapon (%d)", 

  010c9	8b 45 a0	 mov	 eax, DWORD PTR _lpItem$[ebp]
  010cc	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  010d0	51		 push	 ecx
  010d1	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  010d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  010dd	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  010e1	51		 push	 ecx
  010e2	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  010e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  010ee	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  010f2	51		 push	 ecx
  010f3	8b 55 f4	 mov	 edx, DWORD PTR _map_num$[ebp]
  010f6	83 ea 0a	 sub	 edx, 10			; 0000000aH
  010f9	52		 push	 edx
  010fa	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
  010ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01105	83 c4 14	 add	 esp, 20			; 00000014H
$LN48@CGItemGetR:

; 5217 : 									map_num - MAP_INDEX_BLOODCASTLE1 +1, 
; 5218 : 									gObj[aIndex].AccountID, 
; 5219 : 									gObj[aIndex].Name, 
; 5220 : 									lpItem->m_Level);
; 5221 : 							}
; 5222 : 						}
; 5223 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 5224 : #endif
; 5225 : 
; 5226 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//     
; 5227 : 						if( CHECK_ILLUSION_TEMPLE(map_num) && MAKE_ITEMNUM(14, 64) == lpItem->m_Type)
; 5228 : 						{
; 5229 : 							g_IllusionTempleEvent.SetInventoryPos(gObj[aIndex].MapNumber, aIndex, Ret);
; 5230 : 							g_IllusionTempleEvent.SendRelicsUser(&gObj[aIndex]);
; 5231 : 										
; 5232 : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_3_20070731
; 5233 : 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5234 : 							LogAddTD("[Illusion Temple] (%d) (Account:%s, Name:%s) picked up Relics Item(serial:%u)", 
; 5235 : 	#else
; 5236 : 							LogAddTD("[Illusion Temple] (%d) (Account:%s, Name:%s) picked up Relics Item(serial:%d)", 
; 5237 : 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5238 : 									map_num - MAP_INDEX_ILLUSION_TEMPLE1 +1, 
; 5239 : 									gObj[aIndex].AccountID, 
; 5240 : 									gObj[aIndex].Name, lpItem->m_Number);
; 5241 : #else
; 5242 : 							LogAddTD("[Illusion Temple] (%d) (Account:%s, Name:%s) picked up Relics Item", 
; 5243 : 									map_num - MAP_INDEX_ILLUSION_TEMPLE1 +1, 
; 5244 : 									gObj[aIndex].AccountID, 
; 5245 : 									gObj[aIndex].Name);
; 5246 : #endif
; 5247 : 						}
; 5248 : #endif
; 5249 : 					}
; 5250 : 				}

  01108	eb 23		 jmp	 SHORT $LN43@CGItemGetR
$LN42@CGItemGetR:

; 5251 : 				else
; 5252 : 				{
; 5253 : 					//    .
; 5254 : 					pResult.result = 0xFF;

  0110a	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 5255 : 					pResult.h.size -= ITEM_BUFFER_SIZE;

  0110e	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01112	83 e8 05	 sub	 eax, 5
  01115	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 5256 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01118	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0111c	50		 push	 eax
  0111d	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  01120	51		 push	 ecx
  01121	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01124	52		 push	 edx
  01125	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0112a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN43@CGItemGetR:

; 5257 : 				}
; 5258 : 			}

  0112d	eb 23		 jmp	 SHORT $LN41@CGItemGetR
$LN40@CGItemGetR:

; 5259 : 			else 
; 5260 : 			{
; 5261 : 				pResult.result = 0xFF;

  0112f	c6 45 eb ff	 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 5262 : 				pResult.h.size -= ITEM_BUFFER_SIZE;

  01133	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01137	83 e8 05	 sub	 eax, 5
  0113a	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 5263 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0113d	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01141	50		 push	 eax
  01142	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  01145	51		 push	 ecx
  01146	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01149	52		 push	 edx
  0114a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0114f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@CGItemGetR:

; 5264 : 			}			
; 5265 : 		}		
; 5266 : 	}

  01152	eb 1f		 jmp	 SHORT $LN19@CGItemGetR
$LN18@CGItemGetR:

; 5267 : 	else 
; 5268 : 	{
; 5269 : 		pResult.h.size -= ITEM_BUFFER_SIZE;

  01154	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01158	83 e8 05	 sub	 eax, 5
  0115b	88 45 e9	 mov	 BYTE PTR _pResult$[ebp+1], al

; 5270 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0115e	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01162	50		 push	 eax
  01163	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  01166	51		 push	 ecx
  01167	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0116a	52		 push	 edx
  0116b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01170	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@CGItemGetR:
$LN1@CGItemGetR:

; 5271 : //		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);
; 5272 : 	}
; 5273 : }

  01173	5f		 pop	 edi
  01174	5e		 pop	 esi
  01175	5b		 pop	 ebx
  01176	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01179	33 cd		 xor	 ecx, ebp
  0117b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01180	8b e5		 mov	 esp, ebp
  01182	5d		 pop	 ebp
  01183	c3		 ret	 0
?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ENDP	; CGItemGetRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCSendDuelScore@@YAXHH@Z
_TEXT	SEGMENT
tv71 = -88						; size = 4
tv66 = -88						; size = 4
tv72 = -84						; size = 4
tv67 = -84						; size = 4
_pMsg$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex1$ = 8						; size = 4
_aIndex2$ = 12						; size = 4
?GCSendDuelScore@@YAXHH@Z PROC				; GCSendDuelScore, COMDAT

; 21950: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 21951: 
; 21952: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 21953: 	return;
; 21954: #endif
; 21955: 	
; 21956: 	if (!CHECK_LIMIT(aIndex1, MAX_OBJECT) || !CHECK_LIMIT(aIndex2, MAX_OBJECT)) {

  00013	83 7d 08 00	 cmp	 DWORD PTR _aIndex1$[ebp], 0
  00017	7d 09		 jge	 SHORT $LN13@GCSendDuel
  00019	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00020	eb 1f		 jmp	 SHORT $LN14@GCSendDuel
$LN13@GCSendDuel:
  00022	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex1$[ebp], 7399 ; 00001ce7H
  00029	7e 09		 jle	 SHORT $LN11@GCSendDuel
  0002b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN12@GCSendDuel
$LN11@GCSendDuel:
  00034	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN12@GCSendDuel:
  0003b	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  0003e	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN14@GCSendDuel:
  00041	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  00045	74 34		 je	 SHORT $LN3@GCSendDuel
  00047	83 7d 0c 00	 cmp	 DWORD PTR _aIndex2$[ebp], 0
  0004b	7d 09		 jge	 SHORT $LN17@GCSendDuel
  0004d	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  00054	eb 1f		 jmp	 SHORT $LN18@GCSendDuel
$LN17@GCSendDuel:
  00056	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex2$[ebp], 7399 ; 00001ce7H
  0005d	7e 09		 jle	 SHORT $LN15@GCSendDuel
  0005f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00066	eb 07		 jmp	 SHORT $LN16@GCSendDuel
$LN15@GCSendDuel:
  00068	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN16@GCSendDuel:
  0006f	8b 45 a8	 mov	 eax, DWORD PTR tv71[ebp]
  00072	89 45 ac	 mov	 DWORD PTR tv72[ebp], eax
$LN18@GCSendDuel:
  00075	83 7d ac 00	 cmp	 DWORD PTR tv72[ebp], 0
  00079	75 05		 jne	 SHORT $LN2@GCSendDuel
$LN3@GCSendDuel:

; 21957: 		return;

  0007b	e9 1f 01 00 00	 jmp	 $LN1@GCSendDuel
$LN2@GCSendDuel:

; 21958: 	}
; 21959: 
; 21960: 	//     .
; 21961: 	if( gObjIsConnected(aIndex1) == FALSE ||

  00080	8b 45 08	 mov	 eax, DWORD PTR _aIndex1$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00089	83 c4 04	 add	 esp, 4
  0008c	85 c0		 test	 eax, eax
  0008e	74 10		 je	 SHORT $LN5@GCSendDuel
  00090	8b 45 0c	 mov	 eax, DWORD PTR _aIndex2$[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00099	83 c4 04	 add	 esp, 4
  0009c	85 c0		 test	 eax, eax
  0009e	75 05		 jne	 SHORT $LN4@GCSendDuel
$LN5@GCSendDuel:

; 21962: 		gObjIsConnected(aIndex2) == FALSE
; 21963: 		) return;

  000a0	e9 fa 00 00 00	 jmp	 $LN1@GCSendDuel
$LN4@GCSendDuel:

; 21964: 	if( gObj[aIndex1].Type == OBJTYPE_MONSTER ||

  000a5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex1$[ebp], 7072
  000ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b2	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000b7	83 fa 02	 cmp	 edx, 2
  000ba	74 17		 je	 SHORT $LN7@GCSendDuel
  000bc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex2$[ebp], 7072
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c9	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000ce	83 fa 02	 cmp	 edx, 2
  000d1	75 05		 jne	 SHORT $LN6@GCSendDuel
$LN7@GCSendDuel:

; 21965: 		gObj[aIndex2].Type == OBJTYPE_MONSTER
; 21966: 		) return;

  000d3	e9 c7 00 00 00	 jmp	 $LN1@GCSendDuel
$LN6@GCSendDuel:

; 21967: 	if( gObj[aIndex1].CloseCount >= 0 ||

  000d8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex1$[ebp], 7072
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e5	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  000ea	85 d2		 test	 edx, edx
  000ec	7d 16		 jge	 SHORT $LN9@GCSendDuel
  000ee	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex2$[ebp], 7072
  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fb	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  00100	85 d2		 test	 edx, edx
  00102	7c 05		 jl	 SHORT $LN8@GCSendDuel
$LN9@GCSendDuel:

; 21968: 		gObj[aIndex2].CloseCount >= 0
; 21969: 		) return;

  00104	e9 96 00 00 00	 jmp	 $LN1@GCSendDuel
$LN8@GCSendDuel:

; 21970: 
; 21971: 	PMSG_ANS_DUEL_SCORE pMsg;
; 21972: 	pMsg.h.c = PMHC_BYTE;

  00109	c6 45 f0 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 21973: 	pMsg.h.headcode = 0xAD;

  0010d	c6 45 f2 ad	 mov	 BYTE PTR _pMsg$[ebp+2], 173 ; 000000adH

; 21974: 	pMsg.h.size = sizeof( pMsg );

  00111	c6 45 f1 09	 mov	 BYTE PTR _pMsg$[ebp+1], 9

; 21975: 
; 21976: 	pMsg.NumberH1 = HIBYTE(aIndex1);

  00115	8b 45 08	 mov	 eax, DWORD PTR _aIndex1$[ebp]
  00118	c1 e8 08	 shr	 eax, 8
  0011b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00120	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 21977: 	pMsg.NumberL1 = LOBYTE(aIndex1);

  00123	8b 45 08	 mov	 eax, DWORD PTR _aIndex1$[ebp]
  00126	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0012b	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 21978: 	pMsg.NumberH2 = HIBYTE(aIndex2);

  0012e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex2$[ebp]
  00131	c1 e8 08	 shr	 eax, 8
  00134	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00139	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 21979: 	pMsg.NumberL2 = LOBYTE(aIndex2);

  0013c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex2$[ebp]
  0013f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00144	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 21980: 
; 21981: 	pMsg.btDuelScore1 = gObj[aIndex1].m_btDuelScore;

  00147	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex1$[ebp], 7072
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00154	8a 94 01 f0 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3312]
  0015b	88 55 f7	 mov	 BYTE PTR _pMsg$[ebp+7], dl

; 21982: 	pMsg.btDuelScore2 = gObj[aIndex2].m_btDuelScore;

  0015e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex2$[ebp], 7072
  00165	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016b	8a 94 01 f0 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3312]
  00172	88 55 f8	 mov	 BYTE PTR _pMsg$[ebp+8], dl

; 21983: 
; 21984: 	DataSend(aIndex1, (LPBYTE)&pMsg, pMsg.h.size);

  00175	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00179	50		 push	 eax
  0017a	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0017d	51		 push	 ecx
  0017e	8b 55 08	 mov	 edx, DWORD PTR _aIndex1$[ebp]
  00181	52		 push	 edx
  00182	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00187	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21985: 	DataSend(aIndex2, (LPBYTE)&pMsg, pMsg.h.size);

  0018a	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0018e	50		 push	 eax
  0018f	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00192	51		 push	 ecx
  00193	8b 55 0c	 mov	 edx, DWORD PTR _aIndex2$[ebp]
  00196	52		 push	 edx
  00197	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0019c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendDuel:

; 21986: }

  0019f	5f		 pop	 edi
  001a0	5e		 pop	 esi
  001a1	5b		 pop	 ebx
  001a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a5	33 cd		 xor	 ecx, ebp
  001a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c3		 ret	 0
?GCSendDuelScore@@YAXHH@Z ENDP				; GCSendDuelScore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z
_TEXT	SEGMENT
tv236 = -128						; size = 4
tv197 = -128						; size = 4
tv159 = -128						; size = 4
tv146 = -128						; size = 4
tv85 = -128						; size = 4
tv237 = -124						; size = 4
tv198 = -124						; size = 4
tv160 = -124						; size = 4
tv147 = -124						; size = 4
tv86 = -124						; size = 4
$T1 = -120						; size = 4
$T2 = -116						; size = 4
_szDuelName2$3 = -48					; size = 11
_szDuelName$4 = -36					; size = 11
_pMsgSend$ = -24					; size = 16
_iDuelIndex$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z PROC	; CGDuelOkRequestRecv, COMDAT

; 21764: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 21765: 
; 21766: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 21767: 	return;
; 21768: #endif
; 21769: 	
; 21770: 	int iDuelIndex = -1;		//    

  00016	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iDuelIndex$[ebp], -1

; 21771: 
; 21772: 	//    
; 21773: 	PMSG_ANS_START_DUEL pMsgSend;
; 21774: 	pMsgSend.h.c = PMHC_BYTE;

  0001d	c6 45 e8 c1	 mov	 BYTE PTR _pMsgSend$[ebp], 193 ; 000000c1H

; 21775: 	pMsgSend.h.headcode = 0xAA;

  00021	c6 45 ea aa	 mov	 BYTE PTR _pMsgSend$[ebp+2], 170 ; 000000aaH

; 21776: 	pMsgSend.h.size = sizeof( pMsgSend );

  00025	c6 45 e9 10	 mov	 BYTE PTR _pMsgSend$[ebp+1], 16 ; 00000010H

; 21777: 
; 21778: 
; 21779: 	// ..
; 21780: 	if( gObj[aIndex].CloseType != -1 )

  00029	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00036	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  0003b	83 fa ff	 cmp	 edx, -1
  0003e	74 05		 je	 SHORT $LN2@CGDuelOkRe

; 21781: 	{
; 21782: 		return;

  00040	e9 d5 07 00 00	 jmp	 $LN20@CGDuelOkRe
$LN2@CGDuelOkRe:

; 21783: 	}
; 21784: 
; 21785: 	//    .
; 21786: 	iDuelIndex = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  00045	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00048	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0004c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00052	0f b6 d1	 movzx	 edx, cl
  00055	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00058	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0005c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00062	0f b6 c1	 movzx	 eax, cl
  00065	c1 e0 08	 shl	 eax, 8
  00068	0b d0		 or	 edx, eax
  0006a	0f b7 ca	 movzx	 ecx, dx
  0006d	89 4d f8	 mov	 DWORD PTR _iDuelIndex$[ebp], ecx

; 21787: 	if (CHECK_LIMIT(iDuelIndex, MAX_OBJECT)) {

  00070	83 7d f8 00	 cmp	 DWORD PTR _iDuelIndex$[ebp], 0
  00074	7d 09		 jge	 SHORT $LN23@CGDuelOkRe
  00076	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  0007d	eb 1f		 jmp	 SHORT $LN24@CGDuelOkRe
$LN23@CGDuelOkRe:
  0007f	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _iDuelIndex$[ebp], 7399 ; 00001ce7H
  00086	7e 09		 jle	 SHORT $LN21@CGDuelOkRe
  00088	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  0008f	eb 07		 jmp	 SHORT $LN22@CGDuelOkRe
$LN21@CGDuelOkRe:
  00091	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
$LN22@CGDuelOkRe:
  00098	8b 45 80	 mov	 eax, DWORD PTR tv85[ebp]
  0009b	89 45 84	 mov	 DWORD PTR tv86[ebp], eax
$LN24@CGDuelOkRe:
  0009e	83 7d 84 00	 cmp	 DWORD PTR tv86[ebp], 0
  000a2	0f 84 72 07 00
	00		 je	 $LN20@CGDuelOkRe

; 21788: 
; 21789: 		//     .
; 21790: 		if( gObjIsConnected(iDuelIndex) == FALSE ) return;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000b1	83 c4 04	 add	 esp, 4
  000b4	85 c0		 test	 eax, eax
  000b6	75 05		 jne	 SHORT $LN5@CGDuelOkRe
  000b8	e9 5d 07 00 00	 jmp	 $LN20@CGDuelOkRe
$LN5@CGDuelOkRe:

; 21791: 		if( gObj[iDuelIndex].Type == OBJTYPE_MONSTER ) return;

  000bd	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ca	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000cf	83 fa 02	 cmp	 edx, 2
  000d2	75 05		 jne	 SHORT $LN6@CGDuelOkRe
  000d4	e9 41 07 00 00	 jmp	 $LN20@CGDuelOkRe
$LN6@CGDuelOkRe:

; 21792: 		if( gObj[iDuelIndex].CloseCount >= 0 ) return;

  000d9	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e6	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  000eb	85 d2		 test	 edx, edx
  000ed	7c 05		 jl	 SHORT $LN7@CGDuelOkRe
  000ef	e9 26 07 00 00	 jmp	 $LN20@CGDuelOkRe
$LN7@CGDuelOkRe:

; 21793: 
; 21794: #ifdef CHAOSCASTLE_DUAL_GUILDWAR_CHANGE_20040614		
; 21795: 	#ifndef WORLD_TOURNAMENT_EVENT_SETTING	
; 21796: 		if( lpMsg->bDuelOK != 0 )

  000f4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000f7	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000fb	85 c9		 test	 ecx, ecx
  000fd	0f 84 5d 01 00
	00		 je	 $LN8@CGDuelOkRe

; 21797: 		{
; 21798: 			if (CHECK_BLOODCASTLE(gObj[iDuelIndex].MapNumber) ||		// 
; 21799: 				CHECK_CHAOSCASTLE(gObj[iDuelIndex].MapNumber) ||		// 

  00103	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00110	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00118	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0011b	7d 09		 jge	 SHORT $LN27@CGDuelOkRe
  0011d	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv147[ebp], 0
  00124	eb 30		 jmp	 SHORT $LN28@CGDuelOkRe
$LN27@CGDuelOkRe:
  00126	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00133	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0013b	83 fa 11	 cmp	 edx, 17			; 00000011H
  0013e	7e 09		 jle	 SHORT $LN25@CGDuelOkRe
  00140	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
  00147	eb 07		 jmp	 SHORT $LN26@CGDuelOkRe
$LN25@CGDuelOkRe:
  00149	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv146[ebp], 1
$LN26@CGDuelOkRe:
  00150	8b 45 80	 mov	 eax, DWORD PTR tv146[ebp]
  00153	89 45 84	 mov	 DWORD PTR tv147[ebp], eax
$LN28@CGDuelOkRe:
  00156	83 7d 84 00	 cmp	 DWORD PTR tv147[ebp], 0
  0015a	75 77		 jne	 SHORT $LN10@CGDuelOkRe
  0015c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00163	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00169	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00171	83 fa 12	 cmp	 edx, 18			; 00000012H
  00174	7d 09		 jge	 SHORT $LN31@CGDuelOkRe
  00176	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
  0017d	eb 30		 jmp	 SHORT $LN32@CGDuelOkRe
$LN31@CGDuelOkRe:
  0017f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00186	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00194	83 fa 17	 cmp	 edx, 23			; 00000017H
  00197	7e 09		 jle	 SHORT $LN29@CGDuelOkRe
  00199	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
  001a0	eb 07		 jmp	 SHORT $LN30@CGDuelOkRe
$LN29@CGDuelOkRe:
  001a2	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv159[ebp], 1
$LN30@CGDuelOkRe:
  001a9	8b 45 80	 mov	 eax, DWORD PTR tv159[ebp]
  001ac	89 45 84	 mov	 DWORD PTR tv160[ebp], eax
$LN32@CGDuelOkRe:
  001af	83 7d 84 00	 cmp	 DWORD PTR tv160[ebp], 0
  001b3	75 1e		 jne	 SHORT $LN10@CGDuelOkRe
  001b5	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  001bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c2	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001ca	83 fa 09	 cmp	 edx, 9
  001cd	0f 85 8d 00 00
	00		 jne	 $LN8@CGDuelOkRe
$LN10@CGDuelOkRe:

; 21800: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 21801: 				CHECK_DEVILSQUARE(gObj[iDuelIndex].MapNumber)			// 
; 21802: #else
; 21803: 				gObj[iDuelIndex].MapNumber == 9							// 
; 21804: #endif
; 21805: 				)
; 21806: 			{
; 21807: 				GCServerMsgStringSend(lMsg.Get(1231), aIndex, 1);		// "       ."			

  001d3	6a 01		 push	 1
  001d5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001d8	50		 push	 eax
  001d9	68 cf 04 00 00	 push	 1231			; 000004cfH
  001de	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21808: 
; 21809: 				gObj[aIndex].m_iDuelUserRequested = -1;

  001f2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ff	c7 84 01 e8 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3304], -1

; 21810: 				gObj[iDuelIndex].m_iDuelUserReserved = -1;

  0020a	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00211	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00217	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1

; 21811: 
; 21812: 				memcpy(pMsgSend.szName, gObj[aIndex].Name, MAX_IDSTRING);

  00222	6a 0a		 push	 10			; 0000000aH
  00224	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0022b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00231	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00235	52		 push	 edx
  00236	8d 45 ee	 lea	 eax, DWORD PTR _pMsgSend$[ebp+6]
  00239	50		 push	 eax
  0023a	e8 00 00 00 00	 call	 _memcpy
  0023f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21813: 
; 21814: 				pMsgSend.bDuelStart = FALSE;

  00242	c6 45 eb 00	 mov	 BYTE PTR _pMsgSend$[ebp+3], 0

; 21815: 				DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  00246	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  0024a	50		 push	 eax
  0024b	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  0024e	51		 push	 ecx
  0024f	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00258	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21816: 				return;

  0025b	e9 ba 05 00 00	 jmp	 $LN20@CGDuelOkRe
$LN8@CGDuelOkRe:

; 21817: 			}	
; 21818: 		}
; 21819: 	#endif		// #ifndef WORLD_TOURNAMENT_EVENT_SETTING	
; 21820: #endif
; 21821: 
; 21822: 
; 21823: 		//      
; 21824: 		if (CHECK_LIMIT(gObj[aIndex].m_iDuelUser, MAX_OBJECT)) {

  00260	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00267	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0026d	83 bc 01 ec 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3308], 0
  00275	7d 09		 jge	 SHORT $LN35@CGDuelOkRe
  00277	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv198[ebp], 0
  0027e	eb 2f		 jmp	 SHORT $LN36@CGDuelOkRe
$LN35@CGDuelOkRe:
  00280	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00287	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0028c	81 bc 10 ec 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3308], 7399 ; 00001ce7H
  00297	7e 09		 jle	 SHORT $LN33@CGDuelOkRe
  00299	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv197[ebp], 0
  002a0	eb 07		 jmp	 SHORT $LN34@CGDuelOkRe
$LN33@CGDuelOkRe:
  002a2	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv197[ebp], 1
$LN34@CGDuelOkRe:
  002a9	8b 4d 80	 mov	 ecx, DWORD PTR tv197[ebp]
  002ac	89 4d 84	 mov	 DWORD PTR tv198[ebp], ecx
$LN36@CGDuelOkRe:
  002af	83 7d 84 00	 cmp	 DWORD PTR tv198[ebp], 0
  002b3	0f 84 ac 00 00
	00		 je	 $LN11@CGDuelOkRe

; 21825: 			GCServerMsgStringSend(lMsg.Get(1184), aIndex, 1);		// "    ."

  002b9	6a 01		 push	 1
  002bb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002be	50		 push	 eax
  002bf	68 a0 04 00 00	 push	 1184			; 000004a0H
  002c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21826: 			GCServerMsgStringSend(lMsg.Get(1185), aIndex, 1);		// "    ."

  002d8	6a 01		 push	 1
  002da	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002dd	50		 push	 eax
  002de	68 a1 04 00 00	 push	 1185			; 000004a1H
  002e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002ee	50		 push	 eax
  002ef	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21827: 
; 21828: 			gObj[aIndex].m_iDuelUserRequested = -1;

  002f7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00304	c7 84 01 e8 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3304], -1

; 21829: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;

  0030f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00316	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0031c	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1

; 21830: 			memcpy(pMsgSend.szName, gObj[aIndex].Name, MAX_IDSTRING);

  00327	6a 0a		 push	 10			; 0000000aH
  00329	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00330	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00336	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0033a	52		 push	 edx
  0033b	8d 45 ee	 lea	 eax, DWORD PTR _pMsgSend$[ebp+6]
  0033e	50		 push	 eax
  0033f	e8 00 00 00 00	 call	 _memcpy
  00344	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21831: 
; 21832: 			pMsgSend.bDuelStart = FALSE;

  00347	c6 45 eb 00	 mov	 BYTE PTR _pMsgSend$[ebp+3], 0

; 21833: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  0034b	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  0034f	50		 push	 eax
  00350	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  00353	51		 push	 ecx
  00354	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  00357	52		 push	 edx
  00358	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0035d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21834: 			return;

  00360	e9 b5 04 00 00	 jmp	 $LN20@CGDuelOkRe
$LN11@CGDuelOkRe:

; 21835: 		}
; 21836: 
; 21837: 		//    
; 21838: 		if (CHECK_LIMIT(gObj[aIndex].m_iDuelUserReserved, MAX_OBJECT)) {

  00365	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0036c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00372	83 bc 01 e4 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3300], 0
  0037a	7d 09		 jge	 SHORT $LN39@CGDuelOkRe
  0037c	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv237[ebp], 0
  00383	eb 2f		 jmp	 SHORT $LN40@CGDuelOkRe
$LN39@CGDuelOkRe:
  00385	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0038c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00391	81 bc 10 e4 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3300], 7399 ; 00001ce7H
  0039c	7e 09		 jle	 SHORT $LN37@CGDuelOkRe
  0039e	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv236[ebp], 0
  003a5	eb 07		 jmp	 SHORT $LN38@CGDuelOkRe
$LN37@CGDuelOkRe:
  003a7	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv236[ebp], 1
$LN38@CGDuelOkRe:
  003ae	8b 4d 80	 mov	 ecx, DWORD PTR tv236[ebp]
  003b1	89 4d 84	 mov	 DWORD PTR tv237[ebp], ecx
$LN40@CGDuelOkRe:
  003b4	83 7d 84 00	 cmp	 DWORD PTR tv237[ebp], 0
  003b8	0f 84 8d 00 00
	00		 je	 $LN12@CGDuelOkRe

; 21839: 			GCServerMsgStringSend(lMsg.Get(1197), aIndex, 1);		// "    ."

  003be	6a 01		 push	 1
  003c0	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003c3	50		 push	 eax
  003c4	68 ad 04 00 00	 push	 1197			; 000004adH
  003c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003d4	50		 push	 eax
  003d5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21840: 
; 21841: 			gObj[aIndex].m_iDuelUserRequested = -1;

  003dd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ea	c7 84 01 e8 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3304], -1

; 21842: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;

  003f5	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  003fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00402	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1

; 21843: 
; 21844: 			memcpy(pMsgSend.szName, gObj[aIndex].Name, MAX_IDSTRING);

  0040d	6a 0a		 push	 10			; 0000000aH
  0040f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00416	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0041c	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00420	52		 push	 edx
  00421	8d 45 ee	 lea	 eax, DWORD PTR _pMsgSend$[ebp+6]
  00424	50		 push	 eax
  00425	e8 00 00 00 00	 call	 _memcpy
  0042a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21845: 
; 21846: 			pMsgSend.bDuelStart = FALSE;

  0042d	c6 45 eb 00	 mov	 BYTE PTR _pMsgSend$[ebp+3], 0

; 21847: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  00431	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  00435	50		 push	 eax
  00436	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  00439	51		 push	 ecx
  0043a	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  0043d	52		 push	 edx
  0043e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00443	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21848: 			return;

  00446	e9 cf 03 00 00	 jmp	 $LN20@CGDuelOkRe
$LN12@CGDuelOkRe:

; 21849: 		}
; 21850: 
; 21851: 		if (gObj[iDuelIndex].m_iDuelUserReserved == aIndex) {

  0044b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00452	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00458	8b 94 01 e4 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3300]
  0045f	3b 55 0c	 cmp	 edx, DWORD PTR _aIndex$[ebp]
  00462	0f 85 69 03 00
	00		 jne	 $LN13@CGDuelOkRe

; 21852: 			//       .
; 21853: 			CHAR szDuelName[11] = {0,}, szDuelName2[11] = {0,};

  00468	33 c0		 xor	 eax, eax
  0046a	89 45 dc	 mov	 DWORD PTR _szDuelName$4[ebp], eax
  0046d	89 45 e0	 mov	 DWORD PTR _szDuelName$4[ebp+4], eax
  00470	66 89 45 e4	 mov	 WORD PTR _szDuelName$4[ebp+8], ax
  00474	88 45 e6	 mov	 BYTE PTR _szDuelName$4[ebp+10], al
  00477	33 c0		 xor	 eax, eax
  00479	89 45 d0	 mov	 DWORD PTR _szDuelName2$3[ebp], eax
  0047c	89 45 d4	 mov	 DWORD PTR _szDuelName2$3[ebp+4], eax
  0047f	66 89 45 d8	 mov	 WORD PTR _szDuelName2$3[ebp+8], ax
  00483	88 45 da	 mov	 BYTE PTR _szDuelName2$3[ebp+10], al

; 21854: 			memcpy (szDuelName, gObj[iDuelIndex].Name, MAX_IDSTRING);	szDuelName[10] = 0;

  00486	6a 0a		 push	 10			; 0000000aH
  00488	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0048f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00495	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00499	52		 push	 edx
  0049a	8d 45 dc	 lea	 eax, DWORD PTR _szDuelName$4[ebp]
  0049d	50		 push	 eax
  0049e	e8 00 00 00 00	 call	 _memcpy
  004a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a6	b8 01 00 00 00	 mov	 eax, 1
  004ab	6b c8 0a	 imul	 ecx, eax, 10
  004ae	89 4d 8c	 mov	 DWORD PTR $T2[ebp], ecx
  004b1	83 7d 8c 0b	 cmp	 DWORD PTR $T2[ebp], 11	; 0000000bH
  004b5	73 02		 jae	 SHORT $LN41@CGDuelOkRe
  004b7	eb 05		 jmp	 SHORT $LN42@CGDuelOkRe
$LN41@CGDuelOkRe:
  004b9	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN42@CGDuelOkRe:
  004be	8b 55 8c	 mov	 edx, DWORD PTR $T2[ebp]
  004c1	c6 44 15 dc 00	 mov	 BYTE PTR _szDuelName$4[ebp+edx], 0

; 21855: 			memcpy (szDuelName2, lpMsg->szName, MAX_IDSTRING);			szDuelName2[10] = 0;

  004c6	6a 0a		 push	 10			; 0000000aH
  004c8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004cb	83 c0 06	 add	 eax, 6
  004ce	50		 push	 eax
  004cf	8d 4d d0	 lea	 ecx, DWORD PTR _szDuelName2$3[ebp]
  004d2	51		 push	 ecx
  004d3	e8 00 00 00 00	 call	 _memcpy
  004d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  004db	b8 01 00 00 00	 mov	 eax, 1
  004e0	6b c8 0a	 imul	 ecx, eax, 10
  004e3	89 4d 88	 mov	 DWORD PTR $T1[ebp], ecx
  004e6	83 7d 88 0b	 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  004ea	73 02		 jae	 SHORT $LN43@CGDuelOkRe
  004ec	eb 05		 jmp	 SHORT $LN44@CGDuelOkRe
$LN43@CGDuelOkRe:
  004ee	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN44@CGDuelOkRe:
  004f3	8b 55 88	 mov	 edx, DWORD PTR $T1[ebp]
  004f6	c6 44 15 d0 00	 mov	 BYTE PTR _szDuelName2$3[ebp+edx], 0

; 21856: 			
; 21857: 			if (!strcmp(szDuelName, szDuelName2)) {

  004fb	8d 45 d0	 lea	 eax, DWORD PTR _szDuelName2$3[ebp]
  004fe	50		 push	 eax
  004ff	8d 4d dc	 lea	 ecx, DWORD PTR _szDuelName$4[ebp]
  00502	51		 push	 ecx
  00503	e8 00 00 00 00	 call	 _strcmp
  00508	83 c4 08	 add	 esp, 8
  0050b	85 c0		 test	 eax, eax
  0050d	0f 85 71 02 00
	00		 jne	 $LN15@CGDuelOkRe

; 21858: 				//        ->  
; 21859: 
; 21860: 				if (lpMsg->bDuelOK == 0) {

  00513	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00516	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0051a	85 c9		 test	 ecx, ecx
  0051c	75 6e		 jne	 SHORT $LN17@CGDuelOkRe

; 21861: 					//   
; 21862: 					gObj[aIndex].m_iDuelUserRequested = -1;

  0051e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00525	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0052b	c7 84 01 e8 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3304], -1

; 21863: 					gObj[iDuelIndex].m_iDuelUserReserved = -1;

  00536	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0053d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00543	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1

; 21864: 
; 21865: 					memcpy(pMsgSend.szName, gObj[aIndex].Name, MAX_IDSTRING);

  0054e	6a 0a		 push	 10			; 0000000aH
  00550	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00557	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0055d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00561	52		 push	 edx
  00562	8d 45 ee	 lea	 eax, DWORD PTR _pMsgSend$[ebp+6]
  00565	50		 push	 eax
  00566	e8 00 00 00 00	 call	 _memcpy
  0056b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21866: 
; 21867: 					pMsgSend.bDuelStart = FALSE;

  0056e	c6 45 eb 00	 mov	 BYTE PTR _pMsgSend$[ebp+3], 0

; 21868: 					DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  00572	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  00576	50		 push	 eax
  00577	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  0057a	51		 push	 ecx
  0057b	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  0057e	52		 push	 edx
  0057f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00584	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21869: 				}

  00587	e9 f6 01 00 00	 jmp	 $LN18@CGDuelOkRe
$LN17@CGDuelOkRe:

; 21870: 				else if (lpMsg->bDuelOK == 1) {

  0058c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0058f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00593	83 f9 01	 cmp	 ecx, 1
  00596	0f 85 e6 01 00
	00		 jne	 $LN18@CGDuelOkRe

; 21871: 					//   
; 21872: 					
; 21873: 					gObj[iDuelIndex].m_iDuelUserReserved = -1;

  0059c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  005a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a9	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1

; 21874: 					gObj[iDuelIndex].m_btDuelScore = 0;

  005b4	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  005bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c1	c6 84 01 f0 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3312], 0

; 21875: 					gObj[iDuelIndex].m_iDuelUser = aIndex;

  005c9	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  005d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005d6	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005d9	89 94 01 ec 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3308], edx

; 21876: #ifdef DUEL_SYSTEM_FIX_20031224
; 21877: 					gObj[iDuelIndex].m_iDuelTickCount = GetTickCount();

  005e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  005e6	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iDuelIndex$[ebp], 7072
  005ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005f3	89 84 0a f4 0c
	00 00		 mov	 DWORD PTR [edx+ecx+3316], eax

; 21878: #endif
; 21879: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 21880: 					gObj[iDuelIndex].m_iDuelTimer = GetTickCount();
; 21881: #endif
; 21882: 
; 21883: 
; 21884: 					gObj[aIndex].m_iDuelUserRequested = -1;

  005fa	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00601	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00607	c7 84 01 e8 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3304], -1

; 21885: 					gObj[aIndex].m_iDuelUserReserved = -1;

  00612	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00619	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0061f	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1

; 21886: 					gObj[aIndex].m_btDuelScore = 0;

  0062a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00631	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00637	c6 84 01 f0 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3312], 0

; 21887: 					gObj[aIndex].m_iDuelUser = iDuelIndex;

  0063f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00646	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0064c	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  0064f	89 94 01 ec 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3308], edx

; 21888: #ifdef DUEL_SYSTEM_FIX_20031224
; 21889: 					gObj[aIndex].m_iDuelTickCount = GetTickCount();

  00656	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0065c	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00663	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00669	89 84 0a f4 0c
	00 00		 mov	 DWORD PTR [edx+ecx+3316], eax

; 21890: #endif
; 21891: 
; 21892: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 21893: 					gObj[aIndex].m_iDuelTimer = GetTickCount();
; 21894: #endif
; 21895: 					
; 21896: 					pMsgSend.bDuelStart = TRUE;

  00670	c6 45 eb 01	 mov	 BYTE PTR _pMsgSend$[ebp+3], 1

; 21897: 					
; 21898: 					//   
; 21899: 					pMsgSend.NumberH = HIBYTE(iDuelIndex);

  00674	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  00677	c1 e8 08	 shr	 eax, 8
  0067a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0067f	88 45 ec	 mov	 BYTE PTR _pMsgSend$[ebp+4], al

; 21900: 					pMsgSend.NumberL = LOBYTE(iDuelIndex);

  00682	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  00685	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0068a	88 45 ed	 mov	 BYTE PTR _pMsgSend$[ebp+5], al

; 21901: 					memcpy(pMsgSend.szName, szDuelName, MAX_IDSTRING);

  0068d	6a 0a		 push	 10			; 0000000aH
  0068f	8d 45 dc	 lea	 eax, DWORD PTR _szDuelName$4[ebp]
  00692	50		 push	 eax
  00693	8d 4d ee	 lea	 ecx, DWORD PTR _pMsgSend$[ebp+6]
  00696	51		 push	 ecx
  00697	e8 00 00 00 00	 call	 _memcpy
  0069c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21902: 					DataSend(aIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  0069f	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  006a3	50		 push	 eax
  006a4	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  006a7	51		 push	 ecx
  006a8	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  006ab	52		 push	 edx
  006ac	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21903: 					
; 21904: 					//   
; 21905: 					pMsgSend.NumberH = HIBYTE(aIndex);

  006b4	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006b7	c1 e8 08	 shr	 eax, 8
  006ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006bf	88 45 ec	 mov	 BYTE PTR _pMsgSend$[ebp+4], al

; 21906: 					pMsgSend.NumberL = LOBYTE(aIndex);

  006c2	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006c5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006ca	88 45 ed	 mov	 BYTE PTR _pMsgSend$[ebp+5], al

; 21907: 					memcpy(pMsgSend.szName, gObj[aIndex].Name, MAX_IDSTRING);

  006cd	6a 0a		 push	 10			; 0000000aH
  006cf	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006dc	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  006e0	52		 push	 edx
  006e1	8d 45 ee	 lea	 eax, DWORD PTR _pMsgSend$[ebp+6]
  006e4	50		 push	 eax
  006e5	e8 00 00 00 00	 call	 _memcpy
  006ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21908: 					DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  006ed	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  006f1	50		 push	 eax
  006f2	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  006f5	51		 push	 ecx
  006f6	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  006f9	52		 push	 edx
  006fa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21909: 					
; 21910: 					//    .
; 21911: 					GCSendDuelScore(gObj[aIndex].m_Index, gObj[iDuelIndex].m_Index);

  00702	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00709	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0070f	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00712	52		 push	 edx
  00713	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0071a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00720	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00723	52		 push	 edx
  00724	e8 00 00 00 00	 call	 ?GCSendDuelScore@@YAXHH@Z ; GCSendDuelScore
  00729	83 c4 08	 add	 esp, 8

; 21912: 					
; 21913: 					LogAddTD("[Duel] [%s][%s] Duel Started [%s][%s]",

  0072c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00733	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00739	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0073d	52		 push	 edx
  0073e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00745	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0074b	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0074f	52		 push	 edx
  00750	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00757	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0075d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00761	52		 push	 edx
  00762	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00769	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0076f	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00773	52		 push	 edx
  00774	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KCMDMGAG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL?$CF@
  00779	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0077f	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@CGDuelOkRe:

; 21914: 						gObj[aIndex].AccountID,
; 21915: 						gObj[aIndex].Name,
; 21916: 						gObj[iDuelIndex].AccountID,
; 21917: 						gObj[iDuelIndex].Name
; 21918: 						);
; 21919: 				}
; 21920: 			}

  00782	eb 4b		 jmp	 SHORT $LN16@CGDuelOkRe
$LN15@CGDuelOkRe:

; 21921: 			else {
; 21922: 				//      . ( )
; 21923: 				gObj[aIndex].m_iDuelUserRequested = -1;

  00784	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0078b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00791	c7 84 01 e8 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3304], -1

; 21924: 				gObj[iDuelIndex].m_iDuelUserReserved = -1;

  0079c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  007a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007a9	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1

; 21925: 				
; 21926: 				pMsgSend.bDuelStart = FALSE;

  007b4	c6 45 eb 00	 mov	 BYTE PTR _pMsgSend$[ebp+3], 0

; 21927: 				DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  007b8	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  007bc	50		 push	 eax
  007bd	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  007c0	51		 push	 ecx
  007c1	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  007c4	52		 push	 edx
  007c5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  007ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21928: 				return;

  007cd	eb 4b		 jmp	 SHORT $LN20@CGDuelOkRe
$LN16@CGDuelOkRe:

; 21929: 			}
; 21930: 		}

  007cf	eb 49		 jmp	 SHORT $LN20@CGDuelOkRe
$LN13@CGDuelOkRe:

; 21931: 		else {
; 21932: 			//      . ( ) ->       .
; 21933: 			gObj[aIndex].m_iDuelUserRequested = -1;

  007d1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007de	c7 84 01 e8 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3304], -1

; 21934: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;

  007e9	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  007f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007f6	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1

; 21935: 
; 21936: 			pMsgSend.bDuelStart = FALSE;

  00801	c6 45 eb 00	 mov	 BYTE PTR _pMsgSend$[ebp+3], 0

; 21937: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);

  00805	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsgSend$[ebp+1]
  00809	50		 push	 eax
  0080a	8d 4d e8	 lea	 ecx, DWORD PTR _pMsgSend$[ebp]
  0080d	51		 push	 ecx
  0080e	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  00811	52		 push	 edx
  00812	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00817	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@CGDuelOkRe:

; 21938: 		}
; 21939: 	}
; 21940: 	else {
; 21941: 		//    .
; 21942: 		return;
; 21943: 	}
; 21944: }

  0081a	5f		 pop	 edi
  0081b	5e		 pop	 esi
  0081c	5b		 pop	 ebx
  0081d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00820	33 cd		 xor	 ecx, ebp
  00822	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00827	8b e5		 mov	 esp, ebp
  00829	5d		 pop	 ebp
  0082a	c3		 ret	 0
?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ENDP	; CGDuelOkRequestRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z
_TEXT	SEGMENT
tv161 = -112						; size = 4
tv91 = -112						; size = 4
tv77 = -112						; size = 4
tv162 = -108						; size = 4
tv92 = -108						; size = 4
tv78 = -108						; size = 4
_pMsg$1 = -40						; size = 15
_pMsg$2 = -24						; size = 15
_iDuelIndex$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z PROC ; CGDuelEndRequestRecv, COMDAT

; 21677: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 21678: 
; 21679: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 21680: 	return;
; 21681: #endif
; 21682: 
; 21683: 	int iDuelIndex = -1;		//     

  00013	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iDuelIndex$[ebp], -1

; 21684: 
; 21685: 	// ..
; 21686: 	if( gObj[aIndex].CloseType != -1 )

  0001a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00027	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  0002c	83 fa ff	 cmp	 edx, -1
  0002f	74 05		 je	 SHORT $LN2@CGDuelEndR

; 21687: 	{
; 21688: 		return;

  00031	e9 c2 02 00 00	 jmp	 $LN1@CGDuelEndR
$LN2@CGDuelEndR:

; 21689: 	}
; 21690: 	
; 21691: 	//    
; 21692: 	if (CHECK_LIMIT(gObj[aIndex].m_iDuelUserReserved, MAX_OBJECT)) {

  00036	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00043	83 bc 01 e4 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3300], 0
  0004b	7d 09		 jge	 SHORT $LN14@CGDuelEndR
  0004d	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00054	eb 2f		 jmp	 SHORT $LN15@CGDuelEndR
$LN14@CGDuelEndR:
  00056	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00062	81 bc 10 e4 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3300], 7399 ; 00001ce7H
  0006d	7e 09		 jle	 SHORT $LN12@CGDuelEndR
  0006f	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  00076	eb 07		 jmp	 SHORT $LN13@CGDuelEndR
$LN12@CGDuelEndR:
  00078	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
$LN13@CGDuelEndR:
  0007f	8b 4d 90	 mov	 ecx, DWORD PTR tv77[ebp]
  00082	89 4d 94	 mov	 DWORD PTR tv78[ebp], ecx
$LN15@CGDuelEndR:
  00085	83 7d 94 00	 cmp	 DWORD PTR tv78[ebp], 0
  00089	74 18		 je	 SHORT $LN3@CGDuelEndR

; 21693: 		gObj[aIndex].m_iDuelUserReserved = -1;

  0008b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00098	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1
$LN3@CGDuelEndR:

; 21694: 	}
; 21695: 
; 21696: 	//   
; 21697: 	if (CHECK_LIMIT(gObj[aIndex].m_iDuelUser, MAX_OBJECT)) {

  000a3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b0	83 bc 01 ec 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3308], 0
  000b8	7d 09		 jge	 SHORT $LN18@CGDuelEndR
  000ba	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
  000c1	eb 2f		 jmp	 SHORT $LN19@CGDuelEndR
$LN18@CGDuelEndR:
  000c3	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cf	81 bc 10 ec 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3308], 7399 ; 00001ce7H
  000da	7e 09		 jle	 SHORT $LN16@CGDuelEndR
  000dc	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  000e3	eb 07		 jmp	 SHORT $LN17@CGDuelEndR
$LN16@CGDuelEndR:
  000e5	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
$LN17@CGDuelEndR:
  000ec	8b 4d 90	 mov	 ecx, DWORD PTR tv91[ebp]
  000ef	89 4d 94	 mov	 DWORD PTR tv92[ebp], ecx
$LN19@CGDuelEndR:
  000f2	83 7d 94 00	 cmp	 DWORD PTR tv92[ebp], 0
  000f6	0f 84 98 00 00
	00		 je	 $LN4@CGDuelEndR

; 21698: 		iDuelIndex = gObj[aIndex].m_iDuelUser;

  000fc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00103	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00109	8b 94 01 ec 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3308]
  00110	89 55 f8	 mov	 DWORD PTR _iDuelIndex$[ebp], edx

; 21699: 		gObj[aIndex].m_iDuelUser = -1;

  00113	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00120	c7 84 01 ec 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3308], -1

; 21700: //		GCServerMsgStringSend(" .", aIndex, 1);
; 21701: 
; 21702: 		PMSG_ANS_END_DUEL pMsg;
; 21703: 		pMsg.h.c = PMHC_BYTE;

  0012b	c6 45 e8 c1	 mov	 BYTE PTR _pMsg$2[ebp], 193 ; 000000c1H

; 21704: 		pMsg.h.headcode = 0xAB;

  0012f	c6 45 ea ab	 mov	 BYTE PTR _pMsg$2[ebp+2], 171 ; 000000abH

; 21705: 		pMsg.h.size = sizeof( pMsg );

  00133	c6 45 e9 0f	 mov	 BYTE PTR _pMsg$2[ebp+1], 15 ; 0000000fH

; 21706: 
; 21707: 		pMsg.NumberH = HIBYTE(iDuelIndex);

  00137	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  0013a	c1 e8 08	 shr	 eax, 8
  0013d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00142	88 45 eb	 mov	 BYTE PTR _pMsg$2[ebp+3], al

; 21708: 		pMsg.NumberL = LOBYTE(iDuelIndex);

  00145	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  00148	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0014d	88 45 ec	 mov	 BYTE PTR _pMsg$2[ebp+4], al

; 21709: 		memcpy(pMsg.szName, gObj[iDuelIndex].Name, MAX_IDSTRING);

  00150	6a 0a		 push	 10			; 0000000aH
  00152	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00159	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015f	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00163	52		 push	 edx
  00164	8d 45 ed	 lea	 eax, DWORD PTR _pMsg$2[ebp+5]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _memcpy
  0016d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21710: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00170	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$2[ebp+1]
  00174	50		 push	 eax
  00175	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$2[ebp]
  00178	51		 push	 ecx
  00179	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21711: 
; 21712: 		if( iDuelIndex == aIndex ) {

  00185	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  00188	3b 45 0c	 cmp	 eax, DWORD PTR _aIndex$[ebp]
  0018b	75 05		 jne	 SHORT $LN6@CGDuelEndR

; 21713: 			//        -> .
; 21714: 			return;

  0018d	e9 66 01 00 00	 jmp	 $LN1@CGDuelEndR
$LN6@CGDuelEndR:

; 21715: 		}
; 21716: 	}

  00192	eb 26		 jmp	 SHORT $LN5@CGDuelEndR
$LN4@CGDuelEndR:

; 21717: 	else {
; 21718: 		//     ->  .
; 21719: 		LogAdd("error : %s %d (%d)",__FILE__, __LINE__, iDuelIndex);

  00194	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  00197	50		 push	 eax
  00198	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z@4JA
  0019e	83 c1 2a	 add	 ecx, 42			; 0000002aH
  001a1	51		 push	 ecx
  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ@
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001b2	83 c4 10	 add	 esp, 16			; 00000010H

; 21720: 		return;

  001b5	e9 3e 01 00 00	 jmp	 $LN1@CGDuelEndR
$LN5@CGDuelEndR:

; 21721: 	}
; 21722: 
; 21723: 	//      .
; 21724: 	if (CHECK_LIMIT(gObj[iDuelIndex].m_iDuelUser, MAX_OBJECT)) {

  001ba	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  001c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c7	83 bc 01 ec 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3308], 0
  001cf	7d 09		 jge	 SHORT $LN22@CGDuelEndR
  001d1	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv162[ebp], 0
  001d8	eb 2f		 jmp	 SHORT $LN23@CGDuelEndR
$LN22@CGDuelEndR:
  001da	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _iDuelIndex$[ebp], 7072
  001e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e6	81 bc 10 ec 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3308], 7399 ; 00001ce7H
  001f1	7e 09		 jle	 SHORT $LN20@CGDuelEndR
  001f3	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv161[ebp], 0
  001fa	eb 07		 jmp	 SHORT $LN21@CGDuelEndR
$LN20@CGDuelEndR:
  001fc	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv161[ebp], 1
$LN21@CGDuelEndR:
  00203	8b 4d 90	 mov	 ecx, DWORD PTR tv161[ebp]
  00206	89 4d 94	 mov	 DWORD PTR tv162[ebp], ecx
$LN23@CGDuelEndR:
  00209	83 7d 94 00	 cmp	 DWORD PTR tv162[ebp], 0
  0020d	0f 84 e5 00 00
	00		 je	 $LN1@CGDuelEndR

; 21725: 		if (gObj[iDuelIndex].m_iDuelUser == aIndex) {

  00213	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0021a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00220	8b 94 01 ec 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3308]
  00227	3b 55 0c	 cmp	 edx, DWORD PTR _aIndex$[ebp]
  0022a	0f 85 c8 00 00
	00		 jne	 $LN1@CGDuelEndR

; 21726: 			//       .
; 21727: //			GCServerMsgStringSend("   .", iDuelIndex, 1);
; 21728: 			gObj[iDuelIndex].m_iDuelUser = -1;

  00230	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00237	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023d	c7 84 01 ec 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3308], -1

; 21729: 
; 21730: 
; 21731: 			PMSG_ANS_END_DUEL pMsg;
; 21732: 			pMsg.h.c = PMHC_BYTE;

  00248	c6 45 d8 c1	 mov	 BYTE PTR _pMsg$1[ebp], 193 ; 000000c1H

; 21733: 			pMsg.h.headcode = 0xAB;

  0024c	c6 45 da ab	 mov	 BYTE PTR _pMsg$1[ebp+2], 171 ; 000000abH

; 21734: 			pMsg.h.size = sizeof( pMsg );

  00250	c6 45 d9 0f	 mov	 BYTE PTR _pMsg$1[ebp+1], 15 ; 0000000fH

; 21735: 
; 21736: 			pMsg.NumberH = HIBYTE(aIndex);

  00254	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00257	c1 e8 08	 shr	 eax, 8
  0025a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0025f	88 45 db	 mov	 BYTE PTR _pMsg$1[ebp+3], al

; 21737: 			pMsg.NumberL = LOBYTE(aIndex);

  00262	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00265	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0026a	88 45 dc	 mov	 BYTE PTR _pMsg$1[ebp+4], al

; 21738: 
; 21739: 			memcpy(pMsg.szName, gObj[aIndex].Name, MAX_IDSTRING);

  0026d	6a 0a		 push	 10			; 0000000aH
  0026f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00276	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027c	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00280	52		 push	 edx
  00281	8d 45 dd	 lea	 eax, DWORD PTR _pMsg$1[ebp+5]
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 _memcpy
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21740: 			DataSend(iDuelIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0028d	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00291	50		 push	 eax
  00292	8d 4d d8	 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  00295	51		 push	 ecx
  00296	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  00299	52		 push	 edx
  0029a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0029f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21741: 
; 21742: 			LogAddTD("[Duel] [%s][%s] Duel Ended [%s][%s]",

  002a2	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  002a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002af	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  002b3	52		 push	 edx
  002b4	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  002bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c1	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  002c5	52		 push	 edx
  002c6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d3	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  002d7	52		 push	 edx
  002d8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e5	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  002e9	52		 push	 edx
  002ea	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN@
  002ef	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002f5	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CGDuelEndR:

; 21743: 				gObj[aIndex].AccountID,
; 21744: 				gObj[aIndex].Name,
; 21745: 				gObj[iDuelIndex].AccountID,
; 21746: 				gObj[iDuelIndex].Name
; 21747: 				);
; 21748: 		}
; 21749: 		else {
; 21750: 			//     !!
; 21751: 			return;
; 21752: 		}
; 21753: 	}
; 21754: 	else {
; 21755: 		//       !! ->  .
; 21756: 		return;
; 21757: 	}
; 21758: }

  002f8	5f		 pop	 edi
  002f9	5e		 pop	 esi
  002fa	5b		 pop	 ebx
  002fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fe	33 cd		 xor	 ecx, ebp
  00300	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00305	8b e5		 mov	 esp, ebp
  00307	5d		 pop	 ebp
  00308	c3		 ret	 0
?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ENDP ; CGDuelEndRequestRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z
_TEXT	SEGMENT
tv459 = -396						; size = 4
tv436 = -396						; size = 4
tv413 = -396						; size = 4
tv366 = -396						; size = 4
tv206 = -396						; size = 4
tv176 = -396						; size = 4
tv151 = -396						; size = 4
tv128 = -396						; size = 4
tv460 = -392						; size = 4
tv437 = -392						; size = 4
tv414 = -392						; size = 4
tv367 = -392						; size = 4
tv207 = -392						; size = 4
tv177 = -392						; size = 4
tv152 = -392						; size = 4
tv129 = -392						; size = 4
$T1 = -388						; size = 4
$T2 = -384						; size = 4
_pMsg$ = -316						; size = 15
_n$ = -300						; size = 4
_bRetVal$ = -296					; size = 4
_szDuelName2$ = -292					; size = 11
_szDuelName$ = -280					; size = 11
_lpObj$ = -268						; size = 4
_szTempText$ = -264					; size = 256
_iDuelIndex$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z PROC ; CGDuelStartRequestRecv, COMDAT

; 21398: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 21399: 
; 21400: 
; 21401: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 21402: 	return;
; 21403: #endif
; 21404: 
; 21405: 	int iDuelIndex = -1;		//    

  00016	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iDuelIndex$[ebp], -1

; 21406: 	char szTempText [256];
; 21407: 	
; 21408: 	// ..
; 21409: 	if( gObj[aIndex].CloseType != -1 )

  0001d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002a	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  0002f	83 fa ff	 cmp	 edx, -1
  00032	74 05		 je	 SHORT $LN8@CGDuelStar

; 21410: 	{
; 21411: 		return;

  00034	e9 8b 0b 00 00	 jmp	 $LN39@CGDuelStar
$LN8@CGDuelStar:

; 21412: 	}
; 21413: 
; 21414: 	if (gNonPK) {

  00039	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK
  00040	74 24		 je	 SHORT $LN9@CGDuelStar

; 21415: 		GCServerMsgStringSend(lMsg.Get(1198), aIndex, 1);	// "NON-PK     ."

  00042	6a 01		 push	 1
  00044	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00047	50		 push	 eax
  00048	68 ae 04 00 00	 push	 1198			; 000004aeH
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21416: 		return;

  00061	e9 5e 0b 00 00	 jmp	 $LN39@CGDuelStar
$LN9@CGDuelStar:

; 21417: 	}
; 21418: 
; 21419: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 21420: 	if (!gPkLimitFree) {

  00066	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  0006d	75 3e		 jne	 SHORT $LN10@CGDuelStar

; 21421: #endif
; 21422: 
; 21423: #ifdef UPDATE_PK_SYSTEM_20070302	//     
; 21424: 	BOOL	PKFlag = FALSE;
; 21425: 	if(gObj[aIndex].PartyNumber >= 0)	//  
; 21426: 	{
; 21427: 		if( gParty.GetPKPartyPenalty(gObj[aIndex].PartyNumber) >= PK_LEVEL_DEFAULT+3)
; 21428: 		{
; 21429: 			PKFlag = TRUE;
; 21430: 		}
; 21431: 	}
; 21432: 	else
; 21433: 	{
; 21434: 		if(gObj[aIndex].m_PK_Level >= PK_LEVEL_DEFAULT+3)
; 21435: 		{
; 21436: 			PKFlag = TRUE;
; 21437: 		}
; 21438: 	}
; 21439: 	
; 21440: 	if(PKFlag == TRUE) {
; 21441: #else	// UPDATE_PK_SYSTEM_20070302
; 21442: 	if (gObj[aIndex].m_PK_Level >= PK_LEVEL_DEFAULT+3) {

  0006f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007c	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00084	83 fa 06	 cmp	 edx, 6
  00087	7c 24		 jl	 SHORT $LN10@CGDuelStar

; 21443: #endif	// UPDATE_PK_SYSTEM_20070302
; 21444: 
; 21445: 		GCServerMsgStringSend(lMsg.Get(1199), aIndex, 1);	// "    ."

  00089	6a 01		 push	 1
  0008b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0008e	50		 push	 eax
  0008f	68 af 04 00 00	 push	 1199			; 000004afH
  00094	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21446: 		return;

  000a8	e9 17 0b 00 00	 jmp	 $LN39@CGDuelStar
$LN10@CGDuelStar:

; 21447: 	}
; 21448: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 21449: 	}
; 21450: #endif
; 21451: 
; 21452: 	//    
; 21453: 	if (CHECK_LIMIT(gObj[aIndex].m_iDuelUserReserved, MAX_OBJECT)) {

  000ad	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ba	83 bc 01 e4 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3300], 0
  000c2	7d 0c		 jge	 SHORT $LN42@CGDuelStar
  000c4	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv129[ebp], 0
  000ce	eb 3b		 jmp	 SHORT $LN43@CGDuelStar
$LN42@CGDuelStar:
  000d0	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000dc	81 bc 10 e4 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3300], 7399 ; 00001ce7H
  000e7	7e 0c		 jle	 SHORT $LN40@CGDuelStar
  000e9	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv128[ebp], 0
  000f3	eb 0a		 jmp	 SHORT $LN41@CGDuelStar
$LN40@CGDuelStar:
  000f5	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv128[ebp], 1
$LN41@CGDuelStar:
  000ff	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR tv128[ebp]
  00105	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
$LN43@CGDuelStar:
  0010b	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR tv129[ebp], 0
  00112	74 43		 je	 SHORT $LN12@CGDuelStar

; 21454: 		GCServerMsgStringSend(lMsg.Get(1183), aIndex, 1);	// "    ."

  00114	6a 01		 push	 1
  00116	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00119	50		 push	 eax
  0011a	68 9f 04 00 00	 push	 1183			; 0000049fH
  0011f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21455: 		GCServerMsgStringSend(lMsg.Get(1185), aIndex, 1);	// "    ."

  00133	6a 01		 push	 1
  00135	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00138	50		 push	 eax
  00139	68 a1 04 00 00	 push	 1185			; 000004a1H
  0013e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21456: 		return;

  00152	e9 6d 0a 00 00	 jmp	 $LN39@CGDuelStar
$LN12@CGDuelStar:

; 21457: 	}
; 21458: 
; 21459: 	//     
; 21460: 	if (CHECK_LIMIT(gObj[aIndex].m_iDuelUser, MAX_OBJECT)) {

  00157	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00164	83 bc 01 ec 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3308], 0
  0016c	7d 0c		 jge	 SHORT $LN46@CGDuelStar
  0016e	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv152[ebp], 0
  00178	eb 3b		 jmp	 SHORT $LN47@CGDuelStar
$LN46@CGDuelStar:
  0017a	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00181	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00186	81 bc 10 ec 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3308], 7399 ; 00001ce7H
  00191	7e 0c		 jle	 SHORT $LN44@CGDuelStar
  00193	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv151[ebp], 0
  0019d	eb 0a		 jmp	 SHORT $LN45@CGDuelStar
$LN44@CGDuelStar:
  0019f	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv151[ebp], 1
$LN45@CGDuelStar:
  001a9	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR tv151[ebp]
  001af	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv152[ebp], ecx
$LN47@CGDuelStar:
  001b5	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR tv152[ebp], 0
  001bc	74 43		 je	 SHORT $LN13@CGDuelStar

; 21461: 		GCServerMsgStringSend(lMsg.Get(1184), aIndex, 1);	// "    ."

  001be	6a 01		 push	 1
  001c0	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001c3	50		 push	 eax
  001c4	68 a0 04 00 00	 push	 1184			; 000004a0H
  001c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21462: 		GCServerMsgStringSend(lMsg.Get(1185), aIndex, 1);	// "    ."

  001dd	6a 01		 push	 1
  001df	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001e2	50		 push	 eax
  001e3	68 a1 04 00 00	 push	 1185			; 000004a1H
  001e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21463: 		return;

  001fc	e9 c3 09 00 00	 jmp	 $LN39@CGDuelStar
$LN13@CGDuelStar:

; 21464: 	}
; 21465: 
; 21466: #ifdef CHAOSCASTLE_SYSTEM_20040408		//       .
; 21467: 	#ifndef WORLD_TOURNAMENT_EVENT_SETTING	
; 21468: 		if (CHECK_CHAOSCASTLE(gObj[aIndex].MapNumber)) {

  00201	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0020e	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00216	83 fa 12	 cmp	 edx, 18			; 00000012H
  00219	7d 0c		 jge	 SHORT $LN50@CGDuelStar
  0021b	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv177[ebp], 0
  00225	eb 3c		 jmp	 SHORT $LN51@CGDuelStar
$LN50@CGDuelStar:
  00227	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0022e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00234	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0023c	83 fa 17	 cmp	 edx, 23			; 00000017H
  0023f	7e 0c		 jle	 SHORT $LN48@CGDuelStar
  00241	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv176[ebp], 0
  0024b	eb 0a		 jmp	 SHORT $LN49@CGDuelStar
$LN48@CGDuelStar:
  0024d	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv176[ebp], 1
$LN49@CGDuelStar:
  00257	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  0025d	89 85 78 fe ff
	ff		 mov	 DWORD PTR tv177[ebp], eax
$LN51@CGDuelStar:
  00263	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR tv177[ebp], 0
  0026a	74 24		 je	 SHORT $LN14@CGDuelStar

; 21469: 			GCServerMsgStringSend(lMsg.Get(1231), aIndex, 1);	// "       ."

  0026c	6a 01		 push	 1
  0026e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00271	50		 push	 eax
  00272	68 cf 04 00 00	 push	 1231			; 000004cfH
  00277	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0027c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00288	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21470: 			return;

  0028b	e9 34 09 00 00	 jmp	 $LN39@CGDuelStar
$LN14@CGDuelStar:

; 21471: 		}
; 21472: 	#endif
; 21473: #endif	
; 21474: 	
; 21475: 	LPOBJECTSTRUCT lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00290	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00297	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0029d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], eax

; 21476: 	if( PacketCheckTime(lpObj) == FALSE ) return;

  002a3	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a9	50		 push	 eax
  002aa	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  002af	83 c4 04	 add	 esp, 4
  002b2	85 c0		 test	 eax, eax
  002b4	75 05		 jne	 SHORT $LN15@CGDuelStar
  002b6	e9 09 09 00 00	 jmp	 $LN39@CGDuelStar
$LN15@CGDuelStar:

; 21477: 
; 21478: 	iDuelIndex = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  002bb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002be	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  002c2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002c8	0f b6 d1	 movzx	 edx, cl
  002cb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002ce	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  002d2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002d8	0f b6 c1	 movzx	 eax, cl
  002db	c1 e0 08	 shl	 eax, 8
  002de	0b d0		 or	 edx, eax
  002e0	0f b7 ca	 movzx	 ecx, dx
  002e3	89 4d f8	 mov	 DWORD PTR _iDuelIndex$[ebp], ecx

; 21479: 	
; 21480: 	if( !CHECK_LIMIT(iDuelIndex, MAX_OBJECT) )

  002e6	83 7d f8 00	 cmp	 DWORD PTR _iDuelIndex$[ebp], 0
  002ea	7d 0c		 jge	 SHORT $LN54@CGDuelStar
  002ec	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv207[ebp], 0
  002f6	eb 2b		 jmp	 SHORT $LN55@CGDuelStar
$LN54@CGDuelStar:
  002f8	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _iDuelIndex$[ebp], 7399 ; 00001ce7H
  002ff	7e 0c		 jle	 SHORT $LN52@CGDuelStar
  00301	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv206[ebp], 0
  0030b	eb 0a		 jmp	 SHORT $LN53@CGDuelStar
$LN52@CGDuelStar:
  0030d	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv206[ebp], 1
$LN53@CGDuelStar:
  00317	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0031d	89 85 78 fe ff
	ff		 mov	 DWORD PTR tv207[ebp], eax
$LN55@CGDuelStar:
  00323	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR tv207[ebp], 0
  0032a	75 26		 jne	 SHORT $LN16@CGDuelStar

; 21481: 	{
; 21482: 		LogAdd("error : %s %d (%d)",__FILE__, __LINE__, iDuelIndex);

  0032c	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  0032f	50		 push	 eax
  00330	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z@4JA
  00336	83 c1 54	 add	 ecx, 84			; 00000054H
  00339	51		 push	 ecx
  0033a	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0033f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ@
  00344	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0034a	83 c4 10	 add	 esp, 16			; 00000010H

; 21483: 		return;

  0034d	e9 72 08 00 00	 jmp	 $LN39@CGDuelStar
$LN16@CGDuelStar:

; 21484: 	}
; 21485: 
; 21486: 	//     .
; 21487: 	if( iDuelIndex == aIndex ) return;

  00352	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  00355	3b 45 0c	 cmp	 eax, DWORD PTR _aIndex$[ebp]
  00358	75 05		 jne	 SHORT $LN17@CGDuelStar
  0035a	e9 65 08 00 00	 jmp	 $LN39@CGDuelStar
$LN17@CGDuelStar:

; 21488: 
; 21489: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 21490: 	if (!gPkLimitFree) {

  0035f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00366	75 3e		 jne	 SHORT $LN18@CGDuelStar

; 21491: #endif
; 21492: #ifdef UPDATE_PK_SYSTEM_20070302	//     
; 21493: 	BOOL	PKFlag = FALSE;
; 21494: 	if(gObj[aIndex].PartyNumber >= 0)	//  
; 21495: 	{
; 21496: 		if( gParty.GetPKPartyPenalty(gObj[aIndex].PartyNumber) >= PK_LEVEL_DEFAULT+3)
; 21497: 		{
; 21498: 			PKFlag = TRUE;
; 21499: 		}
; 21500: 	}
; 21501: 	else
; 21502: 	{
; 21503: 		if(gObj[aIndex].m_PK_Level >= PK_LEVEL_DEFAULT+3)
; 21504: 		{
; 21505: 			PKFlag = TRUE;
; 21506: 		}
; 21507: 	}
; 21508: 	
; 21509: 	if(PKFlag == TRUE) {
; 21510: #else	// UPDATE_PK_SYSTEM_20070302
; 21511: 	if (gObj[iDuelIndex].m_PK_Level >= PK_LEVEL_DEFAULT+3) {

  00368	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0036f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00375	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  0037d	83 fa 06	 cmp	 edx, 6
  00380	7c 24		 jl	 SHORT $LN18@CGDuelStar

; 21512: #endif	// UPDATE_PK_SYSTEM_20070302
; 21513: 
; 21514: 		GCServerMsgStringSend(lMsg.Get(1200), aIndex, 1);		// "    ."

  00382	6a 01		 push	 1
  00384	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00387	50		 push	 eax
  00388	68 b0 04 00 00	 push	 1200			; 000004b0H
  0038d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00392	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00398	50		 push	 eax
  00399	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0039e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21515: 		return;

  003a1	e9 1e 08 00 00	 jmp	 $LN39@CGDuelStar
$LN18@CGDuelStar:

; 21516: 	}
; 21517: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 21518: 	}
; 21519: #endif
; 21520: 
; 21521: 	//       .
; 21522: 	CHAR szDuelName[11] = {0,}, szDuelName2[11] = {0,};

  003a6	33 c0		 xor	 eax, eax
  003a8	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp], eax
  003ae	89 85 ec fe ff
	ff		 mov	 DWORD PTR _szDuelName$[ebp+4], eax
  003b4	66 89 85 f0 fe
	ff ff		 mov	 WORD PTR _szDuelName$[ebp+8], ax
  003bb	88 85 f2 fe ff
	ff		 mov	 BYTE PTR _szDuelName$[ebp+10], al
  003c1	33 c0		 xor	 eax, eax
  003c3	89 85 dc fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp], eax
  003c9	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _szDuelName2$[ebp+4], eax
  003cf	66 89 85 e4 fe
	ff ff		 mov	 WORD PTR _szDuelName2$[ebp+8], ax
  003d6	88 85 e6 fe ff
	ff		 mov	 BYTE PTR _szDuelName2$[ebp+10], al

; 21523: 	memcpy (szDuelName, gObj[iDuelIndex].Name, MAX_IDSTRING);		szDuelName[10] = 0;

  003dc	6a 0a		 push	 10			; 0000000aH
  003de	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  003e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003eb	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  003ef	52		 push	 edx
  003f0	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _szDuelName$[ebp]
  003f6	50		 push	 eax
  003f7	e8 00 00 00 00	 call	 _memcpy
  003fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ff	b8 01 00 00 00	 mov	 eax, 1
  00404	6b c8 0a	 imul	 ecx, eax, 10
  00407	89 8d 80 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  0040d	83 bd 80 fe ff
	ff 0b		 cmp	 DWORD PTR $T2[ebp], 11	; 0000000bH
  00414	73 02		 jae	 SHORT $LN56@CGDuelStar
  00416	eb 05		 jmp	 SHORT $LN57@CGDuelStar
$LN56@CGDuelStar:
  00418	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN57@CGDuelStar:
  0041d	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  00423	c6 84 15 e8 fe
	ff ff 00	 mov	 BYTE PTR _szDuelName$[ebp+edx], 0

; 21524: 	memcpy (szDuelName2, lpMsg->szName, MAX_IDSTRING);				szDuelName2[10] = 0;

  0042b	6a 0a		 push	 10			; 0000000aH
  0042d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00430	83 c0 05	 add	 eax, 5
  00433	50		 push	 eax
  00434	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _szDuelName2$[ebp]
  0043a	51		 push	 ecx
  0043b	e8 00 00 00 00	 call	 _memcpy
  00440	83 c4 0c	 add	 esp, 12			; 0000000cH
  00443	b8 01 00 00 00	 mov	 eax, 1
  00448	6b c8 0a	 imul	 ecx, eax, 10
  0044b	89 8d 7c fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00451	83 bd 7c fe ff
	ff 0b		 cmp	 DWORD PTR $T1[ebp], 11	; 0000000bH
  00458	73 02		 jae	 SHORT $LN58@CGDuelStar
  0045a	eb 05		 jmp	 SHORT $LN59@CGDuelStar
$LN58@CGDuelStar:
  0045c	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN59@CGDuelStar:
  00461	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00467	c6 84 15 dc fe
	ff ff 00	 mov	 BYTE PTR _szDuelName2$[ebp+edx], 0

; 21525: 
; 21526: 	if(strcmp(szDuelName, szDuelName2)) {

  0046f	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _szDuelName2$[ebp]
  00475	50		 push	 eax
  00476	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _szDuelName$[ebp]
  0047c	51		 push	 ecx
  0047d	e8 00 00 00 00	 call	 _strcmp
  00482	83 c4 08	 add	 esp, 8
  00485	85 c0		 test	 eax, eax
  00487	74 24		 je	 SHORT $LN20@CGDuelStar

; 21527: 		GCServerMsgStringSend(lMsg.Get(1186), aIndex, 1);		// "       ."

  00489	6a 01		 push	 1
  0048b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0048e	50		 push	 eax
  0048f	68 a2 04 00 00	 push	 1186			; 000004a2H
  00494	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00499	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0049f	50		 push	 eax
  004a0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21528: 		return;

  004a8	e9 17 07 00 00	 jmp	 $LN39@CGDuelStar
$LN20@CGDuelStar:

; 21529: 	}
; 21530: 
; 21531: 	//       .
; 21532: 	if (!IsDuelEnable(iDuelIndex)) {

  004ad	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  004b0	50		 push	 eax
  004b1	e8 00 00 00 00	 call	 ?IsDuelEnable@@YA_NH@Z	; IsDuelEnable
  004b6	83 c4 04	 add	 esp, 4
  004b9	0f b6 c8	 movzx	 ecx, al
  004bc	85 c9		 test	 ecx, ecx
  004be	75 24		 jne	 SHORT $LN21@CGDuelStar

; 21533: 		GCServerMsgStringSend(lMsg.Get(1187), aIndex, 1);		// "  ."

  004c0	6a 01		 push	 1
  004c2	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004c5	50		 push	 eax
  004c6	68 a3 04 00 00	 push	 1187			; 000004a3H
  004cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  004d6	50		 push	 eax
  004d7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21534: 		return;

  004df	e9 e0 06 00 00	 jmp	 $LN39@CGDuelStar
$LN21@CGDuelStar:

; 21535: 	}
; 21536: 
; 21537: 	//       .
; 21538: 	if (lpObj->lpGuild && lpObj->lpGuild->WarState == 1) {

  004e4	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  004ea	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  004f1	74 3c		 je	 SHORT $LN22@CGDuelStar
  004f3	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f9	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  004ff	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  00506	83 fa 01	 cmp	 edx, 1
  00509	75 24		 jne	 SHORT $LN22@CGDuelStar

; 21539: 		GCServerMsgStringSend(lMsg.Get(1188), aIndex, 1);		// "     ."

  0050b	6a 01		 push	 1
  0050d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00510	50		 push	 eax
  00511	68 a4 04 00 00	 push	 1188			; 000004a4H
  00516	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0051b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00521	50		 push	 eax
  00522	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00527	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21540: 		return;

  0052a	e9 95 06 00 00	 jmp	 $LN39@CGDuelStar
$LN22@CGDuelStar:

; 21541: 	}
; 21542: 
; 21543: 	//       .
; 21544: 	if (gObj[iDuelIndex].lpGuild && gObj[iDuelIndex].lpGuild->WarState == 1) {

  0052f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00536	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0053c	83 bc 01 94 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+660], 0
  00544	74 44		 je	 SHORT $LN23@CGDuelStar
  00546	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0054d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00553	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  0055a	0f b6 82 91 05
	00 00		 movzx	 eax, BYTE PTR [edx+1425]
  00561	83 f8 01	 cmp	 eax, 1
  00564	75 24		 jne	 SHORT $LN23@CGDuelStar

; 21545: 		GCServerMsgStringSend(lMsg.Get(1189), aIndex, 1);		// "      ."

  00566	6a 01		 push	 1
  00568	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0056b	50		 push	 eax
  0056c	68 a5 04 00 00	 push	 1189			; 000004a5H
  00571	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00576	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0057c	50		 push	 eax
  0057d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00582	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21546: 		return;

  00585	e9 3a 06 00 00	 jmp	 $LN39@CGDuelStar
$LN23@CGDuelStar:

; 21547: 	}
; 21548: 
; 21549: 	//    .
; 21550: 	if( gObjIsConnected(iDuelIndex) == FALSE ) return;

  0058a	8b 45 f8	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  0058d	50		 push	 eax
  0058e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00593	83 c4 04	 add	 esp, 4
  00596	85 c0		 test	 eax, eax
  00598	75 05		 jne	 SHORT $LN24@CGDuelStar
  0059a	e9 25 06 00 00	 jmp	 $LN39@CGDuelStar
$LN24@CGDuelStar:

; 21551: 	if( gObj[iDuelIndex].Type == OBJTYPE_MONSTER ) return;

  0059f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  005a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ac	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  005b1	83 fa 02	 cmp	 edx, 2
  005b4	75 05		 jne	 SHORT $LN25@CGDuelStar
  005b6	e9 09 06 00 00	 jmp	 $LN39@CGDuelStar
$LN25@CGDuelStar:

; 21552: 	if( gObj[iDuelIndex].CloseCount >= 0 ) return;

  005bb	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  005c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c8	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  005cd	85 d2		 test	 edx, edx
  005cf	7c 05		 jl	 SHORT $LN26@CGDuelStar
  005d1	e9 ee 05 00 00	 jmp	 $LN39@CGDuelStar
$LN26@CGDuelStar:

; 21553: 
; 21554: 
; 21555: #ifdef DUEL_SYSTEM_FIX_20031224
; 21556: 	//      .
; 21557: 	BOOL bRetVal = FALSE;

  005d6	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bRetVal$[ebp], 0

; 21558: 	int n;
; 21559: 	for( n=0; n<MAXSELFDEFENSE; n++) {

  005e0	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  005ea	eb 0f		 jmp	 SHORT $LN4@CGDuelStar
$LN2@CGDuelStar:
  005ec	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  005f2	83 c0 01	 add	 eax, 1
  005f5	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LN4@CGDuelStar:
  005fb	83 bd d4 fe ff
	ff 07		 cmp	 DWORD PTR _n$[ebp], 7
  00602	7d 24		 jge	 SHORT $LN3@CGDuelStar

; 21560: 		//       .
; 21561: 		if( lpObj->SelfDefense[n] >= 0) {

  00604	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  0060a	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00610	83 bc 81 40 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax*4+576], 0
  00618	7c 0c		 jl	 SHORT $LN27@CGDuelStar

; 21562: 			bRetVal = TRUE;

  0061a	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bRetVal$[ebp], 1

; 21563: 			break;

  00624	eb 02		 jmp	 SHORT $LN3@CGDuelStar
$LN27@CGDuelStar:

; 21564: 		}
; 21565: 	}

  00626	eb c4		 jmp	 SHORT $LN2@CGDuelStar
$LN3@CGDuelStar:

; 21566: 	if (bRetVal) {

  00628	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _bRetVal$[ebp], 0
  0062f	74 24		 je	 SHORT $LN28@CGDuelStar

; 21567: 		GCServerMsgStringSend(lMsg.Get(1213), aIndex, 1);		// "      ."

  00631	6a 01		 push	 1
  00633	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00636	50		 push	 eax
  00637	68 bd 04 00 00	 push	 1213			; 000004bdH
  0063c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00641	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00647	50		 push	 eax
  00648	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0064d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21568: 		return;

  00650	e9 6f 05 00 00	 jmp	 $LN39@CGDuelStar
$LN28@CGDuelStar:

; 21569: 	}
; 21570: 	for( n=0; n<MAXSELFDEFENSE; n++) {

  00655	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  0065f	eb 0f		 jmp	 SHORT $LN7@CGDuelStar
$LN5@CGDuelStar:
  00661	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00667	83 c0 01	 add	 eax, 1
  0066a	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LN7@CGDuelStar:
  00670	83 bd d4 fe ff
	ff 07		 cmp	 DWORD PTR _n$[ebp], 7
  00677	7d 2b		 jge	 SHORT $LN6@CGDuelStar

; 21571: 		//       .
; 21572: 		if( gObj[iDuelIndex].SelfDefense[n] >= 0) {

  00679	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00680	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00686	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$[ebp]
  0068c	83 bc 88 40 02
	00 00 00	 cmp	 DWORD PTR [eax+ecx*4+576], 0
  00694	7c 0c		 jl	 SHORT $LN29@CGDuelStar

; 21573: 			bRetVal = TRUE;

  00696	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bRetVal$[ebp], 1

; 21574: 			break;

  006a0	eb 02		 jmp	 SHORT $LN6@CGDuelStar
$LN29@CGDuelStar:

; 21575: 		}
; 21576: 	}

  006a2	eb bd		 jmp	 SHORT $LN5@CGDuelStar
$LN6@CGDuelStar:

; 21577: 	if (bRetVal) {

  006a4	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _bRetVal$[ebp], 0
  006ab	74 24		 je	 SHORT $LN30@CGDuelStar

; 21578: 		GCServerMsgStringSend(lMsg.Get(1213), aIndex, 1);		// "      ."

  006ad	6a 01		 push	 1
  006af	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006b2	50		 push	 eax
  006b3	68 bd 04 00 00	 push	 1213			; 000004bdH
  006b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  006bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  006c3	50		 push	 eax
  006c4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  006c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21579: 		return;

  006cc	e9 f3 04 00 00	 jmp	 $LN39@CGDuelStar
$LN30@CGDuelStar:

; 21580: 	}
; 21581: #endif
; 21582: 
; 21583: 	if( gObj[iDuelIndex].m_stateEngagePVP == PVP_USER_PLAYING )

  006d1	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  006d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006de	83 bc 01 80 1a
	00 00 02	 cmp	 DWORD PTR [ecx+eax+6784], 2
  006e6	75 18		 jne	 SHORT $LN31@CGDuelStar

; 21584: 	{
; 21585: 		GCServerMsgStringSend("[PVP Event] Accion no permitida", aIndex, 1);

  006e8	6a 01		 push	 1
  006ea	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006ed	50		 push	 eax
  006ee	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DGNFGBFP@?$FLPVP?5Event?$FN?5Accion?5no?5permitida@
  006f3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  006f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21586: 		return;

  006fb	e9 c4 04 00 00	 jmp	 $LN39@CGDuelStar
$LN31@CGDuelStar:

; 21587: 	}
; 21588: 
; 21589: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 21590: 	if( CHECK_DEVILSQUARE(gObj[iDuelIndex].MapNumber) )
; 21591: #else
; 21592: 	if( gObj[iDuelIndex].MapNumber == 9 )

  00700	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00707	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0070d	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00715	83 fa 09	 cmp	 edx, 9
  00718	75 24		 jne	 SHORT $LN32@CGDuelStar

; 21593: #endif
; 21594: 	{	//    
; 21595: 		GCServerMsgStringSend(lMsg.Get(1204), aIndex, 1);

  0071a	6a 01		 push	 1
  0071c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0071f	50		 push	 eax
  00720	68 b4 04 00 00	 push	 1204			; 000004b4H
  00725	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0072a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00730	50		 push	 eax
  00731	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00736	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21596: 		return;

  00739	e9 86 04 00 00	 jmp	 $LN39@CGDuelStar
$LN32@CGDuelStar:

; 21597: 	}
; 21598: 
; 21599: #ifdef FOR_BLOODCASTLE
; 21600: 	if (CHECK_BLOODCASTLE(gObj[aIndex].MapNumber)) {		

  0073e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00745	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0074b	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00753	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00756	7d 0c		 jge	 SHORT $LN62@CGDuelStar
  00758	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv367[ebp], 0
  00762	eb 3c		 jmp	 SHORT $LN63@CGDuelStar
$LN62@CGDuelStar:
  00764	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0076b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00771	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00779	83 fa 11	 cmp	 edx, 17			; 00000011H
  0077c	7e 0c		 jle	 SHORT $LN60@CGDuelStar
  0077e	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv366[ebp], 0
  00788	eb 0a		 jmp	 SHORT $LN61@CGDuelStar
$LN60@CGDuelStar:
  0078a	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv366[ebp], 1
$LN61@CGDuelStar:
  00794	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR tv366[ebp]
  0079a	89 85 78 fe ff
	ff		 mov	 DWORD PTR tv367[ebp], eax
$LN63@CGDuelStar:
  007a0	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR tv367[ebp], 0
  007a7	74 24		 je	 SHORT $LN33@CGDuelStar

; 21601: 		GCServerMsgStringSend(lMsg.Get(1190), aIndex, 1);		// "      ."

  007a9	6a 01		 push	 1
  007ab	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007ae	50		 push	 eax
  007af	68 a6 04 00 00	 push	 1190			; 000004a6H
  007b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  007b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  007bf	50		 push	 eax
  007c0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  007c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21602: 		return;

  007c8	e9 f7 03 00 00	 jmp	 $LN39@CGDuelStar
$LN33@CGDuelStar:

; 21603: 	}
; 21604: #endif
; 21605: 
; 21606: 	//         
; 21607: 	if( lpObj->m_IfState.use > 0 )

  007cd	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  007d3	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  007d9	80 e1 03	 and	 cl, 3
  007dc	0f b6 d1	 movzx	 edx, cl
  007df	85 d2		 test	 edx, edx
  007e1	7e 24		 jle	 SHORT $LN34@CGDuelStar

; 21608: 	{
; 21609: 		GCServerMsgStringSend(lMsg.Get(1191), aIndex, 1);		// "     ."

  007e3	6a 01		 push	 1
  007e5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007e8	50		 push	 eax
  007e9	68 a7 04 00 00	 push	 1191			; 000004a7H
  007ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  007f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  007f9	50		 push	 eax
  007fa	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  007ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21610: 		return;

  00802	e9 bd 03 00 00	 jmp	 $LN39@CGDuelStar
$LN34@CGDuelStar:

; 21611: 	}
; 21612: 
; 21613: 	//         
; 21614: 	if( gObj[iDuelIndex].m_IfState.use > 0 )

  00807	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0080e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00814	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0081b	80 e2 03	 and	 dl, 3
  0081e	0f b6 c2	 movzx	 eax, dl
  00821	85 c0		 test	 eax, eax
  00823	7e 4d		 jle	 SHORT $LN35@CGDuelStar

; 21615: 	{
; 21616: 		wsprintf(szTempText, lMsg.Get(1192), gObj[iDuelIndex].Name);		// "%s      ."

  00825	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0082c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00832	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00836	52		 push	 edx
  00837	68 a8 04 00 00	 push	 1192			; 000004a8H
  0083c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00841	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00847	50		 push	 eax
  00848	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  0084e	50		 push	 eax
  0084f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00855	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21617: 		GCServerMsgStringSend(szTempText, aIndex, 1);

  00858	6a 01		 push	 1
  0085a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0085d	50		 push	 eax
  0085e	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTempText$[ebp]
  00864	51		 push	 ecx
  00865	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0086a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21618: 		return;

  0086d	e9 52 03 00 00	 jmp	 $LN39@CGDuelStar
$LN35@CGDuelStar:

; 21619: 	}
; 21620: 
; 21621: 	//        
; 21622: 	if( CHECK_LIMIT(gObj[iDuelIndex].m_iDuelUserRequested, MAX_OBJECT)) {

  00872	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00879	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0087f	83 bc 01 e8 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3304], 0
  00887	7d 0c		 jge	 SHORT $LN66@CGDuelStar
  00889	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv414[ebp], 0
  00893	eb 3b		 jmp	 SHORT $LN67@CGDuelStar
$LN66@CGDuelStar:
  00895	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _iDuelIndex$[ebp], 7072
  0089c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008a1	81 bc 10 e8 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3304], 7399 ; 00001ce7H
  008ac	7e 0c		 jle	 SHORT $LN64@CGDuelStar
  008ae	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv413[ebp], 0
  008b8	eb 0a		 jmp	 SHORT $LN65@CGDuelStar
$LN64@CGDuelStar:
  008ba	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv413[ebp], 1
$LN65@CGDuelStar:
  008c4	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR tv413[ebp]
  008ca	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv414[ebp], ecx
$LN67@CGDuelStar:
  008d0	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR tv414[ebp], 0
  008d7	74 4d		 je	 SHORT $LN36@CGDuelStar

; 21623: 		wsprintf(szTempText, lMsg.Get(1193), gObj[iDuelIndex].Name);		// "%s       ."

  008d9	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  008e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008e6	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  008ea	52		 push	 edx
  008eb	68 a9 04 00 00	 push	 1193			; 000004a9H
  008f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  008f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  008fb	50		 push	 eax
  008fc	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  00902	50		 push	 eax
  00903	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00909	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21624: 		GCServerMsgStringSend(szTempText, aIndex, 1);

  0090c	6a 01		 push	 1
  0090e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00911	50		 push	 eax
  00912	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTempText$[ebp]
  00918	51		 push	 ecx
  00919	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0091e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21625: 		return;

  00921	e9 9e 02 00 00	 jmp	 $LN39@CGDuelStar
$LN36@CGDuelStar:

; 21626: 	}
; 21627: 
; 21628: 	//        
; 21629: 	if( CHECK_LIMIT(gObj[iDuelIndex].m_iDuelUserReserved, MAX_OBJECT)) {

  00926	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  0092d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00933	83 bc 01 e4 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3300], 0
  0093b	7d 0c		 jge	 SHORT $LN70@CGDuelStar
  0093d	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv437[ebp], 0
  00947	eb 3b		 jmp	 SHORT $LN71@CGDuelStar
$LN70@CGDuelStar:
  00949	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _iDuelIndex$[ebp], 7072
  00950	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00955	81 bc 10 e4 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3300], 7399 ; 00001ce7H
  00960	7e 0c		 jle	 SHORT $LN68@CGDuelStar
  00962	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv436[ebp], 0
  0096c	eb 0a		 jmp	 SHORT $LN69@CGDuelStar
$LN68@CGDuelStar:
  0096e	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv436[ebp], 1
$LN69@CGDuelStar:
  00978	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR tv436[ebp]
  0097e	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv437[ebp], ecx
$LN71@CGDuelStar:
  00984	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR tv437[ebp], 0
  0098b	74 4d		 je	 SHORT $LN37@CGDuelStar

; 21630: 		wsprintf(szTempText, lMsg.Get(1194), gObj[iDuelIndex].Name);		// "%s      ."

  0098d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00994	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0099a	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0099e	52		 push	 edx
  0099f	68 aa 04 00 00	 push	 1194			; 000004aaH
  009a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  009a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  009af	50		 push	 eax
  009b0	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  009b6	50		 push	 eax
  009b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  009bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21631: 		GCServerMsgStringSend(szTempText, aIndex, 1);

  009c0	6a 01		 push	 1
  009c2	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009c5	50		 push	 eax
  009c6	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTempText$[ebp]
  009cc	51		 push	 ecx
  009cd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  009d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21632: 		return;

  009d5	e9 ea 01 00 00	 jmp	 $LN39@CGDuelStar
$LN37@CGDuelStar:

; 21633: 	}
; 21634: 
; 21635: 	//        
; 21636: 	if( CHECK_LIMIT(gObj[iDuelIndex].m_iDuelUser, MAX_OBJECT)) {

  009da	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  009e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009e7	83 bc 01 ec 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3308], 0
  009ef	7d 0c		 jge	 SHORT $LN74@CGDuelStar
  009f1	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv460[ebp], 0
  009fb	eb 3b		 jmp	 SHORT $LN75@CGDuelStar
$LN74@CGDuelStar:
  009fd	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _iDuelIndex$[ebp], 7072
  00a04	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a09	81 bc 10 ec 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3308], 7399 ; 00001ce7H
  00a14	7e 0c		 jle	 SHORT $LN72@CGDuelStar
  00a16	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv459[ebp], 0
  00a20	eb 0a		 jmp	 SHORT $LN73@CGDuelStar
$LN72@CGDuelStar:
  00a22	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv459[ebp], 1
$LN73@CGDuelStar:
  00a2c	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR tv459[ebp]
  00a32	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv460[ebp], ecx
$LN75@CGDuelStar:
  00a38	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR tv460[ebp], 0
  00a3f	74 4d		 je	 SHORT $LN38@CGDuelStar

; 21637: 		wsprintf(szTempText, lMsg.Get(1195), gObj[iDuelIndex].Name);		// "%s      ."

  00a41	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00a48	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a4e	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00a52	52		 push	 edx
  00a53	68 ab 04 00 00	 push	 1195			; 000004abH
  00a58	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00a5d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00a63	50		 push	 eax
  00a64	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  00a6a	50		 push	 eax
  00a6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00a71	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21638: 		GCServerMsgStringSend(szTempText, aIndex, 1);

  00a74	6a 01		 push	 1
  00a76	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a79	50		 push	 eax
  00a7a	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTempText$[ebp]
  00a80	51		 push	 ecx
  00a81	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00a86	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21639: 		return;

  00a89	e9 36 01 00 00	 jmp	 $LN39@CGDuelStar
$LN38@CGDuelStar:

; 21640: 	}
; 21641: 
; 21642: 	//     .
; 21643: 	lpObj->m_iDuelUserReserved = iDuelIndex;

  00a8e	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a94	8b 4d f8	 mov	 ecx, DWORD PTR _iDuelIndex$[ebp]
  00a97	89 88 e4 0c 00
	00		 mov	 DWORD PTR [eax+3300], ecx

; 21644: 	lpObj->m_iDuelUser = -1;

  00a9d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aa3	c7 80 ec 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3308], -1

; 21645: 
; 21646: 	//    .
; 21647: 	gObj[iDuelIndex].m_iDuelUserRequested = aIndex;

  00aad	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00ab4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00aba	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00abd	89 94 01 e8 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3304], edx

; 21648: 
; 21649: 	//    .
; 21650: 	PMSG_REQ_DUEL_OK pMsg;
; 21651: 	pMsg.h.c = PMHC_BYTE;

  00ac4	c6 85 c4 fe ff
	ff c1		 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 21652: 	pMsg.h.headcode = 0xAC;

  00acb	c6 85 c6 fe ff
	ff ac		 mov	 BYTE PTR _pMsg$[ebp+2], 172 ; 000000acH

; 21653: 	pMsg.h.size = sizeof( pMsg );

  00ad2	c6 85 c5 fe ff
	ff 0f		 mov	 BYTE PTR _pMsg$[ebp+1], 15 ; 0000000fH

; 21654: 
; 21655: 	pMsg.NumberH = HIBYTE(aIndex);

  00ad9	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00adc	c1 e8 08	 shr	 eax, 8
  00adf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ae4	88 85 c7 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+3], al

; 21656: 	pMsg.NumberL = LOBYTE(aIndex);

  00aea	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00aed	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00af2	88 85 c8 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], al

; 21657: 	memcpy(pMsg.szName, gObj[aIndex].Name, MAX_IDSTRING);

  00af8	6a 0a		 push	 10			; 0000000aH
  00afa	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b01	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b07	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00b0b	52		 push	 edx
  00b0c	8d 85 c9 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+5]
  00b12	50		 push	 eax
  00b13	e8 00 00 00 00	 call	 _memcpy
  00b18	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21658: 	DataSend(iDuelIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00b1b	0f b6 85 c5 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00b22	50		 push	 eax
  00b23	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00b29	51		 push	 ecx
  00b2a	8b 55 f8	 mov	 edx, DWORD PTR _iDuelIndex$[ebp]
  00b2d	52		 push	 edx
  00b2e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00b33	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21659: 	
; 21660: 
; 21661: 	//      .
; 21662: 	wsprintf(szTempText, lMsg.Get(1196), gObj[iDuelIndex].Name);			// "%s  ."

  00b36	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00b3d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b43	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00b47	52		 push	 edx
  00b48	68 ac 04 00 00	 push	 1196			; 000004acH
  00b4d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00b52	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00b58	50		 push	 eax
  00b59	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  00b5f	50		 push	 eax
  00b60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00b66	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21663: 	GCServerMsgStringSend(szTempText, aIndex, 1);

  00b69	6a 01		 push	 1
  00b6b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b6e	50		 push	 eax
  00b6f	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTempText$[ebp]
  00b75	51		 push	 ecx
  00b76	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00b7b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21664: 
; 21665: 	LogAddTD("[Duel] [%s][%s] Requested to Start Duel to [%s][%s]",

  00b7e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00b85	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b8b	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00b8f	52		 push	 edx
  00b90	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  00b97	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b9d	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00ba1	52		 push	 edx
  00ba2	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ba8	83 c0 73	 add	 eax, 115		; 00000073H
  00bab	50		 push	 eax
  00bac	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bb2	83 c1 68	 add	 ecx, 104		; 00000068H
  00bb5	51		 push	 ecx
  00bb6	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5St@
  00bbb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00bc1	83 c4 14	 add	 esp, 20			; 00000014H
$LN39@CGDuelStar:

; 21666: 		lpObj->AccountID,
; 21667: 		lpObj->Name,
; 21668: 		gObj[iDuelIndex].AccountID,
; 21669: 		gObj[iDuelIndex].Name
; 21670: 		);
; 21671: }

  00bc4	5f		 pop	 edi
  00bc5	5e		 pop	 esi
  00bc6	5b		 pop	 ebx
  00bc7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bca	33 cd		 xor	 ecx, ebp
  00bcc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bd1	8b e5		 mov	 esp, ebp
  00bd3	5d		 pop	 ebp
  00bd4	c3		 ret	 0
?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z ENDP ; CGDuelStartRequestRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGRequestQuestInfo@@YAXH@Z
_TEXT	SEGMENT
_iSize$ = -84						; size = 4
_i$ = -80						; size = 4
_lpQuestInfo$ = -76					; size = 4
_pMsg$ = -72						; size = 54
_foundquest$ = -16					; size = 4
_questcount$ = -12					; size = 4
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?CGRequestQuestInfo@@YAXH@Z PROC			; CGRequestQuestInfo, COMDAT

; 19449: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 19450: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00016	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 19451: 
; 19452: 	if( lpObj->m_SendQuestInfo )

  00026	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00029	0f b6 88 c2 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3778]
  00030	85 c9		 test	 ecx, ecx
  00032	74 05		 je	 SHORT $LN5@CGRequestQ

; 19453: 	{	//    
; 19454: 		return;

  00034	e9 bd 00 00 00	 jmp	 $LN1@CGRequestQ
$LN5@CGRequestQ:

; 19455: 	}
; 19456: 
; 19457: 	int questcount = g_QuestInfo.GetQeustCount();

  00039	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0003e	e8 00 00 00 00	 call	 ?GetQeustCount@CQuestInfo@@QAEHXZ ; CQuestInfo::GetQeustCount
  00043	89 45 f4	 mov	 DWORD PTR _questcount$[ebp], eax

; 19458: 	int	foundquest = 0;

  00046	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _foundquest$[ebp], 0

; 19459: 
; 19460: 	PMSG_SEND_QEUSTINFO pMsg;
; 19461: 	memcpy(pMsg.State, lpObj->m_Quest, MAX_DBQUEST);

  0004d	6a 32		 push	 50			; 00000032H
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00052	05 90 0e 00 00	 add	 eax, 3728		; 00000e90H
  00057	50		 push	 eax
  00058	8d 4d bc	 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _memcpy
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19462: 	
; 19463: 	LPQUEST_INFO lpQuestInfo;
; 19464: 	int i;
; 19465: 	for( i = 0; i < MAX_QUEST; i++ )

  00064	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0006b	eb 09		 jmp	 SHORT $LN4@CGRequestQ
$LN2@CGRequestQ:
  0006d	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	89 45 b0	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CGRequestQ:
  00076	81 7d b0 c8 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 200	; 000000c8H
  0007d	7d 2c		 jge	 SHORT $LN3@CGRequestQ

; 19466: 	{
; 19467: 		lpQuestInfo = g_QuestInfo.GetQuestInfo(i);

  0007f	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  00082	50		 push	 eax
  00083	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00088	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo
  0008d	89 45 b4	 mov	 DWORD PTR _lpQuestInfo$[ebp], eax

; 19468: 		if( lpQuestInfo )	

  00090	83 7d b4 00	 cmp	 DWORD PTR _lpQuestInfo$[ebp], 0
  00094	74 13		 je	 SHORT $LN6@CGRequestQ

; 19469: 		{
; 19470: 			foundquest++;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _foundquest$[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 45 f0	 mov	 DWORD PTR _foundquest$[ebp], eax

; 19471: 			if( foundquest == questcount )		

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _foundquest$[ebp]
  000a2	3b 45 f4	 cmp	 eax, DWORD PTR _questcount$[ebp]
  000a5	75 02		 jne	 SHORT $LN6@CGRequestQ

; 19472: 				break;

  000a7	eb 02		 jmp	 SHORT $LN3@CGRequestQ
$LN6@CGRequestQ:

; 19473: 		}
; 19474: 	}

  000a9	eb c2		 jmp	 SHORT $LN2@CGRequestQ
$LN3@CGRequestQ:

; 19475: 
; 19476: 	int	iSize = 3+(i/4)+2;

  000ab	8b 45 b0	 mov	 eax, DWORD PTR _i$[ebp]
  000ae	99		 cdq
  000af	83 e2 03	 and	 edx, 3
  000b2	03 c2		 add	 eax, edx
  000b4	c1 f8 02	 sar	 eax, 2
  000b7	83 c0 05	 add	 eax, 5
  000ba	89 45 ac	 mov	 DWORD PTR _iSize$[ebp], eax

; 19477: 	PHeadSetB((LPBYTE)&pMsg, 0xA0, iSize);

  000bd	8b 45 ac	 mov	 eax, DWORD PTR _iSize$[ebp]
  000c0	50		 push	 eax
  000c1	68 a0 00 00 00	 push	 160			; 000000a0H
  000c6	8d 4d b8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19478: 	pMsg.Count = i;

  000d2	8a 45 b0	 mov	 al, BYTE PTR _i$[ebp]
  000d5	88 45 bb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 19479: 
; 19480: 	DataSend(aIndex, (LPBYTE)&pMsg, iSize);

  000d8	8b 45 ac	 mov	 eax, DWORD PTR _iSize$[ebp]
  000db	50		 push	 eax
  000dc	8d 4d b8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000df	51		 push	 ecx
  000e0	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19481: 
; 19482: 	lpObj->m_SendQuestInfo = TRUE;

  000ec	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ef	c6 80 c2 0e 00
	00 01		 mov	 BYTE PTR [eax+3778], 1
$LN1@CGRequestQ:

; 19483: 
; 19484: #ifdef AUTH_GAMESERVER_CHECKKEY
; 19485: 	if( szAuthKey[8] != AUTH_CHECK_08 )
; 19486: 		DestroyGIocp();
; 19487: #endif
; 19488: }

  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	33 cd		 xor	 ecx, ebp
  000fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
?CGRequestQuestInfo@@YAXH@Z ENDP			; CGRequestQuestInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCItemMoveResultSend@@YAXHEEQAE@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_pos$ = 16						; size = 1
_ItemInfo$ = 20						; size = 4
?GCItemMoveResultSend@@YAXHEEQAE@Z PROC			; GCItemMoveResultSend, COMDAT

; 6605 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 6606 : 	PMSG_INVENTORYITEMMOVE_RESULT	pMsg;
; 6607 : 
; 6608 : 	pMsg.h.c			= PMHCE_BYTE;

  00013	c6 45 f0 c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H

; 6609 : 	pMsg.h.headcode		= 0x24;

  00017	c6 45 f2 24	 mov	 BYTE PTR _pMsg$[ebp+2], 36 ; 00000024H

; 6610 : 	pMsg.h.size			= sizeof(pMsg);

  0001b	c6 45 f1 0a	 mov	 BYTE PTR _pMsg$[ebp+1], 10 ; 0000000aH

; 6611 : 	pMsg.result			= result;

  0001f	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00022	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 6612 : 	pMsg.Pos			= pos;

  00025	8a 45 10	 mov	 al, BYTE PTR _pos$[ebp]
  00028	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 6613 : 	pMsg.ItemInfo[0]    = ItemInfo[0];

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	6b c8 00	 imul	 ecx, eax, 0
  00033	ba 01 00 00 00	 mov	 edx, 1
  00038	6b c2 00	 imul	 eax, edx, 0
  0003b	8b 55 14	 mov	 edx, DWORD PTR _ItemInfo$[ebp]
  0003e	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00041	88 4c 05 f5	 mov	 BYTE PTR _pMsg$[ebp+eax+5], cl

; 6614 : 	pMsg.ItemInfo[1]    = ItemInfo[1];

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	c1 e0 00	 shl	 eax, 0
  0004d	b9 01 00 00 00	 mov	 ecx, 1
  00052	c1 e1 00	 shl	 ecx, 0
  00055	8b 55 14	 mov	 edx, DWORD PTR _ItemInfo$[ebp]
  00058	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0005b	88 44 0d f5	 mov	 BYTE PTR _pMsg$[ebp+ecx+5], al

; 6615 : 	pMsg.ItemInfo[2]    = ItemInfo[2];

  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	d1 e0		 shl	 eax, 1
  00066	b9 01 00 00 00	 mov	 ecx, 1
  0006b	d1 e1		 shl	 ecx, 1
  0006d	8b 55 14	 mov	 edx, DWORD PTR _ItemInfo$[ebp]
  00070	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00073	88 44 0d f5	 mov	 BYTE PTR _pMsg$[ebp+ecx+5], al

; 6616 : 	pMsg.ItemInfo[3]    = ItemInfo[3];

  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	6b c8 03	 imul	 ecx, eax, 3
  0007f	ba 01 00 00 00	 mov	 edx, 1
  00084	6b c2 03	 imul	 eax, edx, 3
  00087	8b 55 14	 mov	 edx, DWORD PTR _ItemInfo$[ebp]
  0008a	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  0008d	88 4c 05 f5	 mov	 BYTE PTR _pMsg$[ebp+eax+5], cl

; 6617 : 
; 6618 : #if ITEM_BUFFER_SIZE > 4
; 6619 : 	pMsg.ItemInfo[4]    = ItemInfo[4];	

  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	c1 e0 02	 shl	 eax, 2
  00099	b9 01 00 00 00	 mov	 ecx, 1
  0009e	c1 e1 02	 shl	 ecx, 2
  000a1	8b 55 14	 mov	 edx, DWORD PTR _ItemInfo$[ebp]
  000a4	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  000a7	88 44 0d f5	 mov	 BYTE PTR _pMsg$[ebp+ecx+5], al

; 6620 : #endif
; 6621 : 
; 6622 : #ifdef ITEM_INDEX_EXTEND_20050706
; 6623 : 	pMsg.ItemInfo[5]    = ItemInfo[5];
; 6624 : 	pMsg.ItemInfo[6]    = ItemInfo[6];
; 6625 : #endif
; 6626 : 
; 6627 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 6628 : 	pMsg.ItemInfo[7]	= ItemInfo[7];
; 6629 : 	pMsg.ItemInfo[8]	= ItemInfo[8];
; 6630 : 	pMsg.ItemInfo[9]	= ItemInfo[9];
; 6631 : 	pMsg.ItemInfo[10]	= ItemInfo[10];
; 6632 : 	pMsg.ItemInfo[11]	= ItemInfo[11];
; 6633 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 6634 : 	
; 6635 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000ab	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000af	50		 push	 eax
  000b0	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000b3	51		 push	 ecx
  000b4	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6636 : }

  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	33 cd		 xor	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
?GCItemMoveResultSend@@YAXHEEQAE@Z ENDP			; GCItemMoveResultSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z
_TEXT	SEGMENT
_oldmoney$1 = -320					; size = 4
_oldmoney$2 = -316					; size = 4
_rZen$3 = -312						; size = 4
_durTsend$4 = -308					; size = 4
_durSsend$5 = -304					; size = 4
_p$6 = -300						; size = 4
_type$7 = -296						; size = 4
_msg$8 = -292						; size = 255
_rZen$9 = -36						; size = 4
_target$ = -32						; size = 4
_source$ = -28						; size = 4
_it_type$ = -24						; size = 4
_lpObj$ = -20						; size = 4
_ItemInfo$ = -16					; size = 5
_result$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z PROC ; CGInventoryItemMove, COMDAT

; 6644 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 01 00
	00		 sub	 esp, 384		; 00000180H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 6645 : 	BYTE result;
; 6646 : 	
; 6647 : 
; 6648 : 	BYTE ItemInfo[ITEM_BUFFER_SIZE];
; 6649 : 	
; 6650 : 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) 

  00016	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00029	83 c4 04	 add	 esp, 4
  0002c	85 c0		 test	 eax, eax
  0002e	75 1c		 jne	 SHORT $LN2@CGInventor

; 6651 : 	{	//GCResultSend(aIndex, 0x24, 0xFF);
; 6652 : 		GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  00030	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00033	50		 push	 eax
  00034	6a 00		 push	 0
  00036	68 ff 00 00 00	 push	 255			; 000000ffH
  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00044	83 c4 10	 add	 esp, 16			; 00000010H

; 6653 : 		return;

  00047	e9 8b 0c 00 00	 jmp	 $LN1@CGInventor
$LN2@CGInventor:

; 6654 : 	}
; 6655 : 	if( gObjIsConnectedGP(aIndex) == FALSE ) 

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00055	83 c4 04	 add	 esp, 4
  00058	85 c0		 test	 eax, eax
  0005a	75 3a		 jne	 SHORT $LN3@CGInventor

; 6656 : 	{
; 6657 : 		LogAddC(LOGC_RED, "[%s][%d] error-L3", __FILE__,__LINE__);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z@4JA
  00061	83 c0 0d	 add	 eax, 13			; 0000000dH
  00064	50		 push	 eax
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3@
  0006f	6a 02		 push	 2
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00077	83 c4 10	 add	 esp, 16			; 00000010H

; 6658 : 		GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  0007a	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  0007d	50		 push	 eax
  0007e	6a 00		 push	 0
  00080	68 ff 00 00 00	 push	 255			; 000000ffH
  00085	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 6659 : 		return;

  00091	e9 41 0c 00 00	 jmp	 $LN1@CGInventor
$LN3@CGInventor:

; 6660 : 	}
; 6661 : 	
; 6662 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00096	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a3	89 45 ec	 mov	 DWORD PTR _lpObj$[ebp], eax

; 6663 : 	int it_type = 0;

  000a6	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _it_type$[ebp], 0

; 6664 : 
; 6665 : 
; 6666 : #ifdef WAREHOUSE_ITEMCOPY_BUG_FIX
; 6667 : 	if( lpObj->m_ReqWarehouseOpen )

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b0	0f b6 88 24 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3876]
  000b7	85 c9		 test	 ecx, ecx
  000b9	74 3a		 je	 SHORT $LN4@CGInventor

; 6668 : 	{	//       
; 6669 : 		LogAddC(LOGC_RED, "[%s][%d] error-L3", __FILE__,__LINE__);

  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z@4JA
  000c0	83 c0 19	 add	 eax, 25			; 00000019H
  000c3	50		 push	 eax
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3@
  000ce	6a 02		 push	 2
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000d6	83 c4 10	 add	 esp, 16			; 00000010H

; 6670 : 		GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  000d9	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  000dc	50		 push	 eax
  000dd	6a 00		 push	 0
  000df	68 ff 00 00 00	 push	 255			; 000000ffH
  000e4	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000e7	51		 push	 ecx
  000e8	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  000ed	83 c4 10	 add	 esp, 16			; 00000010H

; 6671 : 		return;

  000f0	e9 e2 0b 00 00	 jmp	 $LN1@CGInventor
$LN4@CGInventor:

; 6672 : 	}
; 6673 : #endif
; 6674 : 
; 6675 : 	int source = lpMsg->source_item_num;

  000f5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000f8	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000fc	89 4d e4	 mov	 DWORD PTR _source$[ebp], ecx

; 6676 : 	int target = lpMsg->target_item_num;

  000ff	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00102	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  00106	89 4d e0	 mov	 DWORD PTR _target$[ebp], ecx

; 6677 : 
; 6678 : 	if( lpMsg->tFlag == ITEMMOVE_WAREHOUSE || lpMsg->sFlag == ITEMMOVE_WAREHOUSE )		//  

  00109	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0010c	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00110	83 f9 02	 cmp	 ecx, 2
  00113	74 0c		 je	 SHORT $LN6@CGInventor
  00115	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00118	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0011c	83 f9 02	 cmp	 ecx, 2
  0011f	75 07		 jne	 SHORT $LN5@CGInventor
$LN6@CGInventor:

; 6679 : 		it_type = I_WAREHOUSE;

  00121	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR _it_type$[ebp], 6
$LN5@CGInventor:

; 6680 : 	if( lpMsg->tFlag == ITEMMOVE_INVENTORY && lpMsg->sFlag == ITEMMOVE_INVENTORY )		//  

  00128	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0012b	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  0012f	85 c9		 test	 ecx, ecx
  00131	75 12		 jne	 SHORT $LN7@CGInventor
  00133	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00136	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0013a	85 c9		 test	 ecx, ecx
  0013c	75 07		 jne	 SHORT $LN7@CGInventor

; 6681 : 		it_type = I_INVENTORY;

  0013e	c7 45 e8 08 00
	00 00		 mov	 DWORD PTR _it_type$[ebp], 8
$LN7@CGInventor:

; 6682 : #ifdef PERSONAL_SHOP_20040113
; 6683 : 	if((lpMsg->tFlag == ITEMMOVE_INVENTORY && lpMsg->sFlag == ITEMMOVE_PSHOPWND ) ||	//    .
; 6684 : 		(lpMsg->tFlag == ITEMMOVE_PSHOPWND && lpMsg->sFlag == ITEMMOVE_INVENTORY ) ||

  00145	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00148	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  0014c	85 c9		 test	 ecx, ecx
  0014e	75 0c		 jne	 SHORT $LN10@CGInventor
  00150	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00153	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00157	83 f9 04	 cmp	 ecx, 4
  0015a	74 2f		 je	 SHORT $LN9@CGInventor
$LN10@CGInventor:
  0015c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0015f	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00163	83 f9 04	 cmp	 ecx, 4
  00166	75 0b		 jne	 SHORT $LN11@CGInventor
  00168	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0016b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0016f	85 c9		 test	 ecx, ecx
  00171	74 18		 je	 SHORT $LN9@CGInventor
$LN11@CGInventor:
  00173	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00176	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  0017a	83 f9 04	 cmp	 ecx, 4
  0017d	75 13		 jne	 SHORT $LN8@CGInventor
  0017f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00182	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00186	83 f9 04	 cmp	 ecx, 4
  00189	75 07		 jne	 SHORT $LN8@CGInventor
$LN9@CGInventor:

; 6685 : 		(lpMsg->tFlag == ITEMMOVE_PSHOPWND && lpMsg->sFlag == ITEMMOVE_PSHOPWND ))
; 6686 : 		it_type = I_INVENTORY;		//       

  0018b	c7 45 e8 08 00
	00 00		 mov	 DWORD PTR _it_type$[ebp], 8
$LN8@CGInventor:

; 6687 : #endif
; 6688 : 	
; 6689 : #ifdef MODIFY_INVENTORY_ITEM_MOVE_BUGFIX_20071113
; 6690 : 	if( lpMsg->tFlag == lpMsg->sFlag
; 6691 : 		&& source == target )

  00192	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00195	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00199	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0019c	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  001a0	3b c8		 cmp	 ecx, eax
  001a2	75 24		 jne	 SHORT $LN12@CGInventor
  001a4	8b 45 e4	 mov	 eax, DWORD PTR _source$[ebp]
  001a7	3b 45 e0	 cmp	 eax, DWORD PTR _target$[ebp]
  001aa	75 1c		 jne	 SHORT $LN12@CGInventor

; 6692 : 	{
; 6693 : 		GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  001ac	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  001af	50		 push	 eax
  001b0	6a 00		 push	 0
  001b2	68 ff 00 00 00	 push	 255			; 000000ffH
  001b7	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  001c0	83 c4 10	 add	 esp, 16			; 00000010H

; 6694 : 		return;

  001c3	e9 0f 0b 00 00	 jmp	 $LN1@CGInventor
$LN12@CGInventor:

; 6695 : 	}
; 6696 : #endif		
; 6697 : 	
; 6698 : 	if( gObjCanItemTouch(lpObj, it_type) == FALSE )	//    

  001c8	8b 45 e8	 mov	 eax, DWORD PTR _it_type$[ebp]
  001cb	50		 push	 eax
  001cc	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001cf	51		 push	 ecx
  001d0	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  001d5	83 c4 08	 add	 esp, 8
  001d8	85 c0		 test	 eax, eax
  001da	0f 85 86 00 00
	00		 jne	 $LN15@CGInventor

; 6699 : 	{
; 6700 : 		//     
; 6701 : 		if( lpMsg->sItemInfo[0] == MAKE_ITEMNUM(4, 7) || lpMsg->sItemInfo[0] == MAKE_ITEMNUM(4, 15) )

  001e0	b8 01 00 00 00	 mov	 eax, 1
  001e5	6b c8 00	 imul	 ecx, eax, 0
  001e8	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  001eb	0f b6 74 0a 05	 movzx	 esi, BYTE PTR [edx+ecx+5]
  001f0	6a 07		 push	 7
  001f2	6a 04		 push	 4
  001f4	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f9	83 c4 08	 add	 esp, 8
  001fc	3b f0		 cmp	 esi, eax
  001fe	74 20		 je	 SHORT $LN16@CGInventor
  00200	b8 01 00 00 00	 mov	 eax, 1
  00205	6b c8 00	 imul	 ecx, eax, 0
  00208	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0020b	0f b6 74 0a 05	 movzx	 esi, BYTE PTR [edx+ecx+5]
  00210	6a 0f		 push	 15			; 0000000fH
  00212	6a 04		 push	 4
  00214	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00219	83 c4 08	 add	 esp, 8
  0021c	3b f0		 cmp	 esi, eax
  0021e	75 2a		 jne	 SHORT $LN14@CGInventor
$LN16@CGInventor:

; 6702 : 		{
; 6703 : 			if( (target >= MAX_EQUIPMENT || source < MAX_EQUIPMENT) )

  00220	83 7d e0 0c	 cmp	 DWORD PTR _target$[ebp], 12 ; 0000000cH
  00224	7d 06		 jge	 SHORT $LN18@CGInventor
  00226	83 7d e4 0c	 cmp	 DWORD PTR _source$[ebp], 12 ; 0000000cH
  0022a	7d 1c		 jge	 SHORT $LN17@CGInventor
$LN18@CGInventor:

; 6704 : 			{			
; 6705 : 				GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  0022c	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  0022f	50		 push	 eax
  00230	6a 00		 push	 0
  00232	68 ff 00 00 00	 push	 255			; 000000ffH
  00237	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0023a	51		 push	 ecx
  0023b	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00240	83 c4 10	 add	 esp, 16			; 00000010H

; 6706 : 				return;

  00243	e9 8f 0a 00 00	 jmp	 $LN1@CGInventor
$LN17@CGInventor:

; 6707 : 			}
; 6708 : 		}	

  00248	eb 1c		 jmp	 SHORT $LN15@CGInventor
$LN14@CGInventor:

; 6709 : 		else
; 6710 : 		{
; 6711 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  0024a	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  0024d	50		 push	 eax
  0024e	6a 00		 push	 0
  00250	68 ff 00 00 00	 push	 255			; 000000ffH
  00255	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00258	51		 push	 ecx
  00259	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0025e	83 c4 10	 add	 esp, 16			; 00000010H

; 6712 : 			return;

  00261	e9 71 0a 00 00	 jmp	 $LN1@CGInventor
$LN15@CGInventor:

; 6713 : 		}
; 6714 : 	}
; 6715 : 
; 6716 : #ifdef CHINA_BUG_RETOUCH	
; 6717 : #ifdef ITEM_INDEX_EXTEND_20050706
; 6718 : 	int itemtype	= lpMsg->sItemInfo[0]+((lpMsg->sItemInfo[3]&0x80)<<1)+((lpMsg->sItemInfo[5]&0xF0)<<5);
; 6719 : #else
; 6720 : 	int itemtype	= lpMsg->sItemInfo[0]+(((lpMsg->sItemInfo[3]&0x80)>>7)*256);
; 6721 : #endif
; 6722 : 	if( itemtype == MAKE_ITEMNUM(13, 20) )
; 6723 : 	{	//    &&    ...
; 6724 : 		if( lpMsg->sFlag != ITEMMOVE_INVENTORY || lpMsg->tFlag != ITEMMOVE_INVENTORY )
; 6725 : 		{	//      
; 6726 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);
; 6727 : 			return;
; 6728 : 		}
; 6729 : 	}
; 6730 : #endif // CHINA_BUG_RETOUCH
; 6731 : 
; 6732 : 
; 6733 : #if TESTSERVER == 1 
; 6734 : 	#ifdef DARKLORD_WORK
; 6735 : 		{
; 6736 : #ifdef ITEM_INDEX_EXTEND_20050706
; 6737 : 			int itemtype	= lpMsg->sItemInfo[0]+((lpMsg->sItemInfo[3]&0x80)<<1)+((lpMsg->sItemInfo[5]&0xF0)<<5);
; 6738 : #else
; 6739 : 			int itemtype	= lpMsg->sItemInfo[0]+(((lpMsg->sItemInfo[3]&0x80)>>7)*256);
; 6740 : #endif
; 6741 : 			if( itemtype == MAKE_ITEMNUM(13, 4) || itemtype == MAKE_ITEMNUM(13, 5) )
; 6742 : 			{
; 6743 : 				if( lpMsg->sFlag == ITEMMOVE_INVENTORY )
; 6744 : 				{
; 6745 : 					DebugOutput(aIndex, "[%s] Lv:%d Exp:%d", 
; 6746 : 							lpObj->pInventory[source].GetName(),				
; 6747 : 							lpObj->pInventory[source].m_PetItem_Level, 
; 6748 : 							lpObj->pInventory[source].m_PetItem_Exp);
; 6749 : 				}
; 6750 : 				else if( lpMsg->sFlag == ITEMMOVE_WAREHOUSE )
; 6751 : 				{
; 6752 : 					DebugOutput(aIndex, "[%s] Lv:%d Exp:%d", 
; 6753 : 								lpObj->pWarehouse[source].GetName(),				
; 6754 : 								lpObj->pWarehouse[source].m_PetItem_Level, 
; 6755 : 								lpObj->pWarehouse[source].m_PetItem_Exp);
; 6756 : 				}
; 6757 : 			}
; 6758 : 		}
; 6759 : 	#endif
; 6760 : #endif
; 6761 : 
; 6762 : 	if( lpObj->DieRegen ) 

  00266	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00269	0f be 88 fe 01
	00 00		 movsx	 ecx, BYTE PTR [eax+510]
  00270	85 c9		 test	 ecx, ecx
  00272	74 1c		 je	 SHORT $LN19@CGInventor

; 6763 : 	{
; 6764 : 		//      .
; 6765 : 		GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  00274	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00277	50		 push	 eax
  00278	6a 00		 push	 0
  0027a	68 ff 00 00 00	 push	 255			; 000000ffH
  0027f	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00282	51		 push	 ecx
  00283	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00288	83 c4 10	 add	 esp, 16			; 00000010H

; 6766 : 		return;

  0028b	e9 47 0a 00 00	 jmp	 $LN1@CGInventor
$LN19@CGInventor:

; 6767 : 	}
; 6768 : 	
; 6769 : 	ItemInfo[0] = lpMsg->sItemInfo[0];

  00290	b8 01 00 00 00	 mov	 eax, 1
  00295	6b c8 00	 imul	 ecx, eax, 0
  00298	ba 01 00 00 00	 mov	 edx, 1
  0029d	6b c2 00	 imul	 eax, edx, 0
  002a0	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  002a3	8a 4c 0a 05	 mov	 cl, BYTE PTR [edx+ecx+5]
  002a7	88 4c 05 f0	 mov	 BYTE PTR _ItemInfo$[ebp+eax], cl

; 6770 : 	ItemInfo[1] = lpMsg->sItemInfo[1];

  002ab	b8 01 00 00 00	 mov	 eax, 1
  002b0	c1 e0 00	 shl	 eax, 0
  002b3	b9 01 00 00 00	 mov	 ecx, 1
  002b8	c1 e1 00	 shl	 ecx, 0
  002bb	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  002be	8a 44 02 05	 mov	 al, BYTE PTR [edx+eax+5]
  002c2	88 44 0d f0	 mov	 BYTE PTR _ItemInfo$[ebp+ecx], al

; 6771 : 	ItemInfo[2] = lpMsg->sItemInfo[2];

  002c6	b8 01 00 00 00	 mov	 eax, 1
  002cb	d1 e0		 shl	 eax, 1
  002cd	b9 01 00 00 00	 mov	 ecx, 1
  002d2	d1 e1		 shl	 ecx, 1
  002d4	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  002d7	8a 44 02 05	 mov	 al, BYTE PTR [edx+eax+5]
  002db	88 44 0d f0	 mov	 BYTE PTR _ItemInfo$[ebp+ecx], al

; 6772 : 	ItemInfo[3] = lpMsg->sItemInfo[3];

  002df	b8 01 00 00 00	 mov	 eax, 1
  002e4	6b c8 03	 imul	 ecx, eax, 3
  002e7	ba 01 00 00 00	 mov	 edx, 1
  002ec	6b c2 03	 imul	 eax, edx, 3
  002ef	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  002f2	8a 4c 0a 05	 mov	 cl, BYTE PTR [edx+ecx+5]
  002f6	88 4c 05 f0	 mov	 BYTE PTR _ItemInfo$[ebp+eax], cl

; 6773 : 
; 6774 : #if ITEM_BUFFER_SIZE > 4
; 6775 : 	ItemInfo[4] = lpMsg->sItemInfo[4];

  002fa	b8 01 00 00 00	 mov	 eax, 1
  002ff	c1 e0 02	 shl	 eax, 2
  00302	b9 01 00 00 00	 mov	 ecx, 1
  00307	c1 e1 02	 shl	 ecx, 2
  0030a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0030d	8a 44 02 05	 mov	 al, BYTE PTR [edx+eax+5]
  00311	88 44 0d f0	 mov	 BYTE PTR _ItemInfo$[ebp+ecx], al

; 6776 : #endif
; 6777 : 
; 6778 : #ifdef ITEM_INDEX_EXTEND_20050706
; 6779 : 	ItemInfo[5] = lpMsg->sItemInfo[5];
; 6780 : 	ItemInfo[6] = lpMsg->sItemInfo[6];
; 6781 : #endif
; 6782 : 
; 6783 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 6784 : 	ItemInfo[7]		= lpMsg->sItemInfo[7];
; 6785 : 	ItemInfo[8]		= lpMsg->sItemInfo[8];
; 6786 : 	ItemInfo[9]		= lpMsg->sItemInfo[9];
; 6787 : 	ItemInfo[10]	= lpMsg->sItemInfo[10];
; 6788 : 	ItemInfo[11]	= lpMsg->sItemInfo[11];
; 6789 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 6790 : 
; 6791 : 	if( lpMsg->sFlag == ITEMMOVE_CHAOSBOX || lpMsg->tFlag == ITEMMOVE_CHAOSBOX )		//      ..

  00315	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00318	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0031c	83 f9 03	 cmp	 ecx, 3
  0031f	74 10		 je	 SHORT $LN21@CGInventor
  00321	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00324	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00328	83 f9 03	 cmp	 ecx, 3
  0032b	0f 85 d3 00 00
	00		 jne	 $LN24@CGInventor
$LN21@CGInventor:

; 6792 : 	{
; 6793 : 		if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_CHAOSBOX ) 

  00331	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00334	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0033a	80 e1 03	 and	 cl, 3
  0033d	0f b6 d1	 movzx	 edx, cl
  00340	83 fa 01	 cmp	 edx, 1
  00343	7c 17		 jl	 SHORT $LN23@CGInventor
  00345	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00348	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0034e	c0 e9 04	 shr	 cl, 4
  00351	80 e1 0f	 and	 cl, 15			; 0000000fH
  00354	0f b6 d1	 movzx	 edx, cl
  00357	83 fa 07	 cmp	 edx, 7
  0035a	74 4e		 je	 SHORT $LN22@CGInventor
$LN23@CGInventor:

; 6794 : 		{
; 6795 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  0035c	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  0035f	50		 push	 eax
  00360	6a 00		 push	 0
  00362	68 ff 00 00 00	 push	 255			; 000000ffH
  00367	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0036a	51		 push	 ecx
  0036b	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00370	83 c4 10	 add	 esp, 16			; 00000010H

; 6796 : 			LogAdd("[%s][%s] error-L1 : used not Chaosbox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00373	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0037a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00380	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00384	52		 push	 edx
  00385	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0038c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00392	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00396	52		 push	 edx
  00397	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Ch@
  0039c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6797 : 			return;

  003a5	e9 2d 09 00 00	 jmp	 $LN1@CGInventor
$LN22@CGInventor:

; 6798 : 		}
; 6799 : 		if( lpObj->ChaosLock == TRUE )	//    ..

  003aa	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ad	83 b8 bc 0c 00
	00 01		 cmp	 DWORD PTR [eax+3260], 1
  003b4	75 4e		 jne	 SHORT $LN24@CGInventor

; 6800 : 		{
; 6801 : 			LogAddTD("[%s][%s] error-L3 : CBMixing", gObj[aIndex].AccountID, gObj[aIndex].Name);

  003b6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003c3	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  003c7	52		 push	 edx
  003c8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d5	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  003d9	52		 push	 edx
  003da	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing@
  003df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6802 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  003e8	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  003eb	50		 push	 eax
  003ec	6a 00		 push	 0
  003ee	68 ff 00 00 00	 push	 255			; 000000ffH
  003f3	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  003f6	51		 push	 ecx
  003f7	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  003fc	83 c4 10	 add	 esp, 16			; 00000010H

; 6803 : 			return;

  003ff	e9 d3 08 00 00	 jmp	 $LN1@CGInventor
$LN24@CGInventor:

; 6804 : 		}
; 6805 : 	}
; 6806 : 
; 6807 : #ifdef DARKLORD_WORK		//       
; 6808 : 	if( lpMsg->sFlag == ITEMMOVE_DARK_TRAINER || lpMsg->tFlag == ITEMMOVE_DARK_TRAINER )		//      ..

  00404	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00407	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0040b	83 f9 05	 cmp	 ecx, 5
  0040e	74 10		 je	 SHORT $LN26@CGInventor
  00410	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00413	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00417	83 f9 05	 cmp	 ecx, 5
  0041a	0f 85 d3 00 00
	00		 jne	 $LN29@CGInventor
$LN26@CGInventor:

; 6809 : 	{
; 6810 : 		if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_DARK_TRAINER ) 

  00420	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00423	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00429	80 e1 03	 and	 cl, 3
  0042c	0f b6 d1	 movzx	 edx, cl
  0042f	83 fa 01	 cmp	 edx, 1
  00432	7c 17		 jl	 SHORT $LN28@CGInventor
  00434	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00437	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0043d	c0 e9 04	 shr	 cl, 4
  00440	80 e1 0f	 and	 cl, 15			; 0000000fH
  00443	0f b6 d1	 movzx	 edx, cl
  00446	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  00449	74 4e		 je	 SHORT $LN27@CGInventor
$LN28@CGInventor:

; 6811 : 		{
; 6812 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  0044b	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  0044e	50		 push	 eax
  0044f	6a 00		 push	 0
  00451	68 ff 00 00 00	 push	 255			; 000000ffH
  00456	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00459	51		 push	 ecx
  0045a	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0045f	83 c4 10	 add	 esp, 16			; 00000010H

; 6813 : 			LogAdd("[%s][%s] error-L1 : used not DarkTrainerBox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00462	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00469	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0046f	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00473	52		 push	 edx
  00474	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0047b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00481	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00485	52		 push	 edx
  00486	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Da@
  0048b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00491	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6814 : 			return;

  00494	e9 3e 08 00 00	 jmp	 $LN1@CGInventor
$LN27@CGInventor:

; 6815 : 		}
; 6816 : 		if( lpObj->ChaosLock == TRUE )	//    ..

  00499	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0049c	83 b8 bc 0c 00
	00 01		 cmp	 DWORD PTR [eax+3260], 1
  004a3	75 4e		 jne	 SHORT $LN29@CGInventor

; 6817 : 		{
; 6818 : 			LogAddTD("[%s][%s] error-L3 : DarkTrainerBoxMixing", gObj[aIndex].AccountID, gObj[aIndex].Name);

  004a5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004b2	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  004b6	52		 push	 edx
  004b7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004c4	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  004c8	52		 push	 edx
  004c9	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainer@
  004ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6819 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  004d7	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  004da	50		 push	 eax
  004db	6a 00		 push	 0
  004dd	68 ff 00 00 00	 push	 255			; 000000ffH
  004e2	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  004e5	51		 push	 ecx
  004e6	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  004eb	83 c4 10	 add	 esp, 16			; 00000010H

; 6820 : 			return;

  004ee	e9 e4 07 00 00	 jmp	 $LN1@CGInventor
$LN29@CGInventor:

; 6821 : 		}
; 6822 : 	}
; 6823 : #endif
; 6824 : 
; 6825 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530	
; 6826 : 	//   /   /  
; 6827 : 	if( lpMsg->sFlag == ITEMMOVE_JEWELOFHARMONY_PURITY	|| 
; 6828 : 		lpMsg->sFlag == ITEMMOVE_JEWELOFHARMONY_SMELT	|| 
; 6829 : 		lpMsg->sFlag == ITEMMOVE_JEWELOFHARMONY_RESTORE || 
; 6830 : 		lpMsg->tFlag == ITEMMOVE_JEWELOFHARMONY_PURITY ||
; 6831 : 		lpMsg->tFlag == ITEMMOVE_JEWELOFHARMONY_SMELT ||
; 6832 : 		lpMsg->tFlag == ITEMMOVE_JEWELOFHARMONY_RESTORE 
; 6833 : 		)
; 6834 : 	{
; 6835 : 		if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_CHAOSBOX ) 
; 6836 : 		{
; 6837 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);
; 6838 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 6839 : 			return;
; 6840 : 		}
; 6841 : 		if( lpObj->ChaosLock == TRUE )	//    ..
; 6842 : 		{
; 6843 : 			LogAddTD("[%s][%s] error-L3 : JewelOfHarmony Mixing", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 6844 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);
; 6845 : 			return;
; 6846 : 		}
; 6847 : 	}
; 6848 : #endif	// ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 6849 : 
; 6850 : #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 6851 : 	if( lpMsg->sFlag == ITEMMOVE_LOTTERY_MIX || lpMsg->tFlag == ITEMMOVE_LOTTERY_MIX )
; 6852 : 	{
; 6853 : 		if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_CHAOSBOX ) 
; 6854 : 		{
; 6855 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);
; 6856 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 6857 : 			return;
; 6858 : 		}
; 6859 : 		if( lpObj->ChaosLock == TRUE )	//    ..
; 6860 : 		{
; 6861 : 			LogAddTD("[%s][%s] error-L3 : JewelOfHarmony Mixing", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 6862 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);
; 6863 : 			return;
; 6864 : 		}
; 6865 : 	}
; 6866 : #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 6867 : 	
; 6868 : #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 6869 : 	if( lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_EXTRACT
; 6870 : 		|| lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_COMPOSIT
; 6871 : 		|| lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_EQUIP
; 6872 : 		|| lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_REMOVE
; 6873 : 		|| lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_EXTRACT
; 6874 : 		|| lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_COMPOSIT
; 6875 : 		|| lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_EQUIP
; 6876 : 		|| lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_REMOVE
; 6877 : 	  )
; 6878 : 	{
; 6879 : 		if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_CHAOSBOX ) 
; 6880 : 		{
; 6881 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);
; 6882 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 6883 : 			return;
; 6884 : 		}
; 6885 : 		if( lpObj->ChaosLock == TRUE )	//    ..
; 6886 : 		{
; 6887 : 			LogAddTD("[%s][%s] error-L3 : SocketItem Mixing", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 6888 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);
; 6889 : 			return;
; 6890 : 		}
; 6891 : 	}
; 6892 : #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 6893 : 	
; 6894 : 	if( lpMsg->sFlag == ITEMMOVE_WAREHOUSE || lpMsg->tFlag == ITEMMOVE_WAREHOUSE )		//      ..

  004f3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004f6	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  004fa	83 f9 02	 cmp	 ecx, 2
  004fd	74 0c		 je	 SHORT $LN31@CGInventor
  004ff	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00502	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00506	83 f9 02	 cmp	 ecx, 2
  00509	75 79		 jne	 SHORT $LN32@CGInventor
$LN31@CGInventor:

; 6895 : 	{
; 6896 : 		if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_WAREHOUSE ) 

  0050b	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0050e	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00514	80 e1 03	 and	 cl, 3
  00517	0f b6 d1	 movzx	 edx, cl
  0051a	83 fa 01	 cmp	 edx, 1
  0051d	7c 17		 jl	 SHORT $LN33@CGInventor
  0051f	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00522	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00528	c0 e9 04	 shr	 cl, 4
  0052b	80 e1 0f	 and	 cl, 15			; 0000000fH
  0052e	0f b6 d1	 movzx	 edx, cl
  00531	83 fa 06	 cmp	 edx, 6
  00534	74 4e		 je	 SHORT $LN32@CGInventor
$LN33@CGInventor:

; 6897 : 		{
; 6898 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  00536	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00539	50		 push	 eax
  0053a	6a 00		 push	 0
  0053c	68 ff 00 00 00	 push	 255			; 000000ffH
  00541	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00544	51		 push	 ecx
  00545	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0054a	83 c4 10	 add	 esp, 16			; 00000010H

; 6899 : 			LogAdd("[%s][%s] error-L1 : used not Warehouse", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0054d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00554	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0055a	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0055e	52		 push	 edx
  0055f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00566	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0056c	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00570	52		 push	 edx
  00571	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Wa@
  00576	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0057c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6900 : 			return;

  0057f	e9 53 07 00 00	 jmp	 $LN1@CGInventor
$LN32@CGInventor:

; 6901 : 		}
; 6902 : 	}
; 6903 : 	// 2002/09/09  
; 6904 : 	//      ..
; 6905 : 	if( lpMsg->sFlag == ITEMMOVE_TRADEWND && lpMsg->tFlag == ITEMMOVE_INVENTORY )

  00584	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00587	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0058b	83 f9 01	 cmp	 ecx, 1
  0058e	0f 85 84 00 00
	00		 jne	 $LN35@CGInventor
  00594	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00597	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  0059b	85 c9		 test	 ecx, ecx
  0059d	75 79		 jne	 SHORT $LN35@CGInventor

; 6906 : 	{
; 6907 : 		if( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != I_TRADE ) 

  0059f	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005a2	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  005a8	80 e1 03	 and	 cl, 3
  005ab	0f b6 d1	 movzx	 edx, cl
  005ae	83 fa 01	 cmp	 edx, 1
  005b1	7c 17		 jl	 SHORT $LN36@CGInventor
  005b3	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b6	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  005bc	c0 e9 04	 shr	 cl, 4
  005bf	80 e1 0f	 and	 cl, 15			; 0000000fH
  005c2	0f b6 d1	 movzx	 edx, cl
  005c5	83 fa 01	 cmp	 edx, 1
  005c8	74 4e		 je	 SHORT $LN35@CGInventor
$LN36@CGInventor:

; 6908 : 		{
; 6909 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  005ca	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  005cd	50		 push	 eax
  005ce	6a 00		 push	 0
  005d0	68 ff 00 00 00	 push	 255			; 000000ffH
  005d5	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  005d8	51		 push	 ecx
  005d9	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  005de	83 c4 10	 add	 esp, 16			; 00000010H

; 6910 : 			LogAdd("[%s][%s] error-L1 : used not Trade", gObj[aIndex].AccountID, gObj[aIndex].Name);

  005e1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ee	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  005f2	52		 push	 edx
  005f3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00600	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00604	52		 push	 edx
  00605	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tr@
  0060a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00610	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6911 : 			return;

  00613	e9 bf 06 00 00	 jmp	 $LN1@CGInventor
$LN35@CGInventor:

; 6912 : 		}
; 6913 : 	}
; 6914 : 
; 6915 : 	//    
; 6916 : 	if( (lpMsg->sFlag == ITEMMOVE_WAREHOUSE && lpMsg->tFlag == ITEMMOVE_INVENTORY) )	

  00618	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0061b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0061f	83 f9 02	 cmp	 ecx, 2
  00622	0f 85 04 01 00
	00		 jne	 $LN40@CGInventor
  00628	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0062b	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  0062f	85 c9		 test	 ecx, ecx
  00631	0f 85 f5 00 00
	00		 jne	 $LN40@CGInventor

; 6917 : 	{	
; 6918 : 		//      
; 6919 : 
; 6920 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//  -   
; 6921 : 		int  rZen = GetWarehouseUsedHowMuch( lpObj->Level, lpObj->m_nMasterLevel, lpObj->WarehousePW );
; 6922 : #else
; 6923 : 		int  rZen = GetWarehouseUsedHowMuch(lpObj->Level, lpObj->WarehousePW);

  00637	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0063a	0f bf 88 9e 0c
	00 00		 movsx	 ecx, WORD PTR [eax+3230]
  00641	51		 push	 ecx
  00642	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00645	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  0064c	50		 push	 eax
  0064d	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHH@Z ; GetWarehouseUsedHowMuch
  00652	83 c4 08	 add	 esp, 8
  00655	89 45 dc	 mov	 DWORD PTR _rZen$9[ebp], eax

; 6924 : #endif
; 6925 : 
; 6926 : 		
; 6927 : #ifdef MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 6928 : 		if( (lpObj->Money-rZen) < 0 && (lpObj->WarehouseMoney-rZen) < 0)

  00658	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0065b	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00661	2b 4d dc	 sub	 ecx, DWORD PTR _rZen$9[ebp]
  00664	79 66		 jns	 SHORT $LN38@CGInventor
  00666	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00669	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  0066f	2b 4d dc	 sub	 ecx, DWORD PTR _rZen$9[ebp]
  00672	79 58		 jns	 SHORT $LN38@CGInventor

; 6929 : #else // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 6930 : 		if( (lpObj->Money-rZen) < 1 && (lpObj->WarehouseMoney-rZen) < 1)
; 6931 : #endif // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 6932 : 		{	//   	
; 6933 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  00674	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00677	50		 push	 eax
  00678	6a 00		 push	 0
  0067a	68 ff 00 00 00	 push	 255			; 000000ffH
  0067f	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00682	51		 push	 ecx
  00683	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00688	83 c4 10	 add	 esp, 16			; 00000010H

; 6934 : 
; 6935 : 			char msg[255];
; 6936 : 			wsprintf(msg, lMsg.Get(1605), rZen);

  0068b	8b 45 dc	 mov	 eax, DWORD PTR _rZen$9[ebp]
  0068e	50		 push	 eax
  0068f	68 45 06 00 00	 push	 1605			; 00000645H
  00694	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00699	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0069f	50		 push	 eax
  006a0	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$8[ebp]
  006a6	51		 push	 ecx
  006a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  006ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6937 : 			//wsprintf(msg, "   %d ", rZen);
; 6938 : 			GCServerMsgStringSend(msg, lpObj->m_Index, 1);	

  006b0	6a 01		 push	 1
  006b2	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b7	51		 push	 ecx
  006b8	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _msg$8[ebp]
  006be	52		 push	 edx
  006bf	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  006c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6939 : 			return;

  006c7	e9 0b 06 00 00	 jmp	 $LN1@CGInventor
$LN38@CGInventor:

; 6940 : 		}
; 6941 : 
; 6942 : 		if( bCanWarehouseLock == TRUE )

  006cc	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  006d3	75 57		 jne	 SHORT $LN40@CGInventor

; 6943 : 		{
; 6944 : 			if( gObj[aIndex].WarehouseLock == 1 )

  006d5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006e2	0f b6 94 01 a0
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3232]
  006ea	83 fa 01	 cmp	 edx, 1
  006ed	75 3d		 jne	 SHORT $LN40@CGInventor

; 6945 : 			{
; 6946 : 				GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);				

  006ef	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  006f2	50		 push	 eax
  006f3	6a 00		 push	 0
  006f5	68 ff 00 00 00	 push	 255			; 000000ffH
  006fa	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  006fd	51		 push	 ecx
  006fe	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00703	83 c4 10	 add	 esp, 16			; 00000010H

; 6947 : 				GCServerMsgStringSend(lMsg.Get(1606), lpObj->m_Index, 1);	

  00706	6a 01		 push	 1
  00708	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0070b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0070d	51		 push	 ecx
  0070e	68 46 06 00 00	 push	 1606			; 00000646H
  00713	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00718	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0071e	50		 push	 eax
  0071f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00724	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6948 : 				//GCServerMsgStringSend("  .", lpObj->m_Index, 1);	
; 6949 : 				return;

  00727	e9 ab 05 00 00	 jmp	 $LN1@CGInventor
$LN40@CGInventor:

; 6950 : 			}
; 6951 : 		}
; 6952 : 	}
; 6953 : 
; 6954 : #ifdef NEW_SKILL_FORSKYLAND	
; 6955 : 	if(it_type != I_INVENTORY )

  0072c	83 7d e8 08	 cmp	 DWORD PTR _it_type$[ebp], 8
  00730	0f 84 91 00 00
	00		 je	 $LN43@CGInventor

; 6956 : 	{
; 6957 : #ifdef ITEM_INDEX_EXTEND_20050706
; 6958 : 		int type	= ItemInfo[0]+((ItemInfo[3]&0x80)<<1)+((ItemInfo[5]&0xF0)<<5);
; 6959 : #else
; 6960 : 		int type	= ItemInfo[0]+(((ItemInfo[3]&0x80)>>7)*256);

  00736	b8 01 00 00 00	 mov	 eax, 1
  0073b	6b c8 00	 imul	 ecx, eax, 0
  0073e	0f b6 54 0d f0	 movzx	 edx, BYTE PTR _ItemInfo$[ebp+ecx]
  00743	b8 01 00 00 00	 mov	 eax, 1
  00748	6b c8 03	 imul	 ecx, eax, 3
  0074b	0f b6 44 0d f0	 movzx	 eax, BYTE PTR _ItemInfo$[ebp+ecx]
  00750	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00755	c1 f8 07	 sar	 eax, 7
  00758	c1 e0 08	 shl	 eax, 8
  0075b	03 d0		 add	 edx, eax
  0075d	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _type$7[ebp], edx

; 6961 : #endif
; 6962 : 
; 6963 : 		ITEM_ATTRIBUTE * p = GetItemAttr(type);

  00763	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _type$7[ebp]
  00769	50		 push	 eax
  0076a	e8 00 00 00 00	 call	 ?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z ; GetItemAttr
  0076f	83 c4 04	 add	 esp, 4
  00772	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _p$6[ebp], eax

; 6964 : 		if( !p )

  00778	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _p$6[ebp], 0
  0077f	75 1c		 jne	 SHORT $LN42@CGInventor

; 6965 : 		{
; 6966 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  00781	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00784	50		 push	 eax
  00785	6a 00		 push	 0
  00787	68 ff 00 00 00	 push	 255			; 000000ffH
  0078c	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0078f	51		 push	 ecx
  00790	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00795	83 c4 10	 add	 esp, 16			; 00000010H

; 6967 : 			return;

  00798	e9 3a 05 00 00	 jmp	 $LN1@CGInventor
$LN42@CGInventor:

; 6968 : 		}
; 6969 : 
; 6970 : 		if( p->QuestItem )

  0079d	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _p$6[ebp]
  007a3	0f b6 48 5c	 movzx	 ecx, BYTE PTR [eax+92]
  007a7	85 c9		 test	 ecx, ecx
  007a9	74 1c		 je	 SHORT $LN43@CGInventor

; 6971 : 		{	//    
; 6972 : 			GCItemMoveResultSend(aIndex, 0xFF, 0, ItemInfo);

  007ab	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  007ae	50		 push	 eax
  007af	6a 00		 push	 0
  007b1	68 ff 00 00 00	 push	 255			; 000000ffH
  007b6	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  007b9	51		 push	 ecx
  007ba	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  007bf	83 c4 10	 add	 esp, 16			; 00000010H

; 6973 : 			return;

  007c2	e9 10 05 00 00	 jmp	 $LN1@CGInventor
$LN43@CGInventor:

; 6974 : 		}
; 6975 : 	}
; 6976 : #endif
; 6977 : 
; 6978 : 	if( (lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_INVENTORY) ||	//  -> 
; 6979 : 		(lpMsg->sFlag == ITEMMOVE_WAREHOUSE && lpMsg->tFlag == ITEMMOVE_INVENTORY) ||	//  -> 
; 6980 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_WAREHOUSE) ||	//  -> 	
; 6981 : 		(lpMsg->sFlag == ITEMMOVE_WAREHOUSE && lpMsg->tFlag == ITEMMOVE_WAREHOUSE) ||	//  -> 
; 6982 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_CHAOSBOX) ||	//  -> 
; 6983 : #ifdef DARKLORD_WORK		//       
; 6984 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_DARK_TRAINER) ||	//  -> 2
; 6985 : #endif
; 6986 : 
; 6987 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 6988 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_JEWELOFHARMONY_PURITY) ||	//  ->  
; 6989 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_JEWELOFHARMONY_SMELT)  ||	//  ->   
; 6990 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_JEWELOFHARMONY_RESTORE) ||	//  ->   
; 6991 : #endif  // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 6992 : 
; 6993 : #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 6994 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_LOTTERY_MIX ) ||	//  ->  
; 6995 : 		(lpMsg->sFlag == ITEMMOVE_LOTTERY_MIX && lpMsg->tFlag == ITEMMOVE_LOTTERY_MIX ) ||	//   ->  
; 6996 : 		(lpMsg->sFlag == ITEMMOVE_LOTTERY_MIX && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||	//   -> 
; 6997 : #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 6998 : 
; 6999 : #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 7000 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_EXTRACT ) ||	//  ->   
; 7001 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_COMPOSIT ) ||	//  ->   
; 7002 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_EQUIP )	||		//  ->   
; 7003 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_REMOVE ) ||		//  ->   
; 7004 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_EXTRACT && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||	//    -> 
; 7005 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_COMPOSIT && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||	//    -> 
; 7006 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_EQUIP && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||		//    -> 
; 7007 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_REMOVE && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||		//    -> 
; 7008 : #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 7009 : 
; 7010 : #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 7011 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_CHERRYBLOSSOM ) ||	//  ->  
; 7012 : 		(lpMsg->sFlag == ITEMMOVE_CHERRYBLOSSOM && lpMsg->tFlag == ITEMMOVE_CHERRYBLOSSOM ) ||	//   ->  
; 7013 : 		(lpMsg->sFlag == ITEMMOVE_CHERRYBLOSSOM && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||	//   -> 
; 7014 : #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 7015 : 
; 7016 : #ifdef PERSONAL_SHOP_20040113 
; 7017 : 		(lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_PSHOPWND) ||	//  -> 
; 7018 : 		(lpMsg->sFlag == ITEMMOVE_PSHOPWND && lpMsg->tFlag == ITEMMOVE_INVENTORY) ||	//  -> 
; 7019 : 		(lpMsg->sFlag == ITEMMOVE_PSHOPWND && lpMsg->tFlag == ITEMMOVE_PSHOPWND) ||		//  -> 
; 7020 : #endif
; 7021 : 
; 7022 : #ifdef DARKLORD_WORK		//       		
; 7023 : 		(lpMsg->sFlag == ITEMMOVE_DARK_TRAINER && lpMsg->tFlag == ITEMMOVE_INVENTORY) ||	//  -> 
; 7024 : 		(lpMsg->sFlag == ITEMMOVE_DARK_TRAINER && lpMsg->tFlag == ITEMMOVE_DARK_TRAINER)  ||		//  -> 
; 7025 : #endif
; 7026 : 
; 7027 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530		
; 7028 : 		(lpMsg->sFlag == ITEMMOVE_JEWELOFHARMONY_PURITY && lpMsg->tFlag == ITEMMOVE_INVENTORY) ||				//  -> 
; 7029 : 		(lpMsg->sFlag == ITEMMOVE_JEWELOFHARMONY_PURITY && lpMsg->tFlag == ITEMMOVE_JEWELOFHARMONY_PURITY)  ||	//  -> 
; 7030 : 
; 7031 : 		(lpMsg->sFlag == ITEMMOVE_JEWELOFHARMONY_SMELT && lpMsg->tFlag == ITEMMOVE_INVENTORY) ||				//  -> 
; 7032 : 		(lpMsg->sFlag == ITEMMOVE_JEWELOFHARMONY_SMELT && lpMsg->tFlag == ITEMMOVE_JEWELOFHARMONY_SMELT)  ||	//  -> 
; 7033 : 
; 7034 : 		(lpMsg->sFlag == ITEMMOVE_JEWELOFHARMONY_RESTORE && lpMsg->tFlag == ITEMMOVE_INVENTORY) ||				 //  -> 
; 7035 : 		(lpMsg->sFlag == ITEMMOVE_JEWELOFHARMONY_RESTORE && lpMsg->tFlag == ITEMMOVE_JEWELOFHARMONY_RESTORE)  || //  -> 
; 7036 : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 7037 : 
; 7038 : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_03_20080704
; 7039 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_EXTRACT && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||				//    -> 
; 7040 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_COMPOSIT && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||				//    -> 
; 7041 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_EQUIP && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||				//    -> 
; 7042 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_REMOVE && lpMsg->tFlag == ITEMMOVE_INVENTORY ) ||				//    -> 
; 7043 : 
; 7044 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_EXTRACT && lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_EXTRACT ) ||				//    -> 
; 7045 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_COMPOSIT && lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_COMPOSIT ) ||				//    -> 
; 7046 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_EQUIP && lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_EQUIP ) ||				//    -> 
; 7047 : 		(lpMsg->sFlag == ITEMMOVE_SOCKET_ITEM_REMOVE && lpMsg->tFlag == ITEMMOVE_SOCKET_ITEM_REMOVE ) ||				//    -> 
; 7048 : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_03_20080704
; 7049 : 
; 7050 : 		(lpMsg->sFlag == ITEMMOVE_CHAOSBOX && lpMsg->tFlag == ITEMMOVE_INVENTORY) ||	//  -> 

  007c7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007ca	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  007ce	85 c9		 test	 ecx, ecx
  007d0	75 0f		 jne	 SHORT $LN47@CGInventor
  007d2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007d5	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  007d9	85 c9		 test	 ecx, ecx
  007db	0f 84 38 01 00
	00		 je	 $LN46@CGInventor
$LN47@CGInventor:
  007e1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007e4	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  007e8	83 f9 02	 cmp	 ecx, 2
  007eb	75 0f		 jne	 SHORT $LN48@CGInventor
  007ed	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007f0	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  007f4	85 c9		 test	 ecx, ecx
  007f6	0f 84 1d 01 00
	00		 je	 $LN46@CGInventor
$LN48@CGInventor:
  007fc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007ff	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00803	85 c9		 test	 ecx, ecx
  00805	75 10		 jne	 SHORT $LN49@CGInventor
  00807	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0080a	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  0080e	83 f9 02	 cmp	 ecx, 2
  00811	0f 84 02 01 00
	00		 je	 $LN46@CGInventor
$LN49@CGInventor:
  00817	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0081a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0081e	83 f9 02	 cmp	 ecx, 2
  00821	75 10		 jne	 SHORT $LN50@CGInventor
  00823	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00826	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  0082a	83 f9 02	 cmp	 ecx, 2
  0082d	0f 84 e6 00 00
	00		 je	 $LN46@CGInventor
$LN50@CGInventor:
  00833	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00836	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0083a	85 c9		 test	 ecx, ecx
  0083c	75 10		 jne	 SHORT $LN51@CGInventor
  0083e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00841	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00845	83 f9 03	 cmp	 ecx, 3
  00848	0f 84 cb 00 00
	00		 je	 $LN46@CGInventor
$LN51@CGInventor:
  0084e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00851	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00855	85 c9		 test	 ecx, ecx
  00857	75 10		 jne	 SHORT $LN52@CGInventor
  00859	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0085c	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00860	83 f9 05	 cmp	 ecx, 5
  00863	0f 84 b0 00 00
	00		 je	 $LN46@CGInventor
$LN52@CGInventor:
  00869	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0086c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00870	85 c9		 test	 ecx, ecx
  00872	75 10		 jne	 SHORT $LN53@CGInventor
  00874	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00877	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  0087b	83 f9 04	 cmp	 ecx, 4
  0087e	0f 84 95 00 00
	00		 je	 $LN46@CGInventor
$LN53@CGInventor:
  00884	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00887	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0088b	83 f9 04	 cmp	 ecx, 4
  0088e	75 0b		 jne	 SHORT $LN54@CGInventor
  00890	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00893	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00897	85 c9		 test	 ecx, ecx
  00899	74 7e		 je	 SHORT $LN46@CGInventor
$LN54@CGInventor:
  0089b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0089e	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  008a2	83 f9 04	 cmp	 ecx, 4
  008a5	75 0c		 jne	 SHORT $LN55@CGInventor
  008a7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008aa	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  008ae	83 f9 04	 cmp	 ecx, 4
  008b1	74 66		 je	 SHORT $LN46@CGInventor
$LN55@CGInventor:
  008b3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008b6	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  008ba	83 f9 05	 cmp	 ecx, 5
  008bd	75 0b		 jne	 SHORT $LN56@CGInventor
  008bf	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008c2	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  008c6	85 c9		 test	 ecx, ecx
  008c8	74 4f		 je	 SHORT $LN46@CGInventor
$LN56@CGInventor:
  008ca	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008cd	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  008d1	83 f9 05	 cmp	 ecx, 5
  008d4	75 0c		 jne	 SHORT $LN57@CGInventor
  008d6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008d9	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  008dd	83 f9 05	 cmp	 ecx, 5
  008e0	74 37		 je	 SHORT $LN46@CGInventor
$LN57@CGInventor:
  008e2	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008e5	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  008e9	83 f9 03	 cmp	 ecx, 3
  008ec	75 0b		 jne	 SHORT $LN58@CGInventor
  008ee	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008f1	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  008f5	85 c9		 test	 ecx, ecx
  008f7	74 20		 je	 SHORT $LN46@CGInventor
$LN58@CGInventor:
  008f9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008fc	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00900	83 f9 03	 cmp	 ecx, 3
  00903	0f 85 1d 02 00
	00		 jne	 $LN44@CGInventor
  00909	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0090c	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00910	83 f9 03	 cmp	 ecx, 3
  00913	0f 85 0d 02 00
	00		 jne	 $LN44@CGInventor
$LN46@CGInventor:

; 7051 : 		(lpMsg->sFlag == ITEMMOVE_CHAOSBOX && lpMsg->tFlag == ITEMMOVE_CHAOSBOX) )		//  -> 
; 7052 : 	{
; 7053 : 		int durSsend, durTsend;
; 7054 : 
; 7055 : 		result = gObjInventoryMoveItem(aIndex, source, target, durSsend, durTsend, lpMsg->sFlag, lpMsg->tFlag, ItemInfo);

  00919	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  0091c	50		 push	 eax
  0091d	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00920	0f b6 51 0a	 movzx	 edx, BYTE PTR [ecx+10]
  00924	52		 push	 edx
  00925	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00928	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0092c	51		 push	 ecx
  0092d	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _durTsend$4[ebp]
  00933	52		 push	 edx
  00934	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _durSsend$5[ebp]
  0093a	50		 push	 eax
  0093b	0f b6 4d e0	 movzx	 ecx, BYTE PTR _target$[ebp]
  0093f	51		 push	 ecx
  00940	0f b6 55 e4	 movzx	 edx, BYTE PTR _source$[ebp]
  00944	52		 push	 edx
  00945	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00948	50		 push	 eax
  00949	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem
  0094e	83 c4 20	 add	 esp, 32			; 00000020H
  00951	88 45 fb	 mov	 BYTE PTR _result$[ebp], al

; 7056 : 
; 7057 : 		GCItemMoveResultSend(aIndex, result, target, ItemInfo);

  00954	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00957	50		 push	 eax
  00958	0f b6 4d e0	 movzx	 ecx, BYTE PTR _target$[ebp]
  0095c	51		 push	 ecx
  0095d	0f b6 55 fb	 movzx	 edx, BYTE PTR _result$[ebp]
  00961	52		 push	 edx
  00962	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00965	50		 push	 eax
  00966	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0096b	83 c4 10	 add	 esp, 16			; 00000010H

; 7058 : 		
; 7059 : 		if( durSsend )

  0096e	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR _durSsend$5[ebp], 0
  00975	74 2a		 je	 SHORT $LN59@CGInventor

; 7060 : 			GCItemDurSend(aIndex, source, (int)lpObj->pInventory[source].m_Durability, 0);

  00977	6a 00		 push	 0
  00979	69 45 e4 a8 00
	00 00		 imul	 eax, DWORD PTR _source$[ebp], 168
  00980	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00983	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00989	f3 0f 2c 44 02
	24		 cvttss2si eax, DWORD PTR [edx+eax+36]
  0098f	50		 push	 eax
  00990	0f b6 4d e4	 movzx	 ecx, BYTE PTR _source$[ebp]
  00994	51		 push	 ecx
  00995	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00998	52		 push	 edx
  00999	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0099e	83 c4 10	 add	 esp, 16			; 00000010H
$LN59@CGInventor:

; 7061 : 
; 7062 : 		if( durTsend )

  009a1	83 bd cc fe ff
	ff 00		 cmp	 DWORD PTR _durTsend$4[ebp], 0
  009a8	74 2a		 je	 SHORT $LN60@CGInventor

; 7063 : 			GCItemDurSend(aIndex, target, (int)lpObj->pInventory[target].m_Durability, 0);

  009aa	6a 00		 push	 0
  009ac	69 45 e0 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  009b3	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009b6	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  009bc	f3 0f 2c 44 02
	24		 cvttss2si eax, DWORD PTR [edx+eax+36]
  009c2	50		 push	 eax
  009c3	0f b6 4d e0	 movzx	 ecx, BYTE PTR _target$[ebp]
  009c7	51		 push	 ecx
  009c8	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  009cb	52		 push	 edx
  009cc	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  009d1	83 c4 10	 add	 esp, 16			; 00000010H
$LN60@CGInventor:

; 7064 : 
; 7065 : #ifdef MODIFY_MOVE_KUNDUN_MARK_20070307	//        
; 7066 : 		int itemtype	= lpMsg->sItemInfo[0]+((lpMsg->sItemInfo[3]&0x80)<<1)+((lpMsg->sItemInfo[5]&0xF0)<<5);		
; 7067 : 		if(itemtype == MAKE_ITEMNUM(14,29) && lpObj->pInventory[target].m_Durability == 0 
; 7068 : 			&& lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_INVENTORY)
; 7069 : 		{
; 7070 : 			GCInventoryItemDeleteSend(aIndex, target, 0);
; 7071 : 		}
; 7072 : #else	// MODIFY_MOVE_KUNDUN_MARK_20070307
; 7073 : #ifdef MODIFY_CREATE_LOSTMAP_ITEM_20070209
; 7074 : 		int itemtype	= lpMsg->sItemInfo[0]+((lpMsg->sItemInfo[3]&0x80)<<1)+((lpMsg->sItemInfo[5]&0xF0)<<5);		
; 7075 : 		if(itemtype == MAKE_ITEMNUM(14,29) && lpObj->pInventory[target].m_Durability == 0)
; 7076 : 		{
; 7077 : 			GCInventoryItemDeleteSend(aIndex, target, 0);
; 7078 : 		}
; 7079 : #endif
; 7080 : #endif	// MODIFY_MOVE_KUNDUN_MARK_20070307
; 7081 : 		
; 7082 : 		if( (result!=0xFF)&& (lpMsg->sFlag == ITEMMOVE_WAREHOUSE && lpMsg->tFlag == ITEMMOVE_INVENTORY) )	

  009d4	0f b6 45 fb	 movzx	 eax, BYTE PTR _result$[ebp]
  009d8	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  009dd	0f 84 3e 01 00
	00		 je	 $LN64@CGInventor
  009e3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  009e6	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  009ea	83 f9 02	 cmp	 ecx, 2
  009ed	0f 85 2e 01 00
	00		 jne	 $LN64@CGInventor
  009f3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  009f6	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  009fa	85 c9		 test	 ecx, ecx
  009fc	0f 85 1f 01 00
	00		 jne	 $LN64@CGInventor

; 7083 : 		{	
; 7084 : 			//    
; 7085 : 
; 7086 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//  -   
; 7087 : 			int  rZen = GetWarehouseUsedHowMuch( lpObj->Level, lpObj->m_nMasterLevel, lpObj->WarehousePW );
; 7088 : #else	
; 7089 : 			int  rZen = GetWarehouseUsedHowMuch(lpObj->Level, lpObj->WarehousePW);

  00a02	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a05	0f bf 88 9e 0c
	00 00		 movsx	 ecx, WORD PTR [eax+3230]
  00a0c	51		 push	 ecx
  00a0d	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a10	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  00a17	50		 push	 eax
  00a18	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHH@Z ; GetWarehouseUsedHowMuch
  00a1d	83 c4 08	 add	 esp, 8
  00a20	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _rZen$3[ebp], eax

; 7090 : #endif
; 7091 : 
; 7092 : #ifdef MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 7093 : 			if( lpObj->Money-rZen >= 0 )

  00a26	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a29	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00a2f	2b 8d c8 fe ff
	ff		 sub	 ecx, DWORD PTR _rZen$3[ebp]
  00a35	78 6a		 js	 SHORT $LN62@CGInventor

; 7094 : #else // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 7095 : 			if( lpObj->Money-rZen > 0 )
; 7096 : #endif // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 7097 : 			{
; 7098 : 				int oldmoney=lpObj->Money;

  00a37	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a3a	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00a40	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _oldmoney$2[ebp], ecx

; 7099 : 				lpObj->Money -= rZen;

  00a46	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a49	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00a4f	2b 8d c8 fe ff
	ff		 sub	 ecx, DWORD PTR _rZen$3[ebp]
  00a55	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a58	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 7100 : 				GCMoneySend(lpObj->m_Index, lpObj->Money);

  00a5e	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a61	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00a67	51		 push	 ecx
  00a68	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a6b	8b 02		 mov	 eax, DWORD PTR [edx]
  00a6d	50		 push	 eax
  00a6e	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00a73	83 c4 08	 add	 esp, 8

; 7101 : 				LogAdd("Pay WareHouse Money(In Inventory) : %d - %d = %d", oldmoney, rZen, lpObj->Money);

  00a76	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a79	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00a7f	51		 push	 ecx
  00a80	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _rZen$3[ebp]
  00a86	52		 push	 edx
  00a87	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _oldmoney$2[ebp]
  00a8d	50		 push	 eax
  00a8e	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventor@
  00a93	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00a99	83 c4 10	 add	 esp, 16			; 00000010H

; 7102 : 			}

  00a9c	e9 80 00 00 00	 jmp	 $LN64@CGInventor
$LN62@CGInventor:

; 7103 : #ifdef MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 7104 : 			else if( lpObj->WarehouseMoney-rZen >= 0 )

  00aa1	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aa4	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00aaa	2b 8d c8 fe ff
	ff		 sub	 ecx, DWORD PTR _rZen$3[ebp]
  00ab0	78 6f		 js	 SHORT $LN64@CGInventor

; 7105 : #else // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 7106 : 			else if( lpObj->WarehouseMoney-rZen > 0 )
; 7107 : #endif // MODIFY_WAREHOUSE_HIRE_BUGFIX_20090413
; 7108 : 			{
; 7109 : 				int oldmoney=lpObj->WarehouseMoney;

  00ab2	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ab5	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00abb	89 8d c0 fe ff
	ff		 mov	 DWORD PTR _oldmoney$1[ebp], ecx

; 7110 : 				lpObj->WarehouseMoney -= rZen;

  00ac1	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ac4	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00aca	2b 8d c8 fe ff
	ff		 sub	 ecx, DWORD PTR _rZen$3[ebp]
  00ad0	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ad3	89 8a a4 0c 00
	00		 mov	 DWORD PTR [edx+3236], ecx

; 7111 : 				LogAdd("Pay WareHouse Money(In WareHouse) : %d - %d = %d", oldmoney, rZen, lpObj->WarehouseMoney);

  00ad9	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00adc	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00ae2	51		 push	 ecx
  00ae3	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _rZen$3[ebp]
  00ae9	52		 push	 edx
  00aea	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _oldmoney$1[ebp]
  00af0	50		 push	 eax
  00af1	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHous@
  00af6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00afc	83 c4 10	 add	 esp, 16			; 00000010H

; 7112 : 				GCWarehouseInventoryMoneySend(aIndex, 0x01, lpObj->Money, lpObj->WarehouseMoney);

  00aff	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b02	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00b08	51		 push	 ecx
  00b09	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b0c	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  00b12	50		 push	 eax
  00b13	6a 01		 push	 1
  00b15	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00b18	51		 push	 ecx
  00b19	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00b1e	83 c4 10	 add	 esp, 16			; 00000010H
$LN64@CGInventor:

; 7113 : 			}
; 7114 : 		}
; 7115 : 	}

  00b21	e9 b1 01 00 00	 jmp	 $LN73@CGInventor
$LN44@CGInventor:

; 7116 : 	//   
; 7117 : 	else if( lpMsg->sFlag == ITEMMOVE_TRADEWND && lpMsg->tFlag == ITEMMOVE_TRADEWND )

  00b26	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00b29	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00b2d	83 f9 01	 cmp	 ecx, 1
  00b30	75 44		 jne	 SHORT $LN65@CGInventor
  00b32	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00b35	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00b39	83 f9 01	 cmp	 ecx, 1
  00b3c	75 38		 jne	 SHORT $LN65@CGInventor

; 7118 : 	{
; 7119 : 		result = gObjTradeTradeMove(lpObj, source, target);

  00b3e	0f b6 45 e0	 movzx	 eax, BYTE PTR _target$[ebp]
  00b42	50		 push	 eax
  00b43	0f b6 4d e4	 movzx	 ecx, BYTE PTR _source$[ebp]
  00b47	51		 push	 ecx
  00b48	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b4b	52		 push	 edx
  00b4c	e8 00 00 00 00	 call	 ?gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z ; gObjTradeTradeMove
  00b51	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b54	88 45 fb	 mov	 BYTE PTR _result$[ebp], al

; 7120 : 		GCItemMoveResultSend(aIndex, result, target, ItemInfo);

  00b57	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00b5a	50		 push	 eax
  00b5b	0f b6 4d e0	 movzx	 ecx, BYTE PTR _target$[ebp]
  00b5f	51		 push	 ecx
  00b60	0f b6 55 fb	 movzx	 edx, BYTE PTR _result$[ebp]
  00b64	52		 push	 edx
  00b65	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b68	50		 push	 eax
  00b69	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00b6e	83 c4 10	 add	 esp, 16			; 00000010H

; 7121 : 
; 7122 : 		
; 7123 : 	}

  00b71	e9 61 01 00 00	 jmp	 $LN73@CGInventor
$LN65@CGInventor:

; 7124 : 	//   
; 7125 : 	else if( lpMsg->sFlag == ITEMMOVE_TRADEWND && lpMsg->tFlag == ITEMMOVE_INVENTORY )

  00b76	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00b79	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00b7d	83 f9 01	 cmp	 ecx, 1
  00b80	0f 85 07 01 00
	00		 jne	 $LN67@CGInventor
  00b86	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00b89	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00b8d	85 c9		 test	 ecx, ecx
  00b8f	0f 85 f8 00 00
	00		 jne	 $LN67@CGInventor

; 7126 : 	{
; 7127 : 		result = gObjTradeInventoryMove(lpObj, source, target);

  00b95	0f b6 45 e0	 movzx	 eax, BYTE PTR _target$[ebp]
  00b99	50		 push	 eax
  00b9a	0f b6 4d e4	 movzx	 ecx, BYTE PTR _source$[ebp]
  00b9e	51		 push	 ecx
  00b9f	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ba2	52		 push	 edx
  00ba3	e8 00 00 00 00	 call	 ?gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z ; gObjTradeInventoryMove
  00ba8	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bab	88 45 fb	 mov	 BYTE PTR _result$[ebp], al

; 7128 : 		
; 7129 : 		if( result == 0xFF )

  00bae	0f b6 45 fb	 movzx	 eax, BYTE PTR _result$[ebp]
  00bb2	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00bb7	75 28		 jne	 SHORT $LN69@CGInventor

; 7130 : 		{
; 7131 : 			GCItemMoveResultSend(aIndex, 0xFF, target, ItemInfo);

  00bb9	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00bbc	50		 push	 eax
  00bbd	0f b6 4d e0	 movzx	 ecx, BYTE PTR _target$[ebp]
  00bc1	51		 push	 ecx
  00bc2	68 ff 00 00 00	 push	 255			; 000000ffH
  00bc7	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00bca	52		 push	 edx
  00bcb	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00bd0	83 c4 10	 add	 esp, 16			; 00000010H

; 7132 : 			
; 7133 : 			CGTradeCancelButtonRecv(aIndex);

  00bd3	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00bd6	50		 push	 eax
  00bd7	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  00bdc	83 c4 04	 add	 esp, 4

; 7134 : 		}

  00bdf	eb 1a		 jmp	 SHORT $LN70@CGInventor
$LN69@CGInventor:

; 7135 : 		else 
; 7136 : 		{
; 7137 : 			GCItemMoveResultSend(aIndex, result, target, ItemInfo);

  00be1	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00be4	50		 push	 eax
  00be5	0f b6 4d e0	 movzx	 ecx, BYTE PTR _target$[ebp]
  00be9	51		 push	 ecx
  00bea	0f b6 55 fb	 movzx	 edx, BYTE PTR _result$[ebp]
  00bee	52		 push	 edx
  00bef	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00bf2	50		 push	 eax
  00bf3	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00bf8	83 c4 10	 add	 esp, 16			; 00000010H
$LN70@CGInventor:

; 7138 : 
; 7139 : 		}
; 7140 : 		if( result == 0xFF )

  00bfb	0f b6 45 fb	 movzx	 eax, BYTE PTR _result$[ebp]
  00bff	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00c04	75 21		 jne	 SHORT $LN71@CGInventor

; 7141 : 		{
; 7142 : 			lpObj->m_IfState.state = 0;

  00c06	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c09	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00c0f	80 e1 f3	 and	 cl, 243			; 000000f3H
  00c12	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c15	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 7143 : 			GCItemListSend(aIndex);

  00c1b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00c1e	50		 push	 eax
  00c1f	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  00c24	83 c4 04	 add	 esp, 4
$LN71@CGInventor:

; 7144 : 		}
; 7145 : 		if( lpObj->TargetNumber >= 0 )

  00c27	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c2a	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00c31	85 c9		 test	 ecx, ecx
  00c33	7c 56		 jl	 SHORT $LN72@CGInventor

; 7146 : 		{
; 7147 : 			lpObj->TradeOk = 0;

  00c35	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c38	c6 80 90 0c 00
	00 00		 mov	 BYTE PTR [eax+3216], 0

; 7148 : 			gObj[gObj[aIndex].TargetNumber].TradeOk = 0;

  00c3f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c46	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c4c	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  00c54	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  00c5a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c60	c6 84 01 90 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3216], 0

; 7149 : 			GCTradeOkButtonSend(lpObj->TargetNumber, 0x02);

  00c68	6a 02		 push	 2
  00c6a	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c6d	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00c74	51		 push	 ecx
  00c75	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  00c7a	83 c4 08	 add	 esp, 8

; 7150 : 			GCTradeOkButtonSend(aIndex, 0x00);

  00c7d	6a 00		 push	 0
  00c7f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00c82	50		 push	 eax
  00c83	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  00c88	83 c4 08	 add	 esp, 8
$LN72@CGInventor:

; 7151 : 		}
; 7152 : 	}

  00c8b	eb 4a		 jmp	 SHORT $LN73@CGInventor
$LN67@CGInventor:

; 7153 : 	//   
; 7154 : 	else if( lpMsg->sFlag == ITEMMOVE_INVENTORY && lpMsg->tFlag == ITEMMOVE_TRADEWND )

  00c8d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00c90	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00c94	85 c9		 test	 ecx, ecx
  00c96	75 3f		 jne	 SHORT $LN73@CGInventor
  00c98	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00c9b	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00c9f	83 f9 01	 cmp	 ecx, 1
  00ca2	75 33		 jne	 SHORT $LN73@CGInventor

; 7155 : 	{
; 7156 : 		result = gObjInventoryTradeMove(lpObj, source, target);

  00ca4	0f b6 45 e0	 movzx	 eax, BYTE PTR _target$[ebp]
  00ca8	50		 push	 eax
  00ca9	0f b6 4d e4	 movzx	 ecx, BYTE PTR _source$[ebp]
  00cad	51		 push	 ecx
  00cae	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cb1	52		 push	 edx
  00cb2	e8 00 00 00 00	 call	 ?gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z ; gObjInventoryTradeMove
  00cb7	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cba	88 45 fb	 mov	 BYTE PTR _result$[ebp], al

; 7157 : 		GCItemMoveResultSend(aIndex, result, target, ItemInfo);

  00cbd	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00cc0	50		 push	 eax
  00cc1	0f b6 4d e0	 movzx	 ecx, BYTE PTR _target$[ebp]
  00cc5	51		 push	 ecx
  00cc6	0f b6 55 fb	 movzx	 edx, BYTE PTR _result$[ebp]
  00cca	52		 push	 edx
  00ccb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00cce	50		 push	 eax
  00ccf	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00cd4	83 c4 10	 add	 esp, 16			; 00000010H
$LN73@CGInventor:
$LN1@CGInventor:

; 7158 : 
; 7159 : 	}
; 7160 : }

  00cd7	5f		 pop	 edi
  00cd8	5e		 pop	 esi
  00cd9	5b		 pop	 ebx
  00cda	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cdd	33 cd		 xor	 ecx, ebp
  00cdf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ce4	8b e5		 mov	 esp, ebp
  00ce6	5d		 pop	 ebp
  00ce7	c3		 ret	 0
?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ENDP ; CGInventoryItemMove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z
_TEXT	SEGMENT
tv88 = -80						; size = 4
tv89 = -76						; size = 4
_pMsg$ = -8						; size = 8
_lpObj$ = 8						; size = 4
_state$ = 12						; size = 1
_ViewSkillState$ = 16					; size = 2
?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z PROC		; GCStateInfoSend, COMDAT

; 15634: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15635: 	PMSG_VIEWSKILLSTATE	pMsg;
; 15636: 
; 15637: 	PHeadSetB((LPBYTE)&pMsg, 0x07, sizeof( pMsg ));

  00009	6a 08		 push	 8
  0000b	6a 07		 push	 7
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15638: 
; 15639: 	pMsg.State = state;

  00019	8a 45 0c	 mov	 al, BYTE PTR _state$[ebp]
  0001c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 15640: 
; 15641: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 15642: 	pMsg.BuffEffectCount = gObjMakeViewportState( lpObj, pMsg.BuffEffectList );
; 15643: 	pMsg.h.size -= MAX_BUFF_SLOT_INDEX - pMsg.BuffEffectCount;
; 15644: #else
; 15645: 	pMsg.ViewSkillState = ViewSkillState;

  0001f	66 8b 45 10	 mov	 ax, WORD PTR _ViewSkillState$[ebp]
  00023	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 15646: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 15647: 	pMsg.NumberH = HIBYTE(lpObj->m_Index);

  00027	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	c1 e9 08	 shr	 ecx, 8
  0002f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00035	88 4d fe	 mov	 BYTE PTR _pMsg$[ebp+6], cl

; 15648: 	pMsg.NumberL = LOBYTE(lpObj->m_Index);

  00038	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00043	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 15649: 	
; 15650: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00046	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00049	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0004d	83 f9 01	 cmp	 ecx, 1
  00050	75 17		 jne	 SHORT $LN2@GCStateInf

; 15651: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00052	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00056	50		 push	 eax
  00057	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005a	51		 push	 ecx
  0005b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005e	8b 02		 mov	 eax, DWORD PTR [edx]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCStateInf:

; 15652: 
; 15653: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917					// !! NOT
; 15654: 	#ifdef CHAOSCASTLE_SYSTEM_20040408		// !!> .          .
; 15655: 	if (CHECK_CHAOSCASTLE(lpObj->MapNumber)) {

  00069	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00073	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00076	7d 09		 jge	 SHORT $LN7@GCStateInf
  00078	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  0007f	eb 25		 jmp	 SHORT $LN8@GCStateInf
$LN7@GCStateInf:
  00081	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00084	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0008b	83 f8 17	 cmp	 eax, 23			; 00000017H
  0008e	7e 09		 jle	 SHORT $LN5@GCStateInf
  00090	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
  00097	eb 07		 jmp	 SHORT $LN6@GCStateInf
$LN5@GCStateInf:
  00099	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
$LN6@GCStateInf:
  000a0	8b 4d b0	 mov	 ecx, DWORD PTR tv88[ebp]
  000a3	89 4d b4	 mov	 DWORD PTR tv89[ebp], ecx
$LN8@GCStateInf:
  000a6	83 7d b4 00	 cmp	 DWORD PTR tv89[ebp], 0
  000aa	74 06		 je	 SHORT $LN3@GCStateInf

; 15656: //		pMsg.ViewSkillState &= ~STATE_REDUCE_MAGICDEFENSE;		// 
; 15657: //		pMsg.ViewSkillState &= ~STATE_ADD_LIFE;					// 
; 15658: //		pMsg.ViewSkillState &= ~STATE_ATTACK;					// 
; 15659: //		pMsg.ViewSkillState &= ~STATE_DEFENSE;					// 
; 15660: 		pMsg.ViewSkillState = 0;

  000ac	33 c0		 xor	 eax, eax
  000ae	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax
$LN3@GCStateInf:

; 15661: 	}
; 15662: 	#endif
; 15663: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 15664: 
; 15665: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  000b2	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000b6	50		 push	 eax
  000b7	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000ba	51		 push	 ecx
  000bb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15666: }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z ENDP		; GCStateInfoSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCSendQuestPrize@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 7
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Type$ = 12						; size = 1
_Count$ = 16						; size = 1
?GCSendQuestPrize@@YAXHEE@Z PROC			; GCSendQuestPrize, COMDAT

; 19523: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19524: 	CGRequestQuestInfo(aIndex);

  00009	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo
  00012	83 c4 04	 add	 esp, 4

; 19525: 
; 19526: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00015	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00022	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 19527: 
; 19528: 	PMSG_SETQUEST_PRIZE pMsg;
; 19529: 	PHeadSetB((LPBYTE)&pMsg, 0xA3, sizeof(pMsg));

  00025	6a 07		 push	 7
  00027	68 a3 00 00 00	 push	 163			; 000000a3H
  0002c	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19530: 
; 19531: 	pMsg.NumberH	= HIBYTE(lpObj->m_Index);

  00038	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	c1 e9 08	 shr	 ecx, 8
  00040	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00046	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 19532: 	pMsg.NumberL	= LOBYTE(lpObj->m_Index);

  00049	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00054	88 4d f8	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 19533: 
; 19534: 	pMsg.Type = Type;

  00057	8a 45 0c	 mov	 al, BYTE PTR _Type$[ebp]
  0005a	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 19535: 	pMsg.Count = Count;

  0005d	8a 45 10	 mov	 al, BYTE PTR _Count$[ebp]
  00060	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 19536: 
; 19537: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00063	6a 07		 push	 7
  00065	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00068	50		 push	 eax
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19538: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, sizeof(pMsg));

  00075	6a 07		 push	 7
  00077	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19539: }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?GCSendQuestPrize@@YAXHEE@Z ENDP			; GCSendQuestPrize
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCSendQuestInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 5
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
?GCSendQuestInfo@@YAXHH@Z PROC				; GCSendQuestInfo, COMDAT

; 19491: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19492: 	CGRequestQuestInfo(aIndex);

  00009	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo
  00012	83 c4 04	 add	 esp, 4

; 19493: 
; 19494: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00015	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00022	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 19495: 
; 19496: 	PMSG_SETQUEST pMsg;
; 19497: 	PHeadSetB((LPBYTE)&pMsg, 0xA1, sizeof(pMsg));

  00025	6a 05		 push	 5
  00027	68 a1 00 00 00	 push	 161			; 000000a1H
  0002c	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19498: 
; 19499: 	pMsg.QuestIndex = QuestIndex;

  00038	8a 45 0c	 mov	 al, BYTE PTR _QuestIndex$[ebp]
  0003b	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 19500: 	pMsg.State = g_QuestInfo.GetQuestStateBYTE(lpObj, QuestIndex);

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00041	50		 push	 eax
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00045	51		 push	 ecx
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0004b	e8 00 00 00 00	 call	 ?GetQuestStateBYTE@CQuestInfo@@QAEEPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestStateBYTE
  00050	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19501: 
; 19502: 	if( pMsg.State != 0 )

  00053	0f b6 45 f8	 movzx	 eax, BYTE PTR _pMsg$[ebp+4]
  00057	85 c0		 test	 eax, eax
  00059	74 12		 je	 SHORT $LN1@GCSendQues

; 19503: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0005b	6a 05		 push	 5
  0005d	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00060	50		 push	 eax
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCSendQues:

; 19504: }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?GCSendQuestInfo@@YAXHH@Z ENDP				; GCSendQuestInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCWarehouseStateSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_state$ = 12						; size = 1
?GCWarehouseStateSend@@YAXHE@Z PROC			; GCWarehouseStateSend, COMDAT

; 13264: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 13265: 	PMSG_WAREHOUSESTATE pMsg;
; 13266: 
; 13267: 	PHeadSetB((LPBYTE)&pMsg, 0x83, sizeof( pMsg ));

  00009	6a 04		 push	 4
  0000b	68 83 00 00 00	 push	 131			; 00000083H
  00010	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13268: 	pMsg.State      = state;//gObj[aIndex].WarehouseLock;

  0001c	8a 45 0c	 mov	 al, BYTE PTR _state$[ebp]
  0001f	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 13269: 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00022	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00026	50		 push	 eax
  00027	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13270: }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?GCWarehouseStateSend@@YAXHE@Z ENDP			; GCWarehouseStateSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCSendPing@@YAXH@Z
_TEXT	SEGMENT
_pMsgPing$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCSendPing@@YAXH@Z PROC				; GCSendPing, COMDAT

; 19132: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19133: 	PMSG_PING pMsgPing;
; 19134: 
; 19135: 	PHeadSetB((LPBYTE)&pMsgPing, 0x71, sizeof(pMsgPing));

  00009	6a 03		 push	 3
  0000b	6a 71		 push	 113			; 00000071H
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _pMsgPing$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19136: 	gObj[aIndex].iPingTime = GetTickCount();	

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0001f	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00026	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002c	89 44 0a 50	 mov	 DWORD PTR [edx+ecx+80], eax

; 19137: 	DataSend(aIndex, (LPBYTE)&pMsgPing, pMsgPing.h.size);

  00030	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsgPing$[ebp+1]
  00034	50		 push	 eax
  00035	8d 4d fc	 lea	 ecx, DWORD PTR _pMsgPing$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19138: }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?GCSendPing@@YAXH@Z ENDP				; GCSendPing
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?AllSendSameMapMsg@@YAXPAEHE@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_Msg$ = 8						; size = 4
_size$ = 12						; size = 4
_mapnumber$ = 16					; size = 1
?AllSendSameMapMsg@@YAXPAEHE@Z PROC			; AllSendSameMapMsg, COMDAT

; 19120: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19121: 	for( int n=0; n<MAX_OBJECT; n++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@AllSendSam
$LN2@AllSendSam:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@AllSendSam:
  0001b	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00022	7d 5e		 jge	 SHORT $LN1@AllSendSam

; 19122: 	{
; 19123: 		if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) && 

  00024	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00031	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00036	75 48		 jne	 SHORT $LN5@AllSendSam
  00038	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00045	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0004a	83 fa 01	 cmp	 edx, 1
  0004d	75 31		 jne	 SHORT $LN5@AllSendSam
  0004f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00064	0f b6 45 10	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  00068	3b d0		 cmp	 edx, eax
  0006a	75 14		 jne	 SHORT $LN5@AllSendSam

; 19124: 			gObj[n].MapNumber == mapnumber )
; 19125: 		{
; 19126: 			DataSend(n, (LPBYTE)Msg, size);

  0006c	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _Msg$[ebp]
  00073	51		 push	 ecx
  00074	8b 55 fc	 mov	 edx, DWORD PTR _n$1[ebp]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@AllSendSam:

; 19127: 		}
; 19128: 	}

  00080	eb 90		 jmp	 SHORT $LN2@AllSendSam
$LN1@AllSendSam:

; 19129: }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?AllSendSameMapMsg@@YAXPAEHE@Z ENDP			; AllSendSameMapMsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?AllSendMsg@@YAXPAEH@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_Msg$ = 8						; size = 4
_size$ = 12						; size = 4
?AllSendMsg@@YAXPAEH@Z PROC				; AllSendMsg, COMDAT

; 19105: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19106: #ifdef FOR_BLOODCASTLE
; 19107: 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00009	c7 45 fc 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00010	eb 09		 jmp	 SHORT $LN4@AllSendMsg
$LN2@AllSendMsg:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@AllSendMsg:
  0001b	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00022	7d 41		 jge	 SHORT $LN1@AllSendMsg

; 19108: #else
; 19109: 	for( int n=0; n<MAX_OBJECT; n++)
; 19110: #endif	
; 19111: 	{
; 19112: 		if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) )

  00024	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00031	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00036	75 2b		 jne	 SHORT $LN5@AllSendMsg
  00038	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00045	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0004a	83 fa 01	 cmp	 edx, 1
  0004d	75 14		 jne	 SHORT $LN5@AllSendMsg

; 19113: 		{
; 19114: 			DataSend(n, (LPBYTE)Msg, size);

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _Msg$[ebp]
  00056	51		 push	 ecx
  00057	8b 55 fc	 mov	 edx, DWORD PTR _n$1[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@AllSendMsg:

; 19115: 		}
; 19116: 	}

  00063	eb ad		 jmp	 SHORT $LN2@AllSendMsg
$LN1@AllSendMsg:

; 19117: }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?AllSendMsg@@YAXPAEH@Z ENDP				; AllSendMsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z
_TEXT	SEGMENT
tv69 = -88						; size = 4
_wREMAIN_TIME$1 = -20					; size = 2
_wREMAIN_TIME$2 = -16					; size = 2
_iENTER_LEVEL$3 = -12					; size = 4
_pResult$ = -8						; size = 7
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z PROC ; GCReqDevilSquareRemainTime, COMDAT

; 18915: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18916: 	PMSG_RESULT_DEVILSQUARE_REMAINTIME pResult;	PHeadSetB((LPBYTE)&pResult, 0x91, sizeof(pResult));

  00009	6a 07		 push	 7
  0000b	68 91 00 00 00	 push	 145			; 00000091H
  00010	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18917: 	pResult.RemainTime = 0;

  0001c	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 18918: 
; 18919: #ifdef UPDATE_PK_SYSTEM_20070302
; 18920: 	BOOL	PKFlag = FALSE;
; 18921: #endif
; 18922: 
; 18923: #ifdef FOR_BLOODCASTLE
; 18924: 	switch (lpMsg->hEventType) {

  00020	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00023	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00026	88 4d a8	 mov	 BYTE PTR tv69[ebp], cl
  00029	80 7d a8 01	 cmp	 BYTE PTR tv69[ebp], 1
  0002d	74 19		 je	 SHORT $LN4@GCReqDevil
  0002f	80 7d a8 02	 cmp	 BYTE PTR tv69[ebp], 2
  00033	0f 84 d8 00 00
	00		 je	 $LN11@GCReqDevil
  00039	80 7d a8 04	 cmp	 BYTE PTR tv69[ebp], 4
  0003d	0f 84 c0 01 00
	00		 je	 $LN18@GCReqDevil
  00043	e9 1f 03 00 00	 jmp	 $LN2@GCReqDevil
$LN4@GCReqDevil:

; 18925: 
; 18926: 	case 1 :	// 
; 18927: #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 18928: 		//     .
; 18929: 		if( gObj[aIndex].m_PK_Level >= PK_LEVEL_DEFAULT + 1 )

  00048	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00055	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  0005d	83 fa 04	 cmp	 edx, 4
  00060	7c 61		 jl	 SHORT $LN5@GCReqDevil

; 18930: 		{	
; 18931: 			GCServerCmd( aIndex, MSGBOX_ENTERLIMIT_PKUSER_DEVILSQURE, 0, 0 );

  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	6a 37		 push	 55			; 00000037H
  00068	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd
  00071	83 c4 10	 add	 esp, 16			; 00000010H

; 18932: 			LogAddTD( "[PK User][DevilSquare] [%s][%s] Move Fail [PK Level:%d]", 

  00074	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00081	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00089	52		 push	 edx
  0008a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00097	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0009b	52		 push	 edx
  0009c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a9	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000ad	52		 push	 edx
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b9	83 c4 10	 add	 esp, 16			; 00000010H

; 18933: 			   gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level );			
; 18934: 			return;

  000bc	e9 bb 02 00 00	 jmp	 $LN1@GCReqDevil

; 18935: 		}			

  000c1	eb 49		 jmp	 SHORT $LN6@GCReqDevil
$LN5@GCReqDevil:

; 18936: 		else
; 18937: 		{
; 18938: #endif		
; 18939: 			pResult.hEventType = 1;

  000c3	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 18940: 			if( g_DevilSquare.GetState() == DevilSquare_CLOSE )

  000c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  000cc	e8 00 00 00 00	 call	 ?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ; CDevilSquare::GetState
  000d1	85 c0		 test	 eax, eax
  000d3	75 0f		 jne	 SHORT $LN7@GCReqDevil

; 18941: 			{	// ,   
; 18942: 				pResult.RemainTime = g_DevilSquare.GetRemainTime();

  000d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  000da	e8 00 00 00 00	 call	 ?GetRemainTime@CDevilSquare@@QAEHXZ ; CDevilSquare::GetRemainTime
  000df	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al

; 18943: 			}

  000e2	eb 28		 jmp	 SHORT $LN6@GCReqDevil
$LN7@GCReqDevil:

; 18944: 			else if( g_DevilSquare.GetState() == DevilSquare_OPEN )

  000e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  000e9	e8 00 00 00 00	 call	 ?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ; CDevilSquare::GetState
  000ee	83 f8 01	 cmp	 eax, 1
  000f1	75 06		 jne	 SHORT $LN9@GCReqDevil

; 18945: 			{
; 18946: 				pResult.RemainTime = 0x00;

  000f3	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 18947: 			}

  000f7	eb 13		 jmp	 SHORT $LN6@GCReqDevil
$LN9@GCReqDevil:

; 18948: 			else
; 18949: 			{
; 18950: #ifdef UPDATE_DEVIL_SQUARE_START_TIME_20070511	//  
; 18951: 				pResult.RemainTime = g_DevilSquare.GetNextRemainTime();
; 18952: #else
; 18953: 				pResult.RemainTime = g_DevilSquare.GetRemainTime()+g_DevilSquare.m_iCloseTime;

  000f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  000fe	e8 00 00 00 00	 call	 ?GetRemainTime@CDevilSquare@@QAEHXZ ; CDevilSquare::GetRemainTime
  00103	03 05 24 00 00
	00		 add	 eax, DWORD PTR ?g_DevilSquare@@3VCDevilSquare@@A+36
  00109	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al
$LN6@GCReqDevil:

; 18954: #endif
; 18955: 			}
; 18956: #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 18957: 		}
; 18958: #endif		
; 18959: 		break;

  0010c	e9 56 02 00 00	 jmp	 $LN2@GCReqDevil
$LN11@GCReqDevil:

; 18960: 
; 18961: 	case 2 :	//  
; 18962: #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 18963: 		//     .
; 18964: 		if( gObj[aIndex].m_PK_Level >= PK_LEVEL_DEFAULT + 1 )

  00111	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011e	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00126	83 fa 04	 cmp	 edx, 4
  00129	7c 61		 jl	 SHORT $LN12@GCReqDevil

; 18965: 		{	
; 18966: 			GCServerCmd( aIndex, MSGBOX_ENTERLIMIT_PKUSER_BLOODCASTLE, 0, 0 );

  0012b	6a 00		 push	 0
  0012d	6a 00		 push	 0
  0012f	6a 38		 push	 56			; 00000038H
  00131	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd
  0013a	83 c4 10	 add	 esp, 16			; 00000010H

; 18967: 			LogAddTD( "[PK User][BloodCastle] [%s][%s] Move Fail [PK Level:%d]", 

  0013d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00144	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014a	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00152	52		 push	 edx
  00153	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0015a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00160	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00164	52		 push	 edx
  00165	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0016c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00172	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00176	52		 push	 edx
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00182	83 c4 10	 add	 esp, 16			; 00000010H

; 18968: 			   gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level );
; 18969: 			return;

  00185	e9 f2 01 00 00	 jmp	 $LN1@GCReqDevil

; 18970: 		}			

  0018a	eb 72		 jmp	 SHORT $LN13@GCReqDevil
$LN12@GCReqDevil:

; 18971: 		else
; 18972: 		{
; 18973: #endif
; 18974: 			pResult.hEventType = 2;

  0018c	c6 45 fb 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 18975: 			if ( g_BloodCastle.GetCurrentState(lpMsg->btItemLevel-1) == BLOODCASTLE_STATE_CLOSED) {	//        ??

  00190	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00193	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00197	83 e9 01	 sub	 ecx, 1
  0019a	51		 push	 ecx
  0019b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001a0	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  001a5	83 f8 01	 cmp	 eax, 1
  001a8	75 3c		 jne	 SHORT $LN14@GCReqDevil

; 18976: 				if (g_BloodCastle.CheckCanEnter(lpMsg->btItemLevel-1))

  001aa	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001ad	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001b1	83 e9 01	 sub	 ecx, 1
  001b4	51		 push	 ecx
  001b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001ba	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  001bf	0f b6 d0	 movzx	 edx, al
  001c2	85 d2		 test	 edx, edx
  001c4	74 06		 je	 SHORT $LN16@GCReqDevil

; 18977: 					pResult.RemainTime = 0x00;

  001c6	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  001ca	eb 18		 jmp	 SHORT $LN17@GCReqDevil
$LN16@GCReqDevil:

; 18978: 				else
; 18979: 					pResult.RemainTime = g_BloodCastle.GetRemainTime(lpMsg->btItemLevel-1);

  001cc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001cf	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001d3	83 e9 01	 sub	 ecx, 1
  001d6	51		 push	 ecx
  001d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001dc	e8 00 00 00 00	 call	 ?GetRemainTime@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetRemainTime
  001e1	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al
$LN17@GCReqDevil:

; 18980: 			}

  001e4	eb 18		 jmp	 SHORT $LN13@GCReqDevil
$LN14@GCReqDevil:

; 18981: 			else {
; 18982: 				pResult.RemainTime = g_BloodCastle.GetRemainTime(lpMsg->btItemLevel-1);

  001e6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001e9	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  001ed	83 e9 01	 sub	 ecx, 1
  001f0	51		 push	 ecx
  001f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001f6	e8 00 00 00 00	 call	 ?GetRemainTime@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetRemainTime
  001fb	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al
$LN13@GCReqDevil:

; 18983: 			}
; 18984: #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 18985: 		}
; 18986: #endif		
; 18987: 		break;

  001fe	e9 64 01 00 00	 jmp	 $LN2@GCReqDevil
$LN18@GCReqDevil:

; 18988: #ifdef CHAOSCASTLE_SYSTEM_20040408		//     
; 18989: 	case 4 :	//  
; 18990: 		{
; 18991: #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 18992: 		//     .
; 18993: 		if( gObj[aIndex].m_PK_Level >= PK_LEVEL_DEFAULT + 1 )

  00203	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0020a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00210	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00218	83 fa 04	 cmp	 edx, 4
  0021b	7c 64		 jl	 SHORT $LN19@GCReqDevil

; 18994: 		{	
; 18995: 			GCServerCmd( aIndex, MSGBOX_ENTERLIMIT_PKUSER_CHAOSCASTLE, 0, 0 );

  0021d	6a 00		 push	 0
  0021f	6a 00		 push	 0
  00221	6a 39		 push	 57			; 00000039H
  00223	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd
  0022c	83 c4 10	 add	 esp, 16			; 00000010H

; 18996: 			LogAddTD( "[PK User][ChaosCastle] [%s][%s] Move Fail [PK Level:%d]", 

  0022f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023c	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00244	52		 push	 edx
  00245	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0024c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00252	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00256	52		 push	 edx
  00257	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0025e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00264	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00268	52		 push	 edx
  00269	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@OGLBFJCJ@?$FLPK?5User?$FN?$FLChaosCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00274	83 c4 10	 add	 esp, 16			; 00000010H

; 18997: 			   gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level );
; 18998: 			return;

  00277	e9 00 01 00 00	 jmp	 $LN1@GCReqDevil

; 18999: 		}			

  0027c	e9 e6 00 00 00	 jmp	 $LN2@GCReqDevil
$LN19@GCReqDevil:

; 19000: 		else
; 19001: 		{
; 19002: #endif			
; 19003: 			// 1 .      .
; 19004: 			INT iENTER_LEVEL = g_ChaosCastle.GetUserLevelToEnter(aIndex);

  00281	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00284	50		 push	 eax
  00285	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0028a	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetUserLevelToEnter
  0028f	89 45 f4	 mov	 DWORD PTR _iENTER_LEVEL$3[ebp], eax

; 19005: 			if (iENTER_LEVEL == -1) {

  00292	83 7d f4 ff	 cmp	 DWORD PTR _iENTER_LEVEL$3[ebp], -1
  00296	75 0a		 jne	 SHORT $LN21@GCReqDevil

; 19006: 				return;

  00298	e9 df 00 00 00	 jmp	 $LN1@GCReqDevil

; 19007: 			}

  0029d	e9 c5 00 00 00	 jmp	 $LN2@GCReqDevil
$LN21@GCReqDevil:

; 19008: 			else {
; 19009: 				pResult.hEventType = 4;

  002a2	c6 45 fb 04	 mov	 BYTE PTR _pResult$[ebp+3], 4

; 19010: 				if ( g_ChaosCastle.GetCurrentState(iENTER_LEVEL) == CHAOSCASTLE_STATE_CLOSED) {	//        ??

  002a6	8b 45 f4	 mov	 eax, DWORD PTR _iENTER_LEVEL$3[ebp]
  002a9	50		 push	 eax
  002aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  002af	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  002b4	83 f8 01	 cmp	 eax, 1
  002b7	75 70		 jne	 SHORT $LN23@GCReqDevil

; 19011: #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 19012: 					if (g_ChaosCastle.CheckCanEnter( aIndex, iENTER_LEVEL)) {
; 19013: #else
; 19014: 					if (g_ChaosCastle.CheckCanEnter(iENTER_LEVEL)) {

  002b9	8b 45 f4	 mov	 eax, DWORD PTR _iENTER_LEVEL$3[ebp]
  002bc	50		 push	 eax
  002bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  002c2	e8 00 00 00 00	 call	 ?CheckCanEnter@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanEnter
  002c7	0f b6 c8	 movzx	 ecx, al
  002ca	85 c9		 test	 ecx, ecx
  002cc	74 1b		 je	 SHORT $LN25@GCReqDevil

; 19015: #endif
; 19016: 						
; 19017: #ifdef CHAOSCASTLE_TIME_BUGFIX_20040508
; 19018: 						pResult.RemainTime		= 0x00;

  002ce	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 19019: 						
; 19020: 						//##BUGFIX MODIFY_OPENTIME_CHAOS_CASTLE_20041129
; 19021: 						pResult.RemainTime_LOW	= 0x00;

  002d2	c6 45 fe 00	 mov	 BYTE PTR _pResult$[ebp+6], 0

; 19022: #else
; 19023: 						pResult.RemainTime		= 0x00;
; 19024: #endif
; 19025: 						pResult.EnteredUser		= g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  002d6	8b 45 f4	 mov	 eax, DWORD PTR _iENTER_LEVEL$3[ebp]
  002d9	50		 push	 eax
  002da	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  002df	e8 00 00 00 00	 call	 ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurEnteredUser
  002e4	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al

; 19026: 					}

  002e7	eb 3e		 jmp	 SHORT $LN26@GCReqDevil
$LN25@GCReqDevil:

; 19027: 					else {
; 19028: #ifdef CHAOSCASTLE_TIME_BUGFIX_20040508
; 19029: 	#ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 19030: 						WORD wREMAIN_TIME		= (WORD) g_ChaosCastle.GetRemainTime( aIndex, iENTER_LEVEL );
; 19031: 	#else
; 19032: 						WORD wREMAIN_TIME		= (WORD) g_ChaosCastle.GetRemainTime(iENTER_LEVEL);

  002e9	8b 45 f4	 mov	 eax, DWORD PTR _iENTER_LEVEL$3[ebp]
  002ec	50		 push	 eax
  002ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  002f2	e8 00 00 00 00	 call	 ?GetRemainTime@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetRemainTime
  002f7	66 89 45 f0	 mov	 WORD PTR _wREMAIN_TIME$2[ebp], ax

; 19033: 	#endif	// #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307						
; 19034: 						pResult.RemainTime		= HIBYTE((WORD) wREMAIN_TIME);

  002fb	0f b7 45 f0	 movzx	 eax, WORD PTR _wREMAIN_TIME$2[ebp]
  002ff	c1 e8 08	 shr	 eax, 8
  00302	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00307	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al

; 19035: 						pResult.RemainTime_LOW	= LOBYTE((WORD) wREMAIN_TIME);

  0030a	0f b7 45 f0	 movzx	 eax, WORD PTR _wREMAIN_TIME$2[ebp]
  0030e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00313	88 45 fe	 mov	 BYTE PTR _pResult$[ebp+6], al

; 19036: #else
; 19037: 	#ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307						
; 19038: 						pResult.RemainTime		= (WORD) g_ChaosCastle.GetRemainTime( aIndex, iENTER_LEVEL );
; 19039: 	#else
; 19040: 						pResult.RemainTime		= (WORD) g_ChaosCastle.GetRemainTime(iENTER_LEVEL);
; 19041: 	#endif	// #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307				
; 19042: #endif
; 19043: 						pResult.EnteredUser		= g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  00316	8b 45 f4	 mov	 eax, DWORD PTR _iENTER_LEVEL$3[ebp]
  00319	50		 push	 eax
  0031a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0031f	e8 00 00 00 00	 call	 ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurEnteredUser
  00324	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al
$LN26@GCReqDevil:

; 19044: 					}
; 19045: 				}

  00327	eb 3e		 jmp	 SHORT $LN2@GCReqDevil
$LN23@GCReqDevil:

; 19046: 				else {
; 19047: #ifdef CHAOSCASTLE_TIME_BUGFIX_20040508
; 19048: 	#ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 19049: 					WORD wREMAIN_TIME		= (WORD) g_ChaosCastle.GetRemainTime( aIndex, iENTER_LEVEL);
; 19050: 	#else
; 19051: 					WORD wREMAIN_TIME		= (WORD) g_ChaosCastle.GetRemainTime(iENTER_LEVEL);

  00329	8b 45 f4	 mov	 eax, DWORD PTR _iENTER_LEVEL$3[ebp]
  0032c	50		 push	 eax
  0032d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00332	e8 00 00 00 00	 call	 ?GetRemainTime@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetRemainTime
  00337	66 89 45 ec	 mov	 WORD PTR _wREMAIN_TIME$1[ebp], ax

; 19052: 	#endif	// #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 19053: 					pResult.RemainTime		= HIBYTE((WORD) wREMAIN_TIME);

  0033b	0f b7 45 ec	 movzx	 eax, WORD PTR _wREMAIN_TIME$1[ebp]
  0033f	c1 e8 08	 shr	 eax, 8
  00342	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00347	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al

; 19054: 					pResult.RemainTime_LOW	= LOBYTE((WORD) wREMAIN_TIME);

  0034a	0f b7 45 ec	 movzx	 eax, WORD PTR _wREMAIN_TIME$1[ebp]
  0034e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00353	88 45 fe	 mov	 BYTE PTR _pResult$[ebp+6], al

; 19055: #else
; 19056: 	#ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 19057: 					pResult.RemainTime		= (WORD) g_ChaosCastle.GetRemainTime( aIndex, iENTER_LEVEL );
; 19058: 	#else
; 19059: 					pResult.RemainTime		= (WORD) g_ChaosCastle.GetRemainTime(iENTER_LEVEL);
; 19060: 	#endif	// #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307		
; 19061: #endif
; 19062: 					pResult.EnteredUser		= g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  00356	8b 45 f4	 mov	 eax, DWORD PTR _iENTER_LEVEL$3[ebp]
  00359	50		 push	 eax
  0035a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0035f	e8 00 00 00 00	 call	 ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurEnteredUser
  00364	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al
$LN2@GCReqDevil:

; 19063: 				}
; 19064: 			}
; 19065: #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 19066: 		}
; 19067: #endif				
; 19068: 		}
; 19069: 		break;
; 19070: #endif
; 19071: 
; 19072: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//   
; 19073: 	case 5:	//  
; 19074: 		{
; 19075: 			pResult.hEventType	= 5;
; 19076: 			pResult.RemainTime	= g_IllusionTempleEvent.GetRemainTime();
; 19077: 			pResult.EnteredUser	= 0;
; 19078: 			pResult.RemainTime_LOW	= 0;
; 19079: 		}
; 19080: 		break;	
; 19081: #endif
; 19082: 	}
; 19083: 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	

  00367	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0036b	50		 push	 eax
  0036c	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0036f	51		 push	 ecx
  00370	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00373	52		 push	 edx
  00374	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00379	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCReqDevil:

; 19084: 
; 19085: #else
; 19086: 	
; 19087: 	if( g_DevilSquare.GetState() == DevilSquare_CLOSE )
; 19088: 	{	// ,   
; 19089: 		pResult.RemainTime = g_DevilSquare.GetRemainTime();
; 19090: 	}
; 19091: 	else if( g_DevilSquare.GetState() == DevilSquare_OPEN )
; 19092: 	{
; 19093: 		pResult.RemainTime = 0x0;
; 19094: 	}
; 19095: 	else
; 19096: 	{
; 19097: 		pResult.RemainTime = g_DevilSquare.GetRemainTime()+g_DevilSquare.m_iCloseTime;
; 19098: 	}
; 19099: 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	
; 19100: #endif
; 19101: }

  0037c	5f		 pop	 edi
  0037d	5e		 pop	 esi
  0037e	5b		 pop	 ebx
  0037f	8b e5		 mov	 esp, ebp
  00381	5d		 pop	 ebp
  00382	c3		 ret	 0
?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ENDP ; GCReqDevilSquareRemainTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCServerCmd@@YAXHEEE@Z
_TEXT	SEGMENT
_ServerCmd$ = -8					; size = 7
_aIndex$ = 8						; size = 4
_type$ = 12						; size = 1
_Cmd1$ = 16						; size = 1
_Cmd2$ = 20						; size = 1
?GCServerCmd@@YAXHEEE@Z PROC				; GCServerCmd, COMDAT

; 18563: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18564: 	PMSG_SERVERCMD	ServerCmd;
; 18565: 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  00009	6a 07		 push	 7
  0000b	6a 40		 push	 64			; 00000040H
  0000d	68 f3 00 00 00	 push	 243			; 000000f3H
  00012	8d 45 f8	 lea	 eax, DWORD PTR _ServerCmd$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 18566: 
; 18567: 	ServerCmd.CmdType = type;

  0001e	8a 45 0c	 mov	 al, BYTE PTR _type$[ebp]
  00021	88 45 fc	 mov	 BYTE PTR _ServerCmd$[ebp+4], al

; 18568: 	ServerCmd.X = Cmd1;

  00024	8a 45 10	 mov	 al, BYTE PTR _Cmd1$[ebp]
  00027	88 45 fd	 mov	 BYTE PTR _ServerCmd$[ebp+5], al

; 18569: 	ServerCmd.Y = Cmd2;

  0002a	8a 45 14	 mov	 al, BYTE PTR _Cmd2$[ebp]
  0002d	88 45 fe	 mov	 BYTE PTR _ServerCmd$[ebp+6], al

; 18570: 
; 18571: 	DataSend(aIndex, (LPBYTE)&ServerCmd, ServerCmd.h.size);

  00030	0f b6 45 f9	 movzx	 eax, BYTE PTR _ServerCmd$[ebp+1]
  00034	50		 push	 eax
  00035	8d 4d f8	 lea	 ecx, DWORD PTR _ServerCmd$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18572: }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?GCServerCmd@@YAXHEEE@Z ENDP				; GCServerCmd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCUserChaosBoxSend@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_n$1 = -1044						; size = 4
_lOfs$ = -1040						; size = 4
_SendByte$ = -1036					; size = 1024
_pMsg$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iChaosBoxType$ = 12					; size = 4
?GCUserChaosBoxSend@@YAXPAVOBJECTSTRUCT@@H@Z PROC	; GCUserChaosBoxSend, COMDAT

; 13394: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 13395: 	PMSG_SHOPITEMCOUNT	pMsg;
; 13396: #ifdef ITEM_INDEX_EXTEND_20050706
; 13397: 	BYTE				SendByte[2048];
; 13398: #else
; 13399: 	BYTE				SendByte[1024];
; 13400: #endif
; 13401: 		
; 13402: #ifdef DARKLORD_WORK
; 13403: 	if( iChaosBoxType == 1 )

  00016	83 7d 0c 01	 cmp	 DWORD PTR _iChaosBoxType$[ebp], 1
  0001a	75 51		 jne	 SHORT $LN5@GCUserChao

; 13404: 	{
; 13405: 		if( lpObj->m_IfState.type != I_DARK_TRAINER )

  0001c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001f	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00025	c0 e9 04	 shr	 cl, 4
  00028	80 e1 0f	 and	 cl, 15			; 0000000fH
  0002b	0f b6 d1	 movzx	 edx, cl
  0002e	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  00031	74 05		 je	 SHORT $LN7@GCUserChao

; 13406: 		{
; 13407: 			return;

  00033	e9 c2 01 00 00	 jmp	 $LN1@GCUserChao
$LN7@GCUserChao:

; 13408: 		}		
; 13409: 		if( lpObj->m_IfState.type == I_DARK_TRAINER && lpObj->m_IfState.state == 1 )

  00038	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00041	c0 e9 04	 shr	 cl, 4
  00044	80 e1 0f	 and	 cl, 15			; 0000000fH
  00047	0f b6 d1	 movzx	 edx, cl
  0004a	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  0004d	75 1c		 jne	 SHORT $LN8@GCUserChao
  0004f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00052	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00058	c0 e9 02	 shr	 cl, 2
  0005b	80 e1 03	 and	 cl, 3
  0005e	0f b6 d1	 movzx	 edx, cl
  00061	83 fa 01	 cmp	 edx, 1
  00064	75 05		 jne	 SHORT $LN8@GCUserChao

; 13410: 		{
; 13411: 			return;

  00066	e9 8f 01 00 00	 jmp	 $LN1@GCUserChao
$LN8@GCUserChao:

; 13412: 		}
; 13413: 	}else	

  0006b	eb 4f		 jmp	 SHORT $LN6@GCUserChao
$LN5@GCUserChao:

; 13414: #endif
; 13415: 	{
; 13416: 		if( lpObj->m_IfState.type != I_CHAOSBOX )

  0006d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00070	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00076	c0 e9 04	 shr	 cl, 4
  00079	80 e1 0f	 and	 cl, 15			; 0000000fH
  0007c	0f b6 d1	 movzx	 edx, cl
  0007f	83 fa 07	 cmp	 edx, 7
  00082	74 05		 je	 SHORT $LN9@GCUserChao

; 13417: 		{
; 13418: 			return;

  00084	e9 71 01 00 00	 jmp	 $LN1@GCUserChao
$LN9@GCUserChao:

; 13419: 		}		
; 13420: 		if( lpObj->m_IfState.type == I_CHAOSBOX && lpObj->m_IfState.state == 1 )

  00089	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00092	c0 e9 04	 shr	 cl, 4
  00095	80 e1 0f	 and	 cl, 15			; 0000000fH
  00098	0f b6 d1	 movzx	 edx, cl
  0009b	83 fa 07	 cmp	 edx, 7
  0009e	75 1c		 jne	 SHORT $LN6@GCUserChao
  000a0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a3	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000a9	c0 e9 02	 shr	 cl, 2
  000ac	80 e1 03	 and	 cl, 3
  000af	0f b6 d1	 movzx	 edx, cl
  000b2	83 fa 01	 cmp	 edx, 1
  000b5	75 05		 jne	 SHORT $LN6@GCUserChao

; 13421: 		{
; 13422: 			return;

  000b7	e9 3e 01 00 00	 jmp	 $LN1@GCUserChao
$LN6@GCUserChao:

; 13423: 		}
; 13424: 	}
; 13425: 	int lOfs = sizeof( pMsg );

  000bc	c7 85 f0 fb ff
	ff 06 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 6

; 13426: 	
; 13427: 	PHeadSetW((LPBYTE)&pMsg, 0x31, 0);

  000c6	6a 00		 push	 0
  000c8	6a 31		 push	 49			; 00000031H
  000ca	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13428: 
; 13429: 	pMsg.count			= 0;

  000d6	c6 45 f9 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0

; 13430: 
; 13431: 
; 13432: #ifdef DARKLORD_WORK
; 13433: 	if( iChaosBoxType == 1 )

  000da	83 7d 0c 01	 cmp	 DWORD PTR _iChaosBoxType$[ebp], 1
  000de	75 06		 jne	 SHORT $LN11@GCUserChao

; 13434: 	{	//  
; 13435: 		pMsg.Type			= ITEMMOVE_DARK_TRAINER;

  000e0	c6 45 f8 05	 mov	 BYTE PTR _pMsg$[ebp+4], 5

; 13436: 	}

  000e4	eb 04		 jmp	 SHORT $LN12@GCUserChao
$LN11@GCUserChao:

; 13437: 	else
; 13438: #endif
; 13439: 		pMsg.Type			= ITEMMOVE_CHAOSBOX;

  000e6	c6 45 f8 03	 mov	 BYTE PTR _pMsg$[ebp+4], 3
$LN12@GCUserChao:

; 13440: 
; 13441: 	for( int n=0; n<MAX_CHAOSBOXITEMS; n++)

  000ea	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1[ebp], 0
  000f4	eb 0f		 jmp	 SHORT $LN4@GCUserChao
$LN2@GCUserChao:
  000f6	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  000fc	83 c0 01	 add	 eax, 1
  000ff	89 85 ec fb ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@GCUserChao:
  00105	83 bd ec fb ff
	ff 20		 cmp	 DWORD PTR _n$1[ebp], 32	; 00000020H
  0010c	0f 8d 98 00 00
	00		 jge	 $LN3@GCUserChao

; 13442: 	{
; 13443: 		if( lpObj->pChaosBox[n].IsItem() == TRUE )

  00112	69 8d ec fb ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0011c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011f	03 88 ac 0c 00
	00		 add	 ecx, DWORD PTR [eax+3244]
  00125	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0012a	83 f8 01	 cmp	 eax, 1
  0012d	75 76		 jne	 SHORT $LN13@GCUserChao

; 13444: 		{
; 13445: 			*(SendByte+lOfs) = n;

  0012f	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00135	8a 8d ec fb ff
	ff		 mov	 cl, BYTE PTR _n$1[ebp]
  0013b	88 8c 05 f4 fb
	ff ff		 mov	 BYTE PTR _SendByte$[ebp+eax], cl

; 13446: 			lOfs += 1;

  00142	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00148	83 c0 01	 add	 eax, 1
  0014b	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 13447: 			ItemByteConvert( (SendByte+lOfs), lpObj->pChaosBox[n]);

  00151	69 85 ec fb ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 168
  0015b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0015e	8b b1 ac 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3244]
  00164	03 f0		 add	 esi, eax
  00166	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0016c	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00171	8b fc		 mov	 edi, esp
  00173	f3 a5		 rep movsd
  00175	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _lOfs$[ebp]
  0017b	8d 84 15 f4 fb
	ff ff		 lea	 eax, DWORD PTR _SendByte$[ebp+edx]
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00188	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 13448: 			lOfs += ITEM_BUFFER_SIZE;

  0018e	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00194	83 c0 05	 add	 eax, 5
  00197	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 13449: 			pMsg.count++;

  0019d	8a 45 f9	 mov	 al, BYTE PTR _pMsg$[ebp+5]
  001a0	04 01		 add	 al, 1
  001a2	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+5], al
$LN13@GCUserChao:

; 13450: 		}
; 13451: 	}

  001a5	e9 4c ff ff ff	 jmp	 $LN2@GCUserChao
$LN3@GCUserChao:

; 13452: 	pMsg.h.sizeH		= HIBYTE(lOfs);

  001aa	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  001b0	c1 e8 08	 shr	 eax, 8
  001b3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001b8	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+1], al

; 13453: 	pMsg.h.sizeL		= LOBYTE(lOfs);

  001bb	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  001c1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001c6	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+2], al

; 13454: 	memcpy(SendByte, &pMsg, sizeof( pMsg ));

  001c9	6a 06		 push	 6
  001cb	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001ce	50		 push	 eax
  001cf	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  001d5	51		 push	 ecx
  001d6	e8 00 00 00 00	 call	 _memcpy
  001db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13455: 	DataSend(lpObj->m_Index, (LPBYTE)SendByte, lOfs);

  001de	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  001e4	50		 push	 eax
  001e5	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  001eb	51		 push	 ecx
  001ec	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001ef	8b 02		 mov	 eax, DWORD PTR [edx]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCUserChao:

; 13456: }

  001fa	5f		 pop	 edi
  001fb	5e		 pop	 esi
  001fc	5b		 pop	 ebx
  001fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00200	33 cd		 xor	 ecx, ebp
  00202	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c3		 ret	 0
?GCUserChaosBoxSend@@YAXPAVOBJECTSTRUCT@@H@Z ENDP	; GCUserChaosBoxSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCSkillKeySend@@YAXHPAEEEEEE@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 19
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_keybuffer$ = 12					; size = 4
_GO$ = 16						; size = 1
_Qk$ = 20						; size = 1
_Wk$ = 24						; size = 1
_Ek$ = 28						; size = 1
_ChatWnd$ = 32						; size = 1
?GCSkillKeySend@@YAXHPAEEEEEE@Z PROC			; GCSkillKeySend, COMDAT

; 4280 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4281 : 	PMSG_SKILLKEY	pMsg;
; 4282 : 
; 4283 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x30, sizeof( pMsg ));

  00013	6a 13		 push	 19			; 00000013H
  00015	6a 30		 push	 48			; 00000030H
  00017	68 f3 00 00 00	 push	 243			; 000000f3H
  0001c	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 4284 : #ifdef UPDATE_SKILLKEY_EXPAND_20080804
; 4285 : 	memcpy(pMsg.SKillKey, keybuffer, 20);
; 4286 : #else	// UPDATE_SKILLKEY_EXPAND_20080804
; 4287 : 	memcpy(pMsg.SKillKey, keybuffer, 10);

  00028	6a 0a		 push	 10			; 0000000aH
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _keybuffer$[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4288 : #endif	// UPDATE_SKILLKEY_EXPAND_20080804
; 4289 : 	pMsg.GameOption = GO;

  0003a	8a 45 10	 mov	 al, BYTE PTR _GO$[ebp]
  0003d	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+14], al

; 4290 : 	pMsg.QkeyDefine = Qk;

  00040	8a 45 14	 mov	 al, BYTE PTR _Qk$[ebp]
  00043	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+15], al

; 4291 : 	pMsg.WkeyDefine = Wk;

  00046	8a 45 18	 mov	 al, BYTE PTR _Wk$[ebp]
  00049	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+16], al

; 4292 : 	pMsg.EkeyDefine = Ek;

  0004c	8a 45 1c	 mov	 al, BYTE PTR _Ek$[ebp]
  0004f	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+17], al

; 4293 : 
; 4294 : #ifdef VER_CHATWINDOW_OPTION
; 4295 : 	pMsg.ChatWindow = ChatWnd;

  00052	8a 45 20	 mov	 al, BYTE PTR _ChatWnd$[ebp]
  00055	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+18], al

; 4296 : #endif
; 4297 : 
; 4298 : #ifdef ADD_SEASON_3_NEW_UI_20071122 
; 4299 : 	pMsg.RkeyDefine = Rk;
; 4300 : #endif
; 4301 : 
; 4302 : #ifdef UPDATE_OPTIONKEY_LEVEL_20080116
; 4303 : 	pMsg.QWERLevel	= QWERLevel;
; 4304 : #endif
; 4305 : 
; 4306 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00058	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0005c	50		 push	 eax
  0005d	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4307 : #ifdef UPDATE_OPTIONKEY_LEVEL_20080116
; 4308 : 	LogAddL("Option Send %d %d %d %d %d %d", GO, Qk, Wk,Ek, Rk, QWERLevel);
; 4309 : #else	// UPDATE_OPTIONKEY_LEVEL_20080116
; 4310 : 	LogAddL("Option Send %d %d %d %d", GO, Qk, Wk,Ek);

  0006d	0f b6 45 1c	 movzx	 eax, BYTE PTR _Ek$[ebp]
  00071	50		 push	 eax
  00072	0f b6 4d 18	 movzx	 ecx, BYTE PTR _Wk$[ebp]
  00076	51		 push	 ecx
  00077	0f b6 55 14	 movzx	 edx, BYTE PTR _Qk$[ebp]
  0007b	52		 push	 edx
  0007c	0f b6 45 10	 movzx	 eax, BYTE PTR _GO$[ebp]
  00080	50		 push	 eax
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LJJFCIF@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  0008c	83 c4 14	 add	 esp, 20			; 00000014H

; 4311 : #endif	// UPDATE_OPTIONKEY_LEVEL_20080116
; 4312 : }

  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5b		 pop	 ebx
  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	33 cd		 xor	 ecx, ebp
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
?GCSkillKeySend@@YAXHPAEEEEEE@Z ENDP			; GCSkillKeySend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGoalSend@@YAXHPADE0E@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 22
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Name1$ = 12						; size = 4
_score1$ = 16						; size = 1
_Name2$ = 20						; size = 4
_score2$ = 24						; size = 1
?GCGoalSend@@YAXHPADE0E@Z PROC				; GCGoalSend, COMDAT

; 4200 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4201 : 	PMSG_GOALSEND pMsg;
; 4202 : 	
; 4203 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x23, sizeof( pMsg) );	

  00013	6a 16		 push	 22			; 00000016H
  00015	6a 23		 push	 35			; 00000023H
  00017	68 f3 00 00 00	 push	 243			; 000000f3H
  0001c	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 4204 : 
; 4205 : 	memcpy(pMsg.RedTeamName, Name1, MAX_GUILDNAMESTRING);

  00028	6a 08		 push	 8
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _Name1$[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4206 : 	pMsg.RedTeamScore   = score1;

  0003a	8a 45 10	 mov	 al, BYTE PTR _score1$[ebp]
  0003d	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 4207 : 	memcpy(pMsg.BlueTeamName, Name2, MAX_GUILDNAMESTRING);

  00040	6a 08		 push	 8
  00042	8b 45 14	 mov	 eax, DWORD PTR _Name2$[ebp]
  00045	50		 push	 eax
  00046	8d 4d f1	 lea	 ecx, DWORD PTR _pMsg$[ebp+13]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _memcpy
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4208 : 	pMsg.BlueTeamScore   = score2;

  00052	8a 45 18	 mov	 al, BYTE PTR _score2$[ebp]
  00055	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+21], al

; 4209 : 
; 4210 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00058	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0005c	50		 push	 eax
  0005d	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4211 : }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?GCGoalSend@@YAXHPADE0E@Z ENDP				; GCGoalSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCTimeViewSend@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_second$ = 12						; size = 4
?GCTimeViewSend@@YAXHH@Z PROC				; GCTimeViewSend, COMDAT

; 4188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4189 : 	PMSG_TIMEVIEW	pMsg;
; 4190 : 	
; 4191 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x22, sizeof( pMsg) );	

  00009	6a 06		 push	 6
  0000b	6a 22		 push	 34			; 00000022H
  0000d	68 f3 00 00 00	 push	 243			; 000000f3H
  00012	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4192 : 	pMsg.Second			= second;

  0001e	66 8b 45 0c	 mov	 ax, WORD PTR _second$[ebp]
  00022	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4193 : 
; 4194 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00026	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0002a	50		 push	 eax
  0002b	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4195 : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?GCTimeViewSend@@YAXHH@Z ENDP				; GCTimeViewSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCRecallMonLife@@YAXHHH@Z
_TEXT	SEGMENT
_per$ = -9						; size = 1
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_maxlife$ = 12						; size = 4
_life$ = 16						; size = 4
?GCRecallMonLife@@YAXHHH@Z PROC				; GCRecallMonLife, COMDAT

; 4107 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4108 : 	if( maxlife <= 0 ) return;

  00009	83 7d 0c 00	 cmp	 DWORD PTR _maxlife$[ebp], 0
  0000d	7f 02		 jg	 SHORT $LN2@GCRecallMo
  0000f	eb 3b		 jmp	 SHORT $LN1@GCRecallMo
$LN2@GCRecallMo:

; 4109 : 
; 4110 : 	PMSG_RECALLMONLIFE	pMsg;
; 4111 : 
; 4112 : 	BYTE per  = (life*100)/maxlife;

  00011	6b 45 10 64	 imul	 eax, DWORD PTR _life$[ebp], 100
  00015	99		 cdq
  00016	f7 7d 0c	 idiv	 DWORD PTR _maxlife$[ebp]
  00019	88 45 f7	 mov	 BYTE PTR _per$[ebp], al

; 4113 : 
; 4114 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x20, sizeof( pMsg) );	

  0001c	6a 05		 push	 5
  0001e	6a 20		 push	 32			; 00000020H
  00020	68 f3 00 00 00	 push	 243			; 000000f3H
  00025	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0002e	83 c4 10	 add	 esp, 16			; 00000010H

; 4115 : 	pMsg.Life			= per;

  00031	8a 45 f7	 mov	 al, BYTE PTR _per$[ebp]
  00034	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 4116 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00037	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0003b	50		 push	 eax
  0003c	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCRecallMo:

; 4117 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?GCRecallMonLife@@YAXHHH@Z ENDP				; GCRecallMonLife
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGWarehouseUseEnd@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 3
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CGWarehouseUseEnd@@YAXH@Z PROC				; CGWarehouseUseEnd, COMDAT

; 13236: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 13237: 	if( gObjIsConnectedGP(aIndex) == FALSE ) 

  00009	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	75 23		 jne	 SHORT $LN2@CGWarehous

; 13238: 	{
; 13239: 		LogAddC(LOGC_RED, "error-L3 [%s][%d]", __FILE__,__LINE__);

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGWarehouseUseEnd@@YAXH@Z@4JA
  0001e	83 c0 03	 add	 eax, 3
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN@
  0002c	6a 02		 push	 2
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 13240: 		return;

  00037	e9 bd 00 00 00	 jmp	 $LN1@CGWarehous
$LN2@CGWarehous:

; 13241: 	}
; 13242: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  0003c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00043	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00049	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 13243: 
; 13244: 	PMSG_DEFAULT	pMsg;
; 13245: 
; 13246: 	PHeadSetB((LPBYTE)&pMsg, 0x82, sizeof( pMsg ));

  0004c	6a 03		 push	 3
  0004e	68 82 00 00 00	 push	 130			; 00000082H
  00053	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13247: 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0005f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00063	50		 push	 eax
  00064	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13248: 	
; 13249: 	gObjItemTextSave(lpObj);

  00074	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAVOBJECTSTRUCT@@@Z ; gObjItemTextSave
  0007d	83 c4 04	 add	 esp, 4

; 13250: 	GDSetWarehouseList(aIndex);

  00080	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?GDSetWarehouseList@@YAXH@Z ; GDSetWarehouseList
  00089	83 c4 04	 add	 esp, 4

; 13251: 	//GJSetCharacterInfo(lpObj, aIndex);
; 13252: 	GDUserItemSave(lpObj);

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?GDUserItemSave@@YAXPAVOBJECTSTRUCT@@@Z ; GDUserItemSave
  00095	83 c4 04	 add	 esp, 4

; 13253: 
; 13254: 	if( lpObj->m_IfState.use && lpObj->m_IfState.type == I_WAREHOUSE )

  00098	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000a1	80 e1 03	 and	 cl, 3
  000a4	0f b6 d1	 movzx	 edx, cl
  000a7	85 d2		 test	 edx, edx
  000a9	74 4e		 je	 SHORT $LN1@CGWarehous
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ae	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000b4	c0 e9 04	 shr	 cl, 4
  000b7	80 e1 0f	 and	 cl, 15			; 0000000fH
  000ba	0f b6 d1	 movzx	 edx, cl
  000bd	83 fa 06	 cmp	 edx, 6
  000c0	75 37		 jne	 SHORT $LN1@CGWarehous

; 13255: 	{
; 13256: 		lpObj->m_IfState.use   = 0;

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c5	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000cb	80 e1 fc	 and	 cl, 252			; 000000fcH
  000ce	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d1	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 13257: 		lpObj->m_IfState.state = 0;

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000da	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000e0	80 e1 f3	 and	 cl, 243			; 000000f3H
  000e3	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e6	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 13258: 		lpObj->WarehouseSave   = FALSE;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ef	c7 80 a8 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3240], 0
$LN1@CGWarehous:

; 13259: 	}
; 13260: }

  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
?CGWarehouseUseEnd@@YAXH@Z ENDP				; CGWarehouseUseEnd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCUserWarehouseSend@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -1044						; size = 4
_lOfs$ = -1040						; size = 4
_SendByte$ = -1036					; size = 1024
_pMsg$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GCUserWarehouseSend@@YAXPAVOBJECTSTRUCT@@@Z PROC	; GCUserWarehouseSend, COMDAT

; 7865 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 04 00
	00		 sub	 esp, 1236		; 000004d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 7866 : 	PMSG_SHOPITEMCOUNT	pMsg;
; 7867 : #ifdef ITEM_INDEX_EXTEND_20050706
; 7868 : 	BYTE				SendByte[2048];
; 7869 : #else
; 7870 : 	BYTE				SendByte[1024];
; 7871 : #endif	
; 7872 : 	
; 7873 : 	if( lpObj->m_IfState.type != I_WAREHOUSE )

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0001f	c0 e9 04	 shr	 cl, 4
  00022	80 e1 0f	 and	 cl, 15			; 0000000fH
  00025	0f b6 d1	 movzx	 edx, cl
  00028	83 fa 06	 cmp	 edx, 6
  0002b	74 05		 je	 SHORT $LN5@GCUserWare

; 7874 : 	{
; 7875 : 		return;

  0002d	e9 c5 01 00 00	 jmp	 $LN1@GCUserWare
$LN5@GCUserWare:

; 7876 : 	}
; 7877 : 		
; 7878 : 	// .. ..
; 7879 : 	if( lpObj->m_IfState.type == I_WAREHOUSE && lpObj->m_IfState.state == 1 )

  00032	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00035	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0003b	c0 e9 04	 shr	 cl, 4
  0003e	80 e1 0f	 and	 cl, 15			; 0000000fH
  00041	0f b6 d1	 movzx	 edx, cl
  00044	83 fa 06	 cmp	 edx, 6
  00047	75 1c		 jne	 SHORT $LN6@GCUserWare
  00049	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004c	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00052	c0 e9 02	 shr	 cl, 2
  00055	80 e1 03	 and	 cl, 3
  00058	0f b6 d1	 movzx	 edx, cl
  0005b	83 fa 01	 cmp	 edx, 1
  0005e	75 05		 jne	 SHORT $LN6@GCUserWare

; 7880 : 	{
; 7881 : 		return;

  00060	e9 92 01 00 00	 jmp	 $LN1@GCUserWare
$LN6@GCUserWare:

; 7882 : 	}
; 7883 : 	int lOfs = sizeof( pMsg );

  00065	c7 85 f0 fb ff
	ff 06 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 6

; 7884 : 		
; 7885 : 	PHeadSetW((LPBYTE)&pMsg, 0x31, 0);

  0006f	6a 00		 push	 0
  00071	6a 31		 push	 49			; 00000031H
  00073	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7886 : 
; 7887 : 	pMsg.count			= 0;

  0007f	c6 45 f9 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0

; 7888 : 	pMsg.Type			= 0;

  00083	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 7889 : 
; 7890 : 	for( int n=0; n<MAX_WAREHOUSEITEMS; n++)

  00087	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1[ebp], 0
  00091	eb 0f		 jmp	 SHORT $LN4@GCUserWare
$LN2@GCUserWare:
  00093	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 85 ec fb ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@GCUserWare:
  000a2	83 bd ec fb ff
	ff 78		 cmp	 DWORD PTR _n$1[ebp], 120 ; 00000078H
  000a9	0f 8d 98 00 00
	00		 jge	 $LN3@GCUserWare

; 7891 : 	{
; 7892 : 		if( lpObj->pWarehouse[n].IsItem() == TRUE )

  000af	69 8d ec fb ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _n$1[ebp], 168
  000b9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bc	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  000c2	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000c7	83 f8 01	 cmp	 eax, 1
  000ca	75 76		 jne	 SHORT $LN7@GCUserWare

; 7893 : 		{
; 7894 : 			*(SendByte+lOfs) = n;

  000cc	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000d2	8a 8d ec fb ff
	ff		 mov	 cl, BYTE PTR _n$1[ebp]
  000d8	88 8c 05 f4 fb
	ff ff		 mov	 BYTE PTR _SendByte$[ebp+eax], cl

; 7895 : 			lOfs += 1;

  000df	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000e5	83 c0 01	 add	 eax, 1
  000e8	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 7896 : 			ItemByteConvert( (SendByte+lOfs), lpObj->pWarehouse[n]);

  000ee	69 85 ec fb ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 168
  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000fb	8b b1 94 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3220]
  00101	03 f0		 add	 esi, eax
  00103	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00109	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0010e	8b fc		 mov	 edi, esp
  00110	f3 a5		 rep movsd
  00112	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _lOfs$[ebp]
  00118	8d 84 15 f4 fb
	ff ff		 lea	 eax, DWORD PTR _SendByte$[ebp+edx]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00125	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 7897 : 
; 7898 : 			lOfs += ITEM_BUFFER_SIZE;

  0012b	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00131	83 c0 05	 add	 eax, 5
  00134	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 7899 : 			pMsg.count++;

  0013a	8a 45 f9	 mov	 al, BYTE PTR _pMsg$[ebp+5]
  0013d	04 01		 add	 al, 1
  0013f	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+5], al
$LN7@GCUserWare:

; 7900 : 		}
; 7901 : 	}

  00142	e9 4c ff ff ff	 jmp	 $LN2@GCUserWare
$LN3@GCUserWare:

; 7902 : 	pMsg.h.sizeH		= HIBYTE(lOfs);

  00147	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0014d	c1 e8 08	 shr	 eax, 8
  00150	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00155	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+1], al

; 7903 : 	pMsg.h.sizeL		= LOBYTE(lOfs);

  00158	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0015e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00163	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+2], al

; 7904 : 	memcpy(SendByte, &pMsg, sizeof( pMsg ));

  00166	6a 06		 push	 6
  00168	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0016b	50		 push	 eax
  0016c	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  00172	51		 push	 ecx
  00173	e8 00 00 00 00	 call	 _memcpy
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7905 : 	DataSend(lpObj->m_Index, (LPBYTE)SendByte, lOfs);

  0017b	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00181	50		 push	 eax
  00182	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  00188	51		 push	 ecx
  00189	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0018c	8b 02		 mov	 eax, DWORD PTR [edx]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7906 : 
; 7907 : 	GCWarehouseInventoryMoneySend( lpObj->m_Index, 0x01, lpObj->Money, lpObj->WarehouseMoney);

  00197	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019a	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  001a0	51		 push	 ecx
  001a1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001a4	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  001aa	50		 push	 eax
  001ab	6a 01		 push	 1
  001ad	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b2	52		 push	 edx
  001b3	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  001b8	83 c4 10	 add	 esp, 16			; 00000010H

; 7908 : 	//LogAdd("%s] %d %d %d", lpObj->Name, lpObj->m_IfState.type, lpObj->m_IfState.state);
; 7909 : 	
; 7910 : 	if( lpObj->m_IfState.type == I_WAREHOUSE )

  001bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001be	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  001c4	c0 e9 04	 shr	 cl, 4
  001c7	80 e1 0f	 and	 cl, 15			; 0000000fH
  001ca	0f b6 d1	 movzx	 edx, cl
  001cd	83 fa 06	 cmp	 edx, 6
  001d0	75 25		 jne	 SHORT $LN1@GCUserWare

; 7911 : 	{
; 7912 : 		lpObj->m_IfState.state	= 1;

  001d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d5	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  001db	80 e1 f3	 and	 cl, 243			; 000000f3H
  001de	80 c9 04	 or	 cl, 4
  001e1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001e4	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 7913 : 		lpObj->WarehouseSave	= TRUE;

  001ea	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ed	c7 80 a8 0c 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3240], 1
$LN1@GCUserWare:

; 7914 : 	}
; 7915 : }

  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	5b		 pop	 ebx
  001fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fd	33 cd		 xor	 ecx, ebp
  001ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00204	8b e5		 mov	 esp, ebp
  00206	5d		 pop	 ebp
  00207	c3		 ret	 0
?GCUserWarehouseSend@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; GCUserWarehouseSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCJoinBillCheckSend@@YAXPADH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_AccountId$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCJoinBillCheckSend@@YAXPADH@Z PROC			; GCJoinBillCheckSend, COMDAT

; 3252 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3253 : 	SDHP_BILLSEARCH	pMsg;
; 3254 : 	
; 3255 : 	PHeadSetB((LPBYTE)&pMsg, 0x06, sizeof( pMsg ));

  00013	6a 10		 push	 16			; 00000010H
  00015	6a 06		 push	 6
  00017	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3256 : 
; 3257 : 	memcpy(pMsg.Id, AccountId, MAX_IDSTRING);

  00023	6a 0a		 push	 10			; 0000000aH
  00025	8b 45 08	 mov	 eax, DWORD PTR _AccountId$[ebp]
  00028	50		 push	 eax
  00029	8d 4d ef	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _memcpy
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3258 : 	pMsg.Number = aIndex;

  00035	66 8b 45 0c	 mov	 ax, WORD PTR _aIndex$[ebp]
  00039	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 3259 : 
; 3260 : 	wsJServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  0003d	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00041	50		 push	 eax
  00042	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00045	51		 push	 ecx
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  0004b	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 3261 : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?GCJoinBillCheckSend@@YAXPADH@Z ENDP			; GCJoinBillCheckSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCJoinSocketResult@@YAXEI@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 5
_result$ = 8						; size = 1
_Socket$ = 12						; size = 4
?GCJoinSocketResult@@YAXEI@Z PROC			; GCJoinSocketResult, COMDAT

; 3279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3280 : 	PMSG_RESULT			pResult;
; 3281 : 		
; 3282 : 	PHeadSubSetB((LPBYTE)&pResult, 0xF1, 0x01, sizeof( pResult ) );

  00009	6a 05		 push	 5
  0000b	6a 01		 push	 1
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3283 : 
; 3284 : 	pResult.result	   = result;

  0001e	8a 45 08	 mov	 al, BYTE PTR _result$[ebp]
  00021	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al

; 3285 : 	wsGServer.DataSocketSend(Socket, (char*)&pResult, pResult.h.size);

  00024	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 0c	 mov	 edx, DWORD PTR _Socket$[ebp]
  00030	52		 push	 edx
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsGServer@@3VCwsGameServer@@A ; wsGServer
  00036	e8 00 00 00 00	 call	 ?DataSocketSend@CwsGameServer@@QAEHIPADH@Z ; CwsGameServer::DataSocketSend

; 3286 : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?GCJoinSocketResult@@YAXEI@Z ENDP			; GCJoinSocketResult
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCJoinResult@@YAXEH@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 5
_result$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?GCJoinResult@@YAXEH@Z PROC				; GCJoinResult, COMDAT

; 3267 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3268 : 	PMSG_RESULT			pResult;
; 3269 : 		
; 3270 : 	PHeadSubSetB((LPBYTE)&pResult, 0xF1, 0x01, sizeof( pResult ) );

  00009	6a 05		 push	 5
  0000b	6a 01		 push	 1
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3271 : 	pResult.result	   = result;

  0001e	8a 45 08	 mov	 al, BYTE PTR _result$[ebp]
  00021	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al

; 3272 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00024	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3273 : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?GCJoinResult@@YAXEH@Z ENDP				; GCJoinResult
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCInventoryItemDeleteSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_flag$ = 16						; size = 1
?GCInventoryItemDeleteSend@@YAXHEE@Z PROC		; GCInventoryItemDeleteSend, COMDAT

; 18490: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18491: 	PMSG_INVENTORYDELETE	pMsg;
; 18492: 	
; 18493: 	PHeadSetB((LPBYTE)&pMsg, 0x28, sizeof( pMsg ));

  00009	6a 05		 push	 5
  0000b	6a 28		 push	 40			; 00000028H
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18494: 	pMsg.IPos       = pos;

  00019	8a 45 0c	 mov	 al, BYTE PTR _pos$[ebp]
  0001c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 18495: 	pMsg.Flag		= flag;

  0001f	8a 45 10	 mov	 al, BYTE PTR _flag$[ebp]
  00022	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 18496: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00025	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00029	50		 push	 eax
  0002a	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18497: }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?GCInventoryItemDeleteSend@@YAXHEE@Z ENDP		; GCInventoryItemDeleteSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCItemDurSend2@@YAXHEEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_dur$ = 16						; size = 1
_flag$ = 20						; size = 1
?GCItemDurSend2@@YAXHEEE@Z PROC				; GCItemDurSend2, COMDAT

; 18532: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18533: #ifdef DURABILITY_DOWN_CHANGE	//    ( , )
; 18534: 	if( dur > 5 && (dur%5 != 0) )
; 18535: 	{	// 5   
; 18536: 		return;
; 18537: 	}
; 18538: #endif
; 18539: 	PMSG_ITEMDUR	pMsg;
; 18540: 	
; 18541: 	PHeadSetB((LPBYTE)&pMsg, 0x2A, sizeof( pMsg ));

  00009	6a 06		 push	 6
  0000b	6a 2a		 push	 42			; 0000002aH
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18542: 	pMsg.IPos       = pos;

  00019	8a 45 0c	 mov	 al, BYTE PTR _pos$[ebp]
  0001c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 18543: 	pMsg.Dur		= dur;

  0001f	8a 45 10	 mov	 al, BYTE PTR _dur$[ebp]
  00022	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 18544: 	pMsg.Flag		= flag;

  00025	8a 45 14	 mov	 al, BYTE PTR _flag$[ebp]
  00028	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 18545: 
; 18546: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0002b	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18547: }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?GCItemDurSend2@@YAXHEEE@Z ENDP				; GCItemDurSend2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCItemDurSend@@YAXHEEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_dur$ = 16						; size = 1
_flag$ = 20						; size = 1
?GCItemDurSend@@YAXHEEE@Z PROC				; GCItemDurSend, COMDAT

; 18518: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18519: 	PMSG_ITEMDUR	pMsg;
; 18520: 	
; 18521: 	PHeadSetB((LPBYTE)&pMsg, 0x2A, sizeof( pMsg ));

  00009	6a 06		 push	 6
  0000b	6a 2a		 push	 42			; 0000002aH
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18522: 	pMsg.IPos       = pos;

  00019	8a 45 0c	 mov	 al, BYTE PTR _pos$[ebp]
  0001c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 18523: 	pMsg.Dur		= dur;

  0001f	8a 45 10	 mov	 al, BYTE PTR _dur$[ebp]
  00022	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 18524: 	pMsg.Flag		= flag;

  00025	8a 45 14	 mov	 al, BYTE PTR _flag$[ebp]
  00028	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 18525: 
; 18526: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0002b	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0002f	50		 push	 eax
  00030	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18527: }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?GCItemDurSend@@YAXHEEE@Z ENDP				; GCItemDurSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCItemUseSpecialTimeSend@@YAXHEH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_number$ = 12						; size = 1
_time$ = 16						; size = 4
?GCItemUseSpecialTimeSend@@YAXHEH@Z PROC		; GCItemUseSpecialTimeSend, COMDAT

; 18503: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18504: 	PMSG_ITEMUSESPECIALTIME	pMsg;
; 18505: 
; 18506: 	if( time > 65535 ) time = 65535;

  00009	81 7d 10 ff ff
	00 00		 cmp	 DWORD PTR _time$[ebp], 65535 ; 0000ffffH
  00010	7e 07		 jle	 SHORT $LN2@GCItemUseS
  00012	c7 45 10 ff ff
	00 00		 mov	 DWORD PTR _time$[ebp], 65535 ; 0000ffffH
$LN2@GCItemUseS:

; 18507: 
; 18508: 	PHeadSetBE((LPBYTE)&pMsg, 0x29, sizeof( pMsg ));

  00019	6a 06		 push	 6
  0001b	6a 29		 push	 41			; 00000029H
  0001d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18509: 	pMsg.Number     = number;

  00029	8a 45 0c	 mov	 al, BYTE PTR _number$[ebp]
  0002c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 18510: 	pMsg.Time       = (WORD)time;

  0002f	66 8b 45 10	 mov	 ax, WORD PTR _time$[ebp]
  00033	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 18511: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00037	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0003b	50		 push	 eax
  0003c	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18512: }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?GCItemUseSpecialTimeSend@@YAXHEH@Z ENDP		; GCItemUseSpecialTimeSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCInventoryItemOneSend@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?GCInventoryItemOneSend@@YAXHH@Z PROC			; GCInventoryItemOneSend, COMDAT

; 3884 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3885 : 	PMSG_INVENTORYITEMMODIFY	pMsg;
; 3886 : 
; 3887 : 	if( gObj[aIndex].pInventory[pos].IsItem() == FALSE ) return;

  00013	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001a	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00027	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0002e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00033	85 c0		 test	 eax, eax
  00035	75 02		 jne	 SHORT $LN2@GCInventor
  00037	eb 6b		 jmp	 SHORT $LN1@GCInventor
$LN2@GCInventor:

; 3888 : 
; 3889 : 	
; 3890 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x14, sizeof( pMsg ) );

  00039	6a 0a		 push	 10			; 0000000aH
  0003b	6a 14		 push	 20			; 00000014H
  0003d	68 f3 00 00 00	 push	 243			; 000000f3H
  00042	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0004b	83 c4 10	 add	 esp, 16			; 00000010H

; 3891 : 	pMsg.Pos			= pos;

  0004e	8a 45 0c	 mov	 al, BYTE PTR _pos$[ebp]
  00051	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 3892 : 	ItemByteConvert(pMsg.ItemInfo, gObj[aIndex].pInventory[pos] );

  00054	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005b	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00062	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00068	8b b4 02 5c 0c
	00 00		 mov	 esi, DWORD PTR [edx+eax+3164]
  0006f	03 f1		 add	 esi, ecx
  00071	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00077	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0007c	8b fc		 mov	 edi, esp
  0007e	f3 a5		 rep movsd
  00080	8d 45 f5	 lea	 eax, DWORD PTR _pMsg$[ebp+5]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00089	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 3893 : 		
; 3894 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0008f	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00093	50		 push	 eax
  00094	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCInventor:

; 3895 : }

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000aa	33 cd		 xor	 ecx, ebp
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?GCInventoryItemOneSend@@YAXHH@Z ENDP			; GCInventoryItemOneSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z
_TEXT	SEGMENT
_n$1 = -24						; size = 4
_pnumber$ = -20						; size = 4
_number$ = -16						; size = 4
_count$ = -12						; size = 4
_dbnumber$ = -8						; size = 4
_usernumber$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z PROC	; CGPartyDelUser, COMDAT

; 11426: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 11427: 	int usernumber=-1, dbnumber=-1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _usernumber$[ebp], -1
  00010	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _dbnumber$[ebp], -1

; 11428: 	int count;
; 11429: 	int number, pnumber;
; 11430: 
; 11431: 	//   
; 11432: 	if( gObj[aIndex].PartyNumber < 0 ) 

  00017	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00024	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  0002c	7d 37		 jge	 SHORT $LN5@CGPartyDel

; 11433: 	{
; 11434: 		LogAdd("No Party %s %s", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0002e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003b	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0003f	52		 push	 edx
  00040	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00051	52		 push	 edx
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs@
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11435: 		return;

  00060	e9 fc 01 00 00	 jmp	 $LN1@CGPartyDel
$LN5@CGPartyDel:

; 11436: 	}
; 11437: 
; 11438: 	//   
; 11439: 	if( gParty.GetIndexUser(gObj[aIndex].PartyNumber, lpMsg->Number, usernumber, dbnumber) == FALSE )

  00065	8d 45 f8	 lea	 eax, DWORD PTR _dbnumber$[ebp]
  00068	50		 push	 eax
  00069	8d 4d fc	 lea	 ecx, DWORD PTR _usernumber$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00070	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00074	50		 push	 eax
  00075	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0007c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00082	8b 84 0a 88 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+648]
  00089	50		 push	 eax
  0008a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0008f	e8 00 00 00 00	 call	 ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ; PartyClass::GetIndexUser
  00094	85 c0		 test	 eax, eax
  00096	75 13		 jne	 SHORT $LN6@CGPartyDel

; 11440: 	{
; 11441: 		LogAdd("User Not found");

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAPFACKC@User?5Not?5found@
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000a3	83 c4 04	 add	 esp, 4

; 11442: 		return;

  000a6	e9 b6 01 00 00	 jmp	 $LN1@CGPartyDel
$LN6@CGPartyDel:

; 11443: 	}
; 11444: 	
; 11445: 	//   
; 11446: 	if( usernumber < 0 ) 

  000ab	83 7d fc 00	 cmp	 DWORD PTR _usernumber$[ebp], 0
  000af	7d 13		 jge	 SHORT $LN7@CGPartyDel

; 11447: 	{
; 11448: 		LogAdd("User Not found");

  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAPFACKC@User?5Not?5found@
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000bc	83 c4 04	 add	 esp, 4

; 11449: 		return;

  000bf	e9 9d 01 00 00	 jmp	 $LN1@CGPartyDel
$LN7@CGPartyDel:

; 11450: 	}
; 11451: 
; 11452: #ifdef FOR_BLOODCASTLE
; 11453: /*
; 11454: 	if (CHECK_BLOODCASTLE(gObj[aIndex].MapNumber)) {	
; 11455: 		//       
; 11456: 		if (!g_BloodCastle.CheckCanParty(gObj[aIndex].MapNumber - MAP_INDEX_BLOODCASTLE1)) {
; 11457: 			GCServerMsgStringSend(lMsg.Get(1172), aIndex, 1);		// "       ."
; 11458: 			return;
; 11459: 		}
; 11460: 	}
; 11461: */
; 11462: #endif
; 11463: 
; 11464: 	pnumber = gObj[aIndex].PartyNumber;

  000c4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d1	8b 94 01 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+648]
  000d8	89 55 ec	 mov	 DWORD PTR _pnumber$[ebp], edx

; 11465: 	if( pnumber < 0 ) {

  000db	83 7d ec 00	 cmp	 DWORD PTR _pnumber$[ebp], 0
  000df	7d 21		 jge	 SHORT $LN8@CGPartyDel

; 11466: 		LogAdd("%s %d",__FILE__,__LINE__);

  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z@4JA
  000e6	83 c0 28	 add	 eax, 40			; 00000028H
  000e9	50		 push	 eax
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_05DIALNFFA@?$CFs?5?$CFd@
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11467: 		return;

  000fd	e9 5f 01 00 00	 jmp	 $LN1@CGPartyDel
$LN8@CGPartyDel:

; 11468: 	}
; 11469: 
; 11470: 	count   = gParty.GetCount(pnumber);

  00102	8b 45 ec	 mov	 eax, DWORD PTR _pnumber$[ebp]
  00105	50		 push	 eax
  00106	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0010b	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  00110	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax

; 11471: 	if( count < 1 ) {

  00113	83 7d f4 01	 cmp	 DWORD PTR _count$[ebp], 1
  00117	7d 21		 jge	 SHORT $LN9@CGPartyDel

; 11472: 		LogAdd("%s %d",__FILE__,__LINE__);

  00119	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z@4JA
  0011e	83 c0 2e	 add	 eax, 46			; 0000002eH
  00121	50		 push	 eax
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_05DIALNFFA@?$CFs?5?$CFd@
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11473: 		return;

  00135	e9 27 01 00 00	 jmp	 $LN1@CGPartyDel
$LN9@CGPartyDel:

; 11474: 	}
; 11475: 
; 11476: 	//  2 ..  
; 11477: 	if( lpMsg->Number == 0 || count <= 2 )

  0013a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0013d	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00141	85 c9		 test	 ecx, ecx
  00143	74 0a		 je	 SHORT $LN12@CGPartyDel
  00145	83 7d f4 02	 cmp	 DWORD PTR _count$[ebp], 2
  00149	0f 8f 92 00 00
	00		 jg	 $LN10@CGPartyDel
$LN12@CGPartyDel:

; 11478: 	{
; 11479: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//        
; 11480: 		if(CHECK_ILLUSION_TEMPLE(gObj[usernumber].MapNumber) 
; 11481: 			&& (lpMsg->Number == 0 && count > 2))
; 11482: 		{
; 11483: 			gParty.Delete(pnumber, lpMsg->Number);
; 11484: 			count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 11485: 			gObj[usernumber].PartyNumber = -1;
; 11486: 			gObj[usernumber].PartyTargetUser = -1;
; 11487: 			gParty.UpdatePKPartyPanalty(pnumber);
; 11488: 			gParty.ChangeLeader(pnumber);
; 11489: 			GCPartyDelUserSend(usernumber);
; 11490: 			CGPartyListAll(pnumber);
; 11491: 
; 11492: 			if(count == 0)
; 11493: 			{
; 11494: 				gParty.Destroy(pnumber);
; 11495: 			}
; 11496: 
; 11497: 			return;
; 11498: 		}		
; 11499: #endif
; 11500: 
; 11501: #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_6_200708013	//       
; 11502: 		if(CHECK_ILLUSION_TEMPLE(gObj[usernumber].MapNumber) && count <= 2)
; 11503: 		{
; 11504: 			gParty.Delete(pnumber, lpMsg->Number);
; 11505: 			count = gParty.GetCount(gObj[aIndex].PartyNumber);
; 11506: 			gObj[usernumber].PartyNumber = -1;
; 11507: 			gObj[usernumber].PartyTargetUser = -1;
; 11508: 			gParty.UpdatePKPartyPanalty(pnumber);
; 11509: 		
; 11510: 			if(lpMsg == 0)	// 
; 11511: 			{
; 11512: 				gParty.ChangeLeader(pnumber);
; 11513: 			}
; 11514: 
; 11515: 			GCPartyDelUserSend(usernumber);
; 11516: 			CGPartyListAll(pnumber);
; 11517: 
; 11518: 			return;
; 11519: 		}
; 11520: #endif
; 11521: 
; 11522: 		for( int n=0; n<MAX_PARTYUSER; n++)

  0014f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00156	eb 09		 jmp	 SHORT $LN4@CGPartyDel
$LN2@CGPartyDel:
  00158	8b 45 e8	 mov	 eax, DWORD PTR _n$1[ebp]
  0015b	83 c0 01	 add	 eax, 1
  0015e	89 45 e8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@CGPartyDel:
  00161	83 7d e8 05	 cmp	 DWORD PTR _n$1[ebp], 5
  00165	7d 67		 jge	 SHORT $LN3@CGPartyDel

; 11523: 		{
; 11524: 			number = gParty.m_PartyS[pnumber].Number[n];

  00167	6b 45 ec 30	 imul	 eax, DWORD PTR _pnumber$[ebp], 48
  0016b	8b 4d e8	 mov	 ecx, DWORD PTR _n$1[ebp]
  0016e	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  00175	89 55 f0	 mov	 DWORD PTR _number$[ebp], edx

; 11525: 
; 11526: 			if( number >= 0 )

  00178	83 7d f0 00	 cmp	 DWORD PTR _number$[ebp], 0
  0017c	7c 4e		 jl	 SHORT $LN13@CGPartyDel

; 11527: 			{
; 11528: 				gParty.Delete(pnumber, n);

  0017e	8b 45 e8	 mov	 eax, DWORD PTR _n$1[ebp]
  00181	50		 push	 eax
  00182	8b 4d ec	 mov	 ecx, DWORD PTR _pnumber$[ebp]
  00185	51		 push	 ecx
  00186	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0018b	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 11529: 				gObj[number].PartyNumber = -1;

  00190	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019d	c7 84 01 88 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+648], -1

; 11530: 				gObj[number].PartyTargetUser = -1;

  001a8	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  001af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b5	c7 84 01 8c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+652], -1

; 11531: 				GCPartyDelUserSend(number);

  001c0	8b 45 f0	 mov	 eax, DWORD PTR _number$[ebp]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend
  001c9	83 c4 04	 add	 esp, 4
$LN13@CGPartyDel:

; 11532: 			}
; 11533: 		}

  001cc	eb 8a		 jmp	 SHORT $LN2@CGPartyDel
$LN3@CGPartyDel:

; 11534: 		gParty.Destroy(pnumber);

  001ce	8b 45 ec	 mov	 eax, DWORD PTR _pnumber$[ebp]
  001d1	50		 push	 eax
  001d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001d7	e8 00 00 00 00	 call	 ?Destroy@PartyClass@@QAEHH@Z ; PartyClass::Destroy

; 11535: 	}

  001dc	e9 80 00 00 00	 jmp	 $LN1@CGPartyDel
$LN10@CGPartyDel:

; 11536: 	else 
; 11537: 	{
; 11538: 		gParty.Delete(pnumber, lpMsg->Number);

  001e1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001e4	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  001e8	51		 push	 ecx
  001e9	8b 55 ec	 mov	 edx, DWORD PTR _pnumber$[ebp]
  001ec	52		 push	 edx
  001ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001f2	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 11539: 		count = gParty.GetCount(gObj[aIndex].PartyNumber);

  001f7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00204	8b 94 01 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+648]
  0020b	52		 push	 edx
  0020c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00211	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  00216	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax

; 11540: 		gObj[usernumber].PartyNumber = -1;

  00219	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _usernumber$[ebp], 7072
  00220	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00226	c7 84 01 88 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+648], -1

; 11541: 		gObj[usernumber].PartyTargetUser = -1;

  00231	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _usernumber$[ebp], 7072
  00238	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023e	c7 84 01 8c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+652], -1

; 11542: 
; 11543: #ifdef UPDATE_PK_SYSTEM_20070302		// PK 
; 11544: 		gParty.UpdatePKPartyPanalty(pnumber);
; 11545: #endif
; 11546: 
; 11547: 		GCPartyDelUserSend(usernumber);

  00249	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  0024c	50		 push	 eax
  0024d	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend
  00252	83 c4 04	 add	 esp, 4

; 11548: 		CGPartyListAll(pnumber);

  00255	8b 45 ec	 mov	 eax, DWORD PTR _pnumber$[ebp]
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  0025e	83 c4 04	 add	 esp, 4
$LN1@CGPartyDel:

; 11549: 	}
; 11550: }

  00261	5f		 pop	 edi
  00262	5e		 pop	 esi
  00263	5b		 pop	 ebx
  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	c3		 ret	 0
?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ENDP	; CGPartyDelUser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCEquipmentChange@@YAXHH@Z
_TEXT	SEGMENT
_lpObj$ = -20						; size = 4
_pChange$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?GCEquipmentChange@@YAXHH@Z PROC			; GCEquipmentChange, COMDAT

; 7535 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 7536 : 	PMSG_USEREQUIPMENTCHANGED	pChange;
; 7537 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00013	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00020	89 45 ec	 mov	 DWORD PTR _lpObj$[ebp], eax

; 7538 : 
; 7539 : 	PHeadSetB((LPBYTE)&pChange, 0x25, sizeof( pChange ));

  00023	6a 0a		 push	 10			; 0000000aH
  00025	6a 25		 push	 37			; 00000025H
  00027	8d 45 f0	 lea	 eax, DWORD PTR _pChange$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7540 : 
; 7541 : 	pChange.NumberH    = HIBYTE( aIndex );

  00033	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00036	c1 e8 08	 shr	 eax, 8
  00039	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003e	88 45 f3	 mov	 BYTE PTR _pChange$[ebp+3], al

; 7542 : 	pChange.NumberL	   = LOBYTE( aIndex );

  00041	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00044	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00049	88 45 f4	 mov	 BYTE PTR _pChange$[ebp+4], al

; 7543 : 
; 7544 : 	//pChange.ItemInfo[0]  = (BYTE)lpObj->pInventory[pos].m_Type;
; 7545 : 	ItemByteConvert(pChange.ItemInfo, lpObj->pInventory[pos]);

  0004c	69 45 0c a8 00
	00 00		 imul	 eax, DWORD PTR _pos$[ebp], 168
  00053	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00056	8b b1 5c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3164]
  0005c	03 f0		 add	 esi, eax
  0005e	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00064	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00069	8b fc		 mov	 edi, esp
  0006b	f3 a5		 rep movsd
  0006d	8d 55 f5	 lea	 edx, DWORD PTR _pChange$[ebp+5]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00076	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 7546 : 	pChange.ItemInfo[1]  = pos<<4;

  0007c	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  0007f	c1 e0 04	 shl	 eax, 4
  00082	b9 01 00 00 00	 mov	 ecx, 1
  00087	c1 e1 00	 shl	 ecx, 0
  0008a	88 44 0d f5	 mov	 BYTE PTR _pChange$[ebp+ecx+5], al

; 7547 : 	pChange.ItemInfo[1] |= LevelSmallConvert(aIndex, pos)&0x0F;

  0008e	be 01 00 00 00	 mov	 esi, 1
  00093	c1 e6 00	 shl	 esi, 0
  00096	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00099	50		 push	 eax
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  000a3	83 c4 08	 add	 esp, 8
  000a6	0f b6 d0	 movzx	 edx, al
  000a9	83 e2 0f	 and	 edx, 15			; 0000000fH
  000ac	0f b6 44 35 f5	 movzx	 eax, BYTE PTR _pChange$[ebp+esi+5]
  000b1	0b c2		 or	 eax, edx
  000b3	b9 01 00 00 00	 mov	 ecx, 1
  000b8	c1 e1 00	 shl	 ecx, 0
  000bb	88 44 0d f5	 mov	 BYTE PTR _pChange$[ebp+ecx+5], al

; 7548 : 	//BufferItemtoConvert3(pChange.ItemInfo, lpObj->pInventory[pos].m_Type, , BYTE & op1, BYTE & op2, BYTE & op3, BYTE & dur)
; 7549 : 	MsgSendV2(lpObj, (LPBYTE)&pChange, pChange.h.size);

  000bf	0f b6 45 f1	 movzx	 eax, BYTE PTR _pChange$[ebp+1]
  000c3	50		 push	 eax
  000c4	8d 4d f0	 lea	 ecx, DWORD PTR _pChange$[ebp]
  000c7	51		 push	 ecx
  000c8	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7550 : }

  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	33 cd		 xor	 ecx, ebp
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
?GCEquipmentChange@@YAXHH@Z ENDP			; GCEquipmentChange
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCEquipmentSend@@YAXH@Z
_TEXT	SEGMENT
_lpObj$ = -28						; size = 4
_pMsg$ = -24						; size = 19
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCEquipmentSend@@YAXH@Z PROC				; GCEquipmentSend, COMDAT

; 4079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4080 : 	PMSG_EQUIPMENTLIST	pMsg;
; 4081 : 	
; 4082 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x13, sizeof( pMsg) );	

  00013	6a 13		 push	 19			; 00000013H
  00015	6a 13		 push	 19			; 00000013H
  00017	68 f3 00 00 00	 push	 243			; 000000f3H
  0001c	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 4083 : 
; 4084 : 	pMsg.NumberH = HIBYTE(aIndex);

  00028	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0002b	c1 e8 08	 shr	 eax, 8
  0002e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00033	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 4085 : 	pMsg.NumberL = LOBYTE(aIndex);

  00036	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00039	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003e	88 45 ed	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 4086 : 
; 4087 : 	gObjMakePreviewCharSet(aIndex);

  00041	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  0004a	83 c4 04	 add	 esp, 4

; 4088 : 
; 4089 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  0004d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00054	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005a	89 45 e4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 4090 : 
; 4091 : #ifdef ITEM_INDEX_EXTEND_20050706
; 4092 : 	memcpy(pMsg.Equipment, lpObj->CharSet, MAX_PREVIEWCHARSET+9);
; 4093 : #else
; 4094 : #ifdef DARKLORD_WORK	
; 4095 : 	memcpy(pMsg.Equipment, lpObj->CharSet, MAX_PREVIEWCHARSET+4);

  0005d	6a 0d		 push	 13			; 0000000dH
  0005f	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00062	05 28 03 00 00	 add	 eax, 808		; 00000328H
  00067	50		 push	 eax
  00068	8d 4d ee	 lea	 ecx, DWORD PTR _pMsg$[ebp+6]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 _memcpy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4096 : #else	
; 4097 : 	memcpy(pMsg.Equipment, lpObj->CharSet, MAX_PREVIEWCHARSET+3);
; 4098 : #endif
; 4099 : #endif
; 4100 : 		
; 4101 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00074	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00078	50		 push	 eax
  00079	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007c	51		 push	 ecx
  0007d	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00080	52		 push	 edx
  00081	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4102 : }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008f	33 cd		 xor	 ecx, ebp
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?GCEquipmentSend@@YAXH@Z ENDP				; GCEquipmentSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCMoneySend@@YAXHK@Z
_TEXT	SEGMENT
_loWord$ = -24						; size = 2
_hiWord$ = -20						; size = 2
_pMsg$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?GCMoneySend@@YAXHK@Z PROC				; GCMoneySend, COMDAT

; 4319 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4320 : 	PMSG_ITEMGETRESULT	pMsg;
; 4321 : 	WORD hiWord, loWord;
; 4322 : 
; 4323 : 	pMsg.h.c		= PMHCE_BYTE;

  00013	c6 45 f0 c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H

; 4324 : 	pMsg.h.headcode	= 0x22;

  00017	c6 45 f2 22	 mov	 BYTE PTR _pMsg$[ebp+2], 34 ; 00000022H

; 4325 : 	pMsg.h.size     = sizeof( pMsg );

  0001b	c6 45 f1 09	 mov	 BYTE PTR _pMsg$[ebp+1], 9

; 4326 : 	pMsg.result     = 0xFE;

  0001f	c6 45 f3 fe	 mov	 BYTE PTR _pMsg$[ebp+3], 254 ; 000000feH

; 4327 : 
; 4328 : 	hiWord = HIWORD(money);

  00023	8b 45 0c	 mov	 eax, DWORD PTR _money$[ebp]
  00026	c1 e8 10	 shr	 eax, 16			; 00000010H
  00029	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002e	66 89 45 ec	 mov	 WORD PTR _hiWord$[ebp], ax

; 4329 : 	loWord = LOWORD(money);

  00032	8b 45 0c	 mov	 eax, DWORD PTR _money$[ebp]
  00035	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003a	66 89 45 e8	 mov	 WORD PTR _loWord$[ebp], ax

; 4330 : 
; 4331 : 	pMsg.Data[0] = HIBYTE(hiWord);

  0003e	0f b7 45 ec	 movzx	 eax, WORD PTR _hiWord$[ebp]
  00042	c1 e8 08	 shr	 eax, 8
  00045	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004a	b9 01 00 00 00	 mov	 ecx, 1
  0004f	6b d1 00	 imul	 edx, ecx, 0
  00052	88 44 15 f4	 mov	 BYTE PTR _pMsg$[ebp+edx+4], al

; 4332 : 	pMsg.Data[1] = LOBYTE(hiWord);

  00056	0f b7 45 ec	 movzx	 eax, WORD PTR _hiWord$[ebp]
  0005a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	c1 e1 00	 shl	 ecx, 0
  00067	88 44 0d f4	 mov	 BYTE PTR _pMsg$[ebp+ecx+4], al

; 4333 : 	pMsg.Data[2] = HIBYTE(loWord);

  0006b	0f b7 45 e8	 movzx	 eax, WORD PTR _loWord$[ebp]
  0006f	c1 e8 08	 shr	 eax, 8
  00072	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00077	b9 01 00 00 00	 mov	 ecx, 1
  0007c	d1 e1		 shl	 ecx, 1
  0007e	88 44 0d f4	 mov	 BYTE PTR _pMsg$[ebp+ecx+4], al

; 4334 : 	pMsg.Data[3] = LOBYTE(loWord);

  00082	0f b7 45 e8	 movzx	 eax, WORD PTR _loWord$[ebp]
  00086	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0008b	b9 01 00 00 00	 mov	 ecx, 1
  00090	6b d1 03	 imul	 edx, ecx, 3
  00093	88 44 15 f4	 mov	 BYTE PTR _pMsg$[ebp+edx+4], al

; 4335 : 
; 4336 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00097	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0009b	50		 push	 eax
  0009c	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0009f	51		 push	 ecx
  000a0	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4337 : }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b2	33 cd		 xor	 ecx, ebp
  000b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?GCMoneySend@@YAXHK@Z ENDP				; GCMoneySend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCPkLevelSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_pklevel$ = 12						; size = 1
?GCPkLevelSend@@YAXHE@Z PROC				; GCPkLevelSend, COMDAT

; 3899 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3900 : 	PMSG_PKLEVEL	pMsg;
; 3901 : 		
; 3902 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x08, sizeof( pMsg ) );

  00009	6a 07		 push	 7
  0000b	6a 08		 push	 8
  0000d	68 f3 00 00 00	 push	 243			; 000000f3H
  00012	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3903 : 
; 3904 : 	pMsg.NumberH	= HIBYTE(aIndex);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00021	c1 e8 08	 shr	 eax, 8
  00024	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00029	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 3905 : 	pMsg.NumberL	= LOBYTE(aIndex);

  0002c	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0002f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00034	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 3906 : 	pMsg.PkLevel	= pklevel;

  00037	8a 45 0c	 mov	 al, BYTE PTR _pklevel$[ebp]
  0003a	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 3907 : 	
; 3908 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003d	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00041	50		 push	 eax
  00042	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00045	51		 push	 ecx
  00046	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3909 : 	MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  00052	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00056	50		 push	 eax
  00057	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005a	51		 push	 ecx
  0005b	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00062	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3910 : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?GCPkLevelSend@@YAXHE@Z ENDP				; GCPkLevelSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z
_TEXT	SEGMENT
_pChange$1 = -684					; size = 10
_aAntiLootIndex$2 = -672				; size = 4
_pNotice$3 = -668					; size = 272
_pNotice$4 = -396					; size = 272
_szItemName$5 = -124					; size = 50
_item_number$6 = -72					; size = 4
_SOption$7 = -65					; size = 1
_PetExp$8 = -64						; size = 4
_PetLevel$9 = -60					; size = 4
_s_num$10 = -56						; size = 4
_NOption$11 = -52					; size = 1
_Option3$12 = -51					; size = 1
_Option2$13 = -50					; size = 1
_Option1$14 = -49					; size = 1
_ret$15 = -48						; size = 4
_dur$16 = -44						; size = 4
_level$17 = -40						; size = 4
_type$18 = -36						; size = 4
_map_num$19 = -32					; size = 4
_lpObj$ = -28						; size = 4
_pResult$ = -24						; size = 5
_NewOption$ = -16					; size = 8
_CopyItem$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_drop_type$ = 16					; size = 4
?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z PROC	; CGItemDropRequest, COMDAT

; 5281 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 03 00
	00		 sub	 esp, 812		; 0000032cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 5282 : 	int CopyItem=0;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _CopyItem$[ebp], 0

; 5283 : 	BYTE NewOption[8];
; 5284 : 	
; 5285 : 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return FALSE;

  0001d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00024	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00030	83 c4 04	 add	 esp, 4
  00033	85 c0		 test	 eax, eax
  00035	75 07		 jne	 SHORT $LN2@CGItemDrop
  00037	33 c0		 xor	 eax, eax
  00039	e9 a5 14 00 00	 jmp	 $LN1@CGItemDrop
$LN2@CGItemDrop:

; 5286 : 
; 5287 : 	PMSG_ITEMTHROW_RESULT pResult;
; 5288 : 
; 5289 : 	PHeadSetB((LPBYTE)&pResult, 0x23, sizeof( pResult ));

  0003e	6a 05		 push	 5
  00040	6a 23		 push	 35			; 00000023H
  00042	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5290 : 	pResult.Result		= 0x01;

  0004e	c6 45 eb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 5291 : 	pResult.Ipos		= lpMsg->Ipos;		

  00052	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00055	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  00058	88 4d ec	 mov	 BYTE PTR _pResult$[ebp+4], cl

; 5292 : 
; 5293 : 	if( gObj[aIndex].m_IfState.use )

  0005b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00068	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0006f	80 e2 03	 and	 dl, 3
  00072	0f b6 c2	 movzx	 eax, dl
  00075	85 c0		 test	 eax, eax
  00077	74 2d		 je	 SHORT $LN4@CGItemDrop

; 5294 : 	{
; 5295 : 		if( gObj[aIndex].m_IfState.type != I_SHOP ) 

  00079	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00086	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0008d	c0 ea 04	 shr	 dl, 4
  00090	80 e2 0f	 and	 dl, 15			; 0000000fH
  00093	0f b6 c2	 movzx	 eax, dl
  00096	83 f8 03	 cmp	 eax, 3
  00099	74 0b		 je	 SHORT $LN4@CGItemDrop

; 5296 : 		{
; 5297 : 			pResult.Result = 0x00;

  0009b	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 5298 : 			return FALSE;

  0009f	33 c0		 xor	 eax, eax
  000a1	e9 3d 14 00 00	 jmp	 $LN1@CGItemDrop
$LN4@CGItemDrop:

; 5299 : 		}
; 5300 : 	}
; 5301 : 
; 5302 : 	//  ..
; 5303 : 	if( gObj[aIndex].CloseType != -1 ) 

  000a6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b3	0f be 54 01 0b	 movsx	 edx, BYTE PTR [ecx+eax+11]
  000b8	83 fa ff	 cmp	 edx, -1
  000bb	74 04		 je	 SHORT $LN5@CGItemDrop

; 5304 : 	{
; 5305 : 		pResult.Result = 0x00;		

  000bd	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN5@CGItemDrop:

; 5306 : 	}
; 5307 : 
; 5308 : #ifdef MODIFY_ITEM_DUPLICATION_USING_ITEMDROP_20060518
; 5309 : 	if( gObj[aIndex].m_bMapSvrMoveQuit == true )
; 5310 : 	{
; 5311 : 		//  
; 5312 : 		LogAddTD("[ANTI-HACK][Item Duplication] - Item Drop during MapServer Move [%s][%s]",
; 5313 : 			gObj[aIndex].AccountID, gObj[aIndex].Name );
; 5314 : 		pResult.Result = 0x00;
; 5315 : 	}
; 5316 : #endif
; 5317 : 
; 5318 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719		//    -   
; 5319 : 	if (gObjFixInventoryPointer(aIndex) == false) {

  000c1	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  000ca	83 c4 04	 add	 esp, 4
  000cd	0f b6 c8	 movzx	 ecx, al
  000d0	85 c9		 test	 ecx, ecx
  000d2	75 1c		 jne	 SHORT $LN6@CGItemDrop

; 5320 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  000d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z@4JA
  000d9	83 c0 27	 add	 eax, 39			; 00000027H
  000dc	50		 push	 eax
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CGItemDrop:

; 5321 : 	}
; 5322 : #endif
; 5323 : 
; 5324 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//       .
; 5325 : 	if (gObj[aIndex].pTransaction == 1) {

  000f0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fd	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  00105	83 fa 01	 cmp	 edx, 1
  00108	75 5b		 jne	 SHORT $LN7@CGItemDrop

; 5326 : 		LogAddTD("[%s][%s] CGItemDropRequest() Failed : Transaction == 1, IF_TYPE : %d",

  0010a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00117	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0011e	c0 ea 04	 shr	 dl, 4
  00121	80 e2 0f	 and	 dl, 15			; 0000000fH
  00124	0f b6 c2	 movzx	 eax, dl
  00127	50		 push	 eax
  00128	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0012f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00135	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00139	50		 push	 eax
  0013a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00141	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00147	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0014b	50		 push	 eax
  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fa@
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00157	83 c4 10	 add	 esp, 16			; 00000010H

; 5327 : 			gObj[aIndex].AccountID,
; 5328 : 			gObj[aIndex].Name,
; 5329 : 			gObj[aIndex].m_IfState.type
; 5330 : 			);
; 5331 : 		pResult.Result = 0x00;

  0015a	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 5332 : 		return FALSE;

  0015e	33 c0		 xor	 eax, eax
  00160	e9 7e 13 00 00	 jmp	 $LN1@CGItemDrop
$LN7@CGItemDrop:

; 5333 : 	}
; 5334 : #endif
; 5335 : 	
; 5336 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00165	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0016c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00172	89 45 e4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 5337 : 
; 5338 : 	if( lpMsg->Ipos == 0xFF ) 

  00175	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00178	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0017c	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00182	75 20		 jne	 SHORT $LN8@CGItemDrop

; 5339 : 	{
; 5340 : 		LogAdd("error:%s %d", __FILE__, __LINE__);

  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z@4JA
  00189	83 c0 3b	 add	 eax, 59			; 0000003bH
  0018c	50		 push	 eax
  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd@
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5341 : 		pResult.Result = 0x00;

  001a0	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN8@CGItemDrop:

; 5342 : 	}
; 5343 : 	
; 5344 : 	if( lpMsg->Ipos < 0 || lpMsg->Ipos > MAX_INVENTORY-1 ) 

  001a4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001a7	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  001ab	85 c9		 test	 ecx, ecx
  001ad	7c 0c		 jl	 SHORT $LN10@CGItemDrop
  001af	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001b2	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  001b6	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  001b9	7e 04		 jle	 SHORT $LN9@CGItemDrop
$LN10@CGItemDrop:

; 5345 : 		pResult.Result = 0x00;

  001bb	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN9@CGItemDrop:

; 5346 : 	
; 5347 : 	if( gObjCanItemTouch(lpObj, 0) == FALSE )	//    

  001bf	6a 00		 push	 0
  001c1	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  001ca	83 c4 08	 add	 esp, 8
  001cd	85 c0		 test	 eax, eax
  001cf	75 04		 jne	 SHORT $LN11@CGItemDrop

; 5348 : 	{
; 5349 : 		pResult.Result = 0x00;		

  001d1	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN11@CGItemDrop:

; 5350 : 	}
; 5351 : 
; 5352 : #ifdef NEW_SKILL_FORSKYLAND
; 5353 : 	if( gObj[aIndex].MapNumber == 10 )

  001d5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e2	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001ea	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  001ed	0f 85 8d 00 00
	00		 jne	 $LN18@CGItemDrop

; 5354 : 	{	//   
; 5355 : 		if( lpMsg->Ipos == EQUIPMENT_HELPER  )

  001f3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001f6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  001fa	83 f9 08	 cmp	 ecx, 8
  001fd	75 4b		 jne	 SHORT $LN13@CGItemDrop

; 5356 : 		{
; 5357 : 			if( lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM(13,3) )

  001ff	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00202	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00206	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0020c	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0020f	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00215	0f bf 74 11 06	 movsx	 esi, WORD PTR [ecx+edx+6]
  0021a	6a 03		 push	 3
  0021c	6a 0d		 push	 13			; 0000000dH
  0021e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00223	83 c4 08	 add	 esp, 8
  00226	3b f0		 cmp	 esi, eax
  00228	75 1e		 jne	 SHORT $LN16@CGItemDrop

; 5358 : 			{	//   
; 5359 : 				if( !lpObj->pInventory[EQUIPMENT_WING].IsItem() )

  0022a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0022f	6b c8 07	 imul	 ecx, eax, 7
  00232	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00235	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0023b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00240	85 c0		 test	 eax, eax
  00242	75 04		 jne	 SHORT $LN16@CGItemDrop

; 5360 : 				{	//     
; 5361 : 					pResult.Result = 0x00;		

  00244	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN16@CGItemDrop:

; 5362 : 				}
; 5363 : 			}	
; 5364 : 		}

  00248	eb 36		 jmp	 SHORT $LN18@CGItemDrop
$LN13@CGItemDrop:

; 5365 : 		else if( lpMsg->Ipos == EQUIPMENT_WING )

  0024a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0024d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00251	83 f9 07	 cmp	 ecx, 7
  00254	75 2a		 jne	 SHORT $LN18@CGItemDrop

; 5366 : 		{	//   
; 5367 : 			if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,3) )

  00256	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0025b	c1 e0 03	 shl	 eax, 3
  0025e	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00261	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00267	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0026c	6a 03		 push	 3
  0026e	6a 0d		 push	 13			; 0000000dH
  00270	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00275	83 c4 08	 add	 esp, 8
  00278	3b f0		 cmp	 esi, eax
  0027a	74 04		 je	 SHORT $LN18@CGItemDrop

; 5368 : 			{	//     
; 5369 : 				pResult.Result = 0x00;

  0027c	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN18@CGItemDrop:

; 5370 : 			}
; 5371 : 		}
; 5372 : 	}	
; 5373 : #endif
; 5374 : 	
; 5375 : #ifdef ADD_NON_DROP_VALUABLE_ITEM_20060518
; 5376 : 	if( (lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM(12,30))			// 
; 5377 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM(12,31))		// 
; 5378 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM(13,36))		//  
; 5379 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM(13,37))		//  
; 5380 : 		)
; 5381 : 	{
; 5382 : 		pResult.Result = 0x00;
; 5383 : 	}
; 5384 : #endif
; 5385 : 
; 5386 : #ifdef UPDATE_GM_FUNCTION_20070228	// GM      
; 5387 : 	if( lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM(13, 42) )
; 5388 : 	{
; 5389 : 		pResult.Result = 0x00;
; 5390 : 	}
; 5391 : #endif
; 5392 : 
; 5393 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//        ,   
; 5394 : 	if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) 
; 5395 : 		&&lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM(13, 51) )	//   
; 5396 : 	{
; 5397 : 		pResult.Result = 0x00;
; 5398 : 	}
; 5399 : 
; 5400 : 	if( lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM(14, 64) )		// 
; 5401 : 	{
; 5402 : 		pResult.Result = 0x00;
; 5403 : 	}
; 5404 : #endif
; 5405 : 
; 5406 : #ifdef ADD_THIRD_WING_20070525	// 3  .
; 5407 : 	if( lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEM_WING+36 
; 5408 : 		&& lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEM_WING+40 )	// 3
; 5409 : 	{
; 5410 : #ifdef MODIFY_VALUABLE_ITME_BUGFIX_20070828
; 5411 : 		if (!gPkLimitFree)
; 5412 : #endif		
; 5413 : 		pResult.Result = 0x00;
; 5414 : 	}
; 5415 : #endif
; 5416 : #ifdef ADD_THIRD_WING_20070525	// ,  .
; 5417 : 	if( ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEM_HELPER + 52 )		// 
; 5418 : 		|| ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEM_HELPER + 53 ) )	// 
; 5419 : 	{
; 5420 : 		pResult.Result = 0x00;
; 5421 : 	}
; 5422 : #endif
; 5423 : 
; 5424 : #ifdef UPDATE_VALUABLE_ITEM_20070307	//    
; 5425 : 	if( (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+13 || 
; 5426 : 		lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+14 || 
; 5427 : 		lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+16 ) ||  // , , .
; 5428 : 		(lpObj->pInventory[lpMsg->Ipos].m_Type>=ITEM_WING && 
; 5429 : 		lpObj->pInventory[lpMsg->Ipos].m_Type<=ITEM_WING+6 ) ||		// .
; 5430 : 		(lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_WING+15 )||	//  .
; 5431 : 		((lpObj->pInventory[lpMsg->Ipos].m_Level >= 7 && lpObj->pInventory[lpMsg->Ipos].m_Type < ITEM_WING) //  7 
; 5432 : 		|| (lpObj->pInventory[lpMsg->Ipos].IsSetItem())				// 
; 5433 : 		|| (lpObj->pInventory[lpMsg->Ipos].IsExtItem()) )			// 	
; 5434 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_HELPER+14)	//  
; 5435 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_HELPER+19)	// 
; 5436 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_HELPER+15)	// 
; 5437 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_HELPER+34)	//  
; 5438 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+31)	// 
; 5439 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+41)	// 
; 5440 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+42)	// 
; 5441 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+43)	//  
; 5442 : 		|| (lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+44)	//  		
; 5443 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  1( )  
; 5444 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEM_WING+41	//  1( )
; 5445 : #endif
; 5446 : #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	//       
; 5447 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEM_WING+42	//  2( )
; 5448 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == ITEM_WING+43	//  3( )
; 5449 : #endif		
; 5450 : 		)
; 5451 : 	{
; 5452 : #ifdef MODIFY_VALUABLE_ITME_BUGFIX_20070828
; 5453 : 		if (!gPkLimitFree)
; 5454 : #endif
; 5455 : 		pResult.Result = 0x00;
; 5456 : 	}
; 5457 : #else // UPDATE_VALUABLE_ITEM_20070307
; 5458 : //#if TESTSERVER == 0
; 5459 : 	if( (lpObj->pInventory[lpMsg->Ipos].m_Type>=ITEM_HELPER && 
; 5460 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type<=ITEM_HELPER+3 ) ||	//  , .
; 5461 : 		(lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+13 || 
; 5462 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+14 || 
; 5463 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_POTION+16 ) ||   //  , , .
; 5464 : 		(lpObj->pInventory[lpMsg->Ipos].m_Type>=ITEM_WING && 
; 5465 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type<=ITEM_WING+6 ) || //  .
; 5466 : 		(lpObj->pInventory[lpMsg->Ipos].m_Type==ITEM_WING+15 )|| //   .

  00280	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00283	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00287	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0028d	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00290	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00296	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  0029b	81 fa a0 01 00
	00		 cmp	 edx, 416		; 000001a0H
  002a1	7c 27		 jl	 SHORT $LN21@CGItemDrop
  002a3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002a6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002aa	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  002b0	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b3	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  002b9	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  002be	81 fa a3 01 00
	00		 cmp	 edx, 419		; 000001a3H
  002c4	0f 8e 67 01 00
	00		 jle	 $LN23@CGItemDrop
$LN21@CGItemDrop:
  002ca	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002cd	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002d1	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  002d7	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002da	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  002e0	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  002e5	81 fa cd 01 00
	00		 cmp	 edx, 461		; 000001cdH
  002eb	0f 84 40 01 00
	00		 je	 $LN23@CGItemDrop
  002f1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002f4	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002f8	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  002fe	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00301	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00307	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  0030c	81 fa ce 01 00
	00		 cmp	 edx, 462		; 000001ceH
  00312	0f 84 19 01 00
	00		 je	 $LN23@CGItemDrop
  00318	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0031b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0031f	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00325	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00328	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0032e	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  00333	81 fa d0 01 00
	00		 cmp	 edx, 464		; 000001d0H
  00339	0f 84 f2 00 00
	00		 je	 $LN23@CGItemDrop
  0033f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00342	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00346	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0034c	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034f	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00355	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  0035a	81 fa 80 01 00
	00		 cmp	 edx, 384		; 00000180H
  00360	7c 27		 jl	 SHORT $LN22@CGItemDrop
  00362	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00365	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00369	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0036f	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00372	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00378	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  0037d	81 fa 86 01 00
	00		 cmp	 edx, 390		; 00000186H
  00383	0f 8e a8 00 00
	00		 jle	 $LN23@CGItemDrop
$LN22@CGItemDrop:
  00389	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0038c	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00390	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00396	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00399	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0039f	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  003a4	81 fa 8f 01 00
	00		 cmp	 edx, 399		; 0000018fH
  003aa	0f 84 81 00 00
	00		 je	 $LN23@CGItemDrop
  003b0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003b3	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  003b7	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  003bd	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c0	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  003c6	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  003cb	83 fa 04	 cmp	 edx, 4
  003ce	7e 23		 jle	 SHORT $LN24@CGItemDrop
  003d0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003d3	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  003d7	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  003dd	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e0	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  003e6	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  003eb	81 fa 80 01 00
	00		 cmp	 edx, 384		; 00000180H
  003f1	7c 3e		 jl	 SHORT $LN23@CGItemDrop
$LN24@CGItemDrop:
  003f3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003f6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  003fa	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00400	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00403	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00409	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  0040e	85 c0		 test	 eax, eax
  00410	75 1f		 jne	 SHORT $LN23@CGItemDrop
  00412	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00415	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00419	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  0041f	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00422	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00428	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  0042d	85 c0		 test	 eax, eax
  0042f	74 0d		 je	 SHORT $LN25@CGItemDrop
$LN23@CGItemDrop:

; 5467 : 		((lpObj->pInventory[lpMsg->Ipos].m_Level>4 && lpObj->pInventory[lpMsg->Ipos].m_Type < ITEM_WING) || 		
; 5468 : 		(lpObj->pInventory[lpMsg->Ipos].IsSetItem()) ||
; 5469 : 		 (lpObj->pInventory[lpMsg->Ipos].IsExtItem()) ) ) //   4 .
; 5470 : 		{
; 5471 : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 5472 : 			if (!gPkLimitFree)

  00431	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00438	75 04		 jne	 SHORT $LN25@CGItemDrop

; 5473 : #endif
; 5474 : 			pResult.Result = 0x00;

  0043a	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN25@CGItemDrop:

; 5475 : 		}
; 5476 : #endif	// UPDATE_VALUABLE_ITEM_20070307
; 5477 : //#endif
; 5478 : 
; 5479 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 5480 : 	//       .
; 5481 : 	if( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony( &lpObj->pInventory[lpMsg->Ipos] ) == TRUE )
; 5482 : 	{
; 5483 : 		pResult.Result = 0x00;
; 5484 : #ifdef ADD_JEWEL_OF_HARMONY_WTFMESSAGE_20060818
; 5485 : 		GCServerMsgStringSend(lMsg.Get(3371), lpObj->m_Index, 1); //     .
; 5486 : #endif
; 5487 : 	}
; 5488 : 	// (/).     .
; 5489 : 	if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyOriginal( lpObj->pInventory[lpMsg->Ipos].m_Type )
; 5490 : 		|| g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity( lpObj->pInventory[lpMsg->Ipos].m_Type )
; 5491 : 		|| g_kJewelOfHarmonySystem.IsJewelOfHarmonySmeltingItems( lpObj->pInventory[lpMsg->Ipos].m_Type )
; 5492 : 		)
; 5493 : 	{
; 5494 : 		pResult.Result = 0x00;
; 5495 : 	}
; 5496 : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530	
; 5497 : 
; 5498 : #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 5499 : 	if( lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 5500 : 	{
; 5501 : 		//     .
; 5502 : 		pResult.Result = 0x00;
; 5503 : 	}
; 5504 : #endif
; 5505 : 
; 5506 : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 5507 : 	if( IsCashItem( lpObj->pInventory[lpMsg->Ipos].m_Type ) == TRUE )
; 5508 : 	{
; 5509 : 		pResult.Result = 0x00;
; 5510 : 	}
; 5511 : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 5512 : 	
; 5513 : #ifdef PREMIUMITEM_20090106
; 5514 : 	//     .
; 5515 : 	if(	IsPremiumItem( lpObj->pInventory[lpMsg->Ipos].m_Type ) == TRUE )
; 5516 : 	{
; 5517 : 		pResult.Result = 0x00;
; 5518 : 	}
; 5519 : #endif // PREMIUMITEM_20090106
; 5520 : 	
; 5521 : #ifndef FOR_KOREA
; 5522 : #ifdef ADD_PREMIUMITEM_PANDA
; 5523 : 	if( lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM( 13, 76)		// 
; 5524 : 		|| lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM( 13, 80)	// 
; 5525 : 		)
; 5526 : 	{
; 5527 : 		pResult.Result = 0x00;
; 5528 : 	}
; 5529 : #endif // ADD_PREMIUMITEM_PANDA
; 5530 : #endif // NOT_FOR_KOREA
; 5531 : 	
; 5532 : #ifdef ADD_NEWPVP_PKFIELD
; 5533 : 	if (drop_type == 0 &&lpObj->pInventory[lpMsg->Ipos].m_Type == MAKE_ITEMNUM(14, 28))
; 5534 : 	{
; 5535 : 		if (g_NewPVP.IsDuel(*lpObj))
; 5536 : 		{
; 5537 : 			pResult.Result = 0x00;
; 5538 : 		}
; 5539 : 	}
; 5540 : #endif // ADD_NEWPVP_PKFIELD
; 5541 : 
; 5542 : #ifdef MODIFY_QUEST_SYSTEM_20070525	//      .
; 5543 : 	if( lpObj->pInventory[lpMsg->Ipos].m_QuestItem )
; 5544 : 	{
; 5545 : 		return 0xFF;
; 5546 : 	}
; 5547 : #endif	
; 5548 : 	
; 5549 : 	if( pResult.Result == 0x01 )

  0043e	0f b6 45 eb	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  00442	83 f8 01	 cmp	 eax, 1
  00445	0f 85 29 0f 00
	00		 jne	 $LN30@CGItemDrop

; 5550 : 	{
; 5551 : 		ItemIsBufExOption(NewOption, &lpObj->pInventory[lpMsg->Ipos]);

  0044b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0044e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00452	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00458	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0045b	03 90 5c 0c 00
	00		 add	 edx, DWORD PTR [eax+3164]
  00461	52		 push	 edx
  00462	8d 4d f0	 lea	 ecx, DWORD PTR _NewOption$[ebp]
  00465	51		 push	 ecx
  00466	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  0046b	83 c4 08	 add	 esp, 8

; 5552 : 
; 5553 : 		int map_num = lpObj->MapNumber;	

  0046e	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00471	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00478	89 4d e0	 mov	 DWORD PTR _map_num$19[ebp], ecx

; 5554 : 		int type    = lpObj->pInventory[lpMsg->Ipos].m_Type;

  0047b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0047e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00482	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00488	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0048b	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00491	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  00496	89 55 dc	 mov	 DWORD PTR _type$18[ebp], edx

; 5555 : 		int level   = lpObj->pInventory[lpMsg->Ipos].m_Level;

  00499	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0049c	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  004a0	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  004a6	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004a9	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  004af	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  004b4	89 55 d8	 mov	 DWORD PTR _level$17[ebp], edx

; 5556 : 		float dur   = lpObj->pInventory[lpMsg->Ipos].m_Durability;

  004b7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004ba	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  004be	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  004c4	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004c7	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  004cd	f3 0f 10 44 11
	24		 movss	 xmm0, DWORD PTR [ecx+edx+36]
  004d3	f3 0f 11 45 d4	 movss	 DWORD PTR _dur$16[ebp], xmm0

; 5557 : 		int ret     = lpObj->pInventory[lpMsg->Ipos].IsItem();

  004d8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004db	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  004df	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  004e5	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004e8	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  004ee	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  004f3	89 45 d0	 mov	 DWORD PTR _ret$15[ebp], eax

; 5558 : 		BYTE Option1= lpObj->pInventory[lpMsg->Ipos].m_Option1;

  004f6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004f9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  004fd	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00503	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00506	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0050c	8a 54 11 78	 mov	 dl, BYTE PTR [ecx+edx+120]
  00510	88 55 cf	 mov	 BYTE PTR _Option1$14[ebp], dl

; 5559 : 		BYTE Option2= lpObj->pInventory[lpMsg->Ipos].m_Option2;

  00513	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00516	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0051a	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00520	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00523	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00529	8a 54 11 79	 mov	 dl, BYTE PTR [ecx+edx+121]
  0052d	88 55 ce	 mov	 BYTE PTR _Option2$13[ebp], dl

; 5560 : 		BYTE Option3= lpObj->pInventory[lpMsg->Ipos].m_Option3;

  00530	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00533	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00537	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0053d	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00540	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00546	8a 54 11 7a	 mov	 dl, BYTE PTR [ecx+edx+122]
  0054a	88 55 cd	 mov	 BYTE PTR _Option3$12[ebp], dl

; 5561 : 		BYTE NOption= lpObj->pInventory[lpMsg->Ipos].m_NewOption;

  0054d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00550	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00554	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0055a	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0055d	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00563	8a 54 11 7b	 mov	 dl, BYTE PTR [ecx+edx+123]
  00567	88 55 cc	 mov	 BYTE PTR _NOption$11[ebp], dl

; 5562 : 		DWORD s_num = lpObj->pInventory[lpMsg->Ipos].m_Number;

  0056a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0056d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00571	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00577	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057a	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00580	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00583	89 55 c8	 mov	 DWORD PTR _s_num$10[ebp], edx

; 5563 : 
; 5564 : #ifdef DARKLORD_WORK
; 5565 : 		int	 PetLevel = lpObj->pInventory[lpMsg->Ipos].m_PetItem_Level;

  00586	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00589	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0058d	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00593	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00596	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0059c	8b 94 11 a0 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+160]
  005a3	89 55 c4	 mov	 DWORD PTR _PetLevel$9[ebp], edx

; 5566 : 		int	 PetExp = 	lpObj->pInventory[lpMsg->Ipos].m_PetItem_Exp;

  005a6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  005a9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  005ad	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  005b3	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b6	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  005bc	8b 94 11 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+164]
  005c3	89 55 c0	 mov	 DWORD PTR _PetExp$8[ebp], edx

; 5567 : #endif
; 5568 : 
; 5569 : 		BYTE SOption= lpObj->pInventory[lpMsg->Ipos].m_SetOption;

  005c6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  005c9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  005cd	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  005d3	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d6	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  005dc	8a 94 11 92 00
	00 00		 mov	 dl, BYTE PTR [ecx+edx+146]
  005e3	88 55 bf	 mov	 BYTE PTR _SOption$7[ebp], dl

; 5570 : 
; 5571 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 5572 : 	#ifdef MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 5573 : 		BYTE ItemEffectEx = lpObj->pInventory[lpMsg->Ipos].m_ItemOptionEx;
; 5574 : 	#else
; 5575 : 		BYTE ItemEffectEx = lpObj->pInventory[lpMsg->Ipos].m_ItemOptionEx>>7;
; 5576 : 	#endif // MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 5577 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 5578 : 
; 5579 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 5580 : 		BYTE SocketOption[MAX_SOCKET_SLOT];
; 5581 : 		BYTE SocketBonusOption;
; 5582 : 
; 5583 : 		g_SocketOptionSystem.GetSocketOption( &lpObj->pInventory[lpMsg->Ipos], SocketOption, SocketBonusOption );
; 5584 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 5585 : 
; 5586 : 		DWORD item_number = lpObj->pInventory[lpMsg->Ipos].m_Number;

  005e6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  005e9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  005ed	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  005f3	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f6	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  005fc	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  005ff	89 55 b8	 mov	 DWORD PTR _item_number$6[ebp], edx

; 5587 : 		char szItemName[50]="Item";

  00602	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04BGCMBJDA@Item@
  00607	89 45 84	 mov	 DWORD PTR _szItemName$5[ebp], eax
  0060a	8a 0d 04 00 00
	00		 mov	 cl, BYTE PTR ??_C@_04BGCMBJDA@Item@+4
  00610	88 4d 88	 mov	 BYTE PTR _szItemName$5[ebp+4], cl
  00613	6a 2d		 push	 45			; 0000002dH
  00615	6a 00		 push	 0
  00617	8d 45 89	 lea	 eax, DWORD PTR _szItemName$5[ebp+5]
  0061a	50		 push	 eax
  0061b	e8 00 00 00 00	 call	 _memset
  00620	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5588 : 
; 5589 : #ifdef EXTEND_LOG_SYSTEM_03_20060816
; 5590 : 	#ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 5591 : 		BYTE ItemExOption = g_kJewelOfHarmonySystem.GetItemStrengthenOption( &lpObj->pInventory[lpMsg->Ipos] );
; 5592 : 		BYTE ItemExLevel = g_kJewelOfHarmonySystem.GetItemOptionLevel( &lpObj->pInventory[lpMsg->Ipos] );
; 5593 : 	#endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 5594 : #endif // EXTEND_LOG_SYSTEM_03_20060816
; 5595 : 
; 5596 : #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202	
; 5597 : 		if( gObjCheckSerial0ItemList(&lpObj->pInventory[lpMsg->Ipos]) )

  00623	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00626	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0062a	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00630	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00633	03 90 5c 0c 00
	00		 add	 edx, DWORD PTR [eax+3164]
  00639	52		 push	 edx
  0063a	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  0063f	83 c4 04	 add	 esp, 4
  00642	85 c0		 test	 eax, eax
  00644	74 71		 je	 SHORT $LN27@CGItemDrop

; 5598 : 		{
; 5599 : 			// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 5600 : 			MsgOutput( lpObj->m_Index, lMsg.Get(3354) );			// "  .  ."

  00646	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0064b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00650	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00656	50		 push	 eax
  00657	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0065a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0065c	51		 push	 ecx
  0065d	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00662	83 c4 08	 add	 esp, 8

; 5601 : 			LogAddTD("[ANTI-HACK][Serial 0 Item] [ItemDrop] (%s)(%s) Item(%s) Pos(%d)", 

  00665	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00668	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0066c	51		 push	 ecx
  0066d	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00670	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00674	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0067a	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0067d	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00683	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00688	50		 push	 eax
  00689	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0068c	83 c0 73	 add	 eax, 115		; 00000073H
  0068f	50		 push	 eax
  00690	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00693	83 c1 68	 add	 ecx, 104		; 00000068H
  00696	51		 push	 ecx
  00697	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLIte@
  0069c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006a2	83 c4 14	 add	 esp, 20			; 00000014H

; 5602 : 				lpObj->AccountID, lpObj->Name, lpObj->pInventory[lpMsg->Ipos].GetName(), lpMsg->Ipos);
; 5603 : 			CopyItem = 1;

  006a5	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _CopyItem$[ebp], 1

; 5604 : 			pResult.Result = 0x00;

  006ac	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 5605 : 			ret = FALSE;

  006b0	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _ret$15[ebp], 0
$LN27@CGItemDrop:

; 5606 : 		}
; 5607 : #endif
; 5608 : 		
; 5609 : 		if( gObjInventorySearchSerialNumber(lpObj, item_number) == FALSE )

  006b7	8b 45 b8	 mov	 eax, DWORD PTR _item_number$6[ebp]
  006ba	50		 push	 eax
  006bb	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006be	51		 push	 ecx
  006bf	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  006c4	83 c4 08	 add	 esp, 8
  006c7	85 c0		 test	 eax, eax
  006c9	75 12		 jne	 SHORT $LN28@CGItemDrop

; 5610 : 		{
; 5611 : 			CopyItem = 1;

  006cb	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _CopyItem$[ebp], 1

; 5612 : 			pResult.Result = 0x00;

  006d2	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 5613 : 			ret = FALSE;

  006d6	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _ret$15[ebp], 0
$LN28@CGItemDrop:

; 5614 : 		}
; 5615 : 
; 5616 : 		//      ?	
; 5617 : 		if( ret == TRUE ) 

  006dd	83 7d d0 01	 cmp	 DWORD PTR _ret$15[ebp], 1
  006e1	0f 85 6f 0c 00
	00		 jne	 $LN29@CGItemDrop

; 5618 : 		{		
; 5619 : 			strcpy( szItemName, lpObj->pInventory[lpMsg->Ipos].GetName());

  006e7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006ea	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  006ee	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  006f4	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006f7	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  006fd	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00702	50		 push	 eax
  00703	8d 45 84	 lea	 eax, DWORD PTR _szItemName$5[ebp]
  00706	50		 push	 eax
  00707	e8 00 00 00 00	 call	 _strcpy
  0070c	83 c4 08	 add	 esp, 8

; 5620 : 
; 5621 : 	#ifdef EVENT_SERVER_OPEN_COMMEMORATION_20050510
; 5622 : 			if( type == MAKE_ITEMNUM(13,10) && level == 6 ) //   
; 5623 : 			{	
; 5624 : 				MsgOutput( aIndex, "  6   .");		
; 5625 : 				pResult.Result = 0x00;
; 5626 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5627 : 				return FALSE;
; 5628 : 			}	
; 5629 : 	#endif // EVENT_SERVER_OPEN_COMMEMORATION_20050510
; 5630 : 
; 5631 : 	//testcat@
; 5632 : 	#ifdef HAPPY_POUCH
; 5633 : 			if (ret && type == MAKE_ITEMNUM(14,11)) //RED POUCH -    .
; 5634 : 			{	
; 5635 : 				if (level == 15)
; 5636 : 				{						
; 5637 : 					DropHappyItemOfRedPouch(&gObj[aIndex]);
; 5638 : 
; 5639 : 					pResult.Result = 0x01;
; 5640 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5641 : 					
; 5642 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5643 : 					return TRUE;
; 5644 : 				}
; 5645 : 				else if ( level == 14 ) //  apple20050203 - (NOTICE) MU_CHN_THANKS_COOKIE_EVENT_20040908   
; 5646 : 				{
; 5647 : 					MsgOutput( aIndex, "  .");		
; 5648 : 					pResult.Result = 0x00;
; 5649 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5650 : 					return FALSE;
; 5651 : 				}
; 5652 : 			}
; 5653 : 		
; 5654 : 	#endif//HAPPY_POUCH
; 5655 : 
; 5656 : 			
; 5657 : 			if( type == MAKE_ITEMNUM(14,11) ) //  ..

  0070f	6a 0b		 push	 11			; 0000000bH
  00711	6a 0e		 push	 14			; 0000000eH
  00713	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00718	83 c4 08	 add	 esp, 8
  0071b	39 45 dc	 cmp	 DWORD PTR _type$18[ebp], eax
  0071e	0f 85 ee 06 00
	00		 jne	 $LN31@CGItemDrop

; 5658 : 			{
; 5659 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00724	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00727	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0072b	51		 push	 ecx
  0072c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0072f	52		 push	 edx
  00730	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00735	83 c4 08	 add	 esp, 8

; 5660 : 				pResult.Result = 0x01;

  00738	c6 45 eb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 5661 : 				if( level == 1 )

  0073c	83 7d d8 01	 cmp	 DWORD PTR _level$17[ebp], 1
  00740	75 77		 jne	 SHORT $LN33@CGItemDrop

; 5662 : 				{	//  
; 5663 : 					StarOfXMasOpenEven(&gObj[aIndex]);

  00742	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00749	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0074f	50		 push	 eax
  00750	e8 00 00 00 00	 call	 ?StarOfXMasOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ; StarOfXMasOpenEven
  00755	83 c4 04	 add	 esp, 4

; 5664 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5665 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of StarOfXMas Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5666 : #else
; 5667 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of StarOfXMas Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  00758	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  0075c	50		 push	 eax
  0075d	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  00761	51		 push	 ecx
  00762	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  00766	52		 push	 edx
  00767	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  0076a	50		 push	 eax
  0076b	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  0076e	51		 push	 ecx
  0076f	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  00772	52		 push	 edx
  00773	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  00776	50		 push	 eax
  00777	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0077a	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00781	52		 push	 edx
  00782	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00785	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0078c	51		 push	 ecx
  0078d	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00790	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00797	50		 push	 eax
  00798	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0079b	83 c1 73	 add	 ecx, 115		; 00000073H
  0079e	51		 push	 ecx
  0079f	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007a2	83 c2 68	 add	 edx, 104		; 00000068H
  007a5	52		 push	 edx
  007a6	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@HPOJPJGH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5S@
  007ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  007b1	83 c4 34	 add	 esp, 52			; 00000034H

; 5668 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5669 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);					
; 5670 : 
; 5671 : 				}

  007b4	e9 54 06 00 00	 jmp	 $LN58@CGItemDrop
$LN33@CGItemDrop:

; 5672 : 				else if( level == 2 )

  007b9	83 7d d8 02	 cmp	 DWORD PTR _level$17[ebp], 2
  007bd	75 77		 jne	 SHORT $LN35@CGItemDrop

; 5673 : 				{	// 
; 5674 : 					FireCrackerOpenEven(&gObj[aIndex]);

  007bf	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007c6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007cc	50		 push	 eax
  007cd	e8 00 00 00 00	 call	 ?FireCrackerOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ; FireCrackerOpenEven
  007d2	83 c4 04	 add	 esp, 4

; 5675 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5676 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of FireCracker Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5677 : #else
; 5678 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of FireCracker Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  007d5	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  007d9	50		 push	 eax
  007da	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  007de	51		 push	 ecx
  007df	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  007e3	52		 push	 edx
  007e4	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  007e7	50		 push	 eax
  007e8	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  007eb	51		 push	 ecx
  007ec	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  007ef	52		 push	 edx
  007f0	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  007f3	50		 push	 eax
  007f4	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  007f7	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  007fe	52		 push	 edx
  007ff	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00802	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00809	51		 push	 ecx
  0080a	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0080d	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00814	50		 push	 eax
  00815	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00818	83 c1 73	 add	 ecx, 115		; 00000073H
  0081b	51		 push	 ecx
  0081c	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0081f	83 c2 68	 add	 edx, 104		; 00000068H
  00822	52		 push	 edx
  00823	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@DGEGEEP@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5F@
  00828	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0082e	83 c4 34	 add	 esp, 52			; 00000034H

; 5679 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5680 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);					
; 5681 : 
; 5682 : 				}

  00831	e9 d7 05 00 00	 jmp	 $LN58@CGItemDrop
$LN35@CGItemDrop:

; 5683 : 				else if( level == 3 )

  00836	83 7d d8 03	 cmp	 DWORD PTR _level$17[ebp], 3
  0083a	75 77		 jne	 SHORT $LN37@CGItemDrop

; 5684 : 				{	//  
; 5685 : 					HeartOfLoveOpenEven(&gObj[aIndex]);

  0083c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00843	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00849	50		 push	 eax
  0084a	e8 00 00 00 00	 call	 ?HeartOfLoveOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ; HeartOfLoveOpenEven
  0084f	83 c4 04	 add	 esp, 4

; 5686 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5687 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of HeartOfLove Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5688 : #else
; 5689 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of HeartOfLove Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  00852	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  00856	50		 push	 eax
  00857	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  0085b	51		 push	 ecx
  0085c	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  00860	52		 push	 edx
  00861	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00864	50		 push	 eax
  00865	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  00868	51		 push	 ecx
  00869	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  0086c	52		 push	 edx
  0086d	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  00870	50		 push	 eax
  00871	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00874	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  0087b	52		 push	 edx
  0087c	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0087f	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00886	51		 push	 ecx
  00887	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0088a	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00891	50		 push	 eax
  00892	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00895	83 c1 73	 add	 ecx, 115		; 00000073H
  00898	51		 push	 ecx
  00899	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0089c	83 c2 68	 add	 edx, 104		; 00000068H
  0089f	52		 push	 edx
  008a0	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@EBLAMMBK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5H@
  008a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  008ab	83 c4 34	 add	 esp, 52			; 00000034H

; 5690 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5691 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5692 : 				}

  008ae	e9 5a 05 00 00	 jmp	 $LN58@CGItemDrop
$LN37@CGItemDrop:

; 5693 : 				else if( level == 6 )

  008b3	83 7d d8 06	 cmp	 DWORD PTR _level$17[ebp], 6
  008b7	75 77		 jne	 SHORT $LN39@CGItemDrop

; 5694 : 				{	// 
; 5695 : 					GoldMedalOpenEven(&gObj[aIndex]);

  008b9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  008c0	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008c6	50		 push	 eax
  008c7	e8 00 00 00 00	 call	 ?GoldMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ; GoldMedalOpenEven
  008cc	83 c4 04	 add	 esp, 4

; 5696 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5697 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of GoldMedal Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5698 : #else
; 5699 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of GoldMedal Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  008cf	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  008d3	50		 push	 eax
  008d4	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  008d8	51		 push	 ecx
  008d9	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  008dd	52		 push	 edx
  008de	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  008e1	50		 push	 eax
  008e2	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  008e5	51		 push	 ecx
  008e6	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  008e9	52		 push	 edx
  008ea	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  008ed	50		 push	 eax
  008ee	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  008f1	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  008f8	52		 push	 edx
  008f9	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008fc	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00903	51		 push	 ecx
  00904	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00907	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0090e	50		 push	 eax
  0090f	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00912	83 c1 73	 add	 ecx, 115		; 00000073H
  00915	51		 push	 ecx
  00916	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00919	83 c2 68	 add	 edx, 104		; 00000068H
  0091c	52		 push	 edx
  0091d	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@MPNDPHHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5G@
  00922	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00928	83 c4 34	 add	 esp, 52			; 00000034H

; 5700 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5701 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5702 : 				}

  0092b	e9 dd 04 00 00	 jmp	 $LN58@CGItemDrop
$LN39@CGItemDrop:

; 5703 : 				else if( level == 5 )

  00930	83 7d d8 05	 cmp	 DWORD PTR _level$17[ebp], 5
  00934	75 77		 jne	 SHORT $LN41@CGItemDrop

; 5704 : 				{	// 
; 5705 : 					SilverMedalOpenEven(&gObj[aIndex]);

  00936	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0093d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00943	50		 push	 eax
  00944	e8 00 00 00 00	 call	 ?SilverMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ; SilverMedalOpenEven
  00949	83 c4 04	 add	 esp, 4

; 5706 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5707 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of SilverMedal Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5708 : #else
; 5709 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of SilverMedal Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  0094c	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  00950	50		 push	 eax
  00951	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  00955	51		 push	 ecx
  00956	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  0095a	52		 push	 edx
  0095b	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  0095e	50		 push	 eax
  0095f	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  00962	51		 push	 ecx
  00963	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  00966	52		 push	 edx
  00967	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  0096a	50		 push	 eax
  0096b	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0096e	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00975	52		 push	 edx
  00976	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00979	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00980	51		 push	 ecx
  00981	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00984	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0098b	50		 push	 eax
  0098c	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0098f	83 c1 73	 add	 ecx, 115		; 00000073H
  00992	51		 push	 ecx
  00993	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00996	83 c2 68	 add	 edx, 104		; 00000068H
  00999	52		 push	 edx
  0099a	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@IGKKOJBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5S@
  0099f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  009a5	83 c4 34	 add	 esp, 52			; 00000034H

; 5710 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5711 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5712 : 				}

  009a8	e9 60 04 00 00	 jmp	 $LN58@CGItemDrop
$LN41@CGItemDrop:

; 5713 : 				else if( level == 7 )

  009ad	83 7d d8 07	 cmp	 DWORD PTR _level$17[ebp], 7
  009b1	75 77		 jne	 SHORT $LN43@CGItemDrop

; 5714 : 				{	//  
; 5715 : 					EventChipOpenEven(&gObj[aIndex]);

  009b3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  009ba	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009c0	50		 push	 eax
  009c1	e8 00 00 00 00	 call	 ?EventChipOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ; EventChipOpenEven
  009c6	83 c4 04	 add	 esp, 4

; 5716 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5717 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of EventChip Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5718 : #else
; 5719 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of EventChip Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  009c9	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  009cd	50		 push	 eax
  009ce	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  009d2	51		 push	 ecx
  009d3	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  009d7	52		 push	 edx
  009d8	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  009db	50		 push	 eax
  009dc	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  009df	51		 push	 ecx
  009e0	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  009e3	52		 push	 edx
  009e4	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  009e7	50		 push	 eax
  009e8	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009eb	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  009f2	52		 push	 edx
  009f3	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009f6	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  009fd	51		 push	 ecx
  009fe	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a01	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00a08	50		 push	 eax
  00a09	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a0c	83 c1 73	 add	 ecx, 115		; 00000073H
  00a0f	51		 push	 ecx
  00a10	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a13	83 c2 68	 add	 edx, 104		; 00000068H
  00a16	52		 push	 edx
  00a17	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@PGPEHJJI@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
  00a1c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a22	83 c4 34	 add	 esp, 52			; 00000034H

; 5720 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5721 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5722 : 				}

  00a25	e9 e3 03 00 00	 jmp	 $LN58@CGItemDrop
$LN43@CGItemDrop:

; 5723 : 				else if( level == 8 )

  00a2a	83 7d d8 08	 cmp	 DWORD PTR _level$17[ebp], 8
  00a2e	0f 85 82 00 00
	00		 jne	 $LN45@CGItemDrop

; 5724 : 				{
; 5725 : 					EledoradoBoxOpenEven(&gObj[aIndex], level, 2, 50000);

  00a34	68 50 c3 00 00	 push	 50000			; 0000c350H
  00a39	6a 02		 push	 2
  00a3b	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00a3e	50		 push	 eax
  00a3f	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00a46	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a4c	51		 push	 ecx
  00a4d	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven
  00a52	83 c4 10	 add	 esp, 16			; 00000010H

; 5726 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5727 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox-8 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5728 : #else
; 5729 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox-8 Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  00a55	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  00a59	50		 push	 eax
  00a5a	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  00a5e	51		 push	 ecx
  00a5f	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  00a63	52		 push	 edx
  00a64	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00a67	50		 push	 eax
  00a68	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  00a6b	51		 push	 ecx
  00a6c	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  00a6f	52		 push	 edx
  00a70	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  00a73	50		 push	 eax
  00a74	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a77	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00a7e	52		 push	 edx
  00a7f	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a82	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00a89	51		 push	 ecx
  00a8a	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a8d	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00a94	50		 push	 eax
  00a95	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a98	83 c1 73	 add	 ecx, 115		; 00000073H
  00a9b	51		 push	 ecx
  00a9c	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a9f	83 c2 68	 add	 edx, 104		; 00000068H
  00aa2	52		 push	 edx
  00aa3	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@JEPLEEGL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
  00aa8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00aae	83 c4 34	 add	 esp, 52			; 00000034H

; 5730 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5731 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5732 : 				}				

  00ab1	e9 57 03 00 00	 jmp	 $LN58@CGItemDrop
$LN45@CGItemDrop:

; 5733 : 				else if( level == 9 )

  00ab6	83 7d d8 09	 cmp	 DWORD PTR _level$17[ebp], 9
  00aba	0f 85 82 00 00
	00		 jne	 $LN47@CGItemDrop

; 5734 : 				{
; 5735 : 					EledoradoBoxOpenEven(&gObj[aIndex], level, 2, 100000);

  00ac0	68 a0 86 01 00	 push	 100000			; 000186a0H
  00ac5	6a 02		 push	 2
  00ac7	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00aca	50		 push	 eax
  00acb	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00ad2	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ad8	51		 push	 ecx
  00ad9	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven
  00ade	83 c4 10	 add	 esp, 16			; 00000010H

; 5736 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5737 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox-9 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5738 : #else
; 5739 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox-9 Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  00ae1	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  00ae5	50		 push	 eax
  00ae6	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  00aea	51		 push	 ecx
  00aeb	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  00aef	52		 push	 edx
  00af0	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00af3	50		 push	 eax
  00af4	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  00af7	51		 push	 ecx
  00af8	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  00afb	52		 push	 edx
  00afc	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  00aff	50		 push	 eax
  00b00	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b03	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00b0a	52		 push	 edx
  00b0b	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b0e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00b15	51		 push	 ecx
  00b16	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b19	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00b20	50		 push	 eax
  00b21	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b24	83 c1 73	 add	 ecx, 115		; 00000073H
  00b27	51		 push	 ecx
  00b28	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b2b	83 c2 68	 add	 edx, 104		; 00000068H
  00b2e	52		 push	 edx
  00b2f	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@PNDHLIGG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
  00b34	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b3a	83 c4 34	 add	 esp, 52			; 00000034H

; 5740 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5741 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5742 : 				}				

  00b3d	e9 cb 02 00 00	 jmp	 $LN58@CGItemDrop
$LN47@CGItemDrop:

; 5743 : 				else if( level == 10 )

  00b42	83 7d d8 0a	 cmp	 DWORD PTR _level$17[ebp], 10 ; 0000000aH
  00b46	0f 85 82 00 00
	00		 jne	 $LN49@CGItemDrop

; 5744 : 				{
; 5745 : 					EledoradoBoxOpenEven(&gObj[aIndex], level, 2, 150000);

  00b4c	68 f0 49 02 00	 push	 150000			; 000249f0H
  00b51	6a 02		 push	 2
  00b53	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00b56	50		 push	 eax
  00b57	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00b5e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b64	51		 push	 ecx
  00b65	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven
  00b6a	83 c4 10	 add	 esp, 16			; 00000010H

; 5746 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5747 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox-10 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5748 : #else
; 5749 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox-10 Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  00b6d	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  00b71	50		 push	 eax
  00b72	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  00b76	51		 push	 ecx
  00b77	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  00b7b	52		 push	 edx
  00b7c	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00b7f	50		 push	 eax
  00b80	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  00b83	51		 push	 ecx
  00b84	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  00b87	52		 push	 edx
  00b88	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  00b8b	50		 push	 eax
  00b8c	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b8f	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00b96	52		 push	 edx
  00b97	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b9a	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00ba1	51		 push	 ecx
  00ba2	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ba5	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00bac	50		 push	 eax
  00bad	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bb0	83 c1 73	 add	 ecx, 115		; 00000073H
  00bb3	51		 push	 ecx
  00bb4	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bb7	83 c2 68	 add	 edx, 104		; 00000068H
  00bba	52		 push	 edx
  00bbb	68 00 00 00 00	 push	 OFFSET ??_C@_0FP@PHLHAFBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
  00bc0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00bc6	83 c4 34	 add	 esp, 52			; 00000034H

; 5750 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5751 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5752 : 				}				

  00bc9	e9 3f 02 00 00	 jmp	 $LN58@CGItemDrop
$LN49@CGItemDrop:

; 5753 : 				else if( level == 11 )

  00bce	83 7d d8 0b	 cmp	 DWORD PTR _level$17[ebp], 11 ; 0000000bH
  00bd2	0f 85 82 00 00
	00		 jne	 $LN51@CGItemDrop

; 5754 : 				{
; 5755 : 					EledoradoBoxOpenEven(&gObj[aIndex], level, 1, 200000);

  00bd8	68 40 0d 03 00	 push	 200000			; 00030d40H
  00bdd	6a 01		 push	 1
  00bdf	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00be2	50		 push	 eax
  00be3	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00bea	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bf0	51		 push	 ecx
  00bf1	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven
  00bf6	83 c4 10	 add	 esp, 16			; 00000010H

; 5756 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5757 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox1-11 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5758 : #else
; 5759 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox1-11 Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  00bf9	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  00bfd	50		 push	 eax
  00bfe	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  00c02	51		 push	 ecx
  00c03	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  00c07	52		 push	 edx
  00c08	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00c0b	50		 push	 eax
  00c0c	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  00c0f	51		 push	 ecx
  00c10	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  00c13	52		 push	 edx
  00c14	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  00c17	50		 push	 eax
  00c18	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c1b	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00c22	52		 push	 edx
  00c23	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c26	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00c2d	51		 push	 ecx
  00c2e	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c31	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00c38	50		 push	 eax
  00c39	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c3c	83 c1 73	 add	 ecx, 115		; 00000073H
  00c3f	51		 push	 ecx
  00c40	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c43	83 c2 68	 add	 edx, 104		; 00000068H
  00c46	52		 push	 edx
  00c47	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JIKHBPIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
  00c4c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00c52	83 c4 34	 add	 esp, 52			; 00000034H

; 5760 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5761 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5762 : 				}				

  00c55	e9 b3 01 00 00	 jmp	 $LN58@CGItemDrop
$LN51@CGItemDrop:

; 5763 : 				else if( level == 12 )

  00c5a	83 7d d8 0c	 cmp	 DWORD PTR _level$17[ebp], 12 ; 0000000cH
  00c5e	0f 85 82 00 00
	00		 jne	 $LN53@CGItemDrop

; 5764 : 				{
; 5765 : 					EledoradoBoxOpenEven(&gObj[aIndex], level, 0, 250000);

  00c64	68 90 d0 03 00	 push	 250000			; 0003d090H
  00c69	6a 00		 push	 0
  00c6b	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00c6e	50		 push	 eax
  00c6f	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00c76	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c7c	51		 push	 ecx
  00c7d	e8 00 00 00 00	 call	 ?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven
  00c82	83 c4 10	 add	 esp, 16			; 00000010H

; 5766 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5767 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox1-12 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5768 : #else
; 5769 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of ElradoraBox1-12 Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  00c85	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  00c89	50		 push	 eax
  00c8a	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  00c8e	51		 push	 ecx
  00c8f	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  00c93	52		 push	 edx
  00c94	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00c97	50		 push	 eax
  00c98	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  00c9b	51		 push	 ecx
  00c9c	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  00c9f	52		 push	 edx
  00ca0	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  00ca3	50		 push	 eax
  00ca4	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ca7	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00cae	52		 push	 edx
  00caf	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cb2	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00cb9	51		 push	 ecx
  00cba	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cbd	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00cc4	50		 push	 eax
  00cc5	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cc8	83 c1 73	 add	 ecx, 115		; 00000073H
  00ccb	51		 push	 ecx
  00ccc	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ccf	83 c2 68	 add	 edx, 104		; 00000068H
  00cd2	52		 push	 edx
  00cd3	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@CCPCBLJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5E@
  00cd8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00cde	83 c4 34	 add	 esp, 52			; 00000034H

; 5770 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5771 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5772 : 				}

  00ce1	e9 27 01 00 00	 jmp	 $LN58@CGItemDrop
$LN53@CGItemDrop:

; 5773 : #ifdef DARK_LORD_HEART_EVENT_20040810				//     
; 5774 : 				else if( level == 13 )

  00ce6	83 7d d8 0d	 cmp	 DWORD PTR _level$17[ebp], 13 ; 0000000dH
  00cea	75 77		 jne	 SHORT $LN55@CGItemDrop

; 5775 : 				{
; 5776 : 					DarkLordHeartItemBoxOpen(&gObj[aIndex]);

  00cec	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00cf3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00cf9	50		 push	 eax
  00cfa	e8 00 00 00 00	 call	 ?DarkLordHeartItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z ; DarkLordHeartItemBoxOpen
  00cff	83 c4 04	 add	 esp, 4

; 5777 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5778 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of DarkLordHeart Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5779 : #else
; 5780 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of DarkLordHeart Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  00d02	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  00d06	50		 push	 eax
  00d07	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  00d0b	51		 push	 ecx
  00d0c	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  00d10	52		 push	 edx
  00d11	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00d14	50		 push	 eax
  00d15	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  00d18	51		 push	 ecx
  00d19	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  00d1c	52		 push	 edx
  00d1d	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  00d20	50		 push	 eax
  00d21	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d24	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00d2b	52		 push	 edx
  00d2c	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d2f	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00d36	51		 push	 ecx
  00d37	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d3a	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00d41	50		 push	 eax
  00d42	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d45	83 c1 73	 add	 ecx, 115		; 00000073H
  00d48	51		 push	 ecx
  00d49	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d4c	83 c2 68	 add	 edx, 104		; 00000068H
  00d4f	52		 push	 edx
  00d50	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@FJBOPNFK@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5box?5of?5D@
  00d55	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00d5b	83 c4 34	 add	 esp, 52			; 00000034H

; 5781 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5782 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5783 : 				}

  00d5e	e9 aa 00 00 00	 jmp	 $LN58@CGItemDrop
$LN55@CGItemDrop:

; 5784 : #endif
; 5785 : #ifdef MU_CHN_THANKS_COOKIE_EVENT_20040908		//   
; 5786 : 				else if( level == 14 )
; 5787 : 				{
; 5788 : 					ChnThanksCookieEvent->DropItem(lpObj->m_Index);
; 5789 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5790 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of China Event-14 Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5791 : #else
; 5792 : 					LogAddTD("[%s][%s][%d]%d/%d Used box of China Event-14 Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5793 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5794 : 						     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5795 : 				}					
; 5796 : #endif
; 5797 : 				else if ( level == 0 ) //happcat@20050202 - Level  0   .

  00d63	83 7d d8 00	 cmp	 DWORD PTR _level$17[ebp], 0
  00d67	0f 85 80 00 00
	00		 jne	 $LN57@CGItemDrop

; 5798 : 				{	//  
; 5799 : 					LuckyBoxOpenEven(&gObj[aIndex]);

  00d6d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00d74	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d7a	50		 push	 eax
  00d7b	e8 00 00 00 00	 call	 ?LuckyBoxOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ; LuckyBoxOpenEven
  00d80	83 c4 04	 add	 esp, 4

; 5800 : 					LogAddTD(lMsg.Get(478),lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);					

  00d83	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  00d87	50		 push	 eax
  00d88	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  00d8c	51		 push	 ecx
  00d8d	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  00d91	52		 push	 edx
  00d92	8b 45 d8	 mov	 eax, DWORD PTR _level$17[ebp]
  00d95	50		 push	 eax
  00d96	8b 4d dc	 mov	 ecx, DWORD PTR _type$18[ebp]
  00d99	51		 push	 ecx
  00d9a	8d 55 84	 lea	 edx, DWORD PTR _szItemName$5[ebp]
  00d9d	52		 push	 edx
  00d9e	8b 45 c8	 mov	 eax, DWORD PTR _s_num$10[ebp]
  00da1	50		 push	 eax
  00da2	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00da5	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00dac	52		 push	 edx
  00dad	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00db0	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00db7	51		 push	 ecx
  00db8	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00dbb	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00dc2	50		 push	 eax
  00dc3	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00dc6	83 c1 73	 add	 ecx, 115		; 00000073H
  00dc9	51		 push	 ecx
  00dca	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00dcd	83 c2 68	 add	 edx, 104		; 00000068H
  00dd0	52		 push	 edx
  00dd1	68 de 01 00 00	 push	 478			; 000001deH
  00dd6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00ddb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00de1	50		 push	 eax
  00de2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00de8	83 c4 34	 add	 esp, 52			; 00000034H

; 5801 : 				}

  00deb	eb 20		 jmp	 SHORT $LN58@CGItemDrop
$LN57@CGItemDrop:

; 5802 : 				else //happcat@20050202 -      .
; 5803 : 				{					
; 5804 : 					pResult.Result = 0x00;

  00ded	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 5805 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00df1	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00df5	50		 push	 eax
  00df6	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00df9	51		 push	 ecx
  00dfa	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00dfd	52		 push	 edx
  00dfe	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00e03	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5806 : 					return FALSE;

  00e06	33 c0		 xor	 eax, eax
  00e08	e9 d6 06 00 00	 jmp	 $LN1@CGItemDrop
$LN58@CGItemDrop:

; 5807 : 				}
; 5808 : 
; 5809 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 5810 : 				LogAddTD("[%s][%s] Used box of luck (level:%d)",
; 5811 : 					lpObj->AccountID, lpObj->Name, level );
; 5812 : #endif
; 5813 : 			}

  00e0d	e9 42 05 00 00	 jmp	 $LN75@CGItemDrop
$LN31@CGItemDrop:

; 5814 : 			
; 5815 : #ifdef CHRISTMAS_RIBBONBOX_EVENT_20051212		//   
; 5816 : 			else if( type == MAKE_ITEMNUM( 12, 32 ) )
; 5817 : 			{
; 5818 : 				//   .
; 5819 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5820 : 				
; 5821 : 				RedRibbonBoxOpen( &gObj[aIndex] );
; 5822 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5823 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5824 : #else
; 5825 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5826 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5827 : 					     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);				
; 5828 : 			}
; 5829 : 			else if( type == MAKE_ITEMNUM( 12, 33 ) )
; 5830 : 			{
; 5831 : 				//   .
; 5832 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);	
; 5833 : 				
; 5834 : 				GreenRibbonBoxOpen( &gObj[aIndex] );
; 5835 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5836 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5837 : #else
; 5838 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5839 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5840 : 					     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5841 : 			}
; 5842 : 			else if( type == MAKE_ITEMNUM( 12, 34 ) )
; 5843 : 			{
; 5844 : 				//   .
; 5845 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);	
; 5846 : 				
; 5847 : 				BlueRibbonBoxOpen( &gObj[aIndex] );
; 5848 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5849 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5850 : #else
; 5851 : 				LogAddTD("[%s][%s][%d]%d/%d Used Christmas RibbonBox Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5852 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5853 : 					     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5854 : 			}
; 5855 : #endif // #ifdef CHRISTMAS_RIBBONBOX_EVENT_20051212
; 5856 : 				
; 5857 : #ifdef VALENTINES_DAY_BOX_EVENT_20060124
; 5858 : 			else if( type == MAKE_ITEMNUM( 14, 32 ) && level == 0 )
; 5859 : 			{
; 5860 : 				//   .
; 5861 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5862 : 				
; 5863 : 				PinkChocolateBoxOpen( &gObj[aIndex] );
; 5864 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5865 : 				LogAddTD("[%s][%s][%d]%d/%d Used Valentine's Day ChocolateBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5866 : #else
; 5867 : 				LogAddTD("[%s][%s][%d]%d/%d Used Valentine's Day ChocolateBox Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5868 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5869 : 				     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);			
; 5870 : 			}
; 5871 : 			else if( type == MAKE_ITEMNUM( 14, 33 ) && level == 0 )
; 5872 : 			{
; 5873 : 				//   .
; 5874 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);	
; 5875 : 				
; 5876 : 				RedChocolateBoxOpen( &gObj[aIndex] );
; 5877 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5878 : 				LogAddTD("[%s][%s][%d]%d/%d Used Valentine's Day ChocolateBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5879 : #else
; 5880 : 				LogAddTD("[%s][%s][%d]%d/%d Used Valentine's Day ChocolateBox Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5881 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5882 : 				     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5883 : 			}	
; 5884 : 			else if( type == MAKE_ITEMNUM( 14, 34 ) && level == 0 )
; 5885 : 			{
; 5886 : 				//   .
; 5887 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);	
; 5888 : 				
; 5889 : 				BlueChocolateBoxOpen( &gObj[aIndex] );
; 5890 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5891 : 				LogAddTD("[%s][%s][%d]%d/%d Used Valentine's Day ChocolateBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5892 : #else
; 5893 : 				LogAddTD("[%s][%s][%d]%d/%d Used Valentine's Day ChocolateBox Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5894 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5895 : 				     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5896 : 			}
; 5897 : #endif // #ifdef VALENTINES_DAY_BOX_EVENT_20060124
; 5898 : 
; 5899 : #ifdef WHITEDAY_CANDY_BOX_EVENT_20060222
; 5900 : 			else if( type == MAKE_ITEMNUM( 14, 32 ) && level == 1 )
; 5901 : 			{
; 5902 : 				//   .
; 5903 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 5904 : 				
; 5905 : 				LightPurpleCandyBoxOpen( &gObj[aIndex] );
; 5906 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5907 : 				LogAddTD("[%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5908 : #else
; 5909 : 				LogAddTD("[%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5910 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5911 : 				     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5912 : 			}
; 5913 : 			else if( type == MAKE_ITEMNUM( 14, 33 ) && level == 1 )
; 5914 : 			{
; 5915 : 				//   .
; 5916 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);	
; 5917 : 				
; 5918 : 				VermilionCandyBoxOpen( &gObj[aIndex] );
; 5919 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5920 : 				LogAddTD("[%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5921 : #else
; 5922 : 				LogAddTD("[%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5923 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5924 : 				     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5925 : 			}	
; 5926 : 			else if( type == MAKE_ITEMNUM( 14, 34 ) && level == 1 )
; 5927 : 			{
; 5928 : 				//   .
; 5929 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);	
; 5930 : 				
; 5931 : 				DeepBlueCandyBoxOpen( &gObj[aIndex] );
; 5932 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5933 : 				LogAddTD("[%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5934 : #else
; 5935 : 				LogAddTD("[%s][%s][%d]%d/%d Used WhiteDay CandyBox Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5936 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5937 : 				     lpObj->AccountID, lpObj->Name,lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 5938 : 			}
; 5939 : #endif // #ifdef WHITEDAY_CANDY_BOX_EVENT_20060222
; 5940 : 
; 5941 : #ifdef HALLOWINDAY_JACK_O_LANTERN_EVENT_20061017
; 5942 : 			else if( type == MAKE_ITEMNUM( 14, 45 ) )
; 5943 : 			{
; 5944 : 				//   
; 5945 : 				gObjInventoryDeleteItem( aIndex, lpMsg->Ipos );
; 5946 : 
; 5947 : 				HallowinDayEventItemBoxOpen( lpObj );
; 5948 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5949 : 				LogAddTD("[%s][%s][%d]%d/%d Used Pumpkin of Luck Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5950 : #else
; 5951 : 				LogAddTD("[%s][%s][%d]%d/%d Used Pumpkin of Luck Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5952 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5953 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3 );
; 5954 : 			}
; 5955 : #endif // HALLOWINDAY_JACK_O_LANTERN_EVENT_20061017
; 5956 : 
; 5957 : #ifdef CHRISTMAS_STAR_20061211
; 5958 : 			else if( type == MAKE_ITEMNUM( 14, 51 ) )
; 5959 : 			{
; 5960 : 				//   
; 5961 : 				gObjInventoryDeleteItem( aIndex, lpMsg->Ipos );
; 5962 : 
; 5963 : 				ChristmasStarDrop( lpObj );
; 5964 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5965 : 				LogAddTD( "[%s][%s][%d]%d/%d Used Christmas-Star Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5966 : #else
; 5967 : 				LogAddTD( "[%s][%s][%d]%d/%d Used Christmas-Star Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5968 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5969 : 				lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3 );
; 5970 : 			}
; 5971 : #endif
; 5972 : 			
; 5973 : #ifdef ADD_FIRECRACKER_NPC_20070306	//    
; 5974 : 			else if( type == MAKE_ITEMNUM( 14, 63 ) )
; 5975 : 			{
; 5976 : 				//  
; 5977 : 				gObjInventoryDeleteItem( aIndex, lpMsg->Ipos );
; 5978 : 				
; 5979 : 				ChristmasStarDrop( lpObj );
; 5980 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5981 : 				LogAddTD( "[%s][%s][%d]%d/%d Used FireCraker Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5982 : #else
; 5983 : 				LogAddTD( "[%s][%s][%d]%d/%d Used FireCraker Item Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5984 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5985 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3 );
; 5986 : 			}
; 5987 : 
; 5988 : #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 5989 : 			else if( type == MAKE_ITEMNUM( 14, 84 ) )
; 5990 : 			{
; 5991 : 				//  
; 5992 : 				gObjInventoryDeleteItem( aIndex, lpMsg->Ipos );
; 5993 : 				
; 5994 : 				CherryBlossomEventItemBoxOpen( &gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y );
; 5995 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 5996 : 				LogAddTD( "[%s][%s][%d]%d/%d Used CherryBox Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5997 : #else
; 5998 : 					LogAddTD( "[%s][%s][%d]%d/%d Used CherryBox Item Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 5999 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6000 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3 );
; 6001 : 			}
; 6002 : #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 6003 : 
; 6004 : #endif //MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6005 : //------------->
; 6006 : //20081013    -  (grooving)
; 6007 : #ifdef	UPDATE_XMASEVENT_MAP_20080930
; 6008 : 			else if( type == MAKE_ITEMNUM( 14, 99) )
; 6009 : 			{
; 6010 : 				//  
; 6011 : 				gObjInventoryDeleteItem( aIndex, lpMsg->Ipos );
; 6012 : 				
; 6013 : 				ChristmasFireCrackerDrop( lpObj );
; 6014 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6015 : 				LogAddTD( "[%s][%s][%d]%d/%d Used FireCraker Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6016 : #else
; 6017 : 				LogAddTD( "[%s][%s][%d]%d/%d Used FireCraker Item Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6018 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6019 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3 );
; 6020 : 			}
; 6021 : #endif //UPDATE_XMASEVENT_MAP_20080930
; 6022 : 			//<-------------
; 6023 : #ifdef HIDDEN_TREASUREBOX_EVENT_20050804
; 6024 : 			else if(type == MAKE_ITEMNUM(12,26)) {
; 6025 : 				switch(level) {
; 6026 : 				case 0:
; 6027 : 					{
; 6028 : 						gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 6029 : 						pResult.Result = 0x01;
; 6030 : 						INT iType = MAKE_ITEMNUM(12,26);
; 6031 : 						INT iDropRate = rand()%100;
; 6032 : 						INT iLevel;
; 6033 : 						if (iDropRate < 10) {
; 6034 : 							iLevel = 3;		//  ( 10%)
; 6035 : 						}
; 6036 : 						else if (iDropRate < 45 ) {
; 6037 : 							iLevel = 1;		//  ( 35%)
; 6038 : 						}
; 6039 : 						else {
; 6040 : 							iLevel = 2;		//  ( 55%)
; 6041 : 						}
; 6042 : 						ItemSerialCreateSend(aIndex, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, iType, iLevel, (BYTE)1, 0, 0, 0, lpObj->m_Index, 0);
; 6043 : 
; 6044 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6045 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Mysterious Bead : Drop (%d) - serial:%u",
; 6046 : #else
; 6047 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Mysterious Bead : Drop (%d) - serial:%d",
; 6048 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6049 : 							lpObj->AccountID,
; 6050 : 							lpObj->Name,
; 6051 : 							iLevel,
; 6052 : 							s_num
; 6053 : 							);
; 6054 : 					}
; 6055 : 					break;
; 6056 : 				case 1:
; 6057 : 				case 2:
; 6058 : 				case 3:
; 6059 : 					{
; 6060 : 						gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 6061 : 						pResult.Result = 0x01;
; 6062 : 
; 6063 : 						PMSG_SERVERCMD	ServerCmd;
; 6064 : 						PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			
; 6065 : 						ServerCmd.CmdType = 0;
; 6066 : 						ServerCmd.X = lpObj->X;
; 6067 : 						ServerCmd.Y = lpObj->Y;
; 6068 : 						MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 6069 : 						DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 6070 : 
; 6071 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6072 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Crystal (%d) - serial:%u",
; 6073 : #else
; 6074 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Crystal (%d) - serial:%d",
; 6075 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6076 : 							lpObj->AccountID,
; 6077 : 							lpObj->Name,
; 6078 : 							level,
; 6079 : 							s_num
; 6080 : 							);
; 6081 : 					}
; 6082 : 					break;
; 6083 : 				case 4:
; 6084 : 					{
; 6085 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6086 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Hidden Treasure Box - serial:%u",
; 6087 : #else
; 6088 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Hidden Treasure Box - serial:%d",
; 6089 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6090 : 							lpObj->AccountID,
; 6091 : 							lpObj->Name,
; 6092 : 							s_num
; 6093 : 							);
; 6094 : 
; 6095 : 						gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 6096 : 						pResult.Result = 0x01;
; 6097 : 						HiddenTreasureBoxItemBoxOpen(&gObj[aIndex]);
; 6098 : 					}
; 6099 : 					break;
; 6100 : 				case 5:
; 6101 : 					{
; 6102 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6103 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Surprise Treasure Box - serial:%u",
; 6104 : #else
; 6105 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Surprise Treasure Box - serial:%d",
; 6106 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6107 : 							lpObj->AccountID,
; 6108 : 							lpObj->Name,
; 6109 : 							s_num
; 6110 : 							);
; 6111 : 
; 6112 : 						gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 6113 : 						pResult.Result = 0x01;
; 6114 : 						
; 6115 : 						//    
; 6116 : 						if (rand()%10000 < g_iHiddenTreasureBoxOfflineRate) {
; 6117 : 							//   
; 6118 : 							EGReqRegHTOfflineGift(lpObj->m_Index);
; 6119 : 						}
; 6120 : 						else {
; 6121 : 							//  
; 6122 : 							INT iDropZen = 1000000;
; 6123 : 							MapC[lpObj->MapNumber].MoneyItemDrop(iDropZen, lpObj->X, lpObj->Y);
; 6124 : 
; 6125 : 							LogAddTD("[Hidden TreasureBox Event] [%s][%s] Event ZenDrop : %d : (%d)(%d/%d)", 
; 6126 : 									lpObj->AccountID, lpObj->Name, 
; 6127 : 									iDropZen,
; 6128 : 									lpObj->MapNumber, lpObj->X, lpObj->Y);
; 6129 : 						}
; 6130 : 					}
; 6131 : 					break;
; 6132 : 				}
; 6133 : 			}
; 6134 : #endif
; 6135 : #ifdef RING_EVENT_ITEMBOX_20031124		//   40    
; 6136 : 			else if( type == MAKE_ITEMNUM(13,20) && level == 1)

  00e12	6a 14		 push	 20			; 00000014H
  00e14	6a 0d		 push	 13			; 0000000dH
  00e16	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00e1b	83 c4 08	 add	 esp, 8
  00e1e	39 45 dc	 cmp	 DWORD PTR _type$18[ebp], eax
  00e21	0f 85 e1 00 00
	00		 jne	 $LN59@CGItemDrop
  00e27	83 7d d8 01	 cmp	 DWORD PTR _level$17[ebp], 1
  00e2b	0f 85 d7 00 00
	00		 jne	 $LN59@CGItemDrop

; 6137 : 			{
; 6138 : 				//   .
; 6139 : 	#ifndef FOR_ONAIR	//    
; 6140 : 				if (gObj[aIndex].Level >= 40) 

  00e31	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e38	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e3e	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00e46	83 fa 28	 cmp	 edx, 40			; 00000028H
  00e49	7c 2f		 jl	 SHORT $LN61@CGItemDrop

; 6141 : 	#endif
; 6142 : 				{
; 6143 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00e4b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00e4e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00e52	51		 push	 ecx
  00e53	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00e56	52		 push	 edx
  00e57	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00e5c	83 c4 08	 add	 esp, 8

; 6144 : 
; 6145 : #ifdef UPDATE_LOWLEVEL_SUPPORT_RING_20070119	// , ( )  /(goni)
; 6146 : 					RingOfHeroEventItemBoxOpen(&gObj[aIndex]);
; 6147 : #else
; 6148 : 					RingEventItemBoxOpen (&gObj[aIndex]);		

  00e5f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e66	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e6c	50		 push	 eax
  00e6d	e8 00 00 00 00	 call	 ?RingEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z ; RingEventItemBoxOpen
  00e72	83 c4 04	 add	 esp, 4

; 6149 : #endif
; 6150 : 				}

  00e75	e9 89 00 00 00	 jmp	 $LN62@CGItemDrop
$LN61@CGItemDrop:

; 6151 : 	#ifndef FOR_ONAIR
; 6152 : 				else 
; 6153 : 				{
; 6154 : 				
; 6155 : 				#ifdef MODIFY_NOTICE_20040325
; 6156 : 					PMSG_NOTICE	pNotice;
; 6157 : 					TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, lMsg.Get(1211) );

  00e7a	68 bb 04 00 00	 push	 1211			; 000004bbH
  00e7f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00e84	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00e8a	50		 push	 eax
  00e8b	6a 0a		 push	 10			; 0000000aH
  00e8d	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$4[ebp]
  00e93	50		 push	 eax
  00e94	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00e99	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6158 : 					TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_BLUE);

  00e9c	6a 14		 push	 20			; 00000014H
  00e9e	6a 00		 push	 0
  00ea0	6a 01		 push	 1
  00ea2	68 c4 00 00 00	 push	 196			; 000000c4H
  00ea7	68 95 00 00 00	 push	 149			; 00000095H
  00eac	68 80 00 00 00	 push	 128			; 00000080H
  00eb1	68 ff 00 00 00	 push	 255			; 000000ffH
  00eb6	e8 00 00 00 00	 call	 ?_ARGB@@YAKEEEE@Z	; _ARGB
  00ebb	83 c4 10	 add	 esp, 16			; 00000010H
  00ebe	50		 push	 eax
  00ebf	6a 0a		 push	 10			; 0000000aH
  00ec1	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$4[ebp]
  00ec7	50		 push	 eax
  00ec8	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty
  00ecd	83 c4 18	 add	 esp, 24			; 00000018H

; 6159 : 					TNotice::SendNoticeToUser( aIndex, &pNotice );

  00ed0	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$4[ebp]
  00ed6	50		 push	 eax
  00ed7	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00eda	51		 push	 ecx
  00edb	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser
  00ee0	83 c4 08	 add	 esp, 8

; 6160 : 				#else
; 6161 : 					GCServerMsgStringSend (lMsg.Get(1211), aIndex, 0);		// " 40      ."
; 6162 : 				#endif
; 6163 : 
; 6164 : 					pResult.Result = 0x00;

  00ee3	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 6165 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00ee7	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00eeb	50		 push	 eax
  00eec	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00eef	51		 push	 ecx
  00ef0	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00ef3	52		 push	 edx
  00ef4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00ef9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6166 : 					return FALSE;

  00efc	33 c0		 xor	 eax, eax
  00efe	e9 e0 05 00 00	 jmp	 $LN1@CGItemDrop
$LN62@CGItemDrop:

; 6167 : 
; 6168 : 				}
; 6169 : 	#endif
; 6170 : 			}	

  00f03	e9 4c 04 00 00	 jmp	 $LN75@CGItemDrop
$LN59@CGItemDrop:

; 6171 : #endif
; 6172 : #ifdef FRIENDSHIP_EVENT_RING_BOX_20040211		//   -    80   
; 6173 : 			else if( type == MAKE_ITEMNUM(13,20) && level == 2)

  00f08	6a 14		 push	 20			; 00000014H
  00f0a	6a 0d		 push	 13			; 0000000dH
  00f0c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00f11	83 c4 08	 add	 esp, 8
  00f14	39 45 dc	 cmp	 DWORD PTR _type$18[ebp], eax
  00f17	0f 85 e1 00 00
	00		 jne	 $LN63@CGItemDrop
  00f1d	83 7d d8 02	 cmp	 DWORD PTR _level$17[ebp], 2
  00f21	0f 85 d7 00 00
	00		 jne	 $LN63@CGItemDrop

; 6174 : 			{
; 6175 : 				//   .
; 6176 : 	#ifndef FOR_ONAIR	//    
; 6177 : 				if (gObj[aIndex].Level >= 80) 

  00f27	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f2e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f34	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00f3c	83 fa 50	 cmp	 edx, 80			; 00000050H
  00f3f	7c 2f		 jl	 SHORT $LN65@CGItemDrop

; 6178 : 	#endif
; 6179 : 				{
; 6180 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00f41	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00f44	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00f48	51		 push	 ecx
  00f49	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00f4c	52		 push	 edx
  00f4d	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00f52	83 c4 08	 add	 esp, 8

; 6181 : 					FriendShipItemBoxOpen (&gObj[aIndex]);		

  00f55	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f5c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f62	50		 push	 eax
  00f63	e8 00 00 00 00	 call	 ?FriendShipItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z ; FriendShipItemBoxOpen
  00f68	83 c4 04	 add	 esp, 4

; 6182 : 				}

  00f6b	e9 89 00 00 00	 jmp	 $LN66@CGItemDrop
$LN65@CGItemDrop:

; 6183 : 	#ifndef FOR_ONAIR
; 6184 : 				else 
; 6185 : 				{
; 6186 : 
; 6187 : 				#ifdef MODIFY_NOTICE_20040325
; 6188 : 					PMSG_NOTICE	pNotice;
; 6189 : 					TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, lMsg.Get(1215) );

  00f70	68 bf 04 00 00	 push	 1215			; 000004bfH
  00f75	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00f7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00f80	50		 push	 eax
  00f81	6a 0a		 push	 10			; 0000000aH
  00f83	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  00f89	50		 push	 eax
  00f8a	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00f8f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6190 : 					TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_BLUE);

  00f92	6a 14		 push	 20			; 00000014H
  00f94	6a 00		 push	 0
  00f96	6a 01		 push	 1
  00f98	68 c4 00 00 00	 push	 196			; 000000c4H
  00f9d	68 95 00 00 00	 push	 149			; 00000095H
  00fa2	68 80 00 00 00	 push	 128			; 00000080H
  00fa7	68 ff 00 00 00	 push	 255			; 000000ffH
  00fac	e8 00 00 00 00	 call	 ?_ARGB@@YAKEEEE@Z	; _ARGB
  00fb1	83 c4 10	 add	 esp, 16			; 00000010H
  00fb4	50		 push	 eax
  00fb5	6a 0a		 push	 10			; 0000000aH
  00fb7	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  00fbd	50		 push	 eax
  00fbe	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty
  00fc3	83 c4 18	 add	 esp, 24			; 00000018H

; 6191 : 					TNotice::SendNoticeToUser( aIndex, &pNotice );

  00fc6	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  00fcc	50		 push	 eax
  00fcd	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00fd0	51		 push	 ecx
  00fd1	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser
  00fd6	83 c4 08	 add	 esp, 8

; 6192 : 				#else
; 6193 : 					GCServerMsgStringSend (lMsg.Get(1215), aIndex, 0);		// " 80      ."
; 6194 : 				#endif
; 6195 : 
; 6196 : 					pResult.Result = 0x00;

  00fd9	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 6197 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00fdd	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00fe1	50		 push	 eax
  00fe2	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00fe5	51		 push	 ecx
  00fe6	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00fe9	52		 push	 edx
  00fea	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00fef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6198 : 					return FALSE;

  00ff2	33 c0		 xor	 eax, eax
  00ff4	e9 ea 04 00 00	 jmp	 $LN1@CGItemDrop
$LN66@CGItemDrop:

; 6199 : 				}
; 6200 : 	#endif
; 6201 : 			}	

  00ff9	e9 56 03 00 00	 jmp	 $LN75@CGItemDrop
$LN63@CGItemDrop:

; 6202 : #endif
; 6203 : #ifdef MU_CHN_THANKS_RING_EVENT_20040908		//   -   
; 6204 : 			else if( type == MAKE_ITEMNUM(13,20) && level == 3)
; 6205 : 			{
; 6206 : 				pResult.Result = 0x00;
; 6207 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6208 : 				return FALSE;
; 6209 : 			}
; 6210 : #endif
; 6211 : #ifdef ADD_NEW_MAP_KALIMA_20040518				//     .
; 6212 : 			else if( type == MAKE_ITEMNUM(14, 28) ) {

  00ffe	6a 1c		 push	 28			; 0000001cH
  01000	6a 0e		 push	 14			; 0000000eH
  01002	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01007	83 c4 08	 add	 esp, 8
  0100a	39 45 dc	 cmp	 DWORD PTR _type$18[ebp], eax
  0100d	0f 85 b7 00 00
	00		 jne	 $LN67@CGItemDrop

; 6213 : 
; 6214 : #ifdef MODIFY_KALIMA_KUNDUNMARK_DROP_01_20040906
; 6215 : 				if (g_KalimaGate.CreateKalimaGate(aIndex, level, lpMsg->px, lpMsg->py)) {

  01013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01016	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0101a	51		 push	 ecx
  0101b	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0101e	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  01022	50		 push	 eax
  01023	0f b6 4d d8	 movzx	 ecx, BYTE PTR _level$17[ebp]
  01027	51		 push	 ecx
  01028	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0102b	52		 push	 edx
  0102c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  01031	e8 00 00 00 00	 call	 ?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z ; CKalimaGate::CreateKalimaGate
  01036	85 c0		 test	 eax, eax
  01038	74 6b		 je	 SHORT $LN69@CGItemDrop

; 6216 : #else
; 6217 : 				if (g_KalimaGate.CreateKalimaGate(aIndex, lpMsg->px, lpMsg->py)) {
; 6218 : #endif
; 6219 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6220 : 					LogAddTD("[Kalima] [%s][%s] Success to Make Kalima Gate (Lost Kalima Map Serial:%u)", 
; 6221 : #else
; 6222 : 					LogAddTD("[Kalima] [%s][%s] Success to Make Kalima Gate (Lost Kalima Map Serial:%d)", 

  0103a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01041	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  01044	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  01048	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  0104e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01054	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  0105b	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0105e	51		 push	 ecx
  0105f	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  01066	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0106b	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0106f	51		 push	 ecx
  01070	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  01077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0107c	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  01080	51		 push	 ecx
  01081	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Ma@
  01086	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0108c	83 c4 10	 add	 esp, 16			; 00000010H

; 6223 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6224 : 						gObj[aIndex].AccountID, 
; 6225 : 						gObj[aIndex].Name,
; 6226 : 						gObj[aIndex].pInventory[lpMsg->Ipos].m_Number
; 6227 : 						);
; 6228 : 					
; 6229 : 					//   .
; 6230 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  0108f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01092	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  01096	51		 push	 ecx
  01097	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0109a	52		 push	 edx
  0109b	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  010a0	83 c4 08	 add	 esp, 8

; 6231 : 				}

  010a3	eb 20		 jmp	 SHORT $LN70@CGItemDrop
$LN69@CGItemDrop:

; 6232 : 				else {
; 6233 : 					pResult.Result = 0x00;

  010a5	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 6234 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  010a9	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  010ad	50		 push	 eax
  010ae	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  010b1	51		 push	 ecx
  010b2	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  010b5	52		 push	 edx
  010b6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  010bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6235 : 					return FALSE;

  010be	33 c0		 xor	 eax, eax
  010c0	e9 1e 04 00 00	 jmp	 $LN1@CGItemDrop
$LN70@CGItemDrop:

; 6236 : 				}
; 6237 : 			}

  010c5	e9 8a 02 00 00	 jmp	 $LN75@CGItemDrop
$LN67@CGItemDrop:

; 6238 : #endif
; 6239 : #ifdef JAPAN_1ST_ANIVERSARY_BOX_20040531		//    1   (  +1 ~ +5  )
; 6240 : 			else if( type == MAKE_ITEMNUM(14,20) && CHECK_LIMIT(level-1, 5)) {
; 6241 : 				//  ( +n)
; 6242 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 6243 : 				Japan1StAnivBoxOpen (&gObj[aIndex], level);
; 6244 : 			}
; 6245 : #endif
; 6246 : 
; 6247 : #ifdef ADD_NEW_MERCENARY_FOR_CASTLE_01_20041214
; 6248 : 			//    . ( )
; 6249 : 			else if( type == MAKE_ITEMNUM(13,7) )
; 6250 : 			{
; 6251 : 				INT iMercenaryTypeIndex = 0;
; 6252 : 
; 6253 : 				if( level == 0 )
; 6254 : 				{
; 6255 : 					iMercenaryTypeIndex = NPC_INDEX_BOWMAN;
; 6256 : 				}
; 6257 : 				else if( level == 1 )
; 6258 : 				{
; 6259 : 					iMercenaryTypeIndex = NPC_INDEX_SPEARMAN;
; 6260 : 				}
; 6261 : 
; 6262 : 				if( g_CsNPC_Mercenary.CreateMercenary(aIndex, iMercenaryTypeIndex, lpMsg->px, lpMsg->py) )
; 6263 : 				{
; 6264 : 					//      .
; 6265 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 6266 : 				}
; 6267 : 				else 
; 6268 : 				{
; 6269 : 					pResult.Result = 0x00;
; 6270 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6271 : 					return FALSE;
; 6272 : 				}
; 6273 : 
; 6274 : 			}
; 6275 : #endif
; 6276 : 
; 6277 : #ifdef ADD_NEW_WEAPON_FOR_CASTLE_01_20041116
; 6278 : 			else if( type == MAKE_ITEMNUM(13,11) ) //   ,  .
; 6279 : 			{
; 6280 : 				BOOL bSuccess = FALSE;
; 6281 : 
; 6282 : 				//  
; 6283 : 				if( level == 0 )
; 6284 : 				{
; 6285 : 					bSuccess = g_CsNPC_Guardian.CreateGuardian( aIndex );
; 6286 : 				}
; 6287 : 				//   
; 6288 : 				else if( level == 1 )
; 6289 : 				{
; 6290 : #ifdef CASTLE_NPC_LIFESTONE_WORK_20041208
; 6291 : 					bSuccess = g_CsNPC_LifeStone.CreateLifeStone( aIndex );
; 6292 : #endif
; 6293 : 				}
; 6294 : 				
; 6295 : 				if( bSuccess == TRUE )
; 6296 : 				{
; 6297 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 6298 : 				}
; 6299 : 				else 
; 6300 : 				{
; 6301 : 					pResult.Result = 0x00;
; 6302 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6303 : 					return FALSE;
; 6304 : 				}
; 6305 : 			}
; 6306 : #endif
; 6307 : 
; 6308 : #ifdef UPDATE_GM_FUNCTION_20070228	//  GM  
; 6309 : 			else if( type == MAKE_ITEMNUM( 14, 52 ) )
; 6310 : 			{
; 6311 : 				// GM   
; 6312 : 				gObjInventoryDeleteItem( aIndex, lpMsg->Ipos );
; 6313 : 
; 6314 : 				GMPresentBoxItemBagOpen( lpObj );
; 6315 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6316 : 				LogAddTD("[%s][%s][%d]%d/%d Used GM Present Box Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6317 : #else
; 6318 : 				LogAddTD("[%s][%s][%d]%d/%d Used GM Present Box Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6319 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6320 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3 );
; 6321 : 			}
; 6322 : #endif
; 6323 : #ifdef PCBANG_POINT_SYSTEM_20070206		//   
; 6324 : 			else if( type == MAKE_ITEMNUM( 14, 55 ) && level == 0 )
; 6325 : 			{
; 6326 : 				//   .
; 6327 : 				gObjInventoryDeleteItem( aIndex, lpMsg->Ipos );	
; 6328 : 				
; 6329 : 				BoxOfGreenChaosItemBagOpen( &gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y );
; 6330 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6331 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of Green Chaos Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6332 : #else
; 6333 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of Green Chaos Item Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6334 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6335 : 				     lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 6336 : 			}
; 6337 : 			else if( type == MAKE_ITEMNUM( 14, 56 ) && level == 0 )
; 6338 : 			{
; 6339 : 				//   .
; 6340 : 				gObjInventoryDeleteItem( aIndex, lpMsg->Ipos );	
; 6341 : 				
; 6342 : 				BoxOfRedChaosItemBagOpen( &gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y );
; 6343 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6344 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of Red Chaos Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6345 : #else
; 6346 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of Red Chaos Item Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6347 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6348 : 				     lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 6349 : 			}
; 6350 : 			else if( type == MAKE_ITEMNUM( 14, 57 ) && level == 0 )
; 6351 : 			{
; 6352 : 				//   .
; 6353 : 				gObjInventoryDeleteItem( aIndex, lpMsg->Ipos );	
; 6354 : 				
; 6355 : 				BoxOfPurpleChaosItemBagOpen( &gObj[aIndex], lpObj->MapNumber, lpObj->X, lpObj->Y );
; 6356 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6357 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of Purple Chaos Item Serial:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6358 : #else
; 6359 : 				LogAddTD("[%s][%s][%d]%d/%d Used Box Of Purple Chaos Item Serial:%d (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",
; 6360 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 6361 : 				     lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y, s_num, szItemName, type, level, Option1, Option2, Option3);
; 6362 : 			}
; 6363 : #endif
; 6364 : 
; 6365 : 
; 6366 : 			else
; 6367 : 			{	//
; 6368 : 				//    ??
; 6369 : 				int aAntiLootIndex = aIndex;

  010ca	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  010cd	89 85 60 fd ff
	ff		 mov	 DWORD PTR _aAntiLootIndex$2[ebp], eax

; 6370 : 
; 6371 : 				if( ( type >= MAKE_ITEMNUM(14, 0) && type <= MAKE_ITEMNUM(14, 10) ) || 
; 6372 : 					type == MAKE_ITEMNUM(4, 7) || 

  010d3	6a 00		 push	 0
  010d5	6a 0e		 push	 14			; 0000000eH
  010d7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  010dc	83 c4 08	 add	 esp, 8
  010df	39 45 dc	 cmp	 DWORD PTR _type$18[ebp], eax
  010e2	7c 11		 jl	 SHORT $LN73@CGItemDrop
  010e4	6a 0a		 push	 10			; 0000000aH
  010e6	6a 0e		 push	 14			; 0000000eH
  010e8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  010ed	83 c4 08	 add	 esp, 8
  010f0	39 45 dc	 cmp	 DWORD PTR _type$18[ebp], eax
  010f3	7e 22		 jle	 SHORT $LN72@CGItemDrop
$LN73@CGItemDrop:
  010f5	6a 07		 push	 7
  010f7	6a 04		 push	 4
  010f9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  010fe	83 c4 08	 add	 esp, 8
  01101	39 45 dc	 cmp	 DWORD PTR _type$18[ebp], eax
  01104	74 11		 je	 SHORT $LN72@CGItemDrop
  01106	6a 0f		 push	 15			; 0000000fH
  01108	6a 04		 push	 4
  0110a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0110f	83 c4 08	 add	 esp, 8
  01112	39 45 dc	 cmp	 DWORD PTR _type$18[ebp], eax
  01115	75 0a		 jne	 SHORT $LN71@CGItemDrop
$LN72@CGItemDrop:

; 6373 : 					type == MAKE_ITEMNUM(4, 15) )
; 6374 : 				{
; 6375 : 					aAntiLootIndex = -1;

  01117	c7 85 60 fd ff
	ff ff ff ff ff	 mov	 DWORD PTR _aAntiLootIndex$2[ebp], -1
$LN71@CGItemDrop:

; 6376 : 				}
; 6377 : 
; 6378 : 				
; 6379 : #ifdef DARKLORD_WORK
; 6380 : 	#ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 6381 : 				if( MapC[map_num].ItemDrop(type, level, dur, lpMsg->px, lpMsg->py, Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp, ItemEffectEx, SocketOption, SocketBonusOption ) == TRUE )
; 6382 : 	#else
; 6383 : 		#ifdef ADD_380ITEM_NEWOPTION_20060711
; 6384 : 				if( MapC[map_num].ItemDrop(type, level, dur, lpMsg->px, lpMsg->py, Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp, ItemEffectEx) == TRUE )
; 6385 : 		#else
; 6386 : 				if( MapC[map_num].ItemDrop(type, level, dur, lpMsg->px, lpMsg->py, Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp) == TRUE )

  01121	8b 45 c0	 mov	 eax, DWORD PTR _PetExp$8[ebp]
  01124	50		 push	 eax
  01125	8b 4d c4	 mov	 ecx, DWORD PTR _PetLevel$9[ebp]
  01128	51		 push	 ecx
  01129	8b 95 60 fd ff
	ff		 mov	 edx, DWORD PTR _aAntiLootIndex$2[ebp]
  0112f	52		 push	 edx
  01130	8b 45 b8	 mov	 eax, DWORD PTR _item_number$6[ebp]
  01133	50		 push	 eax
  01134	0f b6 4d bf	 movzx	 ecx, BYTE PTR _SOption$7[ebp]
  01138	51		 push	 ecx
  01139	0f b6 55 cc	 movzx	 edx, BYTE PTR _NOption$11[ebp]
  0113d	52		 push	 edx
  0113e	0f b6 45 cd	 movzx	 eax, BYTE PTR _Option3$12[ebp]
  01142	50		 push	 eax
  01143	0f b6 4d ce	 movzx	 ecx, BYTE PTR _Option2$13[ebp]
  01147	51		 push	 ecx
  01148	0f b6 55 cf	 movzx	 edx, BYTE PTR _Option1$14[ebp]
  0114c	52		 push	 edx
  0114d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01150	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  01154	51		 push	 ecx
  01155	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  01158	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  0115c	50		 push	 eax
  0115d	51		 push	 ecx
  0115e	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _dur$16[ebp]
  01163	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01168	8b 4d d8	 mov	 ecx, DWORD PTR _level$17[ebp]
  0116b	51		 push	 ecx
  0116c	8b 55 dc	 mov	 edx, DWORD PTR _type$18[ebp]
  0116f	52		 push	 edx
  01170	69 4d e0 8c 04
	05 00		 imul	 ecx, DWORD PTR _map_num$19[ebp], 328844
  01177	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0117d	e8 00 00 00 00	 call	 ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z ; MapClass::ItemDrop
  01182	83 f8 01	 cmp	 eax, 1
  01185	0f 85 c5 01 00
	00		 jne	 $LN74@CGItemDrop

; 6387 : 		#endif // ADD_380ITEM_NEWOPTION_20060711
; 6388 : 	#endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 6389 : #else	// #ifdef DARKLORD_WORK
; 6390 : 				if( MapC[map_num].ItemDrop(type, level, dur, lpMsg->px, lpMsg->py, Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex) == TRUE )
; 6391 : #endif	// #ifdef DARKLORD_WORK
; 6392 : 				{   //   ..
; 6393 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  0118b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0118e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  01192	51		 push	 ecx
  01193	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01196	52		 push	 edx
  01197	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0119c	83 c4 08	 add	 esp, 8

; 6394 : 					pResult.Result = 0x01;

  0119f	c6 45 eb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 6395 : 					if( drop_type == 0 )

  011a3	83 7d 10 00	 cmp	 DWORD PTR _drop_type$[ebp], 0
  011a7	0f 85 d3 00 00
	00		 jne	 $LN76@CGItemDrop

; 6396 : 					{
; 6397 : #ifdef MODIFY_LOG_SYSTEM_2_3_20060828
; 6398 : 						LogAddTD(lMsg.Get(479),
; 6399 : 							lpObj->AccountID, 
; 6400 : 							lpObj->Name,
; 6401 : 							lpObj->MapNumber, 
; 6402 : 							lpObj->X, 
; 6403 : 							lpObj->Y, 
; 6404 : 							s_num, 
; 6405 : 							szItemName, 
; 6406 : 							type, 
; 6407 : 							level, 
; 6408 : 							Option1, 
; 6409 : 							Option2, 
; 6410 : 							Option3,
; 6411 : 							(int)dur,
; 6412 : 							NewOption[0],
; 6413 : 							NewOption[1],
; 6414 : 							NewOption[2],
; 6415 : 							NewOption[3],
; 6416 : 							NewOption[4],
; 6417 : 							NewOption[5],
; 6418 : 							NewOption[6],
; 6419 : 							SOption,
; 6420 : 	#ifdef MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 6421 : 							ItemEffectEx>>7,
; 6422 : 	#else
; 6423 : 							ItemEffectEx,
; 6424 : 	#endif // MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 6425 : 							ItemExOption,
; 6426 : 							ItemExLevel
; 6427 : 							);
; 6428 : #else
; 6429 : 	#ifdef EXTEND_LOG_SYSTEM_03_20060816
; 6430 : 		#ifdef ADD_380ITEM_NEWOPTION_20060711
; 6431 : 			#ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 6432 : 						LogAddTD(lMsg.Get(479),
; 6433 : 							lpObj->AccountID, 
; 6434 : 							lpObj->Name,
; 6435 : 							lpObj->MapNumber, 
; 6436 : 							lpObj->X, 
; 6437 : 							lpObj->Y, 
; 6438 : 							s_num, 
; 6439 : 							szItemName, 
; 6440 : 							type, 
; 6441 : 							level, 
; 6442 : 							dur,
; 6443 : 							Option1, 
; 6444 : 							Option2, 
; 6445 : 							Option3,
; 6446 : 							NewOption[0],
; 6447 : 							NewOption[1],
; 6448 : 							NewOption[2],
; 6449 : 							NewOption[3],
; 6450 : 							NewOption[4],
; 6451 : 							NewOption[5],
; 6452 : 							NewOption[6],
; 6453 : 							SOption,
; 6454 : 				#ifdef MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 6455 : 							ItemEffectEx>>7,
; 6456 : 				#else
; 6457 : 							ItemEffectEx,
; 6458 : 				#endif // MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 6459 : 							ItemExOption,
; 6460 : 							ItemExLevel
; 6461 : 							);
; 6462 : 			#endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 6463 : 		#endif // ADD_380ITEM_NEWOPTION_20060711
; 6464 : 	#else // EXTEND_LOG_SYSTEM_03_20060816
; 6465 : 						LogAddTD(lMsg.Get(479),

  011ad	0f b6 45 bf	 movzx	 eax, BYTE PTR _SOption$7[ebp]
  011b1	50		 push	 eax
  011b2	b9 01 00 00 00	 mov	 ecx, 1
  011b7	6b d1 06	 imul	 edx, ecx, 6
  011ba	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  011bf	50		 push	 eax
  011c0	b9 01 00 00 00	 mov	 ecx, 1
  011c5	6b d1 05	 imul	 edx, ecx, 5
  011c8	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  011cd	50		 push	 eax
  011ce	b9 01 00 00 00	 mov	 ecx, 1
  011d3	c1 e1 02	 shl	 ecx, 2
  011d6	0f b6 54 0d f0	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  011db	52		 push	 edx
  011dc	b8 01 00 00 00	 mov	 eax, 1
  011e1	6b c8 03	 imul	 ecx, eax, 3
  011e4	0f b6 54 0d f0	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  011e9	52		 push	 edx
  011ea	b8 01 00 00 00	 mov	 eax, 1
  011ef	d1 e0		 shl	 eax, 1
  011f1	0f b6 4c 05 f0	 movzx	 ecx, BYTE PTR _NewOption$[ebp+eax]
  011f6	51		 push	 ecx
  011f7	ba 01 00 00 00	 mov	 edx, 1
  011fc	c1 e2 00	 shl	 edx, 0
  011ff	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  01204	50		 push	 eax
  01205	b9 01 00 00 00	 mov	 ecx, 1
  0120a	6b d1 00	 imul	 edx, ecx, 0
  0120d	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  01212	50		 push	 eax
  01213	0f b6 4d cd	 movzx	 ecx, BYTE PTR _Option3$12[ebp]
  01217	51		 push	 ecx
  01218	0f b6 55 ce	 movzx	 edx, BYTE PTR _Option2$13[ebp]
  0121c	52		 push	 edx
  0121d	0f b6 45 cf	 movzx	 eax, BYTE PTR _Option1$14[ebp]
  01221	50		 push	 eax
  01222	8b 4d d8	 mov	 ecx, DWORD PTR _level$17[ebp]
  01225	51		 push	 ecx
  01226	8b 55 dc	 mov	 edx, DWORD PTR _type$18[ebp]
  01229	52		 push	 edx
  0122a	8d 45 84	 lea	 eax, DWORD PTR _szItemName$5[ebp]
  0122d	50		 push	 eax
  0122e	8b 4d c8	 mov	 ecx, DWORD PTR _s_num$10[ebp]
  01231	51		 push	 ecx
  01232	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01235	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  0123c	50		 push	 eax
  0123d	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01240	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  01247	52		 push	 edx
  01248	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0124b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  01252	51		 push	 ecx
  01253	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01256	83 c2 73	 add	 edx, 115		; 00000073H
  01259	52		 push	 edx
  0125a	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0125d	83 c0 68	 add	 eax, 104		; 00000068H
  01260	50		 push	 eax
  01261	68 df 01 00 00	 push	 479			; 000001dfH
  01266	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0126b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  01271	50		 push	 eax
  01272	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01278	83 c4 54	 add	 esp, 84			; 00000054H

; 6466 : 							lpObj->AccountID, 
; 6467 : 							lpObj->Name,
; 6468 : 							lpObj->MapNumber, 
; 6469 : 							lpObj->X, 
; 6470 : 							lpObj->Y, 
; 6471 : 							s_num, 
; 6472 : 							szItemName, 
; 6473 : 							type, 
; 6474 : 							level, 
; 6475 : 							Option1, 
; 6476 : 							Option2, 
; 6477 : 							Option3,
; 6478 : 							NewOption[0],
; 6479 : 							NewOption[1],
; 6480 : 							NewOption[2],
; 6481 : 							NewOption[3],
; 6482 : 							NewOption[4],
; 6483 : 							NewOption[5],
; 6484 : 							NewOption[6],
; 6485 : 							SOption
; 6486 : 							);
; 6487 : 	#endif // EXTEND_LOG_SYSTEM_03_20060816
; 6488 : #endif // MODIFY_LOG_SYSTEM_2_3_20060828
; 6489 : 					}

  0127b	e9 ce 00 00 00	 jmp	 $LN77@CGItemDrop
$LN76@CGItemDrop:

; 6490 : 					else 
; 6491 : 					{
; 6492 : #ifdef MODIFY_LOG_SYSTEM_2_3_20060828
; 6493 : 						LogAddTD(lMsg.Get(480),
; 6494 : 							lpObj->AccountID, 
; 6495 : 							lpObj->Name,
; 6496 : 							lpObj->MapNumber, 
; 6497 : 							lpObj->X, 
; 6498 : 							lpObj->Y, 
; 6499 : 							s_num, 
; 6500 : 							szItemName, 
; 6501 : 							type, 
; 6502 : 							level, 
; 6503 : 							Option1, 
; 6504 : 							Option2, 
; 6505 : 							Option3,
; 6506 : 							(int)dur,
; 6507 : 							NewOption[0],
; 6508 : 							NewOption[1],
; 6509 : 							NewOption[2],
; 6510 : 							NewOption[3],
; 6511 : 							NewOption[4],
; 6512 : 							NewOption[5],
; 6513 : 							NewOption[6],
; 6514 : 							SOption,
; 6515 : #ifdef UPDATE_ADD_LOG_20080117
; 6516 : 							ItemEffectEx>>7,
; 6517 : #else	// UPDATE_ADD_LOG_20080117
; 6518 : 							ItemEffectEx,
; 6519 : #endif	// UPDATE_ADD_LOG_20080117
; 6520 : 							ItemExOption,
; 6521 : 							ItemExLevel
; 6522 : 							);
; 6523 : #else
; 6524 : 						LogAddTD(lMsg.Get(480),

  01280	0f b6 45 bf	 movzx	 eax, BYTE PTR _SOption$7[ebp]
  01284	50		 push	 eax
  01285	b9 01 00 00 00	 mov	 ecx, 1
  0128a	6b d1 06	 imul	 edx, ecx, 6
  0128d	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  01292	50		 push	 eax
  01293	b9 01 00 00 00	 mov	 ecx, 1
  01298	6b d1 05	 imul	 edx, ecx, 5
  0129b	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  012a0	50		 push	 eax
  012a1	b9 01 00 00 00	 mov	 ecx, 1
  012a6	c1 e1 02	 shl	 ecx, 2
  012a9	0f b6 54 0d f0	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  012ae	52		 push	 edx
  012af	b8 01 00 00 00	 mov	 eax, 1
  012b4	6b c8 03	 imul	 ecx, eax, 3
  012b7	0f b6 54 0d f0	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  012bc	52		 push	 edx
  012bd	b8 01 00 00 00	 mov	 eax, 1
  012c2	d1 e0		 shl	 eax, 1
  012c4	0f b6 4c 05 f0	 movzx	 ecx, BYTE PTR _NewOption$[ebp+eax]
  012c9	51		 push	 ecx
  012ca	ba 01 00 00 00	 mov	 edx, 1
  012cf	c1 e2 00	 shl	 edx, 0
  012d2	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  012d7	50		 push	 eax
  012d8	b9 01 00 00 00	 mov	 ecx, 1
  012dd	6b d1 00	 imul	 edx, ecx, 0
  012e0	0f b6 44 15 f0	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  012e5	50		 push	 eax
  012e6	0f b6 4d cd	 movzx	 ecx, BYTE PTR _Option3$12[ebp]
  012ea	51		 push	 ecx
  012eb	0f b6 55 ce	 movzx	 edx, BYTE PTR _Option2$13[ebp]
  012ef	52		 push	 edx
  012f0	0f b6 45 cf	 movzx	 eax, BYTE PTR _Option1$14[ebp]
  012f4	50		 push	 eax
  012f5	8b 4d d8	 mov	 ecx, DWORD PTR _level$17[ebp]
  012f8	51		 push	 ecx
  012f9	8b 55 dc	 mov	 edx, DWORD PTR _type$18[ebp]
  012fc	52		 push	 edx
  012fd	8d 45 84	 lea	 eax, DWORD PTR _szItemName$5[ebp]
  01300	50		 push	 eax
  01301	8b 4d c8	 mov	 ecx, DWORD PTR _s_num$10[ebp]
  01304	51		 push	 ecx
  01305	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01308	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  0130f	50		 push	 eax
  01310	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01313	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  0131a	52		 push	 edx
  0131b	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0131e	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  01325	51		 push	 ecx
  01326	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01329	83 c2 73	 add	 edx, 115		; 00000073H
  0132c	52		 push	 edx
  0132d	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01330	83 c0 68	 add	 eax, 104		; 00000068H
  01333	50		 push	 eax
  01334	68 e0 01 00 00	 push	 480			; 000001e0H
  01339	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0133e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  01344	50		 push	 eax
  01345	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0134b	83 c4 54	 add	 esp, 84			; 00000054H
$LN77@CGItemDrop:

; 6525 : 							lpObj->AccountID, 
; 6526 : 							lpObj->Name,
; 6527 : 							lpObj->MapNumber, 
; 6528 : 							lpObj->X, 
; 6529 : 							lpObj->Y, 
; 6530 : 							s_num, 
; 6531 : 							szItemName, 
; 6532 : 							type, 
; 6533 : 							level, 
; 6534 : 							Option1, 
; 6535 : 							Option2, 
; 6536 : 							Option3,
; 6537 : 							NewOption[0],
; 6538 : 							NewOption[1],
; 6539 : 							NewOption[2],
; 6540 : 							NewOption[3],
; 6541 : 							NewOption[4],
; 6542 : 							NewOption[5],
; 6543 : 							NewOption[6],
; 6544 : 							SOption);
; 6545 : #endif
; 6546 : 
; 6547 : 					}
; 6548 : 
; 6549 : 
; 6550 : 				}

  0134e	eb 04		 jmp	 SHORT $LN75@CGItemDrop
$LN74@CGItemDrop:

; 6551 : 				else
; 6552 : 				{
; 6553 : 					//  .
; 6554 : 					pResult.Result = 0x00;

  01350	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN75@CGItemDrop:

; 6555 : 				}
; 6556 : 			}
; 6557 : 		}

  01354	eb 1e		 jmp	 SHORT $LN30@CGItemDrop
$LN29@CGItemDrop:

; 6558 : 		else {
; 6559 : 			LogAdd(lMsg.Get(481));

  01356	68 e1 01 00 00	 push	 481			; 000001e1H
  0135b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01360	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  01366	50		 push	 eax
  01367	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0136d	83 c4 04	 add	 esp, 4

; 6560 : 			pResult.Result = 0x00;

  01370	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN30@CGItemDrop:

; 6561 : 		}
; 6562 : 		
; 6563 : 	}
; 6564 : 	
; 6565 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  01374	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  01378	50		 push	 eax
  01379	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0137c	51		 push	 ecx
  0137d	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01380	52		 push	 edx
  01381	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01386	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6566 : 
; 6567 : 	if( CopyItem )

  01389	83 7d f8 00	 cmp	 DWORD PTR _CopyItem$[ebp], 0
  0138d	74 0c		 je	 SHORT $LN78@CGItemDrop

; 6568 : 	{
; 6569 : 		GCItemListSend(aIndex);

  0138f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01392	50		 push	 eax
  01393	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  01398	83 c4 04	 add	 esp, 4
$LN78@CGItemDrop:

; 6570 : 	}
; 6571 : 
; 6572 : 	if( pResult.Result == 0x01 )

  0139b	0f b6 45 eb	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  0139f	83 f8 01	 cmp	 eax, 1
  013a2	0f 85 37 01 00
	00		 jne	 $LN80@CGItemDrop

; 6573 : 	{
; 6574 : 		//    
; 6575 : 		if( lpMsg->Ipos < MAX_EQUIPMENT ) 

  013a8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  013ab	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  013af	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  013b2	0f 8d 27 01 00
	00		 jge	 $LN80@CGItemDrop

; 6576 : 		{
; 6577 : 			if( lpMsg->Ipos == EQUIPMENT_RING_RIGHT || lpMsg->Ipos == EQUIPMENT_RING_LEFT)

  013b8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  013bb	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  013bf	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  013c2	74 0c		 je	 SHORT $LN82@CGItemDrop
  013c4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  013c7	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  013cb	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  013ce	75 0e		 jne	 SHORT $LN81@CGItemDrop
$LN82@CGItemDrop:

; 6578 : 			{
; 6579 : 				gObjUseSkill.SkillChangeUse(aIndex);				

  013d0	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  013d3	50		 push	 eax
  013d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  013d9	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN81@CGItemDrop:

; 6580 : 			}
; 6581 : 			gObjMakePreviewCharSet(aIndex);

  013de	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  013e1	50		 push	 eax
  013e2	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  013e7	83 c4 04	 add	 esp, 4

; 6582 : 			
; 6583 : 			PMSG_USEREQUIPMENTCHANGED	pChange;
; 6584 : 			
; 6585 : 			PHeadSetB((LPBYTE)&pChange, 0x25, sizeof( pChange ));

  013ea	6a 0a		 push	 10			; 0000000aH
  013ec	6a 25		 push	 37			; 00000025H
  013ee	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR _pChange$1[ebp]
  013f4	50		 push	 eax
  013f5	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  013fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6586 : 
; 6587 : 			pChange.NumberH    = HIBYTE( aIndex );

  013fd	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01400	c1 e8 08	 shr	 eax, 8
  01403	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01408	88 85 57 fd ff
	ff		 mov	 BYTE PTR _pChange$1[ebp+3], al

; 6588 : 			pChange.NumberL	   = LOBYTE( aIndex );

  0140e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01411	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01416	88 85 58 fd ff
	ff		 mov	 BYTE PTR _pChange$1[ebp+4], al

; 6589 : 						
; 6590 : 			//pChange.ItemInfo[0] = (BYTE)lpObj->pInventory[lpMsg->Ipos].m_Type;
; 6591 : 			ItemByteConvert(pChange.ItemInfo, lpObj->pInventory[lpMsg->Ipos]);

  0141c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0141f	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  01423	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  01429	8b 45 e4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0142c	8b b0 5c 0c 00
	00		 mov	 esi, DWORD PTR [eax+3164]
  01432	03 f2		 add	 esi, edx
  01434	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0143a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0143f	8b fc		 mov	 edi, esp
  01441	f3 a5		 rep movsd
  01443	8d 8d 59 fd ff
	ff		 lea	 ecx, DWORD PTR _pChange$1[ebp+5]
  01449	51		 push	 ecx
  0144a	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  0144f	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 6592 : 			pChange.ItemInfo[1] = lpMsg->Ipos<<4;

  01455	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01458	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0145c	c1 e1 04	 shl	 ecx, 4
  0145f	ba 01 00 00 00	 mov	 edx, 1
  01464	c1 e2 00	 shl	 edx, 0
  01467	88 8c 15 59 fd
	ff ff		 mov	 BYTE PTR _pChange$1[ebp+edx+5], cl

; 6593 : 			pChange.ItemInfo[1]|= LevelSmallConvert(aIndex, lpMsg->Ipos)&0x0F;

  0146e	be 01 00 00 00	 mov	 esi, 1
  01473	c1 e6 00	 shl	 esi, 0
  01476	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01479	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0147d	51		 push	 ecx
  0147e	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01481	52		 push	 edx
  01482	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  01487	83 c4 08	 add	 esp, 8
  0148a	0f b6 c0	 movzx	 eax, al
  0148d	83 e0 0f	 and	 eax, 15			; 0000000fH
  01490	0f b6 8c 35 59
	fd ff ff	 movzx	 ecx, BYTE PTR _pChange$1[ebp+esi+5]
  01498	0b c8		 or	 ecx, eax
  0149a	ba 01 00 00 00	 mov	 edx, 1
  0149f	c1 e2 00	 shl	 edx, 0
  014a2	88 8c 15 59 fd
	ff ff		 mov	 BYTE PTR _pChange$1[ebp+edx+5], cl

; 6594 : 
; 6595 : 			
; 6596 : 			DataSend(aIndex, (LPBYTE)&pChange, pChange.h.size);

  014a9	0f b6 85 55 fd
	ff ff		 movzx	 eax, BYTE PTR _pChange$1[ebp+1]
  014b0	50		 push	 eax
  014b1	8d 8d 54 fd ff
	ff		 lea	 ecx, DWORD PTR _pChange$1[ebp]
  014b7	51		 push	 ecx
  014b8	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  014bb	52		 push	 edx
  014bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  014c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6597 : 			MsgSendV2(lpObj, (LPBYTE)&pChange, pChange.h.size);

  014c4	0f b6 85 55 fd
	ff ff		 movzx	 eax, BYTE PTR _pChange$1[ebp+1]
  014cb	50		 push	 eax
  014cc	8d 8d 54 fd ff
	ff		 lea	 ecx, DWORD PTR _pChange$1[ebp]
  014d2	51		 push	 ecx
  014d3	8b 55 e4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  014d6	52		 push	 edx
  014d7	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  014dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN80@CGItemDrop:

; 6598 : 		}
; 6599 : 	}
; 6600 : 	return pResult.Result;

  014df	0f b6 45 eb	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
$LN1@CGItemDrop:

; 6601 : }

  014e3	5f		 pop	 edi
  014e4	5e		 pop	 esi
  014e5	5b		 pop	 ebx
  014e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014e9	33 cd		 xor	 ecx, ebp
  014eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  014f0	8b e5		 mov	 esp, ebp
  014f2	5d		 pop	 ebp
  014f3	c3		 ret	 0
?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ENDP	; CGItemDropRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCItemInventoryPutSend@@YAXHEEE@Z
_TEXT	SEGMENT
_pResult$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_iteminfo1$ = 16					; size = 1
_iteminfo2$ = 20					; size = 1
?GCItemInventoryPutSend@@YAXHEEE@Z PROC			; GCItemInventoryPutSend, COMDAT

; 4343 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4344 : 	PMSG_ITEMGETRESULT	pResult;
; 4345 : 	pResult.h.c        = PMHCE_BYTE;

  00013	c6 45 f0 c3	 mov	 BYTE PTR _pResult$[ebp], 195 ; 000000c3H

; 4346 : 	pResult.h.headcode = 0x22;

  00017	c6 45 f2 22	 mov	 BYTE PTR _pResult$[ebp+2], 34 ; 00000022H

; 4347 : 	pResult.h.size     = sizeof( pResult );

  0001b	c6 45 f1 09	 mov	 BYTE PTR _pResult$[ebp+1], 9

; 4348 : 	pResult.result     = result;

  0001f	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00022	88 45 f3	 mov	 BYTE PTR _pResult$[ebp+3], al

; 4349 : 	pResult.Data[0]	   = iteminfo1;

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	6b c8 00	 imul	 ecx, eax, 0
  0002d	8a 55 10	 mov	 dl, BYTE PTR _iteminfo1$[ebp]
  00030	88 54 0d f4	 mov	 BYTE PTR _pResult$[ebp+ecx+4], dl

; 4350 : 	pResult.Data[1]	   = iteminfo2;	

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	c1 e0 00	 shl	 eax, 0
  0003c	8a 4d 14	 mov	 cl, BYTE PTR _iteminfo2$[ebp]
  0003f	88 4c 05 f4	 mov	 BYTE PTR _pResult$[ebp+eax+4], cl

; 4351 : 	pResult.h.size	  -= 2;

  00043	0f b6 45 f1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00047	83 e8 02	 sub	 eax, 2
  0004a	88 45 f1	 mov	 BYTE PTR _pResult$[ebp+1], al

; 4352 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0004d	0f b6 45 f1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00051	50		 push	 eax
  00052	8d 4d f0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4353 : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?GCItemInventoryPutSend@@YAXHEEE@Z ENDP			; GCItemInventoryPutSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGTradeCancelButtonRecv@@YAXH@Z
_TEXT	SEGMENT
_number$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?CGTradeCancelButtonRecv@@YAXH@Z PROC			; CGTradeCancelButtonRecv, COMDAT

; 9641 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9642 : 	int number = gObj[aIndex].TargetNumber;

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  0001e	89 55 fc	 mov	 DWORD PTR _number$[ebp], edx

; 9643 : 	
; 9644 : 	/*
; 9645 : 	//  ..
; 9646 : 	if( gObj[aIndex].CloseType != -1 )
; 9647 : 	{
; 9648 : 		return;
; 9649 : 	}
; 9650 : 	*/
; 9651 : 	
; 9652 : 	//    .
; 9653 : 	/*
; 9654 : 	if( gObj[aIndex].m_IfState.state != I_TRADE )
; 9655 : 	{
; 9656 : 		CGTradeResult(aIndex, 0x00);
; 9657 : 		CGTradeResult(number, 0x00);
; 9658 : 		return;
; 9659 : 	}
; 9660 : 	
; 9661 : 	//    .
; 9662 : 	if( gObj[number].m_IfState.state != I_TRADE )
; 9663 : 	{
; 9664 : 		CGTradeResult(aIndex, 0x00);
; 9665 : 		CGTradeResult(number, 0x00);
; 9666 : 		return;
; 9667 : 	}
; 9668 : 	*/
; 9669 : 	
; 9670 : 	gObjTradeCancel(aIndex);

  00021	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel
  0002a	83 c4 04	 add	 esp, 4

; 9671 : 	CGTradeResult(aIndex, 0x00);

  0002d	6a 00		 push	 0
  0002f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  00038	83 c4 08	 add	 esp, 8

; 9672 : 
; 9673 : 	//  .
; 9674 : 	if( number >= 0 ) 

  0003b	83 7d fc 00	 cmp	 DWORD PTR _number$[ebp], 0
  0003f	7c 1a		 jl	 SHORT $LN1@CGTradeCan

; 9675 : 	{
; 9676 : 		gObjTradeCancel(number);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _number$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel
  0004a	83 c4 04	 add	 esp, 4

; 9677 : 		CGTradeResult(number, 0x00);

  0004d	6a 00		 push	 0
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _number$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  00058	83 c4 08	 add	 esp, 8
$LN1@CGTradeCan:

; 9678 : 	}
; 9679 : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?CGTradeCancelButtonRecv@@YAXH@Z ENDP			; CGTradeCancelButtonRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGTradeResult@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?CGTradeResult@@YAXHE@Z PROC				; CGTradeResult, COMDAT

; 9684 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9685 : 	PMSG_TRADE_RESULT	pMsg;
; 9686 : 
; 9687 : 	PHeadSetB((LPBYTE)&pMsg, 0x3D, sizeof( pMsg ));

  00009	6a 04		 push	 4
  0000b	6a 3d		 push	 61			; 0000003dH
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9688 : 	pMsg.Result		= result;

  00019	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  0001c	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 9689 : 	
; 9690 : 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001f	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00023	50		 push	 eax
  00024	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9691 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?CGTradeResult@@YAXHE@Z ENDP				; CGTradeResult
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCTradeOtherDel@@YAHHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_tradeindex$ = 12					; size = 1
?GCTradeOtherDel@@YAHHE@Z PROC				; GCTradeOtherDel, COMDAT

; 9433 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9434 : 	PMSG_TRADE_OTHER_DEL pMsg;
; 9435 : 
; 9436 : 	PHeadSetB((LPBYTE)&pMsg, 0x38, sizeof( pMsg ));

  00009	6a 04		 push	 4
  0000b	6a 38		 push	 56			; 00000038H
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9437 : 
; 9438 : 	pMsg.TradeItemIndex = tradeindex;

  00019	8a 45 0c	 mov	 al, BYTE PTR _tradeindex$[ebp]
  0001c	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 9439 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001f	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00023	50		 push	 eax
  00024	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9440 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?GCTradeOtherDel@@YAHHE@Z ENDP				; GCTradeOtherDel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCTradeOtherAdd@@YAHHEEEEEE@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_tradeindex$ = 12					; size = 1
_iteminfo1$ = 16					; size = 1
_iteminfo2$ = 20					; size = 1
_iteminfo3$ = 24					; size = 1
_iteminfo4$ = 28					; size = 1
_iteminfo5$ = 32					; size = 1
?GCTradeOtherAdd@@YAHHEEEEEE@Z PROC			; GCTradeOtherAdd, COMDAT

; 9449 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 9450 : 	PMSG_TRADE_OTHER_MOVE	pMsg;
; 9451 : 
; 9452 : 	PHeadSetB((LPBYTE)&pMsg, 0x39, sizeof( pMsg ));

  00013	6a 09		 push	 9
  00015	6a 39		 push	 57			; 00000039H
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9453 : 
; 9454 : 	pMsg.TradeItemIndex = tradeindex;

  00023	8a 45 0c	 mov	 al, BYTE PTR _tradeindex$[ebp]
  00026	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 9455 : 
; 9456 : #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_03_20080704
; 9457 : 	pMsg.ItemInfo[0] = iteminfo[0];
; 9458 : 	pMsg.ItemInfo[1] = iteminfo[1];
; 9459 : 	pMsg.ItemInfo[2] = iteminfo[2];
; 9460 : 	pMsg.ItemInfo[3] = iteminfo[3];
; 9461 : 	pMsg.ItemInfo[4] = iteminfo[4];
; 9462 : 	pMsg.ItemInfo[5] = iteminfo[5];
; 9463 : 	pMsg.ItemInfo[6] = iteminfo[6];
; 9464 : 	pMsg.ItemInfo[7] = iteminfo[7];
; 9465 : 	pMsg.ItemInfo[8] = iteminfo[8];
; 9466 : 	pMsg.ItemInfo[9] = iteminfo[9];
; 9467 : 	pMsg.ItemInfo[10] = iteminfo[10];
; 9468 : 	pMsg.ItemInfo[11] = iteminfo[11];
; 9469 : #else
; 9470 : 	#ifdef ITEM_INDEX_EXTEND_20050706
; 9471 : 	pMsg.ItemInfo[0] = iteminfo[0];
; 9472 : 	pMsg.ItemInfo[1] = iteminfo[1];
; 9473 : 	pMsg.ItemInfo[2] = iteminfo[2];
; 9474 : 	pMsg.ItemInfo[3] = iteminfo[3];
; 9475 : 	pMsg.ItemInfo[4] = iteminfo[4];
; 9476 : 	pMsg.ItemInfo[5] = iteminfo[5];
; 9477 : 	pMsg.ItemInfo[6] = iteminfo[6];
; 9478 : 	#else
; 9479 : 	pMsg.ItemInfo[0] = iteminfo1;

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	6b c8 00	 imul	 ecx, eax, 0
  00031	8a 55 10	 mov	 dl, BYTE PTR _iteminfo1$[ebp]
  00034	88 54 0d f4	 mov	 BYTE PTR _pMsg$[ebp+ecx+4], dl

; 9480 : 	pMsg.ItemInfo[1] = iteminfo2;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	c1 e0 00	 shl	 eax, 0
  00040	8a 4d 14	 mov	 cl, BYTE PTR _iteminfo2$[ebp]
  00043	88 4c 05 f4	 mov	 BYTE PTR _pMsg$[ebp+eax+4], cl

; 9481 : 	pMsg.ItemInfo[2] = iteminfo3;

  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	d1 e0		 shl	 eax, 1
  0004e	8a 4d 18	 mov	 cl, BYTE PTR _iteminfo3$[ebp]
  00051	88 4c 05 f4	 mov	 BYTE PTR _pMsg$[ebp+eax+4], cl

; 9482 : 	pMsg.ItemInfo[3] = iteminfo4;

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	6b c8 03	 imul	 ecx, eax, 3
  0005d	8a 55 1c	 mov	 dl, BYTE PTR _iteminfo4$[ebp]
  00060	88 54 0d f4	 mov	 BYTE PTR _pMsg$[ebp+ecx+4], dl

; 9483 : 	#if ITEM_BUFFER_SIZE > 4
; 9484 : 		pMsg.ItemInfo[4] = iteminfo5;

  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	c1 e0 02	 shl	 eax, 2
  0006c	8a 4d 20	 mov	 cl, BYTE PTR _iteminfo5$[ebp]
  0006f	88 4c 05 f4	 mov	 BYTE PTR _pMsg$[ebp+eax+4], cl

; 9485 : 	#endif
; 9486 : 	#endif
; 9487 : #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_03_20080704
; 9488 : 
; 9489 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00073	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00077	50		 push	 eax
  00078	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9490 : }

  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?GCTradeOtherAdd@@YAHHEEEEEE@Z ENDP			; GCTradeOtherAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildWarDeclare@@YAXHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
__guildname$ = 12					; size = 4
?GCGuildWarDeclare@@YAXHPAD@Z PROC			; GCGuildWarDeclare, COMDAT

; 13028: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 13029: 
; 13030: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 13031: 	return;
; 13032: #endif
; 13033: 
; 13034: 	PMSG_GUILDWAR_DECLARE pMsg;
; 13035: 
; 13036: 	PHeadSetB((LPBYTE)&pMsg, 0x62, sizeof( pMsg ));

  00013	6a 0d		 push	 13			; 0000000dH
  00015	6a 62		 push	 98			; 00000062H
  00017	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13037: 
; 13038: 	//pMsg.TeamCode	= 
; 13039: 	memcpy( pMsg.GuildName, _guildname, MAX_GUILDNAMESTRING);

  00023	6a 08		 push	 8
  00025	8b 45 0c	 mov	 eax, DWORD PTR __guildname$[ebp]
  00028	50		 push	 eax
  00029	8d 4d ef	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _memcpy
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13040: 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00035	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00039	50		 push	 eax
  0003a	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13041: }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00050	33 cd		 xor	 ecx, ebp
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?GCGuildWarDeclare@@YAXHPAD@Z ENDP			; GCGuildWarDeclare
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildWarScore@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
?GCGuildWarScore@@YAXH@Z PROC				; GCGuildWarScore, COMDAT

; 13061: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 13062: 
; 13063: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 13064: 	return;
; 13065: #endif
; 13066: 	
; 13067: 	PMSG_GUILDSCORE	pMsg;
; 13068: 
; 13069: 	if( gObj[aIndex].GuildNumber < 1 ) return;

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	83 bc 01 90 02
	00 00 01	 cmp	 DWORD PTR [ecx+eax+656], 1
  0001e	7d 05		 jge	 SHORT $LN2@GCGuildWar
  00020	e9 26 01 00 00	 jmp	 $LN1@GCGuildWar
$LN2@GCGuildWar:

; 13070: 
; 13071: 	PHeadSetB((LPBYTE)&pMsg, 0x64, sizeof( pMsg ));

  00025	6a 06		 push	 6
  00027	6a 64		 push	 100			; 00000064H
  00029	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13072: 	pMsg.Score1		= 0;

  00035	c6 45 fb 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 13073: 	pMsg.Score2		= 0;

  00039	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 13074: 	pMsg.Type		= 0;

  0003d	c6 45 fd 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0

; 13075: 
; 13076: 	if( gObj[aIndex].lpGuild != NULL )

  00041	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	83 bc 01 94 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+660], 0
  00056	0f 84 da 00 00
	00		 je	 $LN3@GCGuildWar

; 13077: 	{
; 13078: 		pMsg.Score1		= gObj[aIndex].lpGuild->PlayScore;

  0005c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00069	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  00070	8a 82 95 05 00
	00		 mov	 al, BYTE PTR [edx+1429]
  00076	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 13079: 		LogAdd("Score %s %d", gObj[aIndex].Name, gObj[aIndex].lpGuild->PlayScore);

  00079	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00086	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  0008d	0f b6 82 95 05
	00 00		 movzx	 eax, BYTE PTR [edx+1429]
  00094	50		 push	 eax
  00095	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0009c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a2	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd@
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13080: 
; 13081: 		if( gObj[aIndex].lpGuild->lpTargetGuildNode != NULL ) 

  000b5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c2	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  000c9	83 ba 8c 05 00
	00 00		 cmp	 DWORD PTR [edx+1420], 0
  000d0	74 64		 je	 SHORT $LN3@GCGuildWar

; 13082: 		{
; 13083: 			pMsg.Score2		= gObj[aIndex].lpGuild->lpTargetGuildNode->PlayScore;

  000d2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000df	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  000e6	8b 82 8c 05 00
	00		 mov	 eax, DWORD PTR [edx+1420]
  000ec	8a 88 95 05 00
	00		 mov	 cl, BYTE PTR [eax+1429]
  000f2	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 13084: 			LogAdd("Target Score %s %d", gObj[aIndex].Name, gObj[aIndex].lpGuild->lpTargetGuildNode->PlayScore);

  000f5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00102	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  00109	8b 82 8c 05 00
	00		 mov	 eax, DWORD PTR [edx+1420]
  0010f	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  00116	51		 push	 ecx
  00117	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0011e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00123	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00127	51		 push	 ecx
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd@
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCGuildWar:

; 13085: 		}
; 13086: 	}
; 13087: 	
; 13088: 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00136	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0013a	50		 push	 eax
  0013b	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0013e	51		 push	 ecx
  0013f	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00142	52		 push	 edx
  00143	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildWar:

; 13089: }

  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
?GCGuildWarScore@@YAXH@Z ENDP				; GCGuildWarScore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildWarRequestResult@@YAXPADHH@Z
_TEXT	SEGMENT
tv298 = -108						; size = 4
tv285 = -108						; size = 4
tv299 = -104						; size = 4
tv286 = -104						; size = 4
_warmaster$1 = -36					; size = 4
_n$2 = -32						; size = 4
_lpNode$ = -28						; size = 4
__guildname$ = -24					; size = 9
_lpMyGuild$ = -12					; size = 4
_pMsg$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_GuildName$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 4
?GCGuildWarRequestResult@@YAXPADHH@Z PROC		; GCGuildWarRequestResult, COMDAT

; 12525: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 12526: 
; 12527: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 12528: 	return;
; 12529: #endif
; 12530: 
; 12531: 	PMSG_GUILDWARREQUEST_RESULT	pMsg;
; 12532: 
; 12533: 	PHeadSetB((LPBYTE)&pMsg, 0x60, sizeof( pMsg ));

  00013	6a 04		 push	 4
  00015	6a 60		 push	 96			; 00000060H
  00017	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12534: 
; 12535: 	pMsg.Result     = 0x03;

  00023	c6 45 fb 03	 mov	 BYTE PTR _pMsg$[ebp+3], 3

; 12536: 	
; 12537: 	if( gObj[aIndex].GuildNumber < 1 )

  00027	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	83 bc 01 90 02
	00 00 01	 cmp	 DWORD PTR [ecx+eax+656], 1
  0003c	7d 1a		 jge	 SHORT $LN4@GCGuildWar

; 12538: 	{
; 12539: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00042	50		 push	 eax
  00043	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00046	51		 push	 ecx
  00047	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12540: 		return;

  00053	e9 fb 05 00 00	 jmp	 $LN1@GCGuildWar
$LN4@GCGuildWar:

; 12541: 	}
; 12542: 	LPGUILD_INFO lpMyGuild = gObj[aIndex].lpGuild;

  00058	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00065	8b 94 01 94 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+660]
  0006c	89 55 f4	 mov	 DWORD PTR _lpMyGuild$[ebp], edx

; 12543: 	
; 12544: 	if( lpMyGuild == NULL ) 

  0006f	83 7d f4 00	 cmp	 DWORD PTR _lpMyGuild$[ebp], 0
  00073	75 1a		 jne	 SHORT $LN5@GCGuildWar

; 12545: 	{
; 12546: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00075	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00079	50		 push	 eax
  0007a	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00081	52		 push	 edx
  00082	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12547: 		return;

  0008a	e9 c4 05 00 00	 jmp	 $LN1@GCGuildWar
$LN5@GCGuildWar:

; 12548: 	}
; 12549: 
; 12550: 	if( lpMyGuild->WarState == 1 || lpMyGuild->WarDeclareState == 1 ) 

  0008f	8b 45 f4	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  00092	0f b6 88 91 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1425]
  00099	83 f9 01	 cmp	 ecx, 1
  0009c	74 0f		 je	 SHORT $LN7@GCGuildWar
  0009e	8b 45 f4	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  000a1	0f b6 88 90 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1424]
  000a8	83 f9 01	 cmp	 ecx, 1
  000ab	75 55		 jne	 SHORT $LN6@GCGuildWar
$LN7@GCGuildWar:

; 12551: 	{
; 12552: 		pMsg.Result     = 0x04;

  000ad	c6 45 fb 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4

; 12553: 		LogAdd(lMsg.Get(490),lpMyGuild->WarState, lpMyGuild->WarDeclareState, lpMyGuild->Name);

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  000b4	83 c0 04	 add	 eax, 4
  000b7	50		 push	 eax
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _lpMyGuild$[ebp]
  000bb	0f b6 91 90 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1424]
  000c2	52		 push	 edx
  000c3	8b 45 f4	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  000c6	0f b6 88 91 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1425]
  000cd	51		 push	 ecx
  000ce	68 ea 01 00 00	 push	 490			; 000001eaH
  000d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000e5	83 c4 10	 add	 esp, 16			; 00000010H

; 12554: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000e8	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000ec	50		 push	 eax
  000ed	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000f0	51		 push	 ecx
  000f1	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12555: 		return;

  000fd	e9 51 05 00 00	 jmp	 $LN1@GCGuildWar
$LN6@GCGuildWar:

; 12556: 	}
; 12557: 
; 12558: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 12559: 	if (!gPkLimitFree) {

  00102	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00109	75 68		 jne	 SHORT $LN8@GCGuildWar

; 12560: #endif
; 12561: 	if( gObj[aIndex].m_PK_Level >= 6 )

  0010b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00118	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00120	83 fa 06	 cmp	 edx, 6
  00123	7c 4e		 jl	 SHORT $LN8@GCGuildWar

; 12562: 	{	//     
; 12563: 		pMsg.Result     = 0x04;

  00125	c6 45 fb 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4

; 12564: 		LogAdd("Error on declaring war : GuildMaster Is Murderer 0x04 %s %s",lpMyGuild->Names[0], gObj[aIndex].Name);

  00129	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00136	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0013a	52		 push	 edx
  0013b	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00140	6b c8 00	 imul	 ecx, eax, 0
  00143	8b 55 f4	 mov	 edx, DWORD PTR _lpMyGuild$[ebp]
  00146	8d 44 0a 2f	 lea	 eax, DWORD PTR [edx+ecx+47]
  0014a	50		 push	 eax
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildM@
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00156	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12565: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00159	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0015d	50		 push	 eax
  0015e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00161	51		 push	 ecx
  00162	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12566: 		return;

  0016e	e9 e0 04 00 00	 jmp	 $LN1@GCGuildWar
$LN8@GCGuildWar:

; 12567: 	}
; 12568: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 12569: 	}
; 12570: #endif
; 12571: 	
; 12572: 	//       .
; 12573: 	if( strcmp(lpMyGuild->Names[0], gObj[aIndex].Name) != 0 )

  00173	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0017a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00180	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00184	52		 push	 edx
  00185	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0018a	6b c8 00	 imul	 ecx, eax, 0
  0018d	8b 55 f4	 mov	 edx, DWORD PTR _lpMyGuild$[ebp]
  00190	8d 44 0a 2f	 lea	 eax, DWORD PTR [edx+ecx+47]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _strcmp
  0019a	83 c4 08	 add	 esp, 8
  0019d	85 c0		 test	 eax, eax
  0019f	74 5a		 je	 SHORT $LN10@GCGuildWar

; 12574: 	{
; 12575: 		pMsg.Result     = 0x05;

  001a1	c6 45 fb 05	 mov	 BYTE PTR _pMsg$[ebp+3], 5

; 12576: 		LogAdd(lMsg.Get(491),lpMyGuild->Names[0], gObj[aIndex].Name);

  001a5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b2	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001b6	52		 push	 edx
  001b7	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  001bc	6b c8 00	 imul	 ecx, eax, 0
  001bf	8b 55 f4	 mov	 edx, DWORD PTR _lpMyGuild$[ebp]
  001c2	8d 44 0a 2f	 lea	 eax, DWORD PTR [edx+ecx+47]
  001c6	50		 push	 eax
  001c7	68 eb 01 00 00	 push	 491			; 000001ebH
  001cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001d7	50		 push	 eax
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12577: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  001e1	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001e5	50		 push	 eax
  001e6	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001e9	51		 push	 ecx
  001ea	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001ed	52		 push	 edx
  001ee	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12578: 		return;

  001f6	e9 58 04 00 00	 jmp	 $LN1@GCGuildWar
$LN10@GCGuildWar:

; 12579: 	}
; 12580: 
; 12581: #ifdef MODIFY_GUILDWAR_REQUEST_PROCESS_20050704
; 12582: 	//     .
; 12583: 	char _guildname[MAX_GUILDNAMESTRING+1];
; 12584: 
; 12585: 	memset( _guildname, 0, MAX_GUILDNAMESTRING+1);
; 12586: 	memcpy( _guildname, GuildName, MAX_GUILDNAMESTRING);
; 12587: 
; 12588: 	if( strncmp(lpMyGuild->Name, GuildName, MAX_GUILDNAMESTRING) == 0 )
; 12589: 	{
; 12590: 		return;
; 12591: 	}
; 12592: #else
; 12593: 	char _guildname[MAX_GUILDNAMESTRING+1];
; 12594: 
; 12595: 	memset( _guildname, 0, MAX_GUILDNAMESTRING+1);

  001fb	6a 09		 push	 9
  001fd	6a 00		 push	 0
  001ff	8d 45 e8	 lea	 eax, DWORD PTR __guildname$[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _memset
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12596: 	memcpy( _guildname, GuildName, MAX_GUILDNAMESTRING);

  0020b	6a 08		 push	 8
  0020d	8b 45 08	 mov	 eax, DWORD PTR _GuildName$[ebp]
  00210	50		 push	 eax
  00211	8d 4d e8	 lea	 ecx, DWORD PTR __guildname$[ebp]
  00214	51		 push	 ecx
  00215	e8 00 00 00 00	 call	 _memcpy
  0021a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12597: 
; 12598: 	//     .
; 12599: 	if( strncmp(lpMyGuild->Name, _guildname, MAX_GUILDNAMESTRING) == 0 )

  0021d	6a 08		 push	 8
  0021f	8d 45 e8	 lea	 eax, DWORD PTR __guildname$[ebp]
  00222	50		 push	 eax
  00223	8b 4d f4	 mov	 ecx, DWORD PTR _lpMyGuild$[ebp]
  00226	83 c1 04	 add	 ecx, 4
  00229	51		 push	 ecx
  0022a	e8 00 00 00 00	 call	 _strncmp
  0022f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00232	85 c0		 test	 eax, eax
  00234	75 05		 jne	 SHORT $LN11@GCGuildWar

; 12600: 	{
; 12601: 		return;

  00236	e9 18 04 00 00	 jmp	 $LN1@GCGuildWar
$LN11@GCGuildWar:

; 12602: 	}
; 12603: #endif
; 12604: 
; 12605: 	//    
; 12606: 	LPGUILD_INFO lpNode = Guild.SearchGuild(_guildname);

  0023b	8d 45 e8	 lea	 eax, DWORD PTR __guildname$[ebp]
  0023e	50		 push	 eax
  0023f	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00244	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00249	89 45 e4	 mov	 DWORD PTR _lpNode$[ebp], eax

; 12607: 	if( lpNode != NULL )

  0024c	83 7d e4 00	 cmp	 DWORD PTR _lpNode$[ebp], 0
  00250	0f 84 e4 03 00
	00		 je	 $LN12@GCGuildWar

; 12608: 	{
; 12609: 		if( lpNode->WarState == 1 || lpNode->WarDeclareState == 1)	//   ..

  00256	8b 45 e4	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00259	0f b6 88 91 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1425]
  00260	83 f9 01	 cmp	 ecx, 1
  00263	74 0f		 je	 SHORT $LN15@GCGuildWar
  00265	8b 45 e4	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00268	0f b6 88 90 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1424]
  0026f	83 f9 01	 cmp	 ecx, 1
  00272	75 55		 jne	 SHORT $LN14@GCGuildWar
$LN15@GCGuildWar:

; 12610: 		{
; 12611: 			pMsg.Result     = 0x04;

  00274	c6 45 fb 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4

; 12612: 			LogAdd(lMsg.Get(490),lpNode->WarState, lpNode->WarDeclareState, lpNode->Name);

  00278	8b 45 e4	 mov	 eax, DWORD PTR _lpNode$[ebp]
  0027b	83 c0 04	 add	 eax, 4
  0027e	50		 push	 eax
  0027f	8b 4d e4	 mov	 ecx, DWORD PTR _lpNode$[ebp]
  00282	0f b6 91 90 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1424]
  00289	52		 push	 edx
  0028a	8b 45 e4	 mov	 eax, DWORD PTR _lpNode$[ebp]
  0028d	0f b6 88 91 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1425]
  00294	51		 push	 ecx
  00295	68 ea 01 00 00	 push	 490			; 000001eaH
  0029a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0029f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002a5	50		 push	 eax
  002a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002ac	83 c4 10	 add	 esp, 16			; 00000010H

; 12613: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  002af	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  002b3	50		 push	 eax
  002b4	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  002b7	51		 push	 ecx
  002b8	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002bb	52		 push	 edx
  002bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12614: 			return;

  002c4	e9 8a 03 00 00	 jmp	 $LN1@GCGuildWar
$LN14@GCGuildWar:

; 12615: 		}
; 12616: 
; 12617: 		
; 12618: #ifdef ADD_NEW_UNION_01_20041006
; 12619: 		//      .
; 12620: 		if( lpMyGuild->iGuildUnion != G_RELATIONSHIP_NONE
; 12621: 			&& lpMyGuild->iGuildUnion == lpNode->iGuildUnion )
; 12622: 		{
; 12623: 			LogAddTD("[U.System][Guildwar] Can't declare guildwar between Same Union (%s / %d) <-> (%s / %d)",
; 12624: 				lpMyGuild->Name, lpMyGuild->iGuildUnion, lpNode->Name, lpMyGuild->iGuildUnion);
; 12625: 			return;
; 12626: 		}
; 12627: #endif
; 12628: 		
; 12629: 		int n=0;

  002c9	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _n$2[ebp], 0

; 12630: 		int warmaster=-1;

  002d0	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _warmaster$1[ebp], -1
$LN2@GCGuildWar:

; 12631: 
; 12632: 		//    ?
; 12633: 		while( 1 )

  002d7	b8 01 00 00 00	 mov	 eax, 1
  002dc	85 c0		 test	 eax, eax
  002de	0f 84 32 01 00
	00		 je	 $LN3@GCGuildWar

; 12634: 		{
; 12635: 			if( gObj[n].Type == OBJTYPE_CHARACTER )

  002e4	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  002eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f1	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  002f6	83 fa 01	 cmp	 edx, 1
  002f9	0f 85 fc 00 00
	00		 jne	 $LN16@GCGuildWar

; 12636: 			{
; 12637: 				if( gObj[n].Connected > 2 )

  002ff	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0030c	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00311	0f 8e e4 00 00
	00		 jle	 $LN16@GCGuildWar

; 12638: 				{
; 12639: 					if( gObj[n].Name[0] == lpNode->Names[0][0] )

  00317	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  0031e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00324	b9 01 00 00 00	 mov	 ecx, 1
  00329	6b d1 00	 imul	 edx, ecx, 0
  0032c	0f be 44 10 73	 movsx	 eax, BYTE PTR [eax+edx+115]
  00331	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00336	6b d1 00	 imul	 edx, ecx, 0
  00339	8b 4d e4	 mov	 ecx, DWORD PTR _lpNode$[ebp]
  0033c	8d 54 11 2f	 lea	 edx, DWORD PTR [ecx+edx+47]
  00340	b9 01 00 00 00	 mov	 ecx, 1
  00345	6b c9 00	 imul	 ecx, ecx, 0
  00348	0f be 14 0a	 movsx	 edx, BYTE PTR [edx+ecx]
  0034c	3b c2		 cmp	 eax, edx
  0034e	0f 85 a7 00 00
	00		 jne	 $LN16@GCGuildWar

; 12640: 					{
; 12641: 						if( strcmp(gObj[n].Name, lpNode->Names[0] ) == 0 ) // ..

  00354	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00359	6b c8 00	 imul	 ecx, eax, 0
  0035c	8b 55 e4	 mov	 edx, DWORD PTR _lpNode$[ebp]
  0035f	8d 44 0a 2f	 lea	 eax, DWORD PTR [edx+ecx+47]
  00363	50		 push	 eax
  00364	69 4d e0 a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$2[ebp], 7072
  0036b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00371	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00375	50		 push	 eax
  00376	e8 00 00 00 00	 call	 _strcmp
  0037b	83 c4 08	 add	 esp, 8
  0037e	85 c0		 test	 eax, eax
  00380	75 79		 jne	 SHORT $LN16@GCGuildWar

; 12642: 						{
; 12643: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 12644: 							if (!gPkLimitFree) {

  00382	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00389	75 68		 jne	 SHORT $LN20@GCGuildWar

; 12645: #endif
; 12646: 							if( gObj[n].m_PK_Level >= 6 )

  0038b	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 7072
  00392	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00398	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  003a0	83 fa 06	 cmp	 edx, 6
  003a3	7c 4e		 jl	 SHORT $LN20@GCGuildWar

; 12647: 							{	//       
; 12648: 								pMsg.Result     = 0x04;

  003a5	c6 45 fb 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4

; 12649: 								LogAdd("Error on declaring war : Target GuildMaster Is Murderer 0x04 %s %s",lpMyGuild->Names[0], gObj[aIndex].Name);

  003a9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b6	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  003ba	52		 push	 edx
  003bb	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  003c0	6b c8 00	 imul	 ecx, eax, 0
  003c3	8b 55 f4	 mov	 edx, DWORD PTR _lpMyGuild$[ebp]
  003c6	8d 44 0a 2f	 lea	 eax, DWORD PTR [edx+ecx+47]
  003ca	50		 push	 eax
  003cb	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target@
  003d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12650: 								DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  003d9	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  003dd	50		 push	 eax
  003de	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  003e1	51		 push	 ecx
  003e2	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  003e5	52		 push	 edx
  003e6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12651: 								return;

  003ee	e9 60 02 00 00	 jmp	 $LN1@GCGuildWar
$LN20@GCGuildWar:

; 12652: 							}
; 12653: #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 12654: 							}
; 12655: #endif
; 12656: 
; 12657: 							warmaster = n;

  003f3	8b 45 e0	 mov	 eax, DWORD PTR _n$2[ebp]
  003f6	89 45 dc	 mov	 DWORD PTR _warmaster$1[ebp], eax

; 12658: 							break;

  003f9	eb 1b		 jmp	 SHORT $LN3@GCGuildWar
$LN16@GCGuildWar:

; 12659: 						}
; 12660: 					}
; 12661: 				}
; 12662: 			}
; 12663: 			if( n < MAX_OBJECT-1 ) n++;

  003fb	81 7d e0 e7 1c
	00 00		 cmp	 DWORD PTR _n$2[ebp], 7399 ; 00001ce7H
  00402	7d 0b		 jge	 SHORT $LN22@GCGuildWar
  00404	8b 45 e0	 mov	 eax, DWORD PTR _n$2[ebp]
  00407	83 c0 01	 add	 eax, 1
  0040a	89 45 e0	 mov	 DWORD PTR _n$2[ebp], eax
  0040d	eb 02		 jmp	 SHORT $LN23@GCGuildWar
$LN22@GCGuildWar:

; 12664: 			else break;

  0040f	eb 05		 jmp	 SHORT $LN3@GCGuildWar
$LN23@GCGuildWar:

; 12665: 		}

  00411	e9 c1 fe ff ff	 jmp	 $LN2@GCGuildWar
$LN3@GCGuildWar:

; 12666: 		if( warmaster >= 1 )	//   .. 

  00416	83 7d dc 01	 cmp	 DWORD PTR _warmaster$1[ebp], 1
  0041a	0f 8c ff 01 00
	00		 jl	 $LN24@GCGuildWar

; 12667: 		{
; 12668: #ifdef CHAOSCASTLE_SYSTEM_20040408		//       . (      )
; 12669: 	#ifndef WORLD_TOURNAMENT_EVENT_SETTING			
; 12670: 			if (CHECK_CHAOSCASTLE(gObj[aIndex].MapNumber) || CHECK_CHAOSCASTLE(gObj[warmaster].MapNumber)) {

  00420	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00427	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0042d	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00435	83 fa 12	 cmp	 edx, 18			; 00000012H
  00438	7d 09		 jge	 SHORT $LN32@GCGuildWar
  0043a	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv286[ebp], 0
  00441	eb 30		 jmp	 SHORT $LN33@GCGuildWar
$LN32@GCGuildWar:
  00443	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0044a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00450	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00458	83 fa 17	 cmp	 edx, 23			; 00000017H
  0045b	7e 09		 jle	 SHORT $LN30@GCGuildWar
  0045d	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv285[ebp], 0
  00464	eb 07		 jmp	 SHORT $LN31@GCGuildWar
$LN30@GCGuildWar:
  00466	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv285[ebp], 1
$LN31@GCGuildWar:
  0046d	8b 45 94	 mov	 eax, DWORD PTR tv285[ebp]
  00470	89 45 98	 mov	 DWORD PTR tv286[ebp], eax
$LN33@GCGuildWar:
  00473	83 7d 98 00	 cmp	 DWORD PTR tv286[ebp], 0
  00477	75 59		 jne	 SHORT $LN27@GCGuildWar
  00479	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _warmaster$1[ebp], 7072
  00480	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00486	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0048e	83 fa 12	 cmp	 edx, 18			; 00000012H
  00491	7d 09		 jge	 SHORT $LN36@GCGuildWar
  00493	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv299[ebp], 0
  0049a	eb 30		 jmp	 SHORT $LN37@GCGuildWar
$LN36@GCGuildWar:
  0049c	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _warmaster$1[ebp], 7072
  004a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004a9	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  004b1	83 fa 17	 cmp	 edx, 23			; 00000017H
  004b4	7e 09		 jle	 SHORT $LN34@GCGuildWar
  004b6	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv298[ebp], 0
  004bd	eb 07		 jmp	 SHORT $LN35@GCGuildWar
$LN34@GCGuildWar:
  004bf	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv298[ebp], 1
$LN35@GCGuildWar:
  004c6	8b 45 94	 mov	 eax, DWORD PTR tv298[ebp]
  004c9	89 45 98	 mov	 DWORD PTR tv299[ebp], eax
$LN37@GCGuildWar:
  004cc	83 7d 98 00	 cmp	 DWORD PTR tv299[ebp], 0
  004d0	74 24		 je	 SHORT $LN26@GCGuildWar
$LN27@GCGuildWar:

; 12671: 				GCServerMsgStringSend(lMsg.Get(1223), aIndex, 1);		// "       ."

  004d2	6a 01		 push	 1
  004d4	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004d7	50		 push	 eax
  004d8	68 c7 04 00 00	 push	 1223			; 000004c7H
  004dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  004e8	50		 push	 eax
  004e9	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12672: 				return;

  004f1	e9 5d 01 00 00	 jmp	 $LN1@GCGuildWar
$LN26@GCGuildWar:

; 12673: 			}
; 12674: 	#endif
; 12675: #endif
; 12676: 
; 12677: 			//    
; 12678: 			if( (gObj[warmaster].m_Option&OPTION_TRADE) != OPTION_TRADE )

  004f6	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _warmaster$1[ebp], 7072
  004fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00503	8b 94 01 c0 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3264]
  0050a	83 e2 01	 and	 edx, 1
  0050d	75 1e		 jne	 SHORT $LN28@GCGuildWar

; 12679: 			{
; 12680: 				pMsg.Result = 0x04;

  0050f	c6 45 fb 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4

; 12681: 				DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00513	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00517	50		 push	 eax
  00518	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0051b	51		 push	 ecx
  0051c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0051f	52		 push	 edx
  00520	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00525	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12682: 				return;

  00528	e9 26 01 00 00	 jmp	 $LN1@GCGuildWar
$LN28@GCGuildWar:

; 12683: 			}
; 12684: 			pMsg.Result = 0x01;

  0052d	c6 45 fb 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1

; 12685: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00531	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00535	50		 push	 eax
  00536	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00539	51		 push	 ecx
  0053a	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0053d	52		 push	 edx
  0053e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00543	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12686: 			GCGuildWarRequestSend(lpMyGuild->Name, warmaster, type);

  00546	8b 45 10	 mov	 eax, DWORD PTR _type$[ebp]
  00549	50		 push	 eax
  0054a	8b 4d dc	 mov	 ecx, DWORD PTR _warmaster$1[ebp]
  0054d	51		 push	 ecx
  0054e	8b 55 f4	 mov	 edx, DWORD PTR _lpMyGuild$[ebp]
  00551	83 c2 04	 add	 edx, 4
  00554	52		 push	 edx
  00555	e8 00 00 00 00	 call	 ?GCGuildWarRequestSend@@YAXPADHH@Z ; GCGuildWarRequestSend
  0055a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12687: 			lpMyGuild->WarDeclareState  = 1;

  0055d	8b 45 f4	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  00560	c6 80 90 05 00
	00 01		 mov	 BYTE PTR [eax+1424], 1

; 12688: 			lpNode->WarDeclareState     = 1;

  00567	8b 45 e4	 mov	 eax, DWORD PTR _lpNode$[ebp]
  0056a	c6 80 90 05 00
	00 01		 mov	 BYTE PTR [eax+1424], 1

; 12689: 			lpMyGuild->WarType			= type;

  00571	8b 45 f4	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  00574	8a 4d 10	 mov	 cl, BYTE PTR _type$[ebp]
  00577	88 88 92 05 00
	00		 mov	 BYTE PTR [eax+1426], cl

; 12690: 			lpNode->WarType             = type;

  0057d	8b 45 e4	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00580	8a 4d 10	 mov	 cl, BYTE PTR _type$[ebp]
  00583	88 88 92 05 00
	00		 mov	 BYTE PTR [eax+1426], cl

; 12691: 			
; 12692: 			LogAddTD(lMsg.Get(492), gObj[aIndex].AccountID, gObj[aIndex].Name, lpMyGuild->Name,lpNode->Name);

  00589	8b 45 e4	 mov	 eax, DWORD PTR _lpNode$[ebp]
  0058c	83 c0 04	 add	 eax, 4
  0058f	50		 push	 eax
  00590	8b 4d f4	 mov	 ecx, DWORD PTR _lpMyGuild$[ebp]
  00593	83 c1 04	 add	 ecx, 4
  00596	51		 push	 ecx
  00597	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0059e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a3	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  005a7	51		 push	 ecx
  005a8	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  005af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005b4	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  005b8	51		 push	 ecx
  005b9	68 ec 01 00 00	 push	 492			; 000001ecH
  005be	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  005c9	50		 push	 eax
  005ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005d0	83 c4 14	 add	 esp, 20			; 00000014H

; 12693: 			strcpy(lpMyGuild->TargetGuildName, lpNode->Name);

  005d3	8b 45 e4	 mov	 eax, DWORD PTR _lpNode$[ebp]
  005d6	83 c0 04	 add	 eax, 4
  005d9	50		 push	 eax
  005da	8b 4d f4	 mov	 ecx, DWORD PTR _lpMyGuild$[ebp]
  005dd	81 c1 e0 04 00
	00		 add	 ecx, 1248		; 000004e0H
  005e3	51		 push	 ecx
  005e4	e8 00 00 00 00	 call	 _strcpy
  005e9	83 c4 08	 add	 esp, 8

; 12694: 			strcpy(lpNode->TargetGuildName, lpMyGuild->Name);

  005ec	8b 45 f4	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  005ef	83 c0 04	 add	 eax, 4
  005f2	50		 push	 eax
  005f3	8b 4d e4	 mov	 ecx, DWORD PTR _lpNode$[ebp]
  005f6	81 c1 e0 04 00
	00		 add	 ecx, 1248		; 000004e0H
  005fc	51		 push	 ecx
  005fd	e8 00 00 00 00	 call	 _strcpy
  00602	83 c4 08	 add	 esp, 8

; 12695: 			lpMyGuild->lpTargetGuildNode = lpNode;

  00605	8b 45 f4	 mov	 eax, DWORD PTR _lpMyGuild$[ebp]
  00608	8b 4d e4	 mov	 ecx, DWORD PTR _lpNode$[ebp]
  0060b	89 88 8c 05 00
	00		 mov	 DWORD PTR [eax+1420], ecx

; 12696: 			lpNode->lpTargetGuildNode = lpMyGuild;

  00611	8b 45 e4	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00614	8b 4d f4	 mov	 ecx, DWORD PTR _lpMyGuild$[ebp]
  00617	89 88 8c 05 00
	00		 mov	 DWORD PTR [eax+1420], ecx

; 12697: 	
; 12698: 		}

  0061d	eb 19		 jmp	 SHORT $LN25@GCGuildWar
$LN24@GCGuildWar:

; 12699: 		else
; 12700: 		{	//    .
; 12701: 			pMsg.Result = 0x02;

  0061f	c6 45 fb 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2

; 12702: 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00623	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00627	50		 push	 eax
  00628	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0062b	51		 push	 ecx
  0062c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0062f	52		 push	 edx
  00630	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00635	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@GCGuildWar:

; 12703: 		}
; 12704: 	}

  00638	eb 19		 jmp	 SHORT $LN1@GCGuildWar
$LN12@GCGuildWar:

; 12705: 	else
; 12706: 	{
; 12707: 		pMsg.Result = 0x00; //   .

  0063a	c6 45 fb 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 12708: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0063e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00642	50		 push	 eax
  00643	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00646	51		 push	 ecx
  00647	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0064a	52		 push	 edx
  0064b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00650	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildWar:

; 12709: 	}
; 12710: }

  00653	5f		 pop	 edi
  00654	5e		 pop	 esi
  00655	5b		 pop	 ebx
  00656	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00659	33 cd		 xor	 ecx, ebp
  0065b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00660	8b e5		 mov	 esp, ebp
  00662	5d		 pop	 ebp
  00663	c3		 ret	 0
?GCGuildWarRequestResult@@YAXPADHH@Z ENDP		; GCGuildWarRequestResult
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildWarEnd@@YAXHEPAD@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
__guildname$ = 16					; size = 4
?GCGuildWarEnd@@YAXHEPAD@Z PROC				; GCGuildWarEnd, COMDAT

; 13045: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 13046: 
; 13047: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 13048: 	return;
; 13049: #endif
; 13050: 
; 13051: 	PMSG_GUILDWAR_END	pMsg;
; 13052: 
; 13053: 	PHeadSetB((LPBYTE)&pMsg, 0x63, sizeof( pMsg ));

  00013	6a 0c		 push	 12			; 0000000cH
  00015	6a 63		 push	 99			; 00000063H
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13054: 	pMsg.Result		= result;

  00023	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00026	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 13055: 	memcpy( pMsg.GuildName, _guildname, MAX_GUILDNAMESTRING);

  00029	6a 08		 push	 8
  0002b	8b 45 10	 mov	 eax, DWORD PTR __guildname$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp+4]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _memcpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13056: 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003b	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0003f	50		 push	 eax
  00040	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13057: }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?GCGuildWarEnd@@YAXHEPAD@Z ENDP				; GCGuildWarEnd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildWarRequestSend@@YAXPADHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_GuildName$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 4
?GCGuildWarRequestSend@@YAXPADHH@Z PROC			; GCGuildWarRequestSend, COMDAT

; 12714: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 12715: 
; 12716: #ifdef GAMESERVER_TO_CASTLESIEGESERVER //   ,   .
; 12717: 	return;
; 12718: #endif
; 12719: 	
; 12720: 	PMSG_GUILDWARSEND pMsg;
; 12721: 
; 12722: 	PHeadSetB((LPBYTE)&pMsg, 0x61, sizeof( pMsg ));

  00013	6a 0c		 push	 12			; 0000000cH
  00015	6a 61		 push	 97			; 00000061H
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12723: 
; 12724: 	pMsg.Type		= type;

  00023	8a 45 10	 mov	 al, BYTE PTR _type$[ebp]
  00026	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 12725: 	memcpy(pMsg.GuildName, GuildName, MAX_GUILDNAMESTRING);

  00029	6a 08		 push	 8
  0002b	8b 45 08	 mov	 eax, DWORD PTR _GuildName$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f3	 lea	 ecx, DWORD PTR _pMsg$[ebp+3]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _memcpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12726: 
; 12727: 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003b	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0003f	50		 push	 eax
  00040	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12728: 	LogAddTD(lMsg.Get(493), GuildName);

  00050	8b 45 08	 mov	 eax, DWORD PTR _GuildName$[ebp]
  00053	50		 push	 eax
  00054	68 ed 01 00 00	 push	 493			; 000001edH
  00059	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00064	50		 push	 eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0006b	83 c4 08	 add	 esp, 8

; 12729: }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	33 cd		 xor	 ecx, ebp
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?GCGuildWarRequestSend@@YAXPADHH@Z ENDP			; GCGuildWarRequestSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCManagerGuildWarSet@@YAXPAD0H@Z
_TEXT	SEGMENT
_warmaster$ = -12					; size = 4
_n$ = -8						; size = 4
_lpNode$ = -4						; size = 4
_GuildName1$ = 8					; size = 4
_GuildName2$ = 12					; size = 4
_type$ = 16						; size = 4
?GCManagerGuildWarSet@@YAXPAD0H@Z PROC			; GCManagerGuildWarSet, COMDAT

; 12488: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12489: 	//    
; 12490: 	LPGUILD_INFO lpNode = Guild.SearchGuild(GuildName1);

  00009	8b 45 08	 mov	 eax, DWORD PTR _GuildName1$[ebp]
  0000c	50		 push	 eax
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00012	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00017	89 45 fc	 mov	 DWORD PTR _lpNode$[ebp], eax

; 12491: 	
; 12492: 	if( lpNode == NULL ) return;

  0001a	83 7d fc 00	 cmp	 DWORD PTR _lpNode$[ebp], 0
  0001e	75 05		 jne	 SHORT $LN4@GCManagerG
  00020	e9 ee 00 00 00	 jmp	 $LN1@GCManagerG
$LN4@GCManagerG:

; 12493: 	
; 12494: 	int n=0;

  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 12495: 	int warmaster=-1;

  0002c	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _warmaster$[ebp], -1
$LN2@GCManagerG:

; 12496: 	
; 12497: 	//    ?
; 12498: 	while( 1 )

  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 b9 00 00
	00		 je	 $LN3@GCManagerG

; 12499: 	{
; 12500: 		if( gObj[n].Type == OBJTYPE_CHARACTER )

  00040	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00052	83 fa 01	 cmp	 edx, 1
  00055	0f 85 83 00 00
	00		 jne	 $LN5@GCManagerG

; 12501: 		{
; 12502: 			if( gObj[n].Connected > 2 )

  0005b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00068	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0006d	7e 6f		 jle	 SHORT $LN5@GCManagerG

; 12503: 			{
; 12504: 				if( gObj[n].Name[0] == lpNode->Names[0][0] )

  0006f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00076	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007c	b9 01 00 00 00	 mov	 ecx, 1
  00081	6b d1 00	 imul	 edx, ecx, 0
  00084	0f be 44 10 73	 movsx	 eax, BYTE PTR [eax+edx+115]
  00089	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0008e	6b d1 00	 imul	 edx, ecx, 0
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _lpNode$[ebp]
  00094	8d 54 11 2f	 lea	 edx, DWORD PTR [ecx+edx+47]
  00098	b9 01 00 00 00	 mov	 ecx, 1
  0009d	6b c9 00	 imul	 ecx, ecx, 0
  000a0	0f be 14 0a	 movsx	 edx, BYTE PTR [edx+ecx]
  000a4	3b c2		 cmp	 eax, edx
  000a6	75 36		 jne	 SHORT $LN5@GCManagerG

; 12505: 				{
; 12506: 					if( strcmp(gObj[n].Name, lpNode->Names[0] ) == 0 ) // ..

  000a8	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000ad	6b c8 00	 imul	 ecx, eax, 0
  000b0	8b 55 fc	 mov	 edx, DWORD PTR _lpNode$[ebp]
  000b3	8d 44 0a 2f	 lea	 eax, DWORD PTR [edx+ecx+47]
  000b7	50		 push	 eax
  000b8	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 7072
  000bf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c5	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _strcmp
  000cf	83 c4 08	 add	 esp, 8
  000d2	85 c0		 test	 eax, eax
  000d4	75 08		 jne	 SHORT $LN5@GCManagerG

; 12507: 					{
; 12508: 						warmaster = n;

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000d9	89 45 f4	 mov	 DWORD PTR _warmaster$[ebp], eax

; 12509: 						break;

  000dc	eb 1b		 jmp	 SHORT $LN3@GCManagerG
$LN5@GCManagerG:

; 12510: 					}
; 12511: 				}
; 12512: 			}
; 12513: 		}
; 12514: 		if( n < MAX_OBJECT-1 ) n++;

  000de	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _n$[ebp], 7399 ; 00001ce7H
  000e5	7d 0b		 jge	 SHORT $LN9@GCManagerG
  000e7	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000ea	83 c0 01	 add	 eax, 1
  000ed	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
  000f0	eb 02		 jmp	 SHORT $LN10@GCManagerG
$LN9@GCManagerG:

; 12515: 		else break;

  000f2	eb 05		 jmp	 SHORT $LN3@GCManagerG
$LN10@GCManagerG:

; 12516: 	}

  000f4	e9 3a ff ff ff	 jmp	 $LN2@GCManagerG
$LN3@GCManagerG:

; 12517: 	if( warmaster >= 1 )	//   .. 

  000f9	83 7d f4 01	 cmp	 DWORD PTR _warmaster$[ebp], 1
  000fd	7c 14		 jl	 SHORT $LN1@GCManagerG

; 12518: 	{
; 12519: 		GCGuildWarRequestResult(GuildName2, warmaster, type);

  000ff	8b 45 10	 mov	 eax, DWORD PTR _type$[ebp]
  00102	50		 push	 eax
  00103	8b 4d f4	 mov	 ecx, DWORD PTR _warmaster$[ebp]
  00106	51		 push	 ecx
  00107	8b 55 0c	 mov	 edx, DWORD PTR _GuildName2$[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 ?GCGuildWarRequestResult@@YAXPADHH@Z ; GCGuildWarRequestResult
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCManagerG:

; 12520: 	}
; 12521: }

  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
?GCManagerGuildWarSet@@YAXPAD0H@Z ENDP			; GCManagerGuildWarSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCManagerGuildWarEnd@@YAXPAD@Z
_TEXT	SEGMENT
_r2$1 = -14						; size = 1
_r1$2 = -13						; size = 1
_warmaster$ = -12					; size = 4
_n$ = -8						; size = 4
_lpNode$ = -4						; size = 4
_GuildName$ = 8						; size = 4
?GCManagerGuildWarEnd@@YAXPAD@Z PROC			; GCManagerGuildWarEnd, COMDAT

; 12406: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12407: 	//    
; 12408: 	LPGUILD_INFO lpNode = Guild.SearchGuild(GuildName);

  00009	8b 45 08	 mov	 eax, DWORD PTR _GuildName$[ebp]
  0000c	50		 push	 eax
  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00012	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00017	89 45 fc	 mov	 DWORD PTR _lpNode$[ebp], eax

; 12409: 	
; 12410: 	if( lpNode == NULL ) return;

  0001a	83 7d fc 00	 cmp	 DWORD PTR _lpNode$[ebp], 0
  0001e	75 05		 jne	 SHORT $LN4@GCManagerG
  00020	e9 ec 01 00 00	 jmp	 $LN1@GCManagerG
$LN4@GCManagerG:

; 12411: 	
; 12412: 	int n=0;

  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 12413: 	int warmaster=-1;

  0002c	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _warmaster$[ebp], -1
$LN2@GCManagerG:

; 12414: 	
; 12415: 	//    ?
; 12416: 	while( 1 )

  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 b9 00 00
	00		 je	 $LN3@GCManagerG

; 12417: 	{
; 12418: 		if( gObj[n].Type == OBJTYPE_CHARACTER )

  00040	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00052	83 fa 01	 cmp	 edx, 1
  00055	0f 85 83 00 00
	00		 jne	 $LN5@GCManagerG

; 12419: 		{
; 12420: 			if( gObj[n].Connected > 2 )

  0005b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00068	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0006d	7e 6f		 jle	 SHORT $LN5@GCManagerG

; 12421: 			{
; 12422: 				if( gObj[n].Name[0] == lpNode->Names[0][0] )

  0006f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00076	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007c	b9 01 00 00 00	 mov	 ecx, 1
  00081	6b d1 00	 imul	 edx, ecx, 0
  00084	0f be 44 10 73	 movsx	 eax, BYTE PTR [eax+edx+115]
  00089	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0008e	6b d1 00	 imul	 edx, ecx, 0
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _lpNode$[ebp]
  00094	8d 54 11 2f	 lea	 edx, DWORD PTR [ecx+edx+47]
  00098	b9 01 00 00 00	 mov	 ecx, 1
  0009d	6b c9 00	 imul	 ecx, ecx, 0
  000a0	0f be 14 0a	 movsx	 edx, BYTE PTR [edx+ecx]
  000a4	3b c2		 cmp	 eax, edx
  000a6	75 36		 jne	 SHORT $LN5@GCManagerG

; 12423: 				{
; 12424: 					if( strcmp(gObj[n].Name, lpNode->Names[0] ) == 0 ) // ..

  000a8	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000ad	6b c8 00	 imul	 ecx, eax, 0
  000b0	8b 55 fc	 mov	 edx, DWORD PTR _lpNode$[ebp]
  000b3	8d 44 0a 2f	 lea	 eax, DWORD PTR [edx+ecx+47]
  000b7	50		 push	 eax
  000b8	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 7072
  000bf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c5	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _strcmp
  000cf	83 c4 08	 add	 esp, 8
  000d2	85 c0		 test	 eax, eax
  000d4	75 08		 jne	 SHORT $LN5@GCManagerG

; 12425: 					{
; 12426: 						warmaster = n;

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000d9	89 45 f4	 mov	 DWORD PTR _warmaster$[ebp], eax

; 12427: 						break;

  000dc	eb 1b		 jmp	 SHORT $LN3@GCManagerG
$LN5@GCManagerG:

; 12428: 					}
; 12429: 				}
; 12430: 			}
; 12431: 		}
; 12432: 		if( n < MAX_OBJECT-1 ) n++;

  000de	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _n$[ebp], 7399 ; 00001ce7H
  000e5	7d 0b		 jge	 SHORT $LN9@GCManagerG
  000e7	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000ea	83 c0 01	 add	 eax, 1
  000ed	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
  000f0	eb 02		 jmp	 SHORT $LN10@GCManagerG
$LN9@GCManagerG:

; 12433: 		else break;

  000f2	eb 05		 jmp	 SHORT $LN3@GCManagerG
$LN10@GCManagerG:

; 12434: 	}

  000f4	e9 3a ff ff ff	 jmp	 $LN2@GCManagerG
$LN3@GCManagerG:

; 12435: 	if( warmaster >= 1 )	//   ..   

  000f9	83 7d f4 01	 cmp	 DWORD PTR _warmaster$[ebp], 1
  000fd	0f 8c 0e 01 00
	00		 jl	 $LN1@GCManagerG

; 12436: 	{
; 12437: 		BYTE r1, r2;
; 12438: 		r1 = 0x00;

  00103	c6 45 f3 00	 mov	 BYTE PTR _r1$2[ebp], 0

; 12439: 		r2 = 0x00;

  00107	c6 45 f2 00	 mov	 BYTE PTR _r2$1[ebp], 0

; 12440: 		if( lpNode != NULL && lpNode->lpTargetGuildNode != NULL )

  0010b	83 7d fc 00	 cmp	 DWORD PTR _lpNode$[ebp], 0
  0010f	74 40		 je	 SHORT $LN12@GCManagerG
  00111	8b 45 fc	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00114	83 b8 8c 05 00
	00 00		 cmp	 DWORD PTR [eax+1420], 0
  0011b	74 34		 je	 SHORT $LN12@GCManagerG

; 12441: 		{	//       
; 12442: 			if( lpNode->PlayScore == 0  &&  lpNode->lpTargetGuildNode->PlayScore == 0 )

  0011d	8b 45 fc	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00120	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  00127	85 c9		 test	 ecx, ecx
  00129	75 1e		 jne	 SHORT $LN13@GCManagerG
  0012b	8b 45 fc	 mov	 eax, DWORD PTR _lpNode$[ebp]
  0012e	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00134	0f b6 91 95 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1429]
  0013b	85 d2		 test	 edx, edx
  0013d	75 0a		 jne	 SHORT $LN13@GCManagerG

; 12443: 			{	//    
; 12444: 				r1 = 0x06;

  0013f	c6 45 f3 06	 mov	 BYTE PTR _r1$2[ebp], 6

; 12445: 				r2 = 0x06;

  00143	c6 45 f2 06	 mov	 BYTE PTR _r2$1[ebp], 6

; 12446: 			}

  00147	eb 08		 jmp	 SHORT $LN12@GCManagerG
$LN13@GCManagerG:

; 12447: 			else
; 12448: 			{
; 12449: 				r1 = 0x00;

  00149	c6 45 f3 00	 mov	 BYTE PTR _r1$2[ebp], 0

; 12450: 				r2 = 0x01;

  0014d	c6 45 f2 01	 mov	 BYTE PTR _r2$1[ebp], 1
$LN12@GCManagerG:

; 12451: 			}			
; 12452: 			/*
; 12453: 			if( lpNode->PlayScore < lpNode->lpTargetGuildNode->PlayScore )
; 12454: 			{
; 12455: 				r1 = 0x00;
; 12456: 				r2 = 0x01;
; 12457: 			}
; 12458: 			else if( lpNode->PlayScore > lpNode->lpTargetGuildNode->PlayScore )
; 12459: 			{
; 12460: 				r1 = 0x01;
; 12461: 				r2 = 0x00;
; 12462: 			}
; 12463: 			*/
; 12464: 		}		
; 12465: 		
; 12466: 		if( lpNode->WarType == BTT_SOCCER )

  00151	8b 45 fc	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00154	0f b6 88 92 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1426]
  0015b	83 f9 01	 cmp	 ecx, 1
  0015e	75 7b		 jne	 SHORT $LN15@GCManagerG

; 12467: 		{
; 12468: 			gBattleGroundEnable(lpNode->BattleGroundIndex, 0);	

  00160	6a 00		 push	 0
  00162	8b 45 fc	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00165	0f b6 88 93 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1427]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable
  00172	83 c4 08	 add	 esp, 8

; 12469: #ifdef _NEW_EXDB_
; 12470: 			gObjGuildWarEndSend(lpNode, lpNode->lpTargetGuildNode, r1, r2);

  00175	0f b6 45 f2	 movzx	 eax, BYTE PTR _r2$1[ebp]
  00179	50		 push	 eax
  0017a	0f b6 4d f3	 movzx	 ecx, BYTE PTR _r1$2[ebp]
  0017e	51		 push	 ecx
  0017f	8b 55 fc	 mov	 edx, DWORD PTR _lpNode$[ebp]
  00182	8b 82 8c 05 00
	00		 mov	 eax, DWORD PTR [edx+1420]
  00188	50		 push	 eax
  00189	8b 4d fc	 mov	 ecx, DWORD PTR _lpNode$[ebp]
  0018c	51		 push	 ecx
  0018d	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend
  00192	83 c4 10	 add	 esp, 16			; 00000010H

; 12471: 			gObjGuildWarEnd(lpNode, lpNode->lpTargetGuildNode);

  00195	8b 45 fc	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00198	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0019e	51		 push	 ecx
  0019f	8b 55 fc	 mov	 edx, DWORD PTR _lpNode$[ebp]
  001a2	52		 push	 edx
  001a3	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  001a8	83 c4 08	 add	 esp, 8

; 12472: #endif
; 12473: 			cManager.BattleInfoSend(GetBattleTeamName(0, 0), 255, GetBattleTeamName(0, 1), 255);

  001ab	68 ff 00 00 00	 push	 255			; 000000ffH
  001b0	6a 01		 push	 1
  001b2	6a 00		 push	 0
  001b4	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  001b9	83 c4 08	 add	 esp, 8
  001bc	50		 push	 eax
  001bd	68 ff 00 00 00	 push	 255			; 000000ffH
  001c2	6a 00		 push	 0
  001c4	6a 00		 push	 0
  001c6	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  001cb	83 c4 08	 add	 esp, 8
  001ce	50		 push	 eax
  001cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  001d4	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend

; 12474: 		}

  001d9	eb 36		 jmp	 SHORT $LN1@GCManagerG
$LN15@GCManagerG:

; 12475: 		else
; 12476: 		{
; 12477: #ifdef _NEW_EXDB_
; 12478: 			gObjGuildWarEndSend(lpNode, lpNode->lpTargetGuildNode, r1, r2);	

  001db	0f b6 45 f2	 movzx	 eax, BYTE PTR _r2$1[ebp]
  001df	50		 push	 eax
  001e0	0f b6 4d f3	 movzx	 ecx, BYTE PTR _r1$2[ebp]
  001e4	51		 push	 ecx
  001e5	8b 55 fc	 mov	 edx, DWORD PTR _lpNode$[ebp]
  001e8	8b 82 8c 05 00
	00		 mov	 eax, DWORD PTR [edx+1420]
  001ee	50		 push	 eax
  001ef	8b 4d fc	 mov	 ecx, DWORD PTR _lpNode$[ebp]
  001f2	51		 push	 ecx
  001f3	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend
  001f8	83 c4 10	 add	 esp, 16			; 00000010H

; 12479: 			gObjGuildWarEnd(lpNode, lpNode->lpTargetGuildNode);

  001fb	8b 45 fc	 mov	 eax, DWORD PTR _lpNode$[ebp]
  001fe	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00204	51		 push	 ecx
  00205	8b 55 fc	 mov	 edx, DWORD PTR _lpNode$[ebp]
  00208	52		 push	 edx
  00209	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  0020e	83 c4 08	 add	 esp, 8
$LN1@GCManagerG:

; 12480: #endif
; 12481: 		}
; 12482: 	}
; 12483: }

  00211	5f		 pop	 edi
  00212	5e		 pop	 esi
  00213	5b		 pop	 ebx
  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c3		 ret	 0
?GCManagerGuildWarEnd@@YAXPAD@Z ENDP			; GCManagerGuildWarEnd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildViewportDelNow@@YAXH@Z
_TEXT	SEGMENT
_lpObj$ = -12						; size = 4
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
?GCGuildViewportDelNow@@YAXH@Z PROC			; GCGuildViewportDelNow, COMDAT

; 12384: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12385: 	PMSG_GUILDDEL_VIEWPORT_NOW	pMsg;
; 12386: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 12387: 
; 12388: 	PHeadSetB((LPBYTE)&pMsg, 0x5D, sizeof( pMsg ));

  00019	6a 05		 push	 5
  0001b	6a 5d		 push	 93			; 0000005dH
  0001d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12389: 
; 12390: #ifdef GUILD_VIEWPORT_MODIFY
; 12391: 	pMsg.NumberH		= HIBYTE( aIndex )&0x7F;
; 12392: 	pMsg.NumberL		= LOBYTE( aIndex );
; 12393: 
; 12394: 	if( isGuildMaster )
; 12395: 		pMsg.NumberH |= 0x80;
; 12396: #else
; 12397: 	pMsg.NumberH		= HIBYTE( aIndex );

  00029	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0002c	c1 e8 08	 shr	 eax, 8
  0002f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00034	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 12398: 	pMsg.NumberL		= LOBYTE( aIndex );

  00037	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003f	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 12399: #endif
; 12400: 
; 12401: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00042	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00046	50		 push	 eax
  00047	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0004a	51		 push	 ecx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12402: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00057	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0005b	50		 push	 eax
  0005c	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12403: }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?GCGuildViewportDelNow@@YAXH@Z ENDP			; GCGuildViewportDelNow
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildViewportNowPaint@@YAXHPADPAE@Z
_TEXT	SEGMENT
tv94 = -128						; size = 4
tv95 = -124						; size = 4
_lpObj$ = -56						; size = 4
_pMsg$ = -52						; size = 45
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_guildname$ = 12					; size = 4
_Mark$ = 16						; size = 4
?GCGuildViewportNowPaint@@YAXHPADPAE@Z PROC		; GCGuildViewportNowPaint, COMDAT

; 12269: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 12270: #ifdef MODIFY_GUILD_VIEWPORT_01_20040701
; 12271: 	// > . 0
; 12272: 	LPGUILD_INFO lpGuild = Guild.SearchGuild( guildname );
; 12273: 	
; 12274: 	if( lpGuild == NULL ) return;
; 12275: 
; 12276: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];
; 12277: 	BYTE _GuildInfoBuf[256] = {0,};
; 12278: 	INT	_GuildInfoOfs = sizeof(PMSG_SIMPLE_GUILDVIEWPORT_COUNT);
; 12279: 
; 12280: 	// > . 1
; 12281: 	PMSG_SIMPLE_GUILDVIEWPORT pMsg;
; 12282: 
; 12283: #ifdef MODIFY_GUILD_VIEWPORT_02_20040830
; 12284: 	if( lpObj->lpGuild == NULL )
; 12285: 		return;
; 12286: 	
; 12287: 	pMsg.GuildNumber= lpObj->lpGuild->Number;
; 12288: #else
; 12289: 	pMsg.GNumberH = HIBYTE(lpGuild->Number);
; 12290: 	pMsg.GNumberL = LOBYTE(lpGuild->Number);
; 12291: #endif
; 12292: 
; 12293: 	pMsg.NumberH  = HIBYTE( aIndex )&0x7F;
; 12294: 	pMsg.NumberL  = LOBYTE( aIndex );
; 12295: 	
; 12296: 	if( isGuildMaster )
; 12297: 		pMsg.NumberH |= 0x80;
; 12298: 
; 12299: #ifdef ADD_NEW_GUILD_01_20040913
; 12300: 	if( isGuildMaster )
; 12301: 		pMsg.btGuildStatus = G_MASTER;
; 12302: 	else
; 12303: 		pMsg.btGuildStatus = lpObj->GuildStatus;
; 12304: #endif
; 12305: 
; 12306: #ifdef ADD_NEW_GUILD_02_20040922
; 12307: 	pMsg.btGuildType = lpObj->lpGuild->btGuildType;
; 12308: #endif
; 12309: 
; 12310: #ifdef ADD_NEW_UNION_01_20041006
; 12311: 	pMsg.btGuildRelationShip	= G_RELATIONSHIP_NONE;
; 12312: 	lpObj->iGuildUnionTimeStamp = 0;
; 12313: #endif
; 12314: 
; 12315: #ifdef UPDATE_CHECK_CASTLE_OWNERMEMBER_20090217
; 12316: 	if (g_CastleSiegeSync.CheckCastleOwnerMember(lpObj->m_Index) == TRUE ||
; 12317: 		g_CastleSiegeSync.CheckCastleOwnerUnionMember(lpObj->m_Index) == TRUE)
; 12318: 	{
; 12319: 		pMsg.btCastleOwner = 0x01;
; 12320: 	}
; 12321: 	else
; 12322: 	{
; 12323: 		pMsg.btCastleOwner = 0x00;
; 12324: 	}						
; 12325: #endif	// UPDATE_CHECK_CASTLE_OWNERMEMBER_20090217
; 12326: 
; 12327: 	memcpy( _GuildInfoBuf + _GuildInfoOfs, &pMsg, sizeof(pMsg) );
; 12328: 	_GuildInfoOfs += sizeof( pMsg );
; 12329: 	
; 12330: 	// > . 2
; 12331: 	PMSG_SIMPLE_GUILDVIEWPORT_COUNT pGVCount;
; 12332: 						
; 12333: 	pGVCount.h.c		= PMHC_WORD;
; 12334: 	pGVCount.h.headcode = 0x65;
; 12335: 	pGVCount.h.sizeH	= HIBYTE( _GuildInfoOfs );
; 12336: 	pGVCount.h.sizeL	= LOBYTE( _GuildInfoOfs );
; 12337: 	pGVCount.Count		= 1;
; 12338: 	memcpy(_GuildInfoBuf, &pGVCount, sizeof(pGVCount));
; 12339: 	
; 12340: 	#ifdef CHAOSCASTLE_SYSTEM_20040408			//      .
; 12341: 	if (!CHECK_CHAOSCASTLE(gObj[aIndex].MapNumber))
; 12342: 	#endif
; 12343: 
; 12344: 	DataSend( aIndex, _GuildInfoBuf, _GuildInfoOfs);
; 12345: 	MsgSendV2(lpObj, _GuildInfoBuf, _GuildInfoOfs );
; 12346: 
; 12347: #else // MODIFY_GUILD_VIEWPORT_01_20040701
; 12348: 
; 12349: 	PMSG_GUILDVIEWPORT_NOW	pMsg;
; 12350: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00016	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 c8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 12351: 
; 12352: 	PHeadSetB((LPBYTE)&pMsg, 0x5C, sizeof( pMsg ));

  00026	6a 2d		 push	 45			; 0000002dH
  00028	6a 5c		 push	 92			; 0000005cH
  0002a	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12353: 
; 12354: 	#ifdef GUILD_VIEWPORT_MODIFY
; 12355: 	pMsg.NumberH		= HIBYTE( aIndex )&0x7F;
; 12356: 	pMsg.NumberL		= LOBYTE( aIndex );
; 12357: 
; 12358: 	if( isGuildMaster )
; 12359: 		pMsg.NumberH |= 0x80;
; 12360: 	#else
; 12361: 	pMsg.NumberH		= HIBYTE( aIndex );

  00036	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00039	c1 e8 08	 shr	 eax, 8
  0003c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00041	88 45 cf	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 12362: 	pMsg.NumberL		= LOBYTE( aIndex );

  00044	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00047	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004c	88 45 d0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 12363: 	#endif
; 12364: 	memcpy(pMsg.GuildName, guildname, MAX_GUILDNAMESTRING);

  0004f	6a 08		 push	 8
  00051	8b 45 0c	 mov	 eax, DWORD PTR _guildname$[ebp]
  00054	50		 push	 eax
  00055	8d 4d d1	 lea	 ecx, DWORD PTR _pMsg$[ebp+5]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _memcpy
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12365: 	memcpy(pMsg.Mark, Mark, 32);

  00061	6a 20		 push	 32			; 00000020H
  00063	8b 45 10	 mov	 eax, DWORD PTR _Mark$[ebp]
  00066	50		 push	 eax
  00067	8d 4d d9	 lea	 ecx, DWORD PTR _pMsg$[ebp+13]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 _memcpy
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12366: 
; 12367: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00073	0f b6 45 cd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00077	50		 push	 eax
  00078	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0007f	52		 push	 edx
  00080	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12368: 
; 12369: 	#ifdef CHAOSCASTLE_SYSTEM_20040408			//      .
; 12370: 	if (!CHECK_CHAOSCASTLE(gObj[aIndex].MapNumber))

  00088	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00095	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0009d	83 fa 12	 cmp	 edx, 18			; 00000012H
  000a0	7d 09		 jge	 SHORT $LN6@GCGuildVie
  000a2	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  000a9	eb 30		 jmp	 SHORT $LN7@GCGuildVie
$LN6@GCGuildVie:
  000ab	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b8	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000c0	83 fa 17	 cmp	 edx, 23			; 00000017H
  000c3	7e 09		 jle	 SHORT $LN4@GCGuildVie
  000c5	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  000cc	eb 07		 jmp	 SHORT $LN5@GCGuildVie
$LN4@GCGuildVie:
  000ce	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv94[ebp], 1
$LN5@GCGuildVie:
  000d5	8b 45 80	 mov	 eax, DWORD PTR tv94[ebp]
  000d8	89 45 84	 mov	 DWORD PTR tv95[ebp], eax
$LN7@GCGuildVie:
  000db	83 7d 84 00	 cmp	 DWORD PTR tv95[ebp], 0
  000df	75 15		 jne	 SHORT $LN1@GCGuildVie

; 12371: 	#endif	
; 12372: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  000e1	0f b6 45 cd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000e5	50		 push	 eax
  000e6	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 c8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildVie:

; 12373: 
; 12374: #endif //MODIFY_GUILD_VIEWPORT_01_20040701
; 12375: 	
; 12376: }

  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	33 cd		 xor	 ecx, ebp
  000fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
?GCGuildViewportNowPaint@@YAXHPADPAE@Z ENDP		; GCGuildViewportNowPaint
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildDelUserResult@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Result$ = 12						; size = 1
?GCGuildDelUserResult@@YAXHE@Z PROC			; GCGuildDelUserResult, COMDAT

; 12152: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12153: 	PMSG_GUILDDELUSER_RESULT	pMsg;
; 12154: 
; 12155: 	PHeadSetB((LPBYTE)&pMsg, 0x53, sizeof( pMsg ));

  00009	6a 04		 push	 4
  0000b	6a 53		 push	 83			; 00000053H
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12156: 	pMsg.Result		= Result;

  00019	8a 45 0c	 mov	 al, BYTE PTR _Result$[ebp]
  0001c	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 12157: 
; 12158: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001f	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00023	50		 push	 eax
  00024	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12159: }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?GCGuildDelUserResult@@YAXHE@Z ENDP			; GCGuildDelUserResult
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCGuildMasterQuestionSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCGuildMasterQuestionSend@@YAXH@Z PROC			; GCGuildMasterQuestionSend, COMDAT

; 12164: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12165: 	PMSG_GUILDMASTERQUESTION	pMsg;
; 12166: 	
; 12167: 	if( gObj[aIndex].m_IfState.use > 0 ) return;

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0001d	80 e2 03	 and	 dl, 3
  00020	0f b6 c2	 movzx	 eax, dl
  00023	85 c0		 test	 eax, eax
  00025	7e 05		 jle	 SHORT $LN2@GCGuildMas
  00027	e9 ac 00 00 00	 jmp	 $LN1@GCGuildMas
$LN2@GCGuildMas:

; 12168: 	
; 12169: 	PHeadSetB((LPBYTE)&pMsg, 0x54, sizeof( pMsg ));

  0002c	6a 03		 push	 3
  0002e	6a 54		 push	 84			; 00000054H
  00030	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12170: 
; 12171: 	gObj[aIndex].m_IfState.use    = 1;

  0003c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00049	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00050	80 e2 fc	 and	 dl, 252			; 000000fcH
  00053	80 ca 01	 or	 dl, 1
  00056	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00063	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 12172: 	gObj[aIndex].m_IfState.type   = I_GUILDCREATE;

  0006a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00077	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0007e	80 e2 0f	 and	 dl, 15			; 0000000fH
  00081	80 ca 50	 or	 dl, 80			; 00000050H
  00084	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00091	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 12173: 	gObj[aIndex].m_IfState.state  = 0;

  00098	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a5	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000ac	80 e2 f3	 and	 dl, 243			; 000000f3H
  000af	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bc	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 12174: 
; 12175: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000c3	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000c7	50		 push	 eax
  000c8	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000cb	51		 push	 ecx
  000cc	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildMas:

; 12176: }

  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
?GCGuildMasterQuestionSend@@YAXH@Z ENDP			; GCGuildMasterQuestionSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z
_TEXT	SEGMENT
tv260 = -368						; size = 4
tv261 = -364						; size = 4
_minlevel$ = -296					; size = 4
_maxlevel$ = -292					; size = 4
_dbnumber$1 = -288					; size = 4
_user$2 = -284						; size = 4
_iPartyPos$3 = -280					; size = 4
_szTemp$ = -276						; size = 256
_pnumber$ = -20						; size = 4
_pMsg$ = -16						; size = 5
_number$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z PROC	; CGPartyRequestRecv, COMDAT

; 10937: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 10938: 	int number;
; 10939: 	PMSG_PARTYREQUESTSEND	pMsg;
; 10940: 
; 10941: 	int pnumber = -1;

  00016	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _pnumber$[ebp], -1

; 10942: 	char szTemp[256];
; 10943: 
; 10944: 	number = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  0001d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00020	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00024	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0002a	0f b6 d1	 movzx	 edx, cl
  0002d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00030	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00034	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0003a	0f b6 c1	 movzx	 eax, cl
  0003d	c1 e0 08	 shl	 eax, 8
  00040	0b d0		 or	 edx, eax
  00042	0f b7 ca	 movzx	 ecx, dx
  00045	89 4d f8	 mov	 DWORD PTR _number$[ebp], ecx

; 10945: 	if( number < 0 || number > MAX_OBJECT-1 ) return; 

  00048	83 7d f8 00	 cmp	 DWORD PTR _number$[ebp], 0
  0004c	7c 09		 jl	 SHORT $LN3@CGPartyReq
  0004e	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _number$[ebp], 7399 ; 00001ce7H
  00055	7e 05		 jle	 SHORT $LN2@CGPartyReq
$LN3@CGPartyReq:
  00057	e9 8d 07 00 00	 jmp	 $LN1@CGPartyReq
$LN2@CGPartyReq:

; 10946: 
; 10947: 	//DevGamesX 01/05/2018 - OffExp Auto Party
; 10948: 	if ( gObj[number].OffExp == true )

  0005c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00069	0f b6 94 01 8c
	1a 00 00	 movzx	 edx, BYTE PTR [ecx+eax+6796]
  00071	83 fa 01	 cmp	 edx, 1
  00074	0f 85 c5 01 00
	00		 jne	 $LN4@CGPartyReq

; 10949: 	{
; 10950: 		if ( gObj[number].PartyNumber < 0 )

  0007a	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00087	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  0008f	7d 4a		 jge	 SHORT $LN5@CGPartyReq

; 10951: 		{
; 10952: 			gObj[number].PartyNumber = gParty.Create(number, gObj[number].DBNumber, gObj[number].Level);

  00091	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009e	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  000a6	52		 push	 edx
  000a7	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b4	8b 54 01 2c	 mov	 edx, DWORD PTR [ecx+eax+44]
  000b8	52		 push	 edx
  000b9	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  000bc	50		 push	 eax
  000bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000c2	e8 00 00 00 00	 call	 ?Create@PartyClass@@QAEHHHH@Z ; PartyClass::Create
  000c7	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  000ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d4	89 84 0a 88 02
	00 00		 mov	 DWORD PTR [edx+ecx+648], eax
$LN5@CGPartyReq:

; 10953: 		}
; 10954: 
; 10955: 		if ( gObj[aIndex].PartyNumber < 0 )

  000db	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e8	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  000f0	7d 4a		 jge	 SHORT $LN6@CGPartyReq

; 10956: 		{
; 10957: 			gObj[aIndex].PartyNumber = gParty.Create(aIndex, gObj[aIndex].DBNumber, gObj[aIndex].Level);

  000f2	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ff	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00107	52		 push	 edx
  00108	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0010f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00115	8b 54 01 2c	 mov	 edx, DWORD PTR [ecx+eax+44]
  00119	52		 push	 edx
  0011a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0011d	50		 push	 eax
  0011e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00123	e8 00 00 00 00	 call	 ?Create@PartyClass@@QAEHHHH@Z ; PartyClass::Create
  00128	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0012f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00135	89 84 0a 88 02
	00 00		 mov	 DWORD PTR [edx+ecx+648], eax
$LN6@CGPartyReq:

; 10958: 		}
; 10959: 
; 10960: 		if ( gObj[aIndex].PartyNumber >= 0  )

  0013c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00149	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  00151	0f 8c d1 00 00
	00		 jl	 $LN7@CGPartyReq

; 10961: 		{
; 10962: 			pnumber = gObj[aIndex].PartyNumber;

  00157	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00164	8b 94 01 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+648]
  0016b	89 55 ec	 mov	 DWORD PTR _pnumber$[ebp], edx

; 10963: 			int iPartyPos = gParty.Add(gObj[aIndex].PartyNumber, number, gObj[number].DBNumber, gObj[number].Level);

  0016e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00175	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017b	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00183	52		 push	 edx
  00184	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0018b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00191	8b 54 01 2c	 mov	 edx, DWORD PTR [ecx+eax+44]
  00195	52		 push	 edx
  00196	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00199	50		 push	 eax
  0019a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a7	8b 84 0a 88 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+648]
  001ae	50		 push	 eax
  001af	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001b4	e8 00 00 00 00	 call	 ?Add@PartyClass@@QAEHHHHH@Z ; PartyClass::Add
  001b9	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iPartyPos$3[ebp], eax

; 10964: 
; 10965: 			if ( iPartyPos >= 0 )

  001bf	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iPartyPos$3[ebp], 0
  001c6	7c 60		 jl	 SHORT $LN7@CGPartyReq

; 10966: 			{
; 10967: 				gObj[number].PartyNumber = gObj[aIndex].PartyNumber;

  001c8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001cf	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  001d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001dc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e2	8b 84 06 88 02
	00 00		 mov	 eax, DWORD PTR [esi+eax+648]
  001e9	89 84 0a 88 02
	00 00		 mov	 DWORD PTR [edx+ecx+648], eax

; 10968: 				//wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[number].Name);
; 10969: 				::GCServerMsgStringSend(szTemp, aIndex, 1);

  001f0	6a 01		 push	 1
  001f2	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001f5	50		 push	 eax
  001f6	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  001fc	51		 push	 ecx
  001fd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00202	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10970: 				//wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[aIndex].Name);
; 10971: 				::GCServerMsgStringSend(szTemp, number, 1);

  00205	6a 01		 push	 1
  00207	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0020a	50		 push	 eax
  0020b	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00211	51		 push	 ecx
  00212	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00217	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10972: 				gParty.Paint(pnumber);

  0021a	8b 45 ec	 mov	 eax, DWORD PTR _pnumber$[ebp]
  0021d	50		 push	 eax
  0021e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00223	e8 00 00 00 00	 call	 ?Paint@PartyClass@@QAEXH@Z ; PartyClass::Paint
$LN7@CGPartyReq:

; 10973: 			}
; 10974: 		}
; 10975: 
; 10976: 		if ( pnumber >= 0 )

  00228	83 7d ec 00	 cmp	 DWORD PTR _pnumber$[ebp], 0
  0022c	7c 0c		 jl	 SHORT $LN9@CGPartyReq

; 10977: 		{
; 10978: 			CGPartyListAll(pnumber);

  0022e	8b 45 ec	 mov	 eax, DWORD PTR _pnumber$[ebp]
  00231	50		 push	 eax
  00232	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  00237	83 c4 04	 add	 esp, 4
$LN9@CGPartyReq:

; 10979: 		}
; 10980: 
; 10981: 		return;

  0023a	e9 aa 05 00 00	 jmp	 $LN1@CGPartyReq
$LN4@CGPartyReq:

; 10982: 	} 
; 10983: 
; 10984: 	if( PacketCheckTime(&gObj[aIndex]) == FALSE ) return;

  0023f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00246	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024c	50		 push	 eax
  0024d	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00252	83 c4 04	 add	 esp, 4
  00255	85 c0		 test	 eax, eax
  00257	75 05		 jne	 SHORT $LN10@CGPartyReq
  00259	e9 8b 05 00 00	 jmp	 $LN1@CGPartyReq
$LN10@CGPartyReq:

; 10985: 
; 10986: 	//   .
; 10987: 	if( gObjIsConnected(&gObj[number]) == FALSE ) {

  0025e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00265	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsConnected
  00271	83 c4 04	 add	 esp, 4
  00274	85 c0		 test	 eax, eax
  00276	75 15		 jne	 SHORT $LN11@CGPartyReq

; 10988: 		GCResultSend(aIndex, 0x41, 0x03);

  00278	6a 03		 push	 3
  0027a	6a 41		 push	 65			; 00000041H
  0027c	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0027f	50		 push	 eax
  00280	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00285	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10989: 		return;

  00288	e9 5c 05 00 00	 jmp	 $LN1@CGPartyReq
$LN11@CGPartyReq:

; 10990: 	}
; 10991: 	if( gObj[aIndex].CloseCount >= 0 || gObj[number].CloseCount >= 0 ) 

  0028d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00294	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0029a	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  0029f	85 d2		 test	 edx, edx
  002a1	7d 16		 jge	 SHORT $LN13@CGPartyReq
  002a3	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b0	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  002b5	85 d2		 test	 edx, edx
  002b7	7c 15		 jl	 SHORT $LN12@CGPartyReq
$LN13@CGPartyReq:

; 10992: 	{
; 10993: 		GCResultSend(aIndex, 0x41, 0x00);

  002b9	6a 00		 push	 0
  002bb	6a 41		 push	 65			; 00000041H
  002bd	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002c0	50		 push	 eax
  002c1	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10994: 		return;

  002c9	e9 1b 05 00 00	 jmp	 $LN1@CGPartyReq
$LN12@CGPartyReq:

; 10995: 	}
; 10996: 
; 10997: #ifdef MODIFY_REQUESTNPC_HACK
; 10998: 	if (gObj[number].Type != OBJTYPE_CHARACTER)

  002ce	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002db	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  002e0	83 fa 01	 cmp	 edx, 1
  002e3	74 7f		 je	 SHORT $LN14@CGPartyReq

; 10999: 	{
; 11000: 		LogAddC(LOGC_RED,"[HACKTOOL] : NPC-PartyRequest npc:%d ip:%s account:%s name:%s State:%d", 

  002e5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f2	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  002f6	52		 push	 edx
  002f7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00304	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00308	52		 push	 edx
  00309	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00310	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00316	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0031a	52		 push	 edx
  0031b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00322	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00328	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  0032c	52		 push	 edx
  0032d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00334	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0033a	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00342	52		 push	 edx
  00343	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@LCEBGPEH@?$FLHACKTOOL?$FN?5?3?5NPC?9PartyRequest?5n@
  00348	6a 02		 push	 2
  0034a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00350	83 c4 1c	 add	 esp, 28			; 0000001cH

; 11001: 			gObj[number].Class, 
; 11002: 			gObj[aIndex].Ip_addr,
; 11003: 			gObj[aIndex].AccountID, 
; 11004: 			gObj[aIndex].Name, 
; 11005: 			gObj[aIndex].Connected);
; 11006: 		
; 11007: 		CloseClient(aIndex);

  00353	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00356	50		 push	 eax
  00357	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0035c	83 c4 04	 add	 esp, 4

; 11008: 		return;

  0035f	e9 85 04 00 00	 jmp	 $LN1@CGPartyReq
$LN14@CGPartyReq:

; 11009: 	}
; 11010: #endif // MODIFY_REQUESTNPC_HACK
; 11011: 
; 11012: #ifdef ADD_NEWPVP_PKFIELD
; 11013: 	if ( g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[number]) )
; 11014: 	{
; 11015: 		// "    ."
; 11016: 		GCServerMsgStringSend(lMsg.Get(3424), aIndex, 1);
; 11017: 		return;
; 11018: 	}
; 11019: 
; 11020: 	if ( g_NewPVP.IsObserver(gObj[aIndex]) )
; 11021: 	{
; 11022: 		// "    ."
; 11023: 		GCServerMsgStringSend(lMsg.Get(3425), aIndex, 1);
; 11024: 		return;
; 11025: 	}
; 11026: #endif // ADD_NEWPVP_PKFIELD
; 11027: 
; 11028: #ifdef FOR_BLOODCASTLE
; 11029: /*
; 11030: 	if (CHECK_BLOODCASTLE(gObj[aIndex].MapNumber)) {	
; 11031: 		//       
; 11032: 		if (!g_BloodCastle.CheckCanParty(gObj[aIndex].MapNumber - MAP_INDEX_BLOODCASTLE1)) {
; 11033: 			//    .
; 11034: 			GCServerMsgStringSend(lMsg.Get(1173), aIndex, 1);		// "       ."
; 11035: 			return;
; 11036: 		}
; 11037: 	}
; 11038: */
; 11039: #endif
; 11040: 
; 11041: #ifdef CHAOSCASTLE_SYSTEM_20040408		//       
; 11042: 	if (CHECK_CHAOSCASTLE(gObj[aIndex].MapNumber)) {

  00364	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0036b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00371	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00379	83 fa 12	 cmp	 edx, 18			; 00000012H
  0037c	7d 0c		 jge	 SHORT $LN28@CGPartyReq
  0037e	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv261[ebp], 0
  00388	eb 3c		 jmp	 SHORT $LN29@CGPartyReq
$LN28@CGPartyReq:
  0038a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00391	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00397	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0039f	83 fa 17	 cmp	 edx, 23			; 00000017H
  003a2	7e 0c		 jle	 SHORT $LN26@CGPartyReq
  003a4	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv260[ebp], 0
  003ae	eb 0a		 jmp	 SHORT $LN27@CGPartyReq
$LN26@CGPartyReq:
  003b0	c7 85 90 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv260[ebp], 1
$LN27@CGPartyReq:
  003ba	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv260[ebp]
  003c0	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv261[ebp], eax
$LN29@CGPartyReq:
  003c6	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv261[ebp], 0
  003cd	74 24		 je	 SHORT $LN15@CGPartyReq

; 11043: 		GCServerMsgStringSend(lMsg.Get(1222), aIndex, 1);		// "      ."

  003cf	6a 01		 push	 1
  003d1	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003d4	50		 push	 eax
  003d5	68 c6 04 00 00	 push	 1222			; 000004c6H
  003da	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003e5	50		 push	 eax
  003e6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11044: 		return;

  003ee	e9 f6 03 00 00	 jmp	 $LN1@CGPartyReq
$LN15@CGPartyReq:

; 11045: 	}
; 11046: #endif
; 11047: 
; 11048: #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_6_200708013	//       , wtf  
; 11049: 	if(CHECK_ILLUSION_TEMPLE(gObj[aIndex].MapNumber)) 
; 11050: 	{
; 11051: 		GCServerMsgStringSend(lMsg.Get(3397), aIndex, 1);		// "     ."
; 11052: 		return;
; 11053: 	}
; 11054: #endif
; 11055: 	
; 11056: #ifdef AUTH_GAMESERVER_CHECKKEY
; 11057: 	if( szAuthKey[4] != AUTH_CHECK_04 )
; 11058: 		DestroyGIocp();
; 11059: #endif
; 11060: 
; 11061: 	LogAddL("Party result : %d %d %d %d", gObj[aIndex].CloseCount, gObj[number].CloseCount, gObj[aIndex].Connected, gObj[number].Connected);

  003f3	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  003fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00400	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00404	52		 push	 edx
  00405	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0040c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00412	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00416	52		 push	 edx
  00417	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0041e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00424	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  00429	52		 push	 edx
  0042a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00431	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00437	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  0043c	52		 push	 edx
  0043d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd@
  00442	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  00448	83 c4 14	 add	 esp, 20			; 00000014H

; 11062: 	LogAddL("%s %s", gObj[aIndex].Name, gObj[number].Name);

  0044b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00452	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00458	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0045c	52		 push	 edx
  0045d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00464	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0046a	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0046e	52		 push	 edx
  0046f	68 00 00 00 00	 push	 OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs@
  00474	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  0047a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11063: 	//     
; 11064: 	
; 11065: 	if( gObj[aIndex].m_IfState.use > 0 ) {

  0047d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00484	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0048a	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00491	80 e2 03	 and	 dl, 3
  00494	0f b6 c2	 movzx	 eax, dl
  00497	85 c0		 test	 eax, eax
  00499	7e 15		 jle	 SHORT $LN16@CGPartyReq

; 11066: 		GCResultSend(aIndex, 0x41, 0x00);

  0049b	6a 00		 push	 0
  0049d	6a 41		 push	 65			; 00000041H
  0049f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004a2	50		 push	 eax
  004a3	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  004a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11067: 		return;

  004ab	e9 39 03 00 00	 jmp	 $LN1@CGPartyReq
$LN16@CGPartyReq:

; 11068: 	}
; 11069: 	
; 11070: 	//     
; 11071: 	if( gObj[number].m_IfState.use > 0 ) {

  004b0	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  004b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004bd	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  004c4	80 e2 03	 and	 dl, 3
  004c7	0f b6 c2	 movzx	 eax, dl
  004ca	85 c0		 test	 eax, eax
  004cc	7e 15		 jle	 SHORT $LN17@CGPartyReq

; 11072: 		GCResultSend(aIndex, 0x41, 0x00);

  004ce	6a 00		 push	 0
  004d0	6a 41		 push	 65			; 00000041H
  004d2	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004d5	50		 push	 eax
  004d6	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  004db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11073: 		return;

  004de	e9 06 03 00 00	 jmp	 $LN1@CGPartyReq
$LN17@CGPartyReq:

; 11074: 	}
; 11075: 	
; 11076: 	if( (gObj[number].m_Option&OPTION_TRADE) != OPTION_TRADE )

  004e3	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  004ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004f0	8b 94 01 c0 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3264]
  004f7	83 e2 01	 and	 edx, 1
  004fa	75 15		 jne	 SHORT $LN18@CGPartyReq

; 11077: 	{
; 11078: 		GCResultSend(aIndex, 0x41, 0x01);

  004fc	6a 01		 push	 1
  004fe	6a 41		 push	 65			; 00000041H
  00500	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00503	50		 push	 eax
  00504	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00509	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11079: 		return;

  0050c	e9 d8 02 00 00	 jmp	 $LN1@CGPartyReq
$LN18@CGPartyReq:

; 11080: 	}
; 11081: 
; 11082: 	//       ..
; 11083: 	if( gObj[aIndex].PartyNumber >= 0 ) 

  00511	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00518	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0051e	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  00526	7c 70		 jl	 SHORT $LN19@CGPartyReq

; 11084: 	{
; 11085: 		int user, dbnumber;
; 11086: 		gParty.GetIndexUser(gObj[aIndex].PartyNumber, 0, user, dbnumber);

  00528	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _dbnumber$1[ebp]
  0052e	50		 push	 eax
  0052f	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _user$2[ebp]
  00535	51		 push	 ecx
  00536	6a 00		 push	 0
  00538	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0053f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00544	8b 8c 10 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+edx+648]
  0054b	51		 push	 ecx
  0054c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00551	e8 00 00 00 00	 call	 ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ; PartyClass::GetIndexUser

; 11087: 		if( (user < 0) || (user!=aIndex && gObj[aIndex].DBNumber!=dbnumber) )

  00556	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR _user$2[ebp], 0
  0055d	7c 24		 jl	 SHORT $LN21@CGPartyReq
  0055f	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _user$2[ebp]
  00565	3b 45 0c	 cmp	 eax, DWORD PTR _aIndex$[ebp]
  00568	74 2e		 je	 SHORT $LN19@CGPartyReq
  0056a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00571	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00577	8b 54 01 2c	 mov	 edx, DWORD PTR [ecx+eax+44]
  0057b	3b 95 e0 fe ff
	ff		 cmp	 edx, DWORD PTR _dbnumber$1[ebp]
  00581	74 15		 je	 SHORT $LN19@CGPartyReq
$LN21@CGPartyReq:

; 11088: 		{
; 11089: 			GCResultSend(aIndex, 0x41, 0x00);

  00583	6a 00		 push	 0
  00585	6a 41		 push	 65			; 00000041H
  00587	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0058a	50		 push	 eax
  0058b	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00590	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11090: 			return;

  00593	e9 51 02 00 00	 jmp	 $LN1@CGPartyReq
$LN19@CGPartyReq:

; 11091: 		}		
; 11092: 	}
; 11093: 	
; 11094: 	//     
; 11095: 	if( gObj[aIndex].PartyTargetUser >= 0 ) return;

  00598	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0059f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a5	83 bc 01 8c 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+652], 0
  005ad	7c 05		 jl	 SHORT $LN22@CGPartyReq
  005af	e9 35 02 00 00	 jmp	 $LN1@CGPartyReq
$LN22@CGPartyReq:

; 11096: 
; 11097: 	if( gObj[number].PartyNumber >= 0 ) {

  005b4	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  005bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c1	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  005c9	7c 15		 jl	 SHORT $LN23@CGPartyReq

; 11098: 		GCResultSend(aIndex, 0x41, 0x04);	//      .

  005cb	6a 04		 push	 4
  005cd	6a 41		 push	 65			; 00000041H
  005cf	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005d2	50		 push	 eax
  005d3	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  005d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11099: 		return;

  005db	e9 09 02 00 00	 jmp	 $LN1@CGPartyReq
$LN23@CGPartyReq:

; 11100: 	}
; 11101: 	//      .
; 11102: 	//if( gObj[number].PartyNumber >= 0 ) return;
; 11103: 	if( gObj[number].PartyTargetUser >= 0 ) {

  005e0	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  005e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ed	83 bc 01 8c 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+652], 0
  005f5	7c 15		 jl	 SHORT $LN24@CGPartyReq

; 11104: 		GCResultSend(aIndex, 0x41, 0x00);

  005f7	6a 00		 push	 0
  005f9	6a 41		 push	 65			; 00000041H
  005fb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00604	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11105: 		return;

  00607	e9 dd 01 00 00	 jmp	 $LN1@CGPartyReq
$LN24@CGPartyReq:

; 11106: 	}
; 11107: 
; 11108: 		//       ?
; 11109: 	int maxlevel=0, minlevel=0;

  0060c	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _maxlevel$[ebp], 0
  00616	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _minlevel$[ebp], 0

; 11110: #ifndef UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 11111: 	if( gObj[aIndex].PartyNumber >= 0 )
; 11112: 	{
; 11113: 		if( gParty.GetLevel(gObj[aIndex].PartyNumber, maxlevel, minlevel) == TRUE )
; 11114: 		{
; 11115: 			if( max(maxlevel,gObj[number].Level)-min(maxlevel,gObj[number].Level) > PARTY_LENGTH )
; 11116: 			{
; 11117: 				GCResultSend(aIndex, 0x41, 0x05);				
; 11118: 				LogAdd(lMsg.Get(701), PARTY_LENGTH, gObj[aIndex].Name, gObj[aIndex].Level,gObj[number].Name, gObj[number].Level);
; 11119: 				return;
; 11120: 			}
; 11121: 			if( max(minlevel,gObj[number].Level)-min(minlevel,gObj[number].Level) > PARTY_LENGTH )
; 11122: 			{
; 11123: 				GCResultSend(aIndex, 0x41, 0x05);
; 11124: 				LogAdd(lMsg.Get(701), PARTY_LENGTH, gObj[aIndex].Name, gObj[aIndex].Level,gObj[number].Name, gObj[number].Level);
; 11125: 				return;
; 11126: 			}
; 11127: 		}
; 11128: 	}
; 11129: 	else //   ..  
; 11130: 	{
; 11131: 		if( max(gObj[aIndex].Level,gObj[number].Level)-min(gObj[aIndex].Level,gObj[number].Level) > PARTY_LENGTH )
; 11132: 		{
; 11133: 			GCResultSend(aIndex, 0x41, 0x05);
; 11134: 			LogAdd(lMsg.Get(701), PARTY_LENGTH, gObj[aIndex].Name, gObj[aIndex].Level,gObj[number].Name, gObj[number].Level);
; 11135: 			return;
; 11136: 		}
; 11137: 	}
; 11138: #endif
; 11139: 
; 11140: 	
; 11141: 	gObj[aIndex].m_IfState.use    = 1;

  00620	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00627	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0062d	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00634	80 e2 fc	 and	 dl, 252			; 000000fcH
  00637	80 ca 01	 or	 dl, 1
  0063a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00641	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00647	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11142: 	gObj[aIndex].m_IfState.type   = I_PARTY;

  0064e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00655	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0065b	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00662	80 e2 0f	 and	 dl, 15			; 0000000fH
  00665	80 ca 20	 or	 dl, 32			; 00000020H
  00668	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0066f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00675	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11143: 	gObj[aIndex].m_IfState.state  = 0;

  0067c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00683	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00689	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00690	80 e2 f3	 and	 dl, 243			; 000000f3H
  00693	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0069a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006a0	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11144: 	gObj[number].m_IfState.use    = 1;

  006a7	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  006ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006b4	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  006bb	80 e2 fc	 and	 dl, 252			; 000000fcH
  006be	80 ca 01	 or	 dl, 1
  006c1	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  006c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006ce	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11145: 	gObj[number].m_IfState.type   = I_PARTY;

  006d5	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  006dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006e2	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  006e9	80 e2 0f	 and	 dl, 15			; 0000000fH
  006ec	80 ca 20	 or	 dl, 32			; 00000020H
  006ef	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  006f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006fc	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11146: 	gObj[number].m_IfState.state  = 0;

  00703	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0070a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00710	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00717	80 e2 f3	 and	 dl, 243			; 000000f3H
  0071a	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00721	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00727	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 11147: 	gObj[aIndex].TargetNumber     = number;

  0072e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00735	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0073b	66 8b 55 f8	 mov	 dx, WORD PTR _number$[ebp]
  0073f	66 89 94 01 ac
	02 00 00	 mov	 WORD PTR [ecx+eax+684], dx

; 11148: 	gObj[number].TargetNumber     = aIndex;

  00747	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0074e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00754	66 8b 55 0c	 mov	 dx, WORD PTR _aIndex$[ebp]
  00758	66 89 94 01 ac
	02 00 00	 mov	 WORD PTR [ecx+eax+684], dx

; 11149: 	gObj[aIndex].m_InterfaceTime  = GetTickCount();

  00760	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00766	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0076d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00773	89 84 0a 58 0c
	00 00		 mov	 DWORD PTR [edx+ecx+3160], eax

; 11150: 	gObj[number].m_InterfaceTime  = GetTickCount();

  0077a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00780	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  00787	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0078d	89 84 0a 58 0c
	00 00		 mov	 DWORD PTR [edx+ecx+3160], eax

; 11151: 
; 11152: 	gObj[aIndex].PartyTargetUser  = number;

  00794	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0079b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007a1	8b 55 f8	 mov	 edx, DWORD PTR _number$[ebp]
  007a4	89 94 01 8c 02
	00 00		 mov	 DWORD PTR [ecx+eax+652], edx

; 11153: 	
; 11154: 	//     .
; 11155: 	PHeadSetB((LPBYTE)&pMsg, 0x40, sizeof( pMsg ));

  007ab	6a 05		 push	 5
  007ad	6a 40		 push	 64			; 00000040H
  007af	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  007b2	50		 push	 eax
  007b3	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  007b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11156: 	pMsg.NumberH    = HIBYTE(aIndex);

  007bb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007be	c1 e8 08	 shr	 eax, 8
  007c1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007c6	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 11157: 	pMsg.NumberL    = LOBYTE(aIndex);

  007c9	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007cc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007d1	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 11158: 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  007d4	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  007d8	50		 push	 eax
  007d9	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  007dc	51		 push	 ecx
  007dd	8b 55 f8	 mov	 edx, DWORD PTR _number$[ebp]
  007e0	52		 push	 edx
  007e1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  007e6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGPartyReq:

; 11159: }

  007e9	5f		 pop	 edi
  007ea	5e		 pop	 esi
  007eb	5b		 pop	 ebx
  007ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ef	33 cd		 xor	 ecx, ebp
  007f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007f6	8b e5		 mov	 esp, ebp
  007f8	5d		 pop	 ebp
  007f9	c3		 ret	 0
?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ENDP	; CGPartyRequestRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z
_TEXT	SEGMENT
tv133 = -80						; size = 4
tv137 = -76						; size = 4
tv134 = -76						; size = 4
_pAttack$ = -8						; size = 8
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 1
_usernumber$ = 16					; size = 4
_skillsuccess$ = 20					; size = 1
?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z PROC ; GCMagicAttackNumberSend, COMDAT

; 15434: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15435: 	PMSG_MAGICATTACK_RESULT	pAttack;
; 15436: 
; 15437: 	PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof( pAttack ));

  00009	6a 08		 push	 8
  0000b	6a 19		 push	 25			; 00000019H
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15438: 
; 15439: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD 
; 15440: 	pAttack.MagicNumberH   = HIBYTE( MagicNumber );
; 15441: 	pAttack.MagicNumberL   = LOBYTE( MagicNumber );
; 15442: #else
; 15443: 	pAttack.MagicNumber   = MagicNumber;

  00019	8a 45 0c	 mov	 al, BYTE PTR _MagicNumber$[ebp]
  0001c	88 45 fb	 mov	 BYTE PTR _pAttack$[ebp+3], al

; 15444: #endif
; 15445: 	pAttack.SourceNumberH = HIBYTE(lpObj->m_Index);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	c1 e9 08	 shr	 ecx, 8
  00027	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0002d	88 4d fc	 mov	 BYTE PTR _pAttack$[ebp+4], cl

; 15446: 	pAttack.SourceNumberL = LOBYTE(lpObj->m_Index);	

  00030	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0003b	88 4d fd	 mov	 BYTE PTR _pAttack$[ebp+5], cl

; 15447: 	pAttack.TargetNumberH = HIBYTE(usernumber);

  0003e	8b 45 10	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00041	c1 e8 08	 shr	 eax, 8
  00044	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00049	88 45 fe	 mov	 BYTE PTR _pAttack$[ebp+6], al

; 15448: 	pAttack.TargetNumberL = LOBYTE(usernumber);

  0004c	8b 45 10	 mov	 eax, DWORD PTR _usernumber$[ebp]
  0004f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00054	88 45 ff	 mov	 BYTE PTR _pAttack$[ebp+7], al

; 15449: 	pAttack.TargetNumberH &= 0x7F;

  00057	0f b6 45 fe	 movzx	 eax, BYTE PTR _pAttack$[ebp+6]
  0005b	83 e0 7f	 and	 eax, 127		; 0000007fH
  0005e	88 45 fe	 mov	 BYTE PTR _pAttack$[ebp+6], al

; 15450: 	if( skillsuccess )

  00061	0f b6 45 14	 movzx	 eax, BYTE PTR _skillsuccess$[ebp]
  00065	85 c0		 test	 eax, eax
  00067	74 0c		 je	 SHORT $LN4@GCMagicAtt

; 15451: 	{
; 15452: 		pAttack.TargetNumberH |= 0x80;

  00069	0f b6 45 fe	 movzx	 eax, BYTE PTR _pAttack$[ebp+6]
  0006d	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00072	88 45 fe	 mov	 BYTE PTR _pAttack$[ebp+6], al
$LN4@GCMagicAtt:

; 15453: 	}
; 15454: 
; 15455: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00075	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00078	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0007c	83 f9 01	 cmp	 ecx, 1
  0007f	75 17		 jne	 SHORT $LN5@GCMagicAtt

; 15456: 		DataSend(lpObj->m_Index, (LPBYTE)&pAttack, pAttack.h.size);

  00081	0f b6 45 f9	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  00085	50		 push	 eax
  00086	8d 4d f8	 lea	 ecx, DWORD PTR _pAttack$[ebp]
  00089	51		 push	 ecx
  0008a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0008d	8b 02		 mov	 eax, DWORD PTR [edx]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@GCMagicAtt:

; 15457: 
; 15458: #ifdef CHAOSCASTLE_SYSTEM_20040408		// !!> .         .
; 15459: 	if (CHECK_CHAOSCASTLE(lpObj->MapNumber)) {

  00098	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000a2	83 f9 12	 cmp	 ecx, 18			; 00000012H
  000a5	7d 09		 jge	 SHORT $LN11@GCMagicAtt
  000a7	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], 0
  000ae	eb 25		 jmp	 SHORT $LN12@GCMagicAtt
$LN11@GCMagicAtt:
  000b0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b3	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000ba	83 f8 17	 cmp	 eax, 23			; 00000017H
  000bd	7e 09		 jle	 SHORT $LN9@GCMagicAtt
  000bf	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
  000c6	eb 07		 jmp	 SHORT $LN10@GCMagicAtt
$LN9@GCMagicAtt:
  000c8	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv133[ebp], 1
$LN10@GCMagicAtt:
  000cf	8b 4d b0	 mov	 ecx, DWORD PTR tv133[ebp]
  000d2	89 4d b4	 mov	 DWORD PTR tv134[ebp], ecx
$LN12@GCMagicAtt:
  000d5	83 7d b4 00	 cmp	 DWORD PTR tv134[ebp], 0
  000d9	74 29		 je	 SHORT $LN6@GCMagicAtt

; 15460: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//      (0x19)
; 15461: 		if( g_MasterSkillSystem.CheckMasterLevelSkill( MagicNumber ) )
; 15462: 		{
; 15463: 			INT iBaseMLS = g_MasterSkillSystem.GetBaseMasterLevelSkill( MagicNumber );
; 15464: 			switch( iBaseMLS )
; 15465: 			{
; 15466: 			case AT_SKILL_ML_STRENGTHEN_MAGICDEFENSE:	//  
; 15467: 			case AT_SKILL_ML_STRENGTHEN_KNIGHTADDLIFE:	//  
; 15468: 			case AT_SKILL_ML_STRENGTHEN_HEALING:		//  
; 15469: #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428
; 15470: 			case AT_SKILL_ML_STRENGTHEN_DEFENSE:		//   
; 15471: 			case AT_SKILL_ML_STRENGTHEN_ATTACK:			//   
; 15472: #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428				
; 15473: 				return;							
; 15474: 			}
; 15475: 		}
; 15476: 		else
; 15477: #endif	// ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107
; 15478: 		switch(MagicNumber) {

  000db	0f b6 45 0c	 movzx	 eax, BYTE PTR _MagicNumber$[ebp]
  000df	89 45 b4	 mov	 DWORD PTR tv137[ebp], eax
  000e2	8b 4d b4	 mov	 ecx, DWORD PTR tv137[ebp]
  000e5	83 e9 10	 sub	 ecx, 16			; 00000010H
  000e8	89 4d b4	 mov	 DWORD PTR tv137[ebp], ecx
  000eb	83 7d b4 20	 cmp	 DWORD PTR tv137[ebp], 32 ; 00000020H
  000ef	77 13		 ja	 SHORT $LN6@GCMagicAtt
  000f1	8b 55 b4	 mov	 edx, DWORD PTR tv137[ebp]
  000f4	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN13@GCMagicAtt[edx]
  000fb	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@GCMagicAtt[eax*4]
$LN7@GCMagicAtt:

; 15479: 		case AT_SKILL_MAGICDEFENSE :	// 
; 15480: 		case AT_SKILL_KNIGHTADDLIFE :	// 
; 15481: 		case AT_SKILL_DEFENSE :			// 
; 15482: 		case AT_SKILL_ATTACK :			// 
; 15483: 		case AT_SKILL_HEALING :			// 
; 15484: 			return;

  00102	eb 15		 jmp	 SHORT $LN1@GCMagicAtt
$LN6@GCMagicAtt:

; 15485: 		}
; 15486: 	}
; 15487: #endif
; 15488: 	
; 15489: 	MsgSendV2(lpObj, (LPBYTE)&pAttack, pAttack.h.size);

  00104	0f b6 45 f9	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  00108	50		 push	 eax
  00109	8d 4d f8	 lea	 ecx, DWORD PTR _pAttack$[ebp]
  0010c	51		 push	 ecx
  0010d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00110	52		 push	 edx
  00111	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCMagicAtt:

; 15490: }

  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN14@GCMagicAtt:
  00120	00 00 00 00	 DD	 $LN7@GCMagicAtt
  00124	00 00 00 00	 DD	 $LN6@GCMagicAtt
$LN13@GCMagicAtt:
  00128	00		 DB	 0
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	01		 DB	 1
  0012c	01		 DB	 1
  0012d	01		 DB	 1
  0012e	01		 DB	 1
  0012f	01		 DB	 1
  00130	01		 DB	 1
  00131	01		 DB	 1
  00132	00		 DB	 0
  00133	00		 DB	 0
  00134	00		 DB	 0
  00135	01		 DB	 1
  00136	01		 DB	 1
  00137	01		 DB	 1
  00138	01		 DB	 1
  00139	01		 DB	 1
  0013a	01		 DB	 1
  0013b	01		 DB	 1
  0013c	01		 DB	 1
  0013d	01		 DB	 1
  0013e	01		 DB	 1
  0013f	01		 DB	 1
  00140	01		 DB	 1
  00141	01		 DB	 1
  00142	01		 DB	 1
  00143	01		 DB	 1
  00144	01		 DB	 1
  00145	01		 DB	 1
  00146	01		 DB	 1
  00147	01		 DB	 1
  00148	00		 DB	 0
?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z ENDP ; GCMagicAttackNumberSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCActionSend2@@YAXPAVOBJECTSTRUCT@@EHH@Z
_TEXT	SEGMENT
_pActionResult$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_ActionNumber$ = 12					; size = 1
_aIndex$ = 16						; size = 4
_aTargetIndex$ = 20					; size = 4
?GCActionSend2@@YAXPAVOBJECTSTRUCT@@EHH@Z PROC		; GCActionSend2, COMDAT

; 15093: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 15094: 	PMSG_ACTIONRESULT pActionResult;
; 15095: 
; 15096: 	PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  00013	6a 09		 push	 9
  00015	6a 18		 push	 24			; 00000018H
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pActionResult$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15097: 	pActionResult.NumberH = SET_NUMBERH(aIndex);

  00023	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00026	c1 e8 08	 shr	 eax, 8
  00029	88 45 f3	 mov	 BYTE PTR _pActionResult$[ebp+3], al

; 15098: 	pActionResult.NumberL = SET_NUMBERL(aIndex);

  0002c	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0002f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00034	88 45 f4	 mov	 BYTE PTR _pActionResult$[ebp+4], al

; 15099: 	pActionResult.ActionNumber = ActionNumber;

  00037	8a 45 0c	 mov	 al, BYTE PTR _ActionNumber$[ebp]
  0003a	88 45 f6	 mov	 BYTE PTR _pActionResult$[ebp+6], al

; 15100: 	pActionResult.Dir = lpObj->Dir;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00040	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00046	88 4d f5	 mov	 BYTE PTR _pActionResult$[ebp+5], cl

; 15101: 	pActionResult.TargetNumberH = SET_NUMBERH(aTargetIndex);

  00049	8b 45 14	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0004c	c1 e8 08	 shr	 eax, 8
  0004f	88 45 f7	 mov	 BYTE PTR _pActionResult$[ebp+7], al

; 15102: 	pActionResult.TargetNumberL = SET_NUMBERL(aTargetIndex);

  00052	8b 45 14	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00055	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005a	88 45 f8	 mov	 BYTE PTR _pActionResult$[ebp+8], al

; 15103: 
; 15104: 	MsgSendV2(lpObj, (LPBYTE)&pActionResult, pActionResult.h.size);

  0005d	0f b6 45 f1	 movzx	 eax, BYTE PTR _pActionResult$[ebp+1]
  00061	50		 push	 eax
  00062	8d 4d f0	 lea	 ecx, DWORD PTR _pActionResult$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15105: }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00078	33 cd		 xor	 ecx, ebp
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?GCActionSend2@@YAXPAVOBJECTSTRUCT@@EHH@Z ENDP		; GCActionSend2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCActionSend@@YAXPAVOBJECTSTRUCT@@EH@Z
_TEXT	SEGMENT
_pActionResult$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_ActionNumber$ = 12					; size = 1
_aIndex$ = 16						; size = 4
?GCActionSend@@YAXPAVOBJECTSTRUCT@@EH@Z PROC		; GCActionSend, COMDAT

; 15072: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 15073: 	PMSG_ACTIONRESULT	pActionResult;
; 15074: 		
; 15075: 	//      .
; 15076: 	
; 15077: 	PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof( pActionResult ));

  00013	6a 09		 push	 9
  00015	6a 18		 push	 24			; 00000018H
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pActionResult$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15078: 	pActionResult.NumberH		= HIBYTE(aIndex);

  00023	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00026	c1 e8 08	 shr	 eax, 8
  00029	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002e	88 45 f3	 mov	 BYTE PTR _pActionResult$[ebp+3], al

; 15079: 	pActionResult.NumberL		= LOBYTE(aIndex);

  00031	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00034	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00039	88 45 f4	 mov	 BYTE PTR _pActionResult$[ebp+4], al

; 15080: 	pActionResult.ActionNumber	= ActionNumber;

  0003c	8a 45 0c	 mov	 al, BYTE PTR _ActionNumber$[ebp]
  0003f	88 45 f6	 mov	 BYTE PTR _pActionResult$[ebp+6], al

; 15081: 
; 15082: 	pActionResult.Dir = lpObj->Dir;

  00042	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00045	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  0004b	88 4d f5	 mov	 BYTE PTR _pActionResult$[ebp+5], cl

; 15083: 
; 15084: #ifdef ADD_TRAP_OBJECT_EXTEND_20060731
; 15085: 	pActionResult.TargetNumberH = HIBYTE(aTargetIndex);
; 15086: 	pActionResult.TargetNumberL = LOBYTE(aTargetIndex);
; 15087: #endif // ADD_TRAP_OBJECT_EXTEND_20060731
; 15088: 
; 15089: 	MsgSendV2(lpObj, (LPBYTE)&pActionResult, pActionResult.h.size);	

  0004e	0f b6 45 f1	 movzx	 eax, BYTE PTR _pActionResult$[ebp+1]
  00052	50		 push	 eax
  00053	8d 4d f0	 lea	 ecx, DWORD PTR _pActionResult$[ebp]
  00056	51		 push	 ecx
  00057	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15090: }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00069	33 cd		 xor	 ecx, ebp
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?GCActionSend@@YAXPAVOBJECTSTRUCT@@EH@Z ENDP		; GCActionSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCKillPlayerExpSend@@YAXHHHHH@Z
_TEXT	SEGMENT
tv131 = -88						; size = 4
tv132 = -84						; size = 4
_pkillMsg$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_exp$ = 16						; size = 4
_AttackDamage$ = 20					; size = 4
_MSBFlag$ = 24						; size = 4
?GCKillPlayerExpSend@@YAXHHHHH@Z PROC			; GCKillPlayerExpSend, COMDAT

; 14964: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 14965: 	PMSG_KILLPLAYER	pkillMsg;
; 14966: 	
; 14967: 	PHeadSetBE((LPBYTE)&pkillMsg, 0x16, sizeof( pkillMsg));

  00013	6a 09		 push	 9
  00015	6a 16		 push	 22			; 00000016H
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pkillMsg$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14968: 
; 14969: 	pkillMsg.NumberH	= HIBYTE( TargetIndex );

  00023	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00026	c1 e8 08	 shr	 eax, 8
  00029	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002e	88 45 f3	 mov	 BYTE PTR _pkillMsg$[ebp+3], al

; 14970: 	pkillMsg.NumberL	= LOBYTE( TargetIndex );

  00031	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00034	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00039	88 45 f4	 mov	 BYTE PTR _pkillMsg$[ebp+4], al

; 14971: 	pkillMsg.ExpH		= HIBYTE( exp ) ;

  0003c	8b 45 10	 mov	 eax, DWORD PTR _exp$[ebp]
  0003f	c1 e8 08	 shr	 eax, 8
  00042	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00047	88 45 f5	 mov	 BYTE PTR _pkillMsg$[ebp+5], al

; 14972: 	pkillMsg.ExpL		= LOBYTE( exp ) ;

  0004a	8b 45 10	 mov	 eax, DWORD PTR _exp$[ebp]
  0004d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00052	88 45 f6	 mov	 BYTE PTR _pkillMsg$[ebp+6], al

; 14973: 	pkillMsg.DamageH    = HIBYTE( AttackDamage );

  00055	8b 45 14	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00060	88 45 f7	 mov	 BYTE PTR _pkillMsg$[ebp+7], al

; 14974: 	pkillMsg.DamageL    = LOBYTE( AttackDamage );

  00063	8b 45 14	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00066	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0006b	88 45 f8	 mov	 BYTE PTR _pkillMsg$[ebp+8], al

; 14975: 	
; 14976: 	if( MSBFlag )

  0006e	83 7d 18 00	 cmp	 DWORD PTR _MSBFlag$[ebp], 0
  00072	74 16		 je	 SHORT $LN2@GCKillPlay

; 14977: 	{
; 14978: 		pkillMsg.NumberH &= 0x7F;

  00074	0f b6 45 f3	 movzx	 eax, BYTE PTR _pkillMsg$[ebp+3]
  00078	83 e0 7f	 and	 eax, 127		; 0000007fH
  0007b	88 45 f3	 mov	 BYTE PTR _pkillMsg$[ebp+3], al

; 14979: 		pkillMsg.NumberH |= 0x80;

  0007e	0f b6 45 f3	 movzx	 eax, BYTE PTR _pkillMsg$[ebp+3]
  00082	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00087	88 45 f3	 mov	 BYTE PTR _pkillMsg$[ebp+3], al
$LN2@GCKillPlay:

; 14980: 	}
; 14981: #ifdef FOR_BLOODCASTLE
; 14982: 	//      .
; 14983: 	if (CHECK_BLOODCASTLE(gObj[aIndex].MapNumber)) {

  0008a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00097	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0009f	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  000a2	7d 09		 jge	 SHORT $LN7@GCKillPlay
  000a4	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
  000ab	eb 30		 jmp	 SHORT $LN8@GCKillPlay
$LN7@GCKillPlay:
  000ad	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ba	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000c2	83 fa 11	 cmp	 edx, 17			; 00000011H
  000c5	7e 09		 jle	 SHORT $LN5@GCKillPlay
  000c7	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv131[ebp], 0
  000ce	eb 07		 jmp	 SHORT $LN6@GCKillPlay
$LN5@GCKillPlay:
  000d0	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
$LN6@GCKillPlay:
  000d7	8b 45 a8	 mov	 eax, DWORD PTR tv131[ebp]
  000da	89 45 ac	 mov	 DWORD PTR tv132[ebp], eax
$LN8@GCKillPlay:
  000dd	83 7d ac 00	 cmp	 DWORD PTR tv132[ebp], 0
  000e1	74 12		 je	 SHORT $LN3@GCKillPlay

; 14984: 		g_BloodCastle.AddExperience(aIndex, exp);

  000e3	8b 45 10	 mov	 eax, DWORD PTR _exp$[ebp]
  000e6	50		 push	 eax
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000ea	51		 push	 ecx
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000f0	e8 00 00 00 00	 call	 ?AddExperience@CBloodCastle@@QAE_NHH@Z ; CBloodCastle::AddExperience
$LN3@GCKillPlay:

; 14985: 	}
; 14986: #endif
; 14987: 
; 14988: 	//    .
; 14989: 	DataSend(aIndex, (LPBYTE)&pkillMsg, pkillMsg.h.size);

  000f5	0f b6 45 f1	 movzx	 eax, BYTE PTR _pkillMsg$[ebp+1]
  000f9	50		 push	 eax
  000fa	8d 4d f0	 lea	 ecx, DWORD PTR _pkillMsg$[ebp]
  000fd	51		 push	 ecx
  000fe	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14990: 
; 14991: #ifdef TEST_MSG_MLS_ACTIVE_20080131
; 14992: #if TESTSERVER == 1
; 14993: 	PMSG_NOTICE	pNotice;
; 14994: 	CHAR szNotice[256] = {0,};
; 14995: 	
; 14996: //	TNotice::SetNoticeProperty( &pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED );
; 14997: 	wsprintf( szNotice, "[%s]->[%s] : %d (Kill)", gObj[aIndex].Name, gObj[TargetIndex].Name, AttackDamage );
; 14998: 	TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 14999: 	TNotice::SendNoticeToUser( aIndex, &pNotice );
; 15000: 	TNotice::SendNoticeToUser( TargetIndex, &pNotice );
; 15001: #endif
; 15002: #endif
; 15003: }

  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	33 cd		 xor	 ecx, ebp
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
?GCKillPlayerExpSend@@YAXHHHHH@Z ENDP			; GCKillPlayerExpSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z
_TEXT	SEGMENT
_aTargetIndex$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_lpMagic$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z PROC ; CGDurationMagicRecv, COMDAT

; 16761: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16762: 	CMagicInf *lpMagic;
; 16763: 		
; 16764: 	LPOBJECTSTRUCT lpObj= &gObj[aIndex];

  00009	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 16765: 
; 16766: 	if( lpObj->Teleport ) return;	

  00019	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  00023	85 c9		 test	 ecx, ecx
  00025	74 05		 je	 SHORT $LN2@CGDuration
  00027	e9 23 01 00 00	 jmp	 $LN1@CGDuration
$LN2@CGDuration:

; 16767: 
; 16768: 	if( gObj[aIndex].Type == OBJTYPE_CHARACTER )

  0002c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00039	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0003e	83 fa 01	 cmp	 edx, 1
  00041	75 19		 jne	 SHORT $LN3@CGDuration

; 16769: 	{
; 16770: #ifdef MODIFY_SAFEZONE_CHECK_ATTACK_20080903
; 16771: 		BYTE attr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);
; 16772: 		
; 16773: 		if( ((attr&MAP_ATTR_SAFTYZONE) == MAP_ATTR_SAFTYZONE) )		//    .
; 16774: 		{
; 16775: 			gObjSetPosition( aIndex, gObj[aIndex].X, gObj[aIndex].Y );
; 16776: 			
; 16777: 			return;
; 16778: 		}
; 16779: #endif // MODIFY_SAFEZONE_CHECK_ATTACK_20080903
; 16780: 
; 16781: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD
; 16782: 		WORD wMagicNumber = MAKEWORD( lpMsg->MagicNumberL, lpMsg->MagicNumberH );
; 16783: 		lpMagic = gObjGetMagicSearch( lpObj, wMagicNumber );
; 16784: #else
; 16785: 	#ifdef CHANGE_MAGICATTACKPACKET	//      
; 16786: 			lpMagic = gObjGetMagicSearch(lpObj, lpMsg->MagicNumber);

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00046	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0004a	51		 push	 ecx
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  00054	83 c4 08	 add	 esp, 8
  00057	89 45 fc	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 16787: 	#else
; 16788: 			lpMagic = gObjGetMagic(lpObj, lpMsg->MagicNumber);
; 16789: 	#endif
; 16790: #endif	// ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107
; 16791: 	}

  0005a	eb 17		 jmp	 SHORT $LN4@CGDuration
$LN3@CGDuration:

; 16792: 	else
; 16793: 	{
; 16794: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD
; 16795: 		WORD wMagicNumber = MAKEWORD( lpMsg->MagicNumberL, lpMsg->MagicNumberH );
; 16796: 		lpMagic = gObjGetMagic( lpObj, wMagicNumber );
; 16797: #else
; 16798: 		lpMagic = gObjGetMagic(lpObj, lpMsg->MagicNumber);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0005f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00063	51		 push	 ecx
  00064	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z ; gObjGetMagic
  0006d	83 c4 08	 add	 esp, 8
  00070	89 45 fc	 mov	 DWORD PTR _lpMagic$[ebp], eax
$LN4@CGDuration:

; 16799: #endif
; 16800: 	}
; 16801: 
; 16802: 	if( lpMagic == NULL )

  00073	83 7d fc 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00077	75 05		 jne	 SHORT $LN5@CGDuration

; 16803: 	{		
; 16804: 		return;

  00079	e9 d1 00 00 00	 jmp	 $LN1@CGDuration
$LN5@CGDuration:

; 16805: 	}
; 16806: 
; 16807: #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 16808: 	if( lpObj->Type == OBJTYPE_CHARACTER )
; 16809: 	{
; 16810: 		//     . 
; 16811: 		if( MagicDamageC.CheckStatus( lpMagic->m_Skill, lpObj->GuildStatus ) == FALSE ) 
; 16812: 		{
; 16813: 			LogAddC( LOGC_RED, "[0x1E] CGDurationMagicRecv() - Invalid Status" );
; 16814: 			return;
; 16815: 		}
; 16816: 		
; 16817: 		//  
; 16818: 		if( MagicDamageC.CheckKillCount( lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )
; 16819: 		{
; 16820: 			LogAddC( LOGC_RED, "[0x1E] CGDurationMagicRecv() - Invalid KillCount" );
; 16821: 			return;
; 16822: 		}
; 16823: 	}
; 16824: #endif
; 16825: 
; 16826: 	lpObj->UseMagicNumber = 0;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00081	c6 80 15 03 00
	00 00		 mov	 BYTE PTR [eax+789], 0

; 16827: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//     
; 16828: 	if( lpMagic->m_Skill != AT_SKILL_CROSSBOW 
; 16829: 		&& lpMagic->m_Skill != AT_SKILL_ML_STRENGTHEN_CROSSBOW
; 16830: 		)
; 16831: #else
; 16832: 	if( lpMagic->m_Skill != AT_SKILL_CROSSBOW )

  00088	8b 45 fc	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0008b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0008f	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00092	74 17		 je	 SHORT $LN6@CGDuration

; 16833: #endif
; 16834: 	{	//  
; 16835: 		if( !gObjUseSkill.SpeedHackCheck(aIndex) )

  00094	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00097	50		 push	 eax
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0009d	e8 00 00 00 00	 call	 ?SpeedHackCheck@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SpeedHackCheck
  000a2	85 c0		 test	 eax, eax
  000a4	75 05		 jne	 SHORT $LN6@CGDuration

; 16836: 			return;	//  

  000a6	e9 a4 00 00 00	 jmp	 $LN1@CGDuration
$LN6@CGDuration:

; 16837: 	}
; 16838: 
; 16839: 	//   
; 16840: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// EnableSkill(...)  
; 16841: 	if( !gObjUseSkill.EnableSkill( lpMagic->m_Skill, lpMagic->m_Level ) )
; 16842: 		return;
; 16843: #else
; 16844: 	if( !gObjUseSkill.EnableSkill(lpMagic->m_Skill) )

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000ae	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000b2	51		 push	 ecx
  000b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000b8	e8 00 00 00 00	 call	 ?EnableSkill@CObjUseSkill@@QAEHE@Z ; CObjUseSkill::EnableSkill
  000bd	85 c0		 test	 eax, eax
  000bf	75 05		 jne	 SHORT $LN8@CGDuration

; 16845: 		return;

  000c1	e9 89 00 00 00	 jmp	 $LN1@CGDuration
$LN8@CGDuration:

; 16846: #endif
; 16847: 	
; 16848: #ifdef EXPAND_ATTACK_PACKET_0X1E
; 16849: 	int aTargetIndex = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);	

  000c6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000c9	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  000cd	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000d3	0f b6 d1	 movzx	 edx, cl
  000d6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000d9	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  000dd	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e3	0f b6 c1	 movzx	 eax, cl
  000e6	c1 e0 08	 shl	 eax, 8
  000e9	0b d0		 or	 edx, eax
  000eb	0f b7 ca	 movzx	 ecx, dx
  000ee	89 4d f4	 mov	 DWORD PTR _aTargetIndex$[ebp], ecx

; 16850: 
; 16851: 	gObjUseSkill.UseSkill(aIndex, lpMagic, lpMsg->X, lpMsg->Y, lpMsg->Dir, lpMsg->TargetPos, aTargetIndex);

  000f1	8b 45 f4	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  000f4	50		 push	 eax
  000f5	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000f8	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  000fc	52		 push	 edx
  000fd	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00100	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00104	51		 push	 ecx
  00105	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00108	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00110	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00114	52		 push	 edx
  00115	8b 45 fc	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00118	50		 push	 eax
  00119	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0011c	51		 push	 ecx
  0011d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00122	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 16852: #else
; 16853: 	//  
; 16854: 	#ifdef NEW_ATTACK_PROC
; 16855: 		gObjUseSkill.UseSkill(aIndex, lpMagic, lpMsg->X, lpMsg->Y, lpMsg->Dir, lpMsg->TargetPos);
; 16856: 	#else
; 16857: 		#ifdef ADD_SKILL_20031022			
; 16858: 			gObjUseSkill.UseSkill(aIndex, lpMagic, lpMsg->X, lpMsg->Y, lpMsg->Dir, lpMsg->TargetPos);
; 16859: 		#else
; 16860: 			gObjUseSkill.UseSkill(aIndex, lpMagic, lpMsg->X, lpMsg->Y, lpMsg->Dir);
; 16861: 		#endif
; 16862: 	#endif
; 16863: #endif
; 16864: 
; 16865: #ifdef MODIFY_SKILL_EVEIL_AT_SERVER_20070117	//    -   .
; 16866: 	if( lpMagic->m_Skill == AT_SKILL_EVIL )
; 16867: 	{
; 16868: 		return;
; 16869: 	}
; 16870: #endif
; 16871: 			
; 16872: #ifdef APPLY_DURATION_MAGIC_HACK_CLEANER_20040504
; 16873: 	if( lpMsg->MagicKey != 0 )

  00127	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0012a	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  0012e	85 c9		 test	 ecx, ecx
  00130	74 1d		 je	 SHORT $LN1@CGDuration

; 16874: 	{
; 16875: 		lpObj->DurMagicKeyChecker.SetDurationTime( lpMsg->MagicKey, GetTickCount() );

  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00138	50		 push	 eax
  00139	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0013c	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  00140	51		 push	 ecx
  00141	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00144	81 c1 50 0f 00
	00		 add	 ecx, 3920		; 00000f50H
  0014a	e8 00 00 00 00	 call	 ?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z ; TDurMagicKeyChecker::SetDurationTime
$LN1@CGDuration:

; 16876: 	}
; 16877: #endif
; 16878: 
; 16879: }

  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ENDP ; CGDurationMagicRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGBeattackRecv@@YAXPAEHH@Z
_TEXT	SEGMENT
tv505 = -712						; size = 4
tv506 = -708						; size = 4
_i$1 = -576						; size = 4
_dis$2 = -572						; size = 4
_lpObj$3 = -568						; size = 4
_n$ = -564						; size = 4
_i$4 = -560						; size = 4
_pTargetNumber$ = -556					; size = 512
_lOfs2$ = -44						; size = 4
_lpObj$5 = -40						; size = 4
_iTimeCalc$6 = -36					; size = 4
_lpObj$7 = -32						; size = 4
_NSAttackSerial$8 = -28					; size = 4
_lpMsg$ = -24						; size = 4
_tNumber$ = -20						; size = 4
_lpMagic$ = -16						; size = 4
_lOfs$ = -12						; size = 4
_lpCount$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_magic_send$ = 16					; size = 4
?CGBeattackRecv@@YAXPAEHH@Z PROC			; CGBeattackRecv, COMDAT

; 16145: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 02 00
	00		 sub	 esp, 712		; 000002c8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 16146: 	LPPMSG_BEATTACK_COUNT	lpCount = (LPPMSG_BEATTACK_COUNT)lpRecv;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00019	89 45 f8	 mov	 DWORD PTR _lpCount$[ebp], eax

; 16147: 	int	lOfs;
; 16148: 	CMagicInf *lpMagic;
; 16149: 
; 16150: #ifdef PACKET_CHANGE	
; 16151: 	if( lpCount->h.headcode != PACKET_MAGIC_ATTACK ) 

  0001c	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  0001f	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00023	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  00026	74 21		 je	 SHORT $LN11@CGBeattack

; 16152: #else
; 16153: 	if( lpCount->h.headcode != 0x1D ) 
; 16154: #endif
; 16155: 	{
; 16156: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGBeattackRecv@@YAXPAEHH@Z@4JA
  0002d	83 c0 0b	 add	 eax, 11			; 0000000bH
  00030	50		 push	 eax
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16157: 		return;

  00044	e9 be 0b 00 00	 jmp	 $LN1@CGBeattack
$LN11@CGBeattack:

; 16158: 	}
; 16159: 	if( lpCount->Count < 1 ) {

  00049	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  0004c	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00050	83 f9 01	 cmp	 ecx, 1
  00053	7d 21		 jge	 SHORT $LN12@CGBeattack

; 16160: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGBeattackRecv@@YAXPAEHH@Z@4JA
  0005a	83 c0 0f	 add	 eax, 15			; 0000000fH
  0005d	50		 push	 eax
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16161: 		return;

  00071	e9 91 0b 00 00	 jmp	 $LN1@CGBeattack
$LN12@CGBeattack:

; 16162: 	}
; 16163: 	if( lpCount->Count > 5 ) lpCount->Count = 5;	//  5   .

  00076	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00079	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0007d	83 f9 05	 cmp	 ecx, 5
  00080	7e 07		 jle	 SHORT $LN13@CGBeattack
  00082	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00085	c6 40 07 05	 mov	 BYTE PTR [eax+7], 5
$LN13@CGBeattack:

; 16164: 
; 16165: 	int tNumber;
; 16166: 
; 16167: 	lOfs = sizeof(PMSG_BEATTACK_COUNT);

  00089	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _lOfs$[ebp], 8

; 16168: 	LPPMSG_BEATTACK	lpMsg;
; 16169: 
; 16170: //	lpMagic = gObjGetMagic(&gObj[aIndex], lpCount->MagicNumber);
; 16171: 	//           .
; 16172: 
; 16173: 	if( gObj[aIndex].Type == OBJTYPE_CHARACTER )

  00090	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009d	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000a2	83 fa 01	 cmp	 edx, 1
  000a5	75 23		 jne	 SHORT $LN14@CGBeattack

; 16174: 	{
; 16175: #ifdef MODIFY_SAFEZONE_CHECK_ATTACK_20080903
; 16176: 		BYTE attr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);
; 16177: 		
; 16178: 		if( ((attr&MAP_ATTR_SAFTYZONE) == MAP_ATTR_SAFTYZONE) )		//    .
; 16179: 		{
; 16180: 			gObjSetPosition( aIndex, gObj[aIndex].X, gObj[aIndex].Y );
; 16181: 			
; 16182: 			return;
; 16183: 		}
; 16184: #endif // MODIFY_SAFEZONE_CHECK_ATTACK_20080903
; 16185: 
; 16186: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD
; 16187: 		WORD wMagicNumber = MAKEWORD( lpCount->MagicNumberL, lpCount->MagicNumberH );
; 16188: 		lpMagic = gObjGetMagicSearch( &gObj[aIndex], wMagicNumber );	
; 16189: #else
; 16190: #ifdef CHANGE_MAGICATTACKPACKET	//      
; 16191: 		lpMagic = gObjGetMagicSearch(&gObj[aIndex], lpCount->MagicNumber);

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  000aa	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000ae	51		 push	 ecx
  000af	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000b6	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  000c2	83 c4 08	 add	 esp, 8
  000c5	89 45 f0	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 16192: #else
; 16193: 		lpMagic = gObjGetMagic(&gObj[aIndex], lpCount->MagicNumber);
; 16194: #endif
; 16195: #endif	// ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107
; 16196: 	}

  000c8	eb 21		 jmp	 SHORT $LN15@CGBeattack
$LN14@CGBeattack:

; 16197: 	else
; 16198: 	{
; 16199: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD
; 16200: 		WORD wMagicNumber = MAKEWORD( lpCount->MagicNumberL, lpCount->MagicNumberH );
; 16201: 		lpMagic = gObjGetMagic( &gObj[aIndex], wMagicNumber );	
; 16202: #else
; 16203: 		lpMagic = gObjGetMagic(&gObj[aIndex], lpCount->MagicNumber);

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  000cd	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000d1	51		 push	 ecx
  000d2	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000d9	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000df	52		 push	 edx
  000e0	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z ; gObjGetMagic
  000e5	83 c4 08	 add	 esp, 8
  000e8	89 45 f0	 mov	 DWORD PTR _lpMagic$[ebp], eax
$LN15@CGBeattack:

; 16204: #endif
; 16205: 	}
; 16206: 	
; 16207: 	if( lpMagic == NULL )

  000eb	83 7d f0 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  000ef	75 21		 jne	 SHORT $LN16@CGBeattack

; 16208: 	{
; 16209: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGBeattackRecv@@YAXPAEHH@Z@4JA
  000f6	83 c0 40	 add	 eax, 64			; 00000040H
  000f9	50		 push	 eax
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0010a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16210: 		return;

  0010d	e9 f5 0a 00 00	 jmp	 $LN1@CGBeattack
$LN16@CGBeattack:

; 16211: 	}
; 16212: 
; 16213: #ifdef ADD_SKILL_WITH_COMBO
; 16214: #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428	//  ,     
; 16215: 	if( lpMagic->m_Skill == AT_SKILL_BLOWOFFURY ||	//  
; 16216: 		lpMagic->m_Skill == AT_SKILL_STRIKE		||	// 
; 16217: 		g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_STRIKE	||	//  ()
; 16218: 		g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_BLOWOFFURY ||	//   ()
; 16219: #else	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 16220: 	if( lpMagic->m_Skill == AT_SKILL_BLOWOFFURY ||	//  
; 16221: 		lpMagic->m_Skill == AT_SKILL_STRIKE		||	// 

  00112	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00115	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00119	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  0011c	74 18		 je	 SHORT $LN18@CGBeattack
  0011e	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00121	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00125	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00128	74 0c		 je	 SHORT $LN18@CGBeattack
  0012a	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0012d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00131	83 f9 29	 cmp	 ecx, 41			; 00000029H
  00134	75 05		 jne	 SHORT $LN17@CGBeattack
$LN18@CGBeattack:

; 16222: #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 16223: 		
; 16224: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// ()  
; 16225: 		lpMagic->m_Skill == AT_SKILL_WHEEL		|| 						// 
; 16226: 		lpMagic->m_Skill == AT_SKILL_ML_STRENGTHEN_WHEEL_KNIGHT			//  ()
; 16227: 		)	
; 16228: #else
; 16229: 		lpMagic->m_Skill == AT_SKILL_WHEEL		)	// 
; 16230: #endif
; 16231: 	{
; 16232: 		return;

  00136	e9 cc 0a 00 00	 jmp	 $LN1@CGBeattack
$LN17@CGBeattack:

; 16233: 	}
; 16234: #endif
; 16235: 
; 16236: #ifdef NEW_ATTACK_PROC	//     
; 16237: 	if( lpMagic->m_Skill == AT_SKILL_BLOWOFFURY ||	//  
; 16238: 		//lpMagic->m_Skill == AT_SKILL_EVIL		||	// 
; 16239: 		lpMagic->m_Skill == AT_SKILL_HELL		||	// 
; 16240: 		lpMagic->m_Skill == AT_SKILL_INFERNO	||	// 
; 16241: 		lpMagic->m_Skill == AT_SKILL_WHEEL		)	// 
; 16242: 	{
; 16243: 		return;
; 16244: 	}
; 16245: #endif
; 16246: 
; 16247: #ifdef MODIFY_SKILL_EVEIL_AT_SERVER_20070117	//   .
; 16248: 	if( lpMagic->m_Skill == AT_SKILL_EVIL )
; 16249: 	{
; 16250: 		return;
; 16251: 	}
; 16252: #endif
; 16253: 
; 16254: 
; 16255: 	if( gObj[aIndex].Type == OBJTYPE_CHARACTER )

  0013b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00148	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0014d	83 fa 01	 cmp	 edx, 1
  00150	0f 85 5d 01 00
	00		 jne	 $LN19@CGBeattack

; 16256: 	{	
; 16257: 		/*if( gObj[aIndex].UseMagicNumber != lpMagic->m_Skill)
; 16258: 		{			
; 16259: 			LogAdd("error-L3 %s %d %d %d", __FILE__, __LINE__, gObj[aIndex].UseMagicNumber, lpMagic->m_Skill);
; 16260: 			return;
; 16261: 		}
; 16262: 		*/
; 16263: #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// SkillGetRequireClass(...) 3 
; 16264: 		if( MagicDamageC.SkillGetRequireClass(gObj[aIndex].Class, gObj[aIndex].ChangeUP, gObj[aIndex].ThirdChangeUp, lpMagic->m_Skill) < 1 )
; 16265: #else
; 16266: #ifdef NEW_SKILL_FORSKYLAND
; 16267: 		if( MagicDamageC.SkillGetRequireClass(gObj[aIndex].Class, gObj[aIndex].ChangeUP, lpMagic->m_Skill) < 1 )

  00156	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00159	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0015d	51		 push	 ecx
  0015e	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016a	0f b6 8c 10 9f
	00 00 00	 movzx	 ecx, BYTE PTR [eax+edx+159]
  00172	51		 push	 ecx
  00173	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017f	0f b7 8c 10 9c
	00 00 00	 movzx	 ecx, WORD PTR [eax+edx+156]
  00187	51		 push	 ecx
  00188	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0018d	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z ; CMagicDamage::SkillGetRequireClass
  00192	83 f8 01	 cmp	 eax, 1
  00195	7d 57		 jge	 SHORT $LN20@CGBeattack

; 16268: #else
; 16269: 		if( MagicDamageC.SkillGetRequireClass(gObj[aIndex].Class, lpMagic->m_Skill) == 0 )
; 16270: #endif
; 16271: #endif	// MASTER_LEVEL_SKILL_SYSTEM_20071122
; 16272: 		{
; 16273: 			LogAddC(LOGC_RED, lMsg.Get(495), gObj[aIndex].AccountID, gObj[aIndex].Name, lpMagic->m_Skill);

  00197	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0019a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0019e	51		 push	 ecx
  0019f	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ab	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  001af	51		 push	 ecx
  001b0	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  001b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bc	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  001c0	51		 push	 ecx
  001c1	68 ef 01 00 00	 push	 495			; 000001efH
  001c6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001d1	50		 push	 eax
  001d2	6a 02		 push	 2
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001da	83 c4 14	 add	 esp, 20			; 00000014H

; 16274: 			gObjUserKill(aIndex);

  001dd	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  001e6	83 c4 04	 add	 esp, 4

; 16275: 			return;

  001e9	e9 19 0a 00 00	 jmp	 $LN1@CGBeattack
$LN20@CGBeattack:

; 16276: 		}
; 16277: 
; 16278: 		//   3 .. .
; 16279: 		//if( (GetTickCount()-gObj[aIndex].UseMagicTime) > (1000*4) )
; 16280: 		if( (GetTickCount()-gObj[aIndex].UseMagicTime) > (1000*8) )

  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001f4	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00201	2b 84 0a 18 03
	00 00		 sub	 eax, DWORD PTR [edx+ecx+792]
  00208	3d 40 1f 00 00	 cmp	 eax, 8000		; 00001f40H
  0020d	76 5a		 jbe	 SHORT $LN21@CGBeattack

; 16281: 		{
; 16282: 			/*
; 16283: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 16284: 			if( CHECK_DEVILSQUARE(gObj[aIndex].MapNumber) )
; 16285: #else
; 16286: 			if( gObj[aIndex].MapNumber != 9 )
; 16287: #endif
; 16288: 			{	//       
; 16289: 				gObjUserKill(aIndex);
; 16290: 			}
; 16291: 			*/
; 16292: 			LogAddC(LOGC_RED, "Too long time passed after casting magic. [%s][%s] (%d)(%d)", 

  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00215	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0021c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00222	2b 84 0a 18 03
	00 00		 sub	 eax, DWORD PTR [edx+ecx+792]
  00229	50		 push	 eax
  0022a	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0022d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00231	51		 push	 ecx
  00232	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00239	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023e	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00242	51		 push	 ecx
  00243	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0024a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024f	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00253	51		 push	 ecx
  00254	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5cast@
  00259	6a 02		 push	 2
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00261	83 c4 18	 add	 esp, 24			; 00000018H

; 16293: 					gObj[aIndex].AccountID, gObj[aIndex].Name, lpMagic->m_Skill, GetTickCount()-gObj[aIndex].UseMagicTime);
; 16294: 			//LogAddC(LOGC_RED, lMsg.Get(496), gObj[aIndex].AccountID, gObj[aIndex].Name, lpMagic->m_Skill);
; 16295: 			return;

  00264	e9 9e 09 00 00	 jmp	 $LN1@CGBeattack
$LN21@CGBeattack:

; 16296: 		}
; 16297: 		if( gObj[aIndex].UseMagicCount > 4 )

  00269	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00270	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00276	0f be 94 01 1c
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+796]
  0027e	83 fa 04	 cmp	 edx, 4
  00281	7e 05		 jle	 SHORT $LN22@CGBeattack

; 16298: 		{
; 16299: 			//LogAdd("error-L3 %s %d", __FILE__, __LINE__);
; 16300: 			return;

  00283	e9 7f 09 00 00	 jmp	 $LN1@CGBeattack
$LN22@CGBeattack:

; 16301: 		}
; 16302: 		gObj[aIndex].UseMagicCount++;

  00288	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0028f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00295	8a 94 01 1c 03
	00 00		 mov	 dl, BYTE PTR [ecx+eax+796]
  0029c	80 c2 01	 add	 dl, 1
  0029f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ac	88 94 01 1c 03
	00 00		 mov	 BYTE PTR [ecx+eax+796], dl
$LN19@CGBeattack:

; 16303: 	}
; 16304: 
; 16305: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//   
; 16306: 	if( g_MasterSkillSystem.CheckMasterLevelSkill( lpMagic->m_Skill ) )
; 16307: 	{
; 16308: 		INT iBaseMLS = g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill );
; 16309: 		if( iBaseMLS != AT_SKILL_ML_STRENGTHEN_MAGICDEFENSE			&&	//  
; 16310: 			iBaseMLS != AT_SKILL_ML_STRENGTHEN_HELL					&&	//  
; 16311: 			iBaseMLS != AT_SKILL_ML_STRENGTHEN_WHEEL_KNIGHT			&&	//  1 ()
; 16312: 			iBaseMLS != AT_SKILL_ML_STRENGTHEN_HEALING				&&	//  
; 16313: 			iBaseMLS != AT_SKILL_ML_STRENGTHEN_CROSSBOW				&&	//  
; 16314: 			iBaseMLS != AT_SKILL_ML_STRENGTHEN_WHEEL_MAGUMSA		&&	//  2 ()
; 16315: 			iBaseMLS != AT_SKILL_ML_STRENGTHEN_KNIGHTADDLIFE		&&	//  	
; 16316: 			iBaseMLS != AT_SKILL_ML_STRENGTHEN_BLAST				&&	//  
; 16317: 			iBaseMLS != AT_SKILL_ML_STRENGTHEN_DARKHORSE_ATTACK		&&	//  
; 16318: 			iBaseMLS != AT_SKILL_ML_STRENGTHEN_FIREBURST				//  
; 16319: 
; 16320: #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428	//  4
; 16321: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_EVIL					//  
; 16322: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_EXPICE				//   
; 16323: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_STRIKE				//  ()
; 16324: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_BLOWOFFURY			//   ()
; 16325: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_DEFENSE				//  
; 16326: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_ATTACK				//  	
; 16327: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_DEFENSEDOWN			//   
; 16328: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_SWORD6				//   
; 16329: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_FIRESCREAM			//   
; 16330: #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 16331: 			
; 16332: #ifdef UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808
; 16333: 			&& iBaseMLS !=	AT_SKILL_ML_STRENGTHEN_MAGUMSA_EVIL			//  ()
; 16334: #endif	// UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808
; 16335: 			)
; 16336: 		{
; 16337: 			LogAdd("error-L3 %s %d", __FILE__, __LINE__);
; 16338: 			return;
; 16339: 		}			
; 16340: 	}
; 16341: 	else
; 16342: #endif	// ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107
; 16343: 	if( lpMagic->m_Skill != AT_SKILL_STORM &&
; 16344: 		lpMagic->m_Skill != AT_SKILL_EVIL &&
; 16345: 		lpMagic->m_Skill != AT_SKILL_HELL &&
; 16346: 		lpMagic->m_Skill != AT_SKILL_BLAST &&
; 16347: 		lpMagic->m_Skill != AT_SKILL_INFERNO && 
; 16348: 		lpMagic->m_Skill != AT_SKILL_FLAME &&
; 16349: 		lpMagic->m_Skill != AT_SKILL_CROSSBOW &&
; 16350: 		lpMagic->m_Skill != AT_SKILL_DEVILFIRE &&
; 16351: 		lpMagic->m_Skill != AT_SKILL_FLASH &&
; 16352: 		lpMagic->m_Skill != AT_SKILL_WHEEL && 		
; 16353: 		lpMagic->m_Skill != AT_SKILL_KNIGHTSPEAR	&& // 
; 16354: 		lpMagic->m_Skill != AT_SKILL_STRIKE	// 
; 16355: 
; 16356: //#ifndef NEW_ATTACK_PROC	//       
; 16357: 		&& 
; 16358: 		lpMagic->m_Skill != AT_SKILL_BLOWOFFURY &&	
; 16359: 		lpMagic->m_Skill != AT_SKILL_PENETRATION &&		

  002b3	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  002b6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002ba	83 f9 08	 cmp	 ecx, 8
  002bd	0f 84 e3 00 00
	00		 je	 $LN23@CGBeattack
  002c3	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  002c6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002ca	83 f9 09	 cmp	 ecx, 9
  002cd	0f 84 d3 00 00
	00		 je	 $LN23@CGBeattack
  002d3	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  002d6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002da	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  002dd	0f 84 c3 00 00
	00		 je	 $LN23@CGBeattack
  002e3	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  002e6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002ea	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  002ed	0f 84 b3 00 00
	00		 je	 $LN23@CGBeattack
  002f3	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  002f6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002fa	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  002fd	0f 84 a3 00 00
	00		 je	 $LN23@CGBeattack
  00303	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00306	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0030a	83 f9 05	 cmp	 ecx, 5
  0030d	0f 84 93 00 00
	00		 je	 $LN23@CGBeattack
  00313	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00316	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0031a	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0031d	0f 84 83 00 00
	00		 je	 $LN23@CGBeattack
  00323	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00326	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0032a	83 f9 32	 cmp	 ecx, 50			; 00000032H
  0032d	74 77		 je	 SHORT $LN23@CGBeattack
  0032f	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00332	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00336	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  00339	74 6b		 je	 SHORT $LN23@CGBeattack
  0033b	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0033e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00342	83 f9 29	 cmp	 ecx, 41			; 00000029H
  00345	74 5f		 je	 SHORT $LN23@CGBeattack
  00347	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0034a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0034e	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00351	74 53		 je	 SHORT $LN23@CGBeattack
  00353	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00356	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0035a	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  0035d	74 47		 je	 SHORT $LN23@CGBeattack
  0035f	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00362	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00366	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  00369	74 3b		 je	 SHORT $LN23@CGBeattack
  0036b	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0036e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00372	83 f9 34	 cmp	 ecx, 52			; 00000034H
  00375	74 2f		 je	 SHORT $LN23@CGBeattack
  00377	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0037a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0037e	83 f9 37	 cmp	 ecx, 55			; 00000037H
  00381	74 23		 je	 SHORT $LN23@CGBeattack

; 16360: 		lpMagic->m_Skill != AT_SKILL_DEFENSEDOWN 
; 16361: //#endif			
; 16362: 
; 16363: #ifdef ADD_SKILL_DARKLOAD_FIRESCREAM_20060601
; 16364: 		&& lpMagic->m_Skill != AT_SKILL_FIRESCREAM		//  		
; 16365: #endif
; 16366: 		)
; 16367: 	{
; 16368: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  00383	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGBeattackRecv@@YAXPAEHH@Z@4JA
  00388	05 df 00 00 00	 add	 eax, 223		; 000000dfH
  0038d	50		 push	 eax
  0038e	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00393	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@
  00398	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0039e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16369: 		return;

  003a1	e9 61 08 00 00	 jmp	 $LN1@CGBeattack
$LN23@CGBeattack:

; 16370: 	}	
; 16371: 	
; 16372: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//    
; 16373: 	if( lpMagic->m_Skill == AT_SKILL_CROSSBOW 
; 16374: 		|| lpMagic->m_Skill == AT_SKILL_FIRESCREAM 
; 16375: 		|| g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_CROSSBOW 
; 16376: 		|| g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_FIRESCREAM
; 16377: 		)
; 16378: #else
; 16379: #ifdef ADD_SKILL_DARKLOAD_FIRESCREAM_20060601
; 16380: 	if( lpMagic->m_Skill == AT_SKILL_CROSSBOW || lpMagic->m_Skill == AT_SKILL_FIRESCREAM )
; 16381: #else
; 16382: 	if( lpMagic->m_Skill == AT_SKILL_CROSSBOW )

  003a6	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  003a9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  003ad	83 f9 18	 cmp	 ecx, 24			; 00000018H
  003b0	0f 85 34 02 00
	00		 jne	 $LN24@CGBeattack

; 16383: #endif
; 16384: #endif	// ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107
; 16385: 	{	//     
; 16386: 		int NSAttackSerial = lpCount->Serial;

  003b6	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  003b9	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  003bd	89 4d e4	 mov	 DWORD PTR _NSAttackSerial$8[ebp], ecx

; 16387: 		
; 16388: 		if( gObj[aIndex].OSAttackSerial >= 255 && ((gObj[aIndex].OSAttackSerial-lpCount->Serial)>50))

  003c0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003cd	0f bf 94 01 1e
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+798]
  003d5	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  003db	7c 3b		 jl	 SHORT $LN25@CGBeattack
  003dd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ea	0f bf 94 01 1e
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+798]
  003f2	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  003f5	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  003f9	2b d1		 sub	 edx, ecx
  003fb	83 fa 32	 cmp	 edx, 50			; 00000032H
  003fe	7e 18		 jle	 SHORT $LN25@CGBeattack

; 16389: 		{
; 16390: 			gObj[aIndex].OSAttackSerial = -1;

  00400	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00407	83 c9 ff	 or	 ecx, -1
  0040a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00410	66 89 8c 02 1e
	03 00 00	 mov	 WORD PTR [edx+eax+798], cx
$LN25@CGBeattack:

; 16391: 		}
; 16392: 
; 16393: 		if(NSAttackSerial > gObj[aIndex].OSAttackSerial )

  00418	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0041f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00425	0f bf 94 01 1e
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+798]
  0042d	39 55 e4	 cmp	 DWORD PTR _NSAttackSerial$8[ebp], edx
  00430	0f 8e b4 01 00
	00		 jle	 $LN24@CGBeattack

; 16394: 		{
; 16395: 			gObj[aIndex].OSAttackSerial = NSAttackSerial;

  00436	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0043d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00443	66 8b 55 e4	 mov	 dx, WORD PTR _NSAttackSerial$8[ebp]
  00447	66 89 94 01 1e
	03 00 00	 mov	 WORD PTR [ecx+eax+798], dx

; 16396: 
; 16397: 			LPOBJECTSTRUCT lpObj= &gObj[aIndex];

  0044f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00456	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0045c	89 45 e0	 mov	 DWORD PTR _lpObj$7[ebp], eax

; 16398: 
; 16399: 			int iTimeCalc = GetTickCount()-lpObj->m_LastAttackTime;

  0045f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00465	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$7[ebp]
  00468	2b 81 c8 01 00
	00		 sub	 eax, DWORD PTR [ecx+456]
  0046e	89 45 dc	 mov	 DWORD PTR _iTimeCalc$6[ebp], eax

; 16400: 
; 16401: #ifdef FOR_CHINA
; 16402: 			if( iTimeCalc < lpObj->m_DetectSpeedHackTime ) 
; 16403: #else
; 16404: 	#ifdef FOR_THAILAND		
; 16405: 				if( iTimeCalc < lpObj->m_DetectSpeedHackTime ) 	
; 16406: 	#else
; 16407: 				if( iTimeCalc < lpObj->m_DetectSpeedHackTime && iTimeCalc != 0  ) 

  00471	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  00474	8b 4d dc	 mov	 ecx, DWORD PTR _iTimeCalc$6[ebp]
  00477	3b 88 d0 01 00
	00		 cmp	 ecx, DWORD PTR [eax+464]
  0047d	0f 8d 3e 01 00
	00		 jge	 $LN27@CGBeattack
  00483	83 7d dc 00	 cmp	 DWORD PTR _iTimeCalc$6[ebp], 0
  00487	0f 84 34 01 00
	00		 je	 $LN27@CGBeattack

; 16408: 	#endif
; 16409: #endif
; 16410: 			{	
; 16411: 				lpObj->m_DetectCount++;

  0048d	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  00490	8b 88 d8 01 00
	00		 mov	 ecx, DWORD PTR [eax+472]
  00496	83 c1 01	 add	 ecx, 1
  00499	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$7[ebp]
  0049c	89 8a d8 01 00
	00		 mov	 DWORD PTR [edx+472], ecx

; 16412: 				lpObj->m_SumLastAttackTime += iTimeCalc;

  004a2	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  004a5	8b 88 d4 01 00
	00		 mov	 ecx, DWORD PTR [eax+468]
  004ab	03 4d dc	 add	 ecx, DWORD PTR _iTimeCalc$6[ebp]
  004ae	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$7[ebp]
  004b1	89 8a d4 01 00
	00		 mov	 DWORD PTR [edx+468], ecx

; 16413: 
; 16414: 				if( lpObj->m_DetectCount > gHackCheckCount )

  004b7	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  004ba	8b 88 d8 01 00
	00		 mov	 ecx, DWORD PTR [eax+472]
  004c0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gHackCheckCount@@3KA ; gHackCheckCount
  004c6	0f 86 e4 00 00
	00		 jbe	 $LN29@CGBeattack

; 16415: 				{
; 16416: 					lpObj->m_DetectedHackKickCount++;

  004cc	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  004cf	8b 88 dc 01 00
	00		 mov	 ecx, DWORD PTR [eax+476]
  004d5	83 c1 01	 add	 ecx, 1
  004d8	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$7[ebp]
  004db	89 8a dc 01 00
	00		 mov	 DWORD PTR [edx+476], ecx

; 16417: 
; 16418: 					if( gIsKickDetecHackCountLimit ) 

  004e1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsKickDetecHackCountLimit@@3HA, 0 ; gIsKickDetecHackCountLimit
  004e8	74 64		 je	 SHORT $LN30@CGBeattack

; 16419: 					{
; 16420: 						if( lpObj->m_DetectedHackKickCount > gDetectedHackKickCount )

  004ea	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  004ed	8b 88 dc 01 00
	00		 mov	 ecx, DWORD PTR [eax+476]
  004f3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gDetectedHackKickCount@@3HA ; gDetectedHackKickCount
  004f9	7e 53		 jle	 SHORT $LN30@CGBeattack

; 16421: 						{
; 16422: #ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 16423: 	#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 16424: 							ChinaHackLogFile.Output("[%s][%s] %s Kick DetecHackCountLimit Over User (%d) @%d",
; 16425: 													 lpObj->AccountID, 
; 16426: 													 lpObj->Name, 
; 16427: 													 lMsg.Get(1900+lpObj->Class),
; 16428: 													 lpObj->m_DetectedHackKickCount,
; 16429: 													 lpObj->MapNumber);						     
; 16430: 	#else
; 16431: 							LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d) @%d",
; 16432: 									 lpObj->AccountID, 
; 16433: 									 lpObj->Name, 
; 16434: 									 lMsg.Get(1900+lpObj->Class),
; 16435: 									 lpObj->m_DetectedHackKickCount,
; 16436: 									 lpObj->MapNumber);						     
; 16437: 	#endif
; 16438: #else
; 16439: 	#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 16440: 							ChinaHackLogFile.Output("[%s][%s] %s Kick DetecHackCountLimit Over User (%d)",
; 16441: 													 lpObj->AccountID, 
; 16442: 													 lpObj->Name, 
; 16443: 													 lMsg.Get(1900+lpObj->Class),
; 16444: 													 lpObj->m_DetectedHackKickCount);						     
; 16445: 	#else
; 16446: 							LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d)",

  004fb	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  004fe	8b 88 dc 01 00
	00		 mov	 ecx, DWORD PTR [eax+476]
  00504	51		 push	 ecx
  00505	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$7[ebp]
  00508	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  0050f	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00514	50		 push	 eax
  00515	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0051a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00520	50		 push	 eax
  00521	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$7[ebp]
  00524	83 c1 73	 add	 ecx, 115		; 00000073H
  00527	51		 push	 ecx
  00528	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$7[ebp]
  0052b	83 c2 68	 add	 edx, 104		; 00000068H
  0052e	52		 push	 edx
  0052f	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCount@
  00534	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0053a	83 c4 14	 add	 esp, 20			; 00000014H

; 16447: 									 lpObj->AccountID, 
; 16448: 									 lpObj->Name, 
; 16449: 									 lMsg.Get(1900+lpObj->Class),
; 16450: 									 lpObj->m_DetectedHackKickCount);						     
; 16451: 	#endif
; 16452: #endif
; 16453: 							CloseClient(aIndex);

  0053d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00540	50		 push	 eax
  00541	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00546	83 c4 04	 add	 esp, 4

; 16454: 							return;

  00549	e9 b9 06 00 00	 jmp	 $LN1@CGBeattack
$LN30@CGBeattack:

; 16455: 						}
; 16456: 					}
; 16457: #ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 16458: 	#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 16459: 					ChinaHackLogFile.Output("[%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d @%d", 
; 16460: 											 lpObj->AccountID, 
; 16461: 											 lpObj->Name, 
; 16462: 											 lMsg.Get(1900+lpObj->Class),
; 16463: 											 lpObj->m_DetectSpeedHackTime,
; 16464: 											 lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 16465: 											 lpObj->m_SpeedHackPenalty,
; 16466: 											 lpObj->MapNumber);
; 16467: 					ChinaHackUserKick.InsertSpeedNCount(lpObj->m_Index);
; 16468: 
; 16469: 	#else
; 16470: 					LogAddTD("[%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d", 
; 16471: 						 lpObj->AccountID, 
; 16472: 						 lpObj->Name, 
; 16473: 						 lMsg.Get(1900+lpObj->Class),
; 16474: 						 lpObj->m_DetectSpeedHackTime,
; 16475: 						 lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 16476: 						 lpObj->m_SpeedHackPenalty);				
; 16477: 	#endif
; 16478: #else
; 16479: 	#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 16480: 					ChinaHackLogFile.Output("[%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d @ %d", 
; 16481: 											 lpObj->AccountID, 
; 16482: 											 lpObj->Name, 
; 16483: 											 lMsg.Get(1900+lpObj->Class),
; 16484: 											 lpObj->m_DetectSpeedHackTime,
; 16485: 											 lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 16486: 											 lpObj->m_SpeedHackPenalty,
; 16487: 											 lpObj->MapNumber);
; 16488: 					ChinaHackUserKick.InsertSpeedNCount(lpObj->m_Index);
; 16489: 
; 16490: 	#else
; 16491: 					LogAddTD("[%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d", 

  0054e	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  00551	8b 88 e0 01 00
	00		 mov	 ecx, DWORD PTR [eax+480]
  00557	51		 push	 ecx
  00558	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$7[ebp]
  0055b	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$7[ebp]
  0055e	8b 82 d4 01 00
	00		 mov	 eax, DWORD PTR [edx+468]
  00564	33 d2		 xor	 edx, edx
  00566	f7 b1 d8 01 00
	00		 div	 DWORD PTR [ecx+472]
  0056c	50		 push	 eax
  0056d	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$7[ebp]
  00570	8b 82 d0 01 00
	00		 mov	 eax, DWORD PTR [edx+464]
  00576	50		 push	 eax
  00577	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$7[ebp]
  0057a	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  00581	81 c2 6c 07 00
	00		 add	 edx, 1900		; 0000076cH
  00587	52		 push	 edx
  00588	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0058d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00593	50		 push	 eax
  00594	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  00597	83 c0 73	 add	 eax, 115		; 00000073H
  0059a	50		 push	 eax
  0059b	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$7[ebp]
  0059e	83 c1 68	 add	 ecx, 104		; 00000068H
  005a1	51		 push	 ecx
  005a2	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wro@
  005a7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005ad	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN29@CGBeattack:

; 16492: 						 lpObj->AccountID, 
; 16493: 						 lpObj->Name, 
; 16494: 						 lMsg.Get(1900+lpObj->Class),
; 16495: 						 lpObj->m_DetectSpeedHackTime,
; 16496: 						 lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 16497: 						 lpObj->m_SpeedHackPenalty);				
; 16498: 	#endif
; 16499: #endif
; 16500: 					
; 16501: 					//if( bIsIgnorePacketSpeedHackDetect )
; 16502: 					//	return;
; 16503: 				}
; 16504: 				lpObj->m_LastAttackTime = GetTickCount();				

  005b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  005b6	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$7[ebp]
  005b9	89 81 c8 01 00
	00		 mov	 DWORD PTR [ecx+456], eax

; 16505: 			}

  005bf	eb 1a		 jmp	 SHORT $LN28@CGBeattack
$LN27@CGBeattack:

; 16506: 			else
; 16507: 			{
; 16508: 				lpObj->m_SumLastAttackTime = 0;

  005c1	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  005c4	c7 80 d4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+468], 0

; 16509: 				lpObj->m_DetectCount = 0;

  005ce	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$7[ebp]
  005d1	c7 80 d8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+472], 0
$LN28@CGBeattack:

; 16510: 			}
; 16511: 			lpObj->m_LastAttackTime = GetTickCount();

  005db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  005e1	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$7[ebp]
  005e4	89 81 c8 01 00
	00		 mov	 DWORD PTR [ecx+456], eax
$LN24@CGBeattack:

; 16512: 
; 16513: 			//LogAdd("Multi Magic3 Attack Speed = [%d,%d] %d", gObj[aIndex].OSAttackSerial, lpObj->m_MagicSpeed, iTimeCalc);			
; 16514: 		}
; 16515: 	}	
; 16516: 
; 16517: #ifdef MODIFY_EVIL_BUGFIX_20080618	//    
; 16518: #ifdef UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808	//    
; 16519: 	if( lpMagic->m_Skill == AT_SKILL_EVIL || g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_EVIL
; 16520: 		|| g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_MAGUMSA_EVIL)
; 16521: #else	// UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808
; 16522: #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428
; 16523: 	if( lpMagic->m_Skill == AT_SKILL_EVIL || g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_EVIL )
; 16524: #else	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 16525: 	if( lpMagic->m_Skill == AT_SKILL_EVIL )

  005ea	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  005ed	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  005f1	83 f9 09	 cmp	 ecx, 9
  005f4	75 38		 jne	 SHORT $LN32@CGBeattack

; 16526: #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 16527: #endif	// UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808
; 16528: 	{
; 16529: 		if( gObj[aIndex].Class != CLASS_WIZARD && gObj[aIndex].Class != CLASS_MAGUMSA )

  005f6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00603	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  0060b	85 d2		 test	 edx, edx
  0060d	74 1f		 je	 SHORT $LN32@CGBeattack
  0060f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00616	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0061c	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00624	83 fa 03	 cmp	 edx, 3
  00627	74 05		 je	 SHORT $LN32@CGBeattack

; 16530: 		{
; 16531: 			return;

  00629	e9 d9 05 00 00	 jmp	 $LN1@CGBeattack
$LN32@CGBeattack:

; 16532: 		}
; 16533: 	}
; 16534: #endif	// MODIFY_EVIL_BUGFIX_20080618
; 16535: 
; 16536: 	if( bIsIgnorePacketSpeedHackDetect )

  0062e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  00635	74 78		 je	 SHORT $LN34@CGBeattack

; 16537: 	{
; 16538: 		LPOBJECTSTRUCT lpObj= &gObj[aIndex];

  00637	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0063e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00644	89 45 d8	 mov	 DWORD PTR _lpObj$5[ebp], eax

; 16539: 		if( lpObj->m_SpeedHackPenalty > 0 )

  00647	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$5[ebp]
  0064a	83 b8 e0 01 00
	00 00		 cmp	 DWORD PTR [eax+480], 0
  00651	7e 5c		 jle	 SHORT $LN34@CGBeattack

; 16540: 		{
; 16541: 			lpObj->m_SpeedHackPenalty--;

  00653	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$5[ebp]
  00656	8b 88 e0 01 00
	00		 mov	 ecx, DWORD PTR [eax+480]
  0065c	83 e9 01	 sub	 ecx, 1
  0065f	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$5[ebp]
  00662	89 8a e0 01 00
	00		 mov	 DWORD PTR [edx+480], ecx

; 16542: #ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 16543: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left) @%d", 
; 16544: 					  lpObj->AccountID, lpObj->Name, lMsg.Get(1900+lpObj->Class),
; 16545: 					  lpObj->m_SpeedHackPenalty,
; 16546: 					  lpObj->MapNumber);
; 16547: #else
; 16548: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left)", 

  00668	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$5[ebp]
  0066b	8b 88 e0 01 00
	00		 mov	 ecx, DWORD PTR [eax+480]
  00671	51		 push	 ecx
  00672	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$5[ebp]
  00675	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  0067c	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00681	50		 push	 eax
  00682	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00687	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0068d	50		 push	 eax
  0068e	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$5[ebp]
  00691	83 c1 73	 add	 ecx, 115		; 00000073H
  00694	51		 push	 ecx
  00695	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$5[ebp]
  00698	83 c2 68	 add	 edx, 104		; 00000068H
  0069b	52		 push	 edx
  0069c	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5@
  006a1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006a7	83 c4 14	 add	 esp, 20			; 00000014H

; 16549: 					  lpObj->AccountID, lpObj->Name, lMsg.Get(1900+lpObj->Class),
; 16550: 					  lpObj->m_SpeedHackPenalty);
; 16551: #endif
; 16552: 			return;

  006aa	e9 58 05 00 00	 jmp	 $LN1@CGBeattack
$LN34@CGBeattack:

; 16553: 		}
; 16554: 	}
; 16555: 
; 16556: 	
; 16557: 	int lOfs2 = lOfs;

  006af	8b 45 f4	 mov	 eax, DWORD PTR _lOfs$[ebp]
  006b2	89 45 d4	 mov	 DWORD PTR _lOfs2$[ebp], eax

; 16558: 	int pTargetNumber[128];
; 16559: 
; 16560: 	for( int i = 0; i < lpCount->Count; i++ )

  006b5	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$4[ebp], 0
  006bf	eb 0f		 jmp	 SHORT $LN4@CGBeattack
$LN2@CGBeattack:
  006c1	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _i$4[ebp]
  006c7	83 c0 01	 add	 eax, 1
  006ca	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _i$4[ebp], eax
$LN4@CGBeattack:
  006d0	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  006d3	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  006d7	39 8d d0 fd ff
	ff		 cmp	 DWORD PTR _i$4[ebp], ecx
  006dd	7d 48		 jge	 SHORT $LN3@CGBeattack

; 16561: 	{
; 16562: 		lpMsg = (LPPMSG_BEATTACK)(lpRecv+lOfs2);

  006df	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  006e2	03 45 d4	 add	 eax, DWORD PTR _lOfs2$[ebp]
  006e5	89 45 e8	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 16563: 		pTargetNumber[i] = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  006e8	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006eb	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  006ef	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006f5	0f b6 d1	 movzx	 edx, cl
  006f8	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  006fb	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  006fe	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00704	0f b6 c1	 movzx	 eax, cl
  00707	c1 e0 08	 shl	 eax, 8
  0070a	0b d0		 or	 edx, eax
  0070c	0f b7 ca	 movzx	 ecx, dx
  0070f	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _i$4[ebp]
  00715	89 8c 95 d4 fd
	ff ff		 mov	 DWORD PTR _pTargetNumber$[ebp+edx*4], ecx

; 16564: 		lOfs2 += sizeof(PMSG_BEATTACK);

  0071c	8b 45 d4	 mov	 eax, DWORD PTR _lOfs2$[ebp]
  0071f	83 c0 03	 add	 eax, 3
  00722	89 45 d4	 mov	 DWORD PTR _lOfs2$[ebp], eax

; 16565: 	}

  00725	eb 9a		 jmp	 SHORT $LN2@CGBeattack
$LN3@CGBeattack:

; 16566: 	
; 16567: 	int n;
; 16568: 	for( n=0; n<lpCount->Count; n++)

  00727	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  00731	eb 0f		 jmp	 SHORT $LN7@CGBeattack
$LN5@CGBeattack:
  00733	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  00739	83 c0 01	 add	 eax, 1
  0073c	89 85 cc fd ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LN7@CGBeattack:
  00742	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00745	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00749	39 8d cc fd ff
	ff		 cmp	 DWORD PTR _n$[ebp], ecx
  0074f	0f 8d b2 04 00
	00		 jge	 $LN1@CGBeattack

; 16569: 	{
; 16570: 		lpMsg = (LPPMSG_BEATTACK)(lpRecv+lOfs);

  00755	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00758	03 45 f4	 add	 eax, DWORD PTR _lOfs$[ebp]
  0075b	89 45 e8	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 16571: 		tNumber = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  0075e	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00761	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00765	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0076b	0f b6 d1	 movzx	 edx, cl
  0076e	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00771	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00774	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0077a	0f b6 c1	 movzx	 eax, cl
  0077d	c1 e0 08	 shl	 eax, 8
  00780	0b d0		 or	 edx, eax
  00782	0f b7 ca	 movzx	 ecx, dx
  00785	89 4d ec	 mov	 DWORD PTR _tNumber$[ebp], ecx

; 16572: 
; 16573: #ifdef APPLY_DURATION_MAGIC_HACK_CLEANER_20040504
; 16574: 		LPOBJECTSTRUCT lpObj= &gObj[aIndex];

  00788	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0078f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00795	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _lpObj$3[ebp], eax

; 16575: 		
; 16576: 		// MagicKey  0    .
; 16577: #ifdef MODIFY_EVIL_BUGFIX_20080618
; 16578: #ifdef UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808	//    
; 16579: 		if( lpMsg->MagicKey == 0 && 
; 16580: 			( lpMagic->m_Skill == AT_SKILL_EVIL 
; 16581: 			|| g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_EVIL			//  
; 16582: 			|| g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_MAGUMSA_EVIL )	//   
; 16583: 			)
; 16584: #else	// UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808
; 16585: #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428
; 16586: 		if( lpMsg->MagicKey == 0 && 
; 16587: 			( lpMagic->m_Skill == AT_SKILL_EVIL 
; 16588: 			|| g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_EVIL )	//  
; 16589: 			)
; 16590: #else	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 16591: 		if( lpMsg->MagicKey == 0 && lpMagic->m_Skill == AT_SKILL_EVIL )

  0079b	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0079e	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  007a2	85 c9		 test	 ecx, ecx
  007a4	75 11		 jne	 SHORT $LN36@CGBeattack
  007a6	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  007a9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  007ad	83 f9 09	 cmp	 ecx, 9
  007b0	75 05		 jne	 SHORT $LN36@CGBeattack

; 16592: #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 16593: #endif	// UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808
; 16594: 		{
; 16595: 			return;

  007b2	e9 50 04 00 00	 jmp	 $LN1@CGBeattack
$LN36@CGBeattack:

; 16596: 		}
; 16597: #endif	// MODIFY_EVIL_BUGFIX_20080618
; 16598: 
; 16599: #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428	//   4   
; 16600: 		if( lpMsg->MagicKey != 0 &&   // MagicKey    ..
; 16601: 			(lpMagic->m_Skill == AT_SKILL_EVIL
; 16602: 			|| g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_EVIL	//  
; 16603: #ifdef UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808	//    
; 16604: 			|| g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_MAGUMSA_EVIL //   
; 16605: #endif	// UPDATE_MASTER_SKILL_4RANK_ADDITION_20080808
; 16606: 			))
; 16607: #else	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 16608: 		if( lpMsg->MagicKey != 0 && lpMagic->m_Skill == AT_SKILL_EVIL ) // MagicKey    ..

  007b7	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007ba	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  007be	85 c9		 test	 ecx, ecx
  007c0	0f 84 77 01 00
	00		 je	 $LN37@CGBeattack
  007c6	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  007c9	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  007cd	83 f9 09	 cmp	 ecx, 9
  007d0	0f 85 67 01 00
	00		 jne	 $LN37@CGBeattack

; 16609: #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 16610: 		{
; 16611: 			if( !lpObj->DurMagicKeyChecker.IsValidDurationTime( lpMsg->MagicKey ) ) 

  007d6	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007d9	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  007dd	51		 push	 ecx
  007de	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$3[ebp]
  007e4	81 c1 50 0f 00
	00		 add	 ecx, 3920		; 00000f50H
  007ea	e8 00 00 00 00	 call	 ?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::IsValidDurationTime
  007ef	85 c0		 test	 eax, eax
  007f1	75 54		 jne	 SHORT $LN38@CGBeattack

; 16612: 			{
; 16613: 				LogAddC( 0, " InValid DurationTime Key = %d ( Time : %d) [%d][%d]", 

  007f3	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _lpObj$3[ebp]
  007f9	83 c0 73	 add	 eax, 115		; 00000073H
  007fc	50		 push	 eax
  007fd	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$3[ebp]
  00803	83 c1 68	 add	 ecx, 104		; 00000068H
  00806	51		 push	 ecx
  00807	8b 55 e8	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0080a	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0080e	50		 push	 eax
  0080f	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$3[ebp]
  00815	81 c1 50 0f 00
	00		 add	 ecx, 3920		; 00000f50H
  0081b	e8 00 00 00 00	 call	 ?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidDurationTime
  00820	50		 push	 eax
  00821	8b 4d e8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00824	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00828	52		 push	 edx
  00829	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@EOJDOJAH@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5K@
  0082e	6a 00		 push	 0
  00830	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00836	83 c4 18	 add	 esp, 24			; 00000018H

; 16614: 					lpMsg->MagicKey, lpObj->DurMagicKeyChecker.GetValidDurationTime(lpMsg->MagicKey), lpObj->AccountID, lpObj->Name);
; 16615: 				lOfs += sizeof(PMSG_BEATTACK);

  00839	8b 45 f4	 mov	 eax, DWORD PTR _lOfs$[ebp]
  0083c	83 c0 03	 add	 eax, 3
  0083f	89 45 f4	 mov	 DWORD PTR _lOfs$[ebp], eax

; 16616: 				continue;

  00842	e9 ec fe ff ff	 jmp	 $LN5@CGBeattack
$LN38@CGBeattack:

; 16617: 			}
; 16618: 
; 16619: 			if( !lpObj->DurMagicKeyChecker.IsValidCount( lpMsg->MagicKey ) ) 

  00847	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0084a	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0084e	51		 push	 ecx
  0084f	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$3[ebp]
  00855	81 c1 50 0f 00
	00		 add	 ecx, 3920		; 00000f50H
  0085b	e8 00 00 00 00	 call	 ?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::IsValidCount
  00860	85 c0		 test	 eax, eax
  00862	75 54		 jne	 SHORT $LN40@CGBeattack

; 16620: 			{
; 16621: 				LogAddC( 0, " InValid VailidCount = %d ( Count : %d) [%d][%d]", 

  00864	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR _lpObj$3[ebp]
  0086a	83 c0 73	 add	 eax, 115		; 00000073H
  0086d	50		 push	 eax
  0086e	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$3[ebp]
  00874	83 c1 68	 add	 ecx, 104		; 00000068H
  00877	51		 push	 ecx
  00878	8b 55 e8	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0087b	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0087f	50		 push	 eax
  00880	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$3[ebp]
  00886	81 c1 50 0f 00
	00		 add	 ecx, 3920		; 00000f50H
  0088c	e8 00 00 00 00	 call	 ?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidCount
  00891	50		 push	 eax
  00892	8b 4d e8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00895	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00899	52		 push	 edx
  0089a	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@JFIBGMNL@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5@
  0089f	6a 00		 push	 0
  008a1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  008a7	83 c4 18	 add	 esp, 24			; 00000018H

; 16622: 					lpMsg->MagicKey, lpObj->DurMagicKeyChecker.GetValidCount(lpMsg->MagicKey), lpObj->AccountID, lpObj->Name );
; 16623: 				lOfs += sizeof(PMSG_BEATTACK);

  008aa	8b 45 f4	 mov	 eax, DWORD PTR _lOfs$[ebp]
  008ad	83 c0 03	 add	 eax, 3
  008b0	89 45 f4	 mov	 DWORD PTR _lOfs$[ebp], eax

; 16624: 				continue;

  008b3	e9 7b fe ff ff	 jmp	 $LN5@CGBeattack
$LN40@CGBeattack:

; 16625: 			}
; 16626: 			else
; 16627: 			{
; 16628: 				//LogAddC( 0, " DecValidCount = [ %d ] [ %d ]", 
; 16629: 				//	lpMsg->MagicKey, lpObj->DurMagicKeyChecker.DecValidCount( lpMsg->MagicKey ) );
; 16630: 			}
; 16631: 
; 16632: 			//LogAddC( 0, " PASS");
; 16633: 
; 16634: #ifdef MODIFY_EVIL_BUGFIX_20080618	//    
; 16635: 			if( !CHECK_LIMIT( tNumber, MAX_OBJECT ) )

  008b8	83 7d ec 00	 cmp	 DWORD PTR _tNumber$[ebp], 0
  008bc	7d 0c		 jge	 SHORT $LN59@CGBeattack
  008be	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv506[ebp], 0
  008c8	eb 2b		 jmp	 SHORT $LN60@CGBeattack
$LN59@CGBeattack:
  008ca	81 7d ec e7 1c
	00 00		 cmp	 DWORD PTR _tNumber$[ebp], 7399 ; 00001ce7H
  008d1	7e 0c		 jle	 SHORT $LN57@CGBeattack
  008d3	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv505[ebp], 0
  008dd	eb 0a		 jmp	 SHORT $LN58@CGBeattack
$LN57@CGBeattack:
  008df	c7 85 38 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv505[ebp], 1
$LN58@CGBeattack:
  008e9	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR tv505[ebp]
  008ef	89 85 3c fd ff
	ff		 mov	 DWORD PTR tv506[ebp], eax
$LN60@CGBeattack:
  008f5	83 bd 3c fd ff
	ff 00		 cmp	 DWORD PTR tv506[ebp], 0
  008fc	75 05		 jne	 SHORT $LN41@CGBeattack

; 16636: 				continue;

  008fe	e9 30 fe ff ff	 jmp	 $LN5@CGBeattack
$LN41@CGBeattack:

; 16637: 
; 16638: 			int dis = gObjCalDistance(lpObj, &gObj[tNumber]);

  00903	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _tNumber$[ebp], 7072
  0090a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00910	50		 push	 eax
  00911	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _lpObj$3[ebp]
  00917	51		 push	 ecx
  00918	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0091d	83 c4 08	 add	 esp, 8
  00920	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _dis$2[ebp], eax

; 16639: 			if( dis > 13 )

  00926	83 bd c4 fd ff
	ff 0d		 cmp	 DWORD PTR _dis$2[ebp], 13 ; 0000000dH
  0092d	7e 0e		 jle	 SHORT $LN37@CGBeattack

; 16640: 			{
; 16641: 				lOfs += sizeof(PMSG_BEATTACK);

  0092f	8b 45 f4	 mov	 eax, DWORD PTR _lOfs$[ebp]
  00932	83 c0 03	 add	 eax, 3
  00935	89 45 f4	 mov	 DWORD PTR _lOfs$[ebp], eax

; 16642: 				continue;

  00938	e9 f6 fd ff ff	 jmp	 $LN5@CGBeattack
$LN37@CGBeattack:

; 16643: 			}
; 16644: #endif	// MODIFY_EVIL_BUGFIX_20080618
; 16645: 		}
; 16646: #endif		
; 16647: 
; 16648: #ifdef APPLY_TESTSERVER
; 16649: 		if( gWriteSkillLog )

  0093d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gWriteSkillLog@@3HA, 0 ; gWriteSkillLog
  00944	74 2a		 je	 SHORT $LN43@CGBeattack

; 16650: 			LogAddTD("Magic Attack3 : %d, serial = %d, Tgt =  %d, cnt = %d", lpMagic->m_Skill, lpCount->Serial, tNumber, lpCount->Count);

  00946	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00949	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0094d	51		 push	 ecx
  0094e	8b 55 ec	 mov	 edx, DWORD PTR _tNumber$[ebp]
  00951	52		 push	 edx
  00952	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00955	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00959	51		 push	 ecx
  0095a	8b 55 f0	 mov	 edx, DWORD PTR _lpMagic$[ebp]
  0095d	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00961	50		 push	 eax
  00962	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GMGPOAFD@Magic?5Attack3?5?3?5?$CFd?0?5serial?5?$DN?5?$CFd@
  00967	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0096d	83 c4 14	 add	 esp, 20			; 00000014H
$LN43@CGBeattack:

; 16651: #endif
; 16652: 
; 16653: #ifdef CHECK_PENETRATION_SKILL
; 16654: 		if( gEnableCheckPenetrationSkill )

  00970	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gEnableCheckPenetrationSkill@@3HA, 0 ; gEnableCheckPenetrationSkill
  00977	74 3b		 je	 SHORT $LN44@CGBeattack

; 16655: 		{
; 16656: #ifdef ADD_SKILL_DARKLOAD_FIRESCREAM_20060601	//   
; 16657: 			if( lpMagic->m_Skill == AT_SKILL_FIRESCREAM )
; 16658: 			{
; 16659: 				if( !gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckFireScreamSkill( tNumber, lpMagic->m_Skill, lpCount->Serial ) )
; 16660: 					return;
; 16661: 			}
; 16662: 			else
; 16663: #endif	//ADD_SKILL_DARKLOAD_FIRESCREAM_20060601
; 16664: 			if( !gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckPenetrationSkill(tNumber, lpMagic->m_Skill, lpCount->Serial) )

  00979	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  0097c	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00980	51		 push	 ecx
  00981	8b 55 f0	 mov	 edx, DWORD PTR _lpMagic$[ebp]
  00984	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00988	50		 push	 eax
  00989	8b 4d ec	 mov	 ecx, DWORD PTR _tNumber$[ebp]
  0098c	51		 push	 ecx
  0098d	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00994	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00999	69 0c 10 58 28
	00 00		 imul	 ecx, DWORD PTR [eax+edx], 10328
  009a0	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
  009a6	e8 00 00 00 00	 call	 ?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z ; CMultiAttackHackCheck::CheckPenetrationSkill
  009ab	85 c0		 test	 eax, eax
  009ad	75 05		 jne	 SHORT $LN44@CGBeattack

; 16665: 			{	//       
; 16666: 				//LogAddTD("[%s][%s] Ignore Skill [%d]", 
; 16667: 				//		 gObj[aIndex].AccountID, 
; 16668: 				//		 gObj[aIndex].Name, 
; 16669: 				//		 lpMagic->m_Skill);
; 16670: 
; 16671: 				//GCServerMsgStringSend("Hack 2 Da", gObj[aIndex].m_Index, 1);
; 16672: 				//CloseClient(gObj[aIndex].m_Index);
; 16673: 				return;

  009af	e9 53 02 00 00	 jmp	 $LN1@CGBeattack
$LN44@CGBeattack:

; 16674: 			}		
; 16675: 		}
; 16676: #endif
; 16677: 
; 16678: 
; 16679: 		for( int i = 0; i < lpCount->Count; i++ )

  009b4	c7 85 c0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  009be	eb 0f		 jmp	 SHORT $LN10@CGBeattack
$LN8@CGBeattack:
  009c0	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  009c6	83 c0 01	 add	 eax, 1
  009c9	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN10@CGBeattack:
  009cf	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  009d2	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  009d6	39 8d c0 fd ff
	ff		 cmp	 DWORD PTR _i$1[ebp], ecx
  009dc	0f 8d a1 00 00
	00		 jge	 $LN9@CGBeattack

; 16680: 		{
; 16681: 			if( n != i )

  009e2	8b 85 cc fd ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  009e8	3b 85 c0 fd ff
	ff		 cmp	 eax, DWORD PTR _i$1[ebp]
  009ee	0f 84 8a 00 00
	00		 je	 $LN46@CGBeattack

; 16682: 			{
; 16683: 				if( pTargetNumber[i] == tNumber )

  009f4	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  009fa	8b 8c 85 d4 fd
	ff ff		 mov	 ecx, DWORD PTR _pTargetNumber$[ebp+eax*4]
  00a01	3b 4d ec	 cmp	 ecx, DWORD PTR _tNumber$[ebp]
  00a04	75 78		 jne	 SHORT $LN46@CGBeattack

; 16684: 				{
; 16685: 					LogAddTD("[%s][%s] %s Detect Hack : Multi Attack", 

  00a06	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a13	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00a1b	81 c2 6c 07 00
	00		 add	 edx, 1900		; 0000076cH
  00a21	52		 push	 edx
  00a22	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00a27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00a2d	50		 push	 eax
  00a2e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a35	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a3b	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00a3f	52		 push	 edx
  00a40	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a4d	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00a51	52		 push	 edx
  00a52	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi@
  00a57	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a5d	83 c4 10	 add	 esp, 16			; 00000010H

; 16686: 							 gObj[aIndex].AccountID, 
; 16687: 							 gObj[aIndex].Name, 
; 16688: 							 lMsg.Get(1900+gObj[aIndex].Class));
; 16689: 					CloseClient(gObj[aIndex].m_Index);

  00a60	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a67	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a6d	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00a70	52		 push	 edx
  00a71	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00a76	83 c4 04	 add	 esp, 4

; 16690: 					return;

  00a79	e9 89 01 00 00	 jmp	 $LN1@CGBeattack
$LN46@CGBeattack:

; 16691: 				}
; 16692: 			}
; 16693: 		}

  00a7e	e9 3d ff ff ff	 jmp	 $LN8@CGBeattack
$LN9@CGBeattack:

; 16694: 
; 16695: 		if( tNumber >= 0 && tNumber < MAX_OBJECT-1 )

  00a83	83 7d ec 00	 cmp	 DWORD PTR _tNumber$[ebp], 0
  00a87	0f 8c 6c 01 00
	00		 jl	 $LN48@CGBeattack
  00a8d	81 7d ec e7 1c
	00 00		 cmp	 DWORD PTR _tNumber$[ebp], 7399 ; 00001ce7H
  00a94	0f 8d 5f 01 00
	00		 jge	 $LN48@CGBeattack

; 16696: 		{
; 16697: #ifdef NEW_FORSKYLAND2
; 16698: 			if( lpMagic->m_Skill == AT_SKILL_DEFENSEDOWN )

  00a9a	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00a9d	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00aa1	83 f9 37	 cmp	 ecx, 55			; 00000037H
  00aa4	0f 85 e7 00 00
	00		 jne	 $LN49@CGBeattack

; 16699: 			{	//   				
; 16700: #ifdef MODIFY_BLOOD_ATTACK_AND_ADD_STRENGTH_BUGFIX_20080701
; 16701: 				if( gObj[aIndex].Type == OBJTYPE_CHARACTER )		//    

  00aaa	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ab1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ab7	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00abc	83 fa 01	 cmp	 edx, 1
  00abf	0f 85 80 00 00
	00		 jne	 $LN51@CGBeattack

; 16702: 				{
; 16703: 					//       .
; 16704: 					if( gObj[aIndex].Strength+gObj[aIndex].AddStrength >= 596 )

  00ac5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00acc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ad2	0f b7 94 01 b4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+180]
  00ada	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ae1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ae7	0f b7 84 01 e0
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+224]
  00aef	03 d0		 add	 edx, eax
  00af1	81 fa 54 02 00
	00		 cmp	 edx, 596		; 00000254H
  00af7	7c 4a		 jl	 SHORT $LN53@CGBeattack

; 16705: 					{
; 16706: 						gObjUseSkill.MaGumSkillDefenseDown(aIndex, tNumber, lpMagic->m_Level);

  00af9	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00afc	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00b00	51		 push	 ecx
  00b01	8b 55 ec	 mov	 edx, DWORD PTR _tNumber$[ebp]
  00b04	52		 push	 edx
  00b05	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b08	50		 push	 eax
  00b09	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00b0e	e8 00 00 00 00	 call	 ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z ; CObjUseSkill::MaGumSkillDefenseDown

; 16707: 						gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, 1, 1);

  00b13	6a 00		 push	 0
  00b15	6a 00		 push	 0
  00b17	6a 01		 push	 1
  00b19	6a 01		 push	 1
  00b1b	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00b1e	50		 push	 eax
  00b1f	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _tNumber$[ebp], 7072
  00b26	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b2c	51		 push	 ecx
  00b2d	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00b34	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b3a	52		 push	 edx
  00b3b	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00b40	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN53@CGBeattack:

; 16708: 					}
; 16709: 				}

  00b43	eb 4a		 jmp	 SHORT $LN52@CGBeattack
$LN51@CGBeattack:

; 16710: 				else	//       .
; 16711: 				{
; 16712: 					gObjUseSkill.MaGumSkillDefenseDown(aIndex, tNumber, lpMagic->m_Level);

  00b45	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00b48	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00b4c	51		 push	 ecx
  00b4d	8b 55 ec	 mov	 edx, DWORD PTR _tNumber$[ebp]
  00b50	52		 push	 edx
  00b51	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b54	50		 push	 eax
  00b55	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00b5a	e8 00 00 00 00	 call	 ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHH@Z ; CObjUseSkill::MaGumSkillDefenseDown

; 16713: 					gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, 1, 1);

  00b5f	6a 00		 push	 0
  00b61	6a 00		 push	 0
  00b63	6a 01		 push	 1
  00b65	6a 01		 push	 1
  00b67	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00b6a	50		 push	 eax
  00b6b	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _tNumber$[ebp], 7072
  00b72	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b78	51		 push	 ecx
  00b79	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00b80	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b86	52		 push	 edx
  00b87	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00b8c	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN52@CGBeattack:

; 16714: 				}
; 16715: #else
; 16716: 				gObjUseSkill.MaGumSkillDefenseDown(aIndex, tNumber, lpMagic->m_Level);
; 16717: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, 1, 1);
; 16718: #endif // MODIFY_BLOOD_ATTACK_AND_ADD_STRENGTH_BUGFIX_20080701
; 16719: 			}

  00b8f	eb 68		 jmp	 SHORT $LN48@CGBeattack
$LN49@CGBeattack:

; 16720: 			else
; 16721: #endif
; 16722: #ifdef ADD_SKILL_DARKLOAD_FIRESCREAM_20060601
; 16723: 			if( lpMagic->m_Skill == AT_SKILL_FIRESCREAM )
; 16724: 			{
; 16725: 				gObjUseSkill.SkillFireScream( aIndex, tNumber, lpMagic );
; 16726: 			}
; 16727: 			else
; 16728: #endif
; 16729: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	
; 16730: 			//   
; 16731: 			if( g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_DEFENSEDOWN )
; 16732: 			{
; 16733: 				g_MasterSkillSystem.MLS_MaGumSkillDefenseDown( aIndex, tNumber );
; 16734: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, 1, 1);
; 16735: 			}
; 16736: #ifdef MODIFY_MAGUMSA_SKILL_BUGFIX_20081015	// Attack  
; 16737: 			else 
; 16738: #endif	// MODIFY_MAGUMSA_SKILL_BUGFIX_20081015
; 16739: 			//   
; 16740: 			if( g_MasterSkillSystem.GetBaseMasterLevelSkill( lpMagic->m_Skill ) == AT_SKILL_ML_STRENGTHEN_FIRESCREAM )
; 16741: 			{
; 16742: 				g_MasterSkillSystem.MLS_FireScream( aIndex, tNumber, lpMagic );
; 16743: 			}
; 16744: 			else
; 16745: #endif	// ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107				
; 16746: 			{
; 16747: 				if( magic_send )

  00b91	83 7d 10 00	 cmp	 DWORD PTR _magic_send$[ebp], 0
  00b95	74 32		 je	 SHORT $LN54@CGBeattack

; 16748: 				{
; 16749: 					gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, 1, 1);

  00b97	6a 00		 push	 0
  00b99	6a 00		 push	 0
  00b9b	6a 01		 push	 1
  00b9d	6a 01		 push	 1
  00b9f	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00ba2	50		 push	 eax
  00ba3	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _tNumber$[ebp], 7072
  00baa	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bb0	51		 push	 ecx
  00bb1	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00bb8	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bbe	52		 push	 edx
  00bbf	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00bc4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 16750: 				}

  00bc7	eb 30		 jmp	 SHORT $LN48@CGBeattack
$LN54@CGBeattack:

; 16751: 				else gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, 0, 1);

  00bc9	6a 00		 push	 0
  00bcb	6a 00		 push	 0
  00bcd	6a 01		 push	 1
  00bcf	6a 00		 push	 0
  00bd1	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00bd4	50		 push	 eax
  00bd5	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _tNumber$[ebp], 7072
  00bdc	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00be2	51		 push	 ecx
  00be3	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00bea	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bf0	52		 push	 edx
  00bf1	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00bf6	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN48@CGBeattack:

; 16752: 			}
; 16753: 		}
; 16754: 		lOfs += sizeof(PMSG_BEATTACK);

  00bf9	8b 45 f4	 mov	 eax, DWORD PTR _lOfs$[ebp]
  00bfc	83 c0 03	 add	 eax, 3
  00bff	89 45 f4	 mov	 DWORD PTR _lOfs$[ebp], eax

; 16755: 	}	

  00c02	e9 2c fb ff ff	 jmp	 $LN5@CGBeattack
$LN1@CGBeattack:

; 16756: }

  00c07	5f		 pop	 edi
  00c08	5e		 pop	 esi
  00c09	5b		 pop	 ebx
  00c0a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c0d	33 cd		 xor	 ecx, ebp
  00c0f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c14	8b e5		 mov	 esp, ebp
  00c16	5d		 pop	 ebp
  00c17	c3		 ret	 0
?CGBeattackRecv@@YAXPAEHH@Z ENDP			; CGBeattackRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -284						; size = 4
_Count$ = -280						; size = 4
_lOfs$ = -276						; size = 4
_sendbuf$ = -272					; size = 256
_pList$ = -16						; size = 3
_pCount$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z PROC	; GCMagicListMultiSend, COMDAT

; 4019 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 4020 : 	PMSG_MAGICLISTCOUNT	pCount;
; 4021 : 	PMSG_MAGICLIST		pList;
; 4022 : 	
; 4023 : #ifdef EXPAND_MAX_MAGICLIST_20_TO_60_20041126
; 4024 : 	char sendbuf[1000];
; 4025 : #else
; 4026 : 	char sendbuf[256];
; 4027 : #endif
; 4028 : 	int  lOfs=sizeof(pCount);

  00016	c7 85 ec fe ff
	ff 05 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 5

; 4029 : 	int	 Count=0;

  00020	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _Count$[ebp], 0

; 4030 : 
; 4031 : #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 4032 : 	pCount.btListType	= btListType;
; 4033 : #endif
; 4034 : 	
; 4035 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  0002a	6a 00		 push	 0
  0002c	6a 11		 push	 17			; 00000011H
  0002e	68 f3 00 00 00	 push	 243			; 000000f3H
  00033	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0003c	83 c4 10	 add	 esp, 16			; 00000010H

; 4036 : 	
; 4037 : 	for( int n=0; n<MAX_MAGIC; n++)

  0003f	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1[ebp], 0
  00049	eb 0f		 jmp	 SHORT $LN4@GCMagicLis
$LN2@GCMagicLis:
  0004b	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@GCMagicLis:
  0005a	83 bd e4 fe ff
	ff 3c		 cmp	 DWORD PTR _n$1[ebp], 60	; 0000003cH
  00061	0f 8d e5 00 00
	00		 jge	 $LN3@GCMagicLis

; 4038 : 	{
; 4039 : 		if( lpObj->Magic[n].IsMagic() == TRUE )

  00067	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$1[ebp]
  0006d	c1 e1 04	 shl	 ecx, 4
  00070	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00073	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  00079	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0007e	83 f8 01	 cmp	 eax, 1
  00081	0f 85 c0 00 00
	00		 jne	 $LN5@GCMagicLis

; 4040 : 		{
; 4041 : #ifdef MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_2ND_20090514
; 4042 : 			//       
; 4043 : #else // MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_2ND_20090514
; 4044 : 	#ifdef MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_20080807	//     
; 4045 : 			if( g_MasterSkillSystem.CheckUsableWeaponSkill(lpObj, n) == FALSE)
; 4046 : 			{
; 4047 : 				continue;
; 4048 : 			}
; 4049 : 	#endif	// MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_20080807
; 4050 : #endif // MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_2ND_20090514
; 4051 : 
; 4052 : 			pList.Pos            = n;

  00087	8a 85 e4 fe ff
	ff		 mov	 al, BYTE PTR _n$1[ebp]
  0008d	88 45 f0	 mov	 BYTE PTR _pList$[ebp], al

; 4053 : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// PMSG_MAGICLIST  
; 4054 : 			pList.wSkillNum		 = lpObj->Magic[n].m_Skill;//(lpObj->Magic[n].m_Type<<4)+(lpObj->Magic[n].m_Index);
; 4055 : 			pList.btSkillLevel   = (lpObj->Magic[n].m_Level<<3);
; 4056 : 			pList.btSkillLevel  |= (lpObj->Magic[n].m_Skill&0x07);
; 4057 : #else
; 4058 : 			pList.MagicInfo[0]   = lpObj->Magic[n].m_Skill;//(lpObj->Magic[n].m_Type<<4)+(lpObj->Magic[n].m_Index);

  00090	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00096	c1 e0 04	 shl	 eax, 4
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009c	8b 91 10 03 00
	00		 mov	 edx, DWORD PTR [ecx+784]
  000a2	b9 01 00 00 00	 mov	 ecx, 1
  000a7	6b c9 00	 imul	 ecx, ecx, 0
  000aa	8a 54 02 05	 mov	 dl, BYTE PTR [edx+eax+5]
  000ae	88 54 0d f1	 mov	 BYTE PTR _pList$[ebp+ecx+1], dl

; 4059 : 			pList.MagicInfo[1]   = (lpObj->Magic[n].m_Level<<3);

  000b2	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  000b8	c1 e0 04	 shl	 eax, 4
  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000be	8b 91 10 03 00
	00		 mov	 edx, DWORD PTR [ecx+784]
  000c4	0f b6 44 02 04	 movzx	 eax, BYTE PTR [edx+eax+4]
  000c9	c1 e0 03	 shl	 eax, 3
  000cc	b9 01 00 00 00	 mov	 ecx, 1
  000d1	c1 e1 00	 shl	 ecx, 0
  000d4	88 44 0d f1	 mov	 BYTE PTR _pList$[ebp+ecx+1], al

; 4060 : 			pList.MagicInfo[1]  |= (lpObj->Magic[n].m_Skill&0x07);

  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	c1 e0 00	 shl	 eax, 0
  000e0	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _n$1[ebp]
  000e6	c1 e1 04	 shl	 ecx, 4
  000e9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ec	8b 92 10 03 00
	00		 mov	 edx, DWORD PTR [edx+784]
  000f2	0f b6 4c 0a 05	 movzx	 ecx, BYTE PTR [edx+ecx+5]
  000f7	83 e1 07	 and	 ecx, 7
  000fa	0f b6 54 05 f1	 movzx	 edx, BYTE PTR _pList$[ebp+eax+1]
  000ff	0b d1		 or	 edx, ecx
  00101	b8 01 00 00 00	 mov	 eax, 1
  00106	c1 e0 00	 shl	 eax, 0
  00109	88 54 05 f1	 mov	 BYTE PTR _pList$[ebp+eax+1], dl

; 4061 : #endif
; 4062 : 
; 4063 : 			memcpy(sendbuf+lOfs, &pList, sizeof(pList));

  0010d	6a 03		 push	 3
  0010f	8d 45 f0	 lea	 eax, DWORD PTR _pList$[ebp]
  00112	50		 push	 eax
  00113	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00119	8d 94 0d f0 fe
	ff ff		 lea	 edx, DWORD PTR _sendbuf$[ebp+ecx]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 _memcpy
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4064 : 			lOfs += sizeof( pList );

  00129	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0012f	83 c0 03	 add	 eax, 3
  00132	89 85 ec fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 4065 : 			Count++;

  00138	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _Count$[ebp]
  0013e	83 c0 01	 add	 eax, 1
  00141	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _Count$[ebp], eax
$LN5@GCMagicLis:

; 4066 : 		}
; 4067 : 	}

  00147	e9 ff fe ff ff	 jmp	 $LN2@GCMagicLis
$LN3@GCMagicLis:

; 4068 : 	pCount.Count  = Count;

  0014c	8a 85 e8 fe ff
	ff		 mov	 al, BYTE PTR _Count$[ebp]
  00152	88 45 f8	 mov	 BYTE PTR _pCount$[ebp+4], al

; 4069 : 	pCount.h.size = lOfs;

  00155	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  0015b	88 45 f5	 mov	 BYTE PTR _pCount$[ebp+1], al

; 4070 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  0015e	6a 05		 push	 5
  00160	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  00163	50		 push	 eax
  00164	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  0016a	51		 push	 ecx
  0016b	e8 00 00 00 00	 call	 _memcpy
  00170	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4071 : 
; 4072 : 	DataSend(lpObj->m_Index, (LPBYTE)sendbuf, lOfs);

  00173	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00179	50		 push	 eax
  0017a	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  00180	51		 push	 ecx
  00181	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00184	8b 02		 mov	 eax, DWORD PTR [edx]
  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4073 : }

  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi
  00191	5b		 pop	 ebx
  00192	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00195	33 cd		 xor	 ecx, ebp
  00197	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019c	8b e5		 mov	 esp, ebp
  0019e	5d		 pop	 ebp
  0019f	c3		 ret	 0
?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; GCMagicListMultiSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCMagicListOneDelSend@@YAXHDEEE@Z
_TEXT	SEGMENT
_lOfs$ = -276						; size = 4
_sendbuf$ = -272					; size = 256
_pList$ = -16						; size = 3
_pCount$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Pos$ = 12						; size = 1
_type$ = 16						; size = 1
_level$ = 20						; size = 1
_skill$ = 24						; size = 1
?GCMagicListOneDelSend@@YAXHDEEE@Z PROC			; GCMagicListOneDelSend, COMDAT

; 3973 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3974 : 	PMSG_MAGICLISTCOUNT	pCount;
; 3975 : 	PMSG_MAGICLIST		pList;
; 3976 : 
; 3977 : #ifdef EXPAND_MAX_MAGICLIST_20_TO_60_20041126
; 3978 : 	char sendbuf[1000];
; 3979 : #else
; 3980 : 	char sendbuf[256];
; 3981 : #endif
; 3982 : 
; 3983 : 	int  lOfs=sizeof(pCount);

  00016	c7 85 ec fe ff
	ff 05 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 5

; 3984 : 	
; 3985 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0 );

  00020	6a 00		 push	 0
  00022	6a 11		 push	 17			; 00000011H
  00024	68 f3 00 00 00	 push	 243			; 000000f3H
  00029	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 3986 : 	pCount.h.size		= 0;

  00035	c6 45 f5 00	 mov	 BYTE PTR _pCount$[ebp+1], 0

; 3987 : 	pCount.Count        = 0xFF;	//  0xFF   .

  00039	c6 45 f8 ff	 mov	 BYTE PTR _pCount$[ebp+4], 255 ; 000000ffH

; 3988 : 	
; 3989 : #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 3990 : 	pCount.btListType	= btListType;
; 3991 : #endif
; 3992 : 
; 3993 : 	pList.Pos           = Pos;

  0003d	8a 45 0c	 mov	 al, BYTE PTR _Pos$[ebp]
  00040	88 45 f0	 mov	 BYTE PTR _pList$[ebp], al

; 3994 : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// PMSG_MAGICLIST  
; 3995 : 	pList.wSkillNum		= type;
; 3996 : 	pList.btSkillLevel  = (level<<3);
; 3997 : 	pList.btSkillLevel  |= (skill&0x07);
; 3998 : #else
; 3999 : 	pList.MagicInfo[0]  = type;

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	6b c8 00	 imul	 ecx, eax, 0
  0004b	8a 55 10	 mov	 dl, BYTE PTR _type$[ebp]
  0004e	88 54 0d f1	 mov	 BYTE PTR _pList$[ebp+ecx+1], dl

; 4000 : 	pList.MagicInfo[1]  = (level<<3);

  00052	0f b6 45 14	 movzx	 eax, BYTE PTR _level$[ebp]
  00056	c1 e0 03	 shl	 eax, 3
  00059	b9 01 00 00 00	 mov	 ecx, 1
  0005e	c1 e1 00	 shl	 ecx, 0
  00061	88 44 0d f1	 mov	 BYTE PTR _pList$[ebp+ecx+1], al

; 4001 : 	pList.MagicInfo[1]  |= (skill&0x07);

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	c1 e0 00	 shl	 eax, 0
  0006d	0f b6 4d 18	 movzx	 ecx, BYTE PTR _skill$[ebp]
  00071	83 e1 07	 and	 ecx, 7
  00074	0f b6 54 05 f1	 movzx	 edx, BYTE PTR _pList$[ebp+eax+1]
  00079	0b d1		 or	 edx, ecx
  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	c1 e0 00	 shl	 eax, 0
  00083	88 54 05 f1	 mov	 BYTE PTR _pList$[ebp+eax+1], dl

; 4002 : #endif
; 4003 : 	
; 4004 : 	memcpy(sendbuf+lOfs, &pList, sizeof(pList));

  00087	6a 03		 push	 3
  00089	8d 45 f0	 lea	 eax, DWORD PTR _pList$[ebp]
  0008c	50		 push	 eax
  0008d	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00093	8d 94 0d f0 fe
	ff ff		 lea	 edx, DWORD PTR _sendbuf$[ebp+ecx]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 _memcpy
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4005 : 	lOfs += sizeof( pList );

  000a3	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000a9	83 c0 03	 add	 eax, 3
  000ac	89 85 ec fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 4006 : 
; 4007 : 	pCount.h.size = lOfs;

  000b2	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  000b8	88 45 f5	 mov	 BYTE PTR _pCount$[ebp+1], al

; 4008 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  000bb	6a 05		 push	 5
  000bd	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  000c0	50		 push	 eax
  000c1	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 _memcpy
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4009 : 
; 4010 : 	DataSend(aIndex, (LPBYTE)sendbuf, lOfs);

  000d0	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000d6	50		 push	 eax
  000d7	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  000dd	51		 push	 ecx
  000de	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000e1	52		 push	 edx
  000e2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4011 : }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
?GCMagicListOneDelSend@@YAXHDEEE@Z ENDP			; GCMagicListOneDelSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCMagicListOneSend@@YAXHDEEE@Z
_TEXT	SEGMENT
_lOfs$ = -276						; size = 4
_sendbuf$ = -272					; size = 256
_pList$ = -16						; size = 3
_pCount$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Pos$ = 12						; size = 1
_type$ = 16						; size = 1
_level$ = 20						; size = 1
_skill$ = 24						; size = 1
?GCMagicListOneSend@@YAXHDEEE@Z PROC			; GCMagicListOneSend, COMDAT

; 3922 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3923 : 	PMSG_MAGICLISTCOUNT	pCount;
; 3924 : 	PMSG_MAGICLIST		pList;
; 3925 : 
; 3926 : #ifdef EXPAND_MAX_MAGICLIST_20_TO_60_20041126
; 3927 : 	char sendbuf[1000];
; 3928 : #else
; 3929 : 	char sendbuf[256];
; 3930 : #endif
; 3931 : 	
; 3932 : 	int  lOfs=sizeof(pCount);

  00016	c7 85 ec fe ff
	ff 05 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 5

; 3933 : 
; 3934 : 	
; 3935 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  00020	6a 00		 push	 0
  00022	6a 11		 push	 17			; 00000011H
  00024	68 f3 00 00 00	 push	 243			; 000000f3H
  00029	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 3936 : 
; 3937 : 	pCount.Count        = 0xFE;

  00035	c6 45 f8 fe	 mov	 BYTE PTR _pCount$[ebp+4], 254 ; 000000feH

; 3938 : 
; 3939 : #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 3940 : 	pCount.btListType	= btListType;
; 3941 : #endif
; 3942 : 	
; 3943 : 	pList.Pos           = Pos;

  00039	8a 45 0c	 mov	 al, BYTE PTR _Pos$[ebp]
  0003c	88 45 f0	 mov	 BYTE PTR _pList$[ebp], al

; 3944 : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// PMSG_MAGICLIST  
; 3945 : 	pList.wSkillNum		= type;
; 3946 : 	pList.btSkillLevel  = (level<<3);
; 3947 : 	pList.btSkillLevel  |= (skill&0x07);
; 3948 : #else
; 3949 : 	pList.MagicInfo[0]  = type;

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	6b c8 00	 imul	 ecx, eax, 0
  00047	8a 55 10	 mov	 dl, BYTE PTR _type$[ebp]
  0004a	88 54 0d f1	 mov	 BYTE PTR _pList$[ebp+ecx+1], dl

; 3950 : 	pList.MagicInfo[1]  = (level<<3);

  0004e	0f b6 45 14	 movzx	 eax, BYTE PTR _level$[ebp]
  00052	c1 e0 03	 shl	 eax, 3
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	c1 e1 00	 shl	 ecx, 0
  0005d	88 44 0d f1	 mov	 BYTE PTR _pList$[ebp+ecx+1], al

; 3951 : 	pList.MagicInfo[1]  |= (skill&0x07);

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	c1 e0 00	 shl	 eax, 0
  00069	0f b6 4d 18	 movzx	 ecx, BYTE PTR _skill$[ebp]
  0006d	83 e1 07	 and	 ecx, 7
  00070	0f b6 54 05 f1	 movzx	 edx, BYTE PTR _pList$[ebp+eax+1]
  00075	0b d1		 or	 edx, ecx
  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	c1 e0 00	 shl	 eax, 0
  0007f	88 54 05 f1	 mov	 BYTE PTR _pList$[ebp+eax+1], dl

; 3952 : #endif
; 3953 : 	
; 3954 : 	memcpy(sendbuf+lOfs, &pList, sizeof(pList));

  00083	6a 03		 push	 3
  00085	8d 45 f0	 lea	 eax, DWORD PTR _pList$[ebp]
  00088	50		 push	 eax
  00089	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  0008f	8d 94 0d f0 fe
	ff ff		 lea	 edx, DWORD PTR _sendbuf$[ebp+ecx]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 _memcpy
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3955 : 	lOfs += sizeof( pList );

  0009f	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000a5	83 c0 03	 add	 eax, 3
  000a8	89 85 ec fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 3956 : 
; 3957 : 	pCount.h.size = lOfs;

  000ae	8a 85 ec fe ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  000b4	88 45 f5	 mov	 BYTE PTR _pCount$[ebp+1], al

; 3958 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  000b7	6a 05		 push	 5
  000b9	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  000bc	50		 push	 eax
  000bd	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _memcpy
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3959 : 
; 3960 : 	DataSend(aIndex, (LPBYTE)sendbuf, lOfs);

  000cc	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000d2	50		 push	 eax
  000d3	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  000d9	51		 push	 ecx
  000da	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000dd	52		 push	 edx
  000de	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3961 : }

  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ec	33 cd		 xor	 ecx, ebp
  000ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
?GCMagicListOneSend@@YAXHDEEE@Z ENDP			; GCMagicListOneSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_lpObj$ = 8						; size = 4
_MoveNumber$ = 12					; size = 1
_MapNumber$ = 16					; size = 1
_MapX$ = 20						; size = 1
_MapY$ = 24						; size = 1
_Dir$ = 28						; size = 1
?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z PROC	; GCTeleportSend, COMDAT

; 16113: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16114: 	if( lpObj->Type != OBJTYPE_CHARACTER ) return;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 02		 je	 SHORT $LN2@GCTeleport
  00015	eb 62		 jmp	 SHORT $LN1@GCTeleport
$LN2@GCTeleport:

; 16115: 
; 16116: 	PMSG_TELEPORT_RESULT	pMsg;
; 16117: 	//BYTE sendbuf[256];
; 16118: 
; 16119: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// MoveNumber 0 / 1 .(Gate   BYTE )
; 16120: 	if( MoveNumber > 0 )
; 16121: 		MoveNumber = 1;
; 16122: #endif
; 16123: 
; 16124: 	pMsg.h.c		= PMHCE_BYTE;

  00017	c6 45 f8 c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H

; 16125: 	pMsg.h.size		= sizeof( pMsg );

  0001b	c6 45 f9 08	 mov	 BYTE PTR _pMsg$[ebp+1], 8

; 16126: 	pMsg.h.headcode = 0x1C;

  0001f	c6 45 fa 1c	 mov	 BYTE PTR _pMsg$[ebp+2], 28 ; 0000001cH

; 16127: 	pMsg.MoveNumber = MoveNumber;

  00023	8a 45 0c	 mov	 al, BYTE PTR _MoveNumber$[ebp]
  00026	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 16128: 	pMsg.MapNumber  = MapNumber;

  00029	8a 45 10	 mov	 al, BYTE PTR _MapNumber$[ebp]
  0002c	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 16129: 	pMsg.MapX		= MapX;

  0002f	8a 45 14	 mov	 al, BYTE PTR _MapX$[ebp]
  00032	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 16130: 	pMsg.MapY		= MapY;

  00035	8a 45 18	 mov	 al, BYTE PTR _MapY$[ebp]
  00038	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 16131: 	pMsg.Dir		= Dir;

  0003b	8a 45 1c	 mov	 al, BYTE PTR _Dir$[ebp]
  0003e	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+7], al

; 16132: 
; 16133: 	if( MoveNumber == 0 )

  00041	0f b6 45 0c	 movzx	 eax, BYTE PTR _MoveNumber$[ebp]
  00045	85 c0		 test	 eax, eax
  00047	75 19		 jne	 SHORT $LN3@GCTeleport

; 16134: 	{
; 16135: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00049	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0004d	50		 push	 eax
  0004e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00055	8b 02		 mov	 eax, DWORD PTR [edx]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16136: 	}

  00060	eb 17		 jmp	 SHORT $LN1@GCTeleport
$LN3@GCTeleport:

; 16137: 	else
; 16138: 	{
; 16139: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00062	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00066	50		 push	 eax
  00067	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0006a	51		 push	 ecx
  0006b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0006e	8b 02		 mov	 eax, DWORD PTR [edx]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCTeleport:

; 16140: 	}
; 16141: }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ENDP	; GCTeleportSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 1
?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z PROC	; GCMagicCancelSend, COMDAT

; 15500: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15501: 	PMSG_MAGICCANCEL	pMsg;
; 15502: 
; 15503: 	PHeadSetB((LPBYTE)&pMsg, 0x1B, sizeof( pMsg ));

  00009	6a 06		 push	 6
  0000b	6a 1b		 push	 27			; 0000001bH
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15504: 
; 15505: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD
; 15506: 	pMsg.MagicNumberH = HIBYTE( MagicNumber );
; 15507: 	pMsg.MagicNumberL = LOBYTE( MagicNumber );
; 15508: #else
; 15509: 	pMsg.MagicNumber = MagicNumber;

  00019	8a 45 0c	 mov	 al, BYTE PTR _MagicNumber$[ebp]
  0001c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 15510: #endif
; 15511: 	pMsg.NumberH = HIBYTE(lpObj->m_Index);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	c1 e9 08	 shr	 ecx, 8
  00027	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0002d	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 15512: 	pMsg.NumberL = LOBYTE(lpObj->m_Index);

  00030	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0003b	88 4d fd	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 15513: 	
; 15514: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  0003e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00041	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00045	83 f9 01	 cmp	 ecx, 1
  00048	75 17		 jne	 SHORT $LN2@GCMagicCan

; 15515: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0004a	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0004e	50		 push	 eax
  0004f	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00052	51		 push	 ecx
  00053	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00056	8b 02		 mov	 eax, DWORD PTR [edx]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCMagicCan:

; 15516: 
; 15517: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00061	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00065	50		 push	 eax
  00066	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15518: }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ENDP	; GCMagicCancelSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCDamageSend@@YAXHH@Z
_TEXT	SEGMENT
_pDamage$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_damage$ = 12						; size = 4
?GCDamageSend@@YAXHH@Z PROC				; GCDamageSend, COMDAT

; 14932: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14933: 	if( gObj[aIndex].Type != OBJTYPE_CHARACTER ) return;

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0001b	83 fa 01	 cmp	 edx, 1
  0001e	74 02		 je	 SHORT $LN2@GCDamageSe
  00020	eb 43		 jmp	 SHORT $LN1@GCDamageSe
$LN2@GCDamageSe:

; 14934: 
; 14935: 	PMSG_DAMAGE	pDamage;
; 14936: 	
; 14937: 	PHeadSubSetB((LPBYTE)&pDamage, 0xF3, 0x07, sizeof(pDamage));

  00022	6a 06		 push	 6
  00024	6a 07		 push	 7
  00026	68 f3 00 00 00	 push	 243			; 000000f3H
  0002b	8d 45 f8	 lea	 eax, DWORD PTR _pDamage$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 14938: 
; 14939: 	pDamage.DamageH		= HIBYTE( damage );

  00037	8b 45 0c	 mov	 eax, DWORD PTR _damage$[ebp]
  0003a	c1 e8 08	 shr	 eax, 8
  0003d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00042	88 45 fc	 mov	 BYTE PTR _pDamage$[ebp+4], al

; 14940: 	pDamage.DamageL		= LOBYTE( damage );

  00045	8b 45 0c	 mov	 eax, DWORD PTR _damage$[ebp]
  00048	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004d	88 45 fd	 mov	 BYTE PTR _pDamage$[ebp+5], al

; 14941: #ifdef ADD_SHIELD_POINT_01_20060403
; 14942: 	pDamage.btShieldDamageH = HIBYTE( iShieldDamage );
; 14943: 	pDamage.btShieldDamageL = LOBYTE( iShieldDamage );
; 14944: #endif
; 14945: 	
; 14946: 	DataSend(aIndex, (LPBYTE)&pDamage, pDamage.h.size);

  00050	0f b6 45 f9	 movzx	 eax, BYTE PTR _pDamage$[ebp+1]
  00054	50		 push	 eax
  00055	8d 4d f8	 lea	 ecx, DWORD PTR _pDamage$[ebp]
  00058	51		 push	 ecx
  00059	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCDamageSe:

; 14947: 
; 14948: #ifdef TEST_MSG_MLS_ACTIVE_20080131
; 14949: #if TESTSERVER == 1
; 14950: 	PMSG_NOTICE	pNotice;
; 14951: 	CHAR szNotice[256] = {0,};
; 14952: 	
; 14953: //	TNotice::SetNoticeProperty( &pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED );
; 14954: 	wsprintf( szNotice, "->[%s] : %d(SD:%d)", gObj[aIndex].Name, damage, iShieldDamage );
; 14955: 	TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 14956: 	TNotice::SendNoticeToUser( aIndex, &pNotice );	
; 14957: #endif
; 14958: #endif
; 14959: }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?GCDamageSend@@YAXHH@Z ENDP				; GCDamageSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCDamageSend@@YAXHHHHH@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 8
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
_MSBDamage$ = 24					; size = 4
?GCDamageSend@@YAXHHHHH@Z PROC				; GCDamageSend, COMDAT

; 14861: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14862: 	PMSG_ATTACKRESULT pResult;
; 14863: 
; 14864: 	// [0x15]  /   .
; 14865: #ifdef PACKET_CHANGE	
; 14866: 	PHeadSetB((LPBYTE)&pResult, PACKET_ATTACK, sizeof( pResult ));

  00009	6a 08		 push	 8
  0000b	68 d9 00 00 00	 push	 217			; 000000d9H
  00010	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14867: #else
; 14868: 	PHeadSetB((LPBYTE)&pResult, 0x15, sizeof( pResult ));
; 14869: #endif
; 14870: 	
; 14871: 	pResult.NumberH = HIBYTE(TargetIndex);

  0001c	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0001f	c1 e8 08	 shr	 eax, 8
  00022	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00027	88 45 fb	 mov	 BYTE PTR _pResult$[ebp+3], al

; 14872: 	pResult.NumberL = LOBYTE(TargetIndex);

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0002d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00032	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al

; 14873: 	pResult.DamageH = HIBYTE(AttackDamage);

  00035	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00038	c1 e8 08	 shr	 eax, 8
  0003b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00040	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al

; 14874: 	pResult.DamageL = LOBYTE(AttackDamage);

  00043	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00046	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004b	88 45 fe	 mov	 BYTE PTR _pResult$[ebp+6], al

; 14875: 
; 14876: #ifdef ADD_SHIELD_POINT_01_20060403
; 14877: 	pResult.btShieldDamageH = HIBYTE(iShieldDamage);
; 14878: 	pResult.btShieldDamageL = LOBYTE(iShieldDamage);
; 14879: #endif
; 14880: 
; 14881: 	if( MSBFlag )

  0004e	83 7d 14 00	 cmp	 DWORD PTR _MSBFlag$[ebp], 0
  00052	74 16		 je	 SHORT $LN2@GCDamageSe

; 14882: 	{
; 14883: 		pResult.NumberH &= 0x7F;

  00054	0f b6 45 fb	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  00058	83 e0 7f	 and	 eax, 127		; 0000007fH
  0005b	88 45 fb	 mov	 BYTE PTR _pResult$[ebp+3], al

; 14884: 		pResult.NumberH |= 0x80;

  0005e	0f b6 45 fb	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  00062	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00067	88 45 fb	 mov	 BYTE PTR _pResult$[ebp+3], al
$LN2@GCDamageSe:

; 14885: 		//pResult.NumberH |= MSBFlag;		
; 14886: 	}
; 14887: 
; 14888: #ifdef ADD_SKILL_WITH_COMBO
; 14889: 	pResult.DamageType = MSBDamage; 

  0006a	8a 45 18	 mov	 al, BYTE PTR _MSBDamage$[ebp]
  0006d	88 45 ff	 mov	 BYTE PTR _pResult$[ebp+7], al

; 14890: #else
; 14891: 	if( MSBDamage )
; 14892: 	{	
; 14893: 
; 14894: 		pResult.DamageH &= 0x1F;
; 14895: 		pResult.DamageH |= MSBDamage;
; 14896: 
; 14897: 	}
; 14898: #endif
; 14899: 	
; 14900: 	if( gObj[TargetIndex].Type == OBJTYPE_CHARACTER )

  00070	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _TargetIndex$[ebp], 7072
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007d	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00082	83 fa 01	 cmp	 edx, 1
  00085	75 15		 jne	 SHORT $LN3@GCDamageSe

; 14901: 		DataSend(TargetIndex, (LPBYTE)&pResult, pResult.h.size);

  00087	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0008b	50		 push	 eax
  0008c	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0008f	51		 push	 ecx
  00090	8b 55 0c	 mov	 edx, DWORD PTR _TargetIndex$[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCDamageSe:

; 14902: 
; 14903: 	if( cManager.WatchTargetIndex == TargetIndex || cManager.WatchTargetIndex == aIndex )

  0009c	a1 8c 31 00 00	 mov	 eax, DWORD PTR ?cManager@@3VCGMMng@@A+12684
  000a1	3b 45 0c	 cmp	 eax, DWORD PTR _TargetIndex$[ebp]
  000a4	74 0a		 je	 SHORT $LN5@GCDamageSe
  000a6	a1 8c 31 00 00	 mov	 eax, DWORD PTR ?cManager@@3VCGMMng@@A+12684
  000ab	3b 45 08	 cmp	 eax, DWORD PTR _aIndex$[ebp]
  000ae	75 13		 jne	 SHORT $LN4@GCDamageSe
$LN5@GCDamageSe:

; 14904: 	{	//       
; 14905: 		cManager.DataSend((LPBYTE)&pResult, pResult.h.size);

  000b0	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000b4	50		 push	 eax
  000b5	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000b8	51		 push	 ecx
  000b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  000be	e8 00 00 00 00	 call	 ?DataSend@CGMMng@@QAEXPAEH@Z ; CGMMng::DataSend
$LN4@GCDamageSe:

; 14906: 	}
; 14907: 	
; 14908: 	if( gObj[aIndex].Type == OBJTYPE_CHARACTER )

  000c3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d0	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000d5	83 fa 01	 cmp	 edx, 1
  000d8	75 15		 jne	 SHORT $LN1@GCDamageSe

; 14909: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000da	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000de	50		 push	 eax
  000df	8d 4d f8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000e2	51		 push	 ecx
  000e3	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000e6	52		 push	 edx
  000e7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCDamageSe:

; 14910: 
; 14911: #ifdef TEST_MSG_MLS_ACTIVE_20080131
; 14912: #if TESTSERVER == 1
; 14913: 	PMSG_NOTICE	pNotice;
; 14914: 	CHAR szNotice[256] = {0,};
; 14915: 	
; 14916: 	TNotice::SetNoticeProperty( &pNotice, TNOTICE_TYPE_LEFTTOP, TNOTICE_COLOR_RED );
; 14917: 	wsprintf( szNotice, "[%s]->[%s] : %d(SD:%d)", gObj[aIndex].Name, gObj[TargetIndex].Name, AttackDamage, iShieldDamage );
; 14918: 	TNotice::MakeNoticeMsg( &pNotice, TNOTICE_TYPE_LEFTTOP, szNotice );
; 14919: 	TNotice::SendNoticeToUser( aIndex, &pNotice );
; 14920: 	TNotice::SendNoticeToUser( TargetIndex, &pNotice );
; 14921: #endif
; 14922: #endif
; 14923: }

  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c3		 ret	 0
?GCDamageSend@@YAXHHHHH@Z ENDP				; GCDamageSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCDiePlayerSend@@YAXPAVOBJECTSTRUCT@@HEH@Z
_TEXT	SEGMENT
_iSize$ = -12						; size = 4
_pDieMsg$ = -8						; size = 8
_lpObj$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_skill$ = 16						; size = 1
_KillerIndex$ = 20					; size = 4
?GCDiePlayerSend@@YAXPAVOBJECTSTRUCT@@HEH@Z PROC	; GCDiePlayerSend, COMDAT

; 15029: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15030: 	PMSG_DIEPLAYER  pDieMsg;
; 15031: 
; 15032: 	//      .
; 15033: 	PHeadSetB((LPBYTE)&pDieMsg, 0x17, sizeof( pDieMsg ));

  00009	6a 08		 push	 8
  0000b	6a 17		 push	 23			; 00000017H
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pDieMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15034: 	pDieMsg.NumberH		= HIBYTE( TargetIndex );

  00019	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0001c	c1 e8 08	 shr	 eax, 8
  0001f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00024	88 45 fb	 mov	 BYTE PTR _pDieMsg$[ebp+3], al

; 15035: 	pDieMsg.NumberL		= LOBYTE( TargetIndex );

  00027	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0002a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002f	88 45 fc	 mov	 BYTE PTR _pDieMsg$[ebp+4], al

; 15036: 
; 15037: #ifdef ADD_SKILL_WITH_COMBO
; 15038: 	#ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD
; 15039: 		pDieMsg.MagicNumberH = HIBYTE( skill );
; 15040: 		pDieMsg.MagicNumberL = LOBYTE( skill );
; 15041: 	#else	
; 15042: 		pDieMsg.Skill = skill;	

  00032	8a 45 10	 mov	 al, BYTE PTR _skill$[ebp]
  00035	88 45 fd	 mov	 BYTE PTR _pDieMsg$[ebp+5], al

; 15043: 	#endif
; 15044: 
; 15045: 	pDieMsg.KillerNumberH		= HIBYTE( KillerIndex );

  00038	8b 45 14	 mov	 eax, DWORD PTR _KillerIndex$[ebp]
  0003b	c1 e8 08	 shr	 eax, 8
  0003e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00043	88 45 fe	 mov	 BYTE PTR _pDieMsg$[ebp+6], al

; 15046: 	pDieMsg.KillerNumberL		= LOBYTE( KillerIndex );

  00046	8b 45 14	 mov	 eax, DWORD PTR _KillerIndex$[ebp]
  00049	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004e	88 45 ff	 mov	 BYTE PTR _pDieMsg$[ebp+7], al

; 15047: 
; 15048: 	int iSize = pDieMsg.h.size;

  00051	0f b6 45 f9	 movzx	 eax, BYTE PTR _pDieMsg$[ebp+1]
  00055	89 45 f4	 mov	 DWORD PTR _iSize$[ebp], eax

; 15049: 
; 15050: 	//if( skill != AT_SKILL_EXPHELL &&  skill != AT_SKILL_COMBO )
; 15051: 	//{	//  ,    		
; 15052: 	//	iSize -= 2;
; 15053: 	//}
; 15054: 	MsgSendV2(lpObj, (LPBYTE)&pDieMsg, iSize);

  00058	8b 45 f4	 mov	 eax, DWORD PTR _iSize$[ebp]
  0005b	50		 push	 eax
  0005c	8d 4d f8	 lea	 ecx, DWORD PTR _pDieMsg$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15055: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  0006c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006f	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00073	83 f9 01	 cmp	 ecx, 1
  00076	75 16		 jne	 SHORT $LN1@GCDiePlaye

; 15056: 		DataSend(lpObj->m_Index, (LPBYTE)&pDieMsg, iSize);

  00078	8b 45 f4	 mov	 eax, DWORD PTR _iSize$[ebp]
  0007b	50		 push	 eax
  0007c	8d 4d f8	 lea	 ecx, DWORD PTR _pDieMsg$[ebp]
  0007f	51		 push	 ecx
  00080	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCDiePlaye:

; 15057: #else
; 15058: 	MsgSendV2(lpObj, (LPBYTE)&pDieMsg, pDieMsg.h.size);
; 15059: 	if( lpObj->Type == OBJTYPE_CHARACTER )
; 15060: 		DataSend(lpObj->m_Index, (LPBYTE)&pDieMsg, pDieMsg.h.size);
; 15061: #endif
; 15062: }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?GCDiePlayerSend@@YAXPAVOBJECTSTRUCT@@HEH@Z ENDP	; GCDiePlayerSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCManaSend@@YAXHFEEG@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_aIndex$ = 8						; size = 4
_Mana$ = 12						; size = 2
_Ipos$ = 16						; size = 1
_flag$ = 20						; size = 1
_BP$ = 24						; size = 2
?GCManaSend@@YAXHFEEG@Z PROC				; GCManaSend, COMDAT

; 18461: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18462: 	if( aIndex < 0  || aIndex > MAX_OBJECT-1 ) 

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@GCManaSend
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 1e		 jle	 SHORT $LN2@GCManaSend
$LN3@GCManaSend:

; 18463: 	{
; 18464: 		LogAdd("GCManaSend() return %s %d", __FILE__, __LINE__);

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GCManaSend@@YAXHFEEG@Z@4JA
  0001d	83 c0 03	 add	 eax, 3
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18465: 		return;

  00034	eb 7a		 jmp	 SHORT $LN1@GCManaSend
$LN2@GCManaSend:

; 18466: 	}
; 18467: 	if( gObj[aIndex].Type != OBJTYPE_CHARACTER ) 

  00036	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00043	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00048	83 fa 01	 cmp	 edx, 1
  0004b	74 02		 je	 SHORT $LN4@GCManaSend

; 18468: 	{
; 18469: 		//LogAdd("%s return %s %d", gObj[aIndex].Name, __FILE__, __LINE__);
; 18470: 		return;

  0004d	eb 61		 jmp	 SHORT $LN1@GCManaSend
$LN4@GCManaSend:

; 18471: 	}
; 18472: 
; 18473: 	PMSG_MANASEND	pMsg;
; 18474: 	
; 18475: 	PHeadSetB((LPBYTE)&pMsg, 0x27, sizeof( pMsg ));

  0004f	6a 08		 push	 8
  00051	6a 27		 push	 39			; 00000027H
  00053	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18476: 	pMsg.IPos       = Ipos;

  0005f	8a 45 10	 mov	 al, BYTE PTR _Ipos$[ebp]
  00062	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 18477: 	pMsg.ManaH		= HIBYTE(Mana);

  00065	0f bf 45 0c	 movsx	 eax, WORD PTR _Mana$[ebp]
  00069	c1 e8 08	 shr	 eax, 8
  0006c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00071	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 18478: 	pMsg.ManaL		= LOBYTE(Mana);

  00074	0f bf 45 0c	 movsx	 eax, WORD PTR _Mana$[ebp]
  00078	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007d	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 18479: #ifdef NEW_FORSKYLAND2
; 18480: 	pMsg.BPH		= HIBYTE(BP);

  00080	0f b7 45 18	 movzx	 eax, WORD PTR _BP$[ebp]
  00084	c1 e8 08	 shr	 eax, 8
  00087	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0008c	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 18481: 	pMsg.BPL		= LOBYTE(BP);

  0008f	0f b7 45 18	 movzx	 eax, WORD PTR _BP$[ebp]
  00093	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00098	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+7], al

; 18482: #endif
; 18483: 
; 18484: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0009b	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0009f	50		 push	 eax
  000a0	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000a3	51		 push	 ecx
  000a4	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCManaSend:

; 18485: }	

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
?GCManaSend@@YAXHFEEG@Z ENDP				; GCManaSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCLevelUpMsgSend@@YAXHGGGGGFF@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Level$ = 12						; size = 2
_LevelUpPoint$ = 16					; size = 2
_MaxLife$ = 20						; size = 2
_MaxMana$ = 24						; size = 2
_MaxBP$ = 28						; size = 2
_AddPoint$ = 32						; size = 2
_MaxAddPoint$ = 36					; size = 2
?GCLevelUpMsgSend@@YAXHGGGGGFF@Z PROC			; GCLevelUpMsgSend, COMDAT

; 3810 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3811 : 		PMSG_LEVELUP pMsg;
; 3812 : 		
; 3813 : 		PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x05, sizeof( pMsg ) );

  00013	6a 12		 push	 18			; 00000012H
  00015	6a 05		 push	 5
  00017	68 f3 00 00 00	 push	 243			; 000000f3H
  0001c	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 3814 : 		pMsg.Level			= Level;

  00028	66 8b 45 0c	 mov	 ax, WORD PTR _Level$[ebp]
  0002c	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 3815 : 		pMsg.LevelUpPoint	= LevelUpPoint;

  00030	66 8b 45 10	 mov	 ax, WORD PTR _LevelUpPoint$[ebp]
  00034	66 89 45 ee	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 3816 : 		pMsg.MaxLife        = MaxLife;

  00038	66 8b 45 14	 mov	 ax, WORD PTR _MaxLife$[ebp]
  0003c	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+8], ax

; 3817 : 		pMsg.MaxMana        = MaxMana;

  00040	66 8b 45 18	 mov	 ax, WORD PTR _MaxMana$[ebp]
  00044	66 89 45 f2	 mov	 WORD PTR _pMsg$[ebp+10], ax

; 3818 : 		pMsg.MaxBP			= MaxBP;

  00048	66 8b 45 1c	 mov	 ax, WORD PTR _MaxBP$[ebp]
  0004c	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+12], ax

; 3819 : 		pMsg.AddPoint		= AddPoint;

  00050	66 8b 45 20	 mov	 ax, WORD PTR _AddPoint$[ebp]
  00054	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 3820 : 		pMsg.MaxAddPoint	= MaxAddPoint;

  00058	66 8b 45 24	 mov	 ax, WORD PTR _MaxAddPoint$[ebp]
  0005c	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+16], ax

; 3821 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00060	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00064	50		 push	 eax
  00065	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00068	51		 push	 ecx
  00069	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3822 : 
; 3823 : 	#ifdef ADD_EFFECT_LEVELUP_20040401
; 3824 : 		GCSendEffectInfo( aIndex, EFFECT_LEVELUP );

  00075	6a 10		 push	 16			; 00000010H
  00077	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo
  00080	83 c4 08	 add	 esp, 8

; 3825 : 	#endif
; 3826 : 	}

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?GCLevelUpMsgSend@@YAXHGGGGGFF@Z ENDP			; GCLevelUpMsgSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z
_TEXT	SEGMENT
_dwTick$1 = -24						; size = 4
_attackret$ = -20					; size = 4
_lpMagic$ = -16						; size = 4
_usernumber$ = -12					; size = 4
_lpTargetObj$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z PROC	; CGMagicAttack, COMDAT

; 15174: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15175: 	LPOBJECTSTRUCT	lpObj;
; 15176: 	LPOBJECTSTRUCT	lpTargetObj;
; 15177: 	int				usernumber;
; 15178: 	CMagicInf *		lpMagic;	
; 15179: 	
; 15180: 	usernumber = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);	

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00010	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00016	0f b6 d1	 movzx	 edx, cl
  00019	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00020	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00026	0f b6 c1	 movzx	 eax, cl
  00029	c1 e0 08	 shl	 eax, 8
  0002c	0b d0		 or	 edx, eax
  0002e	0f b7 ca	 movzx	 ecx, dx
  00031	89 4d f4	 mov	 DWORD PTR _usernumber$[ebp], ecx

; 15181: 
; 15182: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD
; 15183: 	WORD wMagicNumber = MAKEWORD( lpMsg->MagicNumberL, lpMsg->MagicNumberH );
; 15184: #endif
; 15185: 		
; 15186: 	//   
; 15187: 	if(usernumber< 0 || (usernumber > (MAX_OBJECT-1))) 

  00034	83 7d f4 00	 cmp	 DWORD PTR _usernumber$[ebp], 0
  00038	7c 09		 jl	 SHORT $LN3@CGMagicAtt
  0003a	81 7d f4 e7 1c
	00 00		 cmp	 DWORD PTR _usernumber$[ebp], 7399 ; 00001ce7H
  00041	7e 26		 jle	 SHORT $LN2@CGMagicAtt
$LN3@CGMagicAtt:

; 15188: 	{
; 15189: 		LogAdd("error :%s %d %d", __FILE__, __LINE__, usernumber);

  00043	8b 45 f4	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00046	50		 push	 eax
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z@4JA
  0004d	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00050	51		 push	 ecx
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00061	83 c4 10	 add	 esp, 16			; 00000010H

; 15190: 		return;

  00064	e9 a3 02 00 00	 jmp	 $LN1@CGMagicAtt
$LN2@CGMagicAtt:

; 15191: 	}
; 15192: 	
; 15193: 	//    
; 15194: 	if( (!gObj[usernumber].Live) || (gObj[usernumber].Connected < 2) )

  00069	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _usernumber$[ebp], 7072
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00076	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  0007b	85 d2		 test	 edx, edx
  0007d	74 14		 je	 SHORT $LN5@CGMagicAtt
  0007f	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _usernumber$[ebp], 7072
  00086	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008c	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00091	7d 05		 jge	 SHORT $LN4@CGMagicAtt
$LN5@CGMagicAtt:

; 15195: 		return;	

  00093	e9 74 02 00 00	 jmp	 $LN1@CGMagicAtt
$LN4@CGMagicAtt:

; 15196: 
; 15197: 	if( gObj[aIndex].CloseCount >= 0 ) return;

  00098	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a5	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  000aa	85 d2		 test	 edx, edx
  000ac	7c 05		 jl	 SHORT $LN6@CGMagicAtt
  000ae	e9 59 02 00 00	 jmp	 $LN1@CGMagicAtt
$LN6@CGMagicAtt:

; 15198: 	
; 15199: #ifdef MODIFY_SAFEZONE_CHECK_ATTACK_20080903
; 15200: 	BYTE attr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);
; 15201: 	
; 15202: 	if( ((attr&MAP_ATTR_SAFTYZONE) == MAP_ATTR_SAFTYZONE) )		//    .
; 15203: 	{
; 15204: 		if( wMagicNumber == AT_SKILL_EXPHELL_START )
; 15205: 		{
; 15206: 			GCMagicAttackNumberSend( &gObj[aIndex], AT_SKILL_EXPHELL, aIndex, 1 );				
; 15207: 			gObjSetPosition( aIndex, gObj[aIndex].X, gObj[aIndex].Y );
; 15208: 			
; 15209: 			return;
; 15210: 		}
; 15211: 	}
; 15212: #endif // MODIFY_SAFEZONE_CHECK_ATTACK_20080903
; 15213: 
; 15214: 	lpObj = &gObj[aIndex];

  000b3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ba	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c0	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 15215: 	lpTargetObj = &gObj[usernumber];

  000c3	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _usernumber$[ebp], 7072
  000ca	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d0	89 45 f8	 mov	 DWORD PTR _lpTargetObj$[ebp], eax

; 15216: 
; 15217: 	//    	
; 15218: 	int attackret = gObjCheckAttackArea(aIndex, usernumber);

  000d3	8b 45 f4	 mov	 eax, DWORD PTR _usernumber$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 ?gObjCheckAttackArea@@YAHHH@Z ; gObjCheckAttackArea
  000e0	83 c4 08	 add	 esp, 8
  000e3	89 45 ec	 mov	 DWORD PTR _attackret$[ebp], eax

; 15219: 	if( attackret )

  000e6	83 7d ec 00	 cmp	 DWORD PTR _attackret$[ebp], 0
  000ea	74 7f		 je	 SHORT $LN7@CGMagicAtt

; 15220: 	{
; 15221: #ifdef CHECK_ATTACK_AREA
; 15222: 		lpObj->m_NotAttackAreaCount++;
; 15223: 
; 15224: 	#ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 15225: 		lpObj->m_NotAttackAreaCountFor10Min++;
; 15226: 	#endif
; 15227: 
; 15228: 	#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 15229: 		ChinaHackUserKick.InsertCataNCount(lpObj->m_Index);
; 15230: 	#endif
; 15231: 
; 15232: 		if( gIsKickNotAttackAreaCountLimit )
; 15233: 		{
; 15234: 	#ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 15235: 			if( lpObj->m_NotAttackAreaCountFor10Min >= gNotAttackAreaKickCount )
; 15236: 			{
; 15237: 		#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 15238: 				ChinaHackLogFile.Output("[%s][%s] Kick NotAttackAreaKickCount Over User (%d) @%d", 
; 15239: 										lpObj->AccountID,
; 15240: 										lpObj->Name,
; 15241: 										lpObj->m_NotAttackAreaCount,
; 15242: 										lpObj->MapNumber);
; 15243: 		#else
; 15244: 					LogAddTD("[%s][%s] Kick NotAttackAreaKickCount Over User (%d, %d) @%d", 
; 15245: 							 lpObj->AccountID, 
; 15246: 							 lpObj->Name, 
; 15247: 							 lpObj->m_NotAttackAreaCountFor10Min, 
; 15248: 							 lpObj->m_NotAttackAreaCount,
; 15249: 							 lpObj->MapNumber);
; 15250: 		#endif
; 15251: 				CloseClient(lpObj->m_Index);					
; 15252: 				return;			
; 15253: 			}
; 15254: 	#else // else MODIFY_HACKLOG_OF_ATTACK_20050518
; 15255: 			//       
; 15256: 			if( lpObj->m_NotAttackAreaCount >= gNotAttackAreaKickCount )
; 15257: 			{
; 15258: 		#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 15259: 				ChinaHackLogFile.Output("[%s][%s] Kick NotAttackAreaKickCount Over User (%d)", 
; 15260: 										lpObj->AccountID, lpObj->Name, lpObj->m_NotAttackAreaCount);
; 15261: 		#else
; 15262: 				LogAddTD("[%s][%s] Kick NotAttackAreaKickCount Over User (%d)", 
; 15263: 						  lpObj->AccountID, lpObj->Name, lpObj->m_NotAttackAreaCount);
; 15264: 		#endif
; 15265: 				CloseClient(lpObj->m_Index);					
; 15266: 				return;
; 15267: 			}
; 15268: 	#endif // MODIFY_HACKLOG_OF_ATTACK_20050518
; 15269: 		}
; 15270: #else // else CHECK_ATTACK_AREA
; 15271: 		LogAddTD("[%s][%s] Try Attack In Not Attack Area [Protocol] (%s:%d,%d) errortype = %d", 

  000ec	8b 45 ec	 mov	 eax, DWORD PTR _attackret$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f3	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  000fa	52		 push	 edx
  000fb	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fe	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00105	51		 push	 ecx
  00106	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00109	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00110	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00115	50		 push	 eax
  00116	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00121	50		 push	 eax
  00122	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00125	83 c1 73	 add	 ecx, 115		; 00000073H
  00128	51		 push	 ecx
  00129	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0012c	83 c2 68	 add	 edx, 104		; 00000068H
  0012f	52		 push	 edx
  00130	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Atta@
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0013b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 15272: 				lpObj->AccountID, lpObj->Name, lMsg.Get(lpObj->MapNumber+2000), lpObj->X, lpObj->Y, attackret);
; 15273: 
; 15274: 		#ifdef MODIFY_KUNDUN_VIEWPORT_20060523
; 15275: 		//      TargetNumber   .
; 15276: 		if ( lpObj->Class == 275 )

  0013e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00141	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00148	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  0014e	75 0d		 jne	 SHORT $LN8@CGMagicAtt

; 15277: 		{
; 15278: 			lpObj->TargetNumber = -1;

  00150	83 c8 ff	 or	 eax, -1
  00153	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00156	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax
$LN8@CGMagicAtt:

; 15279: 		}
; 15280: 		#endif // MODIFY_KUNDUN_VIEWPORT_20060523
; 15281: 
; 15282: #endif // CHECK_ATTACK_AREA
; 15283: 		if( bIsIgnorePacketSpeedHackDetect )

  0015d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  00164	74 05		 je	 SHORT $LN7@CGMagicAtt

; 15284: 		{
; 15285: 			return;

  00166	e9 a1 01 00 00	 jmp	 $LN1@CGMagicAtt
$LN7@CGMagicAtt:

; 15286: 		}
; 15287: 	}
; 15288: 	
; 15289: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  0016b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016e	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00172	83 f9 01	 cmp	 ecx, 1
  00175	75 69		 jne	 SHORT $LN10@CGMagicAtt

; 15290: 	{	
; 15291: 		
; 15292: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD 
; 15293: 		if( wMagicNumber == AT_SKILL_EXPHELL_START )
; 15294: 		{
; 15295: 			usernumber = AT_SKILL_EXPHELL_START;
; 15296: 		}
; 15297: 		lpMagic = gObjGetMagicSearch( lpObj, wMagicNumber );
; 15298: #else
; 15299: #ifdef CHANGE_MAGICATTACKPACKET		//      
; 15300: 		if( lpMsg->MagicNumber == AT_SKILL_EXPHELL_START )

  00177	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0017a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0017e	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00181	75 07		 jne	 SHORT $LN12@CGMagicAtt

; 15301: 		{
; 15302: 			usernumber = AT_SKILL_EXPHELL_START;

  00183	c7 45 f4 3a 00
	00 00		 mov	 DWORD PTR _usernumber$[ebp], 58 ; 0000003aH
$LN12@CGMagicAtt:

; 15303: 		}
; 15304: 		lpMagic = gObjGetMagicSearch(lpObj, lpMsg->MagicNumber);

  0018a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0018d	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00191	51		 push	 ecx
  00192	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00195	52		 push	 edx
  00196	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  0019b	83 c4 08	 add	 esp, 8
  0019e	89 45 f0	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 15305: #else
; 15306: 		lpMagic = gObjGetMagic(lpObj, lpMsg->MagicNumber);
; 15307: #endif
; 15308: #endif	// ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107
; 15309: 
; 15310: #ifdef MODIFY_SKILL_ICEARROW_AND_ADD_DEXTERITY_BUGFIX_20080820
; 15311: 		// 2008/08/20    - riverstyx
; 15312: 		{
; 15313: 			short nEnergy = lpObj->Energy + lpObj->AddEnergy;
; 15314: 			short nStrength = lpObj->Strength + lpObj->AddStrength;
; 15315: 			short nDexterity = lpObj->Dexterity + lpObj->AddDexterity;
; 15316: 			switch (wMagicNumber )
; 15317: 			{
; 15318: 			case AT_SKILL_ELFHARDEN:
; 15319: 				{
; 15320: 					//  
; 15321: 					if (nDexterity < 646) return;
; 15322: 				} break;
; 15323: 			default:
; 15324: 				break;
; 15325: 			}
; 15326: 		}
; 15327: #endif // MODIFY_SKILL_ICEARROW_AND_ADD_DEXTERITY_BUGFIX_20080820
; 15328: 		
; 15329: 		if( lpMagic == NULL )

  001a1	83 7d f0 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  001a5	75 05		 jne	 SHORT $LN13@CGMagicAtt

; 15330: 		{
; 15331: 			return;

  001a7	e9 60 01 00 00	 jmp	 $LN1@CGMagicAtt
$LN13@CGMagicAtt:

; 15332: 		}
; 15333: #ifdef ADD_NEWPVP_PKFIELD
; 15334: 		if (lpMagic->m_Skill == AT_SKILL_RECALL_PARTY 
; 15335: 			&& (g_NewPVP.IsDuel(*lpObj) || g_NewPVP.IsDuel(*lpTargetObj)) )
; 15336: 		{
; 15337: 			return;
; 15338: 		}
; 15339: #endif // ADD_NEWPVP_PKFIELD
; 15340: 
; 15341: #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// SkillGetRequireClass(...) 3 
; 15342: 		if( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, lpObj->ThirdChangeUp, lpMagic->m_Skill) < 1 ) return;
; 15343: #else
; 15344: #ifdef NEW_SKILL_FORSKYLAND
; 15345: 		if( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, lpMagic->m_Skill) < 1 ) return;

  001ac	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001af	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  001b3	51		 push	 ecx
  001b4	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001b7	0f b6 82 9f 00
	00 00		 movzx	 eax, BYTE PTR [edx+159]
  001be	50		 push	 eax
  001bf	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c2	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  001c9	52		 push	 edx
  001ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  001cf	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z ; CMagicDamage::SkillGetRequireClass
  001d4	83 f8 01	 cmp	 eax, 1
  001d7	7d 05		 jge	 SHORT $LN14@CGMagicAtt
  001d9	e9 2e 01 00 00	 jmp	 $LN1@CGMagicAtt
$LN14@CGMagicAtt:

; 15346: #else
; 15347: 		if( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpMagic->m_Skill) < 0 ) return;
; 15348: #endif
; 15349: #endif	// MASTER_LEVEL_SKILL_SYSTEM_20071122
; 15350: 
; 15351: #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 15352: 		//     . 
; 15353: 		if( MagicDamageC.CheckStatus( lpMagic->m_Skill, lpObj->GuildStatus ) == FALSE ) 
; 15354: 		{
; 15355: 			LogAddC( LOGC_RED, "[0x19] CGMagicAttack() - Invalid Status" );
; 15356: 			return;
; 15357: 		}
; 15358: 
; 15359: 		//  
; 15360: 		if( MagicDamageC.CheckKillCount( lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )
; 15361: 		{
; 15362: 			LogAddC( LOGC_RED, "[0x19] CGMagicAttack() - Invalid KillCount" );
; 15363: 			return;
; 15364: 		}
; 15365: #endif
; 15366: 
; 15367: 	}

  001de	eb 22		 jmp	 SHORT $LN11@CGMagicAtt
$LN10@CGMagicAtt:

; 15368: 	else 
; 15369: 	{
; 15370: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD 
; 15371: 		lpMagic = gObjGetMagic( lpObj, wMagicNumber );
; 15372: #else
; 15373: 		lpMagic = gObjGetMagic(lpObj, lpMsg->MagicNumber);

  001e0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001e3	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  001e7	51		 push	 ecx
  001e8	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z ; gObjGetMagic
  001f1	83 c4 08	 add	 esp, 8
  001f4	89 45 f0	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 15374: #endif
; 15375: 		if( lpMagic == NULL )

  001f7	83 7d f0 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  001fb	75 05		 jne	 SHORT $LN11@CGMagicAtt

; 15376: 		{
; 15377: 			return;

  001fd	e9 0a 01 00 00	 jmp	 $LN1@CGMagicAtt
$LN11@CGMagicAtt:

; 15378: 		}
; 15379: 	}
; 15380: 
; 15381: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//     
; 15382: 	if( lpMagic->m_Skill != AT_SKILL_CROSSBOW && lpMagic->m_Skill != AT_SKILL_ML_STRENGTHEN_CROSSBOW )
; 15383: #else
; 15384: 	if( lpMagic->m_Skill != AT_SKILL_CROSSBOW )

  00202	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00205	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00209	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0020c	74 17		 je	 SHORT $LN16@CGMagicAtt

; 15385: #endif
; 15386: 	{	//  
; 15387: 		if( !gObjUseSkill.SpeedHackCheck(aIndex) )

  0020e	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00211	50		 push	 eax
  00212	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00217	e8 00 00 00 00	 call	 ?SpeedHackCheck@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SpeedHackCheck
  0021c	85 c0		 test	 eax, eax
  0021e	75 05		 jne	 SHORT $LN16@CGMagicAtt

; 15388: 			return;

  00220	e9 e7 00 00 00	 jmp	 $LN1@CGMagicAtt
$LN16@CGMagicAtt:

; 15389: 	}
; 15390: 
; 15391: 	//    
; 15392: #ifdef MODIFY_SKILL_CHECK_DISTANCE_20060413
; 15393: 	if ( gCheckSkillDistance(aIndex, usernumber, lpMagic->m_Skill) == FALSE )

  00225	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00228	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0022c	51		 push	 ecx
  0022d	8b 55 f4	 mov	 edx, DWORD PTR _usernumber$[ebp]
  00230	52		 push	 edx
  00231	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  0023a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023d	85 c0		 test	 eax, eax
  0023f	0f 85 b1 00 00
	00		 jne	 $LN18@CGMagicAtt

; 15394: 	{
; 15395: 		//  &   
; 15396: 	#ifdef MODIFY_SKILL_CHECK_DISTANCE_UPDATE_20060417
; 15397: 		#ifdef MODIFY_SKILL_CHECK_DISTANCE_UPDATE_02_20060421
; 15398: 			DWORD dwTick = GetTickCount() - lpObj->m_dwSkillDistanceErrorTick;

  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0024b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0024e	2b 81 3c 1a 00
	00		 sub	 eax, DWORD PTR [ecx+6716]
  00254	89 45 e8	 mov	 DWORD PTR _dwTick$1[ebp], eax

; 15399: 			if (  dwTick > g_iSkillDiatanceKickCheckTime * 1000 )

  00257	69 05 00 00 00
	00 e8 03 00 00	 imul	 eax, DWORD PTR ?g_iSkillDiatanceKickCheckTime@@3HA, 1000 ; g_iSkillDiatanceKickCheckTime
  00261	39 45 e8	 cmp	 DWORD PTR _dwTick$1[ebp], eax
  00264	76 1c		 jbe	 SHORT $LN19@CGMagicAtt

; 15400: 			{
; 15401: 				lpObj->m_iSkillDistanceErrorCount = 0;

  00266	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00269	c7 80 38 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6712], 0

; 15402: 				lpObj->m_dwSkillDistanceErrorTick = GetTickCount();

  00273	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00279	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0027c	89 81 3c 1a 00
	00		 mov	 DWORD PTR [ecx+6716], eax
$LN19@CGMagicAtt:

; 15403: 			}
; 15404: 		#endif
; 15405: 		++lpObj->m_iSkillDistanceErrorCount;

  00282	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00285	8b 88 38 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6712]
  0028b	83 c1 01	 add	 ecx, 1
  0028e	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00291	89 8a 38 1a 00
	00		 mov	 DWORD PTR [edx+6712], ecx

; 15406: 		if ( lpObj->m_iSkillDistanceErrorCount > g_iSkillDistanceKickCount )

  00297	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029a	8b 88 38 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6712]
  002a0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?g_iSkillDistanceKickCount@@3HA ; g_iSkillDistanceKickCount
  002a6	7e 4c		 jle	 SHORT $LN20@CGMagicAtt

; 15407: 		{
; 15408: 			//   .     0   
; 15409: 			if ( g_iSkillDistanceKick != 0 )

  002a8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iSkillDistanceKick@@3HA, 0 ; g_iSkillDistanceKick
  002af	74 36		 je	 SHORT $LN21@CGMagicAtt

; 15410: 			{
; 15411: 				LogAddTD("[SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. count(%d)", 

  002b1	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b4	8b 88 38 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6712]
  002ba	51		 push	 ecx
  002bb	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002be	83 c2 73	 add	 edx, 115		; 00000073H
  002c1	52		 push	 edx
  002c2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c5	83 c0 68	 add	 eax, 104		; 00000068H
  002c8	50		 push	 eax
  002c9	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  002ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002d4	83 c4 10	 add	 esp, 16			; 00000010H

; 15412: 						  lpObj->AccountID, lpObj->Name, lpObj->m_iSkillDistanceErrorCount);
; 15413: 				CloseClient(lpObj->m_Index);

  002d7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002da	8b 08		 mov	 ecx, DWORD PTR [eax]
  002dc	51		 push	 ecx
  002dd	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002e2	83 c4 04	 add	 esp, 4

; 15414: 				return;

  002e5	eb 25		 jmp	 SHORT $LN1@CGMagicAtt
$LN21@CGMagicAtt:

; 15415: 			}
; 15416: 			//      count  
; 15417: 			lpObj->m_iSkillDistanceErrorCount = 0;

  002e7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ea	c7 80 38 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6712], 0
$LN20@CGMagicAtt:

; 15418: 		}
; 15419: 	#endif
; 15420: 		return;

  002f4	eb 16		 jmp	 SHORT $LN1@CGMagicAtt
$LN18@CGMagicAtt:

; 15421: 	}
; 15422: #endif
; 15423: 	
; 15424: 	gObjUseSkill.UseSkill(aIndex, usernumber, lpMagic);	

  002f6	8b 45 f0	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  002f9	50		 push	 eax
  002fa	8b 4d f4	 mov	 ecx, DWORD PTR _usernumber$[ebp]
  002fd	51		 push	 ecx
  002fe	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00301	52		 push	 edx
  00302	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00307	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
$LN1@CGMagicAtt:

; 15425: }

  0030c	5f		 pop	 edi
  0030d	5e		 pop	 esi
  0030e	5b		 pop	 ebx
  0030f	8b e5		 mov	 esp, ebp
  00311	5d		 pop	 ebp
  00312	c3		 ret	 0
?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ENDP	; CGMagicAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z
_TEXT	SEGMENT
_iTimeCalc$ = -16					; size = 4
_usernumber$ = -12					; size = 4
_lpTargetObj$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z PROC			; CGAttack, COMDAT

; 14653: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14654: 	LPOBJECTSTRUCT lpObj, lpTargetObj;
; 14655: 	//BYTE Dis;
; 14656: 
; 14657: 	int usernumber;
; 14658: 	usernumber = MAKEWORD(lpMsg->NumberL,lpMsg->NumberH);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0000c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00010	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00016	0f b6 d1	 movzx	 edx, cl
  00019	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00020	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00026	0f b6 c1	 movzx	 eax, cl
  00029	c1 e0 08	 shl	 eax, 8
  0002c	0b d0		 or	 edx, eax
  0002e	0f b7 ca	 movzx	 ecx, dx
  00031	89 4d f4	 mov	 DWORD PTR _usernumber$[ebp], ecx

; 14659: 
; 14660: 	if(usernumber< 0 || (usernumber > (MAX_OBJECT-1))) 

  00034	83 7d f4 00	 cmp	 DWORD PTR _usernumber$[ebp], 0
  00038	7c 09		 jl	 SHORT $LN3@CGAttack
  0003a	81 7d f4 e7 1c
	00 00		 cmp	 DWORD PTR _usernumber$[ebp], 7399 ; 00001ce7H
  00041	7e 26		 jle	 SHORT $LN2@CGAttack
$LN3@CGAttack:

; 14661: 	{
; 14662: 		LogAdd("[CGAttack] [UserIndex Error] :%s %d %d", __FILE__, __LINE__, usernumber);

  00043	8b 45 f4	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00046	50		 push	 eax
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??CGAttack@@YAXPAUPMSG_ATTACK@@H@Z@4JA
  0004d	83 c1 09	 add	 ecx, 9
  00050	51		 push	 ecx
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CF@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00061	83 c4 10	 add	 esp, 16			; 00000010H

; 14663: 		return;

  00064	e9 94 02 00 00	 jmp	 $LN1@CGAttack
$LN2@CGAttack:

; 14664: 	}
; 14665: 
; 14666: 	if( !gObj[usernumber].Live ) 

  00069	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _usernumber$[ebp], 7072
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00076	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  0007b	85 d2		 test	 edx, edx
  0007d	75 05		 jne	 SHORT $LN4@CGAttack

; 14667: 	{	//  
; 14668: 		return;

  0007f	e9 79 02 00 00	 jmp	 $LN1@CGAttack
$LN4@CGAttack:

; 14669: 	}
; 14670: 	
; 14671: 	lpObj = &gObj[aIndex];

  00084	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00091	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 14672: 
; 14673: #ifdef ADD_ANTI_HACK_01_20051027
; 14674: 	//   
; 14675: 	DWORD dwCurruntTime = GetTickCount();
; 14676: 	if(  dwCurruntTime - lpObj->m_dwLastPacketAttackTime < 200 ) 
; 14677: 	{
; 14678: 		LogAddTD("[Anti-Hack][CGATTACK][PacketTime Error] :(%s)(%s) T:%d", lpObj->AccountID, lpObj->Name, dwCurruntTime - lpObj->m_dwLastPacketAttackTime );
; 14679: 		return;
; 14680: 	}
; 14681: 	else
; 14682: 	{
; 14683: 		lpObj->m_dwLastPacketAttackTime = dwCurruntTime;
; 14684: 	}
; 14685: 
; 14686: 	//   ! 3   !
; 14687: 	INT	iDistance = gObjCalDistance(&gObj[aIndex], &gObj[usernumber]);
; 14688: 	if( iDistance > 3 )
; 14689: 	{
; 14690: 		LogAddTD("[Anti-Hack][CGATTACK][Distance Error] :(%s)(%s) D:%d", lpObj->AccountID, lpObj->Name, iDistance );
; 14691: 		return;
; 14692: 	}
; 14693: #endif
; 14694: 
; 14695: 	int iTimeCalc = GetTickCount()-lpObj->m_LastAttackTime;

  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009d	2b 81 c8 01 00
	00		 sub	 eax, DWORD PTR [ecx+456]
  000a3	89 45 f0	 mov	 DWORD PTR _iTimeCalc$[ebp], eax

; 14696: 
; 14697: /*	K2    .
; 14698: #ifdef FOR_CHINA
; 14699: 	if( iTimeCalc < lpObj->m_DetectSpeedHackTime )
; 14700: #else
; 14701: 	#ifdef FOR_THAILAND		
; 14702: 		if( iTimeCalc < lpObj->m_DetectSpeedHackTime ) 	
; 14703: 	#else
; 14704: 		if( iTimeCalc < lpObj->m_DetectSpeedHackTime && iTimeCalc != 0 && lpObj->HaveWeaponInHand ) 
; 14705: 	#endif
; 14706: #endif
; 14707: */
; 14708: 	if( iTimeCalc < lpObj->m_DetectSpeedHackTime )

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _iTimeCalc$[ebp]
  000ac	3b 88 d0 01 00
	00		 cmp	 ecx, DWORD PTR [eax+464]
  000b2	0f 8d 43 01 00
	00		 jge	 $LN5@CGAttack

; 14709: 	{	//        
; 14710: 		lpObj->m_DetectCount++;

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bb	8b 88 d8 01 00
	00		 mov	 ecx, DWORD PTR [eax+472]
  000c1	83 c1 01	 add	 ecx, 1
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c7	89 8a d8 01 00
	00		 mov	 DWORD PTR [edx+472], ecx

; 14711: 
; 14712: 		lpObj->m_SumLastAttackTime += iTimeCalc;

  000cd	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d0	8b 88 d4 01 00
	00		 mov	 ecx, DWORD PTR [eax+468]
  000d6	03 4d f0	 add	 ecx, DWORD PTR _iTimeCalc$[ebp]
  000d9	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000dc	89 8a d4 01 00
	00		 mov	 DWORD PTR [edx+468], ecx

; 14713: 
; 14714: 		if( lpObj->m_DetectCount > gHackCheckCount )

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e5	8b 88 d8 01 00
	00		 mov	 ecx, DWORD PTR [eax+472]
  000eb	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gHackCheckCount@@3KA ; gHackCheckCount
  000f1	0f 86 f3 00 00
	00		 jbe	 $LN7@CGAttack

; 14715: 		{
; 14716: 			lpObj->m_DetectedHackKickCount++;

  000f7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fa	8b 88 dc 01 00
	00		 mov	 ecx, DWORD PTR [eax+476]
  00100	83 c1 01	 add	 ecx, 1
  00103	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00106	89 8a dc 01 00
	00		 mov	 DWORD PTR [edx+476], ecx

; 14717: 			lpObj->m_SpeedHackPenalty = gSpeedHackPenalty;

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gSpeedHackPenalty@@3HA ; gSpeedHackPenalty
  00115	89 88 e0 01 00
	00		 mov	 DWORD PTR [eax+480], ecx

; 14718: 
; 14719: 			if( gIsKickDetecHackCountLimit ) 

  0011b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsKickDetecHackCountLimit@@3HA, 0 ; gIsKickDetecHackCountLimit
  00122	74 64		 je	 SHORT $LN8@CGAttack

; 14720: 			{
; 14721: 				if( lpObj->m_DetectedHackKickCount > gDetectedHackKickCount )

  00124	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00127	8b 88 dc 01 00
	00		 mov	 ecx, DWORD PTR [eax+476]
  0012d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gDetectedHackKickCount@@3HA ; gDetectedHackKickCount
  00133	7e 53		 jle	 SHORT $LN8@CGAttack

; 14722: 				{
; 14723: #ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 14724: 	#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 14725: 					ChinaHackLogFile.Output("[%s][%s] %s Kick DetecHackCountLimit Over User (%d) @%d",
; 14726: 									 lpObj->AccountID, 
; 14727: 									 lpObj->Name, 
; 14728: 									 lMsg.Get(1900+lpObj->Class),
; 14729: 									 lpObj->m_DetectedHackKickCount,
; 14730: 									 lpObj->MapNumber);
; 14731: 	#else
; 14732: 					LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d) @%d",
; 14733: 							 lpObj->AccountID, 
; 14734: 							 lpObj->Name, 
; 14735: 							 lMsg.Get(1900+lpObj->Class),
; 14736: 							 lpObj->m_DetectedHackKickCount,
; 14737: 							 lpObj->MapNumber);
; 14738: 	#endif
; 14739: #else
; 14740: 	#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 14741: 					ChinaHackLogFile.Output("[%s][%s] %s Kick DetecHackCountLimit Over User (%d)",
; 14742: 									 lpObj->AccountID, 
; 14743: 									 lpObj->Name, 
; 14744: 									 lMsg.Get(1900+lpObj->Class),
; 14745: 									 lpObj->m_DetectedHackKickCount);
; 14746: 	#else
; 14747: 					LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d)",

  00135	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00138	8b 88 dc 01 00
	00		 mov	 ecx, DWORD PTR [eax+476]
  0013e	51		 push	 ecx
  0013f	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00142	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  00149	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  0014e	50		 push	 eax
  0014f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0015a	50		 push	 eax
  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0015e	83 c1 73	 add	 ecx, 115		; 00000073H
  00161	51		 push	 ecx
  00162	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00165	83 c2 68	 add	 edx, 104		; 00000068H
  00168	52		 push	 edx
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCount@
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00174	83 c4 14	 add	 esp, 20			; 00000014H

; 14748: 							 lpObj->AccountID, 
; 14749: 							 lpObj->Name, 
; 14750: 							 lMsg.Get(1900+lpObj->Class),
; 14751: 							 lpObj->m_DetectedHackKickCount);
; 14752: 	#endif
; 14753: #endif
; 14754: 
; 14755: 					CloseClient(aIndex);

  00177	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00180	83 c4 04	 add	 esp, 4

; 14756: 					return;

  00183	e9 75 01 00 00	 jmp	 $LN1@CGAttack
$LN8@CGAttack:

; 14757: 				}
; 14758: 			}
; 14759: 			
; 14760: #ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 14761: 	#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 14762: 			ChinaHackLogFile.Output("[%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d @%d", 
; 14763: 									 lpObj->AccountID, 
; 14764: 									 lpObj->Name, 
; 14765: 									 lMsg.Get(1900+lpObj->Class),
; 14766: 									 lpObj->m_DetectSpeedHackTime,
; 14767: 									 lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 14768: 									 lpObj->m_SpeedHackPenalty,
; 14769: 									 lpObj->MapNumber);
; 14770: 			ChinaHackUserKick.InsertSpeedNCount(lpObj->m_Index);
; 14771: 	#else
; 14772: 			LogAddTD("[%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d @%d", 
; 14773: 						 lpObj->AccountID, 
; 14774: 						 lpObj->Name, 
; 14775: 						 lMsg.Get(1900+lpObj->Class),
; 14776: 						 lpObj->m_DetectSpeedHackTime,
; 14777: 						 lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 14778: 						 lpObj->m_SpeedHackPenalty,
; 14779: 						 lpObj->MapNumber);
; 14780: 	#endif
; 14781: #else
; 14782: 	#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 14783: 			ChinaHackLogFile.Output("[%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d", 
; 14784: 									 lpObj->AccountID, 
; 14785: 									 lpObj->Name, 
; 14786: 									 lMsg.Get(1900+lpObj->Class),
; 14787: 									 lpObj->m_DetectSpeedHackTime,
; 14788: 									 lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 14789: 									 lpObj->m_SpeedHackPenalty);
; 14790: 			ChinaHackUserKick.InsertSpeedNCount(lpObj->m_Index);
; 14791: 	#else
; 14792: 			LogAddTD("[%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d", 

  00188	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018b	8b 88 e0 01 00
	00		 mov	 ecx, DWORD PTR [eax+480]
  00191	51		 push	 ecx
  00192	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00195	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00198	8b 82 d4 01 00
	00		 mov	 eax, DWORD PTR [edx+468]
  0019e	33 d2		 xor	 edx, edx
  001a0	f7 b1 d8 01 00
	00		 div	 DWORD PTR [ecx+472]
  001a6	50		 push	 eax
  001a7	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001aa	8b 82 d0 01 00
	00		 mov	 eax, DWORD PTR [edx+464]
  001b0	50		 push	 eax
  001b1	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001b4	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  001bb	81 c2 6c 07 00
	00		 add	 edx, 1900		; 0000076cH
  001c1	52		 push	 edx
  001c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001cd	50		 push	 eax
  001ce	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d1	83 c0 73	 add	 eax, 115		; 00000073H
  001d4	50		 push	 eax
  001d5	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d8	83 c1 68	 add	 ecx, 104		; 00000068H
  001db	51		 push	 ecx
  001dc	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@GAMOBCPD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wro@
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001e7	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN7@CGAttack:

; 14793: 						 lpObj->AccountID, 
; 14794: 						 lpObj->Name, 
; 14795: 						 lMsg.Get(1900+lpObj->Class),
; 14796: 						 lpObj->m_DetectSpeedHackTime,
; 14797: 						 lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 14798: 						 lpObj->m_SpeedHackPenalty);
; 14799: 	#endif
; 14800: #endif			
; 14801: 			//if( bIsIgnorePacketSpeedHackDetect )
; 14802: 			//	return;
; 14803: 		}
; 14804: 		lpObj->m_LastAttackTime = GetTickCount();		

  001ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001f0	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f3	89 81 c8 01 00
	00		 mov	 DWORD PTR [ecx+456], eax

; 14805: 	}

  001f9	eb 1a		 jmp	 SHORT $LN6@CGAttack
$LN5@CGAttack:

; 14806: 	else
; 14807: 	{
; 14808: 		lpObj->m_SumLastAttackTime = 0;

  001fb	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fe	c7 80 d4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+468], 0

; 14809: 		lpObj->m_DetectCount = 0;

  00208	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0020b	c7 80 d8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+472], 0
$LN6@CGAttack:

; 14810: 	}	
; 14811: 	lpObj->m_LastAttackTime = GetTickCount();	

  00215	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0021b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0021e	89 81 c8 01 00
	00		 mov	 DWORD PTR [ecx+456], eax

; 14812: 
; 14813: 
; 14814: 	if( bIsIgnorePacketSpeedHackDetect )

  00224	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  0022b	74 65		 je	 SHORT $LN10@CGAttack

; 14815: 	{
; 14816: 		if( lpObj->m_SpeedHackPenalty > 0 )

  0022d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00230	83 b8 e0 01 00
	00 00		 cmp	 DWORD PTR [eax+480], 0
  00237	7e 59		 jle	 SHORT $LN10@CGAttack

; 14817: 		{
; 14818: 			lpObj->m_SpeedHackPenalty--;

  00239	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023c	8b 88 e0 01 00
	00		 mov	 ecx, DWORD PTR [eax+480]
  00242	83 e9 01	 sub	 ecx, 1
  00245	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00248	89 8a e0 01 00
	00		 mov	 DWORD PTR [edx+480], ecx

; 14819: 
; 14820: #ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 14821: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left) @%d", 
; 14822: 					  lpObj->AccountID, lpObj->Name, lMsg.Get(1900+lpObj->Class),
; 14823: 					  lpObj->m_SpeedHackPenalty,
; 14824: 					  lpObj->MapNumber);
; 14825: #else
; 14826: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left)", 

  0024e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00251	8b 88 e0 01 00
	00		 mov	 ecx, DWORD PTR [eax+480]
  00257	51		 push	 ecx
  00258	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0025b	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  00262	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00267	50		 push	 eax
  00268	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00273	50		 push	 eax
  00274	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00277	83 c1 73	 add	 ecx, 115		; 00000073H
  0027a	51		 push	 ecx
  0027b	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0027e	83 c2 68	 add	 edx, 104		; 00000068H
  00281	52		 push	 edx
  00282	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5@
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0028d	83 c4 14	 add	 esp, 20			; 00000014H

; 14827: 					  lpObj->AccountID, lpObj->Name, lMsg.Get(1900+lpObj->Class),
; 14828: 					  lpObj->m_SpeedHackPenalty);
; 14829: #endif
; 14830: 			return;

  00290	eb 6b		 jmp	 SHORT $LN1@CGAttack
$LN10@CGAttack:

; 14831: 		}
; 14832: 	}
; 14833: 
; 14834: 	//LogAdd("Normal Attack Speed = [%d,%d] %d", lpObj->m_AttackSpeed, lpObj->m_MagicSpeed, iTimeCalc);
; 14835: 
; 14836: 	lpTargetObj = &gObj[usernumber];

  00292	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _usernumber$[ebp], 7072
  00299	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0029f	89 45 f8	 mov	 DWORD PTR _lpTargetObj$[ebp], eax

; 14837: 	lpObj->Dir  = lpMsg->DirDis;

  002a2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a5	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002a8	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  002ab	88 90 08 01 00
	00		 mov	 BYTE PTR [eax+264], dl

; 14838: 	
; 14839: #ifdef ADD_TRAP_OBJECT_EXTEND_20060731
; 14840: 	//     
; 14841: 	GCActionSend(lpObj, lpMsg->AttackAction, aIndex, usernumber);
; 14842: #else
; 14843: 	GCActionSend(lpObj, lpMsg->AttackAction, aIndex);

  002b1	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002b4	50		 push	 eax
  002b5	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002b8	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  002bc	52		 push	 edx
  002bd	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c0	50		 push	 eax
  002c1	e8 00 00 00 00	 call	 ?GCActionSend@@YAXPAVOBJECTSTRUCT@@EH@Z ; GCActionSend
  002c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14844: #endif // ADD_TRAP_OBJECT_EXTEND_20060731
; 14845: 	
; 14846: #ifdef ADD_SKILL_WITH_COMBO
; 14847: 	gComboAttack.CheckCombo(aIndex, 0);

  002c9	6a 00		 push	 0
  002cb	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002ce	50		 push	 eax
  002cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?gComboAttack@@3VCComboAttack@@A ; gComboAttack
  002d4	e8 00 00 00 00	 call	 ?CheckCombo@CComboAttack@@QAEHHH@Z ; CComboAttack::CheckCombo

; 14848: #endif
; 14849: 
; 14850: 	gObjAttack(lpObj, lpTargetObj, NULL, 0, 0);

  002d9	6a 00		 push	 0
  002db	6a 00		 push	 0
  002dd	6a 00		 push	 0
  002df	6a 00		 push	 0
  002e1	6a 00		 push	 0
  002e3	8b 45 f8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002e6	50		 push	 eax
  002e7	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ea	51		 push	 ecx
  002eb	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  002f0	83 c4 1c	 add	 esp, 28			; 0000001cH

; 14851: 
; 14852: 	lpObj->UseMagicNumber = 0;

  002f3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f6	c6 80 15 03 00
	00 00		 mov	 BYTE PTR [eax+789], 0
$LN1@CGAttack:

; 14853: }

  002fd	5f		 pop	 edi
  002fe	5e		 pop	 esi
  002ff	5b		 pop	 ebx
  00300	8b e5		 mov	 esp, ebp
  00302	5d		 pop	 ebp
  00303	c3		 ret	 0
?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ENDP			; CGAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGWeatherSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_weather$ = 12						; size = 1
?CGWeatherSend@@YAXHE@Z PROC				; CGWeatherSend, COMDAT

; 18552: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18553: 	PMSG_WEATHER	pMsg;
; 18554: 
; 18555: 	PHeadSetB((LPBYTE)&pMsg, 0x0F, sizeof( pMsg ));

  00009	6a 04		 push	 4
  0000b	6a 0f		 push	 15			; 0000000fH
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18556: 	pMsg.Weather    = weather;

  00019	8a 45 0c	 mov	 al, BYTE PTR _weather$[ebp]
  0001c	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 18557: 
; 18558: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001f	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00023	50		 push	 eax
  00024	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18559: }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?CGWeatherSend@@YAXHE@Z ENDP				; CGWeatherSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCReFillSend@@YAXHGEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_Life$ = 12						; size = 2
_Ipos$ = 16						; size = 1
_flag$ = 20						; size = 1
?GCReFillSend@@YAXHGEE@Z PROC				; GCReFillSend, COMDAT

; 18446: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18447: 	PMSG_REFILL	pMsg;
; 18448: 	
; 18449: 	PHeadSetB((LPBYTE)&pMsg, 0x26, sizeof( pMsg ));

  00009	6a 07		 push	 7
  0000b	6a 26		 push	 38			; 00000026H
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18450: 	pMsg.IPos       = Ipos;

  00019	8a 45 10	 mov	 al, BYTE PTR _Ipos$[ebp]
  0001c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 18451: 	pMsg.LifeH		= HIBYTE(Life);

  0001f	0f b7 45 0c	 movzx	 eax, WORD PTR _Life$[ebp]
  00023	c1 e8 08	 shr	 eax, 8
  00026	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002b	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 18452: 	pMsg.LifeL		= LOBYTE(Life);

  0002e	0f b7 45 0c	 movzx	 eax, WORD PTR _Life$[ebp]
  00032	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00037	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 18453: 	pMsg.Flag		= 0;

  0003a	c6 45 fe 00	 mov	 BYTE PTR _pMsg$[ebp+6], 0

; 18454: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00042	50		 push	 eax
  00043	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00046	51		 push	 ecx
  00047	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18455: }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?GCReFillSend@@YAXHGEE@Z ENDP				; GCReFillSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?SCPJoinResultSend@@YAXHE@Z
_TEXT	SEGMENT
_pResult$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?SCPJoinResultSend@@YAXHE@Z PROC			; SCPJoinResultSend, COMDAT

; 3028 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 3029 : 	PMSG_JOINRESULT	pResult;
; 3030 : 
; 3031 : 	memset(&pResult, 0, sizeof(pResult));

  00013	6a 0c		 push	 12			; 0000000cH
  00015	6a 00		 push	 0
  00017	8d 45 f0	 lea	 eax, DWORD PTR _pResult$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _memset
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3032 : 	pResult.h.size     = sizeof(pResult);

  00023	c6 45 f1 0c	 mov	 BYTE PTR _pResult$[ebp+1], 12 ; 0000000cH

; 3033 : 	pResult.h.c		   = PMHC_BYTE;

  00027	c6 45 f0 c1	 mov	 BYTE PTR _pResult$[ebp], 193 ; 000000c1H

; 3034 : 	pResult.h.headcode = 0xF1;

  0002b	c6 45 f2 f1	 mov	 BYTE PTR _pResult$[ebp+2], 241 ; 000000f1H

; 3035 : 	pResult.scode      = 0x00;

  0002f	c6 45 f3 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 3036 : 	pResult.result     = result;

  00033	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00036	88 45 f4	 mov	 BYTE PTR _pResult$[ebp+4], al

; 3037 : 	pResult.NumberH    = HIBYTE(aIndex);

  00039	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0003c	c1 e8 08	 shr	 eax, 8
  0003f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00044	88 45 f5	 mov	 BYTE PTR _pResult$[ebp+5], al

; 3038 : 	pResult.NumberL    = LOBYTE(aIndex);

  00047	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0004a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004f	88 45 f6	 mov	 BYTE PTR _pResult$[ebp+6], al

; 3039 : 	pResult.CliVersion[0] = szClientVersion[0];

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	6b c8 00	 imul	 ecx, eax, 0
  0005a	ba 01 00 00 00	 mov	 edx, 1
  0005f	6b c2 00	 imul	 eax, edx, 0
  00062	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR ?szClientVersion@@3PADA[ecx]
  00068	88 4c 05 f7	 mov	 BYTE PTR _pResult$[ebp+eax+7], cl

; 3040 : 	pResult.CliVersion[1] = szClientVersion[1];

  0006c	b8 01 00 00 00	 mov	 eax, 1
  00071	c1 e0 00	 shl	 eax, 0
  00074	b9 01 00 00 00	 mov	 ecx, 1
  00079	c1 e1 00	 shl	 ecx, 0
  0007c	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR ?szClientVersion@@3PADA[eax]
  00082	88 54 0d f7	 mov	 BYTE PTR _pResult$[ebp+ecx+7], dl

; 3041 : 	pResult.CliVersion[2] = szClientVersion[2];

  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	d1 e0		 shl	 eax, 1
  0008d	b9 01 00 00 00	 mov	 ecx, 1
  00092	d1 e1		 shl	 ecx, 1
  00094	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR ?szClientVersion@@3PADA[eax]
  0009a	88 54 0d f7	 mov	 BYTE PTR _pResult$[ebp+ecx+7], dl

; 3042 : 	pResult.CliVersion[3] = szClientVersion[3];

  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	6b c8 03	 imul	 ecx, eax, 3
  000a6	ba 01 00 00 00	 mov	 edx, 1
  000ab	6b c2 03	 imul	 eax, edx, 3
  000ae	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR ?szClientVersion@@3PADA[ecx]
  000b4	88 4c 05 f7	 mov	 BYTE PTR _pResult$[ebp+eax+7], cl

; 3043 : 	pResult.CliVersion[4] = szClientVersion[4];

  000b8	b8 01 00 00 00	 mov	 eax, 1
  000bd	c1 e0 02	 shl	 eax, 2
  000c0	b9 01 00 00 00	 mov	 ecx, 1
  000c5	c1 e1 02	 shl	 ecx, 2
  000c8	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR ?szClientVersion@@3PADA[eax]
  000ce	88 54 0d f7	 mov	 BYTE PTR _pResult$[ebp+ecx+7], dl

; 3044 : 	
; 3045 : 	
; 3046 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000d2	0f b6 45 f1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000d6	50		 push	 eax
  000d7	8d 4d f0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000da	51		 push	 ecx
  000db	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 : 
; 3048 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();	

  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000ed	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fa	89 44 0a 38	 mov	 DWORD PTR [edx+ecx+56], eax

; 3049 : }

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00104	33 cd		 xor	 ecx, ebp
  00106	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
?SCPJoinResultSend@@YAXHE@Z ENDP			; SCPJoinResultSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?ProtocolCore@@YAXEPAEHHHH@Z
_TEXT	SEGMENT
tv467 = -96						; size = 4
tv436 = -96						; size = 4
tv386 = -96						; size = 4
tv336 = -96						; size = 4
tv222 = -96						; size = 4
tv200 = -96						; size = 4
tv171 = -96						; size = 4
tv161 = -96						; size = 4
_lpDef$1 = -28						; size = 4
_lpDef$2 = -24						; size = 4
_lpDef$3 = -20						; size = 4
_lpDef$4 = -16						; size = 4
_lpObj$5 = -12						; size = 4
_lpDef$6 = -8						; size = 4
_lpMsg2$7 = -4						; size = 4
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
_aIndex$ = 20						; size = 4
_Encrypt$ = 24						; size = 4
_serial$ = 28						; size = 4
?ProtocolCore@@YAXEPAEHHHH@Z PROC			; ProtocolCore, COMDAT

; 840  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 841  : /*	if( aRecv[0] == 0xC1 )
; 842  : 	{
; 843  : 		if( aRecv[2] == 0x26 || aRecv[2] == 0x27 || aRecv[2] == 0x2a || aRecv[2] == 0x28 )
; 844  : 		{
; 845  : 			LogAdd("[%s]r 0x%x pos : %d", gObj[aIndex].Name, aRecv[2], aRecv[3]);
; 846  : 		}
; 847  : 		else LogAdd("[%s]r 0x%x", gObj[aIndex].Name, protoNum);
; 848  : 	}
; 849  : 	else LogAdd("[%s]r 0x%x", gObj[aIndex].Name, protoNum);
; 850  : */
; 851  : 
; 852  : #ifdef PACKET_KUZIMO
; 853  : 	char tempBuff[1024 * 10];
; 854  : 
; 855  : 	wsprintf(tempBuff, "%08u	C	%-12s	UserIndex(%05d)	E(%c)	Serial(%05d)	Msg(0x%02X)	Size(0x%05X)	", 
; 856  : 		GetTickCount(), gObj[aIndex].Name, aIndex, (Encrypt == TRUE)? 'T' : 'F', serial, protoNum, aLen);
; 857  : 
; 858  : 	for(int i = 0; i < aLen; i++)
; 859  : 	{
; 860  : 		wsprintf(&tempBuff[strlen(tempBuff)], ",%02X", aRecv[i]);
; 861  : 	}
; 862  : 
; 863  : 	wsprintf(&tempBuff[strlen(tempBuff)], "\n");	
; 864  : 	WriteLog("PacketLog.txt", tempBuff);	
; 865  : #endif
; 866  : 
; 867  : 	if( gStalkProtocol )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gStalkProtocol@@3HA, 0 ; gStalkProtocol
  00010	0f 84 9f 00 00
	00		 je	 $LN18@ProtocolCo

; 868  : 	{
; 869  : 		if( gStalkProtocolId[0] == gObj[aIndex].AccountID[0] )

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	0f be 91 00 00
	00 00		 movsx	 edx, BYTE PTR ?gStalkProtocolId@@3PADA[ecx]
  00025	69 45 14 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00032	b9 01 00 00 00	 mov	 ecx, 1
  00037	6b c9 00	 imul	 ecx, ecx, 0
  0003a	0f be 44 08 68	 movsx	 eax, BYTE PTR [eax+ecx+104]
  0003f	3b d0		 cmp	 edx, eax
  00041	75 72		 jne	 SHORT $LN18@ProtocolCo

; 870  : 		{
; 871  : 			if( gStalkProtocolId[1] == gObj[aIndex].AccountID[1] )

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	c1 e0 00	 shl	 eax, 0
  0004b	0f be 88 00 00
	00 00		 movsx	 ecx, BYTE PTR ?gStalkProtocolId@@3PADA[eax]
  00052	69 55 14 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00059	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005f	b8 01 00 00 00	 mov	 eax, 1
  00064	c1 e0 00	 shl	 eax, 0
  00067	0f be 54 02 68	 movsx	 edx, BYTE PTR [edx+eax+104]
  0006c	3b ca		 cmp	 ecx, edx
  0006e	75 45		 jne	 SHORT $LN18@ProtocolCo

; 872  : 			{
; 873  : 				if( strcmp(gStalkProtocolId,  gObj[aIndex].AccountID ) == 0 )

  00070	69 45 14 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007d	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00081	52		 push	 edx
  00082	68 00 00 00 00	 push	 OFFSET ?gStalkProtocolId@@3PADA ; gStalkProtocolId
  00087	e8 00 00 00 00	 call	 _strcmp
  0008c	83 c4 08	 add	 esp, 8
  0008f	85 c0		 test	 eax, eax
  00091	75 22		 jne	 SHORT $LN18@ProtocolCo

; 874  : 				{
; 875  : 					LogAddHeadHex(gObj[aIndex].AccountID, (char*)aRecv, aLen);

  00093	8b 45 10	 mov	 eax, DWORD PTR _aLen$[ebp]
  00096	50		 push	 eax
  00097	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0009a	51		 push	 ecx
  0009b	69 55 14 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a7	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  000ab	51		 push	 ecx
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddHeadHex@@3P6AXPAD0H@ZA ; LogAddHeadHex
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@ProtocolCo:

; 876  : 				}
; 877  : 			}
; 878  : 		}
; 879  : 	}
; 880  : 
; 881  : 	if( serial >= 0 )

  000b5	83 7d 1c 00	 cmp	 DWORD PTR _serial$[ebp], 0
  000b9	7c 74		 jl	 SHORT $LN22@ProtocolCo

; 882  : 	{
; 883  : 		if( gObj[aIndex].Type == OBJTYPE_CHARACTER )

  000bb	69 45 14 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c8	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000cd	83 fa 01	 cmp	 edx, 1
  000d0	75 5d		 jne	 SHORT $LN22@ProtocolCo

; 884  : 		{ 
; 885  : 			if( gNSerialCheck[aIndex].InCheck(serial) == FALSE )

  000d2	0f b6 45 1c	 movzx	 eax, BYTE PTR _serial$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 14	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000da	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[ecx*8]
  000e1	e8 00 00 00 00	 call	 ?InCheck@NSerialCheck@@QAEHE@Z ; NSerialCheck::InCheck
  000e6	85 c0		 test	 eax, eax
  000e8	75 45		 jne	 SHORT $LN22@ProtocolCo

; 886  : 			{
; 887  : 				LogAdd("Error-L1 : Socket Serial %s %d o_serial:%d serial:%d ", 

  000ea	8b 45 1c	 mov	 eax, DWORD PTR _serial$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d 14	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000f1	8d 0c cd 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[ecx*8]
  000f8	e8 00 00 00 00	 call	 ?GetSerial@NSerialCheck@@QAEHXZ ; NSerialCheck::GetSerial
  000fd	50		 push	 eax
  000fe	0f b6 55 08	 movzx	 edx, BYTE PTR _protoNum$[ebp]
  00102	52		 push	 edx
  00103	69 45 14 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00110	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00114	52		 push	 edx
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5@
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00120	83 c4 14	 add	 esp, 20			; 00000014H

; 888  : 						gObj[aIndex].AccountID, 
; 889  : 						protoNum, 
; 890  : 						gNSerialCheck[aIndex].GetSerial(), 
; 891  : 						serial);
; 892  : 				CloseClient(aIndex);

  00123	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0012c	83 c4 04	 add	 esp, 4
$LN22@ProtocolCo:

; 893  : 			}
; 894  : 		}
; 895  : 	}
; 896  : 	
; 897  : 	// 
; 898  : //	CHAR szTEMP[256];
; 899  : //	LPPMSG_DEFAULT2 lpMsg3=(LPPMSG_DEFAULT2)aRecv;
; 900  : //	wsprintf(szTEMP, "(C->S)[%x-%x]\n", protoNum, lpMsg3->subcode);
; 901  : //	OutputDebugString(szTEMP);
; 902  : 
; 903  : 	if( protoNum == 0xF1 || protoNum == 0xF3 )

  0012f	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00133	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  00138	74 0f		 je	 SHORT $LN27@ProtocolCo
  0013a	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  0013e	3d f3 00 00 00	 cmp	 eax, 243		; 000000f3H
  00143	0f 85 a4 01 00
	00		 jne	 $LN25@ProtocolCo
$LN27@ProtocolCo:

; 904  : 	{
; 905  : 		switch( protoNum )

  00149	8a 45 08	 mov	 al, BYTE PTR _protoNum$[ebp]
  0014c	88 45 a0	 mov	 BYTE PTR tv161[ebp], al
  0014f	80 7d a0 0e	 cmp	 BYTE PTR tv161[ebp], 14	; 0000000eH
  00153	74 15		 je	 SHORT $LN28@ProtocolCo
  00155	80 7d a0 f1	 cmp	 BYTE PTR tv161[ebp], 241 ; 000000f1H
  00159	74 46		 je	 SHORT $LN30@ProtocolCo
  0015b	80 7d a0 f3	 cmp	 BYTE PTR tv161[ebp], 243 ; 000000f3H
  0015f	0f 84 e3 00 00
	00		 je	 $LN37@ProtocolCo
  00165	e9 7e 01 00 00	 jmp	 $LN2@ProtocolCo
$LN28@ProtocolCo:

; 906  : 		{
; 907  : 		case 0x0E :	//   
; 908  : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  0016a	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  0016d	50		 push	 eax
  0016e	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  00172	51		 push	 ecx
  00173	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0017c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017f	85 c0		 test	 eax, eax
  00181	74 19		 je	 SHORT $LN29@ProtocolCo

; 909  : 			{
; 910  : 				CGLiveClient((LPPMSG_CLIENTTIME)aRecv, aIndex);

  00183	0f b7 45 14	 movzx	 eax, WORD PTR _aIndex$[ebp]
  00187	50		 push	 eax
  00188	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0018b	51		 push	 ecx
  0018c	e8 00 00 00 00	 call	 ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ; CGLiveClient
  00191	83 c4 08	 add	 esp, 8

; 911  : 				tempindex = aIndex;

  00194	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00197	a3 00 00 00 00	 mov	 DWORD PTR ?tempindex@@3HA, eax ; tempindex
$LN29@ProtocolCo:

; 912  : 			}
; 913  : 			break;

  0019c	e9 47 01 00 00	 jmp	 $LN2@ProtocolCo
$LN30@ProtocolCo:

; 914  : 		case 0xF1 :
; 915  : 			{
; 916  : 			LPPMSG_DEFAULT2 lpMsg2=(LPPMSG_DEFAULT2)aRecv;

  001a1	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001a4	89 45 fc	 mov	 DWORD PTR _lpMsg2$7[ebp], eax

; 917  : 			switch( lpMsg2->subcode )

  001a7	8b 45 fc	 mov	 eax, DWORD PTR _lpMsg2$7[ebp]
  001aa	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  001ad	88 4d a0	 mov	 BYTE PTR tv171[ebp], cl
  001b0	80 7d a0 01	 cmp	 BYTE PTR tv171[ebp], 1
  001b4	74 0e		 je	 SHORT $LN31@ProtocolCo
  001b6	80 7d a0 02	 cmp	 BYTE PTR tv171[ebp], 2
  001ba	74 33		 je	 SHORT $LN33@ProtocolCo
  001bc	80 7d a0 03	 cmp	 BYTE PTR tv171[ebp], 3
  001c0	74 58		 je	 SHORT $LN35@ProtocolCo
  001c2	eb 7f		 jmp	 SHORT $LN4@ProtocolCo
$LN31@ProtocolCo:

; 918  : 			{
; 919  : 			case 0x01 : //
; 920  : 				if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  001c4	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  001c7	50		 push	 eax
  001c8	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  001cc	51		 push	 ecx
  001cd	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001d0	52		 push	 edx
  001d1	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  001d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d9	85 c0		 test	 eax, eax
  001db	74 10		 je	 SHORT $LN32@ProtocolCo

; 921  : 					CSPJoinIdPassRequest((LPPMSG_IDPASS)aRecv, aIndex);

  001dd	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001e0	50		 push	 eax
  001e1	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  001e4	51		 push	 ecx
  001e5	e8 00 00 00 00	 call	 ?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z ; CSPJoinIdPassRequest
  001ea	83 c4 08	 add	 esp, 8
$LN32@ProtocolCo:

; 922  : 				break;

  001ed	eb 54		 jmp	 SHORT $LN4@ProtocolCo
$LN33@ProtocolCo:

; 923  : 			case 0x02 :	//    .. 
; 924  : 				if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  001ef	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  001f2	50		 push	 eax
  001f3	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  001f7	51		 push	 ecx
  001f8	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001fb	52		 push	 edx
  001fc	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00201	83 c4 0c	 add	 esp, 12			; 0000000cH
  00204	85 c0		 test	 eax, eax
  00206	74 10		 je	 SHORT $LN34@ProtocolCo

; 925  : 					CGClientCloseMsg((LPPMSG_CLIENTCLOSE)aRecv, aIndex);

  00208	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0020b	50		 push	 eax
  0020c	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z ; CGClientCloseMsg
  00215	83 c4 08	 add	 esp, 8
$LN34@ProtocolCo:

; 926  : 				break;

  00218	eb 29		 jmp	 SHORT $LN4@ProtocolCo
$LN35@ProtocolCo:

; 927  : 			case 0x03 :
; 928  : #ifdef PACKET_KUZIMO
; 929  : 	WriteLog("PacketLog.txt", "%08u	S	%-12s	UserIndex(%05d)	LogIn\n", GetTickCount(), gObj[aIndex].Name, aIndex);
; 930  : #endif
; 931  : 				if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  0021a	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  0021d	50		 push	 eax
  0021e	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  00222	51		 push	 ecx
  00223	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00226	52		 push	 edx
  00227	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022f	85 c0		 test	 eax, eax
  00231	74 10		 je	 SHORT $LN4@ProtocolCo

; 932  : 					CGClientMsg((LPPMSG_CLIENTMSG)aRecv, aIndex);

  00233	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00236	50		 push	 eax
  00237	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0023a	51		 push	 ecx
  0023b	e8 00 00 00 00	 call	 ?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z ; CGClientMsg
  00240	83 c4 08	 add	 esp, 8
$LN4@ProtocolCo:

; 933  : 				break;
; 934  : 			}
; 935  : 			}
; 936  : 			break;

  00243	e9 a0 00 00 00	 jmp	 $LN2@ProtocolCo
$LN37@ProtocolCo:

; 937  : 		case 0xF3 :
; 938  : 			{
; 939  : 			LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;

  00248	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0024b	89 45 f8	 mov	 DWORD PTR _lpDef$6[ebp], eax

; 940  : 			switch( lpDef->subcode )

  0024e	8b 45 f8	 mov	 eax, DWORD PTR _lpDef$6[ebp]
  00251	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00255	89 4d a0	 mov	 DWORD PTR tv200[ebp], ecx
  00258	83 7d a0 30	 cmp	 DWORD PTR tv200[ebp], 48 ; 00000030H
  0025c	0f 87 86 00 00
	00		 ja	 $LN2@ProtocolCo
  00262	8b 55 a0	 mov	 edx, DWORD PTR tv200[ebp]
  00265	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN150@ProtocolCo[edx]
  0026c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN151@ProtocolCo[eax*4]
$LN38@ProtocolCo:

; 941  : 			{
; 942  : 			case 0x00 :	//    
; 943  : 				DataServerGetCharListRequest(aIndex);

  00273	0f b7 45 14	 movzx	 eax, WORD PTR _aIndex$[ebp]
  00277	50		 push	 eax
  00278	e8 00 00 00 00	 call	 ?DataServerGetCharListRequest@@YAXF@Z ; DataServerGetCharListRequest
  0027d	83 c4 04	 add	 esp, 4

; 944  : 				break;

  00280	eb 66		 jmp	 SHORT $LN2@ProtocolCo
$LN39@ProtocolCo:

; 945  : 			case 0x01 : //   
; 946  : 				CGPCharacterCreate((LPPMSG_CHARCREATE)aRecv, aIndex);

  00282	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00285	50		 push	 eax
  00286	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00289	51		 push	 ecx
  0028a	e8 00 00 00 00	 call	 ?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z ; CGPCharacterCreate
  0028f	83 c4 08	 add	 esp, 8

; 947  : 				break;

  00292	eb 54		 jmp	 SHORT $LN2@ProtocolCo
$LN40@ProtocolCo:

; 948  : 			case 0x02 :	//    
; 949  : 				CGPCharDel((LPPMSG_CHARDELETE)aRecv, aIndex);

  00294	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00297	50		 push	 eax
  00298	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0029b	51		 push	 ecx
  0029c	e8 00 00 00 00	 call	 ?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z ; CGPCharDel
  002a1	83 c4 08	 add	 esp, 8

; 950  : 				break;

  002a4	eb 42		 jmp	 SHORT $LN2@ProtocolCo
$LN41@ProtocolCo:

; 951  : 			case 0x03 : //     
; 952  : 				CGPCharacterMapJoinRequest((LPPMSG_CHARMAPJOIN)aRecv, aIndex);

  002a6	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002a9	50		 push	 eax
  002aa	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  002ad	51		 push	 ecx
  002ae	e8 00 00 00 00	 call	 ?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ; CGPCharacterMapJoinRequest
  002b3	83 c4 08	 add	 esp, 8

; 953  : 				//ObjectMapJoinPositionSend(aIndex);	//   .
; 954  : 				break;

  002b6	eb 30		 jmp	 SHORT $LN2@ProtocolCo
$LN42@ProtocolCo:

; 955  : 			case 0x06 :	//   .
; 956  : 				CGLevelUpPointAdd((LPPMSG_LVPOINTADD)aRecv, aIndex);

  002b8	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002bb	50		 push	 eax
  002bc	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  002bf	51		 push	 ecx
  002c0	e8 00 00 00 00	 call	 ?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z ; CGLevelUpPointAdd
  002c5	83 c4 08	 add	 esp, 8

; 957  : 				break;

  002c8	eb 1e		 jmp	 SHORT $LN2@ProtocolCo
$LN43@ProtocolCo:

; 958  : 			case 0x12 :
; 959  : 				gObjMoveDataLoadingOK(aIndex);

  002ca	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002cd	50		 push	 eax
  002ce	e8 00 00 00 00	 call	 ?gObjMoveDataLoadingOK@@YAXH@Z ; gObjMoveDataLoadingOK
  002d3	83 c4 04	 add	 esp, 4

; 960  : 				break;

  002d6	eb 10		 jmp	 SHORT $LN2@ProtocolCo
$LN44@ProtocolCo:

; 961  : #ifdef UPDATE_CHANGE_CHARACTERNAME_20080410 
; 962  : 			case 0x15:
; 963  : 				CGReqCheckChangeName((LPPMSG_REQ_CHECK_CHAGNE_NAME)aRecv, aIndex);
; 964  : 				break;
; 965  : 			case 0x16:
; 966  : 				CGChangeName((LPPMSG_CHAGNE_NAME) aRecv, aIndex);
; 967  : 				break;
; 968  : #endif // UPDATE_CHANGE_CHARACTERNAME_20080410
; 969  : 			case 0x30 : 
; 970  : 				GCSkillKeyRecv((LPPMSG_SKILLKEY)aRecv, aIndex);

  002d8	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  002db	50		 push	 eax
  002dc	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  002df	51		 push	 ecx
  002e0	e8 00 00 00 00	 call	 ?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z ; GCSkillKeyRecv
  002e5	83 c4 08	 add	 esp, 8
$LN2@ProtocolCo:

; 971  : 				break;
; 972  : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	//  .
; 973  : 			case 0x52:
; 974  : 				g_MasterSkillSystem.CGReqGetMasterLevelSkill( ( LPPMSG_REQ_MASTERLEVEL_SKILL )aRecv, aIndex );
; 975  : 				break;				
; 976  : #endif
; 977  : 			}
; 978  : 			}
; 979  : 			break;
; 980  : 		}
; 981  : 	}

  002e8	e9 fd 08 00 00	 jmp	 $LN1@ProtocolCo
$LN25@ProtocolCo:

; 982  : 	else
; 983  : 	{
; 984  : 		LPOBJECTSTRUCT lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  002ed	69 45 14 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002f4	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002fa	89 45 f4	 mov	 DWORD PTR _lpObj$5[ebp], eax

; 985  : 		/*if( gObjIsGamePlaing(lpObj) == FALSE ) 
; 986  : 		{
; 987  : 			if( protoNum != 0x0E )
; 988  : 			{
; 989  : 				LogAdd("error-L3 : %d %s Game Not Play(Protocol:%x,len:%d)", aIndex, gObj[aIndex].Name, protoNum, aLen);
; 990  : 				return;
; 991  : 			}
; 992  : 		}
; 993  : 		*/
; 994  : 		
; 995  : 
; 996  : 		switch( protoNum )

  002fd	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00301	89 45 a0	 mov	 DWORD PTR tv222[ebp], eax
  00304	81 7d a0 d9 00
	00 00		 cmp	 DWORD PTR tv222[ebp], 217 ; 000000d9H
  0030b	0f 87 74 08 00
	00		 ja	 $LN148@ProtocolCo
  00311	8b 4d a0	 mov	 ecx, DWORD PTR tv222[ebp]
  00314	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN152@ProtocolCo[ecx]
  0031b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN153@ProtocolCo[edx*4]
$LN45@ProtocolCo:

; 997  : 		{
; 998  : 		case 0x00 :
; 999  : 			tempindex = aIndex;

  00322	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00325	a3 00 00 00 00	 mov	 DWORD PTR ?tempindex@@3HA, eax ; tempindex

; 1000 : 			PChatProc((LPPMSG_CHATDATA)aRecv, aIndex);

  0032a	0f b7 45 14	 movzx	 eax, WORD PTR _aIndex$[ebp]
  0032e	50		 push	 eax
  0032f	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00332	51		 push	 ecx
  00333	e8 00 00 00 00	 call	 ?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z ; PChatProc
  00338	83 c4 08	 add	 esp, 8

; 1001 : 			break;

  0033b	e9 aa 08 00 00	 jmp	 $LN1@ProtocolCo
$LN46@ProtocolCo:

; 1002 : 		case 0x01 :
; 1003 : 			CGChatRecv((LPPMSG_CHATDATA_NUMBER)aRecv, aIndex);

  00340	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00343	50		 push	 eax
  00344	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00347	51		 push	 ecx
  00348	e8 00 00 00 00	 call	 ?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z ; CGChatRecv
  0034d	83 c4 08	 add	 esp, 8

; 1004 : 			break;

  00350	e9 95 08 00 00	 jmp	 $LN1@ProtocolCo
$LN47@ProtocolCo:

; 1005 : 		case 0x02 :
; 1006 : 			CGChatWhisperRecv((LPPMSG_CHATDATA_WHISPER)aRecv, aIndex);

  00355	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00358	50		 push	 eax
  00359	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0035c	51		 push	 ecx
  0035d	e8 00 00 00 00	 call	 ?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ; CGChatWhisperRecv
  00362	83 c4 08	 add	 esp, 8

; 1007 : 			break;

  00365	e9 80 08 00 00	 jmp	 $LN1@ProtocolCo
$LN48@ProtocolCo:

; 1008 : 		case 0x03 :
; 1009 : 			CGCheckMainRecv((LPPMSG_CHECK_MAINEXE_RESULT)aRecv, aIndex);

  0036a	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0036d	50		 push	 eax
  0036e	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00371	51		 push	 ecx
  00372	e8 00 00 00 00	 call	 ?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ; CGCheckMainRecv
  00377	83 c4 08	 add	 esp, 8

; 1010 : 			break;

  0037a	e9 6b 08 00 00	 jmp	 $LN1@ProtocolCo
$LN49@ProtocolCo:

; 1011 : 		case 0x0E :	//   
; 1012 : 			CGLiveClient((LPPMSG_CLIENTTIME)aRecv, aIndex);

  0037f	0f b7 45 14	 movzx	 eax, WORD PTR _aIndex$[ebp]
  00383	50		 push	 eax
  00384	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00387	51		 push	 ecx
  00388	e8 00 00 00 00	 call	 ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ; CGLiveClient
  0038d	83 c4 08	 add	 esp, 8

; 1013 : 			break;

  00390	e9 55 08 00 00	 jmp	 $LN1@ProtocolCo
$LN50@ProtocolCo:

; 1014 : #ifdef PACKET_CHANGE	
; 1015 : 		case PACKET_MOVE :
; 1016 : #else
; 1017 : 		case 0x10 :
; 1018 : #endif
; 1019 : 			PMoveProc((LPPMSG_MOVE)aRecv, aIndex);

  00395	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00398	50		 push	 eax
  00399	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0039c	51		 push	 ecx
  0039d	e8 00 00 00 00	 call	 ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ; PMoveProc
  003a2	83 c4 08	 add	 esp, 8

; 1020 : 			break;

  003a5	e9 40 08 00 00	 jmp	 $LN1@ProtocolCo
$LN51@ProtocolCo:

; 1021 : 
; 1022 : #ifdef PACKET_CHANGE	
; 1023 : 		case PACKET_POSITION :
; 1024 : #else
; 1025 : 		case 0x11 :
; 1026 : #endif
; 1027 : 			RecvPositionSetProc((LPPMSG_POSISTION_SET)aRecv,aIndex);

  003aa	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003ad	50		 push	 eax
  003ae	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  003b1	51		 push	 ecx
  003b2	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  003b7	83 c4 08	 add	 esp, 8

; 1028 : 			break;

  003ba	e9 2b 08 00 00	 jmp	 $LN1@ProtocolCo
$LN52@ProtocolCo:

; 1029 : 
; 1030 : #ifdef PACKET_CHANGE	
; 1031 : 		case PACKET_ATTACK :
; 1032 : #else
; 1033 : 		case 0x15 :
; 1034 : #endif
; 1035 : 			CGAttack((LPPMSG_ATTACK)aRecv, aIndex);

  003bf	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003c2	50		 push	 eax
  003c3	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  003c6	51		 push	 ecx
  003c7	e8 00 00 00 00	 call	 ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ; CGAttack
  003cc	83 c4 08	 add	 esp, 8

; 1036 : 			break;

  003cf	e9 16 08 00 00	 jmp	 $LN1@ProtocolCo
$LN53@ProtocolCo:

; 1037 : 		case 0x18 :
; 1038 : 			CGActionRecv((LPPMSG_ACTION)aRecv, aIndex);

  003d4	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003d7	50		 push	 eax
  003d8	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  003db	51		 push	 ecx
  003dc	e8 00 00 00 00	 call	 ?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z ; CGActionRecv
  003e1	83 c4 08	 add	 esp, 8

; 1039 : 			break;

  003e4	e9 01 08 00 00	 jmp	 $LN1@ProtocolCo
$LN54@ProtocolCo:

; 1040 : 		case 0x19 :
; 1041 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  003e9	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  003ec	50		 push	 eax
  003ed	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  003f1	51		 push	 ecx
  003f2	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  003f5	52		 push	 edx
  003f6	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  003fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  003fe	85 c0		 test	 eax, eax
  00400	74 10		 je	 SHORT $LN55@ProtocolCo

; 1042 : 				CGMagicAttack((LPPMSG_MAGICATTACK)aRecv, aIndex);

  00402	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00405	50		 push	 eax
  00406	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00409	51		 push	 ecx
  0040a	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  0040f	83 c4 08	 add	 esp, 8
$LN55@ProtocolCo:

; 1043 : 			break;

  00412	e9 d3 07 00 00	 jmp	 $LN1@ProtocolCo
$LN56@ProtocolCo:

; 1044 : 			/*
; 1045 : 		case 0x1A :
; 1046 : 			CGPosMagicAttackRecv((LPPMSG_POSMAGIC)aRecv, aIndex);
; 1047 : 			break;
; 1048 : 			*/
; 1049 : 			
; 1050 : #ifdef ADD_INFINITY_ARROW_CANCEL_20060516
; 1051 : 		case 0x1B:
; 1052 : 			{				
; 1053 : 				//   
; 1054 : 				CGMagicCancel( ( LPPMSG_MAGICCANCEL )aRecv, aIndex );
; 1055 : 			}
; 1056 : 			break;
; 1057 : #endif
; 1058 : 			
; 1059 : 		case 0x1C :
; 1060 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  00417	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  0041a	50		 push	 eax
  0041b	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  0041f	51		 push	 ecx
  00420	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00423	52		 push	 edx
  00424	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00429	83 c4 0c	 add	 esp, 12			; 0000000cH
  0042c	85 c0		 test	 eax, eax
  0042e	74 10		 je	 SHORT $LN57@ProtocolCo

; 1061 : 				CGTeleportRecv((LPPMSG_TELEPORT)aRecv, aIndex);

  00430	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00433	50		 push	 eax
  00434	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00437	51		 push	 ecx
  00438	e8 00 00 00 00	 call	 ?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z ; CGTeleportRecv
  0043d	83 c4 08	 add	 esp, 8
$LN57@ProtocolCo:

; 1062 : 			
; 1063 : 			break;

  00440	e9 a5 07 00 00	 jmp	 $LN1@ProtocolCo
$LN58@ProtocolCo:

; 1064 : #ifdef NEW_FORSKYLAND2
; 1065 : 		case 0xB0 : 
; 1066 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  00445	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  00448	50		 push	 eax
  00449	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  0044d	51		 push	 ecx
  0044e	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00451	52		 push	 edx
  00452	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00457	83 c4 0c	 add	 esp, 12			; 0000000cH
  0045a	85 c0		 test	 eax, eax
  0045c	74 10		 je	 SHORT $LN59@ProtocolCo

; 1067 : 				CGTargetTeleportRecv((LPPMSG_TARGET_TELEPORT) aRecv, aIndex);

  0045e	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00461	50		 push	 eax
  00462	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00465	51		 push	 ecx
  00466	e8 00 00 00 00	 call	 ?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ; CGTargetTeleportRecv
  0046b	83 c4 08	 add	 esp, 8
$LN59@ProtocolCo:

; 1068 : 			break;

  0046e	e9 77 07 00 00	 jmp	 $LN1@ProtocolCo
$LN60@ProtocolCo:

; 1069 : #endif
; 1070 : 
; 1071 : #ifdef PACKET_CHANGE	
; 1072 : 		case PACKET_MAGIC_ATTACK :
; 1073 : #else
; 1074 : 		case 0x1D :
; 1075 : #endif
; 1076 : 			CGBeattackRecv(aRecv, aIndex);

  00473	6a 00		 push	 0
  00475	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00478	50		 push	 eax
  00479	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0047c	51		 push	 ecx
  0047d	e8 00 00 00 00	 call	 ?CGBeattackRecv@@YAXPAEHH@Z ; CGBeattackRecv
  00482	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1077 : 			break;

  00485	e9 60 07 00 00	 jmp	 $LN1@ProtocolCo
$LN61@ProtocolCo:

; 1078 : 		case 0x1E :
; 1079 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  0048a	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  0048d	50		 push	 eax
  0048e	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  00492	51		 push	 ecx
  00493	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00496	52		 push	 edx
  00497	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0049c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0049f	85 c0		 test	 eax, eax
  004a1	74 10		 je	 SHORT $LN62@ProtocolCo

; 1080 : 				CGDurationMagicRecv((LPPMSG_DURATION_MAGIC_RECV)aRecv, aIndex);

  004a3	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004a6	50		 push	 eax
  004a7	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  004aa	51		 push	 ecx
  004ab	e8 00 00 00 00	 call	 ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv
  004b0	83 c4 08	 add	 esp, 8
$LN62@ProtocolCo:

; 1081 : 			break;

  004b3	e9 32 07 00 00	 jmp	 $LN1@ProtocolCo
$LN63@ProtocolCo:

; 1082 : 		case 0x22 :	//   
; 1083 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  004b8	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  004bb	50		 push	 eax
  004bc	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  004c0	51		 push	 ecx
  004c1	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  004c4	52		 push	 edx
  004c5	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  004ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  004cd	85 c0		 test	 eax, eax
  004cf	74 10		 je	 SHORT $LN64@ProtocolCo

; 1084 : 				CGItemGetRequest((LPPMSG_ITEMGETREQUEST)aRecv, aIndex);

  004d1	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004d4	50		 push	 eax
  004d5	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  004d8	51		 push	 ecx
  004d9	e8 00 00 00 00	 call	 ?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ; CGItemGetRequest
  004de	83 c4 08	 add	 esp, 8
$LN64@ProtocolCo:

; 1085 : 			break;

  004e1	e9 04 07 00 00	 jmp	 $LN1@ProtocolCo
$LN65@ProtocolCo:

; 1086 : 		case 0x23 :	//    
; 1087 : 			//if( DataEncryptCheck(aIndex, protoNum, Encrypt) )
; 1088 : 				CGItemDropRequest((LPPMSG_ITEMTHROW)aRecv, aIndex);

  004e6	6a 00		 push	 0
  004e8	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004eb	50		 push	 eax
  004ec	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  004ef	51		 push	 ecx
  004f0	e8 00 00 00 00	 call	 ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ; CGItemDropRequest
  004f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1089 : 			break;

  004f8	e9 ed 06 00 00	 jmp	 $LN1@ProtocolCo
$LN66@ProtocolCo:

; 1090 : 		case 0x24 :	//    
; 1091 : 			CGInventoryItemMove((LPPMSG_INVENTORYITEMMOVE)aRecv, aIndex);

  004fd	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00500	50		 push	 eax
  00501	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00504	51		 push	 ecx
  00505	e8 00 00 00 00	 call	 ?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ; CGInventoryItemMove
  0050a	83 c4 08	 add	 esp, 8

; 1092 : 			break;

  0050d	e9 d8 06 00 00	 jmp	 $LN1@ProtocolCo
$LN67@ProtocolCo:

; 1093 : 		case 0x26 :	//     
; 1094 : 			CGUseItemRecv((LPPMSG_USEITEM)aRecv, aIndex);

  00512	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00515	50		 push	 eax
  00516	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00519	51		 push	 ecx
  0051a	e8 00 00 00 00	 call	 ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ; CGUseItemRecv
  0051f	83 c4 08	 add	 esp, 8

; 1095 : 			break;

  00522	e9 c3 06 00 00	 jmp	 $LN1@ProtocolCo
$LN68@ProtocolCo:

; 1096 : 		case 0x30 :	//  .
; 1097 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  00527	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  0052a	50		 push	 eax
  0052b	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  0052f	51		 push	 ecx
  00530	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00533	52		 push	 edx
  00534	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00539	83 c4 0c	 add	 esp, 12			; 0000000cH
  0053c	85 c0		 test	 eax, eax
  0053e	74 10		 je	 SHORT $LN69@ProtocolCo

; 1098 : 				CGTalkRequestRecv((LPPMSG_TALKREQUEST)aRecv, aIndex);

  00540	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00543	50		 push	 eax
  00544	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00547	51		 push	 ecx
  00548	e8 00 00 00 00	 call	 ?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z ; CGTalkRequestRecv
  0054d	83 c4 08	 add	 esp, 8
$LN69@ProtocolCo:

; 1099 : 			break;

  00550	e9 95 06 00 00	 jmp	 $LN1@ProtocolCo
$LN70@ProtocolCo:

; 1100 : 
; 1101 : #ifdef NEW_SKILL_FORSKYLAND
; 1102 : 		case 0x31 :	//   (, )		
; 1103 : 				CGCloseWindow(aIndex);

  00555	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00558	50		 push	 eax
  00559	e8 00 00 00 00	 call	 ?CGCloseWindow@@YAXH@Z	; CGCloseWindow
  0055e	83 c4 04	 add	 esp, 4

; 1104 : 			break;

  00561	e9 84 06 00 00	 jmp	 $LN1@ProtocolCo
$LN71@ProtocolCo:

; 1105 : #endif
; 1106 : 
; 1107 : 
; 1108 : 		case 0x32 :	//  ..
; 1109 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  00566	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  00569	50		 push	 eax
  0056a	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  0056e	51		 push	 ecx
  0056f	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00572	52		 push	 edx
  00573	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00578	83 c4 0c	 add	 esp, 12			; 0000000cH
  0057b	85 c0		 test	 eax, eax
  0057d	74 10		 je	 SHORT $LN72@ProtocolCo

; 1110 : 				CGBuyRequestRecv((LPPMSG_BUYREQUEST)aRecv, aIndex);

  0057f	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00582	50		 push	 eax
  00583	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00586	51		 push	 ecx
  00587	e8 00 00 00 00	 call	 ?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z ; CGBuyRequestRecv
  0058c	83 c4 08	 add	 esp, 8
$LN72@ProtocolCo:

; 1111 : 			break;

  0058f	e9 56 06 00 00	 jmp	 $LN1@ProtocolCo
$LN73@ProtocolCo:

; 1112 : 		case 0x33 :	//    
; 1113 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  00594	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  00597	50		 push	 eax
  00598	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  0059c	51		 push	 ecx
  0059d	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005a0	52		 push	 edx
  005a1	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  005a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  005a9	85 c0		 test	 eax, eax
  005ab	74 10		 je	 SHORT $LN74@ProtocolCo

; 1114 : 				CGSellRequestRecv((LPPMSG_SELLREQUEST)aRecv, aIndex);

  005ad	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005b0	50		 push	 eax
  005b1	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  005b4	51		 push	 ecx
  005b5	e8 00 00 00 00	 call	 ?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z ; CGSellRequestRecv
  005ba	83 c4 08	 add	 esp, 8
$LN74@ProtocolCo:

; 1115 : 			break;

  005bd	e9 28 06 00 00	 jmp	 $LN1@ProtocolCo
$LN75@ProtocolCo:

; 1116 : 		case 0x34 :	//   
; 1117 : 			CGModifyRequestItem((LPPMSG_ITEMDURREPAIR)aRecv, aIndex);

  005c2	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005c5	50		 push	 eax
  005c6	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  005c9	51		 push	 ecx
  005ca	e8 00 00 00 00	 call	 ?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ; CGModifyRequestItem
  005cf	83 c4 08	 add	 esp, 8

; 1118 : 			break;

  005d2	e9 13 06 00 00	 jmp	 $LN1@ProtocolCo
$LN76@ProtocolCo:

; 1119 : 		case 0x36 :
; 1120 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  005d7	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  005da	50		 push	 eax
  005db	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  005df	51		 push	 ecx
  005e0	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  005e3	52		 push	 edx
  005e4	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  005e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  005ec	85 c0		 test	 eax, eax
  005ee	74 10		 je	 SHORT $LN77@ProtocolCo

; 1121 : 				CGTradeRequestSend((LPPMSG_TRADE_REQUEST)aRecv, aIndex);

  005f0	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005f3	50		 push	 eax
  005f4	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  005f7	51		 push	 ecx
  005f8	e8 00 00 00 00	 call	 ?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ; CGTradeRequestSend
  005fd	83 c4 08	 add	 esp, 8
$LN77@ProtocolCo:

; 1122 : 			break;

  00600	e9 e5 05 00 00	 jmp	 $LN1@ProtocolCo
$LN78@ProtocolCo:

; 1123 : 		case 0x37 :
; 1124 : 			CGTradeResponseRecv((LPPMSG_TRADE_RESPONSE)aRecv, aIndex);

  00605	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00608	50		 push	 eax
  00609	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0060c	51		 push	 ecx
  0060d	e8 00 00 00 00	 call	 ?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ; CGTradeResponseRecv
  00612	83 c4 08	 add	 esp, 8

; 1125 : 			break;

  00615	e9 d0 05 00 00	 jmp	 $LN1@ProtocolCo
$LN79@ProtocolCo:

; 1126 : 		case 0x3A :
; 1127 : 			CGTradeMoneyRecv((LPPMSG_TRADE_GOLD)aRecv, aIndex);

  0061a	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0061d	50		 push	 eax
  0061e	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00621	51		 push	 ecx
  00622	e8 00 00 00 00	 call	 ?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z ; CGTradeMoneyRecv
  00627	83 c4 08	 add	 esp, 8

; 1128 : 			break;

  0062a	e9 bb 05 00 00	 jmp	 $LN1@ProtocolCo
$LN80@ProtocolCo:

; 1129 : 		case 0x3C :
; 1130 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  0062f	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  00632	50		 push	 eax
  00633	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  00637	51		 push	 ecx
  00638	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0063b	52		 push	 edx
  0063c	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00641	83 c4 0c	 add	 esp, 12			; 0000000cH
  00644	85 c0		 test	 eax, eax
  00646	74 10		 je	 SHORT $LN81@ProtocolCo

; 1131 : 				CGTradeOkButtonRecv((LPPMSG_TRADE_OKBUTTON)aRecv, aIndex);

  00648	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0064b	50		 push	 eax
  0064c	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0064f	51		 push	 ecx
  00650	e8 00 00 00 00	 call	 ?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ; CGTradeOkButtonRecv
  00655	83 c4 08	 add	 esp, 8
$LN81@ProtocolCo:

; 1132 : 			break;

  00658	e9 8d 05 00 00	 jmp	 $LN1@ProtocolCo
$LN82@ProtocolCo:

; 1133 : 		case 0x3D :
; 1134 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  0065d	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  00660	50		 push	 eax
  00661	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  00665	51		 push	 ecx
  00666	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00669	52		 push	 edx
  0066a	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0066f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00672	85 c0		 test	 eax, eax
  00674	74 0c		 je	 SHORT $LN83@ProtocolCo

; 1135 : 				CGTradeCancelButtonRecv(aIndex);

  00676	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00679	50		 push	 eax
  0067a	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  0067f	83 c4 04	 add	 esp, 4
$LN83@ProtocolCo:

; 1136 : 			break;

  00682	e9 63 05 00 00	 jmp	 $LN1@ProtocolCo
$LN84@ProtocolCo:

; 1137 : #ifdef PERSONAL_SHOP_20040113		//   
; 1138 : 		case 0x3F :
; 1139 : 			{
; 1140 : 				LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;

  00687	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0068a	89 45 f0	 mov	 DWORD PTR _lpDef$4[ebp], eax

; 1141 : 				switch(lpDef->subcode) {

  0068d	8b 45 f0	 mov	 eax, DWORD PTR _lpDef$4[ebp]
  00690	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00694	89 4d a0	 mov	 DWORD PTR tv336[ebp], ecx
  00697	8b 55 a0	 mov	 edx, DWORD PTR tv336[ebp]
  0069a	83 ea 01	 sub	 edx, 1
  0069d	89 55 a0	 mov	 DWORD PTR tv336[ebp], edx
  006a0	83 7d a0 05	 cmp	 DWORD PTR tv336[ebp], 5
  006a4	77 60		 ja	 SHORT $LN10@ProtocolCo
  006a6	8b 45 a0	 mov	 eax, DWORD PTR tv336[ebp]
  006a9	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN154@ProtocolCo[eax*4]

; 1142 : 				case 0x00 :		
; 1143 : 					break;

  006b0	eb 54		 jmp	 SHORT $LN10@ProtocolCo
$LN86@ProtocolCo:

; 1144 : 				case 0x01 :			// [0x3F][0x01]	   
; 1145 : 					CGPShopReqSetItemPrice ((LPPMSG_REQ_PSHOP_SETITEMPRICE) aRecv, aIndex);

  006b2	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006b5	50		 push	 eax
  006b6	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  006b9	51		 push	 ecx
  006ba	e8 00 00 00 00	 call	 ?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ; CGPShopReqSetItemPrice
  006bf	83 c4 08	 add	 esp, 8

; 1146 : 					break;

  006c2	eb 42		 jmp	 SHORT $LN10@ProtocolCo
$LN87@ProtocolCo:

; 1147 : 				case 0x02 :			// [0x3F][0x02]	  ->      
; 1148 : 					CGPShopReqOpen ((LPPMSG_REQ_PSHOP_OPEN) aRecv, aIndex);

  006c4	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006c7	50		 push	 eax
  006c8	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  006cb	51		 push	 ecx
  006cc	e8 00 00 00 00	 call	 ?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z ; CGPShopReqOpen
  006d1	83 c4 08	 add	 esp, 8

; 1149 : 					break;

  006d4	eb 30		 jmp	 SHORT $LN10@ProtocolCo
$LN88@ProtocolCo:

; 1150 : 				case 0x03 :			// [0x3F][0x03]	 
; 1151 : 					CGPShopReqClose (aIndex);

  006d6	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006d9	50		 push	 eax
  006da	e8 00 00 00 00	 call	 ?CGPShopReqClose@@YAXH@Z ; CGPShopReqClose
  006df	83 c4 04	 add	 esp, 4

; 1152 : 					break;

  006e2	eb 22		 jmp	 SHORT $LN10@ProtocolCo
$LN89@ProtocolCo:

; 1153 : 				case 0x05 :			// [0x3F][0x05]	    
; 1154 : 					CGPShopReqBuyList ((LPPMSG_REQ_BUYLIST_FROM_PSHOP) aRecv, aIndex);

  006e4	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006e7	50		 push	 eax
  006e8	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  006eb	51		 push	 ecx
  006ec	e8 00 00 00 00	 call	 ?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ; CGPShopReqBuyList
  006f1	83 c4 08	 add	 esp, 8

; 1155 : 					break;

  006f4	eb 10		 jmp	 SHORT $LN10@ProtocolCo
$LN90@ProtocolCo:

; 1156 : 				case 0x06 :			// [0x3F][0x06]	   
; 1157 : 					CGPShopReqBuyItem ((LPPMSG_REQ_BUYITEM_FROM_PSHOP) aRecv, aIndex);

  006f6	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006f9	50		 push	 eax
  006fa	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  006fd	51		 push	 ecx
  006fe	e8 00 00 00 00	 call	 ?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItem
  00703	83 c4 08	 add	 esp, 8
$LN10@ProtocolCo:

; 1158 : 					//CGPShopReqBuyItemEx ((LPPMSG_REQ_BUYITEM_FROM_PSHOP) aRecv, aIndex, aIndex);
; 1159 : 					break;
; 1160 : 				}
; 1161 : 			}
; 1162 : 			break;

  00706	e9 df 04 00 00	 jmp	 $LN1@ProtocolCo
$LN91@ProtocolCo:

; 1163 : #endif
; 1164 : 		case 0x40 :	//   .
; 1165 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  0070b	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  0070e	50		 push	 eax
  0070f	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  00713	51		 push	 ecx
  00714	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00717	52		 push	 edx
  00718	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0071d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00720	85 c0		 test	 eax, eax
  00722	74 10		 je	 SHORT $LN92@ProtocolCo

; 1166 : 				CGPartyRequestRecv((LPPMSG_PARTYREQUEST)aRecv, aIndex);

  00724	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00727	50		 push	 eax
  00728	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0072b	51		 push	 ecx
  0072c	e8 00 00 00 00	 call	 ?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ; CGPartyRequestRecv
  00731	83 c4 08	 add	 esp, 8
$LN92@ProtocolCo:

; 1167 : 			break;

  00734	e9 b1 04 00 00	 jmp	 $LN1@ProtocolCo
$LN93@ProtocolCo:

; 1168 : 		case 0x41 :
; 1169 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  00739	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  0073c	50		 push	 eax
  0073d	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  00741	51		 push	 ecx
  00742	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00745	52		 push	 edx
  00746	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0074b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0074e	85 c0		 test	 eax, eax
  00750	74 10		 je	 SHORT $LN94@ProtocolCo

; 1170 : 				CGPartyRequestResultRecv((LPPMSG_PARTYREQUESTRESULT)aRecv, aIndex);

  00752	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00755	50		 push	 eax
  00756	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00759	51		 push	 ecx
  0075a	e8 00 00 00 00	 call	 ?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ; CGPartyRequestResultRecv
  0075f	83 c4 08	 add	 esp, 8
$LN94@ProtocolCo:

; 1171 : 			break;

  00762	e9 83 04 00 00	 jmp	 $LN1@ProtocolCo
$LN95@ProtocolCo:

; 1172 : 		case 0x42 :
; 1173 : 			CGPartyList(aIndex);

  00767	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0076a	50		 push	 eax
  0076b	e8 00 00 00 00	 call	 ?CGPartyList@@YAXH@Z	; CGPartyList
  00770	83 c4 04	 add	 esp, 4

; 1174 : 			break;

  00773	e9 72 04 00 00	 jmp	 $LN1@ProtocolCo
$LN96@ProtocolCo:

; 1175 : 		case 0x43 :		
; 1176 : 			if( PacketCheckTime(&gObj[aIndex]) == TRUE ) 

  00778	69 45 14 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0077f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00785	50		 push	 eax
  00786	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  0078b	83 c4 04	 add	 esp, 4
  0078e	83 f8 01	 cmp	 eax, 1
  00791	75 10		 jne	 SHORT $LN97@ProtocolCo

; 1177 : 				CGPartyDelUser((LPPMSG_PARTYDELUSER)aRecv, aIndex);	

  00793	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00796	50		 push	 eax
  00797	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0079a	51		 push	 ecx
  0079b	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  007a0	83 c4 08	 add	 esp, 8
$LN97@ProtocolCo:

; 1178 : 			break;

  007a3	e9 42 04 00 00	 jmp	 $LN1@ProtocolCo
$LN98@ProtocolCo:

; 1179 : 		case 0x50 :
; 1180 : 			CGGuildRequestRecv((LPPMSG_GUILDJOINQ)aRecv, aIndex);

  007a8	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007ab	50		 push	 eax
  007ac	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  007af	51		 push	 ecx
  007b0	e8 00 00 00 00	 call	 ?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z ; CGGuildRequestRecv
  007b5	83 c4 08	 add	 esp, 8

; 1181 : 			break;

  007b8	e9 2d 04 00 00	 jmp	 $LN1@ProtocolCo
$LN99@ProtocolCo:

; 1182 : 		case 0x51 :
; 1183 : 			CGGuildRequestResultRecv((LPPMSG_GUILDQRESULT)aRecv, aIndex);

  007bd	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007c0	50		 push	 eax
  007c1	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  007c4	51		 push	 ecx
  007c5	e8 00 00 00 00	 call	 ?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ; CGGuildRequestResultRecv
  007ca	83 c4 08	 add	 esp, 8

; 1184 : 			break;

  007cd	e9 18 04 00 00	 jmp	 $LN1@ProtocolCo
$LN100@ProtocolCo:

; 1185 : 		case 0x52 :
; 1186 : 			CGGuildListAll(aIndex);

  007d2	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007d5	50		 push	 eax
  007d6	e8 00 00 00 00	 call	 ?CGGuildListAll@@YAXH@Z	; CGGuildListAll
  007db	83 c4 04	 add	 esp, 4

; 1187 : 			break;

  007de	e9 07 04 00 00	 jmp	 $LN1@ProtocolCo
$LN101@ProtocolCo:

; 1188 : 		case 0x53 :
; 1189 : 			CGGuildDelUser((LPPMSG_GUILDDELUSER)aRecv, aIndex);

  007e3	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007e6	50		 push	 eax
  007e7	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  007ea	51		 push	 ecx
  007eb	e8 00 00 00 00	 call	 ?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z ; CGGuildDelUser
  007f0	83 c4 08	 add	 esp, 8

; 1190 : 			break;

  007f3	e9 f2 03 00 00	 jmp	 $LN1@ProtocolCo
$LN102@ProtocolCo:

; 1191 : 		case 0x54 : 
; 1192 : 			CGGuildMasterAnswerRecv((LPPMSG_GUILDMASTERANSWER)aRecv, aIndex);

  007f8	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  007fb	50		 push	 eax
  007fc	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  007ff	51		 push	 ecx
  00800	e8 00 00 00 00	 call	 ?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ; CGGuildMasterAnswerRecv
  00805	83 c4 08	 add	 esp, 8

; 1193 : 			break;

  00808	e9 dd 03 00 00	 jmp	 $LN1@ProtocolCo
$LN103@ProtocolCo:

; 1194 : 		case 0x55 :
; 1195 : 			CGGuildMasterInfoSave(aIndex, (LPPMSG_GUILDINFOSAVE)aRecv);

  0080d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00810	50		 push	 eax
  00811	8b 4d 14	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00814	51		 push	 ecx
  00815	e8 00 00 00 00	 call	 ?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ; CGGuildMasterInfoSave
  0081a	83 c4 08	 add	 esp, 8

; 1196 : 			break;

  0081d	e9 c8 03 00 00	 jmp	 $LN1@ProtocolCo
$LN104@ProtocolCo:

; 1197 : 		case 0x57 :
; 1198 : 			CGGuildMasterCreateCancel(aIndex);

  00822	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00825	50		 push	 eax
  00826	e8 00 00 00 00	 call	 ?CGGuildMasterCreateCancel@@YAXH@Z ; CGGuildMasterCreateCancel
  0082b	83 c4 04	 add	 esp, 4

; 1199 : 			break;

  0082e	e9 b7 03 00 00	 jmp	 $LN1@ProtocolCo
$LN105@ProtocolCo:

; 1200 : 		case 0x61 :
; 1201 : 			GCGuildWarRequestSendRecv((LPPMSG_GUILDWARSEND_RESULT)aRecv, aIndex);

  00833	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00836	50		 push	 eax
  00837	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0083a	51		 push	 ecx
  0083b	e8 00 00 00 00	 call	 ?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ; GCGuildWarRequestSendRecv
  00840	83 c4 08	 add	 esp, 8

; 1202 : 			break;

  00843	e9 a2 03 00 00	 jmp	 $LN1@ProtocolCo
$LN106@ProtocolCo:

; 1203 : 
; 1204 : 		case 0x5E :
; 1205 : 			//CGShellExecution(aRecv, aIndex);
; 1206 : 			break;

  00848	e9 9d 03 00 00	 jmp	 $LN1@ProtocolCo
$LN107@ProtocolCo:

; 1207 : 
; 1208 : #ifdef MODIFY_GUILD_VIEWPORT_01_20040701
; 1209 : 		case 0x66 :
; 1210 : 			GCGuildViewportInfo( (LPPMSG_REQ_GUILDVIEWPORT)aRecv, aIndex );
; 1211 : 			break;
; 1212 : #endif
; 1213 : 
; 1214 : #ifdef MAP_SERVER_WORK_20041030		//     -  <-> 
; 1215 : 		case 0xB1 :
; 1216 : 			{
; 1217 : 				LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;
; 1218 : 				switch(lpDef->subcode) {
; 1219 : 				//----------------------------------------------------------------------------
; 1220 : 				// CG [0xB1][0x01]     ,  (0xC3)
; 1221 : 				//----------------------------------------------------------------------------
; 1222 : 				case 0x01 :		
; 1223 : 					if( DataEncryptCheck(aIndex, protoNum, Encrypt) )
; 1224 : 						CGReqMapSvrAuth	((LPPMSG_REQ_MAPSERVERAUTH)aRecv, aIndex);
; 1225 : 					break;
; 1226 : 				}
; 1227 : 			}
; 1228 : 			break;
; 1229 : #endif
; 1230 : 
; 1231 : #ifdef MU_CASTLESIEGE_CL_PROTOCOL_20041122	//   -    ,  
; 1232 : 		case 0xB2 :
; 1233 : 			{
; 1234 : 				LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;
; 1235 : 				switch(lpDef->subcode) {
; 1236 : 				//----------------------------------------------------------------------------
; 1237 : 				// CG [0xB2][0x00]    
; 1238 : 				//----------------------------------------------------------------------------
; 1239 : 				case 0x00 :		
; 1240 : 					CGReqCastleSiegeState	((LPPMSG_REQ_CASTLESIEGESTATE)aRecv, aIndex);
; 1241 : 					break;
; 1242 : 				//----------------------------------------------------------------------------
; 1243 : 				// CG [0xB2][0x01]   
; 1244 : 				//----------------------------------------------------------------------------
; 1245 : 				case 0x01 :		
; 1246 : 					CGReqRegCastleSiege		((LPPMSG_REQ_REGCASTLESIEGE)aRecv, aIndex);
; 1247 : 					break;
; 1248 : 				//----------------------------------------------------------------------------
; 1249 : 				// CG [0xB2][0x02]   
; 1250 : 				//----------------------------------------------------------------------------
; 1251 : 				case 0x02 :		
; 1252 : 					CGReqGiveUpCastleSiege	((LPPMSG_REQ_GIVEUPCASTLESIEGE)aRecv, aIndex);
; 1253 : 					break;
; 1254 : 				//----------------------------------------------------------------------------
; 1255 : 				// CG [0xB2][0x03]      
; 1256 : 				//----------------------------------------------------------------------------
; 1257 : 				case 0x03 :		
; 1258 : 					CGReqGuildRegInfo		((LPPMSG_REQ_GUILDREGINFO)aRecv, aIndex);
; 1259 : 					break;
; 1260 : 				//----------------------------------------------------------------------------
; 1261 : 				// CG [0xB2][0x04]      
; 1262 : 				//----------------------------------------------------------------------------
; 1263 : 				case 0x04 :		
; 1264 : 					CGReqRegGuildMark		((LPPMSG_REQ_REGGUILDMARK)aRecv, aIndex);
; 1265 : 					break;
; 1266 : 				//----------------------------------------------------------------------------
; 1267 : 				// CG [0xB2][0x05]  NPC   -> ,  
; 1268 : 				//----------------------------------------------------------------------------
; 1269 : 				case 0x05 :		
; 1270 : 					CGReqNpcBuy				((LPPMSG_REQ_NPCBUY)aRecv, aIndex);
; 1271 : 					break;
; 1272 : 				//----------------------------------------------------------------------------
; 1273 : 				// CG [0xB2][0x06]  NPC   -> ,  
; 1274 : 				//----------------------------------------------------------------------------
; 1275 : 				case 0x06:		
; 1276 : 					CGReqNpcRepair			((LPPMSG_REQ_NPCREPAIR)aRecv, aIndex);
; 1277 : 					break;
; 1278 : 				//----------------------------------------------------------------------------
; 1279 : 				// CG [0xB2][0x07]  NPC   -> ,  
; 1280 : 				//----------------------------------------------------------------------------
; 1281 : 				case 0x07:		
; 1282 : 					CGReqNpcUpgrade			((LPPMSG_REQ_NPCUPGRADE)aRecv, aIndex);
; 1283 : 					break;
; 1284 : 				//----------------------------------------------------------------------------
; 1285 : 				// CG [0xB2][0x08]   ,    -> ,  
; 1286 : 				//----------------------------------------------------------------------------
; 1287 : 				 case 0X08:
; 1288 : 					CGReqTaxMoneyInfo		((LPPMSG_REQ_TAXMONEYINFO)aRecv, aIndex);
; 1289 : 					break;
; 1290 : 				//----------------------------------------------------------------------------
; 1291 : 				// CG [0xB2][0x09]      -> ,  
; 1292 : 				//----------------------------------------------------------------------------
; 1293 : 				 case 0X09:
; 1294 : 					CGReqTaxRateChange		((LPPMSG_REQ_TAXRATECHANGE)aRecv, aIndex);
; 1295 : 					break;
; 1296 : 				//----------------------------------------------------------------------------
; 1297 : 				// CG [0xB2][0x10]      -> ,  
; 1298 : 				//----------------------------------------------------------------------------
; 1299 : 				 case 0X10:
; 1300 : 					CGReqMoneyDrawOut		((LPPMSG_REQ_MONEYDRAWOUT)aRecv, aIndex);
; 1301 : 					break;
; 1302 : 				//----------------------------------------------------------------------------
; 1303 : 				// CG [0xB2][0x12]      (0xC1)
; 1304 : 				//----------------------------------------------------------------------------
; 1305 : 				case 0X12:
; 1306 : 					CGReqCsGateOperate		((LPPMSG_REQ_CSGATEOPERATE)aRecv, aIndex);
; 1307 : 					break;
; 1308 : 				//----------------------------------------------------------------------------
; 1309 : 				// CG [0xB2][0x1B]       (0xC1)
; 1310 : 				//----------------------------------------------------------------------------
; 1311 : 				case 0X1B:
; 1312 : 					CGReqCsMiniMapData		((LPPMSG_REQ_MINIMAPDATA)aRecv, aIndex);
; 1313 : 					break;
; 1314 : 				//----------------------------------------------------------------------------
; 1315 : 				// CG [0xB2][0x1C]       (0xC1)
; 1316 : 				//----------------------------------------------------------------------------
; 1317 : 				case 0X1C:
; 1318 : 					CGReqStopCsMiniMapData	((LPPMSG_REQ_STOPMINIMAPDATA)aRecv, aIndex);
; 1319 : 					break;
; 1320 : 				//----------------------------------------------------------------------------
; 1321 : 				// CG [0xB2][0x1D]       (0xC1)
; 1322 : 				//----------------------------------------------------------------------------
; 1323 : 				case 0X1D:
; 1324 : 					CGReqCsSendCommand		((LPPMSG_REQ_CSCOMMAND)aRecv, aIndex);
; 1325 : 					break;
; 1326 : 				//----------------------------------------------------------------------------
; 1327 : 				// CG [0xB2][0x1F]       (0xC1)
; 1328 : 				//----------------------------------------------------------------------------
; 1329 : 				case 0X1F:
; 1330 : 					CGReqCsSetEnterHuntZone	((LPPMSG_REQ_CSHUNTZONEENTER) aRecv, aIndex);
; 1331 : 					break;
; 1332 : 				}
; 1333 : 			}
; 1334 : 			break;
; 1335 : 		//----------------------------------------------------------------------------
; 1336 : 		// CG [0xB3]  DB   NPC   -> ,  
; 1337 : 		//----------------------------------------------------------------------------
; 1338 : 		case 0xB3 :		
; 1339 : 			CGReqNpcDbList			((LPPMSG_REQ_NPCDBLIST)aRecv, aIndex);
; 1340 : 			break;
; 1341 : 		//----------------------------------------------------------------------------
; 1342 : 		// CG [0xB4]    
; 1343 : 		//----------------------------------------------------------------------------
; 1344 : 		case 0xB4 :		
; 1345 : 			CGReqCsRegGuildList		((LPPMSG_REQ_CSREGGUILDLIST)aRecv, aIndex);
; 1346 : 			break;
; 1347 : 		//----------------------------------------------------------------------------
; 1348 : 		// CG [0xB5]    
; 1349 : 		//----------------------------------------------------------------------------
; 1350 : 		case 0x0B5 :
; 1351 : 			CGReqCsAttkGuildList	((LPPMSG_REQ_CSATTKGUILDLIST)aRecv, aIndex);
; 1352 : 			break;
; 1353 : #endif
; 1354 : 		
; 1355 : #ifdef ADD_NEW_WEAPON_FOR_CASTLE_01_20041116
; 1356 : 		case 0xB7 :
; 1357 : 			{
; 1358 : 				LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;
; 1359 : 				switch(lpDef->subcode) 
; 1360 : 				{
; 1361 : 				//    .
; 1362 : 				case 0x01 :		
; 1363 : 					CGReqWeaponUse	((LPPMSG_REQ_USEWEAPON)aRecv, aIndex);
; 1364 : 					break;
; 1365 : 				//    .
; 1366 : 				case 0x04:
; 1367 : 					CGReqWeaponDamageValue((LPPMSG_REQ_WEAPON_DAMAGE_VALUE)aRecv, aIndex);
; 1368 : 					break;
; 1369 : 				}
; 1370 : 				
; 1371 : 			}
; 1372 : 			break;
; 1373 : 
; 1374 : #endif
; 1375 : 
; 1376 : 		case 0xB9 :
; 1377 : 			{
; 1378 : 				LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;

  0084d	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00850	89 45 ec	 mov	 DWORD PTR _lpDef$3[ebp], eax

; 1379 : 				switch(lpDef->subcode) 

  00853	8b 45 ec	 mov	 eax, DWORD PTR _lpDef$3[ebp]
  00856	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0085a	89 4d a0	 mov	 DWORD PTR tv386[ebp], ecx

; 1380 : 				{
; 1381 : #ifdef ADD_NEW_CASTLE_FLAG_01_20041227
; 1382 : 				//    .
; 1383 : 				case 0x02 :		
; 1384 : 					CGReqGuildMarkOfCastleOwner	((LPPMSG_REQ_GUILDMARK_OF_CASTLEOWNER)aRecv, aIndex);
; 1385 : 					break;
; 1386 : #endif
; 1387 : 
; 1388 : #ifdef ADD_CASTLE_HUNTZONE_NPC_01_20050111
; 1389 : //				case 0x04 :
; 1390 : //					CGReqSettingOfCastleHuntZoneEntrance((LPPMSG_REQ_SETTING_OF_CASTLE_HUNTZONE)aRecv, aIndex);
; 1391 : //					break;
; 1392 : 
; 1393 : 				case 0x05 :
; 1394 : 					CGReqCastleHuntZoneEntrance((LPPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE)aRecv, aIndex);
; 1395 : 					break;
; 1396 : #endif
; 1397 : 				}
; 1398 : 			}
; 1399 : 			break;

  0085d	e9 88 03 00 00	 jmp	 $LN1@ProtocolCo
$LN108@ProtocolCo:

; 1400 : 
; 1401 : 
; 1402 : #ifdef JEWEL_MIX_SYSTEM_20050309			//   /  
; 1403 : 		case 0xBC :
; 1404 : 			{
; 1405 : 				LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;
; 1406 : 				switch(lpDef->subcode) 
; 1407 : 				{
; 1408 : 				case 0x00 :					//  
; 1409 : 					CGReqJewelMix((LPPMSG_REQ_JEWEL_MIX)aRecv, aIndex);
; 1410 : 					break;
; 1411 : 				case 0x01 :					//  
; 1412 : 					CGReqJewelUnMix((LPPMSG_REQ_JEWEL_UNMIX)aRecv, aIndex);
; 1413 : 					break;
; 1414 : 				}
; 1415 : 			}
; 1416 : 			break;
; 1417 : #endif
; 1418 : 
; 1419 : #ifdef MU_CRYWOLF_CL_PROTOCOL_20050505 //  -    ,  
; 1420 : 		case 0xBD :
; 1421 : 			{
; 1422 : 				LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;
; 1423 : 				switch(lpDef->subcode) 
; 1424 : 				{
; 1425 : 				case 0x00 :
; 1426 : 					// [0xBD][0x00]  / 
; 1427 : 					CGReqCrywolfInfo((LPPMSG_REQ_CRYWOLF_INFO)aRecv, aIndex);
; 1428 : 					break;
; 1429 : 				case 0x03 :
; 1430 : 					// [0xBD][0x03]    
; 1431 : 					CGReqAlatrContract((LPPMSG_REQ_CRYWOLF_ALTAR_CONTRACT)aRecv, aIndex );
; 1432 : 					break;
; 1433 : 				case 0x09 :
; 1434 : 					CGReqPlusChaosRate((LPPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE)aRecv, aIndex );
; 1435 : 					break;
; 1436 : 				}
; 1437 : 				
; 1438 : 
; 1439 : 			}
; 1440 : 
; 1441 : 			break;
; 1442 : 
; 1443 : 		case 0xBE :
; 1444 : 			{
; 1445 : 				
; 1446 : 			}
; 1447 : #endif
; 1448 : 
; 1449 : 			
; 1450 : #ifdef ADD_NEW_GUILD_01_20040913
; 1451 : 		case 0xE1 :
; 1452 : 			CGGuildAssignStatus( (LPPMSG_GUILD_ASSIGN_STATUS_REQ)aRecv, aIndex );
; 1453 : 			break;
; 1454 : #endif
; 1455 : 
; 1456 : #ifdef ADD_NEW_GUILD_02_20040922
; 1457 : 		case 0xE2 :
; 1458 : 			CGGuildAssignType( (LPPMSG_GUILD_ASSIGN_TYPE_REQ)aRecv, aIndex );
; 1459 : 			break;
; 1460 : #endif
; 1461 : 			
; 1462 : #ifdef ADD_NEW_UNION_01_20041006
; 1463 : 		case 0xE5 :
; 1464 : 			//   /  
; 1465 : 			CGRelationShipReqJoinBreakOff( (LPPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ)aRecv, aIndex );
; 1466 : 			break;
; 1467 : 		case 0xE6 :
; 1468 : 			CGRelationShipAnsJoinBreakOff( (LPPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS)aRecv, aIndex );
; 1469 : 			break;
; 1470 : 		case 0xE9 :
; 1471 : 			CGUnionList( (LPPMSG_UNIONLIST_REQ)aRecv, aIndex ); 
; 1472 : 			break;
; 1473 : #endif
; 1474 : 
; 1475 : #ifdef ADD_ABILITY_OF_UNIONMASTER_TO_KICK_OUT_UNIONMEMBER_01_20050418
; 1476 : 		case 0xEB :
; 1477 : 			{
; 1478 : 				LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;
; 1479 : 				switch(lpDef->subcode) 
; 1480 : 				{
; 1481 : 				//       .
; 1482 : 				case 0x01 :	
; 1483 : 					CGRelationShipReqKickOutUnionMember( (LPPMSG_KICKOUT_UNIONMEMBER_REQ)aRecv, aIndex );
; 1484 : 					break;
; 1485 : 				}
; 1486 : 			}
; 1487 : 			break;
; 1488 : #endif
; 1489 : 			
; 1490 : 		case 0x71 :
; 1491 : 			GCPingSendRecv((LPPMSG_PING_RESULT)aRecv, aIndex);

  00862	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00865	50		 push	 eax
  00866	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00869	51		 push	 ecx
  0086a	e8 00 00 00 00	 call	 ?GCPingSendRecv@@YAXPAUPMSG_PING_RESULT@@H@Z ; GCPingSendRecv
  0086f	83 c4 08	 add	 esp, 8

; 1492 : 			break;

  00872	e9 73 03 00 00	 jmp	 $LN1@ProtocolCo
$LN109@ProtocolCo:

; 1493 : 
; 1494 : 		case 0x72 :
; 1495 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )

  00877	8b 45 18	 mov	 eax, DWORD PTR _Encrypt$[ebp]
  0087a	50		 push	 eax
  0087b	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  0087f	51		 push	 ecx
  00880	8b 55 14	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00883	52		 push	 edx
  00884	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00889	83 c4 0c	 add	 esp, 12			; 0000000cH
  0088c	85 c0		 test	 eax, eax
  0088e	74 10		 je	 SHORT $LN110@ProtocolCo

; 1496 : 				GCPacketCheckSumRecv((LPPMSG_PACKETCHECKSUM)aRecv, aIndex);

  00890	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00893	50		 push	 eax
  00894	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00897	51		 push	 ecx
  00898	e8 00 00 00 00	 call	 ?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ; GCPacketCheckSumRecv
  0089d	83 c4 08	 add	 esp, 8
$LN110@ProtocolCo:

; 1497 : 			break;

  008a0	e9 45 03 00 00	 jmp	 $LN1@ProtocolCo
$LN111@ProtocolCo:

; 1498 : 
; 1499 : #ifdef NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 1500 : 			case 0x73 :
; 1501 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )
; 1502 : 				GCNPggCheckSumRecv((LPPMSG_NPROTECTGGCHECKSUM)aRecv, aIndex);
; 1503 : 			break;
; 1504 : #else
; 1505 : 	#if defined NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_10_20050411 || defined NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_20_20050411
; 1506 : 			case 0x73 :
; 1507 : 			if( DataEncryptCheck(aIndex, protoNum, Encrypt) )
; 1508 : 				GCNPggCheckSumRecv((LPPMSG_NPROTECTGGCHECKSUM)aRecv, aIndex);
; 1509 : 			break;
; 1510 : 	#endif // NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_10_20050411 || NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_20_20050411
; 1511 : #endif // NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 1512 : 
; 1513 : 		case 0x81 :
; 1514 : 			CGWarehouseMoneyInOut(aIndex, (LPPMSG_WAREHOUSEMONEYINOUT)aRecv);

  008a5	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  008a8	50		 push	 eax
  008a9	8b 4d 14	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  008ac	51		 push	 ecx
  008ad	e8 00 00 00 00	 call	 ?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ; CGWarehouseMoneyInOut
  008b2	83 c4 08	 add	 esp, 8

; 1515 : 			break;

  008b5	e9 30 03 00 00	 jmp	 $LN1@ProtocolCo
$LN112@ProtocolCo:

; 1516 : 		case 0x82 :
; 1517 : 			CGWarehouseUseEnd(aIndex);

  008ba	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  008bd	50		 push	 eax
  008be	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  008c3	83 c4 04	 add	 esp, 4

; 1518 : 			break;

  008c6	e9 1f 03 00 00	 jmp	 $LN1@ProtocolCo
$LN113@ProtocolCo:

; 1519 : 		case 0x83 :
; 1520 : 			GCWarehouseRecivePassword(aIndex, (LPPMSG_WAREHOUSEPASSSEND)aRecv);

  008cb	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  008ce	50		 push	 eax
  008cf	8b 4d 14	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  008d2	51		 push	 ecx
  008d3	e8 00 00 00 00	 call	 ?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ; GCWarehouseRecivePassword
  008d8	83 c4 08	 add	 esp, 8

; 1521 : 			break;

  008db	e9 0a 03 00 00	 jmp	 $LN1@ProtocolCo
$LN114@ProtocolCo:

; 1522 : 		case 0x86 :
; 1523 : 
; 1524 : #ifdef 	CHAOS_MIX_UPGRADE
; 1525 : 			CGChaosBoxItemMixButtonClick((LPPMSG_CHAOSMIX) aRecv, aIndex);

  008e0	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  008e3	50		 push	 eax
  008e4	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  008e7	51		 push	 ecx
  008e8	e8 00 00 00 00	 call	 ?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ; CGChaosBoxItemMixButtonClick
  008ed	83 c4 08	 add	 esp, 8

; 1526 : #else			
; 1527 : 			CGChaosBoxItemMixButtonClick(aIndex);
; 1528 : #endif
; 1529 : 			break;

  008f0	e9 f5 02 00 00	 jmp	 $LN1@ProtocolCo
$LN115@ProtocolCo:

; 1530 : 		case 0x87 :
; 1531 : 			CGChaosBoxUseEnd(aIndex);

  008f5	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  008f8	50		 push	 eax
  008f9	e8 00 00 00 00	 call	 ?CGChaosBoxUseEnd@@YAXH@Z ; CGChaosBoxUseEnd
  008fe	83 c4 04	 add	 esp, 4

; 1532 : 			break;

  00901	e9 e4 02 00 00	 jmp	 $LN1@ProtocolCo
$LN116@ProtocolCo:

; 1533 : 			
; 1534 : 		//    
; 1535 : 		case 0x90 :
; 1536 : 			GCReqmoveDevilSquare((LPPMSG_REQ_MOVEDEVILSQUARE)aRecv, aIndex);

  00906	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00909	50		 push	 eax
  0090a	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0090d	51		 push	 ecx
  0090e	e8 00 00 00 00	 call	 ?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; GCReqmoveDevilSquare
  00913	83 c4 08	 add	 esp, 8

; 1537 : 			break;

  00916	e9 cf 02 00 00	 jmp	 $LN1@ProtocolCo
$LN117@ProtocolCo:

; 1538 : 
; 1539 : 		//  
; 1540 : 		case 0x91 :			
; 1541 : 			GCReqDevilSquareRemainTime((LPPMSG_REQ_DEVILSQUARE_REMAINTIME )aRecv, aIndex);

  0091b	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0091e	50		 push	 eax
  0091f	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00922	51		 push	 ecx
  00923	e8 00 00 00 00	 call	 ?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ; GCReqDevilSquareRemainTime
  00928	83 c4 08	 add	 esp, 8

; 1542 : 			break;

  0092b	e9 ba 02 00 00	 jmp	 $LN1@ProtocolCo
$LN118@ProtocolCo:

; 1543 : 
; 1544 : 		case 0x95:
; 1545 : 			GCRegEventChipRecv((LPPMSG_REGEVENTCHIP) aRecv, aIndex);

  00930	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00933	50		 push	 eax
  00934	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00937	51		 push	 ecx
  00938	e8 00 00 00 00	 call	 ?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ; GCRegEventChipRecv
  0093d	83 c4 08	 add	 esp, 8

; 1546 : 			break;

  00940	e9 a5 02 00 00	 jmp	 $LN1@ProtocolCo
$LN119@ProtocolCo:

; 1547 : 		case 0x96 :
; 1548 : 			GCGetMutoNumRecv( (LPPMSG_GETMUTONUMBER) aRecv, aIndex);

  00945	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00948	50		 push	 eax
  00949	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0094c	51		 push	 ecx
  0094d	e8 00 00 00 00	 call	 ?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ; GCGetMutoNumRecv
  00952	83 c4 08	 add	 esp, 8

; 1549 : 			break;

  00955	e9 90 02 00 00	 jmp	 $LN1@ProtocolCo
$LN120@ProtocolCo:

; 1550 : 
; 1551 : 		//   
; 1552 : 		case 0x97 :
; 1553 : 			GCUseEndEventChipRescv( aIndex);

  0095a	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0095d	50		 push	 eax
  0095e	e8 00 00 00 00	 call	 ?GCUseEndEventChipRescv@@YAXH@Z ; GCUseEndEventChipRescv
  00963	83 c4 04	 add	 esp, 4

; 1554 : 			break;

  00966	e9 7f 02 00 00	 jmp	 $LN1@ProtocolCo
$LN121@ProtocolCo:

; 1555 : 
; 1556 : 		//   
; 1557 : 		case 0x98 :
; 1558 : 			GCUseRenaChangeZenRecv( (LPPMSG_EXCHANGE_EVENTCHIP) aRecv, aIndex);

  0096b	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0096e	50		 push	 eax
  0096f	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00972	51		 push	 ecx
  00973	e8 00 00 00 00	 call	 ?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ; GCUseRenaChangeZenRecv
  00978	83 c4 08	 add	 esp, 8

; 1559 : 			break;

  0097b	e9 6a 02 00 00	 jmp	 $LN1@ProtocolCo
$LN122@ProtocolCo:

; 1560 : 
; 1561 : #ifdef GAMESERVER_DIVISION		
; 1562 : 		case 0x99 :	//   
; 1563 : 			CGReqMoveOtherServer( (LPPMSG_REQ_MOVE_OTHERSERVER) aRecv, aIndex);
; 1564 : 			break;
; 1565 : #endif
; 1566 : 			
; 1567 : #ifdef NEW_SKILL_FORSKYLAND
; 1568 : 		//   
; 1569 : 		case 0xA0:
; 1570 : 			CGRequestQuestInfo( aIndex);

  00980	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00983	50		 push	 eax
  00984	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo
  00989	83 c4 04	 add	 esp, 4

; 1571 : 			break;

  0098c	e9 59 02 00 00	 jmp	 $LN1@ProtocolCo
$LN123@ProtocolCo:

; 1572 : 
; 1573 : 		//     
; 1574 : 		case 0xA2:
; 1575 : 			CGSetQuestState((LPPMSG_SETQUEST) aRecv, aIndex);

  00991	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00994	50		 push	 eax
  00995	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00998	51		 push	 ecx
  00999	e8 00 00 00 00	 call	 ?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z ; CGSetQuestState
  0099e	83 c4 08	 add	 esp, 8

; 1576 : 			break;

  009a1	e9 44 02 00 00	 jmp	 $LN1@ProtocolCo
$LN124@ProtocolCo:

; 1577 : #endif
; 1578 : 
; 1579 : #ifdef DARKLORD_WORK
; 1580 : 		case 0xA7:		
; 1581 : 			CGRequestPetItemCommand((LPPMSG_REQUEST_PET_ITEM_COMMAND) aRecv, aIndex);

  009a6	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009a9	50		 push	 eax
  009aa	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  009ad	51		 push	 ecx
  009ae	e8 00 00 00 00	 call	 ?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ; CGRequestPetItemCommand
  009b3	83 c4 08	 add	 esp, 8

; 1582 : 			break;

  009b6	e9 2f 02 00 00	 jmp	 $LN1@ProtocolCo
$LN125@ProtocolCo:

; 1583 : 
; 1584 : 		case 0xA9:		
; 1585 : 			CGRequestPetItemInfo((LPPMSG_REQUEST_PET_ITEMINFO) aRecv, aIndex);

  009bb	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009be	50		 push	 eax
  009bf	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  009c2	51		 push	 ecx
  009c3	e8 00 00 00 00	 call	 ?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ; CGRequestPetItemInfo
  009c8	83 c4 08	 add	 esp, 8

; 1586 : 			break;

  009cb	e9 1a 02 00 00	 jmp	 $LN1@ProtocolCo
$LN126@ProtocolCo:

; 1587 : #endif
; 1588 : 
; 1589 : #ifdef DUEL_SYSTEM_20031028
; 1590 : #ifdef ADD_NEWPVP_PKFIELD
; 1591 : 		case MASK_NEWPVP:
; 1592 : 			{
; 1593 : 				LPPMSG_DEFAULT2 lpDef = reinterpret_cast<LPPMSG_DEFAULT2>(aRecv);
; 1594 : 				if( lpDef->subcode & 0xFF == 0)
; 1595 : 					break;
; 1596 : 
; 1597 : 				WORD wPacketType = MAKEWORD(lpDef->subcode, MASK_NEWPVP);
; 1598 : 				switch (wPacketType)
; 1599 : 				{
; 1600 : 				case MSG_DUEL_INVITE:
; 1601 : 					{
; 1602 : 						LPPMSG_REQ_DUEL_INVITE lpReq = reinterpret_cast<LPPMSG_REQ_DUEL_INVITE>(aRecv);
; 1603 : 						int nRet = OnCGInviteDuel(lpReq, aIndex);
; 1604 : 						if (E_FAILED(nRet))
; 1605 : 						{
; 1606 : 							PMSG_ANS_DUEL_INVITE res = {0,};
; 1607 : 							res.h.c = PMHC_BYTE;
; 1608 : 							res.h.size = sizeof(res);
; 1609 : 							res.h.headcode = HIBYTE(MSG_DUEL_INVITE);
; 1610 : 							res.h.subcode = LOBYTE(MSG_DUEL_INVITE);
; 1611 : 							res.nResult = nRet;
; 1612 : 							DataSend(aIndex, (LPBYTE)&res, res.h.size);
; 1613 : 						}
; 1614 : 					}
; 1615 : 					break;
; 1616 : 				case MSG_DUEL_ANSWER:
; 1617 : 					{
; 1618 : 						LPPMSG_ANS_DUEL_ANSWER lpReq = reinterpret_cast<LPPMSG_ANS_DUEL_ANSWER>(aRecv);
; 1619 : 						int nRet = OnCGAnswerDuel(lpReq, aIndex);
; 1620 : 						if (E_FAILED(nRet))
; 1621 : 						{
; 1622 : 						}
; 1623 : 					}
; 1624 : 					break;
; 1625 : 				case MSG_DUEL_LEAVE:
; 1626 : 					{
; 1627 : 						LPPMSG_REQ_DUEL_LEAVE lpReq = reinterpret_cast<LPPMSG_REQ_DUEL_LEAVE>(aRecv);
; 1628 : 						int nRet = OnCGLeaveDuel(lpReq, aIndex);
; 1629 : 						if (E_FAILED(nRet))
; 1630 : 						{
; 1631 : 							PMSG_ANS_DUEL_LEAVE res = {0,};
; 1632 : 							res.h.c = PMHC_BYTE;
; 1633 : 							res.h.size = sizeof(res);
; 1634 : 							res.h.headcode = HIBYTE(MSG_DUEL_LEAVE);
; 1635 : 							res.h.subcode = LOBYTE(MSG_DUEL_LEAVE);
; 1636 : 							DataSend(aIndex, (LPBYTE)&res, res.h.size);
; 1637 : 						}
; 1638 : 					}
; 1639 : 					break;
; 1640 : 				case MSG_DUEL_JOINCNANNEL:
; 1641 : 					{
; 1642 : 						LPPMSG_REQ_DUEL_JOINCNANNEL lpReq = reinterpret_cast<LPPMSG_REQ_DUEL_JOINCNANNEL>(aRecv);
; 1643 : 						int nRet = OnDuelChannelJoin(lpReq, aIndex);
; 1644 : 						if (E_FAILED(nRet))
; 1645 : 						{
; 1646 : 							PMSG_ANS_DUEL_JOINCNANNEL res = {0,};
; 1647 : 							res.h.c = PMHC_BYTE;
; 1648 : 							res.h.size = sizeof(res);
; 1649 : 							res.h.headcode = HIBYTE(MSG_DUEL_JOINCNANNEL);
; 1650 : 							res.h.subcode = LOBYTE(MSG_DUEL_JOINCNANNEL);
; 1651 : 							res.nResult = nRet;
; 1652 : 							DataSend(aIndex, (LPBYTE)&res, res.h.size);
; 1653 : 						}
; 1654 : 					}
; 1655 : 					break;
; 1656 : 				case MSG_DUEL_LEAVECNANNEL:
; 1657 : 					{
; 1658 : 						LPPMSG_REQ_DUEL_LEAVECNANNEL lpReq = reinterpret_cast<LPPMSG_REQ_DUEL_LEAVECNANNEL>(aRecv);
; 1659 : 						int nRet = OnDuelChannelLeave(lpReq, aIndex);
; 1660 : 						if (E_FAILED(nRet))
; 1661 : 						{
; 1662 : 							PMSG_ANS_DUEL_LEAVECNANNEL res = {0,};
; 1663 : 							res.h.c = PMHC_BYTE;
; 1664 : 							res.h.size = sizeof(res);
; 1665 : 							res.h.headcode = HIBYTE(MSG_DUEL_LEAVECNANNEL);
; 1666 : 							res.h.subcode = LOBYTE(MSG_DUEL_LEAVECNANNEL);
; 1667 : 							res.nResult = nRet;
; 1668 : 							DataSend(aIndex, (LPBYTE)&res, res.h.size);
; 1669 : 						}
; 1670 : 					}
; 1671 : 					break;
; 1672 : 				}
; 1673 : 			}
; 1674 : 			break;
; 1675 : #else
; 1676 : 		case 0xAA :
; 1677 : 			CGDuelStartRequestRecv((LPPMSG_REQ_START_DUEL) aRecv, aIndex);

  009d0	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009d3	50		 push	 eax
  009d4	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  009d7	51		 push	 ecx
  009d8	e8 00 00 00 00	 call	 ?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z ; CGDuelStartRequestRecv
  009dd	83 c4 08	 add	 esp, 8

; 1678 : 			break;

  009e0	e9 05 02 00 00	 jmp	 $LN1@ProtocolCo
$LN127@ProtocolCo:

; 1679 : 		case 0xAB :
; 1680 : 			CGDuelEndRequestRecv((LPPMSG_REQ_END_DUEL) aRecv, aIndex);

  009e5	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009e8	50		 push	 eax
  009e9	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  009ec	51		 push	 ecx
  009ed	e8 00 00 00 00	 call	 ?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ; CGDuelEndRequestRecv
  009f2	83 c4 08	 add	 esp, 8

; 1681 : 			break;

  009f5	e9 f0 01 00 00	 jmp	 $LN1@ProtocolCo
$LN128@ProtocolCo:

; 1682 : 		case 0xAC :
; 1683 : 			CGDuelOkRequestRecv((LPPMSG_ANS_DUEL_OK) aRecv, aIndex);

  009fa	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  009fd	50		 push	 eax
  009fe	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a01	51		 push	 ecx
  00a02	e8 00 00 00 00	 call	 ?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ; CGDuelOkRequestRecv
  00a07	83 c4 08	 add	 esp, 8

; 1684 : 			break;

  00a0a	e9 db 01 00 00	 jmp	 $LN1@ProtocolCo
$LN129@ProtocolCo:

; 1685 : #endif // ADD_NEWPVP_PKFIELD
; 1686 : #endif
; 1687 : 			
; 1688 : #ifdef FOR_BLOODCASTLE
; 1689 : 		case 0x9A:
; 1690 : 			CGRequestEnterBloodCastle((LPPMSG_REQ_MOVEBLOODCASTLE) aRecv, aIndex);

  00a0f	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a12	50		 push	 eax
  00a13	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a16	51		 push	 ecx
  00a17	e8 00 00 00 00	 call	 ?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; CGRequestEnterBloodCastle
  00a1c	83 c4 08	 add	 esp, 8

; 1691 : 			break;

  00a1f	e9 c6 01 00 00	 jmp	 $LN1@ProtocolCo
$LN130@ProtocolCo:

; 1692 : 		case 0x9B :
; 1693 : 			break;

  00a24	e9 c1 01 00 00	 jmp	 $LN1@ProtocolCo
$LN131@ProtocolCo:

; 1694 : #endif
; 1695 : 
; 1696 : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 1697 : 		case 0x9F:
; 1698 : 			// [0x9F]       
; 1699 : 			CGRequestEventEnterCount((LPPMSG_REQ_CL_ENTERCOUNT) aRecv, aIndex);

  00a29	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a2c	50		 push	 eax
  00a2d	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a30	51		 push	 ecx
  00a31	e8 00 00 00 00	 call	 ?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ; CGRequestEventEnterCount
  00a36	83 c4 08	 add	 esp, 8

; 1700 : 			break;

  00a39	e9 ac 01 00 00	 jmp	 $LN1@ProtocolCo
$LN132@ProtocolCo:

; 1701 : #endif
; 1702 : 
; 1703 : 
; 1704 : #ifdef EVENT_LOTTO
; 1705 : 		case 0x9D :
; 1706 : 			CGRequestLottoRegister((LPPMSG_REQ_2ANV_LOTTO_EVENT) aRecv, aIndex);

  00a3e	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a41	50		 push	 eax
  00a42	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a45	51		 push	 ecx
  00a46	e8 00 00 00 00	 call	 ?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ; CGRequestLottoRegister
  00a4b	83 c4 08	 add	 esp, 8

; 1707 : 			break;

  00a4e	e9 97 01 00 00	 jmp	 $LN1@ProtocolCo
$LN133@ProtocolCo:

; 1708 : #endif
; 1709 : 
; 1710 : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 1711 : 		case 0xAF :
; 1712 : 			{
; 1713 : 				LPPMSG_DEFAULT2 lpDef = (LPPMSG_DEFAULT2)aRecv;

  00a53	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00a56	89 45 e8	 mov	 DWORD PTR _lpDef$2[ebp], eax

; 1714 : 				switch(lpDef->subcode) {

  00a59	8b 45 e8	 mov	 eax, DWORD PTR _lpDef$2[ebp]
  00a5c	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00a5f	88 4d a0	 mov	 BYTE PTR tv436[ebp], cl
  00a62	80 7d a0 01	 cmp	 BYTE PTR tv436[ebp], 1
  00a66	74 08		 je	 SHORT $LN134@ProtocolCo
  00a68	80 7d a0 02	 cmp	 BYTE PTR tv436[ebp], 2
  00a6c	74 14		 je	 SHORT $LN135@ProtocolCo
  00a6e	eb 22		 jmp	 SHORT $LN14@ProtocolCo
$LN134@ProtocolCo:

; 1715 : 				case 0x01 :	
; 1716 : 					CGRequestEnterChaosCastle((LPPMSG_REQ_MOVECHAOSCASTLE) aRecv, aIndex);

  00a70	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a73	50		 push	 eax
  00a74	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a77	51		 push	 ecx
  00a78	e8 00 00 00 00	 call	 ?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ; CGRequestEnterChaosCastle
  00a7d	83 c4 08	 add	 esp, 8

; 1717 : 					break;

  00a80	eb 10		 jmp	 SHORT $LN14@ProtocolCo
$LN135@ProtocolCo:

; 1718 : 				case 0x02 :
; 1719 : 					CGRequestRepositionUserInChaosCastle((LPPMSG_REQ_REPOSUSER_IN_CC) aRecv, aIndex);

  00a82	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a85	50		 push	 eax
  00a86	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a89	51		 push	 ecx
  00a8a	e8 00 00 00 00	 call	 ?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ; CGRequestRepositionUserInChaosCastle
  00a8f	83 c4 08	 add	 esp, 8
$LN14@ProtocolCo:

; 1720 : 					break;;
; 1721 : 				}
; 1722 : 			}
; 1723 : 			break;

  00a92	e9 53 01 00 00	 jmp	 $LN1@ProtocolCo
$LN136@ProtocolCo:

; 1724 : #endif
; 1725 : 			
; 1726 : #ifdef __FRIEND_WORK__
; 1727 : 		case 0xC0 :	//   
; 1728 : 			FriendListRequest(aIndex);

  00a97	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a9a	50		 push	 eax
  00a9b	e8 00 00 00 00	 call	 ?FriendListRequest@@YAXH@Z ; FriendListRequest
  00aa0	83 c4 04	 add	 esp, 4

; 1729 : 			break;

  00aa3	e9 42 01 00 00	 jmp	 $LN1@ProtocolCo
$LN137@ProtocolCo:

; 1730 : 		case 0xC1 :	//   
; 1731 : 			FriendAddRequest((LPPMSG_FRIEND_ADD_REQ)aRecv, aIndex);

  00aa8	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00aab	50		 push	 eax
  00aac	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00aaf	51		 push	 ecx
  00ab0	e8 00 00 00 00	 call	 ?FriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_REQ@@H@Z ; FriendAddRequest
  00ab5	83 c4 08	 add	 esp, 8

; 1732 : 			break;

  00ab8	e9 2d 01 00 00	 jmp	 $LN1@ProtocolCo
$LN138@ProtocolCo:

; 1733 : 		case 0xC2 :
; 1734 : 			WaitFriendAddRequest((LPPMSG_FRIEND_ADD_SIN_RESULT)aRecv, aIndex);

  00abd	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00ac0	50		 push	 eax
  00ac1	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00ac4	51		 push	 ecx
  00ac5	e8 00 00 00 00	 call	 ?WaitFriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_SIN_RESULT@@H@Z ; WaitFriendAddRequest
  00aca	83 c4 08	 add	 esp, 8

; 1735 : 			break;

  00acd	e9 18 01 00 00	 jmp	 $LN1@ProtocolCo
$LN139@ProtocolCo:

; 1736 : 		case 0xC3 : //   
; 1737 : 			FriendDelRequest((LPPMSG_FRIEND_DEL_REQ)aRecv, aIndex);

  00ad2	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00ad5	50		 push	 eax
  00ad6	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00ad9	51		 push	 ecx
  00ada	e8 00 00 00 00	 call	 ?FriendDelRequest@@YAXPAUPMSG_FRIEND_DEL_REQ@@H@Z ; FriendDelRequest
  00adf	83 c4 08	 add	 esp, 8

; 1738 : 			break;

  00ae2	e9 03 01 00 00	 jmp	 $LN1@ProtocolCo
$LN140@ProtocolCo:

; 1739 : 		case 0xC4 :
; 1740 : 			FriendStateClientRecv((LPPMSG_FRIEND_STATE_C)aRecv, aIndex);

  00ae7	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00aea	50		 push	 eax
  00aeb	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00aee	51		 push	 ecx
  00aef	e8 00 00 00 00	 call	 ?FriendStateClientRecv@@YAXPAUPMSG_FRIEND_STATE_C@@H@Z ; FriendStateClientRecv
  00af4	83 c4 08	 add	 esp, 8

; 1741 : 			break;

  00af7	e9 ee 00 00 00	 jmp	 $LN1@ProtocolCo
$LN141@ProtocolCo:

; 1742 : 		case 0xC5 :
; 1743 : 			FriendMemoSend((LPPMSG_FRIEND_MEMO)aRecv, aIndex);

  00afc	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00aff	50		 push	 eax
  00b00	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00b03	51		 push	 ecx
  00b04	e8 00 00 00 00	 call	 ?FriendMemoSend@@YAXPAUPMSG_FRIEND_MEMO@@H@Z ; FriendMemoSend
  00b09	83 c4 08	 add	 esp, 8

; 1744 : 			break;

  00b0c	e9 d9 00 00 00	 jmp	 $LN1@ProtocolCo
$LN142@ProtocolCo:

; 1745 : 		case 0xC7 :
; 1746 : 			FriendMemoReadReq((LPPMSG_FRIEND_READ_MEMO_REQ)aRecv, aIndex);

  00b11	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b14	50		 push	 eax
  00b15	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00b18	51		 push	 ecx
  00b19	e8 00 00 00 00	 call	 ?FriendMemoReadReq@@YAXPAUPMSG_FRIEND_READ_MEMO_REQ@@H@Z ; FriendMemoReadReq
  00b1e	83 c4 08	 add	 esp, 8

; 1747 : 			break;

  00b21	e9 c4 00 00 00	 jmp	 $LN1@ProtocolCo
$LN143@ProtocolCo:

; 1748 : 		case 0xC8 :
; 1749 : 			FriendMemoDelReq((LPPMSG_FRIEND_MEMO_DEL_REQ)aRecv, aIndex);

  00b26	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b29	50		 push	 eax
  00b2a	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00b2d	51		 push	 ecx
  00b2e	e8 00 00 00 00	 call	 ?FriendMemoDelReq@@YAXPAUPMSG_FRIEND_MEMO_DEL_REQ@@H@Z ; FriendMemoDelReq
  00b33	83 c4 08	 add	 esp, 8

; 1750 : 			break;

  00b36	e9 af 00 00 00	 jmp	 $LN1@ProtocolCo
$LN144@ProtocolCo:

; 1751 : 		case 0xC9 :
; 1752 : 			FriendMemoListReq(aIndex);

  00b3b	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b3e	50		 push	 eax
  00b3f	e8 00 00 00 00	 call	 ?FriendMemoListReq@@YAXH@Z ; FriendMemoListReq
  00b44	83 c4 04	 add	 esp, 4

; 1753 : 			break;

  00b47	e9 9e 00 00 00	 jmp	 $LN1@ProtocolCo
$LN145@ProtocolCo:

; 1754 : 		case 0xCA :
; 1755 : 			FriendChatRoomCreateReq((LPPMSG_FRIEND_ROOMCREATE_REQ)aRecv, aIndex);

  00b4c	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b4f	50		 push	 eax
  00b50	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00b53	51		 push	 ecx
  00b54	e8 00 00 00 00	 call	 ?FriendChatRoomCreateReq@@YAXPAUPMSG_FRIEND_ROOMCREATE_REQ@@H@Z ; FriendChatRoomCreateReq
  00b59	83 c4 08	 add	 esp, 8

; 1756 : 			break;

  00b5c	e9 89 00 00 00	 jmp	 $LN1@ProtocolCo
$LN146@ProtocolCo:

; 1757 : 		case 0xCB :
; 1758 : 			FriendRoomInvitationReq((LPPMSG_ROOM_INVITATION)aRecv, aIndex);

  00b61	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00b64	50		 push	 eax
  00b65	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00b68	51		 push	 ecx
  00b69	e8 00 00 00 00	 call	 ?FriendRoomInvitationReq@@YAXPAUPMSG_ROOM_INVITATION@@H@Z ; FriendRoomInvitationReq
  00b6e	83 c4 08	 add	 esp, 8

; 1759 : 			break;

  00b71	eb 77		 jmp	 SHORT $LN1@ProtocolCo
$LN147@ProtocolCo:

; 1760 : #endif	
; 1761 : #ifndef MODIFY_PACKET_POSITION_PROTOCOL_CODE_20071126
; 1762 : 		case 0xD2:
; 1763 : #else
; 1764 : 		case 0xD0:
; 1765 : #endif
; 1766 : 			{
; 1767 : 				LPPMSG_DEFAULT2 lpDef = ( LPPMSG_DEFAULT2 )aRecv;

  00b73	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00b76	89 45 e4	 mov	 DWORD PTR _lpDef$1[ebp], eax

; 1768 : 				switch( lpDef->subcode )

  00b79	8b 45 e4	 mov	 eax, DWORD PTR _lpDef$1[ebp]
  00b7c	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00b80	89 4d a0	 mov	 DWORD PTR tv467[ebp], ecx

; 1769 : 				{
; 1770 : #ifdef PCBANG_COUPON_EVENT_20060124
; 1771 : 				case 0x00:
; 1772 : 					CGReqPCBangCouponItem( ( LPPMSG_REQ_PCBANG_COUPON_ITEM )aRecv, aIndex );
; 1773 : 					break;
; 1774 : #endif // PCBANG_COUPON_EVENT_20060124
; 1775 : #ifdef WHITEANGEL_GET_ITEM_EVENT_20060822
; 1776 : 				case 0x03:
; 1777 : 					CGReqWhiteAngelGetItem( ( LPPMSG_REQ_WHITEANGEL_ITEM )aRecv, aIndex );
; 1778 : 					break;
; 1779 : #endif	// WHITEANGEL_GET_ITEM_EVENT_20060822
; 1780 : #ifdef PCBANG_POINT_SYSTEM_20070206		// Recv From Client
; 1781 : 				case 0x05:
; 1782 : 					CGReqBuyPCBangPointItem( ( LPPMSG_REQ_CG_BUY_PCBANG_POINT_ITEM )aRecv, aIndex );
; 1783 : 					break;
; 1784 : 				case 0x06:					
; 1785 : 					CGReqPCBangPointShopOpen( ( LPPMSG_REQ_PCBANG_POINT_SHOP_OPEN )aRecv, aIndex );
; 1786 : 					break;
; 1787 : #endif	// PCBANG_POINT_SYSTEM_20070206
; 1788 : #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// NPC    
; 1789 : 				case 0x07:
; 1790 : 					CGReqEnterOnWerwolf( ( LPPMSG_REQ_ENTER_ON_WERWOLF )aRecv, aIndex );
; 1791 : 					break;
; 1792 : 				case 0x08:
; 1793 : 					CGReqEnterOnGateKeeper( ( LPPMSG_REQ_ENTER_ON_GATEKEEPER )aRecv, aIndex );
; 1794 : 					break;
; 1795 : #endif
; 1796 : #ifdef ADD_ITEM_GIVE_NPC_ALAN_20070823
; 1797 : 				case 0x09:
; 1798 : 					CGReqAlansItem( ( LPPMSG_REQ_GIVE_ALANS_ITEM )aRecv, aIndex );
; 1799 : 					break;
; 1800 : #endif
; 1801 : #ifdef ADD_NPC_XMASEVENT_20080930
; 1802 : 				case 0x0A:
; 1803 : 					CGAnsSnowManMoveGate( (LPPMSG_REQ_SNOWMAN_NPC)aRecv, aIndex );
; 1804 : 					break;
; 1805 : #endif
; 1806 : #ifdef ADD_GIFTITEM_XMASEVENT_20081030
; 1807 : 				case 0x10:
; 1808 : 					CGReqEventItem( (LPPMSG_REQ_GIVE_SANTA_ITEM)aRecv,aIndex);
; 1809 : 					break;
; 1810 : #endif
; 1811 : 				}
; 1812 : 			}
; 1813 : 			break;

  00b83	eb 65		 jmp	 SHORT $LN1@ProtocolCo
$LN148@ProtocolCo:

; 1814 : 			
; 1815 : #ifdef KANTURU_PROTOCOL_20060705
; 1816 : 		case 0xD1:
; 1817 : 			{
; 1818 : 				LPPMSG_DEFAULT2 lpDef = ( LPPMSG_DEFAULT2 )aRecv;
; 1819 : 				switch( lpDef->subcode ) 
; 1820 : 				{	
; 1821 : 				case 0x00:
; 1822 : 					CGReqKanturuStateInfo( ( LPPMSG_REQ_KANTURU_STATE_INFO )aRecv, aIndex );
; 1823 : 					break;
; 1824 : 				case 0x01:
; 1825 : 					GCReqEnterKanturuBossMap( ( LPPMSG_REQ_ENTER_KANTURU_BOSS_MAP )aRecv, aIndex );
; 1826 : 					break;
; 1827 : 				}
; 1828 : 			}
; 1829 : 			break;			
; 1830 : #endif	// #ifdef KANTURU_PROTOCOL_20060705
; 1831 : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 1832 : 		case 0xF5:
; 1833 : 			{
; 1834 : 				LPPMSG_DEFAULT2 lpDef = ( LPPMSG_DEFAULT2 )aRecv;
; 1835 : 				switch( lpDef->subcode )
; 1836 : 				{
; 1837 : 				case 0x01:		//    
; 1838 : 					g_CashShop.CGCashShopOpen( lpObj, (LPPMSG_REQ_CASHSHOPOPEN)aRecv );
; 1839 : 					break;
; 1840 : 				case 0x03:		//   
; 1841 : 					g_CashShop.CGCashPoint( lpObj );
; 1842 : 					break;
; 1843 : 				case 0x05:		//    
; 1844 : 					g_CashShop.GCCashItemListSend( &gObj[aIndex], (LPPMSG_REQ_CASHITEMLIST)aRecv );
; 1845 : 					break;
; 1846 : 				case 0x07:		//    
; 1847 : 					g_CashShop.CGCashItemBuy( &gObj[aIndex], (LPPMSG_REQ_CASHITEM_BUY)aRecv );
; 1848 : 					break;
; 1849 : 				}
; 1850 : 			}
; 1851 : 			break;
; 1852 : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 1853 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328
; 1854 : 		case 0xBF:
; 1855 : 			{
; 1856 : 				LPPMSG_DEFAULT2 lpDef = ( LPPMSG_DEFAULT2 )aRecv;
; 1857 : 				switch( lpDef->subcode ) 
; 1858 : 				{
; 1859 : 				case 0x00:
; 1860 : 					CGReqEnterIllusionTemple( ( LPPMSG_REQ_ENTER_ILLUSION_TEMPLE )aRecv, aIndex );
; 1861 : 					break;
; 1862 : 				case 0x02:
; 1863 : 					CGIllusionTempleUseMagic( ( LPPMSG_ILLUSION_TEMPLE_USE_MAGIC)aRecv, aIndex );
; 1864 : 					break;
; 1865 : 				case 0x05:
; 1866 : 					CGReqIllusionTempleReward( (LPPMSG_ILLUSION_TEMPLE_REQ_REWARD)aRecv, aIndex );
; 1867 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029
; 1868 : 					break;
; 1869 : 				case 0x0b:
; 1870 : 					CGReqGetCoinCount( (LPPMSG_REQ_GET_COIN_COUNT)aRecv, aIndex );
; 1871 : 					break;
; 1872 : 				case 0x0c:
; 1873 : 					CGReqRegeistCoin( (LPPMSG_REQ_REGEIST_COIN)aRecv, aIndex );
; 1874 : 					break;
; 1875 : 				case 0x0d:
; 1876 : 					CGReqTradeCoin( (LPPMSG_REQ_TRADE_COIN)aRecv, aIndex );
; 1877 : 					break;
; 1878 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029					
; 1879 : 				}
; 1880 : 			}
; 1881 : 			break;
; 1882 : #endif	//ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328
; 1883 : 
; 1884 : #ifdef EXPERIENCE_SERVER_NPC_STAT_RESET
; 1885 : 		case 0xF2:
; 1886 : 			{
; 1887 : 				LPPMSG_DEFAULT2 lpDef = ( LPPMSG_DEFAULT2 )aRecv;
; 1888 : 				switch( lpDef->subcode )
; 1889 : 				{
; 1890 : 				case 0x00:
; 1891 : 					{
; 1892 : 						//   .
; 1893 : 						StatResetBtnClick((LPPMSG_REQ_STAT_RESET)aRecv, aIndex);
; 1894 : 					}
; 1895 : 					break;
; 1896 : 				}
; 1897 : 			}
; 1898 : 			break;
; 1899 : #endif // EXPERIENCE_SERVER_NPC_STAT_RESET
; 1900 : 
; 1901 : #ifdef ADD_HACKING_TOOL_BLOCK_20090311
; 1902 : 			//     .
; 1903 : 		case 0x8A:
; 1904 : 			{
; 1905 : 				CGAnsHacktoolStatistics( (LPPMSG_ANS_HACKTOOL_STATISTICS)aRecv, aIndex );
; 1906 : 			}
; 1907 : 			break;
; 1908 : #endif // ADD_HACKING_TOOL_BLOCK_20090311
; 1909 : 
; 1910 : #ifdef ADD_MAPMOVE_PROTOCOL_20090327
; 1911 : 			//    
; 1912 : 		case 0x8E:
; 1913 : 			{
; 1914 : 				LPPMSG_DEFAULT2 lpDef = ( LPPMSG_DEFAULT2 )aRecv;
; 1915 : 				switch( lpDef->subcode )
; 1916 : 				{
; 1917 : 				case 0x02:
; 1918 : 					CGReqMapMove( (LPPMSG_REQ_MAPMOVE)aRecv, aIndex );
; 1919 : 					break;
; 1920 : 				}
; 1921 : 			}
; 1922 : 			break;
; 1923 : #endif // ADD_MAPMOVE_PROTOCOL_20090327
; 1924 : 
; 1925 : 		default :	//    .
; 1926 : #if ( LOCALCONNECT == 0 )			
; 1927 : 			LogAddC(LOGC_RED,"error-L2 : account:%s name:%s HEAD:%x (%s,%d) State:%d", 

  00b85	69 45 14 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b92	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  00b96	52		 push	 edx
  00b97	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ProtocolCore@@YAXEPAEHHHH@Z@4JA
  00b9c	05 43 04 00 00	 add	 eax, 1091		; 00000443H
  00ba1	50		 push	 eax
  00ba2	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00ba7	0f b6 4d 08	 movzx	 ecx, BYTE PTR _protoNum$[ebp]
  00bab	51		 push	 ecx
  00bac	69 55 14 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00bb3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bb8	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00bbc	51		 push	 ecx
  00bbd	69 55 14 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00bc4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bc9	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00bcd	51		 push	 ecx
  00bce	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5H@
  00bd3	6a 02		 push	 2
  00bd5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00bdb	83 c4 20	 add	 esp, 32			; 00000020H

; 1928 : 					gObj[aIndex].AccountID, 
; 1929 : 					gObj[aIndex].Name, 
; 1930 : 					protoNum, 
; 1931 : 					__FILE__, __LINE__, 
; 1932 : 					gObj[aIndex].Connected);
; 1933 : 			CloseClient(aIndex);

  00bde	8b 45 14	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00be1	50		 push	 eax
  00be2	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00be7	83 c4 04	 add	 esp, 4
$LN1@ProtocolCo:

; 1934 : #else 
; 1935 : 			PEchoProc(aRecv, aLen, aIndex);
; 1936 : 			gObj[aIndex].ConnectCheckTime = GetTickCount();
; 1937 : #endif
; 1938 : 			
; 1939 : 			break;
; 1940 : 		} // switch( protoNum )
; 1941 : 	}
; 1942 : }

  00bea	5f		 pop	 edi
  00beb	5e		 pop	 esi
  00bec	5b		 pop	 ebx
  00bed	8b e5		 mov	 esp, ebp
  00bef	5d		 pop	 ebp
  00bf0	c3		 ret	 0
  00bf1	0f 1f 00	 npad	 3
$LN151@ProtocolCo:
  00bf4	00 00 00 00	 DD	 $LN38@ProtocolCo
  00bf8	00 00 00 00	 DD	 $LN39@ProtocolCo
  00bfc	00 00 00 00	 DD	 $LN40@ProtocolCo
  00c00	00 00 00 00	 DD	 $LN41@ProtocolCo
  00c04	00 00 00 00	 DD	 $LN42@ProtocolCo
  00c08	00 00 00 00	 DD	 $LN43@ProtocolCo
  00c0c	00 00 00 00	 DD	 $LN44@ProtocolCo
  00c10	00 00 00 00	 DD	 $LN2@ProtocolCo
$LN150@ProtocolCo:
  00c14	00		 DB	 0
  00c15	01		 DB	 1
  00c16	02		 DB	 2
  00c17	03		 DB	 3
  00c18	07		 DB	 7
  00c19	07		 DB	 7
  00c1a	04		 DB	 4
  00c1b	07		 DB	 7
  00c1c	07		 DB	 7
  00c1d	07		 DB	 7
  00c1e	07		 DB	 7
  00c1f	07		 DB	 7
  00c20	07		 DB	 7
  00c21	07		 DB	 7
  00c22	07		 DB	 7
  00c23	07		 DB	 7
  00c24	07		 DB	 7
  00c25	07		 DB	 7
  00c26	05		 DB	 5
  00c27	07		 DB	 7
  00c28	07		 DB	 7
  00c29	07		 DB	 7
  00c2a	07		 DB	 7
  00c2b	07		 DB	 7
  00c2c	07		 DB	 7
  00c2d	07		 DB	 7
  00c2e	07		 DB	 7
  00c2f	07		 DB	 7
  00c30	07		 DB	 7
  00c31	07		 DB	 7
  00c32	07		 DB	 7
  00c33	07		 DB	 7
  00c34	07		 DB	 7
  00c35	07		 DB	 7
  00c36	07		 DB	 7
  00c37	07		 DB	 7
  00c38	07		 DB	 7
  00c39	07		 DB	 7
  00c3a	07		 DB	 7
  00c3b	07		 DB	 7
  00c3c	07		 DB	 7
  00c3d	07		 DB	 7
  00c3e	07		 DB	 7
  00c3f	07		 DB	 7
  00c40	07		 DB	 7
  00c41	07		 DB	 7
  00c42	07		 DB	 7
  00c43	07		 DB	 7
  00c44	06		 DB	 6
  00c45	0f 1f 00	 npad	 3
$LN153@ProtocolCo:
  00c48	00 00 00 00	 DD	 $LN45@ProtocolCo
  00c4c	00 00 00 00	 DD	 $LN46@ProtocolCo
  00c50	00 00 00 00	 DD	 $LN47@ProtocolCo
  00c54	00 00 00 00	 DD	 $LN48@ProtocolCo
  00c58	00 00 00 00	 DD	 $LN49@ProtocolCo
  00c5c	00 00 00 00	 DD	 $LN53@ProtocolCo
  00c60	00 00 00 00	 DD	 $LN54@ProtocolCo
  00c64	00 00 00 00	 DD	 $LN56@ProtocolCo
  00c68	00 00 00 00	 DD	 $LN60@ProtocolCo
  00c6c	00 00 00 00	 DD	 $LN61@ProtocolCo
  00c70	00 00 00 00	 DD	 $LN63@ProtocolCo
  00c74	00 00 00 00	 DD	 $LN65@ProtocolCo
  00c78	00 00 00 00	 DD	 $LN66@ProtocolCo
  00c7c	00 00 00 00	 DD	 $LN67@ProtocolCo
  00c80	00 00 00 00	 DD	 $LN68@ProtocolCo
  00c84	00 00 00 00	 DD	 $LN70@ProtocolCo
  00c88	00 00 00 00	 DD	 $LN71@ProtocolCo
  00c8c	00 00 00 00	 DD	 $LN73@ProtocolCo
  00c90	00 00 00 00	 DD	 $LN75@ProtocolCo
  00c94	00 00 00 00	 DD	 $LN76@ProtocolCo
  00c98	00 00 00 00	 DD	 $LN78@ProtocolCo
  00c9c	00 00 00 00	 DD	 $LN79@ProtocolCo
  00ca0	00 00 00 00	 DD	 $LN80@ProtocolCo
  00ca4	00 00 00 00	 DD	 $LN82@ProtocolCo
  00ca8	00 00 00 00	 DD	 $LN84@ProtocolCo
  00cac	00 00 00 00	 DD	 $LN91@ProtocolCo
  00cb0	00 00 00 00	 DD	 $LN93@ProtocolCo
  00cb4	00 00 00 00	 DD	 $LN95@ProtocolCo
  00cb8	00 00 00 00	 DD	 $LN96@ProtocolCo
  00cbc	00 00 00 00	 DD	 $LN98@ProtocolCo
  00cc0	00 00 00 00	 DD	 $LN99@ProtocolCo
  00cc4	00 00 00 00	 DD	 $LN100@ProtocolCo
  00cc8	00 00 00 00	 DD	 $LN101@ProtocolCo
  00ccc	00 00 00 00	 DD	 $LN102@ProtocolCo
  00cd0	00 00 00 00	 DD	 $LN103@ProtocolCo
  00cd4	00 00 00 00	 DD	 $LN104@ProtocolCo
  00cd8	00 00 00 00	 DD	 $LN106@ProtocolCo
  00cdc	00 00 00 00	 DD	 $LN105@ProtocolCo
  00ce0	00 00 00 00	 DD	 $LN108@ProtocolCo
  00ce4	00 00 00 00	 DD	 $LN109@ProtocolCo
  00ce8	00 00 00 00	 DD	 $LN111@ProtocolCo
  00cec	00 00 00 00	 DD	 $LN112@ProtocolCo
  00cf0	00 00 00 00	 DD	 $LN113@ProtocolCo
  00cf4	00 00 00 00	 DD	 $LN114@ProtocolCo
  00cf8	00 00 00 00	 DD	 $LN115@ProtocolCo
  00cfc	00 00 00 00	 DD	 $LN116@ProtocolCo
  00d00	00 00 00 00	 DD	 $LN117@ProtocolCo
  00d04	00 00 00 00	 DD	 $LN118@ProtocolCo
  00d08	00 00 00 00	 DD	 $LN119@ProtocolCo
  00d0c	00 00 00 00	 DD	 $LN120@ProtocolCo
  00d10	00 00 00 00	 DD	 $LN121@ProtocolCo
  00d14	00 00 00 00	 DD	 $LN129@ProtocolCo
  00d18	00 00 00 00	 DD	 $LN130@ProtocolCo
  00d1c	00 00 00 00	 DD	 $LN132@ProtocolCo
  00d20	00 00 00 00	 DD	 $LN131@ProtocolCo
  00d24	00 00 00 00	 DD	 $LN122@ProtocolCo
  00d28	00 00 00 00	 DD	 $LN123@ProtocolCo
  00d2c	00 00 00 00	 DD	 $LN124@ProtocolCo
  00d30	00 00 00 00	 DD	 $LN125@ProtocolCo
  00d34	00 00 00 00	 DD	 $LN126@ProtocolCo
  00d38	00 00 00 00	 DD	 $LN127@ProtocolCo
  00d3c	00 00 00 00	 DD	 $LN128@ProtocolCo
  00d40	00 00 00 00	 DD	 $LN133@ProtocolCo
  00d44	00 00 00 00	 DD	 $LN58@ProtocolCo
  00d48	00 00 00 00	 DD	 $LN107@ProtocolCo
  00d4c	00 00 00 00	 DD	 $LN136@ProtocolCo
  00d50	00 00 00 00	 DD	 $LN137@ProtocolCo
  00d54	00 00 00 00	 DD	 $LN138@ProtocolCo
  00d58	00 00 00 00	 DD	 $LN139@ProtocolCo
  00d5c	00 00 00 00	 DD	 $LN140@ProtocolCo
  00d60	00 00 00 00	 DD	 $LN141@ProtocolCo
  00d64	00 00 00 00	 DD	 $LN142@ProtocolCo
  00d68	00 00 00 00	 DD	 $LN143@ProtocolCo
  00d6c	00 00 00 00	 DD	 $LN144@ProtocolCo
  00d70	00 00 00 00	 DD	 $LN145@ProtocolCo
  00d74	00 00 00 00	 DD	 $LN146@ProtocolCo
  00d78	00 00 00 00	 DD	 $LN51@ProtocolCo
  00d7c	00 00 00 00	 DD	 $LN147@ProtocolCo
  00d80	00 00 00 00	 DD	 $LN50@ProtocolCo
  00d84	00 00 00 00	 DD	 $LN52@ProtocolCo
  00d88	00 00 00 00	 DD	 $LN148@ProtocolCo
$LN152@ProtocolCo:
  00d8c	00		 DB	 0
  00d8d	01		 DB	 1
  00d8e	02		 DB	 2
  00d8f	03		 DB	 3
  00d90	50		 DB	 80			; 00000050H
  00d91	50		 DB	 80			; 00000050H
  00d92	50		 DB	 80			; 00000050H
  00d93	50		 DB	 80			; 00000050H
  00d94	50		 DB	 80			; 00000050H
  00d95	50		 DB	 80			; 00000050H
  00d96	50		 DB	 80			; 00000050H
  00d97	50		 DB	 80			; 00000050H
  00d98	50		 DB	 80			; 00000050H
  00d99	50		 DB	 80			; 00000050H
  00d9a	04		 DB	 4
  00d9b	50		 DB	 80			; 00000050H
  00d9c	50		 DB	 80			; 00000050H
  00d9d	50		 DB	 80			; 00000050H
  00d9e	50		 DB	 80			; 00000050H
  00d9f	50		 DB	 80			; 00000050H
  00da0	50		 DB	 80			; 00000050H
  00da1	50		 DB	 80			; 00000050H
  00da2	50		 DB	 80			; 00000050H
  00da3	50		 DB	 80			; 00000050H
  00da4	05		 DB	 5
  00da5	06		 DB	 6
  00da6	50		 DB	 80			; 00000050H
  00da7	50		 DB	 80			; 00000050H
  00da8	07		 DB	 7
  00da9	08		 DB	 8
  00daa	09		 DB	 9
  00dab	50		 DB	 80			; 00000050H
  00dac	50		 DB	 80			; 00000050H
  00dad	50		 DB	 80			; 00000050H
  00dae	0a		 DB	 10			; 0000000aH
  00daf	0b		 DB	 11			; 0000000bH
  00db0	0c		 DB	 12			; 0000000cH
  00db1	50		 DB	 80			; 00000050H
  00db2	0d		 DB	 13			; 0000000dH
  00db3	50		 DB	 80			; 00000050H
  00db4	50		 DB	 80			; 00000050H
  00db5	50		 DB	 80			; 00000050H
  00db6	50		 DB	 80			; 00000050H
  00db7	50		 DB	 80			; 00000050H
  00db8	50		 DB	 80			; 00000050H
  00db9	50		 DB	 80			; 00000050H
  00dba	50		 DB	 80			; 00000050H
  00dbb	50		 DB	 80			; 00000050H
  00dbc	0e		 DB	 14			; 0000000eH
  00dbd	0f		 DB	 15			; 0000000fH
  00dbe	10		 DB	 16			; 00000010H
  00dbf	11		 DB	 17			; 00000011H
  00dc0	12		 DB	 18			; 00000012H
  00dc1	50		 DB	 80			; 00000050H
  00dc2	13		 DB	 19			; 00000013H
  00dc3	14		 DB	 20			; 00000014H
  00dc4	50		 DB	 80			; 00000050H
  00dc5	50		 DB	 80			; 00000050H
  00dc6	15		 DB	 21			; 00000015H
  00dc7	50		 DB	 80			; 00000050H
  00dc8	16		 DB	 22			; 00000016H
  00dc9	17		 DB	 23			; 00000017H
  00dca	50		 DB	 80			; 00000050H
  00dcb	18		 DB	 24			; 00000018H
  00dcc	19		 DB	 25			; 00000019H
  00dcd	1a		 DB	 26			; 0000001aH
  00dce	1b		 DB	 27			; 0000001bH
  00dcf	1c		 DB	 28			; 0000001cH
  00dd0	50		 DB	 80			; 00000050H
  00dd1	50		 DB	 80			; 00000050H
  00dd2	50		 DB	 80			; 00000050H
  00dd3	50		 DB	 80			; 00000050H
  00dd4	50		 DB	 80			; 00000050H
  00dd5	50		 DB	 80			; 00000050H
  00dd6	50		 DB	 80			; 00000050H
  00dd7	50		 DB	 80			; 00000050H
  00dd8	50		 DB	 80			; 00000050H
  00dd9	50		 DB	 80			; 00000050H
  00dda	50		 DB	 80			; 00000050H
  00ddb	50		 DB	 80			; 00000050H
  00ddc	1d		 DB	 29			; 0000001dH
  00ddd	1e		 DB	 30			; 0000001eH
  00dde	1f		 DB	 31			; 0000001fH
  00ddf	20		 DB	 32			; 00000020H
  00de0	21		 DB	 33			; 00000021H
  00de1	22		 DB	 34			; 00000022H
  00de2	50		 DB	 80			; 00000050H
  00de3	23		 DB	 35			; 00000023H
  00de4	50		 DB	 80			; 00000050H
  00de5	50		 DB	 80			; 00000050H
  00de6	50		 DB	 80			; 00000050H
  00de7	50		 DB	 80			; 00000050H
  00de8	50		 DB	 80			; 00000050H
  00de9	50		 DB	 80			; 00000050H
  00dea	24		 DB	 36			; 00000024H
  00deb	50		 DB	 80			; 00000050H
  00dec	50		 DB	 80			; 00000050H
  00ded	25		 DB	 37			; 00000025H
  00dee	50		 DB	 80			; 00000050H
  00def	50		 DB	 80			; 00000050H
  00df0	50		 DB	 80			; 00000050H
  00df1	50		 DB	 80			; 00000050H
  00df2	50		 DB	 80			; 00000050H
  00df3	50		 DB	 80			; 00000050H
  00df4	50		 DB	 80			; 00000050H
  00df5	50		 DB	 80			; 00000050H
  00df6	50		 DB	 80			; 00000050H
  00df7	50		 DB	 80			; 00000050H
  00df8	50		 DB	 80			; 00000050H
  00df9	50		 DB	 80			; 00000050H
  00dfa	50		 DB	 80			; 00000050H
  00dfb	50		 DB	 80			; 00000050H
  00dfc	50		 DB	 80			; 00000050H
  00dfd	26		 DB	 38			; 00000026H
  00dfe	27		 DB	 39			; 00000027H
  00dff	50		 DB	 80			; 00000050H
  00e00	50		 DB	 80			; 00000050H
  00e01	50		 DB	 80			; 00000050H
  00e02	50		 DB	 80			; 00000050H
  00e03	50		 DB	 80			; 00000050H
  00e04	50		 DB	 80			; 00000050H
  00e05	50		 DB	 80			; 00000050H
  00e06	50		 DB	 80			; 00000050H
  00e07	50		 DB	 80			; 00000050H
  00e08	50		 DB	 80			; 00000050H
  00e09	50		 DB	 80			; 00000050H
  00e0a	50		 DB	 80			; 00000050H
  00e0b	50		 DB	 80			; 00000050H
  00e0c	50		 DB	 80			; 00000050H
  00e0d	28		 DB	 40			; 00000028H
  00e0e	29		 DB	 41			; 00000029H
  00e0f	2a		 DB	 42			; 0000002aH
  00e10	50		 DB	 80			; 00000050H
  00e11	50		 DB	 80			; 00000050H
  00e12	2b		 DB	 43			; 0000002bH
  00e13	2c		 DB	 44			; 0000002cH
  00e14	50		 DB	 80			; 00000050H
  00e15	50		 DB	 80			; 00000050H
  00e16	50		 DB	 80			; 00000050H
  00e17	50		 DB	 80			; 00000050H
  00e18	50		 DB	 80			; 00000050H
  00e19	50		 DB	 80			; 00000050H
  00e1a	50		 DB	 80			; 00000050H
  00e1b	50		 DB	 80			; 00000050H
  00e1c	2d		 DB	 45			; 0000002dH
  00e1d	2e		 DB	 46			; 0000002eH
  00e1e	50		 DB	 80			; 00000050H
  00e1f	50		 DB	 80			; 00000050H
  00e20	50		 DB	 80			; 00000050H
  00e21	2f		 DB	 47			; 0000002fH
  00e22	30		 DB	 48			; 00000030H
  00e23	31		 DB	 49			; 00000031H
  00e24	32		 DB	 50			; 00000032H
  00e25	50		 DB	 80			; 00000050H
  00e26	33		 DB	 51			; 00000033H
  00e27	34		 DB	 52			; 00000034H
  00e28	50		 DB	 80			; 00000050H
  00e29	35		 DB	 53			; 00000035H
  00e2a	50		 DB	 80			; 00000050H
  00e2b	36		 DB	 54			; 00000036H
  00e2c	37		 DB	 55			; 00000037H
  00e2d	50		 DB	 80			; 00000050H
  00e2e	38		 DB	 56			; 00000038H
  00e2f	50		 DB	 80			; 00000050H
  00e30	50		 DB	 80			; 00000050H
  00e31	50		 DB	 80			; 00000050H
  00e32	50		 DB	 80			; 00000050H
  00e33	39		 DB	 57			; 00000039H
  00e34	50		 DB	 80			; 00000050H
  00e35	3a		 DB	 58			; 0000003aH
  00e36	3b		 DB	 59			; 0000003bH
  00e37	3c		 DB	 60			; 0000003cH
  00e38	3d		 DB	 61			; 0000003dH
  00e39	50		 DB	 80			; 00000050H
  00e3a	50		 DB	 80			; 00000050H
  00e3b	3e		 DB	 62			; 0000003eH
  00e3c	3f		 DB	 63			; 0000003fH
  00e3d	50		 DB	 80			; 00000050H
  00e3e	50		 DB	 80			; 00000050H
  00e3f	50		 DB	 80			; 00000050H
  00e40	50		 DB	 80			; 00000050H
  00e41	50		 DB	 80			; 00000050H
  00e42	50		 DB	 80			; 00000050H
  00e43	50		 DB	 80			; 00000050H
  00e44	50		 DB	 80			; 00000050H
  00e45	40		 DB	 64			; 00000040H
  00e46	50		 DB	 80			; 00000050H
  00e47	50		 DB	 80			; 00000050H
  00e48	50		 DB	 80			; 00000050H
  00e49	50		 DB	 80			; 00000050H
  00e4a	50		 DB	 80			; 00000050H
  00e4b	50		 DB	 80			; 00000050H
  00e4c	41		 DB	 65			; 00000041H
  00e4d	42		 DB	 66			; 00000042H
  00e4e	43		 DB	 67			; 00000043H
  00e4f	44		 DB	 68			; 00000044H
  00e50	45		 DB	 69			; 00000045H
  00e51	46		 DB	 70			; 00000046H
  00e52	50		 DB	 80			; 00000050H
  00e53	47		 DB	 71			; 00000047H
  00e54	48		 DB	 72			; 00000048H
  00e55	49		 DB	 73			; 00000049H
  00e56	4a		 DB	 74			; 0000004aH
  00e57	4b		 DB	 75			; 0000004bH
  00e58	50		 DB	 80			; 00000050H
  00e59	50		 DB	 80			; 00000050H
  00e5a	50		 DB	 80			; 00000050H
  00e5b	50		 DB	 80			; 00000050H
  00e5c	4c		 DB	 76			; 0000004cH
  00e5d	50		 DB	 80			; 00000050H
  00e5e	4d		 DB	 77			; 0000004dH
  00e5f	50		 DB	 80			; 00000050H
  00e60	50		 DB	 80			; 00000050H
  00e61	50		 DB	 80			; 00000050H
  00e62	50		 DB	 80			; 00000050H
  00e63	4e		 DB	 78			; 0000004eH
  00e64	50		 DB	 80			; 00000050H
  00e65	4f		 DB	 79			; 0000004fH
  00e66	66 90		 npad	 2
$LN154@ProtocolCo:
  00e68	00 00 00 00	 DD	 $LN86@ProtocolCo
  00e6c	00 00 00 00	 DD	 $LN87@ProtocolCo
  00e70	00 00 00 00	 DD	 $LN88@ProtocolCo
  00e74	00 00 00 00	 DD	 $LN10@ProtocolCo
  00e78	00 00 00 00	 DD	 $LN89@ProtocolCo
  00e7c	00 00 00 00	 DD	 $LN90@ProtocolCo
?ProtocolCore@@YAXEPAEHHHH@Z ENDP			; ProtocolCore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z
_TEXT	SEGMENT
tv66 = -100						; size = 4
tv67 = -96						; size = 4
_n$1 = -28						; size = 4
_MVL$ = -24						; size = 4
_lpObj$ = -20						; size = 4
_pResult$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z PROC		; CGActionRecv, COMDAT

; 15109: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 15110: 	PMSG_ACTIONRESULT	pResult;
; 15111: 
; 15112: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  00013	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00017	7d 09		 jge	 SHORT $LN18@CGActionRe
  00019	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00020	eb 1f		 jmp	 SHORT $LN19@CGActionRe
$LN18@CGActionRe:
  00022	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00029	7e 09		 jle	 SHORT $LN16@CGActionRe
  0002b	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN17@CGActionRe
$LN16@CGActionRe:
  00034	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN17@CGActionRe:
  0003b	8b 45 9c	 mov	 eax, DWORD PTR tv66[ebp]
  0003e	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN19@CGActionRe:
  00041	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  00045	75 21		 jne	 SHORT $LN5@CGActionRe

; 15113: 	{
; 15114: 		LogAdd("error : move protocol index error %s %d",__FILE__, __LINE__);

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z@4JA
  0004c	83 c0 05	 add	 eax, 5
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5err@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15115: 		return;

  00063	e9 a3 01 00 00	 jmp	 $LN1@CGActionRe
$LN5@CGActionRe:

; 15116: 	}
; 15117: 	LPOBJECTSTRUCT	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00068	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00075	89 45 ec	 mov	 DWORD PTR _lpObj$[ebp], eax

; 15118: 	
; 15119: 	PHeadSetB((LPBYTE)&pResult, 0x18, sizeof( pResult ));

  00078	6a 09		 push	 9
  0007a	6a 18		 push	 24			; 00000018H
  0007c	8d 45 f0	 lea	 eax, DWORD PTR _pResult$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15120: 
; 15121: 	pResult.ActionNumber = lpMsg->ActionNumber;

  00088	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008b	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0008e	88 4d f6	 mov	 BYTE PTR _pResult$[ebp+6], cl

; 15122: 	pResult.NumberH = HIBYTE(aIndex);

  00091	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00094	c1 e8 08	 shr	 eax, 8
  00097	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0009c	88 45 f3	 mov	 BYTE PTR _pResult$[ebp+3], al

; 15123: 	pResult.NumberL = LOBYTE(aIndex);

  0009f	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000a2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a7	88 45 f4	 mov	 BYTE PTR _pResult$[ebp+4], al

; 15124: 
; 15125: 	lpObj->m_ActionNumber = lpMsg->ActionNumber;

  000aa	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000b0	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  000b3	88 90 b4 01 00
	00		 mov	 BYTE PTR [eax+436], dl

; 15126: 	lpObj->Dir            = lpMsg->Dir;

  000b9	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000bf	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  000c2	88 90 08 01 00
	00		 mov	 BYTE PTR [eax+264], dl

; 15127: 	pResult.Dir           = lpObj->Dir;

  000c8	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cb	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  000d1	88 4d f5	 mov	 BYTE PTR _pResult$[ebp+5], cl

; 15128: 
; 15129: #ifdef ADD_TRAP_OBJECT_EXTEND_20060731
; 15130: 	pResult.TargetNumberH = lpMsg->iTargetIndexH;
; 15131: 	pResult.TargetNumberL = lpMsg->iTargetIndexL;
; 15132: #endif
; 15133: 
; 15134: 	if( lpObj->m_ActionNumber == AT_SIT1 )

  000d4	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d7	0f b6 88 b4 01
	00 00		 movzx	 ecx, BYTE PTR [eax+436]
  000de	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000e4	75 1e		 jne	 SHORT $LN6@CGActionRe

; 15135: 	{
; 15136: 		lpObj->m_ViewState = 2;

  000e6	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e9	c6 80 be 01 00
	00 02		 mov	 BYTE PTR [eax+446], 2

; 15137: 		lpObj->m_Rest      = lpObj->m_ActionNumber;

  000f0	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f3	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f6	8a 91 b4 01 00
	00		 mov	 dl, BYTE PTR [ecx+436]
  000fc	88 90 bd 01 00
	00		 mov	 BYTE PTR [eax+445], dl

; 15138: 	}

  00102	eb 5e		 jmp	 SHORT $LN7@CGActionRe
$LN6@CGActionRe:

; 15139: 	else if( lpObj->m_ActionNumber == AT_POSE1 )

  00104	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00107	0f b6 88 b4 01
	00 00		 movzx	 ecx, BYTE PTR [eax+436]
  0010e	81 f9 81 00 00
	00		 cmp	 ecx, 129		; 00000081H
  00114	75 1e		 jne	 SHORT $LN8@CGActionRe

; 15140: 	{
; 15141: 		lpObj->m_ViewState = 3;

  00116	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00119	c6 80 be 01 00
	00 03		 mov	 BYTE PTR [eax+446], 3

; 15142: 		lpObj->m_Rest      = lpObj->m_ActionNumber;

  00120	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00123	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00126	8a 91 b4 01 00
	00		 mov	 dl, BYTE PTR [ecx+436]
  0012c	88 90 bd 01 00
	00		 mov	 BYTE PTR [eax+445], dl

; 15143: 	}

  00132	eb 2e		 jmp	 SHORT $LN7@CGActionRe
$LN8@CGActionRe:

; 15144: 	else if( lpObj->m_ActionNumber == AT_HEALING1 )

  00134	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00137	0f b6 88 b4 01
	00 00		 movzx	 ecx, BYTE PTR [eax+436]
  0013e	81 f9 82 00 00
	00		 cmp	 ecx, 130		; 00000082H
  00144	75 1c		 jne	 SHORT $LN7@CGActionRe

; 15145: 	{
; 15146: 		lpObj->m_ViewState = 4;

  00146	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00149	c6 80 be 01 00
	00 04		 mov	 BYTE PTR [eax+446], 4

; 15147: 		lpObj->m_Rest      = lpObj->m_ActionNumber;

  00150	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00153	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00156	8a 91 b4 01 00
	00		 mov	 dl, BYTE PTR [ecx+436]
  0015c	88 90 bd 01 00
	00		 mov	 BYTE PTR [eax+445], dl
$LN7@CGActionRe:

; 15148: 	}
; 15149: 
; 15150: 	int MVL = MAXVIEWPORTOBJECT;

  00162	c7 45 e8 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 15151: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  00169	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00170	83 f9 02	 cmp	 ecx, 2
  00173	75 07		 jne	 SHORT $LN11@CGActionRe
  00175	c7 45 e8 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN11@CGActionRe:

; 15152: 
; 15153: 	for( int n=0; n<MVL; n++ )

  0017c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00183	eb 09		 jmp	 SHORT $LN4@CGActionRe
$LN2@CGActionRe:
  00185	8b 45 e4	 mov	 eax, DWORD PTR _n$1[ebp]
  00188	83 c0 01	 add	 eax, 1
  0018b	89 45 e4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@CGActionRe:
  0018e	8b 45 e4	 mov	 eax, DWORD PTR _n$1[ebp]
  00191	3b 45 e8	 cmp	 eax, DWORD PTR _MVL$[ebp]
  00194	7d 75		 jge	 SHORT $LN1@CGActionRe

; 15154: 	{
; 15155: 		if( lpObj->VpPlayer2[n].type == OBJTYPE_CHARACTER )

  00196	6b 45 e4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0019a	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0019d	0f b6 94 01 ec
	06 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1772]
  001a5	83 fa 01	 cmp	 edx, 1
  001a8	75 5c		 jne	 SHORT $LN12@CGActionRe

; 15156: 		{
; 15157: 			if( lpObj->VpPlayer2[n].state != OBJST_NONE &&
; 15158: 				lpObj->VpPlayer2[n].state != OBJST_DIED &&

  001aa	6b 45 e4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  001ae	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001b1	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  001b9	85 d2		 test	 edx, edx
  001bb	74 49		 je	 SHORT $LN12@CGActionRe
  001bd	6b 45 e4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  001c1	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c4	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  001cc	83 fa 10	 cmp	 edx, 16			; 00000010H
  001cf	74 35		 je	 SHORT $LN12@CGActionRe
  001d1	6b 45 e4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  001d5	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d8	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  001e0	83 fa 08	 cmp	 edx, 8
  001e3	74 21		 je	 SHORT $LN12@CGActionRe

; 15159: 				lpObj->VpPlayer2[n].state != OBJST_DIECMD )
; 15160: 			{
; 15161: 				if( DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pResult, pResult.h.size) == FALSE )

  001e5	0f b6 45 f1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001e9	50		 push	 eax
  001ea	8d 4d f0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  001ed	51		 push	 ecx
  001ee	6b 55 e4 0c	 imul	 edx, DWORD PTR _n$1[ebp], 12
  001f2	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f5	0f bf 8c 10 ea
	06 00 00	 movsx	 ecx, WORD PTR [eax+edx+1770]
  001fd	51		 push	 ecx
  001fe	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00203	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@CGActionRe:

; 15162: 				{
; 15163: 					//LogAdd("error : index: %d number : %d",  aIndex, lpObj->VpPlayer2[n].number);
; 15164: 				}
; 15165: 			}
; 15166: 		}
; 15167: 	}

  00206	e9 7a ff ff ff	 jmp	 $LN2@CGActionRe
$LN1@CGActionRe:

; 15168: 	
; 15169: }

  0020b	5f		 pop	 edi
  0020c	5e		 pop	 esi
  0020d	5b		 pop	 ebx
  0020e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00211	33 cd		 xor	 ecx, ebp
  00213	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c3		 ret	 0
?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z ENDP		; CGActionRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z
_TEXT	SEGMENT
tv93 = -96						; size = 4
tv66 = -96						; size = 4
tv94 = -92						; size = 4
tv67 = -92						; size = 4
_number$1 = -24						; size = 4
_MVL$ = -20						; size = 4
_pMove$ = -16						; size = 7
_lpObj$ = -8						; size = 4
_n$ = -4						; size = 2
_lpMove$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z PROC ; RecvPositionSetProc, COMDAT

; 14552: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14553: 	short n;
; 14554: 
; 14555: 
; 14556: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  00009	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN21@RecvPositi
  0000f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN22@RecvPositi
$LN21@RecvPositi:
  00018	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN19@RecvPositi
  00021	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN20@RecvPositi
$LN19@RecvPositi:
  0002a	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN20@RecvPositi:
  00031	8b 45 a0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN22@RecvPositi:
  00037	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 21		 jne	 SHORT $LN5@RecvPositi

; 14557: 	{
; 14558: 		LogAdd("error : move protocol index error %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z@4JA
  00042	83 c0 06	 add	 eax, 6
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5err@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14559: 		return;

  00059	e9 2d 03 00 00	 jmp	 $LN1@RecvPositi
$LN5@RecvPositi:

; 14560: 	}
; 14561: 	LPOBJECTSTRUCT	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  0005e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00065	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006b	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 14562: 
; 14563: 	if( PacketCheckTime(lpObj) == FALSE ) return;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAVOBJECTSTRUCT@@@Z ; PacketCheckTime
  00077	83 c4 04	 add	 esp, 4
  0007a	85 c0		 test	 eax, eax
  0007c	75 05		 jne	 SHORT $LN6@RecvPositi
  0007e	e9 08 03 00 00	 jmp	 $LN1@RecvPositi
$LN6@RecvPositi:

; 14564: 	
; 14565: 	if( lpObj->Teleport ) return;

  00083	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00086	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  0008d	85 c9		 test	 ecx, ecx
  0008f	74 05		 je	 SHORT $LN7@RecvPositi
  00091	e9 f5 02 00 00	 jmp	 $LN1@RecvPositi
$LN7@RecvPositi:

; 14566: 	//   
; 14567: 	lpObj->X = lpMove->X;

  00096	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  00099	66 0f b6 48 03	 movzx	 cx, BYTE PTR [eax+3]
  0009e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a1	66 89 8a 04 01
	00 00		 mov	 WORD PTR [edx+260], cx

; 14568: 	lpObj->Y = lpMove->Y;	

  000a8	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  000ab	66 0f b6 48 04	 movzx	 cx, BYTE PTR [eax+4]
  000b0	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b3	66 89 8a 06 01
	00 00		 mov	 WORD PTR [edx+262], cx

; 14569: 	
; 14570: #ifdef CHAOSCASTLE_SYSTEM_20040408		//       1      .
; 14571: 	if (CHECK_CHAOSCASTLE(lpObj->MapNumber)) {

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bd	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000c4	83 f9 12	 cmp	 ecx, 18			; 00000012H
  000c7	7d 09		 jge	 SHORT $LN25@RecvPositi
  000c9	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  000d0	eb 25		 jmp	 SHORT $LN26@RecvPositi
$LN25@RecvPositi:
  000d2	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d5	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000dc	83 f8 17	 cmp	 eax, 23			; 00000017H
  000df	7e 09		 jle	 SHORT $LN23@RecvPositi
  000e1	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
  000e8	eb 07		 jmp	 SHORT $LN24@RecvPositi
$LN23@RecvPositi:
  000ea	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv93[ebp], 1
$LN24@RecvPositi:
  000f1	8b 4d a0	 mov	 ecx, DWORD PTR tv93[ebp]
  000f4	89 4d a4	 mov	 DWORD PTR tv94[ebp], ecx
$LN26@RecvPositi:
  000f7	83 7d a4 00	 cmp	 DWORD PTR tv94[ebp], 0
  000fb	74 1b		 je	 SHORT $LN8@RecvPositi

; 14572: 		if( GetTickCount() - lpObj->m_iChaosCastleBlowTime < 1000 ) {

  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00103	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00106	2b 81 dc 0c 00
	00		 sub	 eax, DWORD PTR [ecx+3292]
  0010c	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00111	73 05		 jae	 SHORT $LN8@RecvPositi

; 14573: 			return;

  00113	e9 73 02 00 00	 jmp	 $LN1@RecvPositi
$LN8@RecvPositi:

; 14574: 		}
; 14575: 	}
; 14576: #endif
; 14577: 
; 14578: #ifdef ADD_LOG_CHECK_INVLIDE_X_Y_POSITION_20060131
; 14579: 	if( gObjCheckXYMapTile(lpObj, DBGNAME_RecvPositionSetProc ) == TRUE ) 

  00118	6a 02		 push	 2
  0011a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile
  00123	83 c4 08	 add	 esp, 8
  00126	83 f8 01	 cmp	 eax, 1
  00129	75 05		 jne	 SHORT $LN10@RecvPositi

; 14580: 		return;

  0012b	e9 5b 02 00 00	 jmp	 $LN1@RecvPositi
$LN10@RecvPositi:

; 14581: #else
; 14582: 	if( gObjCheckXYMapTile(lpObj) == TRUE ) return;
; 14583: #endif // ADD_LOG_CHECK_INVLIDE_X_Y_POSITION_20060131
; 14584: 
; 14585: 	PMSG_RECV_POSISTION_SET pMove;
; 14586: 
; 14587: #ifdef PACKET_CHANGE	
; 14588: 	PHeadSetB((LPBYTE)&pMove, PACKET_POSITION, sizeof( pMove));

  00130	6a 07		 push	 7
  00132	68 d0 00 00 00	 push	 208			; 000000d0H
  00137	8d 45 f0	 lea	 eax, DWORD PTR _pMove$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14589: #else
; 14590: 	PHeadSetB((LPBYTE)&pMove, 0x11, sizeof( pMove));
; 14591: #endif
; 14592: 
; 14593: 	pMove.NumberH		= HIBYTE(aIndex);

  00143	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00146	c1 e8 08	 shr	 eax, 8
  00149	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0014e	88 45 f3	 mov	 BYTE PTR _pMove$[ebp+3], al

; 14594: 	pMove.NumberL		= LOBYTE(aIndex);

  00151	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00154	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00159	88 45 f4	 mov	 BYTE PTR _pMove$[ebp+4], al

; 14595: 	pMove.X				= (BYTE)lpMove->X;

  0015c	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  0015f	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00162	88 4d f5	 mov	 BYTE PTR _pMove$[ebp+5], cl

; 14596: 	pMove.Y				= (BYTE)lpMove->Y;

  00165	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  00168	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  0016b	88 4d f6	 mov	 BYTE PTR _pMove$[ebp+6], cl

; 14597: 		
; 14598: 	lpObj->TX     = (BYTE)lpMove->X;

  0016e	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  00171	66 0f b6 48 03	 movzx	 cx, BYTE PTR [eax+3]
  00176	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00179	66 89 8a 20 01
	00 00		 mov	 WORD PTR [edx+288], cx

; 14599: 	lpObj->TY     = (BYTE)lpMove->Y;

  00180	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  00183	66 0f b6 48 04	 movzx	 cx, BYTE PTR [eax+4]
  00188	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0018b	66 89 8a 22 01
	00 00		 mov	 WORD PTR [edx+290], cx

; 14600: 
; 14601: 	if( gObjPositionCheck(lpObj) == FALSE ) 

  00192	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 ?gObjPositionCheck@@YAHPAVOBJECTSTRUCT@@@Z ; gObjPositionCheck
  0019b	83 c4 04	 add	 esp, 4
  0019e	85 c0		 test	 eax, eax
  001a0	75 05		 jne	 SHORT $LN11@RecvPositi

; 14602: 	{
; 14603: 		
; 14604: #ifdef ADD_ANTI_HACK_01_20051027
; 14605: 	//   ..   0xdc
; 14606: 	LogAddTD("[Anti-Hack][RecvPositionSetProc][Check Position Error] :(%s)(%s) S(%d,%d) -> T(%d,%d)", 
; 14607: 				lpObj->AccountID, lpObj->Name,  lpObj->X, lpObj->Y, lpObj->TX, lpObj->TY);
; 14608: #endif
; 14609: 	
; 14610: 		return;

  001a2	e9 e4 01 00 00	 jmp	 $LN1@RecvPositi
$LN11@RecvPositi:

; 14611: 	}
; 14612: 
; 14613: 	CreateFrustrum(lpObj->X,lpObj->Y, aIndex);

  001a7	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001aa	50		 push	 eax
  001ab	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ae	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  001b5	52		 push	 edx
  001b6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b9	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  001c0	51		 push	 ecx
  001c1	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  001c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14614: 
; 14615: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  001c9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001cc	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  001d0	83 f9 01	 cmp	 ecx, 1
  001d3	75 15		 jne	 SHORT $LN12@RecvPositi

; 14616: 		DataSend(aIndex, (LPBYTE)&pMove, pMove.h.size);

  001d5	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  001d9	50		 push	 eax
  001da	8d 4d f0	 lea	 ecx, DWORD PTR _pMove$[ebp]
  001dd	51		 push	 ecx
  001de	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  001e1	52		 push	 edx
  001e2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@RecvPositi:

; 14617: 
; 14618: 	int MVL = MAXVIEWPORTOBJECT;

  001ea	c7 45 ec 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 14619: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  001f1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f4	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  001f8	83 f9 02	 cmp	 ecx, 2
  001fb	75 07		 jne	 SHORT $LN13@RecvPositi
  001fd	c7 45 ec 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN13@RecvPositi:

; 14620: 
; 14621: 	//       .
; 14622: 	for( n=0; n<MVL; n++ )

  00204	33 c0		 xor	 eax, eax
  00206	66 89 45 fc	 mov	 WORD PTR _n$[ebp], ax
  0020a	eb 0c		 jmp	 SHORT $LN4@RecvPositi
$LN2@RecvPositi:
  0020c	66 8b 45 fc	 mov	 ax, WORD PTR _n$[ebp]
  00210	66 83 c0 01	 add	 ax, 1
  00214	66 89 45 fc	 mov	 WORD PTR _n$[ebp], ax
$LN4@RecvPositi:
  00218	0f bf 45 fc	 movsx	 eax, WORD PTR _n$[ebp]
  0021c	3b 45 ec	 cmp	 eax, DWORD PTR _MVL$[ebp]
  0021f	0f 8d dc 00 00
	00		 jge	 $LN3@RecvPositi

; 14623: 	{
; 14624: 		if( lpObj->VpPlayer2[n].type == OBJTYPE_CHARACTER)

  00225	0f bf 45 fc	 movsx	 eax, WORD PTR _n$[ebp]
  00229	6b c8 0c	 imul	 ecx, eax, 12
  0022c	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0022f	0f b6 84 0a ec
	06 00 00	 movzx	 eax, BYTE PTR [edx+ecx+1772]
  00237	83 f8 01	 cmp	 eax, 1
  0023a	0f 85 bc 00 00
	00		 jne	 $LN14@RecvPositi

; 14625: 		{
; 14626: 			if( lpObj->VpPlayer2[n].state == STVP_CREATE )

  00240	0f bf 45 fc	 movsx	 eax, WORD PTR _n$[ebp]
  00244	6b c8 0c	 imul	 ecx, eax, 12
  00247	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0024a	0f be 84 0a e8
	06 00 00	 movsx	 eax, BYTE PTR [edx+ecx+1768]
  00252	83 f8 01	 cmp	 eax, 1
  00255	0f 85 a1 00 00
	00		 jne	 $LN14@RecvPositi

; 14627: 			{
; 14628: 				int number = lpObj->VpPlayer2[n].number;

  0025b	0f bf 45 fc	 movsx	 eax, WORD PTR _n$[ebp]
  0025f	6b c8 0c	 imul	 ecx, eax, 12
  00262	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00265	0f bf 84 0a ea
	06 00 00	 movsx	 eax, WORD PTR [edx+ecx+1770]
  0026d	89 45 e8	 mov	 DWORD PTR _number$1[ebp], eax

; 14629: 				if( (gObj[number].Connected > 1) && (gObj[number].Live) )	//   ..

  00270	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$1[ebp], 7072
  00277	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027d	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  00282	7e 3c		 jle	 SHORT $LN16@RecvPositi
  00284	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$1[ebp], 7072
  0028b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00291	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  00296	85 d2		 test	 edx, edx
  00298	74 26		 je	 SHORT $LN16@RecvPositi

; 14630: 					DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pMove, pMove.h.size);

  0029a	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  0029e	50		 push	 eax
  0029f	8d 4d f0	 lea	 ecx, DWORD PTR _pMove$[ebp]
  002a2	51		 push	 ecx
  002a3	0f bf 55 fc	 movsx	 edx, WORD PTR _n$[ebp]
  002a7	6b c2 0c	 imul	 eax, edx, 12
  002aa	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ad	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  002b5	52		 push	 edx
  002b6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002be	eb 3c		 jmp	 SHORT $LN14@RecvPositi
$LN16@RecvPositi:

; 14631: 				else 
; 14632: 				{
; 14633: 					lpObj->VpPlayer2[n].number = -1;

  002c0	0f bf 45 fc	 movsx	 eax, WORD PTR _n$[ebp]
  002c4	6b c8 0c	 imul	 ecx, eax, 12
  002c7	83 ca ff	 or	 edx, -1
  002ca	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cd	66 89 94 08 ea
	06 00 00	 mov	 WORD PTR [eax+ecx+1770], dx

; 14634: 					lpObj->VpPlayer2[n].state  = STVP_NONE;

  002d5	0f bf 45 fc	 movsx	 eax, WORD PTR _n$[ebp]
  002d9	6b c8 0c	 imul	 ecx, eax, 12
  002dc	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002df	c6 84 0a e8 06
	00 00 00	 mov	 BYTE PTR [edx+ecx+1768], 0

; 14635: 					lpObj->VPCount2--;

  002e7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ea	8b 88 70 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2672]
  002f0	83 e9 01	 sub	 ecx, 1
  002f3	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002f6	89 8a 70 0a 00
	00		 mov	 DWORD PTR [edx+2672], ecx
$LN14@RecvPositi:

; 14636: 				}
; 14637: 				
; 14638: 			}
; 14639: 		}
; 14640: 	}

  002fc	e9 0b ff ff ff	 jmp	 $LN2@RecvPositi
$LN3@RecvPositi:

; 14641: 	//---
; 14642: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  00301	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00304	0f bf 88 1e 01
	00 00		 movsx	 ecx, WORD PTR [eax+286]
  0030b	51		 push	 ecx
  0030c	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0030f	0f bf 82 1c 01
	00 00		 movsx	 eax, WORD PTR [edx+284]
  00316	50		 push	 eax
  00317	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0031a	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00321	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00327	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0032d	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 14643: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  00332	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00335	0f bf 88 22 01
	00 00		 movsx	 ecx, WORD PTR [eax+290]
  0033c	51		 push	 ecx
  0033d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00340	0f bf 82 20 01
	00 00		 movsx	 eax, WORD PTR [edx+288]
  00347	50		 push	 eax
  00348	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0034b	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00352	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00358	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0035e	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 14644: 	lpObj->m_OldX = lpObj->TX;

  00363	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00366	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00369	66 8b 91 20 01
	00 00		 mov	 dx, WORD PTR [ecx+288]
  00370	66 89 90 1c 01
	00 00		 mov	 WORD PTR [eax+284], dx

; 14645: 	lpObj->m_OldY = lpObj->TY;

  00377	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0037d	66 8b 91 22 01
	00 00		 mov	 dx, WORD PTR [ecx+290]
  00384	66 89 90 1e 01
	00 00		 mov	 WORD PTR [eax+286], dx
$LN1@RecvPositi:

; 14646: }

  0038b	5f		 pop	 edi
  0038c	5e		 pop	 esi
  0038d	5b		 pop	 ebx
  0038e	8b e5		 mov	 esp, ebp
  00390	5d		 pop	 ebp
  00391	c3		 ret	 0
?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ENDP ; RecvPositionSetProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCResultSend@@YAXHEE@Z
_TEXT	SEGMENT
_pResult$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_headcode$ = 12						; size = 1
_result$ = 16						; size = 1
?GCResultSend@@YAXHEE@Z PROC				; GCResultSend, COMDAT

; 2197 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2198 : 	PMSG_DEFRESULT		pResult;
; 2199 : 	
; 2200 : 	PHeadSetB((LPBYTE)&pResult, headcode, sizeof(pResult));

  00009	6a 04		 push	 4
  0000b	0f b6 45 0c	 movzx	 eax, BYTE PTR _headcode$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d fc	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2201 : 	pResult.result		= result;

  0001c	8a 45 10	 mov	 al, BYTE PTR _result$[ebp]
  0001f	88 45 ff	 mov	 BYTE PTR _pResult$[ebp+3], al

; 2202 : 
; 2203 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00022	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00026	50		 push	 eax
  00027	8d 4d fc	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2204 : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?GCResultSend@@YAXHEE@Z ENDP				; GCResultSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?DataSendAll@@YAXPAEH@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_lpMsg$ = 8						; size = 4
_iMsgSize$ = 12						; size = 4
?DataSendAll@@YAXPAEH@Z PROC				; DataSendAll, COMDAT

; 2300 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2301 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00009	c7 45 fc 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00010	eb 09		 jmp	 SHORT $LN4@DataSendAl
$LN2@DataSendAl:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@DataSendAl:
  0001b	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00022	7d 41		 jge	 SHORT $LN1@DataSendAl

; 2302 : 	{
; 2303 : 		if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) )

  00024	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00031	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00036	75 2b		 jne	 SHORT $LN5@DataSendAl
  00038	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00045	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0004a	83 fa 01	 cmp	 edx, 1
  0004d	75 14		 jne	 SHORT $LN5@DataSendAl

; 2304 : 		{
; 2305 : 			DataSend(n, (LPBYTE)lpMsg, iMsgSize);

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _iMsgSize$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00056	51		 push	 ecx
  00057	8b 55 fc	 mov	 edx, DWORD PTR _n$1[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@DataSendAl:

; 2306 : 		}
; 2307 : 	}

  00063	eb ad		 jmp	 SHORT $LN2@DataSendAl
$LN1@DataSendAl:

; 2308 : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?DataSendAll@@YAXPAEH@Z ENDP				; DataSendAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCCheckMainExeKeySend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
?GCCheckMainExeKeySend@@YAXH@Z PROC			; GCCheckMainExeKeySend, COMDAT

; 2103 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2104 : 	PMSG_CHECK_MAINEXE	pMsg;
; 2105 : 
; 2106 : 	gObj[aIndex].CheckSumTableNum	= rand()%1024;

  00009	e8 00 00 00 00	 call	 _rand
  0000e	25 ff 03 00 80	 and	 eax, -2147482625	; 800003ffH
  00013	79 07		 jns	 SHORT $LN3@GCCheckMai
  00015	48		 dec	 eax
  00016	0d 00 fc ff ff	 or	 eax, -1024		; fffffc00H
  0001b	40		 inc	 eax
$LN3@GCCheckMai:
  0001c	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00023	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00029	66 89 44 0a 5c	 mov	 WORD PTR [edx+ecx+92], ax

; 2107 : 	gObj[aIndex].CheckSumTime		= GetTickCount();

  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00034	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00041	89 44 0a 60	 mov	 DWORD PTR [edx+ecx+96], eax

; 2108 : 
; 2109 : 	PHeadSetB((LPBYTE)&pMsg, 0x03, sizeof(pMsg));

  00045	6a 06		 push	 6
  00047	6a 03		 push	 3
  00049	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2110 : 
; 2111 : 	pMsg.m_wKey			= EncryptCheckSumKey( gObj[aIndex].CheckSumTableNum );

  00055	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00062	0f b7 54 01 5c	 movzx	 edx, WORD PTR [ecx+eax+92]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 ?EncryptCheckSumKey@@YAGG@Z ; EncryptCheckSumKey
  0006d	83 c4 04	 add	 esp, 4
  00070	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 2112 : 
; 2113 : 	//LogAddL("error-L3 :    : %s key : %d %d %d", gObj[aIndex].AccountID , gObj[aIndex].CheckSumTableNum, dwgCheckSum[gObj[aIndex].CheckSumTableNum], pMsg.m_wKey);
; 2114 : 	DataSend( aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00074	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00078	50		 push	 eax
  00079	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0007c	51		 push	 ecx
  0007d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00080	52		 push	 edx
  00081	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2115 : }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?GCCheckMainExeKeySend@@YAXH@Z ENDP			; GCCheckMainExeKeySend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_lpObj$ = 8						; size = 4
_Msg$ = 12						; size = 4
_size$ = 16						; size = 4
?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z PROC		; MsgSendV2, COMDAT

; 1961 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1962 : 	for( int n=0; n<MAXVIEWPORTOBJECT; n++ )

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@MsgSendV2
$LN2@MsgSendV2:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@MsgSendV2:
  0001b	83 7d fc 4b	 cmp	 DWORD PTR _n$1[ebp], 75	; 0000004bH
  0001f	7d 49		 jge	 SHORT $LN1@MsgSendV2

; 1963 : 	{
; 1964 : 		if( lpObj->VpPlayer2[n].type == OBJTYPE_CHARACTER )

  00021	6b 45 fc 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00028	0f b6 94 01 ec
	06 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1772]
  00030	83 fa 01	 cmp	 edx, 1
  00033	75 33		 jne	 SHORT $LN5@MsgSendV2

; 1965 : 		{
; 1966 : 			if( lpObj->VpPlayer2[n].state )

  00035	6b 45 fc 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0003c	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  00044	85 d2		 test	 edx, edx
  00046	74 20		 je	 SHORT $LN5@MsgSendV2

; 1967 : 				DataSend(lpObj->VpPlayer2[n].number, Msg, size);

  00048	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _Msg$[ebp]
  0004f	51		 push	 ecx
  00050	6b 55 fc 0c	 imul	 edx, DWORD PTR _n$1[ebp], 12
  00054	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00057	0f bf 8c 10 ea
	06 00 00	 movsx	 ecx, WORD PTR [eax+edx+1770]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@MsgSendV2:

; 1968 : 		}
; 1969 : 	}

  00068	eb a8		 jmp	 SHORT $LN2@MsgSendV2
$LN1@MsgSendV2:

; 1970 : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ENDP		; MsgSendV2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?AllSendServerMsg@@YAXPAD@Z
_TEXT	SEGMENT
_n$1 = -280						; size = 4
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_chatmsg$ = 8						; size = 4
?AllSendServerMsg@@YAXPAD@Z PROC			; AllSendServerMsg, COMDAT

; 2274 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 58 01 00
	00		 sub	 esp, 344		; 00000158H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2275 : 	PMSG_NOTICE	pNotice;
; 2276 : 
; 2277 : #ifdef MODIFY_NOTICE_20040325
; 2278 : 	TNotice::MakeNoticeMsg( &pNotice, 0, chatmsg );

  00016	8b 45 08	 mov	 eax, DWORD PTR _chatmsg$[ebp]
  00019	50		 push	 eax
  0001a	6a 00		 push	 0
  0001c	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2279 : #else
; 2280 : 	pNotice.type		= 0;
; 2281 : 	strcpy(pNotice.Notice, chatmsg);
; 2282 : 	PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 2283 : #endif
; 2284 : 
; 2285 : #ifdef FOR_BLOODCASTLE
; 2286 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0002b	c7 85 e8 fe ff
	ff 00 19 00 00	 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00035	eb 0f		 jmp	 SHORT $LN4@AllSendSer
$LN2@AllSendSer:
  00037	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  0003d	83 c0 01	 add	 eax, 1
  00040	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@AllSendSer:
  00046	81 bd e8 fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00050	7d 51		 jge	 SHORT $LN1@AllSendSer

; 2287 : #else
; 2288 : 	for( int n=0; n<MAX_OBJECT; n++)
; 2289 : #endif	
; 2290 : 	{
; 2291 : 		if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) )

  00052	69 85 e8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00062	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00067	75 38		 jne	 SHORT $LN5@AllSendSer
  00069	69 85 e8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00079	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0007e	83 fa 01	 cmp	 edx, 1
  00081	75 1e		 jne	 SHORT $LN5@AllSendSer

; 2292 : 		{
; 2293 : 			DataSend(n, (LPBYTE)&pNotice, pNotice.h.size);

  00083	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  0008a	50		 push	 eax
  0008b	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  00091	51		 push	 ecx
  00092	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _n$1[ebp]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@AllSendSer:

; 2294 : 		}
; 2295 : 	}

  000a1	eb 94		 jmp	 SHORT $LN2@AllSendSer
$LN1@AllSendSer:

; 2296 : }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a9	33 cd		 xor	 ecx, ebp
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?AllSendServerMsg@@YAXPAD@Z ENDP			; AllSendServerMsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCMapEventStateSend@@YAXHEE@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_pMsg$ = -8						; size = 5
_map$ = 8						; size = 4
_state$ = 12						; size = 1
_event$ = 16						; size = 1
?GCMapEventStateSend@@YAXHEE@Z PROC			; GCMapEventStateSend, COMDAT

; 2916 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2917 : 	PMSG_EVENT	pMsg;
; 2918 : 
; 2919 : 	PHeadSetB((LPBYTE)&pMsg, 0x0B, sizeof( pMsg ));

  00009	6a 05		 push	 5
  0000b	6a 0b		 push	 11			; 0000000bH
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2920 : 	pMsg.Event		= event;

  00019	8a 45 10	 mov	 al, BYTE PTR _event$[ebp]
  0001c	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2921 : 	pMsg.State      = state;

  0001f	8a 45 0c	 mov	 al, BYTE PTR _state$[ebp]
  00022	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2922 : 
; 2923 : 	for( int n=0; n<MAX_OBJECT; n++)

  00025	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0002c	eb 09		 jmp	 SHORT $LN4@GCMapEvent
$LN2@GCMapEvent:
  0002e	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@GCMapEvent:
  00037	81 7d f4 e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  0003e	7d 5c		 jge	 SHORT $LN1@GCMapEvent

; 2924 : 	{
; 2925 : 		if( gObj[n].Connected == 3 && 
; 2926 : 			gObj[n].Type == OBJTYPE_CHARACTER && 

  00040	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00052	75 46		 jne	 SHORT $LN5@GCMapEvent
  00054	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00061	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00066	83 fa 01	 cmp	 edx, 1
  00069	75 2f		 jne	 SHORT $LN5@GCMapEvent
  0006b	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00078	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00080	39 55 08	 cmp	 DWORD PTR _map$[ebp], edx
  00083	75 15		 jne	 SHORT $LN5@GCMapEvent

; 2927 : 			map == gObj[n].MapNumber )
; 2928 : 		{
; 2929 : 			DataSend(n, (LPBYTE)&pMsg, pMsg.h.size);

  00085	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00089	50		 push	 eax
  0008a	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 f4	 mov	 edx, DWORD PTR _n$1[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@GCMapEvent:

; 2930 : 		}
; 2931 : 	}

  0009a	eb 92		 jmp	 SHORT $LN2@GCMapEvent
$LN1@GCMapEvent:

; 2932 : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?GCMapEventStateSend@@YAXHEE@Z ENDP			; GCMapEventStateSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCEventStateSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_state$ = 12						; size = 1
_event$ = 16						; size = 1
?GCEventStateSend@@YAXHEE@Z PROC			; GCEventStateSend, COMDAT

; 2905 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2906 : 	PMSG_EVENT	pMsg;
; 2907 : 
; 2908 : 	PHeadSetB((LPBYTE)&pMsg, 0x0B, sizeof( pMsg ));

  00009	6a 05		 push	 5
  0000b	6a 0b		 push	 11			; 0000000bH
  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2909 : 	pMsg.Event		= event;

  00019	8a 45 10	 mov	 al, BYTE PTR _event$[ebp]
  0001c	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2910 : 	pMsg.State      = state;

  0001f	8a 45 0c	 mov	 al, BYTE PTR _state$[ebp]
  00022	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2911 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00025	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00029	50		 push	 eax
  0002a	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2912 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?GCEventStateSend@@YAXHEE@Z ENDP			; GCEventStateSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z
_TEXT	SEGMENT
_pMsg$ = -76						; size = 65
_len$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
_senduser$ = 16						; size = 4
?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z PROC	; ChatTargetSend, COMDAT

; 2315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2316 : 	int len = strlen(szChat);

  00016	8b 45 0c	 mov	 eax, DWORD PTR _szChat$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _strlen
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 2317 : 
; 2318 : 	if( len < 1 || len > MAX_CHAT-1 ) return;

  00025	83 7d f8 01	 cmp	 DWORD PTR _len$[ebp], 1
  00029	7c 06		 jl	 SHORT $LN3@ChatTarget
  0002b	83 7d f8 3b	 cmp	 DWORD PTR _len$[ebp], 59 ; 0000003bH
  0002f	7e 02		 jle	 SHORT $LN2@ChatTarget
$LN3@ChatTarget:
  00031	eb 61		 jmp	 SHORT $LN1@ChatTarget
$LN2@ChatTarget:

; 2319 : 	PMSG_CHATDATA_NUMBER	pMsg;
; 2320 : 	
; 2321 : #ifdef UNICODE_MODE_20050718
; 2322 : 	char szTempMsg[4096] = {0,};
; 2323 : 	
; 2324 : 	MultiByteToWideChar(DEFAULT_CODEPAGE, 0, (char*)szChat, len, (WCHAR*)szTempMsg, sizeof(szTempMsg));
; 2325 : #ifdef MODIFY_VIETNAM_MEMCPY_BUG_20060502
; 2326 : 	memcpy(pMsg.chatmsg, szTempMsg, sizeof(pMsg.chatmsg));
; 2327 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, sizeof(pMsg)-MAX_CHAT+wcslen((WCHAR*)pMsg.chatmsg)*2+2);	
; 2328 : #else		
; 2329 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, sizeof(pMsg)-MAX_CHAT+wcslen((WCHAR*)pMsg.chatmsg)*2+2);	
; 2330 : 	memcpy(pMsg.chatmsg, szTempMsg, sizeof(pMsg.chatmsg));
; 2331 : #endif
; 2332 : 	
; 2333 : 	pMsg.chatmsg[MAX_CHAT-2] = 0;
; 2334 : 	pMsg.chatmsg[MAX_CHAT-1] = 0;
; 2335 : 	pMsg.NumberH = HIBYTE(lpObj->m_Index);
; 2336 : 	pMsg.NumberL = LOBYTE(lpObj->m_Index);
; 2337 : #else
; 2338 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, sizeof(pMsg)-MAX_CHAT+len+1);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00036	83 c0 06	 add	 eax, 6
  00039	50		 push	 eax
  0003a	6a 01		 push	 1
  0003c	8d 4d b4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2339 : 	strcpy(pMsg.chatmsg, szChat);

  00048	8b 45 0c	 mov	 eax, DWORD PTR _szChat$[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d b9	 lea	 ecx, DWORD PTR _pMsg$[ebp+5]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _strcpy
  00055	83 c4 08	 add	 esp, 8

; 2340 : 	pMsg.NumberH = HIBYTE(lpObj->m_Index);

  00058	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	c1 e9 08	 shr	 ecx, 8
  00060	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00066	88 4d b7	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 2341 : 	pMsg.NumberL = LOBYTE(lpObj->m_Index);

  00069	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00074	88 4d b8	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 2342 : 	pMsg.chatmsg[len+1] = '\0';

  00077	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0007a	c6 44 05 ba 00	 mov	 BYTE PTR _pMsg$[ebp+eax+6], 0

; 2343 : #endif
; 2344 : 	DataSend(senduser, (LPBYTE)&pMsg, pMsg.h.size);

  0007f	0f b6 45 b5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00083	50		 push	 eax
  00084	8d 4d b4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00087	51		 push	 ecx
  00088	8b 55 10	 mov	 edx, DWORD PTR _senduser$[ebp]
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ChatTarget:

; 2345 : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ENDP	; ChatTargetSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_lpNode$ = 8						; size = 4
_szMsg$ = 12						; size = 4
_type$ = 16						; size = 1
?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z PROC ; GCServerMsgStringSendGuild, COMDAT

; 2891 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2892 : 	if( lpNode == NULL ) return;

  00009	83 7d 08 00	 cmp	 DWORD PTR _lpNode$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN5@GCServerMs
  0000f	eb 5d		 jmp	 SHORT $LN1@GCServerMs
$LN5@GCServerMs:

; 2893 : 
; 2894 : 	for( int n=0; n<MAX_GUILD; n++)

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00018	eb 09		 jmp	 SHORT $LN4@GCServerMs
$LN2@GCServerMs:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@GCServerMs:
  00023	83 7d fc 50	 cmp	 DWORD PTR _n$1[ebp], 80	; 00000050H
  00027	7d 45		 jge	 SHORT $LN1@GCServerMs

; 2895 : 	{
; 2896 : 		if( (lpNode->Use[n] > 0) && (lpNode->Index[n] >= 0) )

  00029	8b 45 08	 mov	 eax, DWORD PTR _lpNode$[ebp]
  0002c	03 45 fc	 add	 eax, DWORD PTR _n$1[ebp]
  0002f	0f b6 88 40 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1088]
  00036	85 c9		 test	 ecx, ecx
  00038	7e 32		 jle	 SHORT $LN6@GCServerMs
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _lpNode$[ebp]
  00040	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00048	85 d2		 test	 edx, edx
  0004a	7c 20		 jl	 SHORT $LN6@GCServerMs

; 2897 : 		{
; 2898 : 			GCServerMsgStringSend(szMsg, lpNode->Index[n], type);

  0004c	0f b6 45 10	 movzx	 eax, BYTE PTR _type$[ebp]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _n$1[ebp]
  00054	8b 55 08	 mov	 edx, DWORD PTR _lpNode$[ebp]
  00057	0f bf 84 4a a0
	03 00 00	 movsx	 eax, WORD PTR [edx+ecx*2+928]
  0005f	50		 push	 eax
  00060	8b 4d 0c	 mov	 ecx, DWORD PTR _szMsg$[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@GCServerMs:

; 2899 : 		}
; 2900 : 	}

  0006c	eb ac		 jmp	 SHORT $LN2@GCServerMs
$LN1@GCServerMs:

; 2901 : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ENDP ; GCServerMsgStringSendGuild
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCServerMsgStringSend@@YAXPADHE@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_szMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 1
?GCServerMsgStringSend@@YAXPADHE@Z PROC			; GCServerMsgStringSend, COMDAT

; 2861 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2862 : 	PMSG_NOTICE	pNotice;
; 2863 : 	
; 2864 : #ifdef MODIFY_NOTICE_20040325
; 2865 : 	TNotice::MakeNoticeMsg( &pNotice, type, szMsg );

  00016	8b 45 08	 mov	 eax, DWORD PTR _szMsg$[ebp]
  00019	50		 push	 eax
  0001a	0f b6 4d 10	 movzx	 ecx, BYTE PTR _type$[ebp]
  0001e	51		 push	 ecx
  0001f	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2866 : #else
; 2867 : 	pNotice.type = type;
; 2868 : 	strcpy(pNotice.Notice, szMsg);
; 2869 : 	PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 2870 : #endif
; 2871 : 
; 2872 : 	DataSend(aIndex, (LPBYTE)&pNotice, pNotice.h.size);

  0002e	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  00035	50		 push	 eax
  00036	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2873 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004f	33 cd		 xor	 ecx, ebp
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?GCServerMsgStringSend@@YAXPADHE@Z ENDP			; GCServerMsgStringSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z
_TEXT	SEGMENT
tv346 = -424						; size = 4
tv66 = -424						; size = 4
tv358 = -420						; size = 4
tv347 = -420						; size = 4
tv67 = -420						; size = 4
tv210 = -418						; size = 2
tv205 = -418						; size = 2
_number$1 = -352					; size = 4
_MVL$ = -348						; size = 4
_pActionResult$2 = -344					; size = 9
_pActionResult$3 = -332					; size = 9
_pActionResult$4 = -320					; size = 9
_attr$5 = -306						; size = 1
_mapnumber$6 = -305					; size = 1
_nextY$7 = -304						; size = 4
_nextX$8 = -300						; size = 4
_msg$9 = -296						; size = 255
_lpObj$ = -40						; size = 4
_sy$ = -36						; size = 4
_sx$ = -32						; size = 4
_ay$ = -28						; size = 2
_ax$ = -24						; size = 2
_pathtable$ = -20					; size = 2
_n$ = -16						; size = 2
_pMove$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMove$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z PROC			; PMoveProc, COMDAT

; 14079: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 14080: 	PMSG_RECVMOVE	pMove;
; 14081: 	
; 14082: 	short n, pathtable;
; 14083: 	short ax, ay;
; 14084: 	int   sx, sy;	
; 14085: 	
; 14086: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  00016	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0001a	7d 0c		 jge	 SHORT $LN52@PMoveProc
  0001c	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00026	eb 2b		 jmp	 SHORT $LN53@PMoveProc
$LN52@PMoveProc:
  00028	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0002f	7e 0c		 jle	 SHORT $LN50@PMoveProc
  00031	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN51@PMoveProc
$LN50@PMoveProc:
  0003d	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN51@PMoveProc:
  00047	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 5c fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN53@PMoveProc:
  00053	83 bd 5c fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 21		 jne	 SHORT $LN16@PMoveProc

; 14087: 	{
; 14088: 		LogAdd("error-L3 : move protocol index error %s %d",__FILE__, __LINE__);

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??PMoveProc@@YAXPAUPMSG_MOVE@@H@Z@4JA
  00061	83 c0 09	 add	 eax, 9
  00064	50		 push	 eax
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14089: 		return;

  00078	e9 00 0c 00 00	 jmp	 $LN1@PMoveProc
$LN16@PMoveProc:

; 14090: 	}
; 14091: 	LPOBJECTSTRUCT	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  0007d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00084	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008a	89 45 d8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 14092: 
; 14093: 	if( lpObj->RegenOk > 0 ) 

  0008d	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00090	0f be 88 ff 01
	00 00		 movsx	 ecx, BYTE PTR [eax+511]
  00097	85 c9		 test	 ecx, ecx
  00099	7e 05		 jle	 SHORT $LN17@PMoveProc

; 14094: 	{
; 14095: 		//LogAddL("error-L3 :    . %s %d", __FILE__, __LINE__);
; 14096: 		//char szTemp[256];
; 14097: 		//wsprintf(szTemp,"  ");
; 14098: 		//GCServerMsgStringSend(szTemp, aIndex, 1);
; 14099: 		return;

  0009b	e9 dd 0b 00 00	 jmp	 $LN1@PMoveProc
$LN17@PMoveProc:

; 14100: 	}
; 14101: 
; 14102: #ifdef DARKLORD_WORK	
; 14103: 	if( lpObj->SkillRecallParty_Time )

  000a0	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a3	0f b7 88 7c 10
	00 00		 movzx	 ecx, WORD PTR [eax+4220]
  000aa	85 c9		 test	 ecx, ecx
  000ac	74 44		 je	 SHORT $LN18@PMoveProc

; 14104: 	{
; 14105: 		lpObj->SkillRecallParty_Time = 0;

  000ae	33 c0		 xor	 eax, eax
  000b0	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b3	66 89 81 7c 10
	00 00		 mov	 WORD PTR [ecx+4220], ax

; 14106: 		char msg[255];
; 14107: 		wsprintf(msg, lMsg.Get(1254));	// ""

  000ba	68 e6 04 00 00	 push	 1254			; 000004e6H
  000bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000ca	50		 push	 eax
  000cb	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _msg$9[ebp]
  000d1	50		 push	 eax
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000d8	83 c4 08	 add	 esp, 8

; 14108: 
; 14109: 		GCServerMsgStringSend(msg, lpObj->m_Index, 1);			

  000db	6a 01		 push	 1
  000dd	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e2	51		 push	 ecx
  000e3	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _msg$9[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@PMoveProc:

; 14110: 	}
; 14111: #endif
; 14112: 		
; 14113: 	// 1 3   ..
; 14114: 	if( GetTickCount()-lpObj->m_LastMoveTime < 100 )

  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000f8	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000fb	2b 81 c4 01 00
	00		 sub	 eax, DWORD PTR [ecx+452]
  00101	83 f8 64	 cmp	 eax, 100		; 00000064H
  00104	73 05		 jae	 SHORT $LN19@PMoveProc

; 14115: 	{		
; 14116: #ifdef FOR_ANTI_HACK
; 14117: 		LogAdd("  %d", GetTickCount()-lpObj->m_LastMoveTime);
; 14118: 		if( lpObj->Type == OBJTYPE_CHARACTER  )
; 14119: 		{
; 14120: 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);			
; 14121: 		}
; 14122: 		lpObj->m_LastMoveTime = GetTickCount();
; 14123: #endif
; 14124: 		//char szTemp[256];
; 14125: 		///wsprintf(szTemp,"1 3  ");
; 14126: 		//GCServerMsgStringSend(szTemp, aIndex, 1);		
; 14127: 		
; 14128: #ifdef ADD_ANTI_HACK_01_20051027
; 14129: 		LogAddTD("[Anti-HACK][PMoveProc][LastMoveTime Error] :(%s)(%s) < 100ms", 
; 14130: 				lpObj->AccountID, lpObj->Name);
; 14131: #endif
; 14132: 		return;

  00106	e9 72 0b 00 00	 jmp	 $LN1@PMoveProc
$LN19@PMoveProc:

; 14133: 
; 14134: 	}
; 14135: 	if( lpObj->Teleport ) 

  0010b	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010e	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  00115	85 c9		 test	 ecx, ecx
  00117	74 05		 je	 SHORT $LN20@PMoveProc

; 14136: 	{
; 14137: 		//LogAdd("error-L3 :      %s %d", __FILE__, __LINE__);
; 14138: 		//char szTemp[256];
; 14139: 		//wsprintf(szTemp,"  ");
; 14140: 		//GCServerMsgStringSend(szTemp, aIndex, 1);		
; 14141: 		return;

  00119	e9 5f 0b 00 00	 jmp	 $LN1@PMoveProc
$LN20@PMoveProc:

; 14142: 	}	
; 14143: 
; 14144: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 14145: 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STONE ) == true
; 14146: 		|| gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STUN ) == true 
; 14147: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 14148: 		|| gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SLEEP ) == true 
; 14149: #endif		
; 14150: 	  )
; 14151: 	{
; 14152: 		return;
; 14153: 	}
; 14154: #else
; 14155: 	#ifdef NEW_FORSKYLAND2
; 14156: 	if( lpObj->m_SkillHarden )	//     

  0011e	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00121	83 b8 fc 19 00
	00 00		 cmp	 DWORD PTR [eax+6652], 0
  00128	74 29		 je	 SHORT $LN21@PMoveProc

; 14157: 	{
; 14158: 		gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  0012a	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012d	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00134	51		 push	 ecx
  00135	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00138	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0013f	50		 push	 eax
  00140	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00143	8b 11		 mov	 edx, DWORD PTR [ecx]
  00145	52		 push	 edx
  00146	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14159: 		return;

  0014e	e9 2a 0b 00 00	 jmp	 $LN1@PMoveProc
$LN21@PMoveProc:

; 14160: 	}
; 14161: 	#endif
; 14162: 	
; 14163: 	#ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 14164: 	if( lpObj->m_iSkillStunTime > 0 )	//     .
; 14165: 	{
; 14166: 		gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 14167: 		return;
; 14168: 	}
; 14169: 	#endif
; 14170: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 14171: 	
; 14172: 	lpObj->m_LastMoveTime = GetTickCount();

  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00159	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0015c	89 81 c4 01 00
	00		 mov	 DWORD PTR [ecx+452], eax

; 14173: 
; 14174: 	lpObj->m_Rest    = 0;

  00162	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00165	c6 80 bd 01 00
	00 00		 mov	 BYTE PTR [eax+445], 0

; 14175: 	lpObj->PathCur   = 0;

  0016c	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016f	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 14176: 	lpObj->Dir       = (lpMove->Path[0]>>4);

  00179	b8 01 00 00 00	 mov	 eax, 1
  0017e	6b c8 00	 imul	 ecx, eax, 0
  00181	8b 55 08	 mov	 edx, DWORD PTR _lpMove$[ebp]
  00184	0f b6 44 0a 05	 movzx	 eax, BYTE PTR [edx+ecx+5]
  00189	c1 f8 04	 sar	 eax, 4
  0018c	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0018f	88 81 08 01 00
	00		 mov	 BYTE PTR [ecx+264], al

; 14177: 	lpObj->PathCount = (lpMove->Path[0]&0x0f);

  00195	b8 01 00 00 00	 mov	 eax, 1
  0019a	6b c8 00	 imul	 ecx, eax, 0
  0019d	8b 55 08	 mov	 edx, DWORD PTR _lpMove$[ebp]
  001a0	0f b6 44 0a 05	 movzx	 eax, BYTE PTR [edx+ecx+5]
  001a5	83 e0 0f	 and	 eax, 15			; 0000000fH
  001a8	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ab	89 81 28 01 00
	00		 mov	 DWORD PTR [ecx+296], eax

; 14178: 
; 14179: 	//#ifdef _DEBUG
; 14180: 	if( lpObj->PathCount > MAX_ROADPATH )

  001b1	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b4	83 b8 28 01 00
	00 0f		 cmp	 DWORD PTR [eax+296], 15	; 0000000fH
  001bb	7e 32		 jle	 SHORT $LN22@PMoveProc

; 14181: 	{
; 14182: 		LogAdd("error-L3 : Path Count error %d id:%s %s %d", lpObj->PathCount, lpObj->AccountID, __FILE__, __LINE__);

  001bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??PMoveProc@@YAXPAUPMSG_MOVE@@H@Z@4JA
  001c2	83 c0 67	 add	 eax, 103		; 00000067H
  001c5	50		 push	 eax
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  001cb	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ce	83 c1 68	 add	 ecx, 104		; 00000068H
  001d1	51		 push	 ecx
  001d2	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001d5	8b 82 28 01 00
	00		 mov	 eax, DWORD PTR [edx+296]
  001db	50		 push	 eax
  001dc	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5@
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001e7	83 c4 14	 add	 esp, 20			; 00000014H

; 14183: 		return;

  001ea	e9 8e 0a 00 00	 jmp	 $LN1@PMoveProc
$LN22@PMoveProc:

; 14184: 	}
; 14185: 	for( n=0; n<MAX_ROADPATH; n++)

  001ef	33 c0		 xor	 eax, eax
  001f1	66 89 45 f0	 mov	 WORD PTR _n$[ebp], ax
  001f5	eb 0c		 jmp	 SHORT $LN4@PMoveProc
$LN2@PMoveProc:
  001f7	66 8b 45 f0	 mov	 ax, WORD PTR _n$[ebp]
  001fb	66 83 c0 01	 add	 ax, 1
  001ff	66 89 45 f0	 mov	 WORD PTR _n$[ebp], ax
$LN4@PMoveProc:
  00203	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00207	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0020a	7d 35		 jge	 SHORT $LN3@PMoveProc

; 14186: 	{
; 14187: 		lpObj->PathX[n] = 0;

  0020c	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00210	33 c9		 xor	 ecx, ecx
  00212	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00215	66 89 8c 42 50
	01 00 00	 mov	 WORD PTR [edx+eax*2+336], cx

; 14188: 		lpObj->PathY[n] = 0;

  0021d	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00221	33 c9		 xor	 ecx, ecx
  00223	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00226	66 89 8c 42 6e
	01 00 00	 mov	 WORD PTR [edx+eax*2+366], cx

; 14189: 		lpObj->PathOri[n] = 0;

  0022e	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00232	33 c9		 xor	 ecx, ecx
  00234	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00237	66 89 8c 42 32
	01 00 00	 mov	 WORD PTR [edx+eax*2+306], cx

; 14190: 	}

  0023f	eb b6		 jmp	 SHORT $LN2@PMoveProc
$LN3@PMoveProc:

; 14191: 	//#endif
; 14192: 
; 14193: 	//   
; 14194: 	sx = lpMove->X;

  00241	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  00244	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00248	89 4d e0	 mov	 DWORD PTR _sx$[ebp], ecx

; 14195: 	sy = lpMove->Y;	

  0024b	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  0024e	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00252	89 4d dc	 mov	 DWORD PTR _sy$[ebp], ecx

; 14196: 	
; 14197: #ifdef ADD_LOG_CHECK_INVLIDE_X_Y_POSITION_20060131
; 14198: 	if( gObjCheckXYMapTile(lpObj,DBGNAME_PMoveProc) == TRUE )

  00255	6a 01		 push	 1
  00257	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025a	50		 push	 eax
  0025b	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile
  00260	83 c4 08	 add	 esp, 8
  00263	83 f8 01	 cmp	 eax, 1
  00266	75 4d		 jne	 SHORT $LN23@PMoveProc

; 14199: #ifdef MODIFY_FORCEMOVE_TO_LORENCIA_20060515
; 14200: 	{
; 14201: 		// Path  Clear.
; 14202: 		lpObj->PathCount = 0;

  00268	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026b	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 14203: 		lpObj->PathCur = 0;

  00275	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00278	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 14204: 		// 0524  
; 14205: 		lpObj->PathStartEnd = 0;

  00282	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00285	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0

; 14206: 		gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  0028c	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028f	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00296	51		 push	 ecx
  00297	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0029a	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  002a1	50		 push	 eax
  002a2	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  002a7	52		 push	 edx
  002a8	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  002ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14207: 		return;

  002b0	e9 c8 09 00 00	 jmp	 $LN1@PMoveProc
$LN23@PMoveProc:

; 14208: 	}
; 14209: #else	// #ifdef MODIFY_FORCEMOVE_TO_LORENCIA_20060515
; 14210: 		return;
; 14211: #endif // #ifdef MODIFY_FORCEMOVE_TO_LORENCIA_20060515		
; 14212: 
; 14213: #else
; 14214: 	if( gObjCheckXYMapTile(lpObj) == TRUE ) 
; 14215: 		return;
; 14216: #endif // ADD_LOG_CHECK_INVLIDE_X_Y_POSITION_20060131
; 14217: 	
; 14218: 	ax = lpObj->PathX[0] = lpMove->X;

  002b5	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  002b8	66 0f b6 48 03	 movzx	 cx, BYTE PTR [eax+3]
  002bd	66 89 8d 5e fe
	ff ff		 mov	 WORD PTR tv205[ebp], cx
  002c4	ba 02 00 00 00	 mov	 edx, 2
  002c9	6b c2 00	 imul	 eax, edx, 0
  002cc	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002cf	66 8b 95 5e fe
	ff ff		 mov	 dx, WORD PTR tv205[ebp]
  002d6	66 89 94 01 50
	01 00 00	 mov	 WORD PTR [ecx+eax+336], dx
  002de	66 8b 85 5e fe
	ff ff		 mov	 ax, WORD PTR tv205[ebp]
  002e5	66 89 45 e8	 mov	 WORD PTR _ax$[ebp], ax

; 14219: 	ay = lpObj->PathY[0] = lpMove->Y;

  002e9	8b 45 08	 mov	 eax, DWORD PTR _lpMove$[ebp]
  002ec	66 0f b6 48 04	 movzx	 cx, BYTE PTR [eax+4]
  002f1	66 89 8d 5e fe
	ff ff		 mov	 WORD PTR tv210[ebp], cx
  002f8	ba 02 00 00 00	 mov	 edx, 2
  002fd	6b c2 00	 imul	 eax, edx, 0
  00300	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00303	66 8b 95 5e fe
	ff ff		 mov	 dx, WORD PTR tv210[ebp]
  0030a	66 89 94 01 6e
	01 00 00	 mov	 WORD PTR [ecx+eax+366], dx
  00312	66 8b 85 5e fe
	ff ff		 mov	 ax, WORD PTR tv210[ebp]
  00319	66 89 45 e4	 mov	 WORD PTR _ay$[ebp], ax

; 14220: 	
; 14221: 	lpObj->PathDir[0] = lpObj->Dir;

  0031d	b8 01 00 00 00	 mov	 eax, 1
  00322	6b c8 00	 imul	 ecx, eax, 0
  00325	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00328	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0032b	8a 80 08 01 00
	00		 mov	 al, BYTE PTR [eax+264]
  00331	88 84 0a 8c 01
	00 00		 mov	 BYTE PTR [edx+ecx+396], al

; 14222: 	lpObj->PathStartEnd = 1;

  00338	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033b	c6 80 30 01 00
	00 01		 mov	 BYTE PTR [eax+304], 1

; 14223: 
; 14224: 	if( lpObj->PathCount > 0 ) 

  00342	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00345	83 b8 28 01 00
	00 00		 cmp	 DWORD PTR [eax+296], 0
  0034c	7e 22		 jle	 SHORT $LN24@PMoveProc

; 14225: 	{
; 14226: 		lpObj->PathCur = 1; 

  0034e	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00351	c7 80 2c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+300], 1

; 14227: 		lpObj->PathCount += 1;

  0035b	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035e	8b 88 28 01 00
	00		 mov	 ecx, DWORD PTR [eax+296]
  00364	83 c1 01	 add	 ecx, 1
  00367	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0036a	89 8a 28 01 00
	00		 mov	 DWORD PTR [edx+296], ecx
$LN24@PMoveProc:

; 14228: 	}
; 14229: 
; 14230: 	for( n=1; n<lpObj->PathCount; n++)

  00370	b8 01 00 00 00	 mov	 eax, 1
  00375	66 89 45 f0	 mov	 WORD PTR _n$[ebp], ax
  00379	eb 0c		 jmp	 SHORT $LN7@PMoveProc
$LN5@PMoveProc:
  0037b	66 8b 45 f0	 mov	 ax, WORD PTR _n$[ebp]
  0037f	66 83 c0 01	 add	 ax, 1
  00383	66 89 45 f0	 mov	 WORD PTR _n$[ebp], ax
$LN7@PMoveProc:
  00387	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  0038b	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0038e	3b 81 28 01 00
	00		 cmp	 eax, DWORD PTR [ecx+296]
  00394	0f 8d cc 00 00
	00		 jge	 $LN6@PMoveProc

; 14231: 	{
; 14232: 		if( n%2 == 1 )

  0039a	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  0039e	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  003a3	79 05		 jns	 SHORT $LN58@PMoveProc
  003a5	48		 dec	 eax
  003a6	83 c8 fe	 or	 eax, -2			; fffffffeH
  003a9	40		 inc	 eax
$LN58@PMoveProc:
  003aa	83 f8 01	 cmp	 eax, 1
  003ad	75 1d		 jne	 SHORT $LN25@PMoveProc

; 14233: 			 pathtable = (lpMove->Path[(n+1)/2]>>4);

  003af	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  003b3	83 c0 01	 add	 eax, 1
  003b6	99		 cdq
  003b7	2b c2		 sub	 eax, edx
  003b9	d1 f8		 sar	 eax, 1
  003bb	8b 4d 08	 mov	 ecx, DWORD PTR _lpMove$[ebp]
  003be	0f b6 54 01 05	 movzx	 edx, BYTE PTR [ecx+eax+5]
  003c3	c1 fa 04	 sar	 edx, 4
  003c6	66 89 55 ec	 mov	 WORD PTR _pathtable$[ebp], dx
  003ca	eb 1b		 jmp	 SHORT $LN26@PMoveProc
$LN25@PMoveProc:

; 14234: 		else pathtable = (lpMove->Path[(n+1)/2]&0x0f);

  003cc	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  003d0	83 c0 01	 add	 eax, 1
  003d3	99		 cdq
  003d4	2b c2		 sub	 eax, edx
  003d6	d1 f8		 sar	 eax, 1
  003d8	8b 4d 08	 mov	 ecx, DWORD PTR _lpMove$[ebp]
  003db	0f b6 54 01 05	 movzx	 edx, BYTE PTR [ecx+eax+5]
  003e0	83 e2 0f	 and	 edx, 15			; 0000000fH
  003e3	66 89 55 ec	 mov	 WORD PTR _pathtable$[ebp], dx
$LN26@PMoveProc:

; 14235: 
; 14236: 		ax += RoadPathTable[pathtable*2];

  003e7	0f bf 45 ec	 movsx	 eax, WORD PTR _pathtable$[ebp]
  003eb	d1 e0		 shl	 eax, 1
  003ed	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[eax*2]
  003f5	0f bf 55 e8	 movsx	 edx, WORD PTR _ax$[ebp]
  003f9	03 d1		 add	 edx, ecx
  003fb	66 89 55 e8	 mov	 WORD PTR _ax$[ebp], dx

; 14237: 		ay += RoadPathTable[(pathtable*2)+1];		

  003ff	0f bf 45 ec	 movsx	 eax, WORD PTR _pathtable$[ebp]
  00403	d1 e0		 shl	 eax, 1
  00405	0f bf 0c 45 02
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[eax*2+2]
  0040d	0f bf 55 e4	 movsx	 edx, WORD PTR _ay$[ebp]
  00411	03 d1		 add	 edx, ecx
  00413	66 89 55 e4	 mov	 WORD PTR _ay$[ebp], dx

; 14238: 
; 14239: 		lpObj->PathOri[n-1] = pathtable;

  00417	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  0041b	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0041e	66 8b 55 ec	 mov	 dx, WORD PTR _pathtable$[ebp]
  00422	66 89 94 41 30
	01 00 00	 mov	 WORD PTR [ecx+eax*2+304], dx

; 14240: 		lpObj->PathDir[n]   = (char)pathtable;

  0042a	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  0042e	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00431	8a 55 ec	 mov	 dl, BYTE PTR _pathtable$[ebp]
  00434	88 94 01 8c 01
	00 00		 mov	 BYTE PTR [ecx+eax+396], dl

; 14241: 		lpObj->PathX[n]     = ax;

  0043b	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  0043f	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00442	66 8b 55 e8	 mov	 dx, WORD PTR _ax$[ebp]
  00446	66 89 94 41 50
	01 00 00	 mov	 WORD PTR [ecx+eax*2+336], dx

; 14242: 		lpObj->PathY[n]     = ay;

  0044e	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00452	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00455	66 8b 55 e4	 mov	 dx, WORD PTR _ay$[ebp]
  00459	66 89 94 41 6e
	01 00 00	 mov	 WORD PTR [ecx+eax*2+366], dx

; 14243: 	}

  00461	e9 15 ff ff ff	 jmp	 $LN5@PMoveProc
$LN6@PMoveProc:

; 14244: 	
; 14245: #ifdef MODIFY_FORCEMOVE_TO_LORENCIA_20060515
; 14246: 	//     ,    .
; 14247: 	if ( lpObj->PathCount > 0 )

  00466	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00469	83 b8 28 01 00
	00 00		 cmp	 DWORD PTR [eax+296], 0
  00470	0f 8e 32 01 00
	00		 jle	 $LN27@PMoveProc

; 14248: 	{
; 14249: 		int nextX = lpObj->PathX[1];

  00476	b8 02 00 00 00	 mov	 eax, 2
  0047b	c1 e0 00	 shl	 eax, 0
  0047e	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00481	0f bf 94 01 50
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+336]
  00489	89 95 d4 fe ff
	ff		 mov	 DWORD PTR _nextX$8[ebp], edx

; 14250: 		int nextY = lpObj->PathY[1];

  0048f	b8 02 00 00 00	 mov	 eax, 2
  00494	c1 e0 00	 shl	 eax, 0
  00497	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0049a	0f bf 94 01 6e
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+366]
  004a2	89 95 d0 fe ff
	ff		 mov	 DWORD PTR _nextY$7[ebp], edx

; 14251: 
; 14252: 		BYTE mapnumber;
; 14253: 		mapnumber	= lpObj->MapNumber;

  004a8	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004ab	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  004b1	88 8d cf fe ff
	ff		 mov	 BYTE PTR _mapnumber$6[ebp], cl

; 14254: 		if ( mapnumber > g_TerrainManager.Size() - 1 )

  004b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  004bc	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size

; 14255: 		{
; 14256: 			//  
; 14257: 		}
; 14258: 		BYTE attr =  MapC[mapnumber].GetAttr(nextX, nextY);

  004c1	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _nextY$7[ebp]
  004c7	50		 push	 eax
  004c8	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _nextX$8[ebp]
  004ce	51		 push	 ecx
  004cf	0f b6 95 cf fe
	ff ff		 movzx	 edx, BYTE PTR _mapnumber$6[ebp]
  004d6	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  004dc	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  004e2	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  004e7	88 85 ce fe ff
	ff		 mov	 BYTE PTR _attr$5[ebp], al

; 14259: 		if( (attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK || 

  004ed	0f b6 85 ce fe
	ff ff		 movzx	 eax, BYTE PTR _attr$5[ebp]
  004f4	83 e0 04	 and	 eax, 4
  004f7	75 10		 jne	 SHORT $LN30@PMoveProc
  004f9	0f b6 85 ce fe
	ff ff		 movzx	 eax, BYTE PTR _attr$5[ebp]
  00500	83 e0 08	 and	 eax, 8
  00503	0f 84 9f 00 00
	00		 je	 $LN27@PMoveProc
$LN30@PMoveProc:

; 14260: 			(attr&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW
; 14261: 			)	
; 14262: 		{
; 14263: 			//    .
; 14264: 			for( n=0; n<MAX_ROADPATH; n++)

  00509	33 c0		 xor	 eax, eax
  0050b	66 89 45 f0	 mov	 WORD PTR _n$[ebp], ax
  0050f	eb 0c		 jmp	 SHORT $LN10@PMoveProc
$LN8@PMoveProc:
  00511	66 8b 45 f0	 mov	 ax, WORD PTR _n$[ebp]
  00515	66 83 c0 01	 add	 ax, 1
  00519	66 89 45 f0	 mov	 WORD PTR _n$[ebp], ax
$LN10@PMoveProc:
  0051d	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00521	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00524	7d 35		 jge	 SHORT $LN9@PMoveProc

; 14265: 			{
; 14266: 				lpObj->PathX[n] = 0;

  00526	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  0052a	33 c9		 xor	 ecx, ecx
  0052c	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0052f	66 89 8c 42 50
	01 00 00	 mov	 WORD PTR [edx+eax*2+336], cx

; 14267: 				lpObj->PathY[n] = 0;

  00537	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  0053b	33 c9		 xor	 ecx, ecx
  0053d	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00540	66 89 8c 42 6e
	01 00 00	 mov	 WORD PTR [edx+eax*2+366], cx

; 14268: 				lpObj->PathOri[n] = 0;

  00548	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  0054c	33 c9		 xor	 ecx, ecx
  0054e	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00551	66 89 8c 42 32
	01 00 00	 mov	 WORD PTR [edx+eax*2+306], cx

; 14269: 			}

  00559	eb b6		 jmp	 SHORT $LN8@PMoveProc
$LN9@PMoveProc:

; 14270: 			lpObj->PathCount = 0;

  0055b	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0055e	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 14271: 			lpObj->PathCur = 0;

  00568	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0056b	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 14272: 			lpObj->PathStartEnd = 0;

  00575	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00578	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0

; 14273: 			// 0524  
; 14274: 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  0057f	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00582	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00589	51		 push	 ecx
  0058a	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0058d	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00594	50		 push	 eax
  00595	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00598	8b 11		 mov	 edx, DWORD PTR [ecx]
  0059a	52		 push	 edx
  0059b	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  005a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14275: 			return;

  005a3	e9 d5 06 00 00	 jmp	 $LN1@PMoveProc
$LN27@PMoveProc:

; 14276: 		}
; 14277: 	}
; 14278: #endif //MODIFY_FORCEMOVE_TO_LORENCIA_20060515
; 14279: 	
; 14280: 	lpObj->TX     = (BYTE)ax;

  005a8	66 0f b6 45 e8	 movzx	 ax, BYTE PTR _ax$[ebp]
  005ad	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005b0	66 89 81 20 01
	00 00		 mov	 WORD PTR [ecx+288], ax

; 14281: 	lpObj->TY     = (BYTE)ay;

  005b7	66 0f b6 45 e4	 movzx	 ax, BYTE PTR _ay$[ebp]
  005bc	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005bf	66 89 81 22 01
	00 00		 mov	 WORD PTR [ecx+290], ax

; 14282: 
; 14283: 
; 14284: #ifdef CASTLE_NPC_GATE_WORK_20041206		//      
; 14285: 	
; 14286: //#if TESTSERVER != 1						//  !!! ->        
; 14287: 	//       .
; 14288: 	if (lpObj->Type == OBJTYPE_CHARACTER) {
; 14289: 		INT iCX			= lpObj->X;
; 14290: 		INT iCY			= lpObj->Y;
; 14291: 		BOOL bSetStand	= FALSE;
; 14292: 		WORD wMapAttr	= 0;
; 14293: 
; 14294: 		for (INT iCOUNT = 0 ; iCOUNT < MAX_TERRAIN_SIZE ; iCOUNT++) {
; 14295: 			if (iCX > lpObj->TX)	iCX -= 1;
; 14296: 			if (iCX < lpObj->TX)	iCX += 1;
; 14297: 			if (iCY > lpObj->TY)	iCY -= 1;
; 14298: 			if (iCY < lpObj->TY)	iCY += 1;
; 14299: 
; 14300: 			//   .
; 14301: 			wMapAttr		= MapC[lpObj->MapNumber].GetAttr(iCX, iCY);
; 14302: 			if ((wMapAttr&MAP_ATTR_WATER) == MAP_ATTR_WATER) {			//  (   )
; 14303: 				bSetStand	= TRUE;
; 14304: 				break;
; 14305: 			}
; 14306: 
; 14307: 			if ((iCX == lpObj->TX) && (iCY == lpObj->TY)) {
; 14308: 				break;
; 14309: 			}
; 14310: 		}
; 14311: 
; 14312: 		if (bSetStand == TRUE) {
; 14313: 			lpObj->m_Rest = 1;
; 14314: 			lpObj->PathCur = 0;
; 14315: 			lpObj->PathCount = 0;
; 14316: 			lpObj->PathStartEnd = 0;
; 14317: 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);									//    
; 14318: 			
; 14319: 			PMSG_ACTIONRESULT	pActionResult;
; 14320: 			PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof( pActionResult ));
; 14321: 			pActionResult.NumberH		= HIBYTE(aIndex);
; 14322: 			pActionResult.NumberL		= LOBYTE(aIndex);
; 14323: 			pActionResult.ActionNumber	= AT_STAND1;
; 14324: 			pActionResult.Dir = lpObj->Dir;
; 14325: #ifdef ADD_TRAP_OBJECT_EXTEND_20060731
; 14326: 			pActionResult.TargetNumberH = 0;
; 14327: 			pActionResult.TargetNumberL = 0;
; 14328: #endif
; 14329: 			DataSend(lpObj->m_Index, (unsigned char*) &pActionResult, sizeof(PMSG_ACTIONRESULT));	//   .
; 14330: 			return;
; 14331: 		}
; 14332: 	}
; 14333: //#endif //##TESTSERVER != 1
; 14334: 
; 14335: #endif //##CASTLE_NPC_GATE_WORK_20041206
; 14336: 
; 14337: 	
; 14338: #ifdef FOR_BLOODCASTLE
; 14339: 	//    . ( )
; 14340: 	if (CHECK_BLOODCASTLE(lpObj->MapNumber) && (lpObj->Type == OBJTYPE_CHARACTER)) {

  005c6	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005c9	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  005d0	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  005d3	7d 0c		 jge	 SHORT $LN56@PMoveProc
  005d5	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv347[ebp], 0
  005df	eb 31		 jmp	 SHORT $LN57@PMoveProc
$LN56@PMoveProc:
  005e1	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005e4	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  005eb	83 f8 11	 cmp	 eax, 17			; 00000011H
  005ee	7e 0c		 jle	 SHORT $LN54@PMoveProc
  005f0	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv346[ebp], 0
  005fa	eb 0a		 jmp	 SHORT $LN55@PMoveProc
$LN54@PMoveProc:
  005fc	c7 85 58 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv346[ebp], 1
$LN55@PMoveProc:
  00606	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv346[ebp]
  0060c	89 8d 5c fe ff
	ff		 mov	 DWORD PTR tv347[ebp], ecx
$LN57@PMoveProc:
  00612	83 bd 5c fe ff
	ff 00		 cmp	 DWORD PTR tv347[ebp], 0
  00619	0f 84 3b 03 00
	00		 je	 $LN31@PMoveProc
  0061f	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00622	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00626	83 f9 01	 cmp	 ecx, 1
  00629	0f 85 2b 03 00
	00		 jne	 $LN31@PMoveProc

; 14341: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14342: 		int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( lpObj->MapNumber );
; 14343: 		switch(g_BloodCastle.GetCurrentState( iBridgeIndex )) {
; 14344: #else
; 14345: 		switch(g_BloodCastle.GetCurrentState(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1)) {

  0062f	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00632	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00639	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0063c	51		 push	 ecx
  0063d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00642	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00647	89 85 5c fe ff
	ff		 mov	 DWORD PTR tv358[ebp], eax
  0064d	83 bd 5c fe ff
	ff 01		 cmp	 DWORD PTR tv358[ebp], 1
  00654	74 12		 je	 SHORT $LN32@PMoveProc
  00656	83 bd 5c fe ff
	ff 02		 cmp	 DWORD PTR tv358[ebp], 2
  0065d	0f 84 d3 00 00
	00		 je	 $LN34@PMoveProc
  00663	e9 f2 02 00 00	 jmp	 $LN31@PMoveProc
$LN32@PMoveProc:

; 14346: #endif
; 14347: 		case BLOODCASTLE_STATE_CLOSED:
; 14348: 			{
; 14349: 				if (lpObj->TY > 15) {

  00668	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0066b	0f bf 88 22 01
	00 00		 movsx	 ecx, WORD PTR [eax+290]
  00672	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00675	0f 8e b6 00 00
	00		 jle	 $LN33@PMoveProc

; 14350: 					lpObj->m_Rest = 1;

  0067b	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0067e	c6 80 bd 01 00
	00 01		 mov	 BYTE PTR [eax+445], 1

; 14351: 					lpObj->PathCur = 0;

  00685	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00688	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 14352: 					lpObj->PathCount = 0;

  00692	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00695	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 14353: 					lpObj->PathStartEnd = 0;

  0069f	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006a2	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0

; 14354: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);									//    

  006a9	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ac	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  006b3	51		 push	 ecx
  006b4	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006b7	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  006be	50		 push	 eax
  006bf	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006c2	8b 11		 mov	 edx, DWORD PTR [ecx]
  006c4	52		 push	 edx
  006c5	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  006ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14355: 					
; 14356: 					PMSG_ACTIONRESULT	pActionResult;
; 14357: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof( pActionResult ));

  006cd	6a 09		 push	 9
  006cf	6a 18		 push	 24			; 00000018H
  006d1	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$4[ebp]
  006d7	50		 push	 eax
  006d8	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  006dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14358: 					pActionResult.NumberH		= HIBYTE(aIndex);

  006e0	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006e3	c1 e8 08	 shr	 eax, 8
  006e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006eb	88 85 c3 fe ff
	ff		 mov	 BYTE PTR _pActionResult$4[ebp+3], al

; 14359: 					pActionResult.NumberL		= LOBYTE(aIndex);

  006f1	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  006f4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006f9	88 85 c4 fe ff
	ff		 mov	 BYTE PTR _pActionResult$4[ebp+4], al

; 14360: 					pActionResult.ActionNumber	= AT_STAND1;

  006ff	c6 85 c6 fe ff
	ff 7a		 mov	 BYTE PTR _pActionResult$4[ebp+6], 122 ; 0000007aH

; 14361: 					pActionResult.Dir = lpObj->Dir;

  00706	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00709	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  0070f	88 8d c5 fe ff
	ff		 mov	 BYTE PTR _pActionResult$4[ebp+5], cl

; 14362: #ifdef ADD_TRAP_OBJECT_EXTEND_20060731
; 14363: 					pActionResult.TargetNumberH = 0;
; 14364: 					pActionResult.TargetNumberL = 0;
; 14365: #endif
; 14366: 					DataSend(lpObj->m_Index, (unsigned char*) &pActionResult, sizeof(PMSG_ACTIONRESULT));	//   .

  00715	6a 09		 push	 9
  00717	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$4[ebp]
  0071d	50		 push	 eax
  0071e	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00721	8b 11		 mov	 edx, DWORD PTR [ecx]
  00723	52		 push	 edx
  00724	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00729	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14367: //					gObjMoveGate(lpObj->m_Index, 66 + lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1);
; 14368: 					return;

  0072c	e9 4c 05 00 00	 jmp	 $LN1@PMoveProc
$LN33@PMoveProc:

; 14369: 				}
; 14370: 			}
; 14371: 			break;

  00731	e9 24 02 00 00	 jmp	 $LN31@PMoveProc
$LN34@PMoveProc:

; 14372: 		case BLOODCASTLE_STATE_PLAYING:
; 14373: 			{
; 14374: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14375: 				if ((lpObj->Y > 17) && (!g_BloodCastle.CheckPlayStart( iBridgeIndex ))) {
; 14376: 					gObjMoveGate (lpObj->m_Index, 66 + iBridgeIndex );
; 14377: #else
; 14378: 				if ((lpObj->Y > 17) && (!g_BloodCastle.CheckPlayStart(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1))) {

  00736	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00739	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00740	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00743	7e 40		 jle	 SHORT $LN35@PMoveProc
  00745	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00748	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0074f	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00752	51		 push	 ecx
  00753	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00758	e8 00 00 00 00	 call	 ?CheckPlayStart@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckPlayStart
  0075d	0f b6 d0	 movzx	 edx, al
  00760	85 d2		 test	 edx, edx
  00762	75 21		 jne	 SHORT $LN35@PMoveProc

; 14379: 					gObjMoveGate (lpObj->m_Index, 66 + lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1);

  00764	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00767	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0076e	83 c1 37	 add	 ecx, 55			; 00000037H
  00771	51		 push	 ecx
  00772	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00775	8b 02		 mov	 eax, DWORD PTR [edx]
  00777	50		 push	 eax
  00778	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0077d	83 c4 08	 add	 esp, 8

; 14380: #endif
; 14381: 					return;

  00780	e9 f8 04 00 00	 jmp	 $LN1@PMoveProc
$LN35@PMoveProc:

; 14382: 				}
; 14383: 
; 14384: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14385: 				if ((lpObj->TY > 15) && (!g_BloodCastle.CheckPlayStart( iBridgeIndex ))) {
; 14386: #else
; 14387: 				if ((lpObj->TY > 15) && (!g_BloodCastle.CheckPlayStart(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1))) {

  00785	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00788	0f bf 88 22 01
	00 00		 movsx	 ecx, WORD PTR [eax+290]
  0078f	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00792	0f 8e d9 00 00
	00		 jle	 $LN36@PMoveProc
  00798	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0079b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  007a2	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  007a5	51		 push	 ecx
  007a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  007ab	e8 00 00 00 00	 call	 ?CheckPlayStart@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckPlayStart
  007b0	0f b6 d0	 movzx	 edx, al
  007b3	85 d2		 test	 edx, edx
  007b5	0f 85 b6 00 00
	00		 jne	 $LN36@PMoveProc

; 14388: #endif
; 14389: 					lpObj->m_Rest = 1;

  007bb	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007be	c6 80 bd 01 00
	00 01		 mov	 BYTE PTR [eax+445], 1

; 14390: 					lpObj->PathCur = 0;

  007c5	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007c8	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 14391: 					lpObj->PathCount = 0;

  007d2	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007d5	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 14392: 					lpObj->PathStartEnd = 0;

  007df	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007e2	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0

; 14393: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);									//    

  007e9	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007ec	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  007f3	51		 push	 ecx
  007f4	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007f7	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  007fe	50		 push	 eax
  007ff	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00802	8b 11		 mov	 edx, DWORD PTR [ecx]
  00804	52		 push	 edx
  00805	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  0080a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14394: 					
; 14395: 					PMSG_ACTIONRESULT	pActionResult;
; 14396: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof( pActionResult ));

  0080d	6a 09		 push	 9
  0080f	6a 18		 push	 24			; 00000018H
  00811	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$3[ebp]
  00817	50		 push	 eax
  00818	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0081d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14397: 					pActionResult.NumberH		= HIBYTE(aIndex);

  00820	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00823	c1 e8 08	 shr	 eax, 8
  00826	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0082b	88 85 b7 fe ff
	ff		 mov	 BYTE PTR _pActionResult$3[ebp+3], al

; 14398: 					pActionResult.NumberL		= LOBYTE(aIndex);

  00831	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00834	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00839	88 85 b8 fe ff
	ff		 mov	 BYTE PTR _pActionResult$3[ebp+4], al

; 14399: 					pActionResult.ActionNumber	= AT_STAND1;

  0083f	c6 85 ba fe ff
	ff 7a		 mov	 BYTE PTR _pActionResult$3[ebp+6], 122 ; 0000007aH

; 14400: 					pActionResult.Dir = lpObj->Dir;

  00846	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00849	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  0084f	88 8d b9 fe ff
	ff		 mov	 BYTE PTR _pActionResult$3[ebp+5], cl

; 14401: #ifdef ADD_TRAP_OBJECT_EXTEND_20060731
; 14402: 					pActionResult.TargetNumberH = 0;
; 14403: 					pActionResult.TargetNumberL = 0;
; 14404: #endif
; 14405: 					DataSend(lpObj->m_Index, (unsigned char*) &pActionResult, sizeof(PMSG_ACTIONRESULT));	//   .

  00855	6a 09		 push	 9
  00857	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$3[ebp]
  0085d	50		 push	 eax
  0085e	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00861	8b 11		 mov	 edx, DWORD PTR [ecx]
  00863	52		 push	 edx
  00864	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00869	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14406: //					gObjMoveGate(lpObj->m_Index, 66 + lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1);
; 14407: 					return;

  0086c	e9 0c 04 00 00	 jmp	 $LN1@PMoveProc
$LN36@PMoveProc:

; 14408: 				}
; 14409: 
; 14410: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14411: 				if ((lpObj->TY > 76) && (g_BloodCastle.m_BridgeData[iBridgeIndex].m_bCASTLE_DOOR_LIVE)) {
; 14412: #else
; 14413: 				if ((lpObj->TY > 76) && (g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_bCASTLE_DOOR_LIVE)) {

  00871	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00874	0f bf 88 22 01
	00 00		 movsx	 ecx, WORD PTR [eax+290]
  0087b	83 f9 4c	 cmp	 ecx, 76			; 0000004cH
  0087e	0f 8e d6 00 00
	00		 jle	 $LN31@PMoveProc
  00884	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00887	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0088e	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00891	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00897	83 ba 4c 01 00
	00 00		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+332], 0
  0089e	0f 84 b6 00 00
	00		 je	 $LN31@PMoveProc

; 14414: #endif
; 14415: 					lpObj->m_Rest = 1;

  008a4	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008a7	c6 80 bd 01 00
	00 01		 mov	 BYTE PTR [eax+445], 1

; 14416: 					lpObj->PathCur = 0;

  008ae	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008b1	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 14417: 					lpObj->PathCount = 0;

  008bb	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008be	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 14418: 					lpObj->PathStartEnd = 0;

  008c8	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008cb	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0

; 14419: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);									//    

  008d2	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008d5	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  008dc	51		 push	 ecx
  008dd	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008e0	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  008e7	50		 push	 eax
  008e8	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  008eb	8b 11		 mov	 edx, DWORD PTR [ecx]
  008ed	52		 push	 edx
  008ee	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  008f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14420: 					
; 14421: 					PMSG_ACTIONRESULT	pActionResult;
; 14422: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof( pActionResult ));

  008f6	6a 09		 push	 9
  008f8	6a 18		 push	 24			; 00000018H
  008fa	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$2[ebp]
  00900	50		 push	 eax
  00901	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00906	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14423: 					pActionResult.NumberH		= HIBYTE(aIndex);

  00909	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0090c	c1 e8 08	 shr	 eax, 8
  0090f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00914	88 85 ab fe ff
	ff		 mov	 BYTE PTR _pActionResult$2[ebp+3], al

; 14424: 					pActionResult.NumberL		= LOBYTE(aIndex);

  0091a	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0091d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00922	88 85 ac fe ff
	ff		 mov	 BYTE PTR _pActionResult$2[ebp+4], al

; 14425: 					pActionResult.ActionNumber	= AT_STAND1;

  00928	c6 85 ae fe ff
	ff 7a		 mov	 BYTE PTR _pActionResult$2[ebp+6], 122 ; 0000007aH

; 14426: 					pActionResult.Dir = lpObj->Dir;

  0092f	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00932	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00938	88 8d ad fe ff
	ff		 mov	 BYTE PTR _pActionResult$2[ebp+5], cl

; 14427: #ifdef ADD_TRAP_OBJECT_EXTEND_20060731
; 14428: 					pActionResult.TargetNumberH = 0;
; 14429: 					pActionResult.TargetNumberL = 0;
; 14430: #endif
; 14431: 					DataSend(lpObj->m_Index, (unsigned char*) &pActionResult, sizeof(PMSG_ACTIONRESULT));	//   .

  0093e	6a 09		 push	 9
  00940	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$2[ebp]
  00946	50		 push	 eax
  00947	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0094a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0094c	52		 push	 edx
  0094d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00952	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14432: //					gObjMoveGate(lpObj->m_Index, 66 + lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1);
; 14433: 					return;

  00955	e9 23 03 00 00	 jmp	 $LN1@PMoveProc
$LN31@PMoveProc:

; 14434: 				}
; 14435: 			}
; 14436: 			break;
; 14437: 		default:
; 14438: 			break;
; 14439: 		}
; 14440: 	}
; 14441: #endif
; 14442: 
; 14443: 
; 14444: #ifdef PACKET_CHANGE	
; 14445: 	PHeadSetB((LPBYTE)&pMove, PACKET_MOVE, sizeof( pMove ));

  0095a	6a 08		 push	 8
  0095c	68 d7 00 00 00	 push	 215			; 000000d7H
  00961	8d 45 f4	 lea	 eax, DWORD PTR _pMove$[ebp]
  00964	50		 push	 eax
  00965	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0096a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14446: #else
; 14447: 	PHeadSetB((LPBYTE)&pMove, 0x10, sizeof( pMove ));
; 14448: #endif
; 14449: 
; 14450: 	pMove.NumberH		= HIBYTE(aIndex);

  0096d	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00970	c1 e8 08	 shr	 eax, 8
  00973	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00978	88 45 f7	 mov	 BYTE PTR _pMove$[ebp+3], al

; 14451: 	pMove.NumberL		= LOBYTE(aIndex);

  0097b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0097e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00983	88 45 f8	 mov	 BYTE PTR _pMove$[ebp+4], al

; 14452: 	pMove.X				= (BYTE)ax;

  00986	8a 45 e8	 mov	 al, BYTE PTR _ax$[ebp]
  00989	88 45 f9	 mov	 BYTE PTR _pMove$[ebp+5], al

; 14453: 	pMove.Y				= (BYTE)ay;

  0098c	8a 45 e4	 mov	 al, BYTE PTR _ay$[ebp]
  0098f	88 45 fa	 mov	 BYTE PTR _pMove$[ebp+6], al

; 14454: 	pMove.Path          = lpObj->Dir<<4;

  00992	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00995	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  0099c	c1 e1 04	 shl	 ecx, 4
  0099f	88 4d fb	 mov	 BYTE PTR _pMove$[ebp+7], cl

; 14455: 	
; 14456: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  009a2	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009a5	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  009a9	83 f9 01	 cmp	 ecx, 1
  009ac	0f 85 e6 00 00
	00		 jne	 $LN39@PMoveProc

; 14457: 	{
; 14458: 		if( lpObj->m_IfState.use ) 

  009b2	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009b5	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  009bb	80 e1 03	 and	 cl, 3
  009be	0f b6 d1	 movzx	 edx, cl
  009c1	85 d2		 test	 edx, edx
  009c3	74 4e		 je	 SHORT $LN40@PMoveProc

; 14459: 		{
; 14460: 			if( lpObj->m_IfState.type == I_SHOP )	//  ..

  009c5	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009c8	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  009ce	c0 e9 04	 shr	 cl, 4
  009d1	80 e1 0f	 and	 cl, 15			; 0000000fH
  009d4	0f b6 d1	 movzx	 edx, cl
  009d7	83 fa 03	 cmp	 edx, 3
  009da	75 37		 jne	 SHORT $LN40@PMoveProc

; 14461: 			{
; 14462: 				lpObj->TargetShopNumber = -1;	//  .

  009dc	83 c8 ff	 or	 eax, -1
  009df	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009e2	66 89 81 ae 02
	00 00		 mov	 WORD PTR [ecx+686], ax

; 14463: 				lpObj->m_IfState.type   = 0;

  009e9	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009ec	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  009f2	80 e1 0f	 and	 cl, 15			; 0000000fH
  009f5	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009f8	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 14464: 				lpObj->m_IfState.use    = 0;

  009fe	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a01	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00a07	80 e1 fc	 and	 cl, 252			; 000000fcH
  00a0a	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a0d	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl
$LN40@PMoveProc:

; 14465: 			}
; 14466: 		}
; 14467: 
; 14468: 		if( gObjPositionCheck(lpObj) == FALSE ) 

  00a13	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a16	50		 push	 eax
  00a17	e8 00 00 00 00	 call	 ?gObjPositionCheck@@YAHPAVOBJECTSTRUCT@@@Z ; gObjPositionCheck
  00a1c	83 c4 04	 add	 esp, 4
  00a1f	85 c0		 test	 eax, eax
  00a21	75 60		 jne	 SHORT $LN42@PMoveProc

; 14469: 		{
; 14470: 			lpObj->PathCur  = 0; 

  00a23	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a26	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 14471: 			lpObj->PathCount= 0;

  00a30	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a33	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 14472: #ifdef MODIFY_MOVE_MAP_MOON_WALKING_BUGFIX_20090908
; 14473: 			//   gObjPositionCheck()  FALSE.
; 14474: 			//   Anti_HACK  .
; 14475: #else // MODIFY_MOVE_MAP_MOON_WALKING_BUGFIX_20090908
; 14476: #ifdef ADD_ANTI_HACK_01_20051027
; 14477: 			lpObj->m_Rest				= 1;
; 14478: 			lpObj->PathStartEnd			= 0;
; 14479: 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);									//    
; 14480: 			
; 14481: 			PMSG_ACTIONRESULT	pActionResult;
; 14482: 			PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof( pActionResult ));
; 14483: 
; 14484: 			pActionResult.NumberH		= HIBYTE(aIndex);
; 14485: 			pActionResult.NumberL		= LOBYTE(aIndex);
; 14486: 			pActionResult.ActionNumber	= AT_STAND1;
; 14487: 			pActionResult.Dir			= lpObj->Dir;
; 14488: #ifdef ADD_TRAP_OBJECT_EXTEND_20060731
; 14489: 			pActionResult.TargetNumberH = 0;
; 14490: 			pActionResult.TargetNumberL = 0;
; 14491: #endif
; 14492: 
; 14493: 			DataSend(lpObj->m_Index, (unsigned char*) &pActionResult, sizeof(PMSG_ACTIONRESULT));	//   .
; 14494: 
; 14495: 			LogAddTD("[Anti-HACK][PMoveProc][Check Position Error] :(%s)(%s) S(%d,%d) -> T(%d,%d)", 
; 14496: 				lpObj->AccountID, lpObj->Name,  lpObj->X, lpObj->Y, ax, ay);
; 14497: 			
; 14498: 			return;
; 14499: #endif
; 14500: #endif // MODIFY_MOVE_MAP_MOON_WALKING_BUGFIX_20090908
; 14501: 			
; 14502: 			ax				= lpObj->X;

  00a3d	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a40	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  00a47	66 89 4d e8	 mov	 WORD PTR _ax$[ebp], cx

; 14503: 			ay				= lpObj->Y;

  00a4b	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a4e	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00a55	66 89 4d e4	 mov	 WORD PTR _ay$[ebp], cx

; 14504: 			lpObj->TX		= (BYTE)ax;

  00a59	66 0f b6 45 e8	 movzx	 ax, BYTE PTR _ax$[ebp]
  00a5e	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a61	66 89 81 20 01
	00 00		 mov	 WORD PTR [ecx+288], ax

; 14505: 			lpObj->TY		= (BYTE)ay;			

  00a68	66 0f b6 45 e4	 movzx	 ax, BYTE PTR _ay$[ebp]
  00a6d	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a70	66 89 81 22 01
	00 00		 mov	 WORD PTR [ecx+290], ax

; 14506: 			pMove.X			= (BYTE)ax;

  00a77	8a 45 e8	 mov	 al, BYTE PTR _ax$[ebp]
  00a7a	88 45 f9	 mov	 BYTE PTR _pMove$[ebp+5], al

; 14507: 			pMove.Y	  		= (BYTE)ay;

  00a7d	8a 45 e4	 mov	 al, BYTE PTR _ay$[ebp]
  00a80	88 45 fa	 mov	 BYTE PTR _pMove$[ebp+6], al
$LN42@PMoveProc:

; 14508: 		}
; 14509: 		DataSend(aIndex, (LPBYTE)&pMove, pMove.h.size);

  00a83	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  00a87	50		 push	 eax
  00a88	8d 4d f4	 lea	 ecx, DWORD PTR _pMove$[ebp]
  00a8b	51		 push	 ecx
  00a8c	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00a8f	52		 push	 edx
  00a90	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00a95	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@PMoveProc:

; 14510: 	}
; 14511: 
; 14512: 	int MVL = MAXVIEWPORTOBJECT;

  00a98	c7 85 a4 fe ff
	ff 4b 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 14513: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  00aa2	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aa5	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00aa9	83 f9 02	 cmp	 ecx, 2
  00aac	75 0a		 jne	 SHORT $LN43@PMoveProc
  00aae	c7 85 a4 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN43@PMoveProc:

; 14514: 
; 14515: 	//       .
; 14516: 	for( n=0; n<MVL; n++ )

  00ab8	33 c0		 xor	 eax, eax
  00aba	66 89 45 f0	 mov	 WORD PTR _n$[ebp], ax
  00abe	eb 0c		 jmp	 SHORT $LN15@PMoveProc
$LN13@PMoveProc:
  00ac0	66 8b 45 f0	 mov	 ax, WORD PTR _n$[ebp]
  00ac4	66 83 c0 01	 add	 ax, 1
  00ac8	66 89 45 f0	 mov	 WORD PTR _n$[ebp], ax
$LN15@PMoveProc:
  00acc	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00ad0	3b 85 a4 fe ff
	ff		 cmp	 eax, DWORD PTR _MVL$[ebp]
  00ad6	0f 8d f1 00 00
	00		 jge	 $LN14@PMoveProc

; 14517: 	{
; 14518: 		if( lpObj->VpPlayer2[n].state == STVP_CREATE )

  00adc	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00ae0	6b c8 0c	 imul	 ecx, eax, 12
  00ae3	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ae6	0f be 84 0a e8
	06 00 00	 movsx	 eax, BYTE PTR [edx+ecx+1768]
  00aee	83 f8 01	 cmp	 eax, 1
  00af1	0f 85 d1 00 00
	00		 jne	 $LN44@PMoveProc

; 14519: 		{
; 14520: 			int number = lpObj->VpPlayer2[n].number;

  00af7	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00afb	6b c8 0c	 imul	 ecx, eax, 12
  00afe	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b01	0f bf 84 0a ea
	06 00 00	 movsx	 eax, WORD PTR [edx+ecx+1770]
  00b09	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _number$1[ebp], eax

; 14521: 			if( number >= 0 )

  00b0f	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR _number$1[ebp], 0
  00b16	0f 8c ac 00 00
	00		 jl	 $LN44@PMoveProc

; 14522: 			{
; 14523: 				if( (gObj[number].Connected > 1) && (gObj[number].Live) )	//   ..

  00b1c	69 85 a0 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$1[ebp], 7072
  00b26	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b2c	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  00b31	7e 59		 jle	 SHORT $LN46@PMoveProc
  00b33	69 85 a0 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$1[ebp], 7072
  00b3d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b43	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  00b48	85 d2		 test	 edx, edx
  00b4a	74 40		 je	 SHORT $LN46@PMoveProc

; 14524: 				{
; 14525: 					if( gObj[number].Type == OBJTYPE_CHARACTER)

  00b4c	69 85 a0 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _number$1[ebp], 7072
  00b56	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b5c	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00b61	83 fa 01	 cmp	 edx, 1
  00b64	75 24		 jne	 SHORT $LN48@PMoveProc

; 14526: 						DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pMove, pMove.h.size);

  00b66	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  00b6a	50		 push	 eax
  00b6b	8d 4d f4	 lea	 ecx, DWORD PTR _pMove$[ebp]
  00b6e	51		 push	 ecx
  00b6f	0f bf 55 f0	 movsx	 edx, WORD PTR _n$[ebp]
  00b73	6b c2 0c	 imul	 eax, edx, 12
  00b76	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b79	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  00b81	52		 push	 edx
  00b82	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00b87	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN48@PMoveProc:

; 14527: 				}

  00b8a	eb 3c		 jmp	 SHORT $LN44@PMoveProc
$LN46@PMoveProc:

; 14528: 				else 
; 14529: 				{
; 14530: 					lpObj->VpPlayer2[n].number = -1;

  00b8c	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00b90	6b c8 0c	 imul	 ecx, eax, 12
  00b93	83 ca ff	 or	 edx, -1
  00b96	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b99	66 89 94 08 ea
	06 00 00	 mov	 WORD PTR [eax+ecx+1770], dx

; 14531: 					lpObj->VpPlayer2[n].state  = STVP_NONE;

  00ba1	0f bf 45 f0	 movsx	 eax, WORD PTR _n$[ebp]
  00ba5	6b c8 0c	 imul	 ecx, eax, 12
  00ba8	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bab	c6 84 0a e8 06
	00 00 00	 mov	 BYTE PTR [edx+ecx+1768], 0

; 14532: 					lpObj->VPCount2--;

  00bb3	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bb6	8b 88 70 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2672]
  00bbc	83 e9 01	 sub	 ecx, 1
  00bbf	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bc2	89 8a 70 0a 00
	00		 mov	 DWORD PTR [edx+2672], ecx
$LN44@PMoveProc:

; 14533: 				}
; 14534: 			}
; 14535: 		}	
; 14536: 	}

  00bc8	e9 f3 fe ff ff	 jmp	 $LN13@PMoveProc
$LN14@PMoveProc:

; 14537: 	
; 14538: 	//---
; 14539: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  00bcd	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bd0	0f bf 88 1e 01
	00 00		 movsx	 ecx, WORD PTR [eax+286]
  00bd7	51		 push	 ecx
  00bd8	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bdb	0f bf 82 1c 01
	00 00		 movsx	 eax, WORD PTR [edx+284]
  00be2	50		 push	 eax
  00be3	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00be6	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00bed	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00bf3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00bf9	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 14540: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  00bfe	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c01	0f bf 88 22 01
	00 00		 movsx	 ecx, WORD PTR [eax+290]
  00c08	51		 push	 ecx
  00c09	8b 55 d8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c0c	0f bf 82 20 01
	00 00		 movsx	 eax, WORD PTR [edx+288]
  00c13	50		 push	 eax
  00c14	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c17	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00c1e	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00c24	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00c2a	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 14541: 	lpObj->m_OldX = lpObj->TX;

  00c2f	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c32	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c35	66 8b 91 20 01
	00 00		 mov	 dx, WORD PTR [ecx+288]
  00c3c	66 89 90 1c 01
	00 00		 mov	 WORD PTR [eax+284], dx

; 14542: 	lpObj->m_OldY = lpObj->TY;

  00c43	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c46	8b 4d d8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c49	66 8b 91 22 01
	00 00		 mov	 dx, WORD PTR [ecx+290]
  00c50	66 89 90 1e 01
	00 00		 mov	 WORD PTR [eax+286], dx

; 14543: 	lpObj->X  = sx;

  00c57	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c5a	66 8b 4d e0	 mov	 cx, WORD PTR _sx$[ebp]
  00c5e	66 89 88 04 01
	00 00		 mov	 WORD PTR [eax+260], cx

; 14544: 	lpObj->Y  = sy;

  00c65	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c68	66 8b 4d dc	 mov	 cx, WORD PTR _sy$[ebp]
  00c6c	66 89 88 06 01
	00 00		 mov	 WORD PTR [eax+262], cx

; 14545: 	lpObj->m_ViewState = 0;

  00c73	8b 45 d8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c76	c6 80 be 01 00
	00 00		 mov	 BYTE PTR [eax+446], 0
$LN1@PMoveProc:

; 14546: }

  00c7d	5f		 pop	 edi
  00c7e	5e		 pop	 esi
  00c7f	5b		 pop	 ebx
  00c80	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c83	33 cd		 xor	 ecx, ebp
  00c85	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c8a	8b e5		 mov	 esp, ebp
  00c8c	5d		 pop	 ebp
  00c8d	c3		 ret	 0
?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ENDP			; PMoveProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?ChatSend@@YAXPAVOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_pMsg$ = -76						; size = 65
_len$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
?ChatSend@@YAXPAVOBJECTSTRUCT@@PAD@Z PROC		; ChatSend, COMDAT

; 2210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2211 : 	int len = strlen(szChat);

  00016	8b 45 0c	 mov	 eax, DWORD PTR _szChat$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _strlen
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 2212 : 
; 2213 : 	if( len < 1 ) return;

  00025	83 7d f8 01	 cmp	 DWORD PTR _len$[ebp], 1
  00029	7d 02		 jge	 SHORT $LN2@ChatSend
  0002b	eb 61		 jmp	 SHORT $LN1@ChatSend
$LN2@ChatSend:

; 2214 : 	if( len > MAX_CHAT-1 ) return;

  0002d	83 7d f8 3b	 cmp	 DWORD PTR _len$[ebp], 59 ; 0000003bH
  00031	7e 02		 jle	 SHORT $LN3@ChatSend
  00033	eb 59		 jmp	 SHORT $LN1@ChatSend
$LN3@ChatSend:

; 2215 : 
; 2216 : 	PMSG_CHATDATA_NUMBER	pMsg;
; 2217 : 		
; 2218 : #ifdef UNICODE_MODE_20050718	//  
; 2219 : 	char szTempMsg[4096] = {0,};
; 2220 : 
; 2221 : 	MultiByteToWideChar(DEFAULT_CODEPAGE, 0, (char*)szChat, len, (WCHAR*)szTempMsg, sizeof(szTempMsg));
; 2222 : 	memcpy(pMsg.chatmsg, szTempMsg, sizeof(pMsg.chatmsg));
; 2223 : 	pMsg.chatmsg[MAX_CHAT-2] = 0;
; 2224 : 	pMsg.chatmsg[MAX_CHAT-1] = 0;
; 2225 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, (sizeof(pMsg)-MAX_CHAT)+wcslen((WCHAR*)pMsg.chatmsg)*2+2);
; 2226 : #else
; 2227 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, (sizeof(pMsg)-MAX_CHAT)+(len+1));

  00035	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00038	83 c0 06	 add	 eax, 6
  0003b	50		 push	 eax
  0003c	6a 01		 push	 1
  0003e	8d 4d b4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2228 : 	strcpy(pMsg.chatmsg, szChat);

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _szChat$[ebp]
  0004d	50		 push	 eax
  0004e	8d 4d b9	 lea	 ecx, DWORD PTR _pMsg$[ebp+5]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 _strcpy
  00057	83 c4 08	 add	 esp, 8

; 2229 : #endif
; 2230 : 
; 2231 : 	pMsg.NumberH	= HIBYTE(lpObj->m_Index);

  0005a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005f	c1 e9 08	 shr	 ecx, 8
  00062	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00068	88 4d b7	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 2232 : 	pMsg.NumberL	= LOBYTE(lpObj->m_Index);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00076	88 4d b8	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 2233 : 
; 2234 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00079	0f b6 45 b5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0007d	50		 push	 eax
  0007e	8d 4d b4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00081	51		 push	 ecx
  00082	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00085	52		 push	 edx
  00086	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ChatSend:

; 2235 : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?ChatSend@@YAXPAVOBJECTSTRUCT@@PAD@Z ENDP		; ChatSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?vChatSend@@YAXPAVOBJECTSTRUCT@@PADZZ
_TEXT	SEGMENT
_pMsg$ = -336						; size = 65
_len$ = -268						; size = 4
_pArguments$ = -264					; size = 4
_szBuffer$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
?vChatSend@@YAXPAVOBJECTSTRUCT@@PADZZ PROC		; vChatSend, COMDAT

; 2238 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2239 : 	char szBuffer[256]="";

  00016	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0001b	88 85 fc fe ff
	ff		 mov	 BYTE PTR _szBuffer$[ebp], al
  00021	68 ff 00 00 00	 push	 255			; 000000ffH
  00026	6a 00		 push	 0
  00028	8d 85 fd fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp+1]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2240 : 	va_list		pArguments;
; 2241 : 
; 2242 : 	va_start(pArguments, szChat);

  00037	8d 45 10	 lea	 eax, DWORD PTR _szChat$[ebp+4]
  0003a	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _pArguments$[ebp], eax

; 2243 :     vsprintf(szBuffer, szChat, pArguments);

  00040	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _pArguments$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _szChat$[ebp]
  0004a	51		 push	 ecx
  0004b	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 _vsprintf
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2244 :     va_end(pArguments);

  0005a	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pArguments$[ebp], 0

; 2245 : 	
; 2246 : 	int len = strlen(szBuffer);

  00064	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 _strlen
  00070	83 c4 04	 add	 esp, 4
  00073	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _len$[ebp], eax

; 2247 : 
; 2248 : 	if( len < 1 ) return;

  00079	83 bd f4 fe ff
	ff 01		 cmp	 DWORD PTR _len$[ebp], 1
  00080	7d 02		 jge	 SHORT $LN2@vChatSend
  00082	eb 7c		 jmp	 SHORT $LN1@vChatSend
$LN2@vChatSend:

; 2249 : 	if( len > MAX_CHAT-1 ) return;

  00084	83 bd f4 fe ff
	ff 3b		 cmp	 DWORD PTR _len$[ebp], 59 ; 0000003bH
  0008b	7e 02		 jle	 SHORT $LN3@vChatSend
  0008d	eb 71		 jmp	 SHORT $LN1@vChatSend
$LN3@vChatSend:

; 2250 : 
; 2251 : 	PMSG_CHATDATA_NUMBER	pMsg;
; 2252 : 
; 2253 : #ifdef UNICODE_MODE_20050718	//  
; 2254 : 	char szTempMsg[4096] = {0,};
; 2255 : 
; 2256 : 	MultiByteToWideChar(DEFAULT_CODEPAGE, 0, (char*)szChat, len, (WCHAR*)szTempMsg, sizeof(szTempMsg));
; 2257 : 	memcpy(pMsg.chatmsg, szTempMsg, sizeof(pMsg.chatmsg));
; 2258 : 	pMsg.chatmsg[MAX_CHAT-2] = 0;
; 2259 : 	pMsg.chatmsg[MAX_CHAT-1] = 0;
; 2260 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, (sizeof(pMsg)-MAX_CHAT)+wcslen((WCHAR*)pMsg.chatmsg)*2+2);
; 2261 : #else
; 2262 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, (sizeof(pMsg)-MAX_CHAT)+len+1);

  0008f	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _len$[ebp]
  00095	83 c0 06	 add	 eax, 6
  00098	50		 push	 eax
  00099	6a 01		 push	 1
  0009b	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2263 : 	strcpy(pMsg.chatmsg, szBuffer);

  000aa	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  000b0	50		 push	 eax
  000b1	8d 8d b5 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+5]
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 _strcpy
  000bd	83 c4 08	 add	 esp, 8

; 2264 : #endif
; 2265 : 
; 2266 : 	pMsg.NumberH	= HIBYTE(lpObj->m_Index);

  000c0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	c1 e9 08	 shr	 ecx, 8
  000c8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000ce	88 8d b3 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 2267 : 	pMsg.NumberL	= LOBYTE(lpObj->m_Index);

  000d4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000df	88 8d b4 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 2268 : 
; 2269 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  000e5	0f b6 85 b1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000ec	50		 push	 eax
  000ed	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000f3	51		 push	 ecx
  000f4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f7	52		 push	 edx
  000f8	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@vChatSend:

; 2270 : }

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
?vChatSend@@YAXPAVOBJECTSTRUCT@@PADZZ ENDP		; vChatSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopAnsClose@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?CGPShopAnsClose@@YAXHE@Z PROC				; CGPShopAnsClose, COMDAT

; 10090: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10091: 	LogAddTD("[PShop] [%s][%s] Close PShop",

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0001a	52		 push	 edx
  0001b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00028	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0002c	52		 push	 edx
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10092: 		gObj[aIndex].AccountID,
; 10093: 		gObj[aIndex].Name
; 10094: 		);
; 10095: 
; 10096: 	PMSG_ANS_PSHOP_CLOSE pMsg;
; 10097: 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x03, sizeof( pMsg ));

  0003b	6a 07		 push	 7
  0003d	6a 03		 push	 3
  0003f	6a 3f		 push	 63			; 0000003fH
  00041	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 10098: 	pMsg.btResult = btResult;

  0004d	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]
  00050	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 10099: 	pMsg.NumberH = HIBYTE(aIndex);

  00053	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00056	c1 e8 08	 shr	 eax, 8
  00059	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005e	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 10100: 	pMsg.NumberL = LOBYTE(aIndex);

  00061	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00064	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00069	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 10101: 	
; 10102: 	DataSend (aIndex, (LPBYTE) &pMsg, sizeof(PMSG_ANS_PSHOP_CLOSE));

  0006c	6a 07		 push	 7
  0006e	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00071	50		 push	 eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10103: 	
; 10104: 	if (btResult == 1)		//       .

  0007e	0f b6 45 0c	 movzx	 eax, BYTE PTR _btResult$[ebp]
  00082	83 f8 01	 cmp	 eax, 1
  00085	75 1f		 jne	 SHORT $LN1@CGPShopAns

; 10105: 		MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  00087	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0008b	50		 push	 eax
  0008c	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0008f	51		 push	 ecx
  00090	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00097	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGPShopAns:

; 10106: }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
?CGPShopAnsClose@@YAXHE@Z ENDP				; CGPShopAnsClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
_TEXT	SEGMENT
tv633 = -440						; size = 4
tv634 = -436						; size = 4
$T2 = -432						; size = 4
_btResult$3 = -361					; size = 1
_iPShopItemValue$4 = -360				; size = 4
_btNewItemPos$5 = -353					; size = 1
_dwCost$6 = -352					; size = 4
_CashLog$7 = -348					; size = 255
_precio$8 = -92						; size = 4
_btNewItemPos$9 = -85					; size = 1
_pide$10 = -84						; size = 4
_Golds$11 = -80						; size = 4
_iITEM_LOG_SERIAL$ = -76				; size = 4
_iITEM_LOG_DUR$ = -72					; size = 4
_iITEM_LOG_LEVEL$ = -68					; size = 4
_iITEM_LOG_TYPE$ = -64					; size = 4
_szName$ = -60						; size = 11
_btNewItemPos$12 = -45					; size = 1
_NCPSHOP$ = -44						; size = 4
_pide$ = -40						; size = 4
_Golds$ = -36						; size = 4
_lpObj$ = -32						; size = 4
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_lpMsg$ = 8						; size = 4
_aSourceIndex$ = 12					; size = 4
?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z PROC ; CGPShopReqBuyItem, COMDAT

; 10337: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 c4 58 fe ff
	ff		 add	 esp, -424		; fffffe58H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 10338: 	LPOBJECTSTRUCT lpObj = &gObj[MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)];

  00036	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00039	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0003d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00043	0f b6 d1	 movzx	 edx, cl
  00046	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00049	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0004d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00053	0f b6 c1	 movzx	 eax, cl
  00056	c1 e0 08	 shl	 eax, 8
  00059	0b d0		 or	 edx, eax
  0005b	0f b7 ca	 movzx	 ecx, dx
  0005e	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00064	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006a	89 55 e0	 mov	 DWORD PTR _lpObj$[ebp], edx

; 10339: 	// !!> .    .
; 10340: 
; 10341: 	//LPOBJECTSTRUCT lpObj = &gObj[MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)];
; 10342: 	int Golds = Manager.KCredits(gObj[aSourceIndex].AccountID);

  0006d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007a	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0007e	52		 push	 edx
  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ?Manager@@3VCManager@@A ; Manager
  00084	e8 00 00 00 00	 call	 ?KCredits@CManager@@QAEHPAD@Z ; CManager::KCredits
  00089	89 45 dc	 mov	 DWORD PTR _Golds$[ebp], eax

; 10343: 	int pide = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008f	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00093	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00099	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009c	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  000a2	8b 54 11 68	 mov	 edx, DWORD PTR [ecx+edx+104]
  000a6	89 55 d8	 mov	 DWORD PTR _pide$[ebp], edx

; 10344: 	int NCPSHOP = Manager.Pshopnpc(lpObj->AccountID);

  000a9	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ac	83 c0 68	 add	 eax, 104		; 00000068H
  000af	50		 push	 eax
  000b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?Manager@@3VCManager@@A ; Manager
  000b5	e8 00 00 00 00	 call	 ?Pshopnpc@CManager@@QAEHPAD@Z ; CManager::Pshopnpc
  000ba	89 45 d4	 mov	 DWORD PTR _NCPSHOP$[ebp], eax

; 10345: 	GetPrivateProfileString("UPDATE OFFTRADE", "OFFTRADERESTA", "UPDATE MuOnline.dbo.MEMB_INFO SET Cash = Cash - %d WHERE memb___id = '%s'", g_GlobalConfig.OFFTRADERESTA, 200, CFG_QUERYSHOP);//SACA GOLDS

  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GGOILNKD@?4?4?2data?2QueryShop?4ini@
  000c2	68 c8 00 00 00	 push	 200			; 000000c8H
  000c7	68 d8 04 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+1240
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@BHAABMKG@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HGOOMGKG@OFFTRADERESTA@
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FBHJCJB@UPDATE?5OFFTRADE@
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 10346: 	GetPrivateProfileString("UPDATE OFFTRADE", "OFFTRADESUMA", "UPDATE MuOnline.dbo.MEMB_INFO SET Cash = Cash + %d WHERE memb___id = '%s'", g_GlobalConfig.OFFTRADESUMA, 200, CFG_QUERYSHOP);//SACA GOLDS

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GGOILNKD@?4?4?2data?2QueryShop?4ini@
  000e6	68 c8 00 00 00	 push	 200			; 000000c8H
  000eb	68 10 04 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+1040
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@BCLMBCOI@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HPCIFBAH@OFFTRADESUMA@
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FBHJCJB@UPDATE?5OFFTRADE@
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 10347: 	
; 10348: 	if (NCPSHOP == 1)//parametro del comando offtrade

  00105	83 7d d4 01	 cmp	 DWORD PTR _NCPSHOP$[ebp], 1
  00109	0f 85 4a 01 00
	00		 jne	 $LN2@CGPShopReq

; 10349: 	{
; 10350: 		if (Golds < pide)

  0010f	8b 45 dc	 mov	 eax, DWORD PTR _Golds$[ebp]
  00112	3b 45 d8	 cmp	 eax, DWORD PTR _pide$[ebp]
  00115	7d 54		 jge	 SHORT $LN3@CGPShopReq

; 10351: 		{
; 10352: 			MsgOutput(aSourceIndex,"[BOT STORE] Necesitas %d Cash", lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue);

  00117	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0011a	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0011e	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00124	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00127	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  0012d	8b 54 11 68	 mov	 edx, DWORD PTR [ecx+edx+104]
  00131	52		 push	 edx
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BEPKGPIF@?$FLBOT?5STORE?$FN?5Necesitas?5?$CFd?5Cash@
  00137	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10353: 			MsgOutput(aSourceIndex,"[BOT STORE] Actualmente tienes  %d Cash", Golds);

  00143	8b 45 dc	 mov	 eax, DWORD PTR _Golds$[ebp]
  00146	50		 push	 eax
  00147	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@DPKGHCGP@?$FLBOT?5STORE?$FN?5Actualmente?5tienes?5@
  0014c	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  0014f	51		 push	 ecx
  00150	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10354: 			CGPShopAnsOpen(aSourceIndex, 0);

  00158	6a 00		 push	 0
  0015a	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  00163	83 c4 08	 add	 esp, 8

; 10355: 			return;

  00166	e9 2c 17 00 00	 jmp	 $LN1@CGPShopReq
$LN3@CGPShopReq:

; 10356: 		}
; 10357: 
; 10358: 		BYTE btNewItemPos = 0;

  0016b	c6 45 d3 00	 mov	 BYTE PTR _btNewItemPos$12[ebp], 0

; 10359: 	    btNewItemPos = gObjOnlyInventoryInsertItem(aSourceIndex, lpObj->Inventory1[lpMsg->btItemPos]);//inventario lleno o no

  0016f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00172	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00176	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0017c	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017f	8b b0 6c 0c 00
	00		 mov	 esi, DWORD PTR [eax+3180]
  00185	03 f2		 add	 esi, edx
  00187	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0018d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00192	8b fc		 mov	 edi, esp
  00194	f3 a5		 rep movsd
  00196	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  00199	51		 push	 ecx
  0019a	e8 00 00 00 00	 call	 ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjOnlyInventoryInsertItem
  0019f	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  001a5	88 45 d3	 mov	 BYTE PTR _btNewItemPos$12[ebp], al

; 10360: 
; 10361: 		if (btNewItemPos == 0xFF)

  001a8	0f b6 45 d3	 movzx	 eax, BYTE PTR _btNewItemPos$12[ebp]
  001ac	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001b1	75 1b		 jne	 SHORT $LN4@CGPShopReq

; 10362: 	    {
; 10363: 		//Log.Inform("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Buy Item", gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, lpObj->AccountID, lpObj->Name);
; 10364: 		CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  001b3	6a 08		 push	 8
  001b5	6a 00		 push	 0
  001b7	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  001bc	51		 push	 ecx
  001bd	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  001c0	52		 push	 edx
  001c1	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  001c6	83 c4 10	 add	 esp, 16			; 00000010H

; 10365: 
; 10366: 		return;

  001c9	e9 c9 16 00 00	 jmp	 $LN1@CGPShopReq
$LN4@CGPShopReq:

; 10367: 	    }
; 10368: 
; 10369: 		Manager.ExecFormat(g_GlobalConfig.OFFTRADERESTA, pide, gObj[aSourceIndex].AccountID); // gObj lpObj

  001ce	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  001d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001db	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001df	52		 push	 edx
  001e0	8b 45 d8	 mov	 eax, DWORD PTR _pide$[ebp]
  001e3	50		 push	 eax
  001e4	68 d8 04 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+1240
  001e9	68 00 00 00 00	 push	 OFFSET ?Manager@@3VCManager@@A ; Manager
  001ee	e8 00 00 00 00	 call	 ?ExecFormat@CDataBase@@QAA_NPBDZZ ; CDataBase::ExecFormat
  001f3	83 c4 10	 add	 esp, 16			; 00000010H

; 10370: 		Manager.ExecFormat(g_GlobalConfig.OFFTRADESUMA, pide, lpObj->AccountID);

  001f6	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f9	83 c0 68	 add	 eax, 104		; 00000068H
  001fc	50		 push	 eax
  001fd	8b 4d d8	 mov	 ecx, DWORD PTR _pide$[ebp]
  00200	51		 push	 ecx
  00201	68 10 04 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+1040
  00206	68 00 00 00 00	 push	 OFFSET ?Manager@@3VCManager@@A ; Manager
  0020b	e8 00 00 00 00	 call	 ?ExecFormat@CDataBase@@QAA_NPBDZZ ; CDataBase::ExecFormat
  00210	83 c4 10	 add	 esp, 16			; 00000010H

; 10371: 		MsgOutput(aSourceIndex,"[BOT STORE] Te quedan %d Cash", Golds - pide);

  00213	8b 45 dc	 mov	 eax, DWORD PTR _Golds$[ebp]
  00216	2b 45 d8	 sub	 eax, DWORD PTR _pide$[ebp]
  00219	50		 push	 eax
  0021a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FNEEFLNP@?$FLBOT?5STORE?$FN?5Te?5quedan?5?$CFd?5Cash@
  0021f	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  00222	51		 push	 ecx
  00223	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10372: 		CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, btNewItemPos, 1);

  0022b	6a 01		 push	 1
  0022d	0f b6 45 d3	 movzx	 eax, BYTE PTR _btNewItemPos$12[ebp]
  00231	50		 push	 eax
  00232	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00235	8b 11		 mov	 edx, DWORD PTR [ecx]
  00237	52		 push	 edx
  00238	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00241	83 c4 10	 add	 esp, 16			; 00000010H

; 10373: 		PShop.CGPShopReqBuyItemTest(lpMsg, aSourceIndex);

  00244	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00247	50		 push	 eax
  00248	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0024b	51		 push	 ecx
  0024c	e8 00 00 00 00	 call	 ?CGPShopReqBuyItemTest@CPShop@@SAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CPShop::CGPShopReqBuyItemTest
  00251	83 c4 08	 add	 esp, 8

; 10374: 
; 10375: 		return;

  00254	e9 3e 16 00 00	 jmp	 $LN1@CGPShopReq
$LN2@CGPShopReq:

; 10376: 	}
; 10377: 
; 10378: 	if (gDoPShopOpen == 0) 

  00259	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  00260	75 05		 jne	 SHORT $LN5@CGPShopReq

; 10379: 	{
; 10380: 		return;

  00262	e9 30 16 00 00	 jmp	 $LN1@CGPShopReq
$LN5@CGPShopReq:

; 10381: 	}
; 10382: 	
; 10383: 
; 10384: 	if (!gObjIsConnected(MAKEWORD(lpMsg->NumberL, lpMsg->NumberH))) {

  00267	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0026a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0026e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00274	0f b6 d1	 movzx	 edx, cl
  00277	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0027a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0027e	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00284	0f b6 c1	 movzx	 eax, cl
  00287	c1 e0 08	 shl	 eax, 8
  0028a	0b d0		 or	 edx, eax
  0028c	0f b7 ca	 movzx	 ecx, dx
  0028f	51		 push	 ecx
  00290	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00295	83 c4 04	 add	 esp, 4
  00298	85 c0		 test	 eax, eax
  0029a	75 70		 jne	 SHORT $LN6@CGPShopReq

; 10385: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller did Not CONNECTED (%d)",

  0029c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0029f	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  002a3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002a9	0f b6 d1	 movzx	 edx, cl
  002ac	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002af	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  002b3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002b9	0f b6 c1	 movzx	 eax, cl
  002bc	c1 e0 08	 shl	 eax, 8
  002bf	0b d0		 or	 edx, eax
  002c1	0f b7 ca	 movzx	 ecx, dx
  002c4	51		 push	 ecx
  002c5	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  002cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d1	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  002d5	51		 push	 ecx
  002d6	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  002dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e2	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  002e6	51		 push	 ecx
  002e7	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  002ec	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002f2	83 c4 10	 add	 esp, 16			; 00000010H

; 10386: 			gObj[aSourceIndex].AccountID,
; 10387: 			gObj[aSourceIndex].Name,
; 10388: 			MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)
; 10389: 			);
; 10390: 		CGPShopAnsBuyItem (aSourceIndex, -1, 0, 2);			//  2 :  

  002f5	6a 02		 push	 2
  002f7	6a 00		 push	 0
  002f9	6a ff		 push	 -1
  002fb	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  002fe	50		 push	 eax
  002ff	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00304	83 c4 10	 add	 esp, 16			; 00000010H

; 10391: 		return;

  00307	e9 8b 15 00 00	 jmp	 $LN1@CGPShopReq
$LN6@CGPShopReq:

; 10392: 	}
; 10393: 	
; 10394: 	if (lpObj->Type != OBJTYPE_CHARACTER) {

  0030c	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030f	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00313	83 f9 01	 cmp	 ecx, 1
  00316	74 70		 je	 SHORT $LN7@CGPShopReq

; 10395: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not CHARACTER (%d)",

  00318	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0031b	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0031f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00325	0f b6 d1	 movzx	 edx, cl
  00328	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0032b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0032f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00335	0f b6 c1	 movzx	 eax, cl
  00338	c1 e0 08	 shl	 eax, 8
  0033b	0b d0		 or	 edx, eax
  0033d	0f b7 ca	 movzx	 ecx, dx
  00340	51		 push	 ecx
  00341	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00348	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0034d	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00351	51		 push	 ecx
  00352	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00359	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0035e	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00362	51		 push	 ecx
  00363	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00368	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0036e	83 c4 10	 add	 esp, 16			; 00000010H

; 10396: 			gObj[aSourceIndex].AccountID,
; 10397: 			gObj[aSourceIndex].Name,
; 10398: 			MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)
; 10399: 			);
; 10400: 		CGPShopAnsBuyItem (aSourceIndex, -1, 0, 2);			//  2 :  

  00371	6a 02		 push	 2
  00373	6a 00		 push	 0
  00375	6a ff		 push	 -1
  00377	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  0037a	50		 push	 eax
  0037b	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00380	83 c4 10	 add	 esp, 16			; 00000010H

; 10401: 		return;	

  00383	e9 0f 15 00 00	 jmp	 $LN1@CGPShopReq
$LN7@CGPShopReq:

; 10402: 	}
; 10403: 
; 10404: #ifdef BUGFIX_PERSONALSHOP_ZENCOPY_20050426
; 10405: 	if (lpObj->CloseCount >= 0) {

  00388	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0038b	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  0038f	85 c9		 test	 ecx, ecx
  00391	7c 70		 jl	 SHORT $LN8@CGPShopReq

; 10406: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Closing (%d)",

  00393	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00396	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0039a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003a0	0f b6 d1	 movzx	 edx, cl
  003a3	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  003a6	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  003aa	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003b0	0f b6 c1	 movzx	 eax, cl
  003b3	c1 e0 08	 shl	 eax, 8
  003b6	0b d0		 or	 edx, eax
  003b8	0f b7 ca	 movzx	 ecx, dx
  003bb	51		 push	 ecx
  003bc	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  003c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003c8	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  003cc	51		 push	 ecx
  003cd	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  003d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d9	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  003dd	51		 push	 ecx
  003de	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  003e3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003e9	83 c4 10	 add	 esp, 16			; 00000010H

; 10407: 			gObj[aSourceIndex].AccountID,
; 10408: 			gObj[aSourceIndex].Name,
; 10409: 			MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)
; 10410: 			);
; 10411: 		CGPShopAnsBuyItem (aSourceIndex, -1, 0, 2);			//  2 :  

  003ec	6a 02		 push	 2
  003ee	6a 00		 push	 0
  003f0	6a ff		 push	 -1
  003f2	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  003f5	50		 push	 eax
  003f6	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  003fb	83 c4 10	 add	 esp, 16			; 00000010H

; 10412: 		return;

  003fe	e9 94 14 00 00	 jmp	 $LN1@CGPShopReq
$LN8@CGPShopReq:

; 10413: 	}
; 10414: 	
; 10415: 	if (gObj[aSourceIndex].CloseCount >= 0) {

  00403	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  0040a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00410	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  00415	85 d2		 test	 edx, edx
  00417	7c 70		 jl	 SHORT $LN9@CGPShopReq

; 10416: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Closing (%d)",

  00419	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0041c	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00420	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00426	0f b6 d1	 movzx	 edx, cl
  00429	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0042c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00430	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00436	0f b6 c1	 movzx	 eax, cl
  00439	c1 e0 08	 shl	 eax, 8
  0043c	0b d0		 or	 edx, eax
  0043e	0f b7 ca	 movzx	 ecx, dx
  00441	51		 push	 ecx
  00442	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00449	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0044e	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00452	51		 push	 ecx
  00453	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  0045a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0045f	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00463	51		 push	 ecx
  00464	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00469	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0046f	83 c4 10	 add	 esp, 16			; 00000010H

; 10417: 			gObj[aSourceIndex].AccountID,
; 10418: 			gObj[aSourceIndex].Name,
; 10419: 			MAKEWORD(lpMsg->NumberL, lpMsg->NumberH)
; 10420: 			);
; 10421: 		CGPShopAnsBuyItem (aSourceIndex, -1, 0, 2);			//  2 :  

  00472	6a 02		 push	 2
  00474	6a 00		 push	 0
  00476	6a ff		 push	 -1
  00478	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  0047b	50		 push	 eax
  0047c	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00481	83 c4 10	 add	 esp, 16			; 00000010H

; 10422: 		return;

  00484	e9 0e 14 00 00	 jmp	 $LN1@CGPShopReq
$LN9@CGPShopReq:

; 10423: 	}
; 10424: #endif
; 10425: 
; 10426: #ifdef ADD_NEWPVP_PKFIELD
; 10427: 	if ( g_NewPVP.IsDuel(gObj[aSourceIndex]) )
; 10428: 	{
; 10429: 		// "    ."
; 10430: 		GCServerMsgStringSend(lMsg.Get(3429), aSourceIndex, 1);
; 10431: 		return;
; 10432: 	}
; 10433: 
; 10434: 	if (g_NewPVP.IsObserver(gObj[aSourceIndex]))
; 10435: 	{
; 10436: 		// "    ."
; 10437: 		GCServerMsgStringSend(lMsg.Get(3430), aSourceIndex, 1);
; 10438: 		return;
; 10439: 	}
; 10440: #endif  // ADD_NEWPVP_PKFIELD
; 10441: 
; 10442: 	//   
; 10443: 	if (lpObj->m_bPShopOpen == false) {

  00489	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0048c	0f b6 88 f8 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3320]
  00493	85 c9		 test	 ecx, ecx
  00495	75 59		 jne	 SHORT $LN10@CGPShopReq

; 10444: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did not Open PShop",

  00497	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0049a	83 c0 73	 add	 eax, 115		; 00000073H
  0049d	50		 push	 eax
  0049e	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004a1	83 c1 68	 add	 ecx, 104		; 00000068H
  004a4	51		 push	 ecx
  004a5	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  004ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004b1	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  004b5	51		 push	 ecx
  004b6	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  004bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004c2	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  004c6	51		 push	 ecx
  004c7	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  004cc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004d2	83 c4 14	 add	 esp, 20			; 00000014H

; 10445: 			gObj[aSourceIndex].AccountID,
; 10446: 			gObj[aSourceIndex].Name,
; 10447: 			lpObj->AccountID,
; 10448: 			lpObj->Name
; 10449: 			);
; 10450: 
; 10451: 		CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 3);		//  3 :   

  004d5	6a 03		 push	 3
  004d7	6a 00		 push	 0
  004d9	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  004de	51		 push	 ecx
  004df	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  004e2	52		 push	 edx
  004e3	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  004e8	83 c4 10	 add	 esp, 16			; 00000010H

; 10452: 		return;

  004eb	e9 a7 13 00 00	 jmp	 $LN1@CGPShopReq
$LN10@CGPShopReq:

; 10453: 	}
; 10454: 
; 10455: 	//      
; 10456: 	CHAR szName[MAX_IDSTRING + 1] = {0,};

  004f0	33 c0		 xor	 eax, eax
  004f2	89 45 c4	 mov	 DWORD PTR _szName$[ebp], eax
  004f5	89 45 c8	 mov	 DWORD PTR _szName$[ebp+4], eax
  004f8	66 89 45 cc	 mov	 WORD PTR _szName$[ebp+8], ax
  004fc	88 45 ce	 mov	 BYTE PTR _szName$[ebp+10], al

; 10457: 	memcpy (szName, lpMsg->btName, sizeof(lpMsg->btName));

  004ff	6a 0a		 push	 10			; 0000000aH
  00501	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00504	83 c0 06	 add	 eax, 6
  00507	50		 push	 eax
  00508	8d 4d c4	 lea	 ecx, DWORD PTR _szName$[ebp]
  0050b	51		 push	 ecx
  0050c	e8 00 00 00 00	 call	 _memcpy
  00511	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10458: 	szName[MAX_IDSTRING] = 0;

  00514	b8 01 00 00 00	 mov	 eax, 1
  00519	6b c8 0a	 imul	 ecx, eax, 10
  0051c	89 8d 50 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00522	83 bd 50 fe ff
	ff 0b		 cmp	 DWORD PTR $T2[ebp], 11	; 0000000bH
  00529	73 02		 jae	 SHORT $LN43@CGPShopReq
  0052b	eb 05		 jmp	 SHORT $LN44@CGPShopReq
$LN43@CGPShopReq:
  0052d	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN44@CGPShopReq:
  00532	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  00538	c6 44 15 c4 00	 mov	 BYTE PTR _szName$[ebp+edx], 0

; 10459: 	if (strcmp(szName, lpObj->Name)) {

  0053d	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00540	83 c0 73	 add	 eax, 115		; 00000073H
  00543	50		 push	 eax
  00544	8d 4d c4	 lea	 ecx, DWORD PTR _szName$[ebp]
  00547	51		 push	 ecx
  00548	e8 00 00 00 00	 call	 _strcmp
  0054d	83 c4 08	 add	 esp, 8
  00550	85 c0		 test	 eax, eax
  00552	74 56		 je	 SHORT $LN11@CGPShopReq

; 10460: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch [%s] - [%s]",

  00554	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00557	83 c0 73	 add	 eax, 115		; 00000073H
  0055a	50		 push	 eax
  0055b	8d 4d c4	 lea	 ecx, DWORD PTR _szName$[ebp]
  0055e	51		 push	 ecx
  0055f	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00566	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0056b	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0056f	51		 push	 ecx
  00570	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00577	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0057c	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00580	51		 push	 ecx
  00581	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00586	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0058c	83 c4 14	 add	 esp, 20			; 00000014H

; 10461: 			gObj[aSourceIndex].AccountID,
; 10462: 			gObj[aSourceIndex].Name,
; 10463: 			szName,
; 10464: 			lpObj->Name
; 10465: 			);
; 10466: 
; 10467: 		CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 6);		//  6 :   

  0058f	6a 06		 push	 6
  00591	6a 00		 push	 0
  00593	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00596	8b 08		 mov	 ecx, DWORD PTR [eax]
  00598	51		 push	 ecx
  00599	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  0059c	52		 push	 edx
  0059d	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  005a2	83 c4 10	 add	 esp, 16			; 00000010H

; 10468: 		return;

  005a5	e9 ed 12 00 00	 jmp	 $LN1@CGPShopReq
$LN11@CGPShopReq:

; 10469: 	}
; 10470: 
; 10471: 	//      .
; 10472: 	if( lpObj->CloseType != -1 )

  005aa	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ad	0f be 48 0b	 movsx	 ecx, BYTE PTR [eax+11]
  005b1	83 f9 ff	 cmp	 ecx, -1
  005b4	74 59		 je	 SHORT $LN12@CGPShopReq

; 10473: 	{
; 10474: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is Closing Connection",

  005b6	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b9	83 c0 73	 add	 eax, 115		; 00000073H
  005bc	50		 push	 eax
  005bd	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005c0	83 c1 68	 add	 ecx, 104		; 00000068H
  005c3	51		 push	 ecx
  005c4	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  005cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005d0	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  005d4	51		 push	 ecx
  005d5	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  005dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005e1	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  005e5	51		 push	 ecx
  005e6	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  005eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005f1	83 c4 14	 add	 esp, 20			; 00000014H

; 10475: 			gObj[aSourceIndex].AccountID,
; 10476: 			gObj[aSourceIndex].Name,
; 10477: 			lpObj->AccountID,
; 10478: 			lpObj->Name
; 10479: 			);
; 10480: 
; 10481: 		CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 2);		//  2 :  

  005f4	6a 02		 push	 2
  005f6	6a 00		 push	 0
  005f8	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  005fd	51		 push	 ecx
  005fe	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00601	52		 push	 edx
  00602	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00607	83 c4 10	 add	 esp, 16			; 00000010H

; 10482: 		return;

  0060a	e9 88 12 00 00	 jmp	 $LN1@CGPShopReq
$LN12@CGPShopReq:

; 10483: 	}
; 10484: 
; 10485: 
; 10486: 	//        .
; 10487: 	if( ((lpObj->Penalty&CTLCODE_ITEMDONTTOUCH) == CTLCODE_ITEMDONTTOUCH) ||

  0060f	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00612	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  00618	83 e1 04	 and	 ecx, 4
  0061b	75 0e		 jne	 SHORT $LN14@CGPShopReq
  0061d	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00620	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  00626	83 e1 08	 and	 ecx, 8
  00629	74 59		 je	 SHORT $LN13@CGPShopReq
$LN14@CGPShopReq:

; 10488: 		((lpObj->Penalty&CTLCODE_ACCOUNTITEMBLOCK) == CTLCODE_ACCOUNTITEMBLOCK)
; 10489: 		)
; 10490: 	{
; 10491: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",

  0062b	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0062e	83 c0 73	 add	 eax, 115		; 00000073H
  00631	50		 push	 eax
  00632	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00635	83 c1 68	 add	 ecx, 104		; 00000068H
  00638	51		 push	 ecx
  00639	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00640	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00645	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00649	51		 push	 ecx
  0064a	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00651	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00656	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  0065a	51		 push	 ecx
  0065b	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00660	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00666	83 c4 14	 add	 esp, 20			; 00000014H

; 10492: 			gObj[aSourceIndex].AccountID,
; 10493: 			gObj[aSourceIndex].Name,
; 10494: 			lpObj->AccountID,
; 10495: 			lpObj->Name
; 10496: 			);
; 10497: 
; 10498: 		CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 9);		//  2 :     

  00669	6a 09		 push	 9
  0066b	6a 00		 push	 0
  0066d	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00670	8b 08		 mov	 ecx, DWORD PTR [eax]
  00672	51		 push	 ecx
  00673	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00676	52		 push	 edx
  00677	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  0067c	83 c4 10	 add	 esp, 16			; 00000010H

; 10499: 		return;

  0067f	e9 13 12 00 00	 jmp	 $LN1@CGPShopReq
$LN13@CGPShopReq:

; 10500: 	}
; 10501: 
; 10502: 
; 10503: 	//        .
; 10504: 	if( ((gObj[aSourceIndex].Penalty&CTLCODE_ITEMDONTTOUCH) == CTLCODE_ITEMDONTTOUCH) ||

  00684	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  0068b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00691	8b 94 01 a8 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+424]
  00698	83 e2 04	 and	 edx, 4
  0069b	75 19		 jne	 SHORT $LN16@CGPShopReq
  0069d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  006a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006aa	8b 94 01 a8 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+424]
  006b1	83 e2 08	 and	 edx, 8
  006b4	74 59		 je	 SHORT $LN15@CGPShopReq
$LN16@CGPShopReq:

; 10505: 		((gObj[aSourceIndex].Penalty&CTLCODE_ACCOUNTITEMBLOCK) == CTLCODE_ACCOUNTITEMBLOCK)
; 10506: 		)
; 10507: 	{
; 10508: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",

  006b6	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b9	83 c0 73	 add	 eax, 115		; 00000073H
  006bc	50		 push	 eax
  006bd	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006c0	83 c1 68	 add	 ecx, 104		; 00000068H
  006c3	51		 push	 ecx
  006c4	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  006cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006d0	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  006d4	51		 push	 ecx
  006d5	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  006dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006e1	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  006e5	51		 push	 ecx
  006e6	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  006eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006f1	83 c4 14	 add	 esp, 20			; 00000014H

; 10509: 			gObj[aSourceIndex].AccountID,
; 10510: 			gObj[aSourceIndex].Name,
; 10511: 			lpObj->AccountID,
; 10512: 			lpObj->Name
; 10513: 			);
; 10514: 
; 10515: 		CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 9);		//  2 :     

  006f4	6a 09		 push	 9
  006f6	6a 00		 push	 0
  006f8	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  006fd	51		 push	 ecx
  006fe	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00701	52		 push	 edx
  00702	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00707	83 c4 10	 add	 esp, 16			; 00000010H

; 10516: 		return;

  0070a	e9 88 11 00 00	 jmp	 $LN1@CGPShopReq
$LN15@CGPShopReq:

; 10517: 	}
; 10518: 
; 10519: 
; 10520: 	//    .
; 10521: 	EnterCriticalSection(&lpObj->m_critPShopTrade);

  0070f	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00712	05 34 0d 00 00	 add	 eax, 3380		; 00000d34H
  00717	50		 push	 eax
  00718	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 10522: 	if (lpObj->m_bPShopTransaction == true) {

  0071e	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00721	0f b6 88 f9 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3321]
  00728	83 f9 01	 cmp	 ecx, 1
  0072b	75 6a		 jne	 SHORT $LN17@CGPShopReq

; 10523: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Already Trade With Other",

  0072d	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00730	83 c0 73	 add	 eax, 115		; 00000073H
  00733	50		 push	 eax
  00734	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00737	83 c1 68	 add	 ecx, 104		; 00000068H
  0073a	51		 push	 ecx
  0073b	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00742	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00747	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0074b	51		 push	 ecx
  0074c	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00753	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00758	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  0075c	51		 push	 ecx
  0075d	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00762	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00768	83 c4 14	 add	 esp, 20			; 00000014H

; 10524: 			gObj[aSourceIndex].AccountID,
; 10525: 			gObj[aSourceIndex].Name,
; 10526: 			lpObj->AccountID,
; 10527: 			lpObj->Name
; 10528: 			);
; 10529: 		
; 10530: 		CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 4);		//  4 :   

  0076b	6a 04		 push	 4
  0076d	6a 00		 push	 0
  0076f	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00772	8b 08		 mov	 ecx, DWORD PTR [eax]
  00774	51		 push	 ecx
  00775	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00778	52		 push	 edx
  00779	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  0077e	83 c4 10	 add	 esp, 16			; 00000010H

; 10531: 		LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00781	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00784	05 34 0d 00 00	 add	 eax, 3380		; 00000d34H
  00789	50		 push	 eax
  0078a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 10532: 		return;

  00790	e9 02 11 00 00	 jmp	 $LN1@CGPShopReq

; 10533: 	}

  00795	eb 0a		 jmp	 SHORT $LN18@CGPShopReq
$LN17@CGPShopReq:

; 10534: 	else lpObj->m_bPShopTransaction = true;

  00797	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0079a	c6 80 f9 0c 00
	00 01		 mov	 BYTE PTR [eax+3321], 1
$LN18@CGPShopReq:

; 10535: 	LeaveCriticalSection(&lpObj->m_critPShopTrade);

  007a1	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007a4	05 34 0d 00 00	 add	 eax, 3380		; 00000d34H
  007a9	50		 push	 eax
  007aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 10536: 
; 10537: #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202	
; 10538: 	if( gObjCheckSerial0ItemList(&lpObj->Inventory1[lpMsg->btItemPos]) )

  007b0	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  007b3	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  007b7	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  007bd	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007c0	03 90 6c 0c 00
	00		 add	 edx, DWORD PTR [eax+3180]
  007c6	52		 push	 edx
  007c7	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  007cc	83 c4 04	 add	 esp, 4
  007cf	85 c0		 test	 eax, eax
  007d1	0f 84 91 00 00
	00		 je	 $LN19@CGPShopReq

; 10539: 	{
; 10540: 		// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 10541: 		MsgOutput( lpObj->m_Index, lMsg.Get(3354) );			// "  .  ."

  007d7	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  007dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  007e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  007e7	50		 push	 eax
  007e8	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  007ed	51		 push	 ecx
  007ee	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  007f3	83 c4 08	 add	 esp, 8

; 10542: #ifdef ADD_SHIELD_POINT_01_20060403
; 10543: 		GCReFillSend(aSourceIndex, (WORD)gObj[aSourceIndex].Life, 0xFD, 1, (WORD)gObj[aSourceIndex].iShield);
; 10544: #else
; 10545: 		GCReFillSend(aSourceIndex, (WORD)gObj[aSourceIndex].Life, 0xFD, 1);

  007f6	6a 01		 push	 1
  007f8	68 fd 00 00 00	 push	 253			; 000000fdH
  007fd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00804	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0080a	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  00813	0f b7 c2	 movzx	 eax, dx
  00816	50		 push	 eax
  00817	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  0081a	51		 push	 ecx
  0081b	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00820	83 c4 10	 add	 esp, 16			; 00000010H

; 10546: #endif
; 10547: 		LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop Buy] (%s)(%s) Item(%s) Pos(%d)", 

  00823	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00826	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0082a	51		 push	 ecx
  0082b	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0082e	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00832	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00838	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0083b	03 8a 6c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3180]
  00841	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00846	50		 push	 eax
  00847	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0084a	83 c0 73	 add	 eax, 115		; 00000073H
  0084d	50		 push	 eax
  0084e	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00851	83 c1 68	 add	 ecx, 104		; 00000068H
  00854	51		 push	 ecx
  00855	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSh@
  0085a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00860	83 c4 14	 add	 esp, 20			; 00000014H

; 10548: 			lpObj->AccountID, lpObj->Name, lpObj->Inventory1[lpMsg->btItemPos].GetName(), lpMsg->btItemPos);
; 10549: 		return;

  00863	e9 2f 10 00 00	 jmp	 $LN1@CGPShopReq
$LN19@CGPShopReq:

; 10550: 	}
; 10551: #endif
; 10552: 
; 10553: 	// *> . /        .
; 10554: #ifdef PERSONAL_SHOP_CHECK_COPYITEM_200406016
; 10555: 	if( gObjInventorySearchSerialNumber(&gObj[aSourceIndex], lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  00868	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0086b	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0086f	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00875	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00878	03 8a 6c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3180]
  0087e	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00883	50		 push	 eax
  00884	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  0088b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00891	50		 push	 eax
  00892	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00897	83 c4 08	 add	 esp, 8
  0089a	85 c0		 test	 eax, eax
  0089c	75 74		 jne	 SHORT $LN20@CGPShopReq

; 10556: 	{
; 10557: #ifdef ADD_SHIELD_POINT_01_20060403
; 10558: 		GCReFillSend(aSourceIndex, (WORD)gObj[aSourceIndex].Life, 0xFD, 1, (WORD)gObj[aSourceIndex].iShield);
; 10559: #else
; 10560: 		GCReFillSend(aSourceIndex, (WORD)gObj[aSourceIndex].Life, 0xFD, 1);

  0089e	6a 01		 push	 1
  008a0	68 fd 00 00 00	 push	 253			; 000000fdH
  008a5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  008ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008b2	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  008bb	0f b7 c2	 movzx	 eax, dx
  008be	50		 push	 eax
  008bf	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  008c2	51		 push	 ecx
  008c3	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  008c8	83 c4 10	 add	 esp, 16			; 00000010H

; 10561: #endif
; 10562: 		LogAdd("error-L2 : CopyItem [%s][%s] return %s %d", gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, __FILE__, __LINE__);

  008cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z@4JA
  008d0	05 e1 00 00 00	 add	 eax, 225		; 000000e1H
  008d5	50		 push	 eax
  008d6	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  008db	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aSourceIndex$[ebp], 7072
  008e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008e8	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  008ec	50		 push	 eax
  008ed	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aSourceIndex$[ebp], 7072
  008f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008fa	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  008fe	50		 push	 eax
  008ff	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5re@
  00904	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0090a	83 c4 14	 add	 esp, 20			; 00000014H

; 10563: 		return;

  0090d	e9 85 0f 00 00	 jmp	 $LN1@CGPShopReq
$LN20@CGPShopReq:

; 10564: 	}
; 10565: 
; 10566: 	if( gObjInventorySearchSerialNumber(lpObj, lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  00912	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00915	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00919	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  0091f	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00922	03 8a 6c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3180]
  00928	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  0092d	50		 push	 eax
  0092e	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00931	50		 push	 eax
  00932	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00937	83 c4 08	 add	 esp, 8
  0093a	85 c0		 test	 eax, eax
  0093c	75 55		 jne	 SHORT $LN21@CGPShopReq

; 10567: 	{
; 10568: #ifdef ADD_SHIELD_POINT_01_20060403
; 10569: 		GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFD, 1, (WORD)lpObj->iShield);
; 10570: #else
; 10571: 		GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFD, 1);

  0093e	6a 01		 push	 1
  00940	68 fd 00 00 00	 push	 253			; 000000fdH
  00945	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00948	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  00950	0f b7 d1	 movzx	 edx, cx
  00953	52		 push	 edx
  00954	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00957	8b 08		 mov	 ecx, DWORD PTR [eax]
  00959	51		 push	 ecx
  0095a	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  0095f	83 c4 10	 add	 esp, 16			; 00000010H

; 10572: #endif
; 10573: 		LogAdd("error-L2 : CopyItem [%s][%s] return %s %d", lpObj->AccountID, lpObj->Name, __FILE__, __LINE__);

  00962	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z@4JA
  00967	05 ec 00 00 00	 add	 eax, 236		; 000000ecH
  0096c	50		 push	 eax
  0096d	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00972	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00975	83 c1 73	 add	 ecx, 115		; 00000073H
  00978	51		 push	 ecx
  00979	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0097c	83 c2 68	 add	 edx, 104		; 00000068H
  0097f	52		 push	 edx
  00980	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5re@
  00985	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0098b	83 c4 14	 add	 esp, 20			; 00000014H

; 10574: 		return;

  0098e	e9 04 0f 00 00	 jmp	 $LN1@CGPShopReq
$LN21@CGPShopReq:

; 10575: 	}
; 10576: #endif
; 10577: 
; 10578: 
; 10579: #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719			//    -      
; 10580: 	if (gObjFixInventoryPointer(aSourceIndex) == false) {

  00993	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00996	50		 push	 eax
  00997	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0099c	83 c4 04	 add	 esp, 4
  0099f	0f b6 c8	 movzx	 ecx, al
  009a2	85 c9		 test	 ecx, ecx
  009a4	75 1e		 jne	 SHORT $LN22@CGPShopReq

; 10581: 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  009a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z@4JA
  009ab	05 f4 00 00 00	 add	 eax, 244		; 000000f4H
  009b0	50		 push	 eax
  009b1	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MNNGLLFH@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  009b6	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  009bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  009c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@CGPShopReq:

; 10582: 	}
; 10583: #endif
; 10584: 
; 10585: #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//        . (   )
; 10586: 	if (gObj[aSourceIndex].pTransaction == 1) {

  009c4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  009cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009d1	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  009d9	83 fa 01	 cmp	 edx, 1
  009dc	75 55		 jne	 SHORT $LN23@CGPShopReq

; 10587: 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Requester Transaction == 1, IF_TYPE : %d",

  009de	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  009e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009eb	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  009f2	c0 ea 04	 shr	 dl, 4
  009f5	80 e2 0f	 and	 dl, 15			; 0000000fH
  009f8	0f b6 c2	 movzx	 eax, dl
  009fb	50		 push	 eax
  009fc	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aSourceIndex$[ebp], 7072
  00a03	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a09	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00a0d	50		 push	 eax
  00a0e	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _aSourceIndex$[ebp], 7072
  00a15	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a1b	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00a1f	50		 push	 eax
  00a20	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00a25	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a2b	83 c4 10	 add	 esp, 16			; 00000010H

; 10588: 			gObj[aSourceIndex].AccountID,
; 10589: 			gObj[aSourceIndex].Name,
; 10590: 			gObj[aSourceIndex].m_IfState.type
; 10591: 			);
; 10592: 		return;

  00a2e	e9 64 0e 00 00	 jmp	 $LN1@CGPShopReq
$LN23@CGPShopReq:

; 10593: 	}
; 10594: #endif
; 10595: 
; 10596: 	//     
; 10597: 	INT iITEM_LOG_TYPE		= 0;

  00a33	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _iITEM_LOG_TYPE$[ebp], 0

; 10598: 	INT iITEM_LOG_LEVEL		= 0;

  00a3a	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _iITEM_LOG_LEVEL$[ebp], 0

; 10599: 	INT iITEM_LOG_DUR		= 0;

  00a41	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _iITEM_LOG_DUR$[ebp], 0

; 10600: 	INT iITEM_LOG_SERIAL	= 0;

  00a48	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _iITEM_LOG_SERIAL$[ebp], 0

; 10601: 
; 10602: 
; 10603: 	__try {

  00a4f	9b		 fwait
  00a50	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 10604: 		//            .
; 10605: 		if (!CHECK_LIMIT(lpMsg->btItemPos-MAX_INVENTORY, MAX_INVENTORY_EXTEND - MAX_INVENTORY)) {

  00a57	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00a5a	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00a5e	83 e9 4c	 sub	 ecx, 76			; 0000004cH
  00a61	79 0c		 jns	 SHORT $LN47@CGPShopReq
  00a63	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv634[ebp], 0
  00a6d	eb 31		 jmp	 SHORT $LN48@CGPShopReq
$LN47@CGPShopReq:
  00a6f	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00a72	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00a76	83 e8 4c	 sub	 eax, 76			; 0000004cH
  00a79	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a7c	7e 0c		 jle	 SHORT $LN45@CGPShopReq
  00a7e	c7 85 48 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv633[ebp], 0
  00a88	eb 0a		 jmp	 SHORT $LN46@CGPShopReq
$LN45@CGPShopReq:
  00a8a	c7 85 48 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv633[ebp], 1
$LN46@CGPShopReq:
  00a94	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR tv633[ebp]
  00a9a	89 8d 4c fe ff
	ff		 mov	 DWORD PTR tv634[ebp], ecx
$LN48@CGPShopReq:
  00aa0	83 bd 4c fe ff
	ff 00		 cmp	 DWORD PTR tv634[ebp], 0
  00aa7	75 2f		 jne	 SHORT $LN25@CGPShopReq

; 10606: 			//      
; 10607: 			CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 5);			//  5 :    

  00aa9	6a 05		 push	 5
  00aab	6a 00		 push	 0
  00aad	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ab0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ab2	51		 push	 ecx
  00ab3	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00ab6	52		 push	 edx
  00ab7	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00abc	83 c4 10	 add	 esp, 16			; 00000010H

; 10608: 			return;

  00abf	6a fe		 push	 -2			; fffffffeH
  00ac1	9b		 fwait
  00ac2	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00ac5	50		 push	 eax
  00ac6	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00acb	e8 00 00 00 00	 call	 __local_unwind4
  00ad0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ad3	e9 bf 0d 00 00	 jmp	 $LN1@CGPShopReq
$LN25@CGPShopReq:

; 10609: 		}
; 10610: 
; 10611: #ifdef MODIFY_ITEM_DUPLICATION_IN_MAPSERVER_MOVING_20051219
; 10612: 		//        .
; 10613: 		if( lpObj->m_bMapSvrMoveQuit == true )
; 10614: 		{
; 10615: 			CGPShopAnsBuyItem (aSourceIndex, -1, 0, 2);			
; 10616: 			return;
; 10617: 		}
; 10618: #endif
; 10619: 
; 10620: 		if( lpObj->Inventory1[lpMsg->btItemPos].IsItem() == TRUE )

  00ad8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00adb	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00adf	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00ae5	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ae8	03 8a 6c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3180]
  00aee	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00af3	83 f8 01	 cmp	 eax, 1
  00af6	0f 85 81 0d 00
	00		 jne	 $LN41@CGPShopReq

; 10621: 		{
; 10622: 			if (lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue <= 0) {

  00afc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00aff	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00b03	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00b09	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b0c	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  00b12	83 7c 11 68 00	 cmp	 DWORD PTR [ecx+edx+104], 0
  00b17	7f 6d		 jg	 SHORT $LN27@CGPShopReq

; 10623: 				//       
; 10624: 				LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did Not Choose Item Price",

  00b19	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b1c	83 c0 73	 add	 eax, 115		; 00000073H
  00b1f	50		 push	 eax
  00b20	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b23	83 c1 68	 add	 ecx, 104		; 00000068H
  00b26	51		 push	 ecx
  00b27	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00b2e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b33	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00b37	51		 push	 ecx
  00b38	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00b3f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b44	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00b48	51		 push	 ecx
  00b49	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00b4e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b54	83 c4 14	 add	 esp, 20			; 00000014H

; 10625: 					gObj[aSourceIndex].AccountID,
; 10626: 					gObj[aSourceIndex].Name,
; 10627: 					lpObj->AccountID,
; 10628: 					lpObj->Name
; 10629: 					);
; 10630: 				CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 6);		//  6 :   

  00b57	6a 06		 push	 6
  00b59	6a 00		 push	 0
  00b5b	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b5e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b60	51		 push	 ecx
  00b61	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00b64	52		 push	 edx
  00b65	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00b6a	83 c4 10	 add	 esp, 16			; 00000010H

; 10631: 				return;	

  00b6d	6a fe		 push	 -2			; fffffffeH
  00b6f	9b		 fwait
  00b70	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00b73	50		 push	 eax
  00b74	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00b79	e8 00 00 00 00	 call	 __local_unwind4
  00b7e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b81	e9 11 0d 00 00	 jmp	 $LN1@CGPShopReq
$LN27@CGPShopReq:

; 10632: 			}
; 10633: 			
; 10634: 	if (lpObj->OffTradeCredits == 1)

  00b86	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b89	83 b8 9c 1a 00
	00 01		 cmp	 DWORD PTR [eax+6812], 1
  00b90	0f 85 5e 04 00
	00		 jne	 $LN28@CGPShopReq

; 10635:     {
; 10636: 	int Golds = Manager.KCredits(gObj[aSourceIndex].AccountID);

  00b96	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00b9d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ba3	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00ba7	52		 push	 edx
  00ba8	b9 00 00 00 00	 mov	 ecx, OFFSET ?Manager@@3VCManager@@A ; Manager
  00bad	e8 00 00 00 00	 call	 ?KCredits@CManager@@QAEHPAD@Z ; CManager::KCredits
  00bb2	89 45 b0	 mov	 DWORD PTR _Golds$11[ebp], eax

; 10637: 	int pide = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue;

  00bb5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00bb8	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00bbc	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00bc2	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bc5	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  00bcb	8b 54 11 68	 mov	 edx, DWORD PTR [ecx+edx+104]
  00bcf	89 55 ac	 mov	 DWORD PTR _pide$10[ebp], edx

; 10638: 	//int NCPSHOP = Manager.Pshopnpc(lpObj->AccountID);
; 10639: 	GetPrivateProfileString("UPDATE TIENDAPERSONAL", "TIENDAPERSONALRESTA", "UPDATE MuOnline.dbo.MEMB_INFO SET Cash = Cash - %d WHERE memb___id = '%s'", g_GlobalConfig.OFFTRADERESTA, 200, CFG_QUERYSHOP);//SACA GOLDS

  00bd2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GGOILNKD@?4?4?2data?2QueryShop?4ini@
  00bd7	68 c8 00 00 00	 push	 200			; 000000c8H
  00bdc	68 d8 04 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+1240
  00be1	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@BHAABMKG@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@
  00be6	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BABKIKBE@TIENDAPERSONALRESTA@
  00beb	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CENNGABF@UPDATE?5TIENDAPERSONAL@
  00bf0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 10640: 	GetPrivateProfileString("UPDATE TIENDAPERSONAL", "TIENDAPERSONALSUMA", "UPDATE MuOnline.dbo.MEMB_INFO SET Cash = Cash + %d WHERE memb___id = '%s'", g_GlobalConfig.OFFTRADESUMA, 200, CFG_QUERYSHOP);//SACA GOLDS

  00bf6	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GGOILNKD@?4?4?2data?2QueryShop?4ini@
  00bfb	68 c8 00 00 00	 push	 200			; 000000c8H
  00c00	68 10 04 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+1040
  00c05	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@BCLMBCOI@UPDATE?5MuOnline?4dbo?4MEMB_INFO?5S@
  00c0a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@INFPCJNN@TIENDAPERSONALSUMA@
  00c0f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@CENNGABF@UPDATE?5TIENDAPERSONAL@
  00c14	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 10641: 
; 10642: 	//-- STAR [Tienda Personal] PLAYERS
; 10643: 		if (Golds < pide)

  00c1a	8b 45 b0	 mov	 eax, DWORD PTR _Golds$11[ebp]
  00c1d	3b 45 ac	 cmp	 eax, DWORD PTR _pide$10[ebp]
  00c20	7d 68		 jge	 SHORT $LN30@CGPShopReq

; 10644: 		{
; 10645: 			MsgOutput(aSourceIndex,"[Tienda Personal] Necesitas %d Cash", lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue);

  00c22	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00c25	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00c29	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00c2f	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c32	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  00c38	8b 54 11 68	 mov	 edx, DWORD PTR [ecx+edx+104]
  00c3c	52		 push	 edx
  00c3d	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FKIEGGCJ@?$FLTienda?5Personal?$FN?5Necesitas?5?$CFd?5@
  00c42	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00c45	50		 push	 eax
  00c46	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00c4b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10646: 			MsgOutput(aSourceIndex,"[Tienda Personal] Actualmente tienes  %d Cash", Golds);

  00c4e	8b 45 b0	 mov	 eax, DWORD PTR _Golds$11[ebp]
  00c51	50		 push	 eax
  00c52	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@INIPKDON@?$FLTienda?5Personal?$FN?5Actualmente?5t@
  00c57	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  00c5a	51		 push	 ecx
  00c5b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00c60	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10647: 			CGPShopAnsOpen(aSourceIndex, 0);

  00c63	6a 00		 push	 0
  00c65	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00c68	50		 push	 eax
  00c69	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  00c6e	83 c4 08	 add	 esp, 8

; 10648: 			return;

  00c71	6a fe		 push	 -2			; fffffffeH
  00c73	9b		 fwait
  00c74	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00c77	50		 push	 eax
  00c78	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00c7d	e8 00 00 00 00	 call	 __local_unwind4
  00c82	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c85	e9 0d 0c 00 00	 jmp	 $LN1@CGPShopReq
$LN30@CGPShopReq:

; 10649: 		}
; 10650: 
; 10651: 		Manager.ExecFormat(g_GlobalConfig.OFFTRADERESTA, pide, gObj[aSourceIndex].AccountID); 

  00c8a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00c91	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c97	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00c9b	52		 push	 edx
  00c9c	8b 45 ac	 mov	 eax, DWORD PTR _pide$10[ebp]
  00c9f	50		 push	 eax
  00ca0	68 d8 04 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+1240
  00ca5	68 00 00 00 00	 push	 OFFSET ?Manager@@3VCManager@@A ; Manager
  00caa	e8 00 00 00 00	 call	 ?ExecFormat@CDataBase@@QAA_NPBDZZ ; CDataBase::ExecFormat
  00caf	83 c4 10	 add	 esp, 16			; 00000010H

; 10652: 		Manager.ExecFormat(g_GlobalConfig.OFFTRADESUMA, pide, lpObj->AccountID);

  00cb2	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cb5	83 c0 68	 add	 eax, 104		; 00000068H
  00cb8	50		 push	 eax
  00cb9	8b 4d ac	 mov	 ecx, DWORD PTR _pide$10[ebp]
  00cbc	51		 push	 ecx
  00cbd	68 10 04 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+1040
  00cc2	68 00 00 00 00	 push	 OFFSET ?Manager@@3VCManager@@A ; Manager
  00cc7	e8 00 00 00 00	 call	 ?ExecFormat@CDataBase@@QAA_NPBDZZ ; CDataBase::ExecFormat
  00ccc	83 c4 10	 add	 esp, 16			; 00000010H

; 10653: 		MsgOutput(aSourceIndex,"[Tienda Personal] Te quedan %d Cash", Golds - pide);

  00ccf	8b 45 b0	 mov	 eax, DWORD PTR _Golds$11[ebp]
  00cd2	2b 45 ac	 sub	 eax, DWORD PTR _pide$10[ebp]
  00cd5	50		 push	 eax
  00cd6	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@BDDKFCHD@?$FLTienda?5Personal?$FN?5Te?5quedan?5?$CFd?5@
  00cdb	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  00cde	51		 push	 ecx
  00cdf	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00ce4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10654: 
; 10655: 			if (lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue <= 0) 

  00ce7	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00cea	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00cee	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00cf4	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cf7	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  00cfd	83 7c 11 68 00	 cmp	 DWORD PTR [ecx+edx+104], 0
  00d02	7f 6d		 jg	 SHORT $LN31@CGPShopReq

; 10656: 			{
; 10657: 				//       
; 10658: 				LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did Not Choose Item Price",

  00d04	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d07	83 c0 73	 add	 eax, 115		; 00000073H
  00d0a	50		 push	 eax
  00d0b	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d0e	83 c1 68	 add	 ecx, 104		; 00000068H
  00d11	51		 push	 ecx
  00d12	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00d19	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d1e	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00d22	51		 push	 ecx
  00d23	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00d2a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d2f	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00d33	51		 push	 ecx
  00d34	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00d39	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00d3f	83 c4 14	 add	 esp, 20			; 00000014H

; 10659: 					gObj[aSourceIndex].AccountID,
; 10660: 					gObj[aSourceIndex].Name,
; 10661: 					lpObj->AccountID,
; 10662: 					lpObj->Name
; 10663: 					);
; 10664: 				CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 6);		//  6 :   

  00d42	6a 06		 push	 6
  00d44	6a 00		 push	 0
  00d46	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d49	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d4b	51		 push	 ecx
  00d4c	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00d4f	52		 push	 edx
  00d50	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00d55	83 c4 10	 add	 esp, 16			; 00000010H

; 10665: 				return;	

  00d58	6a fe		 push	 -2			; fffffffeH
  00d5a	9b		 fwait
  00d5b	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00d5e	50		 push	 eax
  00d5f	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00d64	e8 00 00 00 00	 call	 __local_unwind4
  00d69	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d6c	e9 26 0b 00 00	 jmp	 $LN1@CGPShopReq
$LN31@CGPShopReq:

; 10666: 			}
; 10667: 
; 10668: 			BYTE btNewItemPos = 0;

  00d71	c6 45 ab 00	 mov	 BYTE PTR _btNewItemPos$9[ebp], 0

; 10669: 			btNewItemPos = ::gObjOnlyInventoryInsertItem(aSourceIndex, lpObj->Inventory1[lpMsg->btItemPos]);

  00d75	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00d78	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00d7c	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00d82	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d85	8b b0 6c 0c 00
	00		 mov	 esi, DWORD PTR [eax+3180]
  00d8b	03 f2		 add	 esi, edx
  00d8d	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00d93	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00d98	8b fc		 mov	 edi, esp
  00d9a	f3 a5		 rep movsd
  00d9c	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  00d9f	51		 push	 ecx
  00da0	e8 00 00 00 00	 call	 ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjOnlyInventoryInsertItem
  00da5	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  00dab	88 45 ab	 mov	 BYTE PTR _btNewItemPos$9[ebp], al

; 10670: 
; 10671: 
; 10672: 			iITEM_LOG_TYPE		= lpObj->Inventory1[lpMsg->btItemPos].m_Type;

  00dae	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00db1	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00db5	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00dbb	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dbe	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  00dc4	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  00dc9	89 55 c0	 mov	 DWORD PTR _iITEM_LOG_TYPE$[ebp], edx

; 10673: 			iITEM_LOG_LEVEL		= lpObj->Inventory1[lpMsg->btItemPos].m_Level;

  00dcc	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00dcf	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00dd3	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00dd9	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ddc	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  00de2	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  00de7	89 55 bc	 mov	 DWORD PTR _iITEM_LOG_LEVEL$[ebp], edx

; 10674: 			iITEM_LOG_DUR		= lpObj->Inventory1[lpMsg->btItemPos].m_Durability;

  00dea	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00ded	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00df1	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00df7	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dfa	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  00e00	f3 0f 2c 54 11
	24		 cvttss2si edx, DWORD PTR [ecx+edx+36]
  00e06	89 55 b8	 mov	 DWORD PTR _iITEM_LOG_DUR$[ebp], edx

; 10675: 			iITEM_LOG_SERIAL	= lpObj->Inventory1[lpMsg->btItemPos].m_Number;

  00e09	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00e0c	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00e10	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00e16	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e19	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  00e1f	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00e22	89 55 b4	 mov	 DWORD PTR _iITEM_LOG_SERIAL$[ebp], edx

; 10676: 			int precio = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue;

  00e25	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00e28	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00e2c	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00e32	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e35	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  00e3b	8b 54 11 68	 mov	 edx, DWORD PTR [ecx+edx+104]
  00e3f	89 55 a4	 mov	 DWORD PTR _precio$8[ebp], edx

; 10677: 			SQLCHAR CashLog[255] = { 0 };

  00e42	68 ff 00 00 00	 push	 255			; 000000ffH
  00e47	6a 00		 push	 0
  00e49	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _CashLog$7[ebp]
  00e4f	50		 push	 eax
  00e50	e8 00 00 00 00	 call	 _memset
  00e55	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10678: 		    wsprintf((char *)CashLog, "[COMPRA] Cuenta:[%s] Usuario:[%s] Compro por [%d] Cash [VENDEDOR] Cuenta:[%s] Usuario:[%s]", gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, precio, lpObj->AccountID, lpObj->Name );//GUARDA LOGS DEL CAMBIO DE GOLDS

  00e58	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e5b	83 c0 73	 add	 eax, 115		; 00000073H
  00e5e	50		 push	 eax
  00e5f	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e62	83 c1 68	 add	 ecx, 104		; 00000068H
  00e65	51		 push	 ecx
  00e66	8b 55 a4	 mov	 edx, DWORD PTR _precio$8[ebp]
  00e69	52		 push	 edx
  00e6a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00e71	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e77	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00e7b	52		 push	 edx
  00e7c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00e83	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e89	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00e8d	52		 push	 edx
  00e8e	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@OHDLELPO@?$FLCOMPRA?$FN?5Cuenta?3?$FL?$CFs?$FN?5Usuario?3?$FL?$CF@
  00e93	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _CashLog$7[ebp]
  00e99	50		 push	 eax
  00e9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00ea0	83 c4 1c	 add	 esp, 28			; 0000001cH

; 10679: 		    LogSystem::CustomLogcash((char*)CashLog);//GUARDA LOGS DEL CAMBIO DE GOLDS

  00ea3	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _CashLog$7[ebp]
  00ea9	50		 push	 eax
  00eaa	e8 00 00 00 00	 call	 ?CustomLogcash@LogSystem@@SAXPAD@Z ; LogSystem::CustomLogcash
  00eaf	83 c4 04	 add	 esp, 4

; 10680: 	        LogAddTD( "[COMPRA] Cuenta:[%s] Usuario:[%s] Compro por [%d] Cash [VENDEDOR] Cuenta:[%s] Usuario:[%s]", gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, precio, lpObj->AccountID, lpObj->Name );//GUARDA LOGS DEL CAMBIO DE GOLDS	

  00eb2	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00eb5	83 c0 73	 add	 eax, 115		; 00000073H
  00eb8	50		 push	 eax
  00eb9	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ebc	83 c1 68	 add	 ecx, 104		; 00000068H
  00ebf	51		 push	 ecx
  00ec0	8b 55 a4	 mov	 edx, DWORD PTR _precio$8[ebp]
  00ec3	52		 push	 edx
  00ec4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00ecb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ed1	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00ed5	52		 push	 edx
  00ed6	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00edd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ee3	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00ee7	52		 push	 edx
  00ee8	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@OHDLELPO@?$FLCOMPRA?$FN?5Cuenta?3?$FL?$CFs?$FN?5Usuario?3?$FL?$CF@
  00eed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00ef3	83 c4 18	 add	 esp, 24			; 00000018H

; 10681: 			
; 10682: 			gObjInventoryItemSet_PShop(lpObj->m_Index, lpMsg->btItemPos, 0xFF);

  00ef6	68 ff 00 00 00	 push	 255			; 000000ffH
  00efb	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00efe	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00f02	51		 push	 ecx
  00f03	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00f06	8b 02		 mov	 eax, DWORD PTR [edx]
  00f08	50		 push	 eax
  00f09	e8 00 00 00 00	 call	 ?gObjInventoryItemSet_PShop@@YAXHHE@Z ; gObjInventoryItemSet_PShop
  00f0e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10683: 			lpObj->Inventory1[lpMsg->btItemPos].Clear();

  00f11	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00f14	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00f18	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00f1e	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00f21	03 8a 6c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3180]
  00f27	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 10684: 			GCInventoryItemDeleteSend(lpObj->m_Index, lpMsg->btItemPos, 1);

  00f2c	6a 01		 push	 1
  00f2e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00f31	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00f35	51		 push	 ecx
  00f36	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00f39	8b 02		 mov	 eax, DWORD PTR [edx]
  00f3b	50		 push	 eax
  00f3c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00f41	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10685: 
; 10686: 			::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, btNewItemPos, 1);

  00f44	6a 01		 push	 1
  00f46	0f b6 45 ab	 movzx	 eax, BYTE PTR _btNewItemPos$9[ebp]
  00f4a	50		 push	 eax
  00f4b	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00f4e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00f50	52		 push	 edx
  00f51	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  00f54	50		 push	 eax
  00f55	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00f5a	83 c4 10	 add	 esp, 16			; 00000010H

; 10687: 			::CGPShopAnsSoldItem(lpObj->m_Index, aSourceIndex, lpMsg->btItemPos);

  00f5d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00f60	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00f64	51		 push	 ecx
  00f65	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00f68	52		 push	 edx
  00f69	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f6c	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f6e	51		 push	 ecx
  00f6f	e8 00 00 00 00	 call	 ?CGPShopAnsSoldItem@@YAXHHH@Z ; CGPShopAnsSoldItem
  00f74	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10688: 
; 10689: 			if (btNewItemPos == 0xFF)

  00f77	0f b6 45 ab	 movzx	 eax, BYTE PTR _btNewItemPos$9[ebp]
  00f7b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00f80	75 6d		 jne	 SHORT $LN32@CGPShopReq

; 10690: 			{
; 10691: 				LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Buy Item",

  00f82	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f85	83 c0 73	 add	 eax, 115		; 00000073H
  00f88	50		 push	 eax
  00f89	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00f8c	83 c1 68	 add	 ecx, 104		; 00000068H
  00f8f	51		 push	 ecx
  00f90	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00f97	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f9c	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00fa0	51		 push	 ecx
  00fa1	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  00fa8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00fad	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00fb1	51		 push	 ecx
  00fb2	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  00fb7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00fbd	83 c4 14	 add	 esp, 20			; 00000014H

; 10692: 				gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 10693: 				lpObj->AccountID, lpObj->Name);
; 10694: 			    ::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  00fc0	6a 08		 push	 8
  00fc2	6a 00		 push	 0
  00fc4	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fc7	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fc9	51		 push	 ecx
  00fca	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00fcd	52		 push	 edx
  00fce	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00fd3	83 c4 10	 add	 esp, 16			; 00000010H

; 10695: 
; 10696: 					return;

  00fd6	6a fe		 push	 -2			; fffffffeH
  00fd8	9b		 fwait
  00fd9	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00fdc	50		 push	 eax
  00fdd	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00fe2	e8 00 00 00 00	 call	 __local_unwind4
  00fe7	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fea	e9 a8 08 00 00	 jmp	 $LN1@CGPShopReq
$LN32@CGPShopReq:

; 10697: 			}
; 10698: 
; 10699: 		}

  00fef	e9 05 04 00 00	 jmp	 $LN33@CGPShopReq
$LN28@CGPShopReq:

; 10700: 			else if(lpObj->OffTradeZen == 1)

  00ff4	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ff7	83 b8 98 1a 00
	00 01		 cmp	 DWORD PTR [eax+6808], 1
  00ffe	0f 85 f5 03 00
	00		 jne	 $LN33@CGPShopReq

; 10701: 				{
; 10702: 				if ( gObj[aSourceIndex].Money < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue )

  01004	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  0100b	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0100e	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  01012	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  01018	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0101b	8b 92 6c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3180]
  01021	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01027	8b 84 06 b0 00
	00 00		 mov	 eax, DWORD PTR [esi+eax+176]
  0102e	3b 44 0a 68	 cmp	 eax, DWORD PTR [edx+ecx+104]
  01032	7d 6d		 jge	 SHORT $LN34@CGPShopReq

; 10703: 				{
; 10704: 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack of Zen",

  01034	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01037	83 c0 73	 add	 eax, 115		; 00000073H
  0103a	50		 push	 eax
  0103b	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0103e	83 c1 68	 add	 ecx, 104		; 00000068H
  01041	51		 push	 ecx
  01042	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  01049	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0104e	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  01052	51		 push	 ecx
  01053	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  0105a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0105f	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  01063	51		 push	 ecx
  01064	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  01069	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0106f	83 c4 14	 add	 esp, 20			; 00000014H

; 10705: 						gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 10706: 						lpObj->AccountID, lpObj->Name);
; 10707: 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 7);

  01072	6a 07		 push	 7
  01074	6a 00		 push	 0
  01076	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0107b	51		 push	 ecx
  0107c	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  0107f	52		 push	 edx
  01080	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  01085	83 c4 10	 add	 esp, 16			; 00000010H

; 10708: 
; 10709: 					return;

  01088	6a fe		 push	 -2			; fffffffeH
  0108a	9b		 fwait
  0108b	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0108e	50		 push	 eax
  0108f	68 00 00 00 00	 push	 OFFSET ___security_cookie
  01094	e8 00 00 00 00	 call	 __local_unwind4
  01099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0109c	e9 f6 07 00 00	 jmp	 $LN1@CGPShopReq
$LN34@CGPShopReq:

; 10710: 				}
; 10711: 
; 10712: 				DWORD dwCost = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue;

  010a1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  010a4	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  010a8	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  010ae	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010b1	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  010b7	8b 54 11 68	 mov	 edx, DWORD PTR [ecx+edx+104]
  010bb	89 95 a0 fe ff
	ff		 mov	 DWORD PTR _dwCost$6[ebp], edx

; 10713: 
; 10714: 				if ( gObjCheckMaxZen(lpObj->m_Index, dwCost) == FALSE )

  010c1	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _dwCost$6[ebp]
  010c7	50		 push	 eax
  010c8	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  010cb	8b 11		 mov	 edx, DWORD PTR [ecx]
  010cd	52		 push	 edx
  010ce	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  010d3	83 c4 08	 add	 esp, 8
  010d6	85 c0		 test	 eax, eax
  010d8	75 6d		 jne	 SHORT $LN35@CGPShopReq

; 10715: 				{
; 10716: 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exceeding Zen of the Host",

  010da	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010dd	83 c0 73	 add	 eax, 115		; 00000073H
  010e0	50		 push	 eax
  010e1	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  010e4	83 c1 68	 add	 ecx, 104		; 00000068H
  010e7	51		 push	 ecx
  010e8	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  010ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  010f4	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  010f8	51		 push	 ecx
  010f9	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  01100	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01105	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  01109	51		 push	 ecx
  0110a	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  0110f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01115	83 c4 14	 add	 esp, 20			; 00000014H

; 10717: 						gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 10718: 						lpObj->AccountID, lpObj->Name);
; 10719: 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  01118	6a 08		 push	 8
  0111a	6a 00		 push	 0
  0111c	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0111f	8b 08		 mov	 ecx, DWORD PTR [eax]
  01121	51		 push	 ecx
  01122	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  01125	52		 push	 edx
  01126	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  0112b	83 c4 10	 add	 esp, 16			; 00000010H

; 10720: 
; 10721: 					return;

  0112e	6a fe		 push	 -2			; fffffffeH
  01130	9b		 fwait
  01131	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  01134	50		 push	 eax
  01135	68 00 00 00 00	 push	 OFFSET ___security_cookie
  0113a	e8 00 00 00 00	 call	 __local_unwind4
  0113f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01142	e9 50 07 00 00	 jmp	 $LN1@CGPShopReq
$LN35@CGPShopReq:

; 10722: 				}
; 10723: 				
; 10724: 				BYTE btNewItemPos = 0;

  01147	c6 85 9f fe ff
	ff 00		 mov	 BYTE PTR _btNewItemPos$5[ebp], 0

; 10725: 				btNewItemPos = ::gObjOnlyInventoryInsertItem(aSourceIndex, lpObj->Inventory1[lpMsg->btItemPos]);

  0114e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01151	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  01155	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0115b	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0115e	8b b0 6c 0c 00
	00		 mov	 esi, DWORD PTR [eax+3180]
  01164	03 f2		 add	 esi, edx
  01166	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0116c	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01171	8b fc		 mov	 edi, esp
  01173	f3 a5		 rep movsd
  01175	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  01178	51		 push	 ecx
  01179	e8 00 00 00 00	 call	 ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjOnlyInventoryInsertItem
  0117e	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  01184	88 85 9f fe ff
	ff		 mov	 BYTE PTR _btNewItemPos$5[ebp], al

; 10726: 
; 10727: 				iITEM_LOG_TYPE = lpObj->Inventory1[lpMsg->btItemPos].m_Type;

  0118a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0118d	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  01191	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  01197	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0119a	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  011a0	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  011a5	89 55 c0	 mov	 DWORD PTR _iITEM_LOG_TYPE$[ebp], edx

; 10728: 				iITEM_LOG_LEVEL = lpObj->Inventory1[lpMsg->btItemPos].m_Level;

  011a8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  011ab	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  011af	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  011b5	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011b8	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  011be	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  011c3	89 55 bc	 mov	 DWORD PTR _iITEM_LOG_LEVEL$[ebp], edx

; 10729: 				iITEM_LOG_DUR = lpObj->Inventory1[lpMsg->btItemPos].m_Durability;

  011c6	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  011c9	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  011cd	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  011d3	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011d6	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  011dc	f3 0f 2c 54 11
	24		 cvttss2si edx, DWORD PTR [ecx+edx+36]
  011e2	89 55 b8	 mov	 DWORD PTR _iITEM_LOG_DUR$[ebp], edx

; 10730: 				iITEM_LOG_SERIAL = lpObj->Inventory1[lpMsg->btItemPos].m_Number;

  011e5	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  011e8	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  011ec	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  011f2	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011f5	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  011fb	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  011fe	89 55 b4	 mov	 DWORD PTR _iITEM_LOG_SERIAL$[ebp], edx

; 10731: 				::gObjInventoryItemSet_PShop(lpObj->m_Index, lpMsg->btItemPos, -1);

  01201	68 ff 00 00 00	 push	 255			; 000000ffH
  01206	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01209	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0120d	51		 push	 ecx
  0120e	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01211	8b 02		 mov	 eax, DWORD PTR [edx]
  01213	50		 push	 eax
  01214	e8 00 00 00 00	 call	 ?gObjInventoryItemSet_PShop@@YAXHHE@Z ; gObjInventoryItemSet_PShop
  01219	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10732: 				lpObj->Inventory1[lpMsg->btItemPos].Clear();

  0121c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0121f	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  01223	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  01229	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0122c	03 8a 6c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3180]
  01232	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 10733: 				::GCInventoryItemDeleteSend(lpObj->m_Index, lpMsg->btItemPos, TRUE);

  01237	6a 01		 push	 1
  01239	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0123c	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  01240	51		 push	 ecx
  01241	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01244	8b 02		 mov	 eax, DWORD PTR [edx]
  01246	50		 push	 eax
  01247	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0124c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10734: 				gObj[aSourceIndex].Money -= dwCost;

  0124f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  01256	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0125c	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  01263	2b 95 a0 fe ff
	ff		 sub	 edx, DWORD PTR _dwCost$6[ebp]
  01269	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  01270	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01276	89 94 01 b0 00
	00 00		 mov	 DWORD PTR [ecx+eax+176], edx

; 10735: 				lpObj->Money += dwCost;

  0127d	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01280	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  01286	03 8d a0 fe ff
	ff		 add	 ecx, DWORD PTR _dwCost$6[ebp]
  0128c	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0128f	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 10736: 				::GCMoneySend(aSourceIndex, gObj[aSourceIndex].Money);

  01295	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  0129c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  012a2	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  012a9	52		 push	 edx
  012aa	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  012ad	50		 push	 eax
  012ae	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  012b3	83 c4 08	 add	 esp, 8

; 10737: 				::GCMoneySend(lpObj->m_Index, lpObj->Money);

  012b6	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012b9	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  012bf	51		 push	 ecx
  012c0	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  012c3	8b 02		 mov	 eax, DWORD PTR [edx]
  012c5	50		 push	 eax
  012c6	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  012cb	83 c4 08	 add	 esp, 8

; 10738: 				::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, btNewItemPos, 1);

  012ce	6a 01		 push	 1
  012d0	0f b6 85 9f fe
	ff ff		 movzx	 eax, BYTE PTR _btNewItemPos$5[ebp]
  012d7	50		 push	 eax
  012d8	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  012db	8b 11		 mov	 edx, DWORD PTR [ecx]
  012dd	52		 push	 edx
  012de	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  012e1	50		 push	 eax
  012e2	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  012e7	83 c4 10	 add	 esp, 16			; 00000010H

; 10739: 				::CGPShopAnsSoldItem(lpObj->m_Index, aSourceIndex, lpMsg->btItemPos);

  012ea	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  012ed	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  012f1	51		 push	 ecx
  012f2	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  012f5	52		 push	 edx
  012f6	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  012fb	51		 push	 ecx
  012fc	e8 00 00 00 00	 call	 ?CGPShopAnsSoldItem@@YAXHHH@Z ; CGPShopAnsSoldItem
  01301	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10740: 
; 10741: 				if ( btNewItemPos == 0xFF )

  01304	0f b6 85 9f fe
	ff ff		 movzx	 eax, BYTE PTR _btNewItemPos$5[ebp]
  0130b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01310	75 6d		 jne	 SHORT $LN36@CGPShopReq

; 10742: 				{
; 10743: 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Buy Item",

  01312	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01315	83 c0 73	 add	 eax, 115		; 00000073H
  01318	50		 push	 eax
  01319	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0131c	83 c1 68	 add	 ecx, 104		; 00000068H
  0131f	51		 push	 ecx
  01320	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  01327	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0132c	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  01330	51		 push	 ecx
  01331	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  01338	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0133d	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  01341	51		 push	 ecx
  01342	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  01347	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0134d	83 c4 14	 add	 esp, 20			; 00000014H

; 10744: 						gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 10745: 						lpObj->AccountID, lpObj->Name);
; 10746: 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  01350	6a 08		 push	 8
  01352	6a 00		 push	 0
  01354	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01357	8b 08		 mov	 ecx, DWORD PTR [eax]
  01359	51		 push	 ecx
  0135a	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  0135d	52		 push	 edx
  0135e	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  01363	83 c4 10	 add	 esp, 16			; 00000010H

; 10747: 
; 10748: 					return;

  01366	6a fe		 push	 -2			; fffffffeH
  01368	9b		 fwait
  01369	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0136c	50		 push	 eax
  0136d	68 00 00 00 00	 push	 OFFSET ___security_cookie
  01372	e8 00 00 00 00	 call	 __local_unwind4
  01377	83 c4 0c	 add	 esp, 12			; 0000000cH
  0137a	e9 18 05 00 00	 jmp	 $LN1@CGPShopReq
$LN36@CGPShopReq:

; 10749: 				}
; 10750: 				    LogAddTD("[OffTrade][PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s][%s] (Price=%d ZEN, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, Serial:%d",

  0137f	8b 45 b4	 mov	 eax, DWORD PTR _iITEM_LOG_SERIAL$[ebp]
  01382	50		 push	 eax
  01383	8b 4d b8	 mov	 ecx, DWORD PTR _iITEM_LOG_DUR$[ebp]
  01386	51		 push	 ecx
  01387	8b 55 bc	 mov	 edx, DWORD PTR _iITEM_LOG_LEVEL$[ebp]
  0138a	52		 push	 edx
  0138b	6b 45 c0 6c	 imul	 eax, DWORD PTR _iITEM_LOG_TYPE$[ebp], 108
  0138f	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01394	50		 push	 eax
  01395	8b 4d c0	 mov	 ecx, DWORD PTR _iITEM_LOG_TYPE$[ebp]
  01398	51		 push	 ecx
  01399	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR _dwCost$6[ebp]
  0139f	52		 push	 edx
  013a0	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013a3	83 c0 18	 add	 eax, 24			; 00000018H
  013a6	50		 push	 eax
  013a7	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  013aa	83 c1 73	 add	 ecx, 115		; 00000073H
  013ad	51		 push	 ecx
  013ae	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  013b1	83 c2 68	 add	 edx, 104		; 00000068H
  013b4	52		 push	 edx
  013b5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  013bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  013c2	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  013c6	52		 push	 edx
  013c7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  013ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  013d4	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  013d8	52		 push	 edx
  013d9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  013e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  013e6	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  013ea	52		 push	 edx
  013eb	68 00 00 00 00	 push	 OFFSET ??_C@_0JC@NLGCBMPF@?$FLOffTrade?$FN?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  013f0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  013f6	83 c4 34	 add	 esp, 52			; 00000034H
$LN33@CGPShopReq:

; 10751: 					gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, gObj[aSourceIndex].Ip_addr,
; 10752: 					lpObj->AccountID, lpObj->Name, lpObj->Ip_addr, dwCost, iITEM_LOG_TYPE,
; 10753: 					ItemAttribute[iITEM_LOG_TYPE].Name, iITEM_LOG_LEVEL, iITEM_LOG_DUR, iITEM_LOG_SERIAL);
; 10754: 				}
; 10755: 
; 10756:              
; 10757: 			if (gObj[aSourceIndex].Money < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue) 

  013f9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  01400	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  01403	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  01407	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  0140d	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01410	8b 92 6c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3180]
  01416	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0141c	8b 84 06 b0 00
	00 00		 mov	 eax, DWORD PTR [esi+eax+176]
  01423	3b 44 0a 68	 cmp	 eax, DWORD PTR [edx+ecx+104]
  01427	7d 6d		 jge	 SHORT $LN37@CGPShopReq

; 10758:             {
; 10759: 				//     .
; 10760: 				LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack of Zen",

  01429	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0142c	83 c0 73	 add	 eax, 115		; 00000073H
  0142f	50		 push	 eax
  01430	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01433	83 c1 68	 add	 ecx, 104		; 00000068H
  01436	51		 push	 ecx
  01437	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  0143e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01443	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  01447	51		 push	 ecx
  01448	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  0144f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01454	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  01458	51		 push	 ecx
  01459	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  0145e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01464	83 c4 14	 add	 esp, 20			; 00000014H

; 10761: 					gObj[aSourceIndex].AccountID,
; 10762: 					gObj[aSourceIndex].Name,
; 10763: 					lpObj->AccountID,
; 10764: 					lpObj->Name
; 10765: 					);
; 10766: 				CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 7);		//  7 :  

  01467	6a 07		 push	 7
  01469	6a 00		 push	 0
  0146b	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0146e	8b 08		 mov	 ecx, DWORD PTR [eax]
  01470	51		 push	 ecx
  01471	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  01474	52		 push	 edx
  01475	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  0147a	83 c4 10	 add	 esp, 16			; 00000010H

; 10767: 				return;

  0147d	6a fe		 push	 -2			; fffffffeH
  0147f	9b		 fwait
  01480	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  01483	50		 push	 eax
  01484	68 00 00 00 00	 push	 OFFSET ___security_cookie
  01489	e8 00 00 00 00	 call	 __local_unwind4
  0148e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01491	e9 01 04 00 00	 jmp	 $LN1@CGPShopReq
$LN37@CGPShopReq:

; 10768: 			}
; 10769: 			
; 10770: 			//      .
; 10771: 			INT iPShopItemValue = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue;

  01496	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01499	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0149d	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  014a3	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014a6	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  014ac	8b 54 11 68	 mov	 edx, DWORD PTR [ecx+edx+104]
  014b0	89 95 98 fe ff
	ff		 mov	 DWORD PTR _iPShopItemValue$4[ebp], edx

; 10772: 
; 10773: #ifdef MODIFY_ZEN_MAX_20040414
; 10774: 			//      .
; 10775: 			if( !gObjCheckMaxZen( lpObj->m_Index, iPShopItemValue ) )

  014b6	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR _iPShopItemValue$4[ebp]
  014bc	50		 push	 eax
  014bd	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  014c0	8b 11		 mov	 edx, DWORD PTR [ecx]
  014c2	52		 push	 edx
  014c3	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  014c8	83 c4 08	 add	 esp, 8
  014cb	85 c0		 test	 eax, eax
  014cd	75 6d		 jne	 SHORT $LN38@CGPShopReq

; 10776: 			{
; 10777: 				LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exceeding Zen of the Host",

  014cf	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014d2	83 c0 73	 add	 eax, 115		; 00000073H
  014d5	50		 push	 eax
  014d6	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  014d9	83 c1 68	 add	 ecx, 104		; 00000068H
  014dc	51		 push	 ecx
  014dd	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  014e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  014e9	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  014ed	51		 push	 ecx
  014ee	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  014f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  014fa	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  014fe	51		 push	 ecx
  014ff	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  01504	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0150a	83 c4 14	 add	 esp, 20			; 00000014H

; 10778: 					gObj[aSourceIndex].AccountID,
; 10779: 					gObj[aSourceIndex].Name,
; 10780: 					lpObj->AccountID,
; 10781: 					lpObj->Name
; 10782: 					);
; 10783: 				CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 8);		//  9 :      .

  0150d	6a 08		 push	 8
  0150f	6a 00		 push	 0
  01511	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01514	8b 08		 mov	 ecx, DWORD PTR [eax]
  01516	51		 push	 ecx
  01517	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  0151a	52		 push	 edx
  0151b	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  01520	83 c4 10	 add	 esp, 16			; 00000010H

; 10784: 
; 10785: 				return;

  01523	6a fe		 push	 -2			; fffffffeH
  01525	9b		 fwait
  01526	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  01529	50		 push	 eax
  0152a	68 00 00 00 00	 push	 OFFSET ___security_cookie
  0152f	e8 00 00 00 00	 call	 __local_unwind4
  01534	83 c4 0c	 add	 esp, 12			; 0000000cH
  01537	e9 5b 03 00 00	 jmp	 $LN1@CGPShopReq
$LN38@CGPShopReq:

; 10786: 			}
; 10787: #endif
; 10788: 
; 10789: 			BYTE btResult = false;

  0153c	c6 85 97 fe ff
	ff 00		 mov	 BYTE PTR _btResult$3[ebp], 0

; 10790: 			btResult = gObjOnlyInventoryInsertItem(aSourceIndex, lpObj->Inventory1[lpMsg->btItemPos]);		// btResult    .

  01543	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01546	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0154a	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  01550	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01553	8b b0 6c 0c 00
	00		 mov	 esi, DWORD PTR [eax+3180]
  01559	03 f2		 add	 esi, edx
  0155b	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  01561	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01566	8b fc		 mov	 edi, esp
  01568	f3 a5		 rep movsd
  0156a	8b 4d 0c	 mov	 ecx, DWORD PTR _aSourceIndex$[ebp]
  0156d	51		 push	 ecx
  0156e	e8 00 00 00 00	 call	 ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjOnlyInventoryInsertItem
  01573	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  01579	88 85 97 fe ff
	ff		 mov	 BYTE PTR _btResult$3[ebp], al

; 10791: 			if (btResult == 0xFF) {

  0157f	0f b6 85 97 fe
	ff ff		 movzx	 eax, BYTE PTR _btResult$3[ebp]
  01586	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0158b	75 6d		 jne	 SHORT $LN39@CGPShopReq

; 10792: 				LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Buy Item",

  0158d	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01590	83 c0 73	 add	 eax, 115		; 00000073H
  01593	50		 push	 eax
  01594	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01597	83 c1 68	 add	 ecx, 104		; 00000068H
  0159a	51		 push	 ecx
  0159b	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  015a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  015a7	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  015ab	51		 push	 ecx
  015ac	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aSourceIndex$[ebp], 7072
  015b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  015b8	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  015bc	51		 push	 ecx
  015bd	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy@
  015c2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  015c8	83 c4 14	 add	 esp, 20			; 00000014H

; 10793: 					gObj[aSourceIndex].AccountID,
; 10794: 					gObj[aSourceIndex].Name,
; 10795: 					lpObj->AccountID,
; 10796: 					lpObj->Name
; 10797: 					);
; 10798: 				CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, 0, 8);		//  8 :      .

  015cb	6a 08		 push	 8
  015cd	6a 00		 push	 0
  015cf	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  015d4	51		 push	 ecx
  015d5	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  015d8	52		 push	 edx
  015d9	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  015de	83 c4 10	 add	 esp, 16			; 00000010H

; 10799: 				return;

  015e1	6a fe		 push	 -2			; fffffffeH
  015e3	9b		 fwait
  015e4	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  015e7	50		 push	 eax
  015e8	68 00 00 00 00	 push	 OFFSET ___security_cookie
  015ed	e8 00 00 00 00	 call	 __local_unwind4
  015f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  015f5	e9 9d 02 00 00	 jmp	 $LN1@CGPShopReq
$LN39@CGPShopReq:

; 10800: 			}
; 10801: 
; 10802: 			//       .
; 10803: 			iITEM_LOG_TYPE		= lpObj->Inventory1[lpMsg->btItemPos].m_Type;

  015fa	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  015fd	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  01601	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  01607	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0160a	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  01610	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  01615	89 55 c0	 mov	 DWORD PTR _iITEM_LOG_TYPE$[ebp], edx

; 10804: 			iITEM_LOG_LEVEL		= lpObj->Inventory1[lpMsg->btItemPos].m_Level;

  01618	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0161b	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0161f	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  01625	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01628	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  0162e	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  01633	89 55 bc	 mov	 DWORD PTR _iITEM_LOG_LEVEL$[ebp], edx

; 10805: 			iITEM_LOG_DUR		= lpObj->Inventory1[lpMsg->btItemPos].m_Durability;

  01636	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01639	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0163d	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  01643	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01646	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  0164c	f3 0f 2c 54 11
	24		 cvttss2si edx, DWORD PTR [ecx+edx+36]
  01652	89 55 b8	 mov	 DWORD PTR _iITEM_LOG_DUR$[ebp], edx

; 10806: 			iITEM_LOG_SERIAL	= lpObj->Inventory1[lpMsg->btItemPos].m_Number;

  01655	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01658	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0165c	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  01662	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01665	8b 88 6c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3180]
  0166b	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  0166e	89 55 b4	 mov	 DWORD PTR _iITEM_LOG_SERIAL$[ebp], edx

; 10807: 
; 10808: 			//   . -     TRUE .
; 10809: 			gObjInventoryItemSet_PShop(lpObj->m_Index, lpMsg->btItemPos, 0xFF);

  01671	68 ff 00 00 00	 push	 255			; 000000ffH
  01676	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01679	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0167d	51		 push	 ecx
  0167e	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01681	8b 02		 mov	 eax, DWORD PTR [edx]
  01683	50		 push	 eax
  01684	e8 00 00 00 00	 call	 ?gObjInventoryItemSet_PShop@@YAXHHE@Z ; gObjInventoryItemSet_PShop
  01689	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10810: 			lpObj->Inventory1[lpMsg->btItemPos].Clear();

  0168c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0168f	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  01693	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  01699	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0169c	03 8a 6c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3180]
  016a2	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 10811: 			GCInventoryItemDeleteSend(lpObj->m_Index, lpMsg->btItemPos, 1);

  016a7	6a 01		 push	 1
  016a9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  016ac	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  016b0	51		 push	 ecx
  016b1	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016b4	8b 02		 mov	 eax, DWORD PTR [edx]
  016b6	50		 push	 eax
  016b7	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  016bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10812: 
; 10813: 			//      .
; 10814: 			gObj[aSourceIndex].Money -= iPShopItemValue;

  016bf	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  016c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  016cc	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  016d3	2b 95 98 fe ff
	ff		 sub	 edx, DWORD PTR _iPShopItemValue$4[ebp]
  016d9	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  016e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  016e6	89 94 01 b0 00
	00 00		 mov	 DWORD PTR [ecx+eax+176], edx

; 10815: 			lpObj->Money += iPShopItemValue;

  016ed	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  016f0	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  016f6	03 8d 98 fe ff
	ff		 add	 ecx, DWORD PTR _iPShopItemValue$4[ebp]
  016fc	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  016ff	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 10816: 			GCMoneySend(aSourceIndex, gObj[aSourceIndex].Money);

  01705	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  0170c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01712	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  01719	52		 push	 edx
  0171a	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  0171d	50		 push	 eax
  0171e	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  01723	83 c4 08	 add	 esp, 8

; 10817: 			GCMoneySend(lpObj->m_Index, lpObj->Money);

  01726	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01729	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0172f	51		 push	 ecx
  01730	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01733	8b 02		 mov	 eax, DWORD PTR [edx]
  01735	50		 push	 eax
  01736	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0173b	83 c4 08	 add	 esp, 8

; 10818: 
; 10819: 			//      .
; 10820: //			GCItemListSend (aSourceIndex);
; 10821: //			GCItemListSend (lpObj->m_Index);
; 10822: 
; 10823: 			CGPShopAnsBuyItem (aSourceIndex, lpObj->m_Index, btResult, true);		//  1 :    

  0173e	6a 01		 push	 1
  01740	0f b6 85 97 fe
	ff ff		 movzx	 eax, BYTE PTR _btResult$3[ebp]
  01747	50		 push	 eax
  01748	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0174b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0174d	52		 push	 edx
  0174e	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  01751	50		 push	 eax
  01752	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  01757	83 c4 10	 add	 esp, 16			; 00000010H

; 10824: 			CGPShopAnsSoldItem (lpObj->m_Index, aSourceIndex, lpMsg->btItemPos);

  0175a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0175d	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  01761	51		 push	 ecx
  01762	8b 55 0c	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  01765	52		 push	 edx
  01766	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01769	8b 08		 mov	 ecx, DWORD PTR [eax]
  0176b	51		 push	 ecx
  0176c	e8 00 00 00 00	 call	 ?CGPShopAnsSoldItem@@YAXHHH@Z ; CGPShopAnsSoldItem
  01771	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10825: 
; 10826: #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 10827: 			LogAddTD("[PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s][%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, Serial:%u",
; 10828: #else
; 10829: 			LogAddTD("[PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s][%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, Serial:%d",

  01774	8b 45 b4	 mov	 eax, DWORD PTR _iITEM_LOG_SERIAL$[ebp]
  01777	50		 push	 eax
  01778	8b 4d b8	 mov	 ecx, DWORD PTR _iITEM_LOG_DUR$[ebp]
  0177b	51		 push	 ecx
  0177c	8b 55 bc	 mov	 edx, DWORD PTR _iITEM_LOG_LEVEL$[ebp]
  0177f	52		 push	 edx
  01780	6b 45 c0 6c	 imul	 eax, DWORD PTR _iITEM_LOG_TYPE$[ebp], 108
  01784	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01789	50		 push	 eax
  0178a	8b 4d c0	 mov	 ecx, DWORD PTR _iITEM_LOG_TYPE$[ebp]
  0178d	51		 push	 ecx
  0178e	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR _iPShopItemValue$4[ebp]
  01794	52		 push	 edx
  01795	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01798	83 c0 18	 add	 eax, 24			; 00000018H
  0179b	50		 push	 eax
  0179c	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0179f	83 c1 73	 add	 ecx, 115		; 00000073H
  017a2	51		 push	 ecx
  017a3	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017a6	83 c2 68	 add	 edx, 104		; 00000068H
  017a9	52		 push	 edx
  017aa	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  017b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  017b7	8d 54 01 18	 lea	 edx, DWORD PTR [ecx+eax+24]
  017bb	52		 push	 edx
  017bc	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  017c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  017c9	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  017cd	52		 push	 edx
  017ce	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  017d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  017db	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  017df	52		 push	 edx
  017e0	68 00 00 00 00	 push	 OFFSET ??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item@
  017e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  017eb	83 c4 34	 add	 esp, 52			; 00000034H

; 10830: #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 10831: 				gObj[aSourceIndex].AccountID,
; 10832: 				gObj[aSourceIndex].Name,
; 10833: 				gObj[aSourceIndex].Ip_addr,
; 10834: 				lpObj->AccountID,
; 10835: 				lpObj->Name,
; 10836: 				lpObj->Ip_addr,
; 10837: 				iPShopItemValue,
; 10838: 				iITEM_LOG_TYPE,
; 10839: 				ItemAttribute[iITEM_LOG_TYPE].Name,
; 10840: 				iITEM_LOG_LEVEL,
; 10841: 				iITEM_LOG_DUR,
; 10842: 				iITEM_LOG_SERIAL
; 10843: 				);
; 10844: 
; 10845: 
; 10846: 			if (PShop_CheckInventoryEmpty(lpObj->m_Index) == true) {

  017ee	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  017f1	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  017f4	51		 push	 ecx
  017f5	e8 00 00 00 00	 call	 ?PShop_CheckInventoryEmpty@@YA_NF@Z ; PShop_CheckInventoryEmpty
  017fa	83 c4 04	 add	 esp, 4
  017fd	0f b6 d0	 movzx	 edx, al
  01800	83 fa 01	 cmp	 edx, 1
  01803	75 6e		 jne	 SHORT $LN40@CGPShopReq

; 10847: 				//        .
; 10848: 				LogAddTD("[PShop] [%s][%s] Sold All Items - Auto Closing PShop",

  01805	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01808	83 c0 73	 add	 eax, 115		; 00000073H
  0180b	50		 push	 eax
  0180c	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0180f	83 c1 68	 add	 ecx, 104		; 00000068H
  01812	51		 push	 ecx
  01813	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items@
  01818	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0181e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10849: 					lpObj->AccountID,
; 10850: 					lpObj->Name
; 10851: 					);
; 10852: 
; 10853: 				GCServerMsgStringSend(lMsg.Get(1219), lpObj->m_Index, 1);		// "    ."

  01821	6a 01		 push	 1
  01823	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01826	8b 08		 mov	 ecx, DWORD PTR [eax]
  01828	51		 push	 ecx
  01829	68 c3 04 00 00	 push	 1219			; 000004c3H
  0182e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01833	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  01839	50		 push	 eax
  0183a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0183f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10854: 
; 10855: 				lpObj->m_bPShopOpen = false;

  01842	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01845	c6 80 f8 0c 00
	00 00		 mov	 BYTE PTR [eax+3320], 0

; 10856: 				memset (lpObj->m_szPShopText, 0, MAX_PSHOP_TEXT);

  0184c	6a 24		 push	 36			; 00000024H
  0184e	6a 00		 push	 0
  01850	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01853	05 fc 0c 00 00	 add	 eax, 3324		; 00000cfcH
  01858	50		 push	 eax
  01859	e8 00 00 00 00	 call	 _memset
  0185e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10857: 				
; 10858: 				CGPShopAnsClose (lpObj->m_Index, TRUE);

  01861	6a 01		 push	 1
  01863	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01866	8b 08		 mov	 ecx, DWORD PTR [eax]
  01868	51		 push	 ecx
  01869	e8 00 00 00 00	 call	 ?CGPShopAnsClose@@YAXHE@Z ; CGPShopAnsClose
  0186e	83 c4 08	 add	 esp, 8

; 10859: 			}

  01871	eb 0a		 jmp	 SHORT $LN41@CGPShopReq
$LN40@CGPShopReq:

; 10860: 			else {
; 10861: 				//     .
; 10862: 				lpObj->m_bPShopItemChange = true;

  01873	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01876	c6 80 fa 0c 00
	00 01		 mov	 BYTE PTR [eax+3322], 1
$LN41@CGPShopReq:

; 10863: 			}
; 10864: 		}
; 10865: 	}

  0187d	9b		 fwait
  0187e	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  01885	e8 02 00 00 00	 call	 $LN52@CGPShopReq
  0188a	eb 0b		 jmp	 SHORT $LN53@CGPShopReq
$LN50@CGPShopReq:
$LN55@CGPShopReq:
$LN52@CGPShopReq:

; 10866: 	__finally {
; 10867: 		lpObj->m_bPShopTransaction = false;

  0188c	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0188f	c6 80 f9 0c 00
	00 00		 mov	 BYTE PTR [eax+3321], 0
$LN51@CGPShopReq:
$LN54@CGPShopReq:
  01896	c3		 ret	 0
$LN53@CGPShopReq:
$LN1@CGPShopReq:

; 10868: 	}
; 10869: }

  01897	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0189a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  018a1	59		 pop	 ecx
  018a2	5f		 pop	 edi
  018a3	5e		 pop	 esi
  018a4	5b		 pop	 ebx
  018a5	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018a8	33 cd		 xor	 ecx, ebp
  018aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018af	8b e5		 mov	 esp, ebp
  018b1	5d		 pop	 ebp
  018b2	c3		 ret	 0
?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ENDP ; CGPShopReqBuyItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopAnsBuyItem@@YAXHHHE@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_iItemPos$ = 16						; size = 4
_btResult$ = 20						; size = 1
?CGPShopAnsBuyItem@@YAXHHHE@Z PROC			; CGPShopAnsBuyItem, COMDAT

; 10875: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 10876: 	PMSG_ANS_BUYITEM_FROM_PSHOP pMsg;
; 10877: 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x06, sizeof( pMsg ));

  00013	6a 0d		 push	 13			; 0000000dH
  00015	6a 06		 push	 6
  00017	6a 3f		 push	 63			; 0000003fH
  00019	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 10878: 
; 10879: 	pMsg.NumberH	= HIBYTE(aTargetIndex);

  00025	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00028	c1 e8 08	 shr	 eax, 8
  0002b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00030	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 10880: 	pMsg.NumberL	= LOBYTE(aTargetIndex);

  00033	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  00036	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003b	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 10881: 	pMsg.btItemPos	= iItemPos;

  0003e	8a 45 10	 mov	 al, BYTE PTR _iItemPos$[ebp]
  00041	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 10882: 	pMsg.Result		= btResult;

  00044	8a 45 14	 mov	 al, BYTE PTR _btResult$[ebp]
  00047	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 10883: 	ItemByteConvert( pMsg.cItemInfo, gObj[aSourceIndex].Inventory1[iItemPos] );

  0004a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aSourceIndex$[ebp], 7072
  00051	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  00058	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005e	8b b4 02 6c 0c
	00 00		 mov	 esi, DWORD PTR [edx+eax+3180]
  00065	03 f1		 add	 esi, ecx
  00067	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0006d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00072	8b fc		 mov	 edi, esp
  00074	f3 a5		 rep movsd
  00076	8d 45 f3	 lea	 eax, DWORD PTR _pMsg$[ebp+7]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  0007f	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 10884: 
; 10885: 	DataSend (aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00085	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00089	50		 push	 eax
  0008a	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 08	 mov	 edx, DWORD PTR _aSourceIndex$[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10886: }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	33 cd		 xor	 ecx, ebp
  000a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
?CGPShopAnsBuyItem@@YAXHHHE@Z ENDP			; CGPShopAnsBuyItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?CGPShopAnsOpen@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?CGPShopAnsOpen@@YAXHE@Z PROC				; CGPShopAnsOpen, COMDAT

; 10032: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10033: 	PMSG_ANS_PSHOP_OPEN pMsg;
; 10034: 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x02, sizeof( pMsg ));

  00009	6a 05		 push	 5
  0000b	6a 02		 push	 2
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00018	83 c4 10	 add	 esp, 16			; 00000010H

; 10035: 	pMsg.btResult = btResult;

  0001b	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]
  0001e	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 10036: 	
; 10037: 	DataSend (aIndex, (LPBYTE) &pMsg, sizeof(PMSG_ANS_PSHOP_OPEN));

  00021	6a 05		 push	 5
  00023	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10038: }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?CGPShopAnsOpen@@YAXHE@Z ENDP				; CGPShopAnsOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?GCCloseMsgSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?GCCloseMsgSend@@YAXHE@Z PROC				; GCCloseMsgSend, COMDAT

; 3360 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3361 : 	PMSG_RESULT			pMsg;
; 3362 : 	
; 3363 : 	PHeadSubSetBE((LPBYTE)&pMsg, 0xF1, 0x02, sizeof( pMsg ) );

  00009	6a 05		 push	 5
  0000b	6a 02		 push	 2
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetBE@@YAXPAEEEH@Z ; PHeadSubSetBE
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3364 : 	pMsg.result			= result;

  0001e	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00021	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 3365 : 
; 3366 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00024	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3367 : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?GCCloseMsgSend@@YAXHE@Z ENDP				; GCCloseMsgSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?ObjectMapJoinPositionSend@@YAXF@Z
_TEXT	SEGMENT
_pObject$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?ObjectMapJoinPositionSend@@YAXF@Z PROC			; ObjectMapJoinPositionSend, COMDAT

; 16884: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 16885: 	PMSG_USERMAPJOIN	pObject;
; 16886: 
; 16887: 	PHeadSubSetB((LPBYTE)&pObject, PMHC_MAPJOIN, 0x03, sizeof( pObject ) );	

  00013	6a 0a		 push	 10			; 0000000aH
  00015	6a 03		 push	 3
  00017	68 f3 00 00 00	 push	 243			; 000000f3H
  0001c	8d 45 f0	 lea	 eax, DWORD PTR _pObject$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00025	83 c4 10	 add	 esp, 16			; 00000010H

; 16888: 	
; 16889: 	pObject.NumberH   = HIBYTE(aIndex);

  00028	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0002c	c1 e8 08	 shr	 eax, 8
  0002f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00034	88 45 f4	 mov	 BYTE PTR _pObject$[ebp+4], al

; 16890: 	pObject.NumberL   = LOBYTE(aIndex);

  00037	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0003b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00040	88 45 f5	 mov	 BYTE PTR _pObject$[ebp+5], al

; 16891: 	pObject.X		  = (BYTE)gObj[aIndex].X;

  00043	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00047	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0004d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00053	8a 84 0a 04 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+260]
  0005a	88 45 f6	 mov	 BYTE PTR _pObject$[ebp+6], al

; 16892: 	pObject.Y		  = (BYTE)gObj[aIndex].Y;

  0005d	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00061	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006d	8a 84 0a 06 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+262]
  00074	88 45 f7	 mov	 BYTE PTR _pObject$[ebp+7], al

; 16893: 	pObject.MapNumber = gObj[aIndex].MapNumber;

  00077	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0007b	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00087	8a 84 0a 09 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+265]
  0008e	88 45 f8	 mov	 BYTE PTR _pObject$[ebp+8], al

; 16894: 	pObject.Dir	      = gObj[aIndex].Dir;

  00091	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00095	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0009b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a1	8a 84 0a 08 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+264]
  000a8	88 45 f9	 mov	 BYTE PTR _pObject$[ebp+9], al

; 16895: 
; 16896: 	DataSend(aIndex, (LPBYTE)&pObject, pObject.h.size);

  000ab	0f b6 45 f1	 movzx	 eax, BYTE PTR _pObject$[ebp+1]
  000af	50		 push	 eax
  000b0	8d 4d f0	 lea	 ecx, DWORD PTR _pObject$[ebp]
  000b3	51		 push	 ecx
  000b4	0f bf 55 08	 movsx	 edx, WORD PTR _aIndex$[ebp]
  000b8	52		 push	 edx
  000b9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16897: }

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c7	33 cd		 xor	 ecx, ebp
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
?ObjectMapJoinPositionSend@@YAXF@Z ENDP			; ObjectMapJoinPositionSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv69 = -66						; size = 1
tv71 = -65						; size = 1
_dwComposeAuthority$ = 8				; size = 4
_pMyObject$ = 12					; size = 4
?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z PROC		; CheckAuthority, COMDAT

; 1646 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1647 : 	return ((pMyObject->Authority & AUTHORITY_DISABLE) ? false : ((pMyObject->Authority & dwComposeAuthority) ? true : false));

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pMyObject$[ebp]
  0000c	8b 88 a4 01 00
	00		 mov	 ecx, DWORD PTR [eax+420]
  00012	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00018	74 06		 je	 SHORT $LN5@CheckAutho
  0001a	c6 45 bf 00	 mov	 BYTE PTR tv71[ebp], 0
  0001e	eb 1e		 jmp	 SHORT $LN6@CheckAutho
$LN5@CheckAutho:
  00020	8b 55 0c	 mov	 edx, DWORD PTR _pMyObject$[ebp]
  00023	8b 82 a4 01 00
	00		 mov	 eax, DWORD PTR [edx+420]
  00029	23 45 08	 and	 eax, DWORD PTR _dwComposeAuthority$[ebp]
  0002c	74 06		 je	 SHORT $LN3@CheckAutho
  0002e	c6 45 be 01	 mov	 BYTE PTR tv69[ebp], 1
  00032	eb 04		 jmp	 SHORT $LN4@CheckAutho
$LN3@CheckAutho:
  00034	c6 45 be 00	 mov	 BYTE PTR tv69[ebp], 0
$LN4@CheckAutho:
  00038	8a 4d be	 mov	 cl, BYTE PTR tv69[ebp]
  0003b	88 4d bf	 mov	 BYTE PTR tv71[ebp], cl
$LN6@CheckAutho:
  0003e	8a 45 bf	 mov	 al, BYTE PTR tv71[ebp]

; 1648 : 	//return(((pMyObject->Authority & dwComposeAuthority) == pMyObject->Authority)? true : false);
; 1649 : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z ENDP		; CheckAuthority
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TDurMagicKeyChecker.h
;	COMDAT ?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_btMagicKey$ = 8					; size = 1
?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::GetValidCount, COMDAT
; _this$ = ecx

; 73   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 		if( CHECK_VALID_MAGICKEY(btMagicKey) )

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00010	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00013	7f 19		 jg	 SHORT $LN2@GetValidCo
  00015	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	7e 11		 jle	 SHORT $LN2@GetValidCo

; 75   : 		{
; 76   : 			return 	m_btValidCount[btMagicKey];		

  0001d	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	0f b6 84 01 f0
	00 00 00	 movzx	 eax, BYTE PTR [ecx+eax+240]
  0002c	eb 05		 jmp	 SHORT $LN1@GetValidCo
$LN2@GetValidCo:

; 77   : 		}
; 78   : 
; 79   : 		return -77;

  0002e	b8 b3 ff ff ff	 mov	 eax, -77		; ffffffb3H
$LN1@GetValidCo:

; 80   : 	}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::GetValidCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TDurMagicKeyChecker.h
;	COMDAT ?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_btMagicKey$ = 8					; size = 1
?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::GetValidDurationTime, COMDAT
; _this$ = ecx

; 63   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 		if( CHECK_VALID_MAGICKEY(btMagicKey) )

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00010	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00013	7f 14		 jg	 SHORT $LN2@GetValidDu
  00015	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	7e 0c		 jle	 SHORT $LN2@GetValidDu

; 65   : 		{
; 66   : 			return 	m_dwDurationTime[btMagicKey];		

  0001d	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00027	eb 05		 jmp	 SHORT $LN1@GetValidDu
$LN2@GetValidDu:

; 67   : 		}
; 68   : 
; 69   : 		return -77;

  00029	b8 b3 ff ff ff	 mov	 eax, -77		; ffffffb3H
$LN1@GetValidDu:

; 70   : 	}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::GetValidDurationTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TDurMagicKeyChecker.h
;	COMDAT ?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_btMagicKey$ = 8					; size = 1
_dwCurrentTickCount$ = 12				; size = 4
?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z PROC	; TDurMagicKeyChecker::SetDurationTime, COMDAT
; _this$ = ecx

; 41   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 42   : 		if( CHECK_VALID_MAGICKEY(btMagicKey) )

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00010	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00013	7f 24		 jg	 SHORT $LN1@SetDuratio
  00015	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	7e 1c		 jle	 SHORT $LN1@SetDuratio

; 43   : 		{
; 44   : 			m_dwDurationTime[btMagicKey] = dwCurrentTickCount;	

  0001d	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 55 0c	 mov	 edx, DWORD PTR _dwCurrentTickCount$[ebp]
  00027	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 45   : 			m_btValidCount[btMagicKey] = DURATION_M_DEFAULT_VALIDCOUNT;

  0002a	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c6 84 01 f0 00
	00 00 07	 mov	 BYTE PTR [ecx+eax+240], 7
$LN1@SetDuratio:

; 46   : 		}
; 47   : 	}

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z ENDP	; TDurMagicKeyChecker::SetDurationTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TDurMagicKeyChecker.h
;	COMDAT ?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_btMagicKey$ = 8					; size = 1
?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z PROC		; TDurMagicKeyChecker::IsValidCount, COMDAT
; _this$ = ecx

; 28   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 		if( CHECK_VALID_MAGICKEY(btMagicKey) )

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00010	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00013	7f 22		 jg	 SHORT $LN2@IsValidCou
  00015	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	7e 1a		 jle	 SHORT $LN2@IsValidCou

; 30   : 		{
; 31   : 			if( m_btValidCount[btMagicKey] >=0 )

  0001d	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	0f b6 94 01 f0
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+240]
  0002c	85 d2		 test	 edx, edx
  0002e	7c 07		 jl	 SHORT $LN2@IsValidCou

; 32   : 			{
; 33   : 				return TRUE;

  00030	b8 01 00 00 00	 mov	 eax, 1
  00035	eb 02		 jmp	 SHORT $LN1@IsValidCou
$LN2@IsValidCou:

; 34   : 			}
; 35   : 		}
; 36   : 
; 37   : 		return FALSE;

  00037	33 c0		 xor	 eax, eax
$LN1@IsValidCou:

; 38   : 	}

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z ENDP		; TDurMagicKeyChecker::IsValidCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TDurMagicKeyChecker.h
;	COMDAT ?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_btMagicKey$ = 8					; size = 1
?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::IsValidDurationTime, COMDAT
; _this$ = ecx

; 15   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 16   : 		if( CHECK_VALID_MAGICKEY(btMagicKey) )

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00010	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00013	7f 26		 jg	 SHORT $LN2@IsValidDur
  00015	0f b6 45 08	 movzx	 eax, BYTE PTR _btMagicKey$[ebp]
  00019	85 c0		 test	 eax, eax
  0001b	7e 1e		 jle	 SHORT $LN2@IsValidDur

; 17   : 		{
; 18   : 			if( ( GetTickCount() - m_dwDurationTime[btMagicKey] ) < DURATION_M_LIMIT_TIME )

  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00023	0f b6 4d 08	 movzx	 ecx, BYTE PTR _btMagicKey$[ebp]
  00027	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	2b 04 8a	 sub	 eax, DWORD PTR [edx+ecx*4]
  0002d	3d 98 3a 00 00	 cmp	 eax, 15000		; 00003a98H
  00032	73 07		 jae	 SHORT $LN2@IsValidDur

; 19   : 			{
; 20   : 				return TRUE;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	eb 02		 jmp	 SHORT $LN1@IsValidDur
$LN2@IsValidDur:

; 21   : 			}
; 22   : 		}
; 23   : 		
; 24   : 		return FALSE;

  0003b	33 c0		 xor	 eax, eax
$LN1@IsValidDur:

; 25   : 	}

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::IsValidDurationTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\ProDef.h
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 25   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 		lpBuf[0] = PMHC_BYTE;

  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	6b c8 00	 imul	 ecx, eax, 0
  00014	8b 55 08	 mov	 edx, DWORD PTR _lpBuf$[ebp]
  00017	c6 04 0a c1	 mov	 BYTE PTR [edx+ecx], 193	; 000000c1H

; 27   : 		lpBuf[1] = size;

  0001b	b8 01 00 00 00	 mov	 eax, 1
  00020	c1 e0 00	 shl	 eax, 0
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  00026	8a 55 10	 mov	 dl, BYTE PTR _size$[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 28   : 		lpBuf[2] = head;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	d1 e0		 shl	 eax, 1
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  00036	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  00039	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 29   : 	}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1477 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1478 :         #pragma warning(push)
; 1479 :         #pragma warning(disable: 4996) // Deprecation
; 1480 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);

  00009	8b 45 10	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	6a ff		 push	 -1
  00015	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 __vsnprintf_l
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 1481 :         #pragma warning(pop)
; 1482 :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\protocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
