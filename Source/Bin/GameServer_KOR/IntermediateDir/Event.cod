; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?pEventObj@@3PAVOBJECTSTRUCT@@A			; pEventObj
PUBLIC	?g_sz2ANV_GIFT_NAME@@3QAY0EA@$$CBDA		; g_sz2ANV_GIFT_NAME
PUBLIC	?g_bRingEventItemTextLoad@@3HA			; g_bRingEventItemTextLoad
_BSS	SEGMENT
?pEventObj@@3PAVOBJECTSTRUCT@@A DD 01H DUP (?)		; pEventObj
?g_bRingEventItemTextLoad@@3HA DD 01H DUP (?)		; g_bRingEventItemTextLoad
_BSS	ENDS
CONST	SEGMENT
?g_sz2ANV_GIFT_NAME@@3QAY0EA@$$CBDA DB 0c0H, 0cfH, 0baH, 0bbH, ' ', 0c0H, 0afH
	DB	0b4H, 0cfH, 0b9H, 0f6H, 0bcH, 0c8H, ' ', 0bdH, 0baH, 0c6H, 0a9H
	DB	0b5H, 0f0H, 0bfH, 0c0H, 00H			; g_sz2ANV_GIFT_NAME
	ORG $+41
	DB	0c6H, 0e6H, 0c6H, 0bcH, 0beH, 0f6H, ' 4 PC', 00H
	ORG $+52
	DB	0b9H, 0c2H, ' ', 0c7H, 0c7H, 0b1H, 0d4H, 0beH, 0eeH, 00H
	ORG $+54
	DB	0b9H, 0c2H, ' ', 0b1H, 0d7H, 0b7H, 0a1H, 0c7H, 0c8H, ' ', 0c4H
	DB	0abH, 0b5H, 0e5H, '(FX 5200)', 00H
	ORG $+40
	DB	0b9H, 0c2H, ' ', 0b8H, 0b6H, 0bfH, 0ecH, 0bdH, 0baH, 00H
	ORG $+54
	DB	0b5H, 0f0H, 0c1H, 0f6H, 0c5H, 0bbH, ' ', 0c4H, 0abH, 0b8H
	DB	0deH, 0b6H, 0f3H, 00H
	ORG $+50
	DB	0b9H, 0c2H, ' ', 0bcH, 0eeH, 0c7H, 0ceH, 0b8H, 0f4H, ' ', 0bbH
	DB	0e7H, 0c0H, 0ccH, 0b9H, 0f6H, 0b8H, 0d3H, 0b4H, 0cfH, '(3', 0b8H
	DB	0b8H, 0bfH, 0f8H, ')', 00H
	ORG $+36
	DB	0bfH, 0b5H, 0c8H, 0adH, ' ', 0bfH, 0b9H, 0b8H, 0c5H, 0b1H
	DB	0c7H, '(2', 0c0H, 0e5H, ')', 00H
	ORG $+47
	DB	0c3H, 0e0H, 0baH, 0b9H, 0c0H, 0c7H, ' ', 0baH, 0b8H, 0bcH
	DB	0aeH, 00H
	ORG $+52
	DB	0bfH, 0b5H, 0c8H, 0a5H, 0c0H, 0c7H, ' ', 0baH, 0b8H, 0bcH
	DB	0aeH, 00H
	ORG $+52
	DB	0c8H, 0a5H, 0b5H, 0b7H, 0c0H, 0c7H, ' ', 0baH, 0b8H, 0bcH
	DB	0aeH, 00H
	ORG $+52
	DB	'50', 0b8H, 0b8H, 0c1H, 0a8H, 00H
	ORG $+57
	DB	'10', 0b8H, 0b8H, 0c1H, 0a8H, 00H
	ORG $+57
	DB	'5', 0b8H, 0b8H, 0c1H, 0a8H, 00H
	ORG $+58
	DB	0b7H, 0d4H, 0b5H, 0a5H, 0bfH, 0f9H, 0b5H, 0e5H, ' ', 0bfH
	DB	0acH, 0b0H, 0a3H, ' ', 0c0H, 0ccH, 0bfH, 0ebH, 0b1H, 0c7H, 00H
	ORG $+43
	DB	0b7H, 0d4H, 0b5H, 0a5H, 0bfH, 0f9H, 0b5H, 0e5H, ' ', 0c0H
	DB	0daH, 0c0H, 0afH, ' ', 0c0H, 0ccH, 0bfH, 0ebH, 0b1H, 0c7H, '(2'
	DB	0c0H, 0e5H, ')', 00H
	ORG $+38
	DB	'100', 0b5H, 0b7H, ' ', 0b9H, 0c2H, ' ', 0b1H, 0ddH, 0b1H
	DB	0abH, 00H
	ORG $+50
?g_szRingEventOfflineGift@@3QAY0CA@$$CBDA DB '100', 0b5H, 0b7H, ' ', 0b9H
	DB	0c2H, 0b9H, 0ddH, 0c1H, 0f6H, 00H		; g_szRingEventOfflineGift
	ORG $+19
	DB	'10', 0b5H, 0b7H, ' ', 0b9H, 0c2H, 0b9H, 0ddH, 0c1H, 0f6H
	DB	00H
	ORG $+20
	DB	'5', 0b5H, 0b7H, ' ', 0b9H, 0c2H, 0b9H, 0ddH, 0c1H, 0f6H, 00H
	ORG $+21
	DB	'2', 0b5H, 0b7H, ' ', 0b9H, 0c2H, 0b9H, 0ddH, 0c1H, 0f6H, 00H
	ORG $+21
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?GetBagCount@CItemBag@@QAEHXZ			; CItemBag::GetBagCount
PUBLIC	?GetNormalItemCount@CItemBag@@QAEHXZ		; CItemBag::GetNormalItemCount
PUBLIC	?GetExItemCount@CItemBag@@QAEHXZ		; CItemBag::GetExItemCount
PUBLIC	?LuckyBoxOpenEven@@YAXPAVOBJECTSTRUCT@@@Z	; LuckyBoxOpenEven
PUBLIC	?AttackEvent53BagOpen@@YAHPAVOBJECTSTRUCT@@@Z	; AttackEvent53BagOpen
PUBLIC	?AttackEvent55BagOpen@@YAHPAVOBJECTSTRUCT@@@Z	; AttackEvent55BagOpen
PUBLIC	?StarOfXMasOpenEven@@YAXPAVOBJECTSTRUCT@@@Z	; StarOfXMasOpenEven
PUBLIC	?FireCrackerOpenEven@@YAXPAVOBJECTSTRUCT@@@Z	; FireCrackerOpenEven
PUBLIC	?HeartOfLoveOpenEven@@YAXPAVOBJECTSTRUCT@@@Z	; HeartOfLoveOpenEven
PUBLIC	?DarkLordHeartItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z ; DarkLordHeartItemBoxOpen
PUBLIC	?KundunEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@EEE@Z ; KundunEventItemBoxOpen
PUBLIC	?GoldMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z	; GoldMedalOpenEven
PUBLIC	?SilverMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z	; SilverMedalOpenEven
PUBLIC	?EventChipOpenEven@@YAXPAVOBJECTSTRUCT@@@Z	; EventChipOpenEven
PUBLIC	?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z ; EledoradoBoxOpenEven
PUBLIC	?RingEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z	; RingEventItemBoxOpen
PUBLIC	?FriendShipItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z	; FriendShipItemBoxOpen
PUBLIC	?EGBloodCastleEnterCountCheck@@YAXPAUPMSG_ANS_BLOODCASTLEENTERCHECK@@@Z ; EGBloodCastleEnterCountCheck
PUBLIC	?EGBloodCastleEnterCountOn@@YAXH@Z		; EGBloodCastleEnterCountOn
PUBLIC	?EGReqBloodCastleEnterCount@@YAXH@Z		; EGReqBloodCastleEnterCount
PUBLIC	?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z ; EGAnsBloodCastleEnterCount
PUBLIC	?EGReqRegCCOfflineGift@@YAXH@Z			; EGReqRegCCOfflineGift
PUBLIC	?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z ; EGAnsRegCCOfflineGift
PUBLIC	?EGReqRegDLOfflineGift@@YAXH@Z			; EGReqRegDLOfflineGift
PUBLIC	?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z ; EGAnsRegDLOfflineGift
PUBLIC	?EventChipEventProtocolCore@@YAXEPAEH@Z		; EventChipEventProtocolCore
PUBLIC	?DataSendEventChip@@YAXPADH@Z			; DataSendEventChip
PUBLIC	?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z ; EGRecvEventChipInfo
PUBLIC	?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z ; EGResultRegEventChip
PUBLIC	?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z ; EGRecvRegMutoNum
PUBLIC	?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ; EGRecvChangeRena
PUBLIC	?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z ; EGRecvStoneInfo
PUBLIC	?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z ; EGRecvRegStone
PUBLIC	?EGRecvDeleteStone@@YAXPAUPMSG_ANS_DELETE_STONES@@@Z ; EGRecvDeleteStone
PUBLIC	?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ; EGRecvChangeStones
PUBLIC	?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z ; EGRecv2AnvRegSerial
PUBLIC	?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z ; EGRecvRegRingGift
PUBLIC	??_C@_0CB@JKOKDAGE@Can?5not?5connect?5EventChip?5Serve@ ; `string'
PUBLIC	??_C@_0EN@LDELBCFF@EleDoradoBox?9?$CFd?5Event?5ItemDrop?5@ ; `string'
PUBLIC	??_C@_0BO@CCIJBOCK@EventChip?5Event?5ItemDrop?5Rena@ ; `string'
PUBLIC	??_C@_0EL@GGABLOBN@EventChip?5Event?5BoxOfGold?5ItemD@ ; `string'
PUBLIC	??_C@_0EH@JBCAMEJ@Medal?5Event?5GoldMedal?5ItemDrop?5@ ; `string'
PUBLIC	??_C@_0EJ@JIIDGOIJ@Medal?5Event?5SilverMedal?5ItemDro@ ; `string'
PUBLIC	??_C@_0ED@CEAEOAKG@FireCracker?5Event?5ItemDrop?5?3?5It@ ; `string'
PUBLIC	??_C@_0DO@CACDLGAI@?$FLRing?5Event?$FN?5ItemDrop?5?3?5Item?3?$CFd@ ; `string'
PUBLIC	??_C@_0EJ@CFBKDBPL@?$FLFriendShip?5Ring?5Event?$FN?5ItemDro@ ; `string'
PUBLIC	??_C@_0EI@PJJCECOB@?$FLDarkLord?5Heart?5Event?$FN?5ItemDrop@ ; `string'
PUBLIC	??_C@_0DH@MGHNDFPH@Event?5ItemDrop?5?3?5Item?3?$CFd?5Level?3@ ; `string'
PUBLIC	??_C@_0DL@KCOPLAHJ@Event?5ItemDrop?$CI53?$CJ?5?3?5Item?3?$CFd?5Le@ ; `string'
PUBLIC	??_C@_0DL@OLPGIACC@Event?5ItemDrop?$CI55?$CJ?5?3?5Item?3?$CFd?5Le@ ; `string'
PUBLIC	??_C@_0CE@JEOJAEAE@?G?$OA?$LP?n?$MA?G?5?$LM?$PN?$MA?Z?$LE?B?5?$CF03d?9?$CF03d?9?$CF03d?5?$MA?T@ ; `string'
PUBLIC	??_C@_0BO@IGEKNHOC@?$LF?n?$LH?O?$LF?H?5?G?$OA?$LP?n?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$LO?x?$LN?$MA?$LE?O?$LE?Y@ ; `string'
PUBLIC	??_C@_0DL@NPJNKEPH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventSe@ ; `string'
PUBLIC	??_C@_0CL@GENGFGNN@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Eve@ ; `string'
PUBLIC	??_C@_0CO@PLMPLCLH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5MutoN@ ; `string'
PUBLIC	??_C@_0CN@HPMMCJJA@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena@ ; `string'
PUBLIC	??_C@_0CF@KMDOMHEE@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena@ ; `string'
PUBLIC	??_C@_0BP@HIMCGJFF@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Stones@ ; `string'
PUBLIC	??_C@_0DD@JDHGBHBI@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventServer@ ; `string'
PUBLIC	??_C@_0CK@KDDNBJOH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Ad@ ; `string'
PUBLIC	??_C@_0CC@FLCEMGDH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Fa@ ; `string'
PUBLIC	??_C@_0DD@NFIPOICF@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Index?5i@ ; `string'
PUBLIC	??_C@_0DI@IMNBMFDN@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Gift?5In@ ; `string'
PUBLIC	??_C@_0DD@BPJEDJME@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Result?5@ ; `string'
PUBLIC	??_C@_0O@HHCDHNEF@Heart?5of?5Love@		; `string'
PUBLIC	??_C@_0M@NFDLLOLF@500?0000?5Zen@		; `string'
PUBLIC	??_C@_0L@DILECEGA@50?0000?5Zen@			; `string'
PUBLIC	??_C@_0L@NAABOOCD@30?0000?5Zen@			; `string'
PUBLIC	??_C@_0DI@MNCKIFPI@?$FLMu_2Anv_Event?$FN?5Error?5?3?5iGiftNu@ ; `string'
PUBLIC	??_C@_0EO@IOBIPNI@?$FLMu_2Anv_Event?$FN?5Register?5Serial@ ; `string'
PUBLIC	??_C@_0BP@LPHCCDAB@?$CFs?$LE?T?5?$LC?$LC?$LM?$KN?5?$CFs?$LP?$KB?5?$LE?g?C?$LH?$LF?G?$LM?L?$LN?$MA?$LE?O?$LE?Y?4@ ; `string'
PUBLIC	??_C@_0DM@EBGDAEID@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@ ; `string'
PUBLIC	??_C@_0EN@JKCGIJEK@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@ ; `string'
PUBLIC	??_C@_0DC@NJLHLHM@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@ ; `string'
PUBLIC	??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@ ; `string'
PUBLIC	??_C@_0ED@MNBMBKBB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success@ ; `string'
PUBLIC	??_C@_0DL@IPBEOKOL@?$FL?$LE?Y?E?$KJ?$LH?N?$LF?e?5?$LB?b?$LD?d?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC?$LM@ ; `string'
PUBLIC	??_C@_0EL@NOBBOLBI@?$FLDarkLord?5Heart?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	__real@437f0000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_rand:PROC
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?gObjFind10EventChip@@YAHH@Z:PROC		; gObjFind10EventChip
EXTRN	?gObjDelete10EventChip@@YAHH@Z:PROC		; gObjDelete10EventChip
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z:PROC ; ChatTargetSend
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?GetType@CItemBag@@QAEEH@Z:PROC			; CItemBag::GetType
EXTRN	?GetIndex@CItemBag@@QAEEH@Z:PROC		; CItemBag::GetIndex
EXTRN	?GetLevel@CItemBag@@QAEEH@Z:PROC		; CItemBag::GetLevel
EXTRN	?GetOp1@CItemBag@@QAEEH@Z:PROC			; CItemBag::GetOp1
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?GMEventChipServerConnect@@YAHPADK@Z:PROC	; GMEventChipServerConnect
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z:PROC	; ItemSerialCreateSend
EXTRN	?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z:PROC ; gObjMonsterTopHitDamageUser
EXTRN	?NewOptionRand@@YAEH@Z:PROC			; NewOptionRand
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?DropItem@CItemBagEx@@QAEHH@Z:PROC		; CItemBagEx::DropItem
EXTRN	?DropKundunEventItem@CItemBagEx@@QAEHHEEE@Z:PROC ; CItemBagEx::DropKundunEventItem
EXTRN	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDeleteQuestItem
EXTRN	?EnterUserBridge@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::EnterUserBridge
EXTRN	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::CheckEnterLevel
EXTRN	?CheckCanEnter@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckCanEnter
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?DevilSquareEventConnect@@3HA:DWORD		; DevilSquareEventConnect
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
EXTRN	?EventChipServerConnect@@3HA:DWORD		; EventChipServerConnect
EXTRN	?IsEventChipServerConnected@@3HA:DWORD		; IsEventChipServerConnected
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?gLanguage@@3HA:DWORD				; gLanguage
EXTRN	?g_ItemDropRateForgFireCracker@@3HA:DWORD	; g_ItemDropRateForgFireCracker
EXTRN	?gOnlyFireCrackerEffectUse@@3HA:DWORD		; gOnlyFireCrackerEffectUse
EXTRN	?g_ItemDropRateForgHeartOfLove@@3HA:DWORD	; g_ItemDropRateForgHeartOfLove
EXTRN	?g_ItemDropRateForGoldMedal@@3HA:DWORD		; g_ItemDropRateForGoldMedal
EXTRN	?g_ItemDropRateForSilverMedal@@3HA:DWORD	; g_ItemDropRateForSilverMedal
EXTRN	?g_ItemDropRateForBoxOfGold@@3HA:DWORD		; g_ItemDropRateForBoxOfGold
EXTRN	?g_EventChipDropRateForBoxOfGold@@3HA:DWORD	; g_EventChipDropRateForBoxOfGold
EXTRN	?g_iDarkLordHeartOffEventRate@@3HA:DWORD	; g_iDarkLordHeartOffEventRate
EXTRN	?gDevilSquareEventServerIp@@3PADA:BYTE		; gDevilSquareEventServerIp
EXTRN	?gEventChipServerIp@@3PADA:BYTE			; gEventChipServerIp
EXTRN	?gEledoradoGoldGoblenItemDropRate@@3HA:DWORD	; gEledoradoGoldGoblenItemDropRate
EXTRN	?gEledoradoTitanItemDropRate@@3HA:DWORD		; gEledoradoTitanItemDropRate
EXTRN	?gEledoradoGoldDerconItemDropRate@@3HA:DWORD	; gEledoradoGoldDerconItemDropRate
EXTRN	?gEledoradoDevilLizardKingItemDropRate@@3HA:DWORD ; gEledoradoDevilLizardKingItemDropRate
EXTRN	?gEledoradoDevilTantarosItemDropRate@@3HA:DWORD	; gEledoradoDevilTantarosItemDropRate
EXTRN	?gEledoradoGoldGoblenExItemDropRate@@3HA:DWORD	; gEledoradoGoldGoblenExItemDropRate
EXTRN	?gEledoradoTitanExItemDropRate@@3HA:DWORD	; gEledoradoTitanExItemDropRate
EXTRN	?gEledoradoGoldDerconExItemDropRate@@3HA:DWORD	; gEledoradoGoldDerconExItemDropRate
EXTRN	?gEledoradoDevilLizardKingExItemDropRate@@3HA:DWORD ; gEledoradoDevilLizardKingExItemDropRate
EXTRN	?gEledoradoDevilTantarosExItemDropRate@@3HA:DWORD ; gEledoradoDevilTantarosExItemDropRate
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?wsEvenChipServerCli@@3VwsJoinServerCli@@A:BYTE	; wsEvenChipServerCli
EXTRN	?LuckboxItemBag@@3PAVCItemBag@@A:DWORD		; LuckboxItemBag
EXTRN	?Mon55@@3PAVCItemBag@@A:DWORD			; Mon55
EXTRN	?Mon53@@3PAVCItemBag@@A:DWORD			; Mon53
EXTRN	?StarOfXMasItemBag@@3PAVCItemBagEx@@A:DWORD	; StarOfXMasItemBag
EXTRN	?FireCrackerItemBag@@3PAVCItemBag@@A:DWORD	; FireCrackerItemBag
EXTRN	?HeartOfLoveItemBag@@3PAVCItemBag@@A:DWORD	; HeartOfLoveItemBag
EXTRN	?GoldMedalItemBag@@3PAVCItemBag@@A:DWORD	; GoldMedalItemBag
EXTRN	?SilverMedalItemBag@@3PAVCItemBag@@A:DWORD	; SilverMedalItemBag
EXTRN	?GoldGoblenItemBag@@3PAVCItemBag@@A:DWORD	; GoldGoblenItemBag
EXTRN	?TitanItemBag@@3PAVCItemBag@@A:DWORD		; TitanItemBag
EXTRN	?GoldDerconItemBag@@3PAVCItemBag@@A:DWORD	; GoldDerconItemBag
EXTRN	?DevilLizardKingItemBag@@3PAVCItemBag@@A:DWORD	; DevilLizardKingItemBag
EXTRN	?KanturItemBag@@3PAVCItemBag@@A:DWORD		; KanturItemBag
EXTRN	?RingEventItemBag@@3PAVCItemBag@@A:DWORD	; RingEventItemBag
EXTRN	?DarkLordHeartItemBag@@3PAVCItemBag@@A:DWORD	; DarkLordHeartItemBag
EXTRN	?KundunEventItemBag@@3PAVCItemBagEx@@A:DWORD	; KundunEventItemBag
EXTRN	?wsRServerCli@@3VwsJoinServerCli@@A:BYTE	; wsRServerCli
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT ??_C@_0EL@NOBBOLBI@?$FLDarkLord?5Heart?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0EL@NOBBOLBI@?$FLDarkLord?5Heart?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'DarkLord Heart Event] [%s][%s] Success to Register OffLine Gi'
	DB	'ft (GIFT:%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@IPBEOKOL@?$FL?$LE?Y?E?$KJ?$LH?N?$LF?e?5?$LB?b?$LD?d?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC?$LM@
CONST	SEGMENT
??_C@_0DL@IPBEOKOL@?$FL?$LE?Y?E?$KJ?$LH?N?$LF?e?5?$LB?b?$LD?d?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC?$LM@ DB '['
	DB	0b4H, 0d9H, 0c5H, 0a9H, 0b7H, 0ceH, 0b5H, 0e5H, ' ', 0b1H, 0e2H
	DB	0b3H, 0e4H, ' ', 0c0H, 0ccH, 0baH, 0a5H, 0c6H, 0aeH, '] %s ', 0b4H
	DB	0d4H, 0b2H, 0b2H, 0bcH, 0adH, ' %s ', 0b0H, 0e6H, 0c7H, 0b0H, 0bfH
	DB	0a1H, ' ', 0b4H, 0e7H, 0c3H, 0b7H, 0b5H, 0c7H, 0bcH, 0ccH, 0bdH
	DB	0c0H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MNBMBKBB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success@
CONST	SEGMENT
??_C@_0ED@MNBMBKBB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success@ DB '['
	DB	'Chaos Castle] [%s][%s] Success to Register OffLine Gift (GIFT'
	DB	':%s)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@
CONST	SEGMENT
??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@ DB 'Can not connec'
	DB	't Ranking Server', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle'
	DB	' (Invisible Cloak Serial:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NJLHLHM@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@
CONST	SEGMENT
??_C@_0DC@NJLHLHM@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@ DB '['
	DB	'Ring Event] [%s][%s] Register Failed Result : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@JKCGIJEK@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@
CONST	SEGMENT
??_C@_0EN@JKCGIJEK@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@ DB '['
	DB	'Ring Event] [%s][%s] Register Failed Result:%d, Gift:%d (out '
	DB	'of bound, 1~4)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EBGDAEID@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@
CONST	SEGMENT
??_C@_0DM@EBGDAEID@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@ DB '['
	DB	'Ring Event] [%s][%s] Register Succeeded Result:%d, Gift:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LPHCCDAB@?$CFs?$LE?T?5?$LC?$LC?$LM?$KN?5?$CFs?$LP?$KB?5?$LE?g?C?$LH?$LF?G?$LM?L?$LN?$MA?$LE?O?$LE?Y?4@
CONST	SEGMENT
??_C@_0BP@LPHCCDAB@?$CFs?$LE?T?5?$LC?$LC?$LM?$KN?5?$CFs?$LP?$KB?5?$LE?g?C?$LH?$LF?G?$LM?L?$LN?$MA?$LE?O?$LE?Y?4@ DB '%'
	DB	's', 0b4H, 0d4H, ' ', 0b2H, 0b2H, 0bcH, 0adH, ' %s', 0bfH, 0a1H
	DB	' ', 0b4H, 0e7H, 0c3H, 0b7H, 0b5H, 0c7H, 0bcH, 0ccH, 0bdH, 0c0H
	DB	0b4H, 0cfH, 0b4H, 0d9H, '.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@IOBIPNI@?$FLMu_2Anv_Event?$FN?5Register?5Serial@
CONST	SEGMENT
??_C@_0EO@IOBIPNI@?$FLMu_2Anv_Event?$FN?5Register?5Serial@ DB '[Mu_2Anv_E'
	DB	'vent] Register Serial Result : %d [%s][%s] GiftNumber: %d Ite'
	DB	'm : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MNCKIFPI@?$FLMu_2Anv_Event?$FN?5Error?5?3?5iGiftNu@
CONST	SEGMENT
??_C@_0DI@MNCKIFPI@?$FLMu_2Anv_Event?$FN?5Error?5?3?5iGiftNu@ DB '[Mu_2An'
	DB	'v_Event] Error : iGiftNumber is Out of Boud [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NAABOOCD@30?0000?5Zen@
CONST	SEGMENT
??_C@_0L@NAABOOCD@30?0000?5Zen@ DB '30,000 Zen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DILECEGA@50?0000?5Zen@
CONST	SEGMENT
??_C@_0L@DILECEGA@50?0000?5Zen@ DB '50,000 Zen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFDLLOLF@500?0000?5Zen@
CONST	SEGMENT
??_C@_0M@NFDLLOLF@500?0000?5Zen@ DB '500,000 Zen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HHCDHNEF@Heart?5of?5Love@
CONST	SEGMENT
??_C@_0O@HHCDHNEF@Heart?5of?5Love@ DB 'Heart of Love', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BPJEDJME@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Result?5@
CONST	SEGMENT
??_C@_0DD@BPJEDJME@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Result?5@ DB '[Mu_2A'
	DB	'nv_Event] Error : Result Value is Wrong [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@IMNBMFDN@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Gift?5In@
CONST	SEGMENT
??_C@_0DI@IMNBMFDN@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Gift?5In@ DB '[Mu_2A'
	DB	'nv_Event] Error : Gift Index is out of bound [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@NFIPOICF@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Index?5i@
CONST	SEGMENT
??_C@_0DD@NFIPOICF@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Index?5i@ DB '[Mu_2A'
	DB	'nv_Event] Error : Index is out of bound [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FLCEMGDH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Fa@
CONST	SEGMENT
??_C@_0CC@FLCEMGDH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Fa@ DB '['
	DB	'Stones] [%s][%s] ChangeRena Fail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KDDNBJOH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Ad@
CONST	SEGMENT
??_C@_0CK@KDDNBJOH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Ad@ DB '['
	DB	'Stones] [%s][%s] ChangeRena AddMoney(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JDHGBHBI@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventServer@
CONST	SEGMENT
??_C@_0DD@JDHGBHBI@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventServer@ DB '['
	DB	'Stone] [%s][%s] RegEventServer Fail (Stones : %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HIMCGJFF@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Stones@
CONST	SEGMENT
??_C@_0BP@HIMCGJFF@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Stones@ DB '['
	DB	'Stone] [%s][%s] Delete Stones', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KMDOMHEE@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena@
CONST	SEGMENT
??_C@_0CF@KMDOMHEE@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena@ DB '['
	DB	'EventChip] [%s][%s] ChangeRena Fail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HPMMCJJA@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena@
CONST	SEGMENT
??_C@_0CN@HPMMCJJA@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena@ DB '['
	DB	'EventChip] [%s][%s] ChangeRena AddMoney(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PLMPLCLH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5MutoN@
CONST	SEGMENT
??_C@_0CO@PLMPLCLH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5MutoN@ DB '['
	DB	'EventChip] [%s][%s] Make MutoNumber %d,%d,%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GENGFGNN@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Eve@
CONST	SEGMENT
??_C@_0CL@GENGFGNN@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Eve@ DB '['
	DB	'EventChip] [%s][%s] Delete EventChip (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NPJNKEPH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventSe@
CONST	SEGMENT
??_C@_0DL@NPJNKEPH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventSe@ DB '['
	DB	'EventChip] [%s][%s] RegEventServer Fail (RegEventchip) %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IGEKNHOC@?$LF?n?$LH?O?$LF?H?5?G?$OA?$LP?n?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$LO?x?$LN?$MA?$LE?O?$LE?Y@
CONST	SEGMENT
??_C@_0BO@IGEKNHOC@?$LF?n?$LH?O?$LF?H?5?G?$OA?$LP?n?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$LO?x?$LN?$MA?$LE?O?$LE?Y@ DB 0b5H
	DB	0eeH, 0b7H, 0cfH, 0b5H, 0c8H, ' ', 0c7H, 0e0H, 0bfH, 0eeH, 0c0H
	DB	0c7H, ' ', 0bcH, 0fdH, 0c0H, 0daH, 0b0H, 0a1H, ' ', 0beH, 0f8H
	DB	0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JEOJAEAE@?G?$OA?$LP?n?$MA?G?5?$LM?$PN?$MA?Z?$LE?B?5?$CF03d?9?$CF03d?9?$CF03d?5?$MA?T@
CONST	SEGMENT
??_C@_0CE@JEOJAEAE@?G?$OA?$LP?n?$MA?G?5?$LM?$PN?$MA?Z?$LE?B?5?$CF03d?9?$CF03d?9?$CF03d?5?$MA?T@ DB 0c7H
	DB	0e0H, 0bfH, 0eeH, 0c0H, 0c7H, ' ', 0bcH, 0fdH, 0c0H, 0daH, 0b4H
	DB	0c2H, ' %03d-%03d-%03d ', 0c0H, 0d4H, 0b4H, 0cfH, 0b4H, 0d9H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OLPGIACC@Event?5ItemDrop?$CI55?$CJ?5?3?5Item?3?$CFd?5Le@
CONST	SEGMENT
??_C@_0DL@OLPGIACC@Event?5ItemDrop?$CI55?$CJ?5?3?5Item?3?$CFd?5Le@ DB 'Ev'
	DB	'ent ItemDrop(55) : Item:%d Level:%d op1:%d op2:%d op3:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KCOPLAHJ@Event?5ItemDrop?$CI53?$CJ?5?3?5Item?3?$CFd?5Le@
CONST	SEGMENT
??_C@_0DL@KCOPLAHJ@Event?5ItemDrop?$CI53?$CJ?5?3?5Item?3?$CFd?5Le@ DB 'Ev'
	DB	'ent ItemDrop(53) : Item:%d Level:%d op1:%d op2:%d op3:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MGHNDFPH@Event?5ItemDrop?5?3?5Item?3?$CFd?5Level?3@
CONST	SEGMENT
??_C@_0DH@MGHNDFPH@Event?5ItemDrop?5?3?5Item?3?$CFd?5Level?3@ DB 'Event I'
	DB	'temDrop : Item:%d Level:%d op1:%d op2:%d op3:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@PJJCECOB@?$FLDarkLord?5Heart?5Event?$FN?5ItemDrop@
CONST	SEGMENT
??_C@_0EI@PJJCECOB@?$FLDarkLord?5Heart?5Event?$FN?5ItemDrop@ DB '[DarkLor'
	DB	'd Heart Event] ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:'
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@CFBKDBPL@?$FLFriendShip?5Ring?5Event?$FN?5ItemDro@
CONST	SEGMENT
??_C@_0EJ@CFBKDBPL@?$FLFriendShip?5Ring?5Event?$FN?5ItemDro@ DB '[FriendS'
	DB	'hip Ring Event] ItemDrop : Item:%d Level:%d op1:%d op2:%d op3'
	DB	':%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@CACDLGAI@?$FLRing?5Event?$FN?5ItemDrop?5?3?5Item?3?$CFd@
CONST	SEGMENT
??_C@_0DO@CACDLGAI@?$FLRing?5Event?$FN?5ItemDrop?5?3?5Item?3?$CFd@ DB '[R'
	DB	'ing Event] ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@CEAEOAKG@FireCracker?5Event?5ItemDrop?5?3?5It@
CONST	SEGMENT
??_C@_0ED@CEAEOAKG@FireCracker?5Event?5ItemDrop?5?3?5It@ DB 'FireCracker '
	DB	'Event ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@JIIDGOIJ@Medal?5Event?5SilverMedal?5ItemDro@
CONST	SEGMENT
??_C@_0EJ@JIIDGOIJ@Medal?5Event?5SilverMedal?5ItemDro@ DB 'Medal Event Si'
	DB	'lverMedal ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JBCAMEJ@Medal?5Event?5GoldMedal?5ItemDrop?5@
CONST	SEGMENT
??_C@_0EH@JBCAMEJ@Medal?5Event?5GoldMedal?5ItemDrop?5@ DB 'Medal Event Go'
	DB	'ldMedal ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@GGABLOBN@EventChip?5Event?5BoxOfGold?5ItemD@
CONST	SEGMENT
??_C@_0EL@GGABLOBN@EventChip?5Event?5BoxOfGold?5ItemD@ DB 'EventChip Even'
	DB	't BoxOfGold ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CCIJBOCK@EventChip?5Event?5ItemDrop?5Rena@
CONST	SEGMENT
??_C@_0BO@CCIJBOCK@EventChip?5Event?5ItemDrop?5Rena@ DB 'EventChip Event '
	DB	'ItemDrop Rena', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@LDELBCFF@EleDoradoBox?9?$CFd?5Event?5ItemDrop?5@
CONST	SEGMENT
??_C@_0EN@LDELBCFF@EleDoradoBox?9?$CFd?5Event?5ItemDrop?5@ DB 'EleDoradoB'
	DB	'ox-%d Event ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d '
	DB	'ex:%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JKOKDAGE@Can?5not?5connect?5EventChip?5Serve@
CONST	SEGMENT
??_C@_0CB@JKOKDAGE@Can?5not?5connect?5EventChip?5Serve@ DB 'Can not conne'
	DB	'ct EventChip Server', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z
_TEXT	SEGMENT
tv92 = -332						; size = 4
tv93 = -328						; size = 4
_szTemp$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z PROC ; EGRecvRegRingGift, COMDAT

; 3593 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3594 : 	gObj[aRecv->iINDEX].UseEventServer = FALSE;

  00016	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00019	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00020	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00026	c7 84 0a 84 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+3716], 0

; 3595 : 
; 3596 : 	if (gObjIsConnected(aRecv->iINDEX) == FALSE)

  00031	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00034	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	75 05		 jne	 SHORT $LN2@EGRecvRegR

; 3597 : 		return;

  00044	e9 28 02 00 00	 jmp	 $LN1@EGRecvRegR
$LN2@EGRecvRegR:

; 3598 : 
; 3599 : 	if (strcmp(aRecv->szUID, gObj[aRecv->iINDEX].AccountID))

  00049	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0004c	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00059	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00061	83 c1 08	 add	 ecx, 8
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _strcmp
  0006a	83 c4 08	 add	 esp, 8
  0006d	85 c0		 test	 eax, eax
  0006f	74 05		 je	 SHORT $LN3@EGRecvRegR

; 3600 : 		return;

  00071	e9 fb 01 00 00	 jmp	 $LN1@EGRecvRegR
$LN3@EGRecvRegR:

; 3601 : 
; 3602 : 	if (aRecv->btIsRegistered == 1) {

  00076	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00079	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  0007d	83 f9 01	 cmp	 ecx, 1
  00080	0f 85 38 01 00
	00		 jne	 $LN4@EGRecvRegR

; 3603 : 		if (CHECK_LIMIT(aRecv->btGiftKind-1, 4)) {

  00086	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00089	0f b6 48 15	 movzx	 ecx, BYTE PTR [eax+21]
  0008d	83 e9 01	 sub	 ecx, 1
  00090	79 0c		 jns	 SHORT $LN11@EGRecvRegR
  00092	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv93[ebp], 0
  0009c	eb 31		 jmp	 SHORT $LN12@EGRecvRegR
$LN11@EGRecvRegR:
  0009e	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  000a1	0f b6 42 15	 movzx	 eax, BYTE PTR [edx+21]
  000a5	83 e8 01	 sub	 eax, 1
  000a8	83 f8 03	 cmp	 eax, 3
  000ab	7e 0c		 jle	 SHORT $LN9@EGRecvRegR
  000ad	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv92[ebp], 0
  000b7	eb 0a		 jmp	 SHORT $LN10@EGRecvRegR
$LN9@EGRecvRegR:
  000b9	c7 85 b4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv92[ebp], 1
$LN10@EGRecvRegR:
  000c3	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv92[ebp]
  000c9	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
$LN12@EGRecvRegR:
  000cf	83 bd b8 fe ff
	ff 00		 cmp	 DWORD PTR tv93[ebp], 0
  000d6	0f 84 96 00 00
	00		 je	 $LN5@EGRecvRegR

; 3604 : 			// 성공적으로 당첨됨
; 3605 : 			CHAR szTemp[256];
; 3606 : 			wsprintf(szTemp, "%s님 께서 %s에 당첨되셨습니다.", gObj[aRecv->iINDEX].Name, g_szRingEventOfflineGift[aRecv->btGiftKind-1]);

  000dc	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000df	0f b6 48 15	 movzx	 ecx, BYTE PTR [eax+21]
  000e3	83 e9 01	 sub	 ecx, 1
  000e6	c1 e1 05	 shl	 ecx, 5
  000e9	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?g_szRingEventOfflineGift@@3QAY0CA@$$CBDA
  000ef	51		 push	 ecx
  000f0	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  000f3	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00100	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00104	52		 push	 edx
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LPHCCDAB@?$CFs?$LE?T?5?$LC?$LC?$LM?$KN?5?$CFs?$LP?$KB?5?$LE?g?C?$LH?$LF?G?$LM?L?$LN?$MA?$LE?O?$LE?Y?4@
  0010a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  00110	50		 push	 eax
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00117	83 c4 10	 add	 esp, 16			; 00000010H

; 3607 : 			AllSendServerMsg (szTemp);

  0011a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00126	83 c4 04	 add	 esp, 4

; 3608 : 
; 3609 : 			LogAddTD("[Ring Event] [%s][%s] Register Succeeded Result:%d, Gift:%d",

  00129	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0012c	0f b6 48 15	 movzx	 ecx, BYTE PTR [eax+21]
  00130	51		 push	 ecx
  00131	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00134	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  00138	50		 push	 eax
  00139	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0013c	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00148	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0014c	51		 push	 ecx
  0014d	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00150	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00157	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015d	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00161	52		 push	 edx
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EBGDAEID@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0016d	83 c4 14	 add	 esp, 20			; 00000014H

; 3610 : 				gObj[aRecv->iINDEX].AccountID,
; 3611 : 				gObj[aRecv->iINDEX].Name,
; 3612 : 				aRecv->btIsRegistered,
; 3613 : 				aRecv->btGiftKind
; 3614 : 				);
; 3615 : 		}

  00170	eb 47		 jmp	 SHORT $LN6@EGRecvRegR
$LN5@EGRecvRegR:

; 3616 : 		else {
; 3617 : 			LogAddTD("[Ring Event] [%s][%s] Register Failed Result:%d, Gift:%d (out of bound, 1~4)",

  00172	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00175	0f b6 48 15	 movzx	 ecx, BYTE PTR [eax+21]
  00179	51		 push	 ecx
  0017a	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0017d	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  00181	50		 push	 eax
  00182	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00185	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  0018c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00191	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00195	51		 push	 ecx
  00196	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00199	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a6	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  001aa	52		 push	 edx
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@JKCGIJEK@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b6	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@EGRecvRegR:

; 3618 : 				gObj[aRecv->iINDEX].AccountID,
; 3619 : 				gObj[aRecv->iINDEX].Name,
; 3620 : 				aRecv->btIsRegistered,
; 3621 : 				aRecv->btGiftKind
; 3622 : 				);
; 3623 : 		}
; 3624 : 		return;

  001b9	e9 b3 00 00 00	 jmp	 $LN1@EGRecvRegR
$LN4@EGRecvRegR:

; 3625 : 	}
; 3626 : 	
; 3627 : #if TESTSERVER == 1
; 3628 : 	else if (aRecv->btIsRegistered == 2) {
; 3629 : 		CHAR szTemp[256];
; 3630 : 		wsprintf(szTemp, "%s님 께서 경품에 이미 당첨되셨습니다.", gObj[aRecv->iINDEX].Name);
; 3631 : 		AllSendServerMsg (szTemp);
; 3632 : 	}
; 3633 : 	else if (aRecv->btIsRegistered == 3) {
; 3634 : 		CHAR szTemp[256];
; 3635 : 		wsprintf(szTemp, "%s님. 경품등록 횟수 초과", gObj[aRecv->iINDEX].Name);
; 3636 : 		AllSendServerMsg (szTemp);
; 3637 : 	}
; 3638 : 	else if (aRecv->btIsRegistered == 0) {
; 3639 : 		CHAR szTemp[256];
; 3640 : 		wsprintf(szTemp, "%s님의 경품등록에 실패하였습니다.", gObj[aRecv->iINDEX].Name);
; 3641 : 		AllSendServerMsg (szTemp);
; 3642 : 	}
; 3643 : #endif // TESTSERVER == 1
; 3644 : 
; 3645 : 	LogAddTD("[Ring Event] [%s][%s] Register Failed Result : %d",

  001be	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001c1	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  001c5	51		 push	 ecx
  001c6	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  001c9	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  001d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d6	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001da	52		 push	 edx
  001db	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001de	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  001e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001eb	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  001ef	50		 push	 eax
  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@NJLHLHM@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5@
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001fb	83 c4 10	 add	 esp, 16			; 00000010H

; 3646 : 		gObj[aRecv->iINDEX].AccountID,
; 3647 : 		gObj[aRecv->iINDEX].Name,
; 3648 : 		aRecv->btIsRegistered
; 3649 : 		);
; 3650 : 
; 3651 : 	// 경품등록 실패 시 돈을 100000젠 떨군다. -> 꽝 대신
; 3652 : 	if( gObjIsConnected(aRecv->iINDEX) == TRUE )

  001fe	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00201	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00204	51		 push	 ecx
  00205	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0020a	83 c4 04	 add	 esp, 4
  0020d	83 f8 01	 cmp	 eax, 1
  00210	75 5f		 jne	 SHORT $LN1@EGRecvRegR

; 3653 : 		MapC[gObj[aRecv->iINDEX].MapNumber].MoneyItemDrop((int)100000, (BYTE) gObj[aRecv->iINDEX].X ,(BYTE) gObj[aRecv->iINDEX].Y);

  00212	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00215	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0021c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00222	0f b6 84 0a 06
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+262]
  0022a	50		 push	 eax
  0022b	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0022e	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00235	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023a	0f b6 8c 10 04
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+260]
  00242	51		 push	 ecx
  00243	68 a0 86 01 00	 push	 100000			; 000186a0H
  00248	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0024b	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00252	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00258	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00260	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00266	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0026c	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN1@EGRecvRegR:

; 3654 : 
; 3655 : }

  00271	5f		 pop	 edi
  00272	5e		 pop	 esi
  00273	5b		 pop	 ebx
  00274	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00277	33 cd		 xor	 ecx, ebp
  00279	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c3		 ret	 0
?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z ENDP ; EGRecvRegRingGift
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z
_TEXT	SEGMENT
tv352 = -164						; size = 4
tv128 = -164						; size = 4
tv71 = -164						; size = 4
tv393 = -160						; size = 4
tv353 = -160						; size = 4
tv129 = -160						; size = 4
tv72 = -160						; size = 4
_ServerCmd$1 = -92					; size = 7
_ServerCmd$2 = -84					; size = 7
_Result$ = -76						; size = 68
_nItemNumber$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z PROC ; EGRecv2AnvRegSerial, COMDAT

; 2845 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2846 : #ifdef ADD_COUPON_EVENTITEM_LOG
; 2847 : 	int nItemNumber = -1;

  00016	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _nItemNumber$[ebp], -1

; 2848 : #endif // ADD_COUPON_EVENTITEM_LOG
; 2849 : 
; 2850 : 	PMSG_ANS_2ANV_LOTTO_EVENT Result;
; 2851 : 	PHeadSetB((LPBYTE)&Result, 0x9D, sizeof(Result));

  0001d	6a 44		 push	 68			; 00000044H
  0001f	68 9d 00 00 00	 push	 157			; 0000009dH
  00024	8d 45 b4	 lea	 eax, DWORD PTR _Result$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2852 : 
; 2853 : 	if(!CHECK_LIMIT(aRecv->iINDEX, MAX_OBJECT)) {

  00030	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00033	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00037	7d 0c		 jge	 SHORT $LN106@EGRecv2Anv
  00039	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
  00043	eb 2e		 jmp	 SHORT $LN107@EGRecv2Anv
$LN106@EGRecv2Anv:
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00048	81 79 04 e7 1c
	00 00		 cmp	 DWORD PTR [ecx+4], 7399	; 00001ce7H
  0004f	7e 0c		 jle	 SHORT $LN104@EGRecv2Anv
  00051	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
  0005b	eb 0a		 jmp	 SHORT $LN105@EGRecv2Anv
$LN104@EGRecv2Anv:
  0005d	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv71[ebp], 1
$LN105@EGRecv2Anv:
  00067	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv71[ebp]
  0006d	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], edx
$LN107@EGRecv2Anv:
  00073	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR tv72[ebp], 0
  0007a	75 1a		 jne	 SHORT $LN4@EGRecv2Anv

; 2854 : 		LogAddTD("[Mu_2Anv_Event] Error : Index is out of bound [%d]",

  0007c	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0007f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00082	51		 push	 ecx
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@NFIPOICF@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Index?5i@
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0008e	83 c4 08	 add	 esp, 8

; 2855 : 			aRecv->iINDEX
; 2856 : 			);
; 2857 : 		return;

  00091	e9 9e 1c 00 00	 jmp	 $LN1@EGRecv2Anv
$LN4@EGRecv2Anv:

; 2858 : 	}
; 2859 : 
; 2860 : 	if (gObj[aRecv->iINDEX].Connected <= 2) {

  00096	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00099	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  000a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a6	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  000ab	7f 1a		 jg	 SHORT $LN5@EGRecv2Anv

; 2861 : 		LogAddTD("[Mu_2Anv_Event] Error : Index is out of bound [%d]",

  000ad	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b3	51		 push	 ecx
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@NFIPOICF@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Index?5i@
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bf	83 c4 08	 add	 esp, 8

; 2862 : 			aRecv->iINDEX
; 2863 : 			);
; 2864 : 		return;

  000c2	e9 6d 1c 00 00	 jmp	 $LN1@EGRecv2Anv
$LN5@EGRecv2Anv:

; 2865 : 	}
; 2866 : 
; 2867 : 	#ifdef MU_CHN_THANKS_RING_EVENT_20040908	// 중국 이벤트 - 시리얼을 넣으면 영예의 반지가 나옴
; 2868 : 	Result.btIsRegistered = aRecv->btIsRegistered;
; 2869 : 	if (aRecv->btIsRegistered == 0) {		// 등록성공
; 2870 : 		// 폭죽을 터뜨린다.
; 2871 : 		if (gObj[aRecv->iINDEX].Connected > 2) {
; 2872 : 			PMSG_SERVERCMD	ServerCmd;
; 2873 : 			PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			
; 2874 : 
; 2875 : 			ServerCmd.CmdType = 0;
; 2876 : 			ServerCmd.X = (BYTE) gObj[aRecv->iINDEX].X;
; 2877 : 			ServerCmd.Y = (BYTE) gObj[aRecv->iINDEX].Y;
; 2878 : 			MsgSendV2(&gObj[aRecv->iINDEX], (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 2879 : 			DataSend(aRecv->iINDEX, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 2880 : 		}
; 2881 : 
; 2882 : 		ItemSerialCreateSend(
; 2883 : 			gObj[aRecv->iINDEX].m_Index, 
; 2884 : 			ITEMMAKE_INVENTORY_1CELL, 
; 2885 : 			(BYTE)gObj[aRecv->iINDEX].X, 
; 2886 : 			(BYTE)gObj[aRecv->iINDEX].Y, 
; 2887 : 			ItemGetNumberMake(13, 20),		// 영예의 반지
; 2888 : 			3, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 2889 : 	}
; 2890 : 
; 2891 : 	LogAddTD("[Mu_2Anv_Event] Register Serial Result : %d [%s][%s]",
; 2892 : 		aRecv->btIsRegistered,
; 2893 : 		gObj[aRecv->iINDEX].AccountID,
; 2894 : 		gObj[aRecv->iINDEX].Name
; 2895 : 		);
; 2896 : 	
; 2897 : 	strcpy (Result.szGIFT_NAME, "Ring of Glory");
; 2898 : 	DataSend(aRecv->iINDEX, (LPBYTE)&Result, Result.h.size);
; 2899 : 	gObj[aRecv->iINDEX].UseEventServer = FALSE;
; 2900 : 	return;
; 2901 : 	#endif // MU_CHN_THANKS_RING_EVENT_20040908
; 2902 : 
; 2903 : 	#if defined(FOR_KOREA) && !defined (COUPON_EVENT_ITEMLIST_20081022)
; 2904 : 	Result.szGIFT_NAME[0] = 0;

  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	6b c8 00	 imul	 ecx, eax, 0
  000cf	c6 44 0d b8 00	 mov	 BYTE PTR _Result$[ebp+ecx+4], 0

; 2905 : 
; 2906 : 	if (aRecv->btIsRegistered == 0) {		// 등록성공

  000d4	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000d7	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  000db	85 c9		 test	 ecx, ecx
  000dd	0f 85 02 04 00
	00		 jne	 $LN6@EGRecv2Anv

; 2907 : 		Result.btIsRegistered = 0;

  000e3	c6 45 b7 00	 mov	 BYTE PTR _Result$[ebp+3], 0

; 2908 : 		if (!CHECK_LIMIT(aRecv->iGiftNumber-1, 17)) {

  000e7	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000ea	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ed	83 e9 01	 sub	 ecx, 1
  000f0	79 0c		 jns	 SHORT $LN110@EGRecv2Anv
  000f2	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv129[ebp], 0
  000fc	eb 30		 jmp	 SHORT $LN111@EGRecv2Anv
$LN110@EGRecv2Anv:
  000fe	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00101	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00104	83 e8 01	 sub	 eax, 1
  00107	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010a	7e 0c		 jle	 SHORT $LN108@EGRecv2Anv
  0010c	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv128[ebp], 0
  00116	eb 0a		 jmp	 SHORT $LN109@EGRecv2Anv
$LN108@EGRecv2Anv:
  00118	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv128[ebp], 1
$LN109@EGRecv2Anv:
  00122	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv128[ebp]
  00128	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
$LN111@EGRecv2Anv:
  0012e	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR tv129[ebp], 0
  00135	75 1b		 jne	 SHORT $LN8@EGRecv2Anv

; 2909 : 			LogAddTD("[Mu_2Anv_Event] Error : Gift Index is out of bound [%d]",

  00137	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0013a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0013d	51		 push	 ecx
  0013e	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@IMNBMFDN@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Gift?5In@
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00149	83 c4 08	 add	 esp, 8

; 2910 : 				aRecv->iGiftNumber
; 2911 : 				);
; 2912 : 			Result.btIsRegistered = 2;

  0014c	c6 45 b7 02	 mov	 BYTE PTR _Result$[ebp+3], 2

; 2913 : 		}

  00150	eb 1f		 jmp	 SHORT $LN9@EGRecv2Anv
$LN8@EGRecv2Anv:

; 2914 : 		else {
; 2915 : 			strcpy (Result.szGIFT_NAME, g_sz2ANV_GIFT_NAME[aRecv->iGiftNumber-1]);

  00152	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00155	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00158	83 e9 01	 sub	 ecx, 1
  0015b	c1 e1 06	 shl	 ecx, 6
  0015e	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?g_sz2ANV_GIFT_NAME@@3QAY0EA@$$CBDA ; g_sz2ANV_GIFT_NAME
  00164	51		 push	 ecx
  00165	8d 55 b8	 lea	 edx, DWORD PTR _Result$[ebp+4]
  00168	52		 push	 edx
  00169	e8 00 00 00 00	 call	 _strcpy
  0016e	83 c4 08	 add	 esp, 8
$LN9@EGRecv2Anv:

; 2916 : 		}
; 2917 : 
; 2918 : 		if ( aRecv->iGiftNumber != 13 &&		// 10만젠

  00171	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00174	83 78 14 0d	 cmp	 DWORD PTR [eax+20], 13	; 0000000dH
  00178	0f 84 a9 00 00
	00		 je	 $LN10@EGRecv2Anv
  0017e	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00181	83 78 14 0e	 cmp	 DWORD PTR [eax+20], 14	; 0000000eH
  00185	0f 84 9c 00 00
	00		 je	 $LN10@EGRecv2Anv

; 2919 : 			 aRecv->iGiftNumber != 14			// 5만젠
; 2920 : 			) 
; 2921 : 		{
; 2922 : 			// 위의 두 경우를 제외한 나머지는 폭죽을 터뜨린다.
; 2923 : 			if (gObj[aRecv->iINDEX].Connected > 2) {

  0018b	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0018e	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00195	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019b	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  001a0	0f 8e 81 00 00
	00		 jle	 $LN10@EGRecv2Anv

; 2924 : 				PMSG_SERVERCMD	ServerCmd;
; 2925 : 				PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  001a6	6a 07		 push	 7
  001a8	6a 40		 push	 64			; 00000040H
  001aa	68 f3 00 00 00	 push	 243			; 000000f3H
  001af	8d 45 ac	 lea	 eax, DWORD PTR _ServerCmd$2[ebp]
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  001b8	83 c4 10	 add	 esp, 16			; 00000010H

; 2926 : 
; 2927 : 				ServerCmd.CmdType = 0;

  001bb	c6 45 b0 00	 mov	 BYTE PTR _ServerCmd$2[ebp+4], 0

; 2928 : 				ServerCmd.X = (BYTE) gObj[aRecv->iINDEX].X;

  001bf	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001c2	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  001c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cf	8a 84 0a 04 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+260]
  001d6	88 45 b1	 mov	 BYTE PTR _ServerCmd$2[ebp+5], al

; 2929 : 				ServerCmd.Y = (BYTE) gObj[aRecv->iINDEX].Y;

  001d9	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  001dc	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  001e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e9	8a 84 0a 06 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+262]
  001f0	88 45 b2	 mov	 BYTE PTR _ServerCmd$2[ebp+6], al

; 2930 : 				MsgSendV2(&gObj[aRecv->iINDEX], (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  001f3	6a 07		 push	 7
  001f5	8d 45 ac	 lea	 eax, DWORD PTR _ServerCmd$2[ebp]
  001f8	50		 push	 eax
  001f9	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  001fc	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00203	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00209	52		 push	 edx
  0020a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0020f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2931 : 				DataSend(aRecv->iINDEX, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00212	6a 07		 push	 7
  00214	8d 45 ac	 lea	 eax, DWORD PTR _ServerCmd$2[ebp]
  00217	50		 push	 eax
  00218	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0021b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0021e	52		 push	 edx
  0021f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@EGRecv2Anv:

; 2932 : 			}
; 2933 : 		}
; 2934 : 
; 2935 : 
; 2936 : 		if ( aRecv->iGiftNumber == 12 ) {		// 50만젠 

  00227	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0022a	83 78 14 0c	 cmp	 DWORD PTR [eax+20], 12	; 0000000cH
  0022e	75 5f		 jne	 SHORT $LN12@EGRecv2Anv

; 2937 : 			gObj[aRecv->iINDEX].Money += 500000;

  00230	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00233	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0023a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00240	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  00247	05 20 a1 07 00	 add	 eax, 500000		; 0007a120H
  0024c	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0024f	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00256	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0025c	89 84 11 b0 00
	00 00		 mov	 DWORD PTR [ecx+edx+176], eax

; 2938 : 			GCMoneySend(aRecv->iINDEX, gObj[aRecv->iINDEX].Money);

  00263	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00266	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0026d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00273	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  0027a	50		 push	 eax
  0027b	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0027e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00287	83 c4 08	 add	 esp, 8

; 2939 : 		}

  0028a	e9 54 02 00 00	 jmp	 $LN13@EGRecv2Anv
$LN12@EGRecv2Anv:

; 2940 : 		else if ( aRecv->iGiftNumber == 13 ) {	// 10만젠 

  0028f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00292	83 78 14 0d	 cmp	 DWORD PTR [eax+20], 13	; 0000000dH
  00296	75 5f		 jne	 SHORT $LN14@EGRecv2Anv

; 2941 : 			gObj[aRecv->iINDEX].Money += 100000;

  00298	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0029b	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  002a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a8	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  002af	05 a0 86 01 00	 add	 eax, 100000		; 000186a0H
  002b4	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  002b7	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  002be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c4	89 84 11 b0 00
	00 00		 mov	 DWORD PTR [ecx+edx+176], eax

; 2942 : 			GCMoneySend(aRecv->iINDEX, gObj[aRecv->iINDEX].Money);

  002cb	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002ce	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  002d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002db	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  002e2	50		 push	 eax
  002e3	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  002e6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002e9	52		 push	 edx
  002ea	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  002ef	83 c4 08	 add	 esp, 8

; 2943 : 		}

  002f2	e9 ec 01 00 00	 jmp	 $LN13@EGRecv2Anv
$LN14@EGRecv2Anv:

; 2944 : 		else if ( aRecv->iGiftNumber == 14 ) {	// 5만젠 

  002f7	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002fa	83 78 14 0e	 cmp	 DWORD PTR [eax+20], 14	; 0000000eH
  002fe	75 5f		 jne	 SHORT $LN16@EGRecv2Anv

; 2945 : 			gObj[aRecv->iINDEX].Money += 50000;

  00300	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00303	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0030a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00310	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  00317	05 50 c3 00 00	 add	 eax, 50000		; 0000c350H
  0031c	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0031f	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00326	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0032c	89 84 11 b0 00
	00 00		 mov	 DWORD PTR [ecx+edx+176], eax

; 2946 : 			GCMoneySend(aRecv->iINDEX, gObj[aRecv->iINDEX].Money);

  00333	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00336	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0033d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00343	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  0034a	50		 push	 eax
  0034b	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0034e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00351	52		 push	 edx
  00352	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00357	83 c4 08	 add	 esp, 8

; 2947 : 		}

  0035a	e9 84 01 00 00	 jmp	 $LN13@EGRecv2Anv
$LN16@EGRecv2Anv:

; 2948 : 		else if (aRecv->iGiftNumber == 9) {		// 축석

  0035f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00362	83 78 14 09	 cmp	 DWORD PTR [eax+20], 9
  00366	75 7b		 jne	 SHORT $LN18@EGRecv2Anv

; 2949 : 			ItemSerialCreateSend(

  00368	6a 00		 push	 0
  0036a	6a 00		 push	 0
  0036c	6a 00		 push	 0
  0036e	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00371	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00374	51		 push	 ecx
  00375	6a 00		 push	 0
  00377	6a 00		 push	 0
  00379	6a 00		 push	 0
  0037b	6a 00		 push	 0
  0037d	6a 00		 push	 0
  0037f	6a 0d		 push	 13			; 0000000dH
  00381	6a 0e		 push	 14			; 0000000eH
  00383	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00388	83 c4 08	 add	 esp, 8
  0038b	50		 push	 eax
  0038c	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0038f	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00396	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0039c	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  003a4	52		 push	 edx
  003a5	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003a8	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  003af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b5	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  003bd	50		 push	 eax
  003be	68 eb 00 00 00	 push	 235			; 000000ebH
  003c3	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  003c6	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  003cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d2	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  003d5	51		 push	 ecx
  003d6	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  003db	83 c4 38	 add	 esp, 56			; 00000038H

; 2950 : 				gObj[aRecv->iINDEX].m_Index, 
; 2951 : 				ITEMMAKE_INVENTORY_1CELL, 
; 2952 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 2953 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 2954 : 				ItemGetNumberMake(14, 13), 
; 2955 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 2956 : 		}

  003de	e9 00 01 00 00	 jmp	 $LN13@EGRecv2Anv
$LN18@EGRecv2Anv:

; 2957 : 		else if (aRecv->iGiftNumber == 10) {	// 영석

  003e3	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003e6	83 78 14 0a	 cmp	 DWORD PTR [eax+20], 10	; 0000000aH
  003ea	75 78		 jne	 SHORT $LN20@EGRecv2Anv

; 2958 : 			ItemSerialCreateSend(

  003ec	6a 00		 push	 0
  003ee	6a 00		 push	 0
  003f0	6a 00		 push	 0
  003f2	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003f5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  003f8	51		 push	 ecx
  003f9	6a 00		 push	 0
  003fb	6a 00		 push	 0
  003fd	6a 00		 push	 0
  003ff	6a 00		 push	 0
  00401	6a 00		 push	 0
  00403	6a 0e		 push	 14			; 0000000eH
  00405	6a 0e		 push	 14			; 0000000eH
  00407	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0040c	83 c4 08	 add	 esp, 8
  0040f	50		 push	 eax
  00410	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00413	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  0041a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00420	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00428	52		 push	 edx
  00429	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0042c	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00433	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00439	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  00441	50		 push	 eax
  00442	68 eb 00 00 00	 push	 235			; 000000ebH
  00447	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0044a	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00451	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00456	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00459	51		 push	 ecx
  0045a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0045f	83 c4 38	 add	 esp, 56			; 00000038H

; 2959 : 				gObj[aRecv->iINDEX].m_Index, 
; 2960 : 				ITEMMAKE_INVENTORY_1CELL, 
; 2961 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 2962 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 2963 : 				ItemGetNumberMake(14, 14), 
; 2964 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 2965 : 		}

  00462	eb 7f		 jmp	 SHORT $LN13@EGRecv2Anv
$LN20@EGRecv2Anv:

; 2966 : 		else if (aRecv->iGiftNumber == 11) {	// 혼석

  00464	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00467	83 78 14 0b	 cmp	 DWORD PTR [eax+20], 11	; 0000000bH
  0046b	75 76		 jne	 SHORT $LN13@EGRecv2Anv

; 2967 : 			ItemSerialCreateSend(

  0046d	6a 00		 push	 0
  0046f	6a 00		 push	 0
  00471	6a 00		 push	 0
  00473	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00476	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00479	51		 push	 ecx
  0047a	6a 00		 push	 0
  0047c	6a 00		 push	 0
  0047e	6a 00		 push	 0
  00480	6a 00		 push	 0
  00482	6a 00		 push	 0
  00484	6a 0f		 push	 15			; 0000000fH
  00486	6a 0c		 push	 12			; 0000000cH
  00488	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0048d	83 c4 08	 add	 esp, 8
  00490	50		 push	 eax
  00491	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00494	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  0049b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004a1	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  004a9	52		 push	 edx
  004aa	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  004ad	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  004b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ba	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  004c2	50		 push	 eax
  004c3	68 eb 00 00 00	 push	 235			; 000000ebH
  004c8	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  004cb	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  004d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004d7	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  004da	51		 push	 ecx
  004db	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  004e0	83 c4 38	 add	 esp, 56			; 00000038H
$LN13@EGRecv2Anv:

; 2968 : 				gObj[aRecv->iINDEX].m_Index, 
; 2969 : 				ITEMMAKE_INVENTORY_1CELL, 
; 2970 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 2971 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 2972 : 				ItemGetNumberMake(12, 15), 
; 2973 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 2974 : 		}
; 2975 : 
; 2976 : 	}

  004e3	eb 61		 jmp	 SHORT $LN7@EGRecv2Anv
$LN6@EGRecv2Anv:

; 2977 : 	else if (
; 2978 : 		aRecv->btIsRegistered == 1 ||	// 이미 등록된 시리얼
; 2979 : 		aRecv->btIsRegistered == 2 ||	// 등록 횟수 초과
; 2980 : 		aRecv->btIsRegistered == 3 ||	// 없는 시리얼
; 2981 : 		aRecv->btIsRegistered == 4 ||	// 알 수 없는 에러

  004e5	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  004e8	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  004ec	83 f9 01	 cmp	 ecx, 1
  004ef	74 30		 je	 SHORT $LN25@EGRecv2Anv
  004f1	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  004f4	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  004f8	83 f9 02	 cmp	 ecx, 2
  004fb	74 24		 je	 SHORT $LN25@EGRecv2Anv
  004fd	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00500	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00504	83 f9 03	 cmp	 ecx, 3
  00507	74 18		 je	 SHORT $LN25@EGRecv2Anv
  00509	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0050c	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00510	83 f9 04	 cmp	 ecx, 4
  00513	74 0c		 je	 SHORT $LN25@EGRecv2Anv
  00515	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00518	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  0051c	83 f9 05	 cmp	 ecx, 5
  0051f	75 0b		 jne	 SHORT $LN23@EGRecv2Anv
$LN25@EGRecv2Anv:

; 2982 : 		aRecv->btIsRegistered == 5		// 나는 전에 시리얼을 등록했었다
; 2983 : 		)
; 2984 : 	{
; 2985 : 		Result.btIsRegistered = aRecv->btIsRegistered;

  00521	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00524	8a 48 13	 mov	 cl, BYTE PTR [eax+19]
  00527	88 4d b7	 mov	 BYTE PTR _Result$[ebp+3], cl

; 2986 : 	}

  0052a	eb 1a		 jmp	 SHORT $LN7@EGRecv2Anv
$LN23@EGRecv2Anv:

; 2987 : 	else {
; 2988 : 		Result.btIsRegistered = 4;

  0052c	c6 45 b7 04	 mov	 BYTE PTR _Result$[ebp+3], 4

; 2989 : 		LogAddTD("[Mu_2Anv_Event] Error : Result Value is Wrong [%d]",

  00530	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00533	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  00537	51		 push	 ecx
  00538	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@BPJEDJME@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Result?5@
  0053d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00543	83 c4 08	 add	 esp, 8
$LN7@EGRecv2Anv:

; 2990 : 			aRecv->btIsRegistered
; 2991 : 			);
; 2992 : 	}
; 2993 : 	#endif // #if defined(FOR_KOREA) && !defined (COUPON_EVENT_ITEMLIST_20081022)
; 2994 : 
; 2995 : 	Result.szGIFT_NAME[0] = 0;

  00546	b8 01 00 00 00	 mov	 eax, 1
  0054b	6b c8 00	 imul	 ecx, eax, 0
  0054e	c6 44 0d b8 00	 mov	 BYTE PTR _Result$[ebp+ecx+4], 0

; 2996 : 
; 2997 : 	if (aRecv->btIsRegistered == 0) {					// 등록성공

  00553	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00556	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  0055a	85 c9		 test	 ecx, ecx
  0055c	0f 85 f4 16 00
	00		 jne	 $LN26@EGRecv2Anv

; 2998 : 		Result.btIsRegistered = 0;

  00562	c6 45 b7 00	 mov	 BYTE PTR _Result$[ebp+3], 0

; 2999 : 		
; 3000 : #if defined(FOR_JAPAN) && defined (COUPON_EVENT_ITEMLIST_20081022)
; 3001 : 		if (!CHECK_LIMIT(aRecv->iGiftNumber-1, MAX_ITEM_OF_COUPON_EVENT)) // 물품번호의 범위 인덱스를 조사
; 3002 : #else
; 3003 : 		if (!CHECK_LIMIT(aRecv->iGiftNumber-1, MAX_ITEM_OF_FRIENDSHIP_EVENT)) // 물품번호의 범위 인덱스를 조사

  00566	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00569	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0056c	83 e9 01	 sub	 ecx, 1
  0056f	79 0c		 jns	 SHORT $LN114@EGRecv2Anv
  00571	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv353[ebp], 0
  0057b	eb 30		 jmp	 SHORT $LN115@EGRecv2Anv
$LN114@EGRecv2Anv:
  0057d	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00580	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00583	83 e8 01	 sub	 eax, 1
  00586	83 f8 10	 cmp	 eax, 16			; 00000010H
  00589	7e 0c		 jle	 SHORT $LN112@EGRecv2Anv
  0058b	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv352[ebp], 0
  00595	eb 0a		 jmp	 SHORT $LN113@EGRecv2Anv
$LN112@EGRecv2Anv:
  00597	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv352[ebp], 1
$LN113@EGRecv2Anv:
  005a1	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv352[ebp]
  005a7	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv353[ebp], ecx
$LN115@EGRecv2Anv:
  005ad	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR tv353[ebp], 0
  005b4	75 19		 jne	 SHORT $LN28@EGRecv2Anv

; 3004 : #endif
; 3005 : 		{	// 물품번호의 범위 인덱스를 조사
; 3006 : 			LogAddTD("[Mu_2Anv_Event] Error : Gift Index is out of bound [%d]",

  005b6	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  005b9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  005bc	51		 push	 ecx
  005bd	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@IMNBMFDN@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Gift?5In@
  005c2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005c8	83 c4 08	 add	 esp, 8

; 3007 : 				aRecv->iGiftNumber
; 3008 : 				);
; 3009 : 			Result.btIsRegistered = 2;

  005cb	c6 45 b7 02	 mov	 BYTE PTR _Result$[ebp+3], 2
$LN28@EGRecv2Anv:

; 3010 : 		}
; 3011 : 
; 3012 : 		// 폭죽을 터뜨린다.
; 3013 : 		if (gObj[aRecv->iINDEX].Connected > 2) {

  005cf	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  005d2	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  005d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005df	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  005e4	0f 8e 81 00 00
	00		 jle	 $LN29@EGRecv2Anv

; 3014 : 			PMSG_SERVERCMD	ServerCmd;
; 3015 : 			PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  005ea	6a 07		 push	 7
  005ec	6a 40		 push	 64			; 00000040H
  005ee	68 f3 00 00 00	 push	 243			; 000000f3H
  005f3	8d 45 a4	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  005f6	50		 push	 eax
  005f7	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  005fc	83 c4 10	 add	 esp, 16			; 00000010H

; 3016 : 
; 3017 : 			ServerCmd.CmdType = 0;

  005ff	c6 45 a8 00	 mov	 BYTE PTR _ServerCmd$1[ebp+4], 0

; 3018 : 			ServerCmd.X = (BYTE) gObj[aRecv->iINDEX].X;

  00603	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00606	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0060d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00613	8a 84 0a 04 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+260]
  0061a	88 45 a9	 mov	 BYTE PTR _ServerCmd$1[ebp+5], al

; 3019 : 			ServerCmd.Y = (BYTE) gObj[aRecv->iINDEX].Y;

  0061d	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00620	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00627	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0062d	8a 84 0a 06 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+262]
  00634	88 45 aa	 mov	 BYTE PTR _ServerCmd$1[ebp+6], al

; 3020 : 			MsgSendV2(&gObj[aRecv->iINDEX], (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00637	6a 07		 push	 7
  00639	8d 45 a4	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  0063c	50		 push	 eax
  0063d	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00640	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00647	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0064d	52		 push	 edx
  0064e	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00653	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3021 : 			DataSend(aRecv->iINDEX, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00656	6a 07		 push	 7
  00658	8d 45 a4	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  0065b	50		 push	 eax
  0065c	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0065f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00662	52		 push	 edx
  00663	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00668	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@EGRecv2Anv:

; 3022 : 		}
; 3023 : 
; 3024 : 		if (g_bRingEventItemTextLoad)

  0066b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00672	74 1f		 je	 SHORT $LN30@EGRecv2Anv

; 3025 : 			strcpy (Result.szGIFT_NAME, g_sz2ANV_GIFT_NAME[aRecv->iGiftNumber - 1]);

  00674	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00677	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0067a	83 e9 01	 sub	 ecx, 1
  0067d	c1 e1 06	 shl	 ecx, 6
  00680	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?g_sz2ANV_GIFT_NAME@@3QAY0EA@$$CBDA ; g_sz2ANV_GIFT_NAME
  00686	51		 push	 ecx
  00687	8d 55 b8	 lea	 edx, DWORD PTR _Result$[ebp+4]
  0068a	52		 push	 edx
  0068b	e8 00 00 00 00	 call	 _strcpy
  00690	83 c4 08	 add	 esp, 8
$LN30@EGRecv2Anv:

; 3026 : // 일본 쿠폰 이벤트 스크립트로 변경(20081022 - grooving)
; 3027 : #ifdef COUPON_EVENT_ITEMLIST_20081022
; 3028 : 		// 아이템 번호 가져온다.
; 3029 : 		BYTE btItemLevel = 0;
; 3030 : 		BYTE btItemDur = 0;
; 3031 : 		int iItemNumber = g_CouponEventItemLIst.GetItemNum(aRecv->iGiftNumber, btItemLevel, btItemDur);
; 3032 : #ifdef ADD_COUPON_EVENTITEM_LOG
; 3033 : 		nItemNumber = iItemNumber;
; 3034 : #endif // ADD_COUPON_EVENTITEM_LOG
; 3035 : 		
; 3036 : 		if( 0 == iItemNumber || -1 == iItemNumber )
; 3037 : 		{
; 3038 : 			LogAddTD("[Mu_2Anv_Event] Error : iGiftNumber is Out of Boud [%d]",
; 3039 : 				aRecv->iGiftNumber
; 3040 : 				);
; 3041 : 		}
; 3042 : 		else
; 3043 : 		{
; 3044 : 			ItemSerialCreateSend(
; 3045 : 				gObj[aRecv->iINDEX].m_Index, 
; 3046 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3047 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3048 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3049 : 				iItemNumber,
; 3050 : 				btItemLevel, btItemDur, 0, 0, 0, aRecv->iINDEX);
; 3051 : 			
; 3052 : 			if (g_bRingEventItemTextLoad == FALSE)
; 3053 : 			{
; 3054 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[iItemNumber].Name);
; 3055 : 			}
; 3056 : 		}
; 3057 : #else // COUPON_EVENT_ITEMLIST_20081022
; 3058 : 
; 3059 : 		switch(aRecv->iGiftNumber) {

  00693	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00696	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00699	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv393[ebp], ecx
  0069f	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv393[ebp]
  006a5	83 ea 01	 sub	 edx, 1
  006a8	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv393[ebp], edx
  006ae	83 bd 60 ff ff
	ff 2b		 cmp	 DWORD PTR tv393[ebp], 43 ; 0000002bH
  006b5	0f 87 84 15 00
	00		 ja	 $LN99@EGRecv2Anv
  006bb	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv393[ebp]
  006c1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN116@EGRecv2Anv[eax*4]
$LN31@EGRecv2Anv:

; 3060 : 		case 1 :		// 축복의보석
; 3061 : 			ItemSerialCreateSend(

  006c8	6a 00		 push	 0
  006ca	6a 00		 push	 0
  006cc	6a 00		 push	 0
  006ce	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  006d1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  006d4	51		 push	 ecx
  006d5	6a 00		 push	 0
  006d7	6a 00		 push	 0
  006d9	6a 00		 push	 0
  006db	6a 00		 push	 0
  006dd	6a 00		 push	 0
  006df	6a 0d		 push	 13			; 0000000dH
  006e1	6a 0e		 push	 14			; 0000000eH
  006e3	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  006e8	83 c4 08	 add	 esp, 8
  006eb	50		 push	 eax
  006ec	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  006ef	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  006f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006fc	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00704	52		 push	 edx
  00705	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00708	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0070f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00715	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  0071d	50		 push	 eax
  0071e	68 eb 00 00 00	 push	 235			; 000000ebH
  00723	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00726	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  0072d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00732	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00735	51		 push	 ecx
  00736	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0073b	83 c4 38	 add	 esp, 56			; 00000038H

; 3062 : 				gObj[aRecv->iINDEX].m_Index, 
; 3063 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3064 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3065 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3066 : 				ItemGetNumberMake(14, 13), 
; 3067 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3068 : 			if (g_bRingEventItemTextLoad == FALSE)

  0073e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00745	75 21		 jne	 SHORT $LN32@EGRecv2Anv

; 3069 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14,13)].Name);

  00747	6a 0d		 push	 13			; 0000000dH
  00749	6a 0e		 push	 14			; 0000000eH
  0074b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00750	83 c4 08	 add	 esp, 8
  00753	6b c0 6c	 imul	 eax, eax, 108
  00756	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0075b	50		 push	 eax
  0075c	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  0075f	51		 push	 ecx
  00760	e8 00 00 00 00	 call	 _strcpy
  00765	83 c4 08	 add	 esp, 8
$LN32@EGRecv2Anv:

; 3070 : 			break;

  00768	e9 e7 14 00 00	 jmp	 $LN2@EGRecv2Anv
$LN33@EGRecv2Anv:

; 3071 : 		case 2 :		// 영혼의보석
; 3072 : 			ItemSerialCreateSend(

  0076d	6a 00		 push	 0
  0076f	6a 00		 push	 0
  00771	6a 00		 push	 0
  00773	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00776	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00779	51		 push	 ecx
  0077a	6a 00		 push	 0
  0077c	6a 00		 push	 0
  0077e	6a 00		 push	 0
  00780	6a 00		 push	 0
  00782	6a 00		 push	 0
  00784	6a 0e		 push	 14			; 0000000eH
  00786	6a 0e		 push	 14			; 0000000eH
  00788	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0078d	83 c4 08	 add	 esp, 8
  00790	50		 push	 eax
  00791	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00794	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  0079b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007a1	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  007a9	52		 push	 edx
  007aa	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  007ad	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  007b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007ba	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  007c2	50		 push	 eax
  007c3	68 eb 00 00 00	 push	 235			; 000000ebH
  007c8	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  007cb	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  007d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007d7	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  007da	51		 push	 ecx
  007db	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  007e0	83 c4 38	 add	 esp, 56			; 00000038H

; 3073 : 				gObj[aRecv->iINDEX].m_Index, 
; 3074 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3075 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3076 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3077 : 				ItemGetNumberMake(14, 14), 
; 3078 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3079 : 			if (g_bRingEventItemTextLoad == FALSE)

  007e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  007ea	75 21		 jne	 SHORT $LN34@EGRecv2Anv

; 3080 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 14)].Name);

  007ec	6a 0e		 push	 14			; 0000000eH
  007ee	6a 0e		 push	 14			; 0000000eH
  007f0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  007f5	83 c4 08	 add	 esp, 8
  007f8	6b c0 6c	 imul	 eax, eax, 108
  007fb	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00800	50		 push	 eax
  00801	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  00804	51		 push	 ecx
  00805	e8 00 00 00 00	 call	 _strcpy
  0080a	83 c4 08	 add	 esp, 8
$LN34@EGRecv2Anv:

; 3081 : 			break;

  0080d	e9 42 14 00 00	 jmp	 $LN2@EGRecv2Anv
$LN35@EGRecv2Anv:

; 3082 : 		case 3 :		// 혼돈의보석
; 3083 : 			ItemSerialCreateSend(

  00812	6a 00		 push	 0
  00814	6a 00		 push	 0
  00816	6a 00		 push	 0
  00818	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0081b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0081e	51		 push	 ecx
  0081f	6a 00		 push	 0
  00821	6a 00		 push	 0
  00823	6a 00		 push	 0
  00825	6a 00		 push	 0
  00827	6a 00		 push	 0
  00829	6a 0f		 push	 15			; 0000000fH
  0082b	6a 0c		 push	 12			; 0000000cH
  0082d	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00832	83 c4 08	 add	 esp, 8
  00835	50		 push	 eax
  00836	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00839	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00840	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00846	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  0084e	52		 push	 edx
  0084f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00852	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00859	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0085f	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  00867	50		 push	 eax
  00868	68 eb 00 00 00	 push	 235			; 000000ebH
  0086d	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00870	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00877	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0087c	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0087f	51		 push	 ecx
  00880	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00885	83 c4 38	 add	 esp, 56			; 00000038H

; 3084 : 				gObj[aRecv->iINDEX].m_Index, 
; 3085 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3086 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3087 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3088 : 				ItemGetNumberMake(12, 15), 
; 3089 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3090 : 			if (g_bRingEventItemTextLoad == FALSE)

  00888	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0088f	75 21		 jne	 SHORT $LN36@EGRecv2Anv

; 3091 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(12, 15)].Name);

  00891	6a 0f		 push	 15			; 0000000fH
  00893	6a 0c		 push	 12			; 0000000cH
  00895	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0089a	83 c4 08	 add	 esp, 8
  0089d	6b c0 6c	 imul	 eax, eax, 108
  008a0	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  008a5	50		 push	 eax
  008a6	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  008a9	51		 push	 ecx
  008aa	e8 00 00 00 00	 call	 _strcpy
  008af	83 c4 08	 add	 esp, 8
$LN36@EGRecv2Anv:

; 3092 : 			break;

  008b2	e9 9d 13 00 00	 jmp	 $LN2@EGRecv2Anv
$LN37@EGRecv2Anv:

; 3093 : 		case 4 :		// 행운의상자
; 3094 : 			ItemSerialCreateSend(

  008b7	6a 00		 push	 0
  008b9	6a 00		 push	 0
  008bb	6a 00		 push	 0
  008bd	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  008c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  008c3	51		 push	 ecx
  008c4	6a 00		 push	 0
  008c6	6a 00		 push	 0
  008c8	6a 00		 push	 0
  008ca	6a 00		 push	 0
  008cc	6a 00		 push	 0
  008ce	6a 0b		 push	 11			; 0000000bH
  008d0	6a 0e		 push	 14			; 0000000eH
  008d2	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  008d7	83 c4 08	 add	 esp, 8
  008da	50		 push	 eax
  008db	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  008de	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  008e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008eb	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  008f3	52		 push	 edx
  008f4	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  008f7	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  008fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00904	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  0090c	50		 push	 eax
  0090d	68 eb 00 00 00	 push	 235			; 000000ebH
  00912	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00915	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  0091c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00921	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00924	51		 push	 ecx
  00925	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0092a	83 c4 38	 add	 esp, 56			; 00000038H

; 3095 : 				gObj[aRecv->iINDEX].m_Index, 
; 3096 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3097 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3098 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3099 : 				ItemGetNumberMake(14, 11), 
; 3100 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3101 : 			if (g_bRingEventItemTextLoad == FALSE)

  0092d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00934	75 21		 jne	 SHORT $LN38@EGRecv2Anv

; 3102 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 11)].Name);

  00936	6a 0b		 push	 11			; 0000000bH
  00938	6a 0e		 push	 14			; 0000000eH
  0093a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0093f	83 c4 08	 add	 esp, 8
  00942	6b c0 6c	 imul	 eax, eax, 108
  00945	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0094a	50		 push	 eax
  0094b	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  0094e	51		 push	 ecx
  0094f	e8 00 00 00 00	 call	 _strcpy
  00954	83 c4 08	 add	 esp, 8
$LN38@EGRecv2Anv:

; 3103 : 			break;

  00957	e9 f8 12 00 00	 jmp	 $LN2@EGRecv2Anv
$LN39@EGRecv2Anv:

; 3104 : 		case 5 :		// 사랑의하트
; 3105 : 			ItemSerialCreateSend(

  0095c	6a 00		 push	 0
  0095e	6a 00		 push	 0
  00960	6a 00		 push	 0
  00962	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00965	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00968	51		 push	 ecx
  00969	6a 00		 push	 0
  0096b	6a 00		 push	 0
  0096d	6a 00		 push	 0
  0096f	6a 00		 push	 0
  00971	6a 03		 push	 3
  00973	6a 0b		 push	 11			; 0000000bH
  00975	6a 0e		 push	 14			; 0000000eH
  00977	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0097c	83 c4 08	 add	 esp, 8
  0097f	50		 push	 eax
  00980	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00983	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  0098a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00990	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00998	52		 push	 edx
  00999	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0099c	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  009a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009a9	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  009b1	50		 push	 eax
  009b2	68 eb 00 00 00	 push	 235			; 000000ebH
  009b7	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  009ba	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  009c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009c6	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  009c9	51		 push	 ecx
  009ca	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  009cf	83 c4 38	 add	 esp, 56			; 00000038H

; 3106 : 				gObj[aRecv->iINDEX].m_Index, 
; 3107 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3108 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3109 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3110 : 				ItemGetNumberMake(14, 11), 
; 3111 : 				3, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3112 : 			if (g_bRingEventItemTextLoad == FALSE)

  009d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  009d9	75 11		 jne	 SHORT $LN40@EGRecv2Anv

; 3113 : 				strcpy (Result.szGIFT_NAME, "Heart of Love");

  009db	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HHCDHNEF@Heart?5of?5Love@
  009e0	8d 45 b8	 lea	 eax, DWORD PTR _Result$[ebp+4]
  009e3	50		 push	 eax
  009e4	e8 00 00 00 00	 call	 _strcpy
  009e9	83 c4 08	 add	 esp, 8
$LN40@EGRecv2Anv:

; 3114 : 			break;

  009ec	e9 63 12 00 00	 jmp	 $LN2@EGRecv2Anv
$LN41@EGRecv2Anv:

; 3115 : 		case 6 :		// 50만젠
; 3116 : 			gObj[aRecv->iINDEX].Money += 500000;

  009f1	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  009f4	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  009fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a01	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  00a08	05 20 a1 07 00	 add	 eax, 500000		; 0007a120H
  00a0d	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a10	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00a17	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a1d	89 84 11 b0 00
	00 00		 mov	 DWORD PTR [ecx+edx+176], eax

; 3117 : 			GCMoneySend(aRecv->iINDEX, gObj[aRecv->iINDEX].Money);

  00a24	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00a27	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00a2e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a34	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  00a3b	50		 push	 eax
  00a3c	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a3f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00a42	52		 push	 edx
  00a43	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00a48	83 c4 08	 add	 esp, 8

; 3118 : 			if (g_bRingEventItemTextLoad == FALSE)

  00a4b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00a52	75 11		 jne	 SHORT $LN42@EGRecv2Anv

; 3119 : 				strcpy (Result.szGIFT_NAME, "500,000 Zen");

  00a54	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NFDLLOLF@500?0000?5Zen@
  00a59	8d 45 b8	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00a5c	50		 push	 eax
  00a5d	e8 00 00 00 00	 call	 _strcpy
  00a62	83 c4 08	 add	 esp, 8
$LN42@EGRecv2Anv:

; 3120 : 			break;

  00a65	e9 ea 11 00 00	 jmp	 $LN2@EGRecv2Anv
$LN43@EGRecv2Anv:

; 3121 : 		case 7 :		// 5만젠
; 3122 : 			gObj[aRecv->iINDEX].Money += 50000;

  00a6a	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00a6d	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00a74	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a7a	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  00a81	05 50 c3 00 00	 add	 eax, 50000		; 0000c350H
  00a86	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00a89	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00a90	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a96	89 84 11 b0 00
	00 00		 mov	 DWORD PTR [ecx+edx+176], eax

; 3123 : 			GCMoneySend(aRecv->iINDEX, gObj[aRecv->iINDEX].Money);

  00a9d	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00aa0	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00aa7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00aad	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  00ab4	50		 push	 eax
  00ab5	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00ab8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00abb	52		 push	 edx
  00abc	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00ac1	83 c4 08	 add	 esp, 8

; 3124 : 			if (g_bRingEventItemTextLoad == FALSE)

  00ac4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00acb	75 11		 jne	 SHORT $LN44@EGRecv2Anv

; 3125 : 				strcpy (Result.szGIFT_NAME, "50,000 Zen");

  00acd	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DILECEGA@50?0000?5Zen@
  00ad2	8d 45 b8	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00ad5	50		 push	 eax
  00ad6	e8 00 00 00 00	 call	 _strcpy
  00adb	83 c4 08	 add	 esp, 8
$LN44@EGRecv2Anv:

; 3126 : 			break;

  00ade	e9 71 11 00 00	 jmp	 $LN2@EGRecv2Anv
$LN45@EGRecv2Anv:

; 3127 : 		case 8 :		// 3만젠
; 3128 : 		case 9 :		// 3만젠
; 3129 : 		case 10 :		// 3만젠
; 3130 : 			gObj[aRecv->iINDEX].Money += 30000;

  00ae3	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00ae6	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00aed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00af3	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  00afa	05 30 75 00 00	 add	 eax, 30000		; 00007530H
  00aff	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00b02	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00b09	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b0f	89 84 11 b0 00
	00 00		 mov	 DWORD PTR [ecx+edx+176], eax

; 3131 : 			GCMoneySend(aRecv->iINDEX, gObj[aRecv->iINDEX].Money);

  00b16	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00b19	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00b20	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b26	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  00b2d	50		 push	 eax
  00b2e	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00b31	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00b34	52		 push	 edx
  00b35	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00b3a	83 c4 08	 add	 esp, 8

; 3132 : 			if (g_bRingEventItemTextLoad == FALSE)

  00b3d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00b44	75 11		 jne	 SHORT $LN46@EGRecv2Anv

; 3133 : 				strcpy (Result.szGIFT_NAME, "30,000 Zen");

  00b46	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NAABOOCD@30?0000?5Zen@
  00b4b	8d 45 b8	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00b4e	50		 push	 eax
  00b4f	e8 00 00 00 00	 call	 _strcpy
  00b54	83 c4 08	 add	 esp, 8
$LN46@EGRecv2Anv:

; 3134 : 			break;

  00b57	e9 f8 10 00 00	 jmp	 $LN2@EGRecv2Anv
$LN47@EGRecv2Anv:

; 3135 : 		case 11 :		// 블로우 구슬
; 3136 : 			ItemSerialCreateSend(

  00b5c	6a 00		 push	 0
  00b5e	6a 00		 push	 0
  00b60	6a 00		 push	 0
  00b62	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00b65	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00b68	51		 push	 ecx
  00b69	6a 00		 push	 0
  00b6b	6a 00		 push	 0
  00b6d	6a 00		 push	 0
  00b6f	6a 00		 push	 0
  00b71	6a 00		 push	 0
  00b73	6a 13		 push	 19			; 00000013H
  00b75	6a 0c		 push	 12			; 0000000cH
  00b77	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00b7c	83 c4 08	 add	 esp, 8
  00b7f	50		 push	 eax
  00b80	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00b83	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00b8a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b90	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00b98	52		 push	 edx
  00b99	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00b9c	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00ba3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ba9	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  00bb1	50		 push	 eax
  00bb2	68 eb 00 00 00	 push	 235			; 000000ebH
  00bb7	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00bba	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00bc1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bc6	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00bc9	51		 push	 ecx
  00bca	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00bcf	83 c4 38	 add	 esp, 56			; 00000038H

; 3137 : 				gObj[aRecv->iINDEX].m_Index, 
; 3138 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3139 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3140 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3141 : 				ItemGetNumberMake(12, 19), 
; 3142 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3143 : 			if (g_bRingEventItemTextLoad == FALSE)

  00bd2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00bd9	75 21		 jne	 SHORT $LN48@EGRecv2Anv

; 3144 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(12, 11)].Name);

  00bdb	6a 0b		 push	 11			; 0000000bH
  00bdd	6a 0c		 push	 12			; 0000000cH
  00bdf	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00be4	83 c4 08	 add	 esp, 8
  00be7	6b c0 6c	 imul	 eax, eax, 108
  00bea	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00bef	50		 push	 eax
  00bf0	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  00bf3	51		 push	 ecx
  00bf4	e8 00 00 00 00	 call	 _strcpy
  00bf9	83 c4 08	 add	 esp, 8
$LN48@EGRecv2Anv:

; 3145 : 			break;

  00bfc	e9 53 10 00 00	 jmp	 $LN2@EGRecv2Anv
$LN49@EGRecv2Anv:

; 3146 : 		case 12 :		// 아이스애로우 구슬
; 3147 : 			ItemSerialCreateSend(

  00c01	6a 00		 push	 0
  00c03	6a 00		 push	 0
  00c05	6a 00		 push	 0
  00c07	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00c0a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00c0d	51		 push	 ecx
  00c0e	6a 00		 push	 0
  00c10	6a 00		 push	 0
  00c12	6a 00		 push	 0
  00c14	6a 00		 push	 0
  00c16	6a 00		 push	 0
  00c18	6a 12		 push	 18			; 00000012H
  00c1a	6a 0c		 push	 12			; 0000000cH
  00c1c	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00c21	83 c4 08	 add	 esp, 8
  00c24	50		 push	 eax
  00c25	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00c28	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00c2f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c35	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00c3d	52		 push	 edx
  00c3e	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00c41	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00c48	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c4e	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  00c56	50		 push	 eax
  00c57	68 eb 00 00 00	 push	 235			; 000000ebH
  00c5c	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00c5f	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00c66	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c6b	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00c6e	51		 push	 ecx
  00c6f	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00c74	83 c4 38	 add	 esp, 56			; 00000038H

; 3148 : 				gObj[aRecv->iINDEX].m_Index, 
; 3149 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3150 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3151 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3152 : 				ItemGetNumberMake(12, 18), 
; 3153 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3154 : 			if (g_bRingEventItemTextLoad == FALSE)

  00c77	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00c7e	75 21		 jne	 SHORT $LN50@EGRecv2Anv

; 3155 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(12, 18)].Name);

  00c80	6a 12		 push	 18			; 00000012H
  00c82	6a 0c		 push	 12			; 0000000cH
  00c84	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00c89	83 c4 08	 add	 esp, 8
  00c8c	6b c0 6c	 imul	 eax, eax, 108
  00c8f	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00c94	50		 push	 eax
  00c95	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  00c98	51		 push	 ecx
  00c99	e8 00 00 00 00	 call	 _strcpy
  00c9e	83 c4 08	 add	 esp, 8
$LN50@EGRecv2Anv:

; 3156 : 			break;

  00ca1	e9 ae 0f 00 00	 jmp	 $LN2@EGRecv2Anv
$LN51@EGRecv2Anv:

; 3157 : 		case 13 :		// 관통구슬
; 3158 : 			ItemSerialCreateSend(

  00ca6	6a 00		 push	 0
  00ca8	6a 00		 push	 0
  00caa	6a 00		 push	 0
  00cac	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00caf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00cb2	51		 push	 ecx
  00cb3	6a 00		 push	 0
  00cb5	6a 00		 push	 0
  00cb7	6a 00		 push	 0
  00cb9	6a 00		 push	 0
  00cbb	6a 00		 push	 0
  00cbd	6a 11		 push	 17			; 00000011H
  00cbf	6a 0c		 push	 12			; 0000000cH
  00cc1	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00cc6	83 c4 08	 add	 esp, 8
  00cc9	50		 push	 eax
  00cca	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00ccd	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00cd4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00cda	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00ce2	52		 push	 edx
  00ce3	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00ce6	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00ced	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00cf3	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  00cfb	50		 push	 eax
  00cfc	68 eb 00 00 00	 push	 235			; 000000ebH
  00d01	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00d04	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00d0b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d10	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00d13	51		 push	 ecx
  00d14	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00d19	83 c4 38	 add	 esp, 56			; 00000038H

; 3159 : 				gObj[aRecv->iINDEX].m_Index, 
; 3160 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3161 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3162 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3163 : 				ItemGetNumberMake(12, 17), 
; 3164 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3165 : 			if (g_bRingEventItemTextLoad == FALSE)

  00d1c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00d23	75 21		 jne	 SHORT $LN52@EGRecv2Anv

; 3166 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(12, 17)].Name);

  00d25	6a 11		 push	 17			; 00000011H
  00d27	6a 0c		 push	 12			; 0000000cH
  00d29	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00d2e	83 c4 08	 add	 esp, 8
  00d31	6b c0 6c	 imul	 eax, eax, 108
  00d34	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00d39	50		 push	 eax
  00d3a	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  00d3d	51		 push	 ecx
  00d3e	e8 00 00 00 00	 call	 _strcpy
  00d43	83 c4 08	 add	 esp, 8
$LN52@EGRecv2Anv:

; 3167 : 			break;

  00d46	e9 09 0f 00 00	 jmp	 $LN2@EGRecv2Anv
$LN53@EGRecv2Anv:

; 3168 : 		case 14 :		// 블러드 어택구슬
; 3169 : 			ItemSerialCreateSend(

  00d4b	6a 00		 push	 0
  00d4d	6a 00		 push	 0
  00d4f	6a 00		 push	 0
  00d51	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00d54	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00d57	51		 push	 ecx
  00d58	6a 00		 push	 0
  00d5a	6a 00		 push	 0
  00d5c	6a 00		 push	 0
  00d5e	6a 00		 push	 0
  00d60	6a 00		 push	 0
  00d62	6a 10		 push	 16			; 00000010H
  00d64	6a 0c		 push	 12			; 0000000cH
  00d66	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00d6b	83 c4 08	 add	 esp, 8
  00d6e	50		 push	 eax
  00d6f	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00d72	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00d79	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d7f	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00d87	52		 push	 edx
  00d88	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00d8b	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00d92	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d98	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  00da0	50		 push	 eax
  00da1	68 eb 00 00 00	 push	 235			; 000000ebH
  00da6	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00da9	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00db0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00db5	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00db8	51		 push	 ecx
  00db9	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00dbe	83 c4 38	 add	 esp, 56			; 00000038H

; 3170 : 				gObj[aRecv->iINDEX].m_Index, 
; 3171 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3172 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3173 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3174 : 				ItemGetNumberMake(12, 16), 
; 3175 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3176 : 			if (g_bRingEventItemTextLoad == FALSE)

  00dc1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00dc8	75 21		 jne	 SHORT $LN54@EGRecv2Anv

; 3177 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(12, 16)].Name);

  00dca	6a 10		 push	 16			; 00000010H
  00dcc	6a 0c		 push	 12			; 0000000cH
  00dce	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00dd3	83 c4 08	 add	 esp, 8
  00dd6	6b c0 6c	 imul	 eax, eax, 108
  00dd9	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00dde	50		 push	 eax
  00ddf	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  00de2	51		 push	 ecx
  00de3	e8 00 00 00 00	 call	 _strcpy
  00de8	83 c4 08	 add	 esp, 8
$LN54@EGRecv2Anv:

; 3178 : 			break;

  00deb	e9 64 0e 00 00	 jmp	 $LN2@EGRecv2Anv
$LN55@EGRecv2Anv:

; 3179 : 		case 15 :		// 스웰라이프 구슬
; 3180 : 			ItemSerialCreateSend(

  00df0	6a 00		 push	 0
  00df2	6a 00		 push	 0
  00df4	6a 00		 push	 0
  00df6	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00df9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00dfc	51		 push	 ecx
  00dfd	6a 00		 push	 0
  00dff	6a 00		 push	 0
  00e01	6a 00		 push	 0
  00e03	6a 00		 push	 0
  00e05	6a 00		 push	 0
  00e07	6a 0e		 push	 14			; 0000000eH
  00e09	6a 0c		 push	 12			; 0000000cH
  00e0b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00e10	83 c4 08	 add	 esp, 8
  00e13	50		 push	 eax
  00e14	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00e17	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00e1e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e24	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00e2c	52		 push	 edx
  00e2d	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00e30	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00e37	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e3d	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  00e45	50		 push	 eax
  00e46	68 eb 00 00 00	 push	 235			; 000000ebH
  00e4b	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00e4e	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00e55	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e5a	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00e5d	51		 push	 ecx
  00e5e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00e63	83 c4 38	 add	 esp, 56			; 00000038H

; 3181 : 				gObj[aRecv->iINDEX].m_Index, 
; 3182 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3183 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3184 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3185 : 				ItemGetNumberMake(12, 14), 
; 3186 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3187 : 			if (g_bRingEventItemTextLoad == FALSE)

  00e66	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00e6d	75 21		 jne	 SHORT $LN56@EGRecv2Anv

; 3188 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(12, 14)].Name);

  00e6f	6a 0e		 push	 14			; 0000000eH
  00e71	6a 0c		 push	 12			; 0000000cH
  00e73	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00e78	83 c4 08	 add	 esp, 8
  00e7b	6b c0 6c	 imul	 eax, eax, 108
  00e7e	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00e83	50		 push	 eax
  00e84	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  00e87	51		 push	 ecx
  00e88	e8 00 00 00 00	 call	 _strcpy
  00e8d	83 c4 08	 add	 esp, 8
$LN56@EGRecv2Anv:

; 3189 : 			break;

  00e90	e9 bf 0d 00 00	 jmp	 $LN2@EGRecv2Anv
$LN57@EGRecv2Anv:

; 3190 : 		case 16 :		// 창 찌르기 구슬
; 3191 : 			ItemSerialCreateSend(

  00e95	6a 00		 push	 0
  00e97	6a 00		 push	 0
  00e99	6a 00		 push	 0
  00e9b	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00e9e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00ea1	51		 push	 ecx
  00ea2	6a 00		 push	 0
  00ea4	6a 00		 push	 0
  00ea6	6a 00		 push	 0
  00ea8	6a 00		 push	 0
  00eaa	6a 00		 push	 0
  00eac	6a 0d		 push	 13			; 0000000dH
  00eae	6a 0c		 push	 12			; 0000000cH
  00eb0	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00eb5	83 c4 08	 add	 esp, 8
  00eb8	50		 push	 eax
  00eb9	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00ebc	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00ec3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ec9	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00ed1	52		 push	 edx
  00ed2	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00ed5	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00edc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ee2	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  00eea	50		 push	 eax
  00eeb	68 eb 00 00 00	 push	 235			; 000000ebH
  00ef0	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00ef3	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00efa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00eff	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00f02	51		 push	 ecx
  00f03	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00f08	83 c4 38	 add	 esp, 56			; 00000038H

; 3192 : 				gObj[aRecv->iINDEX].m_Index, 
; 3193 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3194 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3195 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3196 : 				ItemGetNumberMake(12, 13), 
; 3197 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3198 : 			if (g_bRingEventItemTextLoad == FALSE)

  00f0b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00f12	75 21		 jne	 SHORT $LN58@EGRecv2Anv

; 3199 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(12, 13)].Name);

  00f14	6a 0d		 push	 13			; 0000000dH
  00f16	6a 0c		 push	 12			; 0000000cH
  00f18	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00f1d	83 c4 08	 add	 esp, 8
  00f20	6b c0 6c	 imul	 eax, eax, 108
  00f23	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00f28	50		 push	 eax
  00f29	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  00f2c	51		 push	 ecx
  00f2d	e8 00 00 00 00	 call	 _strcpy
  00f32	83 c4 08	 add	 esp, 8
$LN58@EGRecv2Anv:

; 3200 : 			break;

  00f35	e9 1a 0d 00 00	 jmp	 $LN2@EGRecv2Anv
$LN59@EGRecv2Anv:

; 3201 : 		case 17 :		// 분노의일격 구슬
; 3202 : 			ItemSerialCreateSend(

  00f3a	6a 00		 push	 0
  00f3c	6a 00		 push	 0
  00f3e	6a 00		 push	 0
  00f40	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00f43	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f46	51		 push	 ecx
  00f47	6a 00		 push	 0
  00f49	6a 00		 push	 0
  00f4b	6a 00		 push	 0
  00f4d	6a 00		 push	 0
  00f4f	6a 00		 push	 0
  00f51	6a 0c		 push	 12			; 0000000cH
  00f53	6a 0c		 push	 12			; 0000000cH
  00f55	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00f5a	83 c4 08	 add	 esp, 8
  00f5d	50		 push	 eax
  00f5e	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00f61	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  00f68	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f6e	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00f76	52		 push	 edx
  00f77	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00f7a	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00f81	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f87	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  00f8f	50		 push	 eax
  00f90	68 eb 00 00 00	 push	 235			; 000000ebH
  00f95	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00f98	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  00f9f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00fa4	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00fa7	51		 push	 ecx
  00fa8	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00fad	83 c4 38	 add	 esp, 56			; 00000038H

; 3203 : 				gObj[aRecv->iINDEX].m_Index, 
; 3204 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3205 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3206 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3207 : 				ItemGetNumberMake(12, 12), 
; 3208 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3209 : 			if (g_bRingEventItemTextLoad == FALSE)

  00fb0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00fb7	75 21		 jne	 SHORT $LN60@EGRecv2Anv

; 3210 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(12, 12)].Name);

  00fb9	6a 0c		 push	 12			; 0000000cH
  00fbb	6a 0c		 push	 12			; 0000000cH
  00fbd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00fc2	83 c4 08	 add	 esp, 8
  00fc5	6b c0 6c	 imul	 eax, eax, 108
  00fc8	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00fcd	50		 push	 eax
  00fce	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  00fd1	51		 push	 ecx
  00fd2	e8 00 00 00 00	 call	 _strcpy
  00fd7	83 c4 08	 add	 esp, 8
$LN60@EGRecv2Anv:

; 3211 : 			break;

  00fda	e9 75 0c 00 00	 jmp	 $LN2@EGRecv2Anv
$LN61@EGRecv2Anv:

; 3212 : 		case 18 :		// 유니리아의 뿔
; 3213 : 			ItemSerialCreateSend(

  00fdf	6a 00		 push	 0
  00fe1	6a 00		 push	 0
  00fe3	6a 00		 push	 0
  00fe5	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00fe8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00feb	51		 push	 ecx
  00fec	6a 00		 push	 0
  00fee	6a 00		 push	 0
  00ff0	6a 00		 push	 0
  00ff2	68 ff 00 00 00	 push	 255			; 000000ffH
  00ff7	6a 00		 push	 0
  00ff9	6a 02		 push	 2
  00ffb	6a 0d		 push	 13			; 0000000dH
  00ffd	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01002	83 c4 08	 add	 esp, 8
  01005	50		 push	 eax
  01006	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01009	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  01010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01016	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  0101e	52		 push	 edx
  0101f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01022	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01029	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0102f	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  01037	50		 push	 eax
  01038	68 eb 00 00 00	 push	 235			; 000000ebH
  0103d	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01040	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0104c	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0104f	51		 push	 ecx
  01050	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01055	83 c4 38	 add	 esp, 56			; 00000038H

; 3214 : 				gObj[aRecv->iINDEX].m_Index, 
; 3215 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3216 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3217 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3218 : 				ItemGetNumberMake(13, 2), 
; 3219 : 				0, (BYTE)255, 0, 0, 0, aRecv->iINDEX);
; 3220 : 			if (g_bRingEventItemTextLoad == FALSE)

  01058	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0105f	75 21		 jne	 SHORT $LN62@EGRecv2Anv

; 3221 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(13, 2)].Name);

  01061	6a 02		 push	 2
  01063	6a 0d		 push	 13			; 0000000dH
  01065	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0106a	83 c4 08	 add	 esp, 8
  0106d	6b c0 6c	 imul	 eax, eax, 108
  01070	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01075	50		 push	 eax
  01076	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01079	51		 push	 ecx
  0107a	e8 00 00 00 00	 call	 _strcpy
  0107f	83 c4 08	 add	 esp, 8
$LN62@EGRecv2Anv:

; 3222 : 			break;

  01082	e9 cd 0b 00 00	 jmp	 $LN2@EGRecv2Anv
$LN63@EGRecv2Anv:

; 3223 : 		case 19 :		// 디노란트의 뿔
; 3224 : 			ItemSerialCreateSend(

  01087	6a 00		 push	 0
  01089	6a 00		 push	 0
  0108b	6a 00		 push	 0
  0108d	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01090	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01093	51		 push	 ecx
  01094	6a 00		 push	 0
  01096	6a 00		 push	 0
  01098	6a 00		 push	 0
  0109a	68 ff 00 00 00	 push	 255			; 000000ffH
  0109f	6a 00		 push	 0
  010a1	6a 03		 push	 3
  010a3	6a 0d		 push	 13			; 0000000dH
  010a5	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  010aa	83 c4 08	 add	 esp, 8
  010ad	50		 push	 eax
  010ae	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  010b1	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  010b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  010be	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  010c6	52		 push	 edx
  010c7	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  010ca	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  010d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  010d7	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  010df	50		 push	 eax
  010e0	68 eb 00 00 00	 push	 235			; 000000ebH
  010e5	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  010e8	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  010ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  010f4	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  010f7	51		 push	 ecx
  010f8	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  010fd	83 c4 38	 add	 esp, 56			; 00000038H

; 3225 : 				gObj[aRecv->iINDEX].m_Index, 
; 3226 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3227 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3228 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3229 : 				ItemGetNumberMake(13, 3), 
; 3230 : 				0, (BYTE)255, 0, 0, 0, aRecv->iINDEX);
; 3231 : 			if (g_bRingEventItemTextLoad == FALSE)

  01100	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01107	75 21		 jne	 SHORT $LN64@EGRecv2Anv

; 3232 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(13, 2)].Name);

  01109	6a 02		 push	 2
  0110b	6a 0d		 push	 13			; 0000000dH
  0110d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01112	83 c4 08	 add	 esp, 8
  01115	6b c0 6c	 imul	 eax, eax, 108
  01118	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0111d	50		 push	 eax
  0111e	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01121	51		 push	 ecx
  01122	e8 00 00 00 00	 call	 _strcpy
  01127	83 c4 08	 add	 esp, 8
$LN64@EGRecv2Anv:

; 3233 : 			break;

  0112a	e9 25 0b 00 00	 jmp	 $LN2@EGRecv2Anv
$LN65@EGRecv2Anv:

; 3234 : 		case 20 :		// 생명의 보석
; 3235 : 			ItemSerialCreateSend(

  0112f	6a 00		 push	 0
  01131	6a 00		 push	 0
  01133	6a 00		 push	 0
  01135	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01138	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0113b	51		 push	 ecx
  0113c	6a 00		 push	 0
  0113e	6a 00		 push	 0
  01140	6a 00		 push	 0
  01142	6a 00		 push	 0
  01144	6a 00		 push	 0
  01146	6a 10		 push	 16			; 00000010H
  01148	6a 0e		 push	 14			; 0000000eH
  0114a	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0114f	83 c4 08	 add	 esp, 8
  01152	50		 push	 eax
  01153	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01156	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  0115d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01163	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  0116b	52		 push	 edx
  0116c	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0116f	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01176	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0117c	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  01184	50		 push	 eax
  01185	68 eb 00 00 00	 push	 235			; 000000ebH
  0118a	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0118d	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01194	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01199	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0119c	51		 push	 ecx
  0119d	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  011a2	83 c4 38	 add	 esp, 56			; 00000038H

; 3236 : 				gObj[aRecv->iINDEX].m_Index, 
; 3237 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3238 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3239 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3240 : 				ItemGetNumberMake(14, 16), 
; 3241 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3242 : 			if (g_bRingEventItemTextLoad == FALSE)

  011a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  011ac	75 21		 jne	 SHORT $LN66@EGRecv2Anv

; 3243 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 16)].Name);

  011ae	6a 10		 push	 16			; 00000010H
  011b0	6a 0e		 push	 14			; 0000000eH
  011b2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  011b7	83 c4 08	 add	 esp, 8
  011ba	6b c0 6c	 imul	 eax, eax, 108
  011bd	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  011c2	50		 push	 eax
  011c3	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  011c6	51		 push	 ecx
  011c7	e8 00 00 00 00	 call	 _strcpy
  011cc	83 c4 08	 add	 esp, 8
$LN66@EGRecv2Anv:

; 3244 : 			break;

  011cf	e9 80 0a 00 00	 jmp	 $LN2@EGRecv2Anv
$LN67@EGRecv2Anv:

; 3245 : 		case 21 :		// 수호천사
; 3246 : 			ItemSerialCreateSend(

  011d4	6a 00		 push	 0
  011d6	6a 00		 push	 0
  011d8	6a 00		 push	 0
  011da	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  011dd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  011e0	51		 push	 ecx
  011e1	6a 00		 push	 0
  011e3	6a 00		 push	 0
  011e5	6a 00		 push	 0
  011e7	68 ff 00 00 00	 push	 255			; 000000ffH
  011ec	6a 00		 push	 0
  011ee	6a 00		 push	 0
  011f0	6a 0d		 push	 13			; 0000000dH
  011f2	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  011f7	83 c4 08	 add	 esp, 8
  011fa	50		 push	 eax
  011fb	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  011fe	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  01205	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0120b	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  01213	52		 push	 edx
  01214	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01217	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0121e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01224	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  0122c	50		 push	 eax
  0122d	68 eb 00 00 00	 push	 235			; 000000ebH
  01232	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01235	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  0123c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01241	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  01244	51		 push	 ecx
  01245	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0124a	83 c4 38	 add	 esp, 56			; 00000038H

; 3247 : 				gObj[aRecv->iINDEX].m_Index, 
; 3248 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3249 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3250 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3251 : 				ItemGetNumberMake(13, 0), 
; 3252 : 				0, (BYTE)255, 0, 0, 0, aRecv->iINDEX);
; 3253 : 			if (g_bRingEventItemTextLoad == FALSE)

  0124d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01254	75 21		 jne	 SHORT $LN68@EGRecv2Anv

; 3254 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(13, 0)].Name);

  01256	6a 00		 push	 0
  01258	6a 0d		 push	 13			; 0000000dH
  0125a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0125f	83 c4 08	 add	 esp, 8
  01262	6b c0 6c	 imul	 eax, eax, 108
  01265	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0126a	50		 push	 eax
  0126b	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  0126e	51		 push	 ecx
  0126f	e8 00 00 00 00	 call	 _strcpy
  01274	83 c4 08	 add	 esp, 8
$LN68@EGRecv2Anv:

; 3255 : 			break;

  01277	e9 d8 09 00 00	 jmp	 $LN2@EGRecv2Anv
$LN69@EGRecv2Anv:

; 3256 : 		case 22 :		// 사탄
; 3257 : 			ItemSerialCreateSend(

  0127c	6a 00		 push	 0
  0127e	6a 00		 push	 0
  01280	6a 00		 push	 0
  01282	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01285	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01288	51		 push	 ecx
  01289	6a 00		 push	 0
  0128b	6a 00		 push	 0
  0128d	6a 00		 push	 0
  0128f	68 ff 00 00 00	 push	 255			; 000000ffH
  01294	6a 00		 push	 0
  01296	6a 01		 push	 1
  01298	6a 0d		 push	 13			; 0000000dH
  0129a	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0129f	83 c4 08	 add	 esp, 8
  012a2	50		 push	 eax
  012a3	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  012a6	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  012ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  012b3	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  012bb	52		 push	 edx
  012bc	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  012bf	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  012c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  012cc	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  012d4	50		 push	 eax
  012d5	68 eb 00 00 00	 push	 235			; 000000ebH
  012da	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  012dd	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  012e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  012e9	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  012ec	51		 push	 ecx
  012ed	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  012f2	83 c4 38	 add	 esp, 56			; 00000038H

; 3258 : 				gObj[aRecv->iINDEX].m_Index, 
; 3259 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3260 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3261 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3262 : 				ItemGetNumberMake(13, 1), 
; 3263 : 				0, (BYTE)255, 0, 0, 0, aRecv->iINDEX);
; 3264 : 			if (g_bRingEventItemTextLoad == FALSE)

  012f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  012fc	75 21		 jne	 SHORT $LN70@EGRecv2Anv

; 3265 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(13, 1)].Name);

  012fe	6a 01		 push	 1
  01300	6a 0d		 push	 13			; 0000000dH
  01302	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01307	83 c4 08	 add	 esp, 8
  0130a	6b c0 6c	 imul	 eax, eax, 108
  0130d	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01312	50		 push	 eax
  01313	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01316	51		 push	 ecx
  01317	e8 00 00 00 00	 call	 _strcpy
  0131c	83 c4 08	 add	 esp, 8
$LN70@EGRecv2Anv:

; 3266 : 			break;

  0131f	e9 30 09 00 00	 jmp	 $LN2@EGRecv2Anv
$LN71@EGRecv2Anv:

; 3267 : 		case 23 :		// 성탄의별
; 3268 : 			ItemSerialCreateSend(

  01324	6a 00		 push	 0
  01326	6a 00		 push	 0
  01328	6a 00		 push	 0
  0132a	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0132d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01330	51		 push	 ecx
  01331	6a 00		 push	 0
  01333	6a 00		 push	 0
  01335	6a 00		 push	 0
  01337	6a 00		 push	 0
  01339	6a 01		 push	 1
  0133b	6a 0b		 push	 11			; 0000000bH
  0133d	6a 0e		 push	 14			; 0000000eH
  0133f	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01344	83 c4 08	 add	 esp, 8
  01347	50		 push	 eax
  01348	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0134b	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  01352	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01358	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  01360	52		 push	 edx
  01361	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01364	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0136b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01371	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  01379	50		 push	 eax
  0137a	68 eb 00 00 00	 push	 235			; 000000ebH
  0137f	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01382	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01389	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0138e	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  01391	51		 push	 ecx
  01392	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01397	83 c4 38	 add	 esp, 56			; 00000038H

; 3269 : 				gObj[aRecv->iINDEX].m_Index, 
; 3270 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3271 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3272 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3273 : 				ItemGetNumberMake(14, 11), 
; 3274 : 				1, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3275 : 			if (g_bRingEventItemTextLoad == FALSE)

  0139a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  013a1	75 21		 jne	 SHORT $LN72@EGRecv2Anv

; 3276 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 11)].Name);

  013a3	6a 0b		 push	 11			; 0000000bH
  013a5	6a 0e		 push	 14			; 0000000eH
  013a7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  013ac	83 c4 08	 add	 esp, 8
  013af	6b c0 6c	 imul	 eax, eax, 108
  013b2	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  013b7	50		 push	 eax
  013b8	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  013bb	51		 push	 ecx
  013bc	e8 00 00 00 00	 call	 _strcpy
  013c1	83 c4 08	 add	 esp, 8
$LN72@EGRecv2Anv:

; 3277 : 			break;

  013c4	e9 8b 08 00 00	 jmp	 $LN2@EGRecv2Anv
$LN73@EGRecv2Anv:

; 3278 : 		case 24 :		// 쿤둔의 상자 + 2
; 3279 : 			ItemSerialCreateSend(

  013c9	6a 00		 push	 0
  013cb	6a 00		 push	 0
  013cd	6a 00		 push	 0
  013cf	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  013d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  013d5	51		 push	 ecx
  013d6	6a 00		 push	 0
  013d8	6a 00		 push	 0
  013da	6a 00		 push	 0
  013dc	6a 00		 push	 0
  013de	6a 09		 push	 9
  013e0	6a 0b		 push	 11			; 0000000bH
  013e2	6a 0e		 push	 14			; 0000000eH
  013e4	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  013e9	83 c4 08	 add	 esp, 8
  013ec	50		 push	 eax
  013ed	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  013f0	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  013f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  013fd	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  01405	52		 push	 edx
  01406	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01409	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01410	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01416	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  0141e	50		 push	 eax
  0141f	68 eb 00 00 00	 push	 235			; 000000ebH
  01424	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01427	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  0142e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01433	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  01436	51		 push	 ecx
  01437	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0143c	83 c4 38	 add	 esp, 56			; 00000038H

; 3280 : 				gObj[aRecv->iINDEX].m_Index, 
; 3281 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3282 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3283 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3284 : 				ItemGetNumberMake(14, 11), 
; 3285 : 				9, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3286 : 			if (g_bRingEventItemTextLoad == FALSE)

  0143f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01446	75 21		 jne	 SHORT $LN74@EGRecv2Anv

; 3287 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 11)].Name);

  01448	6a 0b		 push	 11			; 0000000bH
  0144a	6a 0e		 push	 14			; 0000000eH
  0144c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01451	83 c4 08	 add	 esp, 8
  01454	6b c0 6c	 imul	 eax, eax, 108
  01457	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0145c	50		 push	 eax
  0145d	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01460	51		 push	 ecx
  01461	e8 00 00 00 00	 call	 _strcpy
  01466	83 c4 08	 add	 esp, 8
$LN74@EGRecv2Anv:

; 3288 : 			break;

  01469	e9 e6 07 00 00	 jmp	 $LN2@EGRecv2Anv
$LN75@EGRecv2Anv:

; 3289 : 		case 25 :		// 쿤둔의 상자 + 3
; 3290 : 			ItemSerialCreateSend(

  0146e	6a 00		 push	 0
  01470	6a 00		 push	 0
  01472	6a 00		 push	 0
  01474	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01477	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0147a	51		 push	 ecx
  0147b	6a 00		 push	 0
  0147d	6a 00		 push	 0
  0147f	6a 00		 push	 0
  01481	6a 00		 push	 0
  01483	6a 0a		 push	 10			; 0000000aH
  01485	6a 0b		 push	 11			; 0000000bH
  01487	6a 0e		 push	 14			; 0000000eH
  01489	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0148e	83 c4 08	 add	 esp, 8
  01491	50		 push	 eax
  01492	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01495	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  0149c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  014a2	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  014aa	52		 push	 edx
  014ab	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  014ae	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  014b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  014bb	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  014c3	50		 push	 eax
  014c4	68 eb 00 00 00	 push	 235			; 000000ebH
  014c9	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  014cc	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  014d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  014d8	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  014db	51		 push	 ecx
  014dc	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  014e1	83 c4 38	 add	 esp, 56			; 00000038H

; 3291 : 				gObj[aRecv->iINDEX].m_Index, 
; 3292 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3293 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3294 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3295 : 				ItemGetNumberMake(14, 11), 
; 3296 : 				10, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3297 : 			if (g_bRingEventItemTextLoad == FALSE)

  014e4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  014eb	75 21		 jne	 SHORT $LN76@EGRecv2Anv

; 3298 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 11)].Name);

  014ed	6a 0b		 push	 11			; 0000000bH
  014ef	6a 0e		 push	 14			; 0000000eH
  014f1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  014f6	83 c4 08	 add	 esp, 8
  014f9	6b c0 6c	 imul	 eax, eax, 108
  014fc	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01501	50		 push	 eax
  01502	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01505	51		 push	 ecx
  01506	e8 00 00 00 00	 call	 _strcpy
  0150b	83 c4 08	 add	 esp, 8
$LN76@EGRecv2Anv:

; 3299 : 			break;

  0150e	e9 41 07 00 00	 jmp	 $LN2@EGRecv2Anv
$LN77@EGRecv2Anv:

; 3300 : 		case 26 :		// 데빌스퀘어 초대권 + 0
; 3301 : 			ItemSerialCreateSend(

  01513	6a 00		 push	 0
  01515	6a 00		 push	 0
  01517	6a 00		 push	 0
  01519	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0151c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0151f	51		 push	 ecx
  01520	6a 00		 push	 0
  01522	6a 00		 push	 0
  01524	6a 00		 push	 0
  01526	6a 00		 push	 0
  01528	6a 00		 push	 0
  0152a	6a 13		 push	 19			; 00000013H
  0152c	6a 0e		 push	 14			; 0000000eH
  0152e	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01533	83 c4 08	 add	 esp, 8
  01536	50		 push	 eax
  01537	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0153a	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  01541	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01547	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  0154f	52		 push	 edx
  01550	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01553	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0155a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01560	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  01568	50		 push	 eax
  01569	68 eb 00 00 00	 push	 235			; 000000ebH
  0156e	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01571	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01578	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0157d	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  01580	51		 push	 ecx
  01581	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01586	83 c4 38	 add	 esp, 56			; 00000038H

; 3302 : 				gObj[aRecv->iINDEX].m_Index, 
; 3303 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3304 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3305 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3306 : 				ItemGetNumberMake(14, 19), 
; 3307 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3308 : 			if (g_bRingEventItemTextLoad == FALSE)

  01589	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01590	75 21		 jne	 SHORT $LN78@EGRecv2Anv

; 3309 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 19)].Name);

  01592	6a 13		 push	 19			; 00000013H
  01594	6a 0e		 push	 14			; 0000000eH
  01596	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0159b	83 c4 08	 add	 esp, 8
  0159e	6b c0 6c	 imul	 eax, eax, 108
  015a1	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  015a6	50		 push	 eax
  015a7	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  015aa	51		 push	 ecx
  015ab	e8 00 00 00 00	 call	 _strcpy
  015b0	83 c4 08	 add	 esp, 8
$LN78@EGRecv2Anv:

; 3310 : 			break;

  015b3	e9 9c 06 00 00	 jmp	 $LN2@EGRecv2Anv
$LN79@EGRecv2Anv:

; 3311 : 		case 27 :		// 데빌스퀘어 초대권 + 1
; 3312 : 			ItemSerialCreateSend(

  015b8	6a 00		 push	 0
  015ba	6a 00		 push	 0
  015bc	6a 00		 push	 0
  015be	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  015c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  015c4	51		 push	 ecx
  015c5	6a 00		 push	 0
  015c7	6a 00		 push	 0
  015c9	6a 00		 push	 0
  015cb	6a 00		 push	 0
  015cd	6a 01		 push	 1
  015cf	6a 13		 push	 19			; 00000013H
  015d1	6a 0e		 push	 14			; 0000000eH
  015d3	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  015d8	83 c4 08	 add	 esp, 8
  015db	50		 push	 eax
  015dc	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  015df	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  015e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  015ec	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  015f4	52		 push	 edx
  015f5	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  015f8	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  015ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01605	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  0160d	50		 push	 eax
  0160e	68 eb 00 00 00	 push	 235			; 000000ebH
  01613	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01616	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  0161d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01622	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  01625	51		 push	 ecx
  01626	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0162b	83 c4 38	 add	 esp, 56			; 00000038H

; 3313 : 				gObj[aRecv->iINDEX].m_Index, 
; 3314 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3315 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3316 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3317 : 				ItemGetNumberMake(14, 19), 
; 3318 : 				1, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3319 : 			if (g_bRingEventItemTextLoad == FALSE)

  0162e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01635	75 21		 jne	 SHORT $LN80@EGRecv2Anv

; 3320 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 19)].Name);

  01637	6a 13		 push	 19			; 00000013H
  01639	6a 0e		 push	 14			; 0000000eH
  0163b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01640	83 c4 08	 add	 esp, 8
  01643	6b c0 6c	 imul	 eax, eax, 108
  01646	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0164b	50		 push	 eax
  0164c	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  0164f	51		 push	 ecx
  01650	e8 00 00 00 00	 call	 _strcpy
  01655	83 c4 08	 add	 esp, 8
$LN80@EGRecv2Anv:

; 3321 : 			break;

  01658	e9 f7 05 00 00	 jmp	 $LN2@EGRecv2Anv
$LN81@EGRecv2Anv:

; 3322 : 		case 28 :		// 데빌스퀘어 초대권 + 2
; 3323 : 			ItemSerialCreateSend(

  0165d	6a 00		 push	 0
  0165f	6a 00		 push	 0
  01661	6a 00		 push	 0
  01663	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01666	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01669	51		 push	 ecx
  0166a	6a 00		 push	 0
  0166c	6a 00		 push	 0
  0166e	6a 00		 push	 0
  01670	6a 00		 push	 0
  01672	6a 02		 push	 2
  01674	6a 13		 push	 19			; 00000013H
  01676	6a 0e		 push	 14			; 0000000eH
  01678	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0167d	83 c4 08	 add	 esp, 8
  01680	50		 push	 eax
  01681	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01684	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  0168b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01691	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  01699	52		 push	 edx
  0169a	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0169d	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  016a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  016aa	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  016b2	50		 push	 eax
  016b3	68 eb 00 00 00	 push	 235			; 000000ebH
  016b8	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  016bb	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  016c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  016c7	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  016ca	51		 push	 ecx
  016cb	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  016d0	83 c4 38	 add	 esp, 56			; 00000038H

; 3324 : 				gObj[aRecv->iINDEX].m_Index, 
; 3325 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3326 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3327 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3328 : 				ItemGetNumberMake(14, 19), 
; 3329 : 				2, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3330 : 			if (g_bRingEventItemTextLoad == FALSE)

  016d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  016da	75 21		 jne	 SHORT $LN82@EGRecv2Anv

; 3331 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 19)].Name);

  016dc	6a 13		 push	 19			; 00000013H
  016de	6a 0e		 push	 14			; 0000000eH
  016e0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  016e5	83 c4 08	 add	 esp, 8
  016e8	6b c0 6c	 imul	 eax, eax, 108
  016eb	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  016f0	50		 push	 eax
  016f1	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  016f4	51		 push	 ecx
  016f5	e8 00 00 00 00	 call	 _strcpy
  016fa	83 c4 08	 add	 esp, 8
$LN82@EGRecv2Anv:

; 3332 : 			break;

  016fd	e9 52 05 00 00	 jmp	 $LN2@EGRecv2Anv
$LN83@EGRecv2Anv:

; 3333 : 		case 29 :		// 데빌스퀘어 초대권 + 3
; 3334 : 			ItemSerialCreateSend(

  01702	6a 00		 push	 0
  01704	6a 00		 push	 0
  01706	6a 00		 push	 0
  01708	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0170b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0170e	51		 push	 ecx
  0170f	6a 00		 push	 0
  01711	6a 00		 push	 0
  01713	6a 00		 push	 0
  01715	6a 00		 push	 0
  01717	6a 03		 push	 3
  01719	6a 13		 push	 19			; 00000013H
  0171b	6a 0e		 push	 14			; 0000000eH
  0171d	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01722	83 c4 08	 add	 esp, 8
  01725	50		 push	 eax
  01726	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01729	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  01730	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01736	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  0173e	52		 push	 edx
  0173f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01742	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01749	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0174f	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  01757	50		 push	 eax
  01758	68 eb 00 00 00	 push	 235			; 000000ebH
  0175d	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01760	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01767	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0176c	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0176f	51		 push	 ecx
  01770	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01775	83 c4 38	 add	 esp, 56			; 00000038H

; 3335 : 				gObj[aRecv->iINDEX].m_Index, 
; 3336 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3337 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3338 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3339 : 				ItemGetNumberMake(14, 19), 
; 3340 : 				3, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3341 : 			if (g_bRingEventItemTextLoad == FALSE)

  01778	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0177f	75 21		 jne	 SHORT $LN84@EGRecv2Anv

; 3342 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 19)].Name);

  01781	6a 13		 push	 19			; 00000013H
  01783	6a 0e		 push	 14			; 0000000eH
  01785	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0178a	83 c4 08	 add	 esp, 8
  0178d	6b c0 6c	 imul	 eax, eax, 108
  01790	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01795	50		 push	 eax
  01796	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01799	51		 push	 ecx
  0179a	e8 00 00 00 00	 call	 _strcpy
  0179f	83 c4 08	 add	 esp, 8
$LN84@EGRecv2Anv:

; 3343 : 			break;

  017a2	e9 ad 04 00 00	 jmp	 $LN2@EGRecv2Anv
$LN85@EGRecv2Anv:

; 3344 : 		case 30 :		// 데빌스퀘어 초대권 + 4
; 3345 : 			ItemSerialCreateSend(

  017a7	6a 00		 push	 0
  017a9	6a 00		 push	 0
  017ab	6a 00		 push	 0
  017ad	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  017b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  017b3	51		 push	 ecx
  017b4	6a 00		 push	 0
  017b6	6a 00		 push	 0
  017b8	6a 00		 push	 0
  017ba	6a 00		 push	 0
  017bc	6a 04		 push	 4
  017be	6a 13		 push	 19			; 00000013H
  017c0	6a 0e		 push	 14			; 0000000eH
  017c2	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  017c7	83 c4 08	 add	 esp, 8
  017ca	50		 push	 eax
  017cb	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  017ce	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  017d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  017db	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  017e3	52		 push	 edx
  017e4	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  017e7	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  017ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  017f4	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  017fc	50		 push	 eax
  017fd	68 eb 00 00 00	 push	 235			; 000000ebH
  01802	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01805	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  0180c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01811	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  01814	51		 push	 ecx
  01815	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0181a	83 c4 38	 add	 esp, 56			; 00000038H

; 3346 : 				gObj[aRecv->iINDEX].m_Index, 
; 3347 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3348 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3349 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3350 : 				ItemGetNumberMake(14, 19), 
; 3351 : 				4, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3352 : 			if (g_bRingEventItemTextLoad == FALSE)

  0181d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01824	75 21		 jne	 SHORT $LN86@EGRecv2Anv

; 3353 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 19)].Name);

  01826	6a 13		 push	 19			; 00000013H
  01828	6a 0e		 push	 14			; 0000000eH
  0182a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0182f	83 c4 08	 add	 esp, 8
  01832	6b c0 6c	 imul	 eax, eax, 108
  01835	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0183a	50		 push	 eax
  0183b	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  0183e	51		 push	 ecx
  0183f	e8 00 00 00 00	 call	 _strcpy
  01844	83 c4 08	 add	 esp, 8
$LN86@EGRecv2Anv:

; 3354 : 			break;

  01847	e9 08 04 00 00	 jmp	 $LN2@EGRecv2Anv
$LN87@EGRecv2Anv:

; 3355 : 		case 31 :		// 폭죽
; 3356 : 			ItemSerialCreateSend(

  0184c	6a 00		 push	 0
  0184e	6a 00		 push	 0
  01850	6a 00		 push	 0
  01852	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01855	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01858	51		 push	 ecx
  01859	6a 00		 push	 0
  0185b	6a 00		 push	 0
  0185d	6a 00		 push	 0
  0185f	6a 00		 push	 0
  01861	6a 02		 push	 2
  01863	6a 0b		 push	 11			; 0000000bH
  01865	6a 0e		 push	 14			; 0000000eH
  01867	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0186c	83 c4 08	 add	 esp, 8
  0186f	50		 push	 eax
  01870	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01873	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  0187a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01880	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  01888	52		 push	 edx
  01889	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0188c	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01893	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01899	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  018a1	50		 push	 eax
  018a2	68 eb 00 00 00	 push	 235			; 000000ebH
  018a7	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  018aa	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  018b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  018b6	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  018b9	51		 push	 ecx
  018ba	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  018bf	83 c4 38	 add	 esp, 56			; 00000038H

; 3357 : 				gObj[aRecv->iINDEX].m_Index, 
; 3358 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3359 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3360 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3361 : 				ItemGetNumberMake(14, 11), 
; 3362 : 				2, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3363 : 			if (g_bRingEventItemTextLoad == FALSE)

  018c2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  018c9	75 21		 jne	 SHORT $LN88@EGRecv2Anv

; 3364 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 11)].Name);

  018cb	6a 0b		 push	 11			; 0000000bH
  018cd	6a 0e		 push	 14			; 0000000eH
  018cf	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  018d4	83 c4 08	 add	 esp, 8
  018d7	6b c0 6c	 imul	 eax, eax, 108
  018da	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  018df	50		 push	 eax
  018e0	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  018e3	51		 push	 ecx
  018e4	e8 00 00 00 00	 call	 _strcpy
  018e9	83 c4 08	 add	 esp, 8
$LN88@EGRecv2Anv:

; 3365 : 			break;

  018ec	e9 63 03 00 00	 jmp	 $LN2@EGRecv2Anv
$LN89@EGRecv2Anv:

; 3366 : 		case 32 :		// 사랑의 묘약
; 3367 : 			ItemSerialCreateSend(

  018f1	6a 00		 push	 0
  018f3	6a 00		 push	 0
  018f5	6a 00		 push	 0
  018f7	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  018fa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  018fd	51		 push	 ecx
  018fe	6a 00		 push	 0
  01900	6a 00		 push	 0
  01902	6a 00		 push	 0
  01904	6a 00		 push	 0
  01906	6a 00		 push	 0
  01908	6a 14		 push	 20			; 00000014H
  0190a	6a 0e		 push	 14			; 0000000eH
  0190c	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01911	83 c4 08	 add	 esp, 8
  01914	50		 push	 eax
  01915	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01918	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  0191f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01925	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  0192d	52		 push	 edx
  0192e	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01931	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01938	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0193e	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  01946	50		 push	 eax
  01947	68 eb 00 00 00	 push	 235			; 000000ebH
  0194c	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0194f	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01956	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0195b	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0195e	51		 push	 ecx
  0195f	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01964	83 c4 38	 add	 esp, 56			; 00000038H

; 3368 : 				gObj[aRecv->iINDEX].m_Index, 
; 3369 : 				ITEMMAKE_INVENTORY_1CELL, 
; 3370 : 				(BYTE)gObj[aRecv->iINDEX].X, 
; 3371 : 				(BYTE)gObj[aRecv->iINDEX].Y, 
; 3372 : 				ItemGetNumberMake(14, 20), 
; 3373 : 				0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3374 : 			if (g_bRingEventItemTextLoad == FALSE)

  01967	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0196e	75 21		 jne	 SHORT $LN90@EGRecv2Anv

; 3375 : 				strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 20)].Name);

  01970	6a 14		 push	 20			; 00000014H
  01972	6a 0e		 push	 14			; 0000000eH
  01974	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01979	83 c4 08	 add	 esp, 8
  0197c	6b c0 6c	 imul	 eax, eax, 108
  0197f	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01984	50		 push	 eax
  01985	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01988	51		 push	 ecx
  01989	e8 00 00 00 00	 call	 _strcpy
  0198e	83 c4 08	 add	 esp, 8
$LN90@EGRecv2Anv:

; 3376 : 			break;

  01991	e9 be 02 00 00	 jmp	 $LN2@EGRecv2Anv
$LN91@EGRecv2Anv:

; 3377 : 
; 3378 : 			#ifdef ADD_ITEM_OF_FRIENDSHIP_EVENT_20040729
; 3379 : 			case 33 :		// 창조의 보석
; 3380 : 				ItemSerialCreateSend(

  01996	6a 00		 push	 0
  01998	6a 00		 push	 0
  0199a	6a 00		 push	 0
  0199c	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0199f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  019a2	51		 push	 ecx
  019a3	6a 00		 push	 0
  019a5	6a 00		 push	 0
  019a7	6a 00		 push	 0
  019a9	6a 00		 push	 0
  019ab	6a 00		 push	 0
  019ad	6a 16		 push	 22			; 00000016H
  019af	6a 0e		 push	 14			; 0000000eH
  019b1	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  019b6	83 c4 08	 add	 esp, 8
  019b9	50		 push	 eax
  019ba	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  019bd	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  019c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  019ca	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  019d2	52		 push	 edx
  019d3	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  019d6	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  019dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  019e3	0f b6 84 0a 04
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+260]
  019eb	50		 push	 eax
  019ec	68 eb 00 00 00	 push	 235			; 000000ebH
  019f1	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  019f4	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  019fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01a00	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  01a03	51		 push	 ecx
  01a04	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01a09	83 c4 38	 add	 esp, 56			; 00000038H

; 3381 : 					gObj[aRecv->iINDEX].m_Index, 
; 3382 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3383 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3384 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3385 : 					ItemGetNumberMake(14, 22), 
; 3386 : 					0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3387 : 				if (g_bRingEventItemTextLoad == FALSE)

  01a0c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01a13	75 21		 jne	 SHORT $LN92@EGRecv2Anv

; 3388 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 22)].Name);

  01a15	6a 16		 push	 22			; 00000016H
  01a17	6a 0e		 push	 14			; 0000000eH
  01a19	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01a1e	83 c4 08	 add	 esp, 8
  01a21	6b c0 6c	 imul	 eax, eax, 108
  01a24	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01a29	50		 push	 eax
  01a2a	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01a2d	51		 push	 ecx
  01a2e	e8 00 00 00 00	 call	 _strcpy
  01a33	83 c4 08	 add	 esp, 8
$LN92@EGRecv2Anv:

; 3389 : 				break;

  01a36	e9 19 02 00 00	 jmp	 $LN2@EGRecv2Anv
$LN93@EGRecv2Anv:

; 3390 : 			case 34 :		// 열매 (에너지)
; 3391 : 			case 35 :		// 열매 (체력)
; 3392 : 			case 36 :		// 열매 (민첩)
; 3393 : 			case 37 :		// 열매 (힘)
; 3394 : 				ItemSerialCreateSend(

  01a3b	6a 00		 push	 0
  01a3d	6a 00		 push	 0
  01a3f	6a 00		 push	 0
  01a41	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01a44	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01a47	51		 push	 ecx
  01a48	6a 00		 push	 0
  01a4a	6a 00		 push	 0
  01a4c	6a 00		 push	 0
  01a4e	6a 00		 push	 0
  01a50	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01a53	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01a56	83 e8 22	 sub	 eax, 34			; 00000022H
  01a59	50		 push	 eax
  01a5a	6a 0f		 push	 15			; 0000000fH
  01a5c	6a 0d		 push	 13			; 0000000dH
  01a5e	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01a63	83 c4 08	 add	 esp, 8
  01a66	50		 push	 eax
  01a67	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01a6a	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01a71	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01a76	0f b6 8c 10 06
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+262]
  01a7e	51		 push	 ecx
  01a7f	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01a82	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  01a89	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01a8f	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  01a97	52		 push	 edx
  01a98	68 eb 00 00 00	 push	 235			; 000000ebH
  01a9d	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01aa0	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01aa7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01aad	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  01ab0	50		 push	 eax
  01ab1	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01ab6	83 c4 38	 add	 esp, 56			; 00000038H

; 3395 : 					gObj[aRecv->iINDEX].m_Index, 
; 3396 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3397 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3398 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3399 : 					ItemGetNumberMake(13, 15), 
; 3400 : 					aRecv->iGiftNumber - 34, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3401 : 				if (g_bRingEventItemTextLoad == FALSE)

  01ab9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01ac0	75 21		 jne	 SHORT $LN94@EGRecv2Anv

; 3402 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(13, 15)].Name);

  01ac2	6a 0f		 push	 15			; 0000000fH
  01ac4	6a 0d		 push	 13			; 0000000dH
  01ac6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01acb	83 c4 08	 add	 esp, 8
  01ace	6b c0 6c	 imul	 eax, eax, 108
  01ad1	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01ad6	50		 push	 eax
  01ad7	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01ada	51		 push	 ecx
  01adb	e8 00 00 00 00	 call	 _strcpy
  01ae0	83 c4 08	 add	 esp, 8
$LN94@EGRecv2Anv:

; 3403 : 				break;

  01ae3	e9 6c 01 00 00	 jmp	 $LN2@EGRecv2Anv
$LN95@EGRecv2Anv:

; 3404 : 			case 38 :		// 쿤둔의 상자 +4
; 3405 : 			case 39 :		// 쿤둔의 상자 +5
; 3406 : 				ItemSerialCreateSend(

  01ae8	6a 00		 push	 0
  01aea	6a 00		 push	 0
  01aec	6a 00		 push	 0
  01aee	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01af1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01af4	51		 push	 ecx
  01af5	6a 00		 push	 0
  01af7	6a 00		 push	 0
  01af9	6a 00		 push	 0
  01afb	6a 00		 push	 0
  01afd	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01b00	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01b03	83 e8 1b	 sub	 eax, 27			; 0000001bH
  01b06	50		 push	 eax
  01b07	6a 0b		 push	 11			; 0000000bH
  01b09	6a 0e		 push	 14			; 0000000eH
  01b0b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01b10	83 c4 08	 add	 esp, 8
  01b13	50		 push	 eax
  01b14	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01b17	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01b1e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01b23	0f b6 8c 10 06
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+262]
  01b2b	51		 push	 ecx
  01b2c	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01b2f	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  01b36	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01b3c	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  01b44	52		 push	 edx
  01b45	68 eb 00 00 00	 push	 235			; 000000ebH
  01b4a	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01b4d	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01b54	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01b5a	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  01b5d	50		 push	 eax
  01b5e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01b63	83 c4 38	 add	 esp, 56			; 00000038H

; 3407 : 					gObj[aRecv->iINDEX].m_Index, 
; 3408 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3409 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3410 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3411 : 					ItemGetNumberMake(14, 11), 
; 3412 : 					11 + aRecv->iGiftNumber - 38, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3413 : 				if (g_bRingEventItemTextLoad == FALSE)

  01b66	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01b6d	75 21		 jne	 SHORT $LN96@EGRecv2Anv

; 3414 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 11)].Name);

  01b6f	6a 0b		 push	 11			; 0000000bH
  01b71	6a 0e		 push	 14			; 0000000eH
  01b73	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01b78	83 c4 08	 add	 esp, 8
  01b7b	6b c0 6c	 imul	 eax, eax, 108
  01b7e	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01b83	50		 push	 eax
  01b84	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01b87	51		 push	 ecx
  01b88	e8 00 00 00 00	 call	 _strcpy
  01b8d	83 c4 08	 add	 esp, 8
$LN96@EGRecv2Anv:

; 3415 : 				break;

  01b90	e9 bf 00 00 00	 jmp	 $LN2@EGRecv2Anv
$LN97@EGRecv2Anv:

; 3416 : 			case 40 :		// 애니버서리 박스 +1
; 3417 : 			case 41 :		// 애니버서리 박스 +2
; 3418 : 			case 42 :		// 애니버서리 박스 +3
; 3419 : 			case 43 :		// 애니버서리 박스 +4
; 3420 : 			case 44 :		// 애니버서리 박스 +5
; 3421 : 				ItemSerialCreateSend(

  01b95	6a 00		 push	 0
  01b97	6a 00		 push	 0
  01b99	6a 00		 push	 0
  01b9b	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01b9e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01ba1	51		 push	 ecx
  01ba2	6a 00		 push	 0
  01ba4	6a 00		 push	 0
  01ba6	6a 00		 push	 0
  01ba8	6a 00		 push	 0
  01baa	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01bad	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01bb0	83 e8 27	 sub	 eax, 39			; 00000027H
  01bb3	50		 push	 eax
  01bb4	6a 14		 push	 20			; 00000014H
  01bb6	6a 0e		 push	 14			; 0000000eH
  01bb8	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01bbd	83 c4 08	 add	 esp, 8
  01bc0	50		 push	 eax
  01bc1	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01bc4	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01bcb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01bd0	0f b6 8c 10 06
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+262]
  01bd8	51		 push	 ecx
  01bd9	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01bdc	69 42 04 a0 1b
	00 00		 imul	 eax, DWORD PTR [edx+4], 7072
  01be3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01be9	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  01bf1	52		 push	 edx
  01bf2	68 eb 00 00 00	 push	 235			; 000000ebH
  01bf7	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01bfa	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01c01	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01c07	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  01c0a	50		 push	 eax
  01c0b	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01c10	83 c4 38	 add	 esp, 56			; 00000038H

; 3422 : 					gObj[aRecv->iINDEX].m_Index, 
; 3423 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3424 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3425 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3426 : 					ItemGetNumberMake(14, 20), 
; 3427 : 					1 + aRecv->iGiftNumber - 40, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3428 : 				if (g_bRingEventItemTextLoad == FALSE)

  01c13	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01c1a	75 21		 jne	 SHORT $LN98@EGRecv2Anv

; 3429 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 20)].Name);

  01c1c	6a 14		 push	 20			; 00000014H
  01c1e	6a 0e		 push	 14			; 0000000eH
  01c20	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01c25	83 c4 08	 add	 esp, 8
  01c28	6b c0 6c	 imul	 eax, eax, 108
  01c2b	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  01c30	50		 push	 eax
  01c31	8d 4d b8	 lea	 ecx, DWORD PTR _Result$[ebp+4]
  01c34	51		 push	 ecx
  01c35	e8 00 00 00 00	 call	 _strcpy
  01c3a	83 c4 08	 add	 esp, 8
$LN98@EGRecv2Anv:

; 3430 : 				break;

  01c3d	eb 15		 jmp	 SHORT $LN2@EGRecv2Anv
$LN99@EGRecv2Anv:

; 3431 : 			#endif // ADD_ITEM_OF_FRIENDSHIP_EVENT_20040729
; 3432 : 			#ifdef MODIFY_GOLDEN_ARCHER_EVENT_ITEMLIST_20061109
; 3433 : 			case 45:		// 쿤둔의 상자 +1 (14,11,8)
; 3434 : 				ItemSerialCreateSend(
; 3435 : 					gObj[aRecv->iINDEX].m_Index, 
; 3436 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3437 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3438 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3439 : 					ItemGetNumberMake(14, 11), 
; 3440 : 					8, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3441 : 				if (g_bRingEventItemTextLoad == FALSE)
; 3442 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 11)].Name);
; 3443 : 				break;
; 3444 : 			case 46:		// 보석 원석 (14,41)
; 3445 : 				ItemSerialCreateSend(
; 3446 : 					gObj[aRecv->iINDEX].m_Index, 
; 3447 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3448 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3449 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3450 : 					ItemGetNumberMake(14, 41), 
; 3451 : 					0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3452 : 				if (g_bRingEventItemTextLoad == FALSE)
; 3453 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 41)].Name);
; 3454 : 				break;
; 3455 : 			case 47:		// 조화의 보석 (14,42)
; 3456 : 				ItemSerialCreateSend(
; 3457 : 					gObj[aRecv->iINDEX].m_Index, 
; 3458 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3459 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3460 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3461 : 					ItemGetNumberMake(14, 42), 
; 3462 : 					0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3463 : 				if (g_bRingEventItemTextLoad == FALSE)
; 3464 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 42)].Name);
; 3465 : 				break;
; 3466 : 			case 48:		// 상급 제련석 (14,44)
; 3467 : 				ItemSerialCreateSend(
; 3468 : 					gObj[aRecv->iINDEX].m_Index, 
; 3469 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3470 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3471 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3472 : 					ItemGetNumberMake(14, 44), 
; 3473 : 					0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3474 : 				if (g_bRingEventItemTextLoad == FALSE)
; 3475 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 44)].Name);
; 3476 : 				break;
; 3477 : 			case 49:		// 하급 제련석 (14,43)
; 3478 : 				ItemSerialCreateSend(
; 3479 : 					gObj[aRecv->iINDEX].m_Index, 
; 3480 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3481 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3482 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3483 : 					ItemGetNumberMake(14, 43), 
; 3484 : 					0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3485 : 				if (g_bRingEventItemTextLoad == FALSE)
; 3486 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 43)].Name);
; 3487 : 				break;
; 3488 : 			case 50:		// 수호의 보석 (14,31)
; 3489 : 				ItemSerialCreateSend(
; 3490 : 					gObj[aRecv->iINDEX].m_Index, 
; 3491 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3492 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3493 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3494 : 					ItemGetNumberMake(14, 31), 
; 3495 : 					0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3496 : 				if (g_bRingEventItemTextLoad == FALSE)
; 3497 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 31)].Name);
; 3498 : 				break;
; 3499 : /*
; 3500 : 			case 51:		// 마법사의 반지 (13,20)
; 3501 : 				int iRingCountinInventory;
; 3502 : 				int iRingCountinEquip;
; 3503 : 				iRingCountinInventory = gObjGetItemCountInIventory(gObj[aRecv->iINDEX].m_Index, 13, 20, 0);
; 3504 : 				iRingCountinEquip = gObjGetItemCountInEquipment(gObj[aRecv->iINDEX].m_Index, 13, 20, 0);
; 3505 : 				if( iRingCountinEquip > 0 || iRingCountinInventory )
; 3506 : 				{
; 3507 : 					break;
; 3508 : 				}
; 3509 : 
; 3510 : 				ItemSerialCreateSend(
; 3511 : 					gObj[aRecv->iINDEX].m_Index, 
; 3512 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3513 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3514 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3515 : 					ItemGetNumberMake(13, 20), 
; 3516 : 					0, (BYTE)30, 0, 0, 0, aRecv->iINDEX);
; 3517 : 				if (g_bRingEventItemTextLoad == FALSE)
; 3518 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(13, 20)].Name);
; 3519 : 				break;
; 3520 : */
; 3521 : 			#endif // MODIFY_GOLDEN_ARCHER_EVENT_ITEMLIST_20061109
; 3522 : 			#ifdef MODIFY_GOLDEN_ARCHER_EVENT_ITEMLIST_2_20070408
; 3523 : 			case 51:		// 카오스카드미니 (14, 95)
; 3524 : 				ItemSerialCreateSend(
; 3525 : 					gObj[aRecv->iINDEX].m_Index, 
; 3526 : 					ITEMMAKE_INVENTORY_1CELL, 
; 3527 : 					(BYTE)gObj[aRecv->iINDEX].X, 
; 3528 : 					(BYTE)gObj[aRecv->iINDEX].Y, 
; 3529 : 					ItemGetNumberMake(14, 95), 
; 3530 : 					0, (BYTE)0, 0, 0, 0, aRecv->iINDEX);
; 3531 : 				if (g_bRingEventItemTextLoad == FALSE)
; 3532 : 					strcpy (Result.szGIFT_NAME, ItemAttribute[MAKE_ITEMNUM(14, 95)].Name);
; 3533 : 				break;
; 3534 : 			#endif // MODIFY_GOLDEN_ARCHER_EVENT_ITEMLIST_2_20070408				
; 3535 : 		default :		// 에러
; 3536 : 			LogAddTD("[Mu_2Anv_Event] Error : iGiftNumber is Out of Boud [%d]",

  01c3f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01c42	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01c45	51		 push	 ecx
  01c46	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@MNCKIFPI@?$FLMu_2Anv_Event?$FN?5Error?5?3?5iGiftNu@
  01c4b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01c51	83 c4 08	 add	 esp, 8
$LN2@EGRecv2Anv:

; 3537 : 				aRecv->iGiftNumber
; 3538 : 				);
; 3539 : 			break;
; 3540 : 		}
; 3541 : #endif // COUPON_EVENT_ITEMLIST_20081022
; 3542 : 	}

  01c54	eb 61		 jmp	 SHORT $LN27@EGRecv2Anv
$LN26@EGRecv2Anv:

; 3543 : 	else if (
; 3544 : 		aRecv->btIsRegistered == 1 ||	// 이미 등록된 시리얼
; 3545 : 		aRecv->btIsRegistered == 2 ||	// 등록 횟수 초과
; 3546 : 		aRecv->btIsRegistered == 3 ||	// 없는 시리얼
; 3547 : 		aRecv->btIsRegistered == 4 ||	// 알 수 없는 에러

  01c56	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01c59	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  01c5d	83 f9 01	 cmp	 ecx, 1
  01c60	74 30		 je	 SHORT $LN102@EGRecv2Anv
  01c62	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01c65	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  01c69	83 f9 02	 cmp	 ecx, 2
  01c6c	74 24		 je	 SHORT $LN102@EGRecv2Anv
  01c6e	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01c71	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  01c75	83 f9 03	 cmp	 ecx, 3
  01c78	74 18		 je	 SHORT $LN102@EGRecv2Anv
  01c7a	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01c7d	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  01c81	83 f9 04	 cmp	 ecx, 4
  01c84	74 0c		 je	 SHORT $LN102@EGRecv2Anv
  01c86	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01c89	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  01c8d	83 f9 05	 cmp	 ecx, 5
  01c90	75 0b		 jne	 SHORT $LN100@EGRecv2Anv
$LN102@EGRecv2Anv:

; 3548 : 		aRecv->btIsRegistered == 5		// 나는 전에 시리얼을 등록했었다
; 3549 : 		)
; 3550 : 	{
; 3551 : 		Result.btIsRegistered = aRecv->btIsRegistered;

  01c92	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01c95	8a 48 13	 mov	 cl, BYTE PTR [eax+19]
  01c98	88 4d b7	 mov	 BYTE PTR _Result$[ebp+3], cl

; 3552 : 	}

  01c9b	eb 1a		 jmp	 SHORT $LN27@EGRecv2Anv
$LN100@EGRecv2Anv:

; 3553 : 	else {
; 3554 : 		Result.btIsRegistered = 4;

  01c9d	c6 45 b7 04	 mov	 BYTE PTR _Result$[ebp+3], 4

; 3555 : 		LogAddTD("[Mu_2Anv_Event] Error : Result Value is Wrong [%d]",

  01ca1	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01ca4	0f b6 48 13	 movzx	 ecx, BYTE PTR [eax+19]
  01ca8	51		 push	 ecx
  01ca9	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@BPJEDJME@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Result?5@
  01cae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01cb4	83 c4 08	 add	 esp, 8
$LN27@EGRecv2Anv:

; 3556 : 			aRecv->btIsRegistered
; 3557 : 			);
; 3558 : 	}
; 3559 : 
; 3560 : #ifdef ADD_COUPON_EVENTITEM_LOG
; 3561 : 	LogAddTD("[Mu_2Anv_Event] Register Serial Result : %d [%s][%s] GiftNumber: %d Item : %d",

  01cb7	8b 45 f8	 mov	 eax, DWORD PTR _nItemNumber$[ebp]
  01cba	50		 push	 eax
  01cbb	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01cbe	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  01cc1	52		 push	 edx
  01cc2	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01cc5	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01ccc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01cd2	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  01cd6	50		 push	 eax
  01cd7	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  01cda	69 51 04 a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+4], 7072
  01ce1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01ce6	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  01cea	51		 push	 ecx
  01ceb	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01cee	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  01cf2	50		 push	 eax
  01cf3	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@IOBIPNI@?$FLMu_2Anv_Event?$FN?5Register?5Serial@
  01cf8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01cfe	83 c4 18	 add	 esp, 24			; 00000018H

; 3562 : 		aRecv->btIsRegistered,
; 3563 : 		gObj[aRecv->iINDEX].AccountID,
; 3564 : 		gObj[aRecv->iINDEX].Name, 
; 3565 : 		aRecv->iGiftNumber, 
; 3566 : 		nItemNumber
; 3567 : 		);
; 3568 : #else
; 3569 : 	LogAddTD("[Mu_2Anv_Event] Register Serial Result : %d [%s][%s]",
; 3570 : 		aRecv->btIsRegistered,
; 3571 : 		gObj[aRecv->iINDEX].AccountID,
; 3572 : 		gObj[aRecv->iINDEX].Name
; 3573 : 		);
; 3574 : #endif // ADD_COUPON_EVENTITEM_LOG
; 3575 : 	
; 3576 : 	DataSend(aRecv->iINDEX, (LPBYTE)&Result, Result.h.size);

  01d01	0f b6 45 b5	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  01d05	50		 push	 eax
  01d06	8d 4d b4	 lea	 ecx, DWORD PTR _Result$[ebp]
  01d09	51		 push	 ecx
  01d0a	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  01d0d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01d10	50		 push	 eax
  01d11	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01d16	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3577 : 	gObj[aRecv->iINDEX].UseEventServer = FALSE;

  01d19	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  01d1c	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  01d23	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01d29	c7 84 0a 84 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+3716], 0
$LN1@EGRecv2Anv:

; 3578 : }

  01d34	5f		 pop	 edi
  01d35	5e		 pop	 esi
  01d36	5b		 pop	 ebx
  01d37	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d3a	33 cd		 xor	 ecx, ebp
  01d3c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01d41	8b e5		 mov	 esp, ebp
  01d43	5d		 pop	 ebp
  01d44	c3		 ret	 0
  01d45	0f 1f 00	 npad	 3
$LN116@EGRecv2Anv:
  01d48	00 00 00 00	 DD	 $LN31@EGRecv2Anv
  01d4c	00 00 00 00	 DD	 $LN33@EGRecv2Anv
  01d50	00 00 00 00	 DD	 $LN35@EGRecv2Anv
  01d54	00 00 00 00	 DD	 $LN37@EGRecv2Anv
  01d58	00 00 00 00	 DD	 $LN39@EGRecv2Anv
  01d5c	00 00 00 00	 DD	 $LN41@EGRecv2Anv
  01d60	00 00 00 00	 DD	 $LN43@EGRecv2Anv
  01d64	00 00 00 00	 DD	 $LN45@EGRecv2Anv
  01d68	00 00 00 00	 DD	 $LN45@EGRecv2Anv
  01d6c	00 00 00 00	 DD	 $LN45@EGRecv2Anv
  01d70	00 00 00 00	 DD	 $LN47@EGRecv2Anv
  01d74	00 00 00 00	 DD	 $LN49@EGRecv2Anv
  01d78	00 00 00 00	 DD	 $LN51@EGRecv2Anv
  01d7c	00 00 00 00	 DD	 $LN53@EGRecv2Anv
  01d80	00 00 00 00	 DD	 $LN55@EGRecv2Anv
  01d84	00 00 00 00	 DD	 $LN57@EGRecv2Anv
  01d88	00 00 00 00	 DD	 $LN59@EGRecv2Anv
  01d8c	00 00 00 00	 DD	 $LN61@EGRecv2Anv
  01d90	00 00 00 00	 DD	 $LN63@EGRecv2Anv
  01d94	00 00 00 00	 DD	 $LN65@EGRecv2Anv
  01d98	00 00 00 00	 DD	 $LN67@EGRecv2Anv
  01d9c	00 00 00 00	 DD	 $LN69@EGRecv2Anv
  01da0	00 00 00 00	 DD	 $LN71@EGRecv2Anv
  01da4	00 00 00 00	 DD	 $LN73@EGRecv2Anv
  01da8	00 00 00 00	 DD	 $LN75@EGRecv2Anv
  01dac	00 00 00 00	 DD	 $LN77@EGRecv2Anv
  01db0	00 00 00 00	 DD	 $LN79@EGRecv2Anv
  01db4	00 00 00 00	 DD	 $LN81@EGRecv2Anv
  01db8	00 00 00 00	 DD	 $LN83@EGRecv2Anv
  01dbc	00 00 00 00	 DD	 $LN85@EGRecv2Anv
  01dc0	00 00 00 00	 DD	 $LN87@EGRecv2Anv
  01dc4	00 00 00 00	 DD	 $LN89@EGRecv2Anv
  01dc8	00 00 00 00	 DD	 $LN91@EGRecv2Anv
  01dcc	00 00 00 00	 DD	 $LN93@EGRecv2Anv
  01dd0	00 00 00 00	 DD	 $LN93@EGRecv2Anv
  01dd4	00 00 00 00	 DD	 $LN93@EGRecv2Anv
  01dd8	00 00 00 00	 DD	 $LN93@EGRecv2Anv
  01ddc	00 00 00 00	 DD	 $LN95@EGRecv2Anv
  01de0	00 00 00 00	 DD	 $LN95@EGRecv2Anv
  01de4	00 00 00 00	 DD	 $LN97@EGRecv2Anv
  01de8	00 00 00 00	 DD	 $LN97@EGRecv2Anv
  01dec	00 00 00 00	 DD	 $LN97@EGRecv2Anv
  01df0	00 00 00 00	 DD	 $LN97@EGRecv2Anv
  01df4	00 00 00 00	 DD	 $LN97@EGRecv2Anv
?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z ENDP ; EGRecv2AnvRegSerial
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z
_TEXT	SEGMENT
_aIndex$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_Result$ = -8						; size = 6
_aRecv$ = 8						; size = 4
?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z PROC ; EGRecvChangeStones, COMDAT

; 2810 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2811 : 	PMSG_REGEVENTCHIP_RESULT Result;
; 2812 : 	PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00009	6a 06		 push	 6
  0000b	68 95 00 00 00	 push	 149			; 00000095H
  00010	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2813 : 
; 2814 : 	LPOBJECTSTRUCT lpObj = &gObj[aRecv->iINDEX];	

  0001c	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0001f	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00026	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002c	89 4d f4	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 2815 : 	int aIndex = aRecv->iINDEX;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	89 4d f0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2816 : 
; 2817 : 	if( aRecv->bSUCCESS )

  00038	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0003b	0f be 48 13	 movsx	 ecx, BYTE PTR [eax+19]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 61		 je	 SHORT $LN2@EGRecvChan

; 2818 : 	{	// 스톤 환전
; 2819 : 		lpObj->Money += lpObj->iStoneCount*3000;

  00043	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	69 88 8c 0e 00
	00 b8 0b 00 00	 imul	 ecx, DWORD PTR [eax+3724], 3000
  00050	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00053	03 8a b0 00 00
	00		 add	 ecx, DWORD PTR [edx+176]
  00059	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005c	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx

; 2820 : 
; 2821 : 		GCMoneySend(aIndex, lpObj->Money);

  00062	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00065	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0006b	51		 push	 ecx
  0006c	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00075	83 c4 08	 add	 esp, 8

; 2822 : 		LogAddTD("[Stones] [%s][%s] ChangeRena AddMoney(%d)", 

  00078	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007b	69 88 8c 0e 00
	00 b8 0b 00 00	 imul	 ecx, DWORD PTR [eax+3724], 3000
  00085	51		 push	 ecx
  00086	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00089	83 c2 73	 add	 edx, 115		; 00000073H
  0008c	52		 push	 edx
  0008d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00090	83 c0 68	 add	 eax, 104		; 00000068H
  00093	50		 push	 eax
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KDDNBJOH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Ad@
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0009f	83 c4 10	 add	 esp, 16			; 00000010H

; 2823 : 			      lpObj->AccountID, lpObj->Name, lpObj->iStoneCount*3000);
; 2824 : 	}

  000a2	eb 1c		 jmp	 SHORT $LN3@EGRecvChan
$LN2@EGRecvChan:

; 2825 : 	else
; 2826 : 	{
; 2827 : 		LogAddTD("[Stones] [%s][%s] ChangeRena Fail", 

  000a4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a7	83 c0 73	 add	 eax, 115		; 00000073H
  000aa	50		 push	 eax
  000ab	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ae	83 c1 68	 add	 ecx, 104		; 00000068H
  000b1	51		 push	 ecx
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FLCEMGDH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Fa@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@EGRecvChan:

; 2828 : 			      lpObj->AccountID, lpObj->Name);
; 2829 : 	}
; 2830 : 	
; 2831 : 	Result.ChipCount = 0;

  000c0	33 c0		 xor	 eax, eax
  000c2	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax

; 2832 : 	lpObj->iStoneCount = 0;

  000c6	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c9	c7 80 8c 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3724], 0

; 2833 : 
; 2834 : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000d3	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  000d7	50		 push	 eax
  000d8	8d 4d f8	 lea	 ecx, DWORD PTR _Result$[ebp]
  000db	51		 push	 ecx
  000dc	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000df	52		 push	 edx
  000e0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2835 : 	lpObj->UseEventServer = FALSE;

  000e8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000eb	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0

; 2836 : }

  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ENDP ; EGRecvChangeStones
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGRecvDeleteStone@@YAXPAUPMSG_ANS_DELETE_STONES@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?EGRecvDeleteStone@@YAXPAUPMSG_ANS_DELETE_STONES@@@Z PROC ; EGRecvDeleteStone, COMDAT

; 2801 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2802 : 
; 2803 : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?EGRecvDeleteStone@@YAXPAUPMSG_ANS_DELETE_STONES@@@Z ENDP ; EGRecvDeleteStone
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z
_TEXT	SEGMENT
_aIndex$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_Result$ = -8						; size = 6
_aRecv$ = 8						; size = 4
?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z PROC ; EGRecvRegStone, COMDAT

; 2776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2777 : 	PMSG_REGEVENTCHIP_RESULT Result;
; 2778 : 	PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00009	6a 06		 push	 6
  0000b	68 95 00 00 00	 push	 149			; 00000095H
  00010	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2779 : 
; 2780 : 	LPOBJECTSTRUCT lpObj = &gObj[aRecv->iINDEX];	

  0001c	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0001f	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00026	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002c	89 4d f4	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 2781 : 	int aIndex = aRecv->iINDEX;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	89 4d f0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2782 : 
; 2783 : 	if(aRecv->bSUCCESS) {

  00038	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0003b	0f be 48 14	 movsx	 ecx, BYTE PTR [eax+20]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 53		 je	 SHORT $LN2@EGRecvRegS

; 2784 : 		Result.ChipCount = aRecv->iStoneCount;

  00043	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00046	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  0004a	66 89 4d fc	 mov	 WORD PTR _Result$[ebp+4], cx

; 2785 : 		gObjInventoryDeleteItem(aIndex, aRecv->iPosition);

  0004e	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00051	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00055	51		 push	 ecx
  00056	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0005f	83 c4 08	 add	 esp, 8

; 2786 : 		GCInventoryItemDeleteSend(aIndex, aRecv->iPosition, 1);

  00062	6a 01		 push	 1
  00064	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00067	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0006b	51		 push	 ecx
  0006c	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2787 : 		LogAddTD("[Stone] [%s][%s] Delete Stones", lpObj->AccountID, lpObj->Name);

  00078	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007b	83 c0 73	 add	 eax, 115		; 00000073H
  0007e	50		 push	 eax
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00082	83 c1 68	 add	 ecx, 104		; 00000068H
  00085	51		 push	 ecx
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@HIMCGJFF@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Stones@
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2788 : 	}

  00094	eb 2a		 jmp	 SHORT $LN3@EGRecvRegS
$LN2@EGRecvRegS:

; 2789 : 	else {
; 2790 : 		Result.ChipCount = -1;

  00096	83 c8 ff	 or	 eax, -1
  00099	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax

; 2791 : 		LogAddTD("[Stone] [%s][%s] RegEventServer Fail (Stones : %d)", lpObj->AccountID, lpObj->Name, aRecv->iStoneCount);

  0009d	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000a0	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000a3	51		 push	 ecx
  000a4	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a7	83 c2 73	 add	 edx, 115		; 00000073H
  000aa	52		 push	 edx
  000ab	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ae	83 c0 68	 add	 eax, 104		; 00000068H
  000b1	50		 push	 eax
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@JDHGBHBI@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventServer@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bd	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@EGRecvRegS:

; 2792 : 	}
; 2793 : 
; 2794 : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000c0	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  000c4	50		 push	 eax
  000c5	8d 4d f8	 lea	 ecx, DWORD PTR _Result$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2795 : 	lpObj->UseEventServer = FALSE;

  000d5	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d8	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0

; 2796 : }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z ENDP ; EGRecvRegStone
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z
_TEXT	SEGMENT
_msg$ = -148						; size = 128
_Result$ = -20						; size = 12
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z PROC	; EGRecvStoneInfo, COMDAT

; 2739 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2740 : 	LPOBJECTSTRUCT lpObj = &gObj[aRecv->iINDEX];	

  00016	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00019	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00020	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00026	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 2741 : 
; 2742 : 	PMSG_EVENTCHIPINFO	Result;
; 2743 : 	PHeadSetB((LPBYTE)&Result, 0x94, sizeof(Result));

  00029	6a 0c		 push	 12			; 0000000cH
  0002b	68 94 00 00 00	 push	 148			; 00000094H
  00030	8d 45 ec	 lea	 eax, DWORD PTR _Result$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2744 : 
; 2745 : 	#ifdef FOR_STONE_EXCHANGE
; 2746 : 	if (aRecv->bSUCCESS)

  0003c	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0003f	0f be 48 13	 movsx	 ecx, BYTE PTR [eax+19]
  00043	85 c9		 test	 ecx, ecx
  00045	74 11		 je	 SHORT $LN2@EGRecvSton

; 2747 : 		lpObj->iStoneCount = aRecv->iStoneCount;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0004d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00050	89 90 8c 0e 00
	00		 mov	 DWORD PTR [eax+3724], edx
  00056	eb 0d		 jmp	 SHORT $LN3@EGRecvSton
$LN2@EGRecvSton:

; 2748 : 	else
; 2749 : 		lpObj->iStoneCount = 0;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005b	c7 80 8c 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3724], 0
$LN3@EGRecvSton:

; 2750 : 
; 2751 : 	lpObj->MutoNumber = 0;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00068	c7 80 80 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3712], 0

; 2752 : 
; 2753 : 	Result.Type = 3;	// 스톤환전 정보임

  00072	c6 45 ef 03	 mov	 BYTE PTR _Result$[ebp+3], 3

; 2754 : 	#else // else FOR_STONE_EXCHANGE
; 2755 : 	if (aRecv->bSUCCESS)
; 2756 : 		lpObj->EventChipCount = aRecv->iStoneCount;
; 2757 : 	else
; 2758 : 		lpObj->EventChipCount = 0;
; 2759 : 
; 2760 : 	lpObj->MutoNumber = 0;
; 2761 : 
; 2762 : 	Result.Type = 1;	// 스톤 정보임
; 2763 : 	#endif // FOR_STONE_EXCHANGE
; 2764 : 	Result.ChipCount = aRecv->iStoneCount;

  00076	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00079	66 8b 48 14	 mov	 cx, WORD PTR [eax+20]
  0007d	66 89 4d f0	 mov	 WORD PTR _Result$[ebp+4], cx

; 2765 : 
; 2766 : 	DataSend(lpObj->m_Index, (LPBYTE)&Result, Result.h.size);

  00081	0f b6 45 ed	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  00085	50		 push	 eax
  00086	8d 4d ec	 lea	 ecx, DWORD PTR _Result$[ebp]
  00089	51		 push	 ecx
  0008a	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0008d	8b 02		 mov	 eax, DWORD PTR [edx]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2767 : 
; 2768 : 	char msg [128];
; 2769 : 	wsprintf(msg, lMsg.Get(1177), Result.ChipCount);		// "당신이 등록한 스톤개수는 현재 %d개 입니다."

  00098	0f b7 45 f0	 movzx	 eax, WORD PTR _Result$[ebp+4]
  0009c	50		 push	 eax
  0009d	68 99 04 00 00	 push	 1177			; 00000499H
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000ad	50		 push	 eax
  000ae	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _msg$[ebp]
  000b4	51		 push	 ecx
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2770 : 	ChatTargetSend(pEventObj, msg, lpObj->m_Index);

  000be	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c3	51		 push	 ecx
  000c4	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _msg$[ebp]
  000ca	52		 push	 edx
  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pEventObj@@3PAVOBJECTSTRUCT@@A ; pEventObj
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2771 : }

  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	33 cd		 xor	 ecx, ebp
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z ENDP	; EGRecvStoneInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z
_TEXT	SEGMENT
_aIndex$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_Result$ = -8						; size = 6
_aRecv$ = 8						; size = 4
?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z PROC ; EGRecvChangeRena, COMDAT

; 2706 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2707 : 	PMSG_REGEVENTCHIP_RESULT Result;
; 2708 : 	PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00009	6a 06		 push	 6
  0000b	68 95 00 00 00	 push	 149			; 00000095H
  00010	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2709 : 
; 2710 : 	LPOBJECTSTRUCT lpObj = &gObj[aRecv->iINDEX];	

  0001c	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0001f	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00026	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002c	89 4d f4	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 2711 : 	int aIndex = aRecv->iINDEX;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	89 4d f0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2712 : 
; 2713 : 	if( aRecv->bSUCCESS )

  00038	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0003b	0f be 48 13	 movsx	 ecx, BYTE PTR [eax+19]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 67		 je	 SHORT $LN2@EGRecvChan

; 2714 : 	{	// 레나 환전
; 2715 : 		lpObj->Money += lpObj->EventChipCount*3000;

  00043	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	0f bf 88 7c 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3708]
  0004d	69 d1 b8 0b 00
	00		 imul	 edx, ecx, 3000
  00053	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	03 90 b0 00 00
	00		 add	 edx, DWORD PTR [eax+176]
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0005f	89 91 b0 00 00
	00		 mov	 DWORD PTR [ecx+176], edx

; 2716 : 
; 2717 : 		GCMoneySend(aIndex, lpObj->Money);

  00065	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00068	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  0006e	51		 push	 ecx
  0006f	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00078	83 c4 08	 add	 esp, 8

; 2718 : 		LogAddTD("[EventChip] [%s][%s] ChangeRena AddMoney(%d)", 

  0007b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007e	0f bf 88 7c 0e
	00 00		 movsx	 ecx, WORD PTR [eax+3708]
  00085	69 d1 b8 0b 00
	00		 imul	 edx, ecx, 3000
  0008b	52		 push	 edx
  0008c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008f	83 c0 73	 add	 eax, 115		; 00000073H
  00092	50		 push	 eax
  00093	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00096	83 c1 68	 add	 ecx, 104		; 00000068H
  00099	51		 push	 ecx
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HPMMCJJA@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena@
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a5	83 c4 10	 add	 esp, 16			; 00000010H

; 2719 : 			      lpObj->AccountID, lpObj->Name, lpObj->EventChipCount*3000);
; 2720 : 	}

  000a8	eb 1c		 jmp	 SHORT $LN3@EGRecvChan
$LN2@EGRecvChan:

; 2721 : 	else
; 2722 : 	{
; 2723 : 		LogAddTD("[EventChip] [%s][%s] ChangeRena Fail", 

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ad	83 c0 73	 add	 eax, 115		; 00000073H
  000b0	50		 push	 eax
  000b1	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b4	83 c1 68	 add	 ecx, 104		; 00000068H
  000b7	51		 push	 ecx
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KMDOMHEE@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena@
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@EGRecvChan:

; 2724 : 			      lpObj->AccountID, lpObj->Name);
; 2725 : 	}
; 2726 : 	
; 2727 : 	Result.ChipCount = 0;

  000c6	33 c0		 xor	 eax, eax
  000c8	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax

; 2728 : 	lpObj->EventChipCount = 0;

  000cc	33 c0		 xor	 eax, eax
  000ce	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d1	66 89 81 7c 0e
	00 00		 mov	 WORD PTR [ecx+3708], ax

; 2729 : 
; 2730 : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000d8	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  000dc	50		 push	 eax
  000dd	8d 4d f8	 lea	 ecx, DWORD PTR _Result$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2731 : 	lpObj->UseEventServer = FALSE;

  000ed	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f0	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0

; 2732 : }

  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ENDP ; EGRecvChangeRena
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z
_TEXT	SEGMENT
_Result$ = -24						; size = 10
_aIndex$ = -12						; size = 4
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z PROC ; EGRecvRegMutoNum, COMDAT

; 2665 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 2666 : 	LPOBJECTSTRUCT lpObj = &gObj[aRecv->iINDEX];	

  00013	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00016	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  0001d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 2667 : 	int aIndex = aRecv->iINDEX;

  00026	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	89 4d f4	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2668 : 
; 2669 : 	PMSG_GETMUTONUMBER_RESULT Result;
; 2670 : 	PHeadSetB((LPBYTE)&Result, 0x96, sizeof(Result));	

  0002f	6a 0a		 push	 10			; 0000000aH
  00031	68 96 00 00 00	 push	 150			; 00000096H
  00036	8d 45 e8	 lea	 eax, DWORD PTR _Result$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2671 : 
; 2672 : 	if( !gObjFind10EventChip(aIndex) )

  00042	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?gObjFind10EventChip@@YAHH@Z ; gObjFind10EventChip
  0004b	83 c4 04	 add	 esp, 4
  0004e	85 c0		 test	 eax, eax
  00050	75 54		 jne	 SHORT $LN2@EGRecvRegM

; 2673 : 	{	// 아이템 열개가 없다		
; 2674 : 		Result.MutoNum[0] = -1;

  00052	b8 02 00 00 00	 mov	 eax, 2
  00057	6b c8 00	 imul	 ecx, eax, 0
  0005a	83 ca ff	 or	 edx, -1
  0005d	66 89 54 0d ec	 mov	 WORD PTR _Result$[ebp+ecx+4], dx

; 2675 : 		Result.MutoNum[1] = 0;

  00062	b8 02 00 00 00	 mov	 eax, 2
  00067	c1 e0 00	 shl	 eax, 0
  0006a	33 c9		 xor	 ecx, ecx
  0006c	66 89 4c 05 ec	 mov	 WORD PTR _Result$[ebp+eax+4], cx

; 2676 : 		Result.MutoNum[2] = 0;

  00071	b8 02 00 00 00	 mov	 eax, 2
  00076	d1 e0		 shl	 eax, 1
  00078	33 c9		 xor	 ecx, ecx
  0007a	66 89 4c 05 ec	 mov	 WORD PTR _Result$[ebp+eax+4], cx

; 2677 : 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  0007f	0f b6 45 e9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  00083	50		 push	 eax
  00084	8d 4d e8	 lea	 ecx, DWORD PTR _Result$[ebp]
  00087	51		 push	 ecx
  00088	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2678 : 		lpObj->UseEventServer = FALSE;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00097	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0

; 2679 : 		return;

  000a1	e9 ea 00 00 00	 jmp	 $LN1@EGRecvRegM
$LN2@EGRecvRegM:

; 2680 : 	}
; 2681 : 
; 2682 : 	// 이벤트 칩 열개를 지운다
; 2683 : 	gObjDelete10EventChip(aIndex);

  000a6	8b 45 f4	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ?gObjDelete10EventChip@@YAHH@Z ; gObjDelete10EventChip
  000af	83 c4 04	 add	 esp, 4

; 2684 : 	
; 2685 : 	Result.MutoNum[0] = GETMUTONUM1(aRecv->iMUTO_NUM);

  000b2	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000b5	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000b8	99		 cdq
  000b9	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  000be	f7 f9		 idiv	 ecx
  000c0	ba 02 00 00 00	 mov	 edx, 2
  000c5	6b ca 00	 imul	 ecx, edx, 0
  000c8	66 89 44 0d ec	 mov	 WORD PTR _Result$[ebp+ecx+4], ax

; 2686 : 	Result.MutoNum[1] = GETMUTONUM2(aRecv->iMUTO_NUM);

  000cd	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000d0	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000d3	99		 cdq
  000d4	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  000d9	f7 f9		 idiv	 ecx
  000db	8b c8		 mov	 ecx, eax
  000dd	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  000e0	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000e3	99		 cdq
  000e4	be 40 42 0f 00	 mov	 esi, 1000000		; 000f4240H
  000e9	f7 fe		 idiv	 esi
  000eb	69 c0 e8 03 00
	00		 imul	 eax, eax, 1000
  000f1	2b c8		 sub	 ecx, eax
  000f3	ba 02 00 00 00	 mov	 edx, 2
  000f8	c1 e2 00	 shl	 edx, 0
  000fb	66 89 4c 15 ec	 mov	 WORD PTR _Result$[ebp+edx+4], cx

; 2687 : 	Result.MutoNum[2] = GETMUTONUM3(aRecv->iMUTO_NUM);	

  00100	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00103	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00106	99		 cdq
  00107	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0010c	f7 f9		 idiv	 ecx
  0010e	b8 02 00 00 00	 mov	 eax, 2
  00113	d1 e0		 shl	 eax, 1
  00115	66 89 54 05 ec	 mov	 WORD PTR _Result$[ebp+eax+4], dx

; 2688 : 
; 2689 : 	lpObj->MutoNumber = aRecv->iMUTO_NUM;

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00120	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00123	89 90 80 0e 00
	00		 mov	 DWORD PTR [eax+3712], edx

; 2690 : 
; 2691 : 	LogAddTD("[EventChip] [%s][%s] Make MutoNumber %d,%d,%d", 

  00129	b8 02 00 00 00	 mov	 eax, 2
  0012e	d1 e0		 shl	 eax, 1
  00130	0f bf 4c 05 ec	 movsx	 ecx, WORD PTR _Result$[ebp+eax+4]
  00135	51		 push	 ecx
  00136	ba 02 00 00 00	 mov	 edx, 2
  0013b	c1 e2 00	 shl	 edx, 0
  0013e	0f bf 44 15 ec	 movsx	 eax, WORD PTR _Result$[ebp+edx+4]
  00143	50		 push	 eax
  00144	b9 02 00 00 00	 mov	 ecx, 2
  00149	6b d1 00	 imul	 edx, ecx, 0
  0014c	0f bf 44 15 ec	 movsx	 eax, WORD PTR _Result$[ebp+edx+4]
  00151	50		 push	 eax
  00152	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00155	83 c1 73	 add	 ecx, 115		; 00000073H
  00158	51		 push	 ecx
  00159	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015c	83 c2 68	 add	 edx, 104		; 00000068H
  0015f	52		 push	 edx
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@PLMPLCLH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5MutoN@
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0016b	83 c4 18	 add	 esp, 24			; 00000018H

; 2692 : 			 lpObj->AccountID, lpObj->Name, Result.MutoNum[0], Result.MutoNum[1], Result.MutoNum[2]);
; 2693 : 
; 2694 : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  0016e	0f b6 45 e9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  00172	50		 push	 eax
  00173	8d 4d e8	 lea	 ecx, DWORD PTR _Result$[ebp]
  00176	51		 push	 ecx
  00177	8b 55 f4	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0017a	52		 push	 edx
  0017b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2695 : 	
; 2696 : #ifdef FOR_CHINA
; 2697 : 	lpObj->Money += (3300*10);
; 2698 : 	GCMoneySend(aIndex, lpObj->Money);
; 2699 : #endif // FOR CHINA
; 2700 : 
; 2701 : 	lpObj->UseEventServer = FALSE;

  00183	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00186	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0
$LN1@EGRecvRegM:

; 2702 : }

  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	5b		 pop	 ebx
  00193	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00196	33 cd		 xor	 ecx, ebp
  00198	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c3		 ret	 0
?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z ENDP ; EGRecvRegMutoNum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z
_TEXT	SEGMENT
_aIndex$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_Result$ = -8						; size = 6
_aRecv$ = 8						; size = 4
?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z PROC ; EGResultRegEventChip, COMDAT

; 2630 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2631 : 	PMSG_REGEVENTCHIP_RESULT Result;
; 2632 : 	PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00009	6a 06		 push	 6
  0000b	68 95 00 00 00	 push	 149			; 00000095H
  00010	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2633 : 
; 2634 : 	LPOBJECTSTRUCT lpObj = &gObj[aRecv->iINDEX];	

  0001c	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0001f	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00026	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002c	89 4d f4	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 2635 : 	int aIndex = aRecv->iINDEX;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00032	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00035	89 4d f0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 2636 : 
; 2637 : 	if( aRecv->bSUCCESS == FALSE )

  00038	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0003b	0f be 48 14	 movsx	 ecx, BYTE PTR [eax+20]
  0003f	85 c9		 test	 ecx, ecx
  00041	75 2d		 jne	 SHORT $LN2@EGResultRe

; 2638 : 	{
; 2639 : 		Result.ChipCount = -1;

  00043	83 c8 ff	 or	 eax, -1
  00046	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax

; 2640 : 		LogAddTD("[EventChip] [%s][%s] RegEventServer Fail (RegEventchip) %d", 

  0004a	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0004d	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00051	51		 push	 ecx
  00052	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00055	83 c2 73	 add	 edx, 115		; 00000073H
  00058	52		 push	 edx
  00059	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005c	83 c0 68	 add	 eax, 104		; 00000068H
  0005f	50		 push	 eax
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@NPJNKEPH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventSe@
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0006b	83 c4 10	 add	 esp, 16			; 00000010H

; 2641 : 			   lpObj->AccountID, lpObj->Name, aRecv->Pos);
; 2642 : 	}

  0006e	eb 59		 jmp	 SHORT $LN3@EGResultRe
$LN2@EGResultRe:

; 2643 : 	else
; 2644 : 	{
; 2645 : 		Result.ChipCount = aRecv->nEVENT_CHIPS;

  00070	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00073	66 8b 48 16	 mov	 cx, WORD PTR [eax+22]
  00077	66 89 4d fc	 mov	 WORD PTR _Result$[ebp+4], cx

; 2646 : 		gObjInventoryDeleteItem(aIndex, aRecv->Pos);

  0007b	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0007e	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00082	51		 push	 ecx
  00083	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0008c	83 c4 08	 add	 esp, 8

; 2647 : 		GCInventoryItemDeleteSend(aIndex, aRecv->Pos, 1);

  0008f	6a 01		 push	 1
  00091	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00094	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00098	51		 push	 ecx
  00099	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2648 : 		LogAddTD("[EventChip] [%s][%s] Delete EventChip (%d)", lpObj->AccountID, lpObj->Name, aRecv->Pos);

  000a5	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000a8	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  000ac	51		 push	 ecx
  000ad	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b0	83 c2 73	 add	 edx, 115		; 00000073H
  000b3	52		 push	 edx
  000b4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b7	83 c0 68	 add	 eax, 104		; 00000068H
  000ba	50		 push	 eax
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@GENGFGNN@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Eve@
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c6	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@EGResultRe:

; 2649 : 	}
; 2650 : 
; 2651 : 	Result.Type = 0;

  000c9	c6 45 fb 00	 mov	 BYTE PTR _Result$[ebp+3], 0

; 2652 : 	
; 2653 : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000cd	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  000d1	50		 push	 eax
  000d2	8d 4d f8	 lea	 ecx, DWORD PTR _Result$[ebp]
  000d5	51		 push	 ecx
  000d6	8b 55 f0	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000d9	52		 push	 edx
  000da	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2654 : 
; 2655 : #ifdef FOR_CHINA
; 2656 : 	lpObj->Money += 3300;
; 2657 : 	GCMoneySend(aIndex, lpObj->Money);
; 2658 : #endif // FOR CHINA
; 2659 : 
; 2660 : 	lpObj->UseEventServer = FALSE;

  000e2	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e5	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0

; 2661 : }

  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	c3		 ret	 0
?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z ENDP ; EGResultRegEventChip
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z
_TEXT	SEGMENT
_msg$ = -276						; size = 255
_eventchipeventinfo$ = -20				; size = 12
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z PROC ; EGRecvEventChipInfo, COMDAT

; 2558 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2559 : 	LPOBJECTSTRUCT lpObj = &gObj[aRecv->iINDEX];	

  00016	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00019	69 48 04 a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax+4], 7072
  00020	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00026	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 2560 : 
; 2561 : 	PMSG_EVENTCHIPINFO	eventchipeventinfo;
; 2562 : 	PHeadSetB((LPBYTE)&eventchipeventinfo, 0x94, sizeof(eventchipeventinfo));

  00029	6a 0c		 push	 12			; 0000000cH
  0002b	68 94 00 00 00	 push	 148			; 00000094H
  00030	8d 45 ec	 lea	 eax, DWORD PTR _eventchipeventinfo$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2563 : 
; 2564 : 	eventchipeventinfo.Type	= 0; // bugfix_alice_050113 : Related keyword ' FOR_BLOODCASTLE & PMSG_EVENTCHIPINFO '

  0003c	c6 45 ef 00	 mov	 BYTE PTR _eventchipeventinfo$[ebp+3], 0

; 2565 : 	eventchipeventinfo.ChipCount = aRecv->nEVENT_CHIPS;

  00040	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00043	66 8b 48 14	 mov	 cx, WORD PTR [eax+20]
  00047	66 89 4d f0	 mov	 WORD PTR _eventchipeventinfo$[ebp+4], cx

; 2566 : 
; 2567 : 	lpObj->EventChipCount = aRecv->nEVENT_CHIPS;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00051	66 8b 51 14	 mov	 dx, WORD PTR [ecx+20]
  00055	66 89 90 7c 0e
	00 00		 mov	 WORD PTR [eax+3708], dx

; 2568 : 	lpObj->MutoNumber = aRecv->iMUTO_NUM;

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00062	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00065	89 90 80 0e 00
	00		 mov	 DWORD PTR [eax+3712], edx

; 2569 : 
; 2570 : #ifdef FOR_CHINA
; 2571 : 	eventchipeventinfo.Type = 0;
; 2572 : #endif // FOR CHINA
; 2573 : 	
; 2574 : #ifdef EVENT_RENA_FOR_CASTLE_SIEGE_20041116
; 2575 : 	eventchipeventinfo.Type = 0;
; 2576 : 	DataSend(lpObj->m_Index, (LPBYTE)&eventchipeventinfo, eventchipeventinfo.h.size);
; 2577 : 	return;
; 2578 : #endif // EVENT_RENA_FOR_CASTLE_SIEGE_20041116
; 2579 : 
; 2580 : #ifdef EVENT_RENA_20040909
; 2581 : 	DataSend(lpObj->m_Index, (LPBYTE)&eventchipeventinfo, eventchipeventinfo.h.size);			

  0006b	0f b6 45 ed	 movzx	 eax, BYTE PTR _eventchipeventinfo$[ebp+1]
  0006f	50		 push	 eax
  00070	8d 4d ec	 lea	 ecx, DWORD PTR _eventchipeventinfo$[ebp]
  00073	51		 push	 ecx
  00074	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00077	8b 02		 mov	 eax, DWORD PTR [edx]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2582 : 	lpObj->UseEventServer = FALSE; // bugfix_alice_050113

  00082	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00085	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0

; 2583 : 	return;

  0008f	e9 8e 01 00 00	 jmp	 $LN1@EGRecvEven

; 2584 : #endif // EVENT_RENA_20040909
; 2585 : 
; 2586 : #ifdef EVENT_STONE
; 2587 : 	DataSend(lpObj->m_Index, (LPBYTE)&eventchipeventinfo, eventchipeventinfo.h.size);

  00094	0f b6 45 ed	 movzx	 eax, BYTE PTR _eventchipeventinfo$[ebp+1]
  00098	50		 push	 eax
  00099	8d 4d ec	 lea	 ecx, DWORD PTR _eventchipeventinfo$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a0	8b 02		 mov	 eax, DWORD PTR [edx]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2588 : 	lpObj->UseEventServer = FALSE; // bugfix_alice_050113

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ae	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0

; 2589 : 	return;

  000b8	e9 65 01 00 00	 jmp	 $LN1@EGRecvEven

; 2590 : #endif // EVENT_STONE
; 2591 : 
; 2592 : #if defined ( EVENT_FRIENDSHIP_20040204 ) || defined ( EVENT_LOTTO )
; 2593 : 	char msg[255];
; 2594 : 
; 2595 : 	if( aRecv->iMUTO_NUM != 0 )

  000bd	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000c0	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  000c4	0f 84 cc 00 00
	00		 je	 $LN2@EGRecvEven

; 2596 : 	{
; 2597 : 		eventchipeventinfo.MutoNum[0] = GETMUTONUM1(aRecv->iMUTO_NUM);

  000ca	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000cd	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000d0	99		 cdq
  000d1	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  000d6	f7 f9		 idiv	 ecx
  000d8	ba 02 00 00 00	 mov	 edx, 2
  000dd	6b ca 00	 imul	 ecx, edx, 0
  000e0	66 89 44 0d f2	 mov	 WORD PTR _eventchipeventinfo$[ebp+ecx+6], ax

; 2598 : 		eventchipeventinfo.MutoNum[1] = GETMUTONUM2(aRecv->iMUTO_NUM);

  000e5	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000e8	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000eb	99		 cdq
  000ec	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  000f1	f7 f9		 idiv	 ecx
  000f3	8b c8		 mov	 ecx, eax
  000f5	8b 55 08	 mov	 edx, DWORD PTR _aRecv$[ebp]
  000f8	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000fb	99		 cdq
  000fc	be 40 42 0f 00	 mov	 esi, 1000000		; 000f4240H
  00101	f7 fe		 idiv	 esi
  00103	69 c0 e8 03 00
	00		 imul	 eax, eax, 1000
  00109	2b c8		 sub	 ecx, eax
  0010b	ba 02 00 00 00	 mov	 edx, 2
  00110	c1 e2 00	 shl	 edx, 0
  00113	66 89 4c 15 f2	 mov	 WORD PTR _eventchipeventinfo$[ebp+edx+6], cx

; 2599 : 		eventchipeventinfo.MutoNum[2] = GETMUTONUM3(aRecv->iMUTO_NUM);

  00118	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0011b	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0011e	99		 cdq
  0011f	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00124	f7 f9		 idiv	 ecx
  00126	b8 02 00 00 00	 mov	 eax, 2
  0012b	d1 e0		 shl	 eax, 1
  0012d	66 89 54 05 f2	 mov	 WORD PTR _eventchipeventinfo$[ebp+eax+6], dx

; 2600 : 
; 2601 : 		if( pEventObj )

  00132	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?pEventObj@@3PAVOBJECTSTRUCT@@A, 0 ; pEventObj
  00139	74 59		 je	 SHORT $LN4@EGRecvEven

; 2602 : 		{
; 2603 : 			wsprintf(msg, "행운의 숫자는 %03d-%03d-%03d 입니다", 

  0013b	b8 02 00 00 00	 mov	 eax, 2
  00140	d1 e0		 shl	 eax, 1
  00142	0f bf 4c 05 f2	 movsx	 ecx, WORD PTR _eventchipeventinfo$[ebp+eax+6]
  00147	51		 push	 ecx
  00148	ba 02 00 00 00	 mov	 edx, 2
  0014d	c1 e2 00	 shl	 edx, 0
  00150	0f bf 44 15 f2	 movsx	 eax, WORD PTR _eventchipeventinfo$[ebp+edx+6]
  00155	50		 push	 eax
  00156	b9 02 00 00 00	 mov	 ecx, 2
  0015b	6b d1 00	 imul	 edx, ecx, 0
  0015e	0f bf 44 15 f2	 movsx	 eax, WORD PTR _eventchipeventinfo$[ebp+edx+6]
  00163	50		 push	 eax
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@JEOJAEAE@?G?$OA?$LP?n?$MA?G?5?$LM?$PN?$MA?Z?$LE?B?5?$CF03d?9?$CF03d?9?$CF03d?5?$MA?T@
  00169	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _msg$[ebp]
  0016f	51		 push	 ecx
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00176	83 c4 14	 add	 esp, 20			; 00000014H

; 2604 : 					 eventchipeventinfo.MutoNum[0], eventchipeventinfo.MutoNum[1], eventchipeventinfo.MutoNum[2]);
; 2605 : 			ChatTargetSend(pEventObj, msg, lpObj->m_Index);	// "살인자에겐 아무것도 팔 수 없네!!"

  00179	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017e	51		 push	 ecx
  0017f	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _msg$[ebp]
  00185	52		 push	 edx
  00186	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pEventObj@@3PAVOBJECTSTRUCT@@A ; pEventObj
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@EGRecvEven:

; 2606 : 		}
; 2607 : 	}

  00194	eb 68		 jmp	 SHORT $LN3@EGRecvEven
$LN2@EGRecvEven:

; 2608 : 	else
; 2609 : 	{
; 2610 : 		if( pEventObj )

  00196	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?pEventObj@@3PAVOBJECTSTRUCT@@A, 0 ; pEventObj
  0019d	74 30		 je	 SHORT $LN5@EGRecvEven

; 2611 : 		{
; 2612 : 			wsprintf(msg, "등록된 행운의 숫자가 없습니다");

  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IGEKNHOC@?$LF?n?$LH?O?$LF?H?5?G?$OA?$LP?n?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$LO?x?$LN?$MA?$LE?O?$LE?Y@
  001a4	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  001aa	50		 push	 eax
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001b1	83 c4 08	 add	 esp, 8

; 2613 : 			ChatTargetSend(pEventObj, msg, lpObj->m_Index);	// "살인자에겐 아무것도 팔 수 없네!!"

  001b4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b9	51		 push	 ecx
  001ba	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _msg$[ebp]
  001c0	52		 push	 edx
  001c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pEventObj@@3PAVOBJECTSTRUCT@@A ; pEventObj
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAVOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@EGRecvEven:

; 2614 : 		}
; 2615 : 		
; 2616 : 		eventchipeventinfo.MutoNum[0] = -1;

  001cf	b8 02 00 00 00	 mov	 eax, 2
  001d4	6b c8 00	 imul	 ecx, eax, 0
  001d7	83 ca ff	 or	 edx, -1
  001da	66 89 54 0d f2	 mov	 WORD PTR _eventchipeventinfo$[ebp+ecx+6], dx

; 2617 : 		eventchipeventinfo.MutoNum[1] = -1;

  001df	b8 02 00 00 00	 mov	 eax, 2
  001e4	c1 e0 00	 shl	 eax, 0
  001e7	83 c9 ff	 or	 ecx, -1
  001ea	66 89 4c 05 f2	 mov	 WORD PTR _eventchipeventinfo$[ebp+eax+6], cx

; 2618 : 		eventchipeventinfo.MutoNum[2] = -1;

  001ef	b8 02 00 00 00	 mov	 eax, 2
  001f4	d1 e0		 shl	 eax, 1
  001f6	83 c9 ff	 or	 ecx, -1
  001f9	66 89 4c 05 f2	 mov	 WORD PTR _eventchipeventinfo$[ebp+eax+6], cx
$LN3@EGRecvEven:

; 2619 : 	}
; 2620 : 
; 2621 : 	DataSend(lpObj->m_Index, (LPBYTE)&eventchipeventinfo, eventchipeventinfo.h.size);			

  001fe	0f b6 45 ed	 movzx	 eax, BYTE PTR _eventchipeventinfo$[ebp+1]
  00202	50		 push	 eax
  00203	8d 4d ec	 lea	 ecx, DWORD PTR _eventchipeventinfo$[ebp]
  00206	51		 push	 ecx
  00207	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0020a	8b 02		 mov	 eax, DWORD PTR [edx]
  0020c	50		 push	 eax
  0020d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00212	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2622 : 	lpObj->UseEventServer = FALSE; // bugfix_alice_050113

  00215	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00218	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0
$LN1@EGRecvEven:

; 2623 : 	return;
; 2624 : 
; 2625 : #endif // EVENT_FRIENDSHIP_20040204 || EVENT_LOTTO
; 2626 : }

  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx
  00225	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00228	33 cd		 xor	 ecx, ebp
  0022a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z ENDP ; EGRecvEventChipInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?DataSendEventChip@@YAXPADH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
_size$ = 12						; size = 4
?DataSendEventChip@@YAXPADH@Z PROC			; DataSendEventChip, COMDAT

; 363  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 364  : 	if( !IsEventChipServerConnected && EventChipServerConnect )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsEventChipServerConnected@@3HA, 0 ; IsEventChipServerConnected
  00010	75 5d		 jne	 SHORT $LN2@DataSendEv
  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?EventChipServerConnect@@3HA, 0 ; EventChipServerConnect
  00019	74 54		 je	 SHORT $LN2@DataSendEv

; 365  : 	{
; 366  : 		wsEvenChipServerCli.Close();

  0001b	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsEvenChipServerCli@@3VwsJoinServerCli@@A+4
  00020	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 367  : 		wsEvenChipServerCli.CreateSocket(ghWnd);

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0002a	50		 push	 eax
  0002b	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsEvenChipServerCli@@3VwsJoinServerCli@@A+4
  00030	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 368  : 		if( GMEventChipServerConnect(gEventChipServerIp, WM_ASS_EVENTCHIPCLIMSG) == FALSE )

  00035	68 0d 04 00 00	 push	 1037			; 0000040dH
  0003a	68 00 00 00 00	 push	 OFFSET ?gEventChipServerIp@@3PADA ; gEventChipServerIp
  0003f	e8 00 00 00 00	 call	 ?GMEventChipServerConnect@@YAHPADK@Z ; GMEventChipServerConnect
  00044	83 c4 08	 add	 esp, 8
  00047	85 c0		 test	 eax, eax
  00049	75 1a		 jne	 SHORT $LN3@DataSendEv

; 369  : 		{
; 370  : 			IsEventChipServerConnected = 0;

  0004b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IsEventChipServerConnected@@3HA, 0 ; IsEventChipServerConnected

; 371  : 			LogAddTD("Can not connect EventChip Server");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JKOKDAGE@Can?5not?5connect?5EventChip?5Serve@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00060	83 c4 04	 add	 esp, 4

; 372  : 			return;

  00063	eb 2e		 jmp	 SHORT $LN1@DataSendEv
$LN3@DataSendEv:

; 373  : 		}	
; 374  : 		IsEventChipServerConnected = 1;

  00065	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsEventChipServerConnected@@3HA, 1 ; IsEventChipServerConnected
$LN2@DataSendEv:

; 375  : 	}
; 376  : 
; 377  : 	if( IsEventChipServerConnected && EventChipServerConnect )

  0006f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsEventChipServerConnected@@3HA, 0 ; IsEventChipServerConnected
  00076	74 1b		 je	 SHORT $LN1@DataSendEv
  00078	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?EventChipServerConnect@@3HA, 0 ; EventChipServerConnect
  0007f	74 12		 je	 SHORT $LN1@DataSendEv

; 378  : 		wsEvenChipServerCli.DataSend(pMsg, size);

  00081	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00084	50		 push	 eax
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  00088	51		 push	 ecx
  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsEvenChipServerCli@@3VwsJoinServerCli@@A ; wsEvenChipServerCli
  0008e	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN1@DataSendEv:

; 379  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?DataSendEventChip@@YAXPADH@Z ENDP			; DataSendEventChip
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EventChipEventProtocolCore@@YAXEPAEH@Z
_TEXT	SEGMENT
tv65 = -68						; size = 4
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?EventChipEventProtocolCore@@YAXEPAEH@Z PROC		; EventChipEventProtocolCore, COMDAT

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 226  : 	switch( protoNum )

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  0000d	89 45 bc	 mov	 DWORD PTR tv65[ebp], eax
  00010	8b 4d bc	 mov	 ecx, DWORD PTR tv65[ebp]
  00013	83 e9 01	 sub	 ecx, 1
  00016	89 4d bc	 mov	 DWORD PTR tv65[ebp], ecx
  00019	83 7d bc 15	 cmp	 DWORD PTR tv65[ebp], 21	; 00000015H
  0001d	0f 87 bd 00 00
	00		 ja	 $LN1@EventChipE
  00023	8b 55 bc	 mov	 edx, DWORD PTR tv65[ebp]
  00026	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN17@EventChipE[edx]
  0002d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@EventChipE[eax*4]
$LN4@EventChipE:

; 227  : 	{
; 228  : 		case 0x01 :
; 229  : 			EGRecvEventChipInfo((LPPMSG_ANS_VIEW_EC_MN)aRecv);

  00034	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z ; EGRecvEventChipInfo
  0003d	83 c4 04	 add	 esp, 4

; 230  : 		break;

  00040	e9 9b 00 00 00	 jmp	 $LN1@EventChipE
$LN5@EventChipE:

; 231  : 
; 232  : 		case 0x02 :
; 233  : 			EGResultRegEventChip((LPPMSG_ANS_REGISTER_EVENTCHIP)aRecv);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z ; EGResultRegEventChip
  0004e	83 c4 04	 add	 esp, 4

; 234  : 		break;

  00051	e9 8a 00 00 00	 jmp	 $LN1@EventChipE
$LN6@EventChipE:

; 235  : 
; 236  : 		case 0x03 :
; 237  : 			EGRecvRegMutoNum((LPPMSG_ANS_REGISTER_MUTONUM)aRecv);

  00056	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z ; EGRecvRegMutoNum
  0005f	83 c4 04	 add	 esp, 4

; 238  : 		break;

  00062	eb 7c		 jmp	 SHORT $LN1@EventChipE
$LN7@EventChipE:

; 239  : 
; 240  : 		case 0x04 :
; 241  : 			EGRecvChangeRena((LPPMSG_ANS_RESET_EVENTCHIP)aRecv);

  00064	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ; EGRecvChangeRena
  0006d	83 c4 04	 add	 esp, 4

; 242  : 		break;

  00070	eb 6e		 jmp	 SHORT $LN1@EventChipE
$LN8@EventChipE:

; 243  : 
; 244  : #ifdef FOR_BLOODCASTLE
; 245  : 		case 0x05 : 
; 246  : 			EGRecvStoneInfo((LPPMSG_ANS_VIEW_STONES)aRecv);

  00072	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z ; EGRecvStoneInfo
  0007b	83 c4 04	 add	 esp, 4

; 247  : 			break;

  0007e	eb 60		 jmp	 SHORT $LN1@EventChipE
$LN9@EventChipE:

; 248  : 		case 0x06 : 
; 249  : 			EGRecvRegStone((LPPMSG_ANS_REGISTER_STONES)aRecv);

  00080	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z ; EGRecvRegStone
  00089	83 c4 04	 add	 esp, 4

; 250  : 			break;

  0008c	eb 52		 jmp	 SHORT $LN1@EventChipE
$LN10@EventChipE:

; 251  : 		case 0x07 : 
; 252  : 			EGRecvDeleteStone((LPPMSG_ANS_DELETE_STONES)aRecv);

  0008e	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?EGRecvDeleteStone@@YAXPAUPMSG_ANS_DELETE_STONES@@@Z ; EGRecvDeleteStone
  00097	83 c4 04	 add	 esp, 4

; 253  : 			break;

  0009a	eb 44		 jmp	 SHORT $LN1@EventChipE
$LN11@EventChipE:

; 254  : #endif
; 255  : 			
; 256  : #ifdef FOR_STONE_EXCHANGE
; 257  : 		case 0x09 :
; 258  : 			EGRecvChangeStones((LPPMSG_ANS_RESET_EVENTCHIP)aRecv);

  0009c	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ; EGRecvChangeStones
  000a5	83 c4 04	 add	 esp, 4

; 259  : 			break;

  000a8	eb 36		 jmp	 SHORT $LN1@EventChipE
$LN12@EventChipE:

; 260  : #endif
; 261  : 
; 262  : #if defined ( FOR_KOREA ) || defined ( EVENT_FRIENDSHIP_20040204 ) || defined ( EVENT_LOTTO )
; 263  : 		case 0x08 :
; 264  : 			EGRecv2AnvRegSerial((LPPMSG_ANS_2ANIV_SERIAL)aRecv);

  000aa	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z ; EGRecv2AnvRegSerial
  000b3	83 c4 04	 add	 esp, 4

; 265  : 			break;

  000b6	eb 28		 jmp	 SHORT $LN1@EventChipE
$LN13@EventChipE:

; 266  : #endif // FOR_KOREA || EVENT_FRIENDSHIP_20040204 || EVENT_LOTTO
; 267  : 
; 268  : #ifdef MONSTER_HERD_SYSTEM_20031120
; 269  : 		case 0x10 :
; 270  : 			EGRecvRegRingGift((LPPMSG_ANS_REG_RINGGIFT)aRecv);

  000b8	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z ; EGRecvRegRingGift
  000c1	83 c4 04	 add	 esp, 4

; 271  : 			break;

  000c4	eb 1a		 jmp	 SHORT $LN1@EventChipE
$LN14@EventChipE:

; 272  : #endif
; 273  : 
; 274  : #ifdef EVENT_STONE_OF_FIENDSHIP_20040206
; 275  : 		case 0x11 : 
; 276  : 			EGRecvFriendShipStoneInfo		((LPPMSG_ANS_VIEW_STONES)aRecv);
; 277  : 			break;
; 278  : 		case 0x12 : 
; 279  : 			EGRecvRegFriendShipStone		((LPPMSG_ANS_REGISTER_STONES)aRecv);
; 280  : 			break;
; 281  : 		case 0x13 : 
; 282  : 			EGRecvDeleteFriendShipStone		((LPPMSG_ANS_DELETE_STONES)aRecv);
; 283  : 			break;
; 284  : #endif // EVENT_STONE_OF_FIENDSHIP_20040206
; 285  : 
; 286  : #ifdef CHAOSCASTLE_SYSTEM_20040408			// 카오스 캐슬 오프라인 경품과 관련된 함수들
; 287  : 		case 0x15 :
; 288  : 			EGAnsRegCCOfflineGift			((LPPMSG_ANS_REG_CC_OFFLINE_GIFT)aRecv);

  000c6	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z ; EGAnsRegCCOfflineGift
  000cf	83 c4 04	 add	 esp, 4

; 289  : 			break;;

  000d2	eb 0c		 jmp	 SHORT $LN1@EventChipE
$LN15@EventChipE:

; 290  : #endif
; 291  : 
; 292  : #ifdef DARK_LORD_HEART_EVENT_20040810		// 다크로드의 마음 오프라인 경품과 관련된 함수들
; 293  : 		case 0x16 :
; 294  : 			EGAnsRegDLOfflineGift			((LPPMSG_ANS_REG_DL_OFFLINE_GIFT)aRecv);

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z ; EGAnsRegDLOfflineGift
  000dd	83 c4 04	 add	 esp, 4
$LN1@EventChipE:

; 295  : 			break;;
; 296  : #endif
; 297  : 			
; 298  : #ifdef HIDDEN_TREASUREBOX_EVENT_20050804	// 숨겨진 보물상자 이벤트 경품과 관련된 함수들
; 299  : 		case 0x17 :
; 300  : 			EGAnsRegHTOfflineGift			((LPPMSG_ANS_REG_HT_OFFLINE_GIFT)aRecv);
; 301  : 			break;
; 302  : #endif
; 303  : #ifdef PCBANG_COUPON_EVENT_20060124
; 304  : 		case 0x18:
; 305  : 			EGAnsPossiblePCBangCouponEvent	((LPPMSG_ANS_POSSIBLE_PCBANG_COUPON)aRecv);
; 306  : 			break;
; 307  : 		case 0x19:
; 308  : 			EGAnsUsePCBangCoupon			((LPPMSG_ANS_USE_PCBANG_COUPON)aRecv);
; 309  : 			break;
; 310  : #endif // PCBANG_COUPON_EVENT_20060124	
; 311  : #ifdef WHITEANGEL_GET_ITEM_EVENT_20060822
; 312  : 		case 0x20:
; 313  : 			EGAnsCheckWhiteAngelGetItem( ( LPPMSG_ANS_CHECK_WHITEANGEL_GET_ITEM )aRecv );
; 314  : 			break;
; 315  : 		case 0x21:
; 316  : 			EGAnsWhiteAngelGetItem( ( LPPMSG_ANS_WHITEANGEL_GET_ITEM )aRecv );
; 317  : 			break;
; 318  : #endif			
; 319  : #ifdef PCBANG_POINT_SYSTEM_20070206	// EventServer로부터 데이터를 받음
; 320  : 		case 0x23:
; 321  : 			g_PCBangPointSystem.EGRecvPCBangPointInfo( aRecv );
; 322  : 			break;
; 323  : 		case 0x24:
; 324  : 			g_PCBangPointSystem.EGRecvUpdatePCBangPoint( aRecv );
; 325  : 			break;
; 326  : #endif
; 327  : #ifdef ADD_ITEM_GIVE_NPC_ALAN_20070823	// EventServer로부터 데이터를 받음
; 328  : 		case 0x27:
; 329  : 			EGAnsCheckAlansTarget( ( LPPMSG_ANS_CHECK_ALANS_TARGET )aRecv );
; 330  : 			break;
; 331  : 		case 0x28:
; 332  : 			EGAnsAlansItem( ( LPPMSG_ANS_ALANS_ITEM )aRecv );
; 333  : 			break;
; 334  : #endif
; 335  : #ifdef PCBANG_KUZIMO	// EventServer로부터 데이터를 받음
; 336  : 		case 0x29:
; 337  : 			g_PCBangPointSystem.EGRecvPCBangPointInfo2( aRecv );
; 338  : 			break;
; 339  : 		case 0x30:
; 340  : 			g_PCBangPointSystem.EGRecvUpdatePCBangPoint2( aRecv );
; 341  : 			break;
; 342  : #endif
; 343  : #ifdef ADD_PAYITEM_20081030 // by natinda
; 344  : 		case DBTASK_REQ_GET_PAYITEM:
; 345  : 			EGAnsCheckEventNPCTarget((LPPMSG_ANS_GET_PAYITEM) aRecv );
; 346  : 			break;
; 347  : 		case DBTASK_ANS_SET_PAYITEM:
; 348  : 			EGAnsEventNPCItem((LPPMSG_ANS_SET_PAYITEM) aRecv );
; 349  : 			break;
; 350  : #endif
; 351  : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029
; 352  : 		case 0x33:
; 353  : 			EGAnsGetCoinCount( ( LPPMSG__ES_ANS_GET_COIN_COUNT )aRecv );
; 354  : 			break;
; 355  : 		case 0x34:
; 356  : 			EGAnsRegeistCoin( ( LPPMSG_ES_ANS_REG_COIN )aRecv );
; 357  : 			break;			
; 358  : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029			
; 359  : 	}
; 360  : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
  000e7	90		 npad	 1
$LN18@EventChipE:
  000e8	00 00 00 00	 DD	 $LN4@EventChipE
  000ec	00 00 00 00	 DD	 $LN5@EventChipE
  000f0	00 00 00 00	 DD	 $LN6@EventChipE
  000f4	00 00 00 00	 DD	 $LN7@EventChipE
  000f8	00 00 00 00	 DD	 $LN8@EventChipE
  000fc	00 00 00 00	 DD	 $LN9@EventChipE
  00100	00 00 00 00	 DD	 $LN10@EventChipE
  00104	00 00 00 00	 DD	 $LN12@EventChipE
  00108	00 00 00 00	 DD	 $LN11@EventChipE
  0010c	00 00 00 00	 DD	 $LN13@EventChipE
  00110	00 00 00 00	 DD	 $LN14@EventChipE
  00114	00 00 00 00	 DD	 $LN15@EventChipE
  00118	00 00 00 00	 DD	 $LN1@EventChipE
$LN17@EventChipE:
  0011c	00		 DB	 0
  0011d	01		 DB	 1
  0011e	02		 DB	 2
  0011f	03		 DB	 3
  00120	04		 DB	 4
  00121	05		 DB	 5
  00122	06		 DB	 6
  00123	07		 DB	 7
  00124	08		 DB	 8
  00125	0c		 DB	 12			; 0000000cH
  00126	0c		 DB	 12			; 0000000cH
  00127	0c		 DB	 12			; 0000000cH
  00128	0c		 DB	 12			; 0000000cH
  00129	0c		 DB	 12			; 0000000cH
  0012a	0c		 DB	 12			; 0000000cH
  0012b	09		 DB	 9
  0012c	0c		 DB	 12			; 0000000cH
  0012d	0c		 DB	 12			; 0000000cH
  0012e	0c		 DB	 12			; 0000000cH
  0012f	0c		 DB	 12			; 0000000cH
  00130	0a		 DB	 10			; 0000000aH
  00131	0b		 DB	 11			; 0000000bH
?EventChipEventProtocolCore@@YAXEPAEH@Z ENDP		; EventChipEventProtocolCore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z
_TEXT	SEGMENT
$T1 = -412						; size = 4
$T2 = -408						; size = 4
$T3 = -404						; size = 4
_szText$ = -336						; size = 256
_szGIFT_NAME$ = -80					; size = 50
_szName$ = -28						; size = 11
_szAccountID$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z PROC ; EGAnsRegDLOfflineGift, COMDAT

; 4785 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 01 00
	00		 sub	 esp, 412		; 0000019cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 4786 : 	if (lpMsg == NULL) {

  00016	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  0001a	75 05		 jne	 SHORT $LN2@EGAnsRegDL

; 4787 : 		return;

  0001c	e9 82 01 00 00	 jmp	 $LN4@EGAnsRegDL
$LN2@EGAnsRegDL:

; 4788 : 	}
; 4789 : 
; 4790 : 	if (lpMsg->iResultCode == 0) {		// 선물 등록에 실패하였으면 그냥 나간다.

  00021	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00024	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00028	75 05		 jne	 SHORT $LN3@EGAnsRegDL

; 4791 : 		return;

  0002a	e9 74 01 00 00	 jmp	 $LN4@EGAnsRegDL
$LN3@EGAnsRegDL:

; 4792 : 	}
; 4793 : 
; 4794 : 	CHAR szAccountID[MAX_IDSTRING+1] = {0,};

  0002f	33 c0		 xor	 eax, eax
  00031	89 45 f0	 mov	 DWORD PTR _szAccountID$[ebp], eax
  00034	89 45 f4	 mov	 DWORD PTR _szAccountID$[ebp+4], eax
  00037	66 89 45 f8	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  0003b	88 45 fa	 mov	 BYTE PTR _szAccountID$[ebp+10], al

; 4795 : 	CHAR szName[MAX_IDSTRING+1] = {0,};

  0003e	33 c0		 xor	 eax, eax
  00040	89 45 e4	 mov	 DWORD PTR _szName$[ebp], eax
  00043	89 45 e8	 mov	 DWORD PTR _szName$[ebp+4], eax
  00046	66 89 45 ec	 mov	 WORD PTR _szName$[ebp+8], ax
  0004a	88 45 ee	 mov	 BYTE PTR _szName$[ebp+10], al

; 4796 : 	CHAR szGIFT_NAME[50] = {0,};

  0004d	6a 32		 push	 50			; 00000032H
  0004f	6a 00		 push	 0
  00051	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _memset
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4797 : 	
; 4798 : 	memset (szAccountID, 0, sizeof(szAccountID));

  0005d	6a 0b		 push	 11			; 0000000bH
  0005f	6a 00		 push	 0
  00061	8d 45 f0	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _memset
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4799 : 	memset (szName, 0, sizeof(szName));

  0006d	6a 0b		 push	 11			; 0000000bH
  0006f	6a 00		 push	 0
  00071	8d 45 e4	 lea	 eax, DWORD PTR _szName$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _memset
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4800 : 	memset (szGIFT_NAME, 0, sizeof(szGIFT_NAME));

  0007d	6a 32		 push	 50			; 00000032H
  0007f	6a 00		 push	 0
  00081	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _memset
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4801 : 
; 4802 : 	memcpy (szAccountID, lpMsg->szUID, sizeof(szAccountID));

  0008d	6a 0b		 push	 11			; 0000000bH
  0008f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00092	83 c0 08	 add	 eax, 8
  00095	50		 push	 eax
  00096	8d 4d f0	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 _memcpy
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4803 : 	memcpy (szName, lpMsg->szNAME, sizeof(szName));

  000a2	6a 0b		 push	 11			; 0000000bH
  000a4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a7	83 c0 16	 add	 eax, 22			; 00000016H
  000aa	50		 push	 eax
  000ab	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 _memcpy
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4804 : 	memcpy (szGIFT_NAME, lpMsg->szGIFT_NAME, sizeof(szGIFT_NAME));

  000b7	6a 32		 push	 50			; 00000032H
  000b9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000bc	83 c0 28	 add	 eax, 40			; 00000028H
  000bf	50		 push	 eax
  000c0	8d 4d b0	 lea	 ecx, DWORD PTR _szGIFT_NAME$[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _memcpy
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4805 : 
; 4806 : 	szAccountID[sizeof(szAccountID)-1]	= 0;

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	6b c8 0a	 imul	 ecx, eax, 10
  000d4	89 8d 6c fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  000da	83 bd 6c fe ff
	ff 0b		 cmp	 DWORD PTR $T3[ebp], 11	; 0000000bH
  000e1	73 02		 jae	 SHORT $LN5@EGAnsRegDL
  000e3	eb 05		 jmp	 SHORT $LN6@EGAnsRegDL
$LN5@EGAnsRegDL:
  000e5	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN6@EGAnsRegDL:
  000ea	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  000f0	c6 44 15 f0 00	 mov	 BYTE PTR _szAccountID$[ebp+edx], 0

; 4807 : 	szName[sizeof(szName)-1]			= 0;

  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	6b c8 0a	 imul	 ecx, eax, 10
  000fd	89 8d 68 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00103	83 bd 68 fe ff
	ff 0b		 cmp	 DWORD PTR $T2[ebp], 11	; 0000000bH
  0010a	73 02		 jae	 SHORT $LN7@EGAnsRegDL
  0010c	eb 05		 jmp	 SHORT $LN8@EGAnsRegDL
$LN7@EGAnsRegDL:
  0010e	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN8@EGAnsRegDL:
  00113	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  00119	c6 44 15 e4 00	 mov	 BYTE PTR _szName$[ebp+edx], 0

; 4808 : 	szGIFT_NAME[sizeof(szGIFT_NAME)-1]	= 0;

  0011e	b8 01 00 00 00	 mov	 eax, 1
  00123	6b c8 31	 imul	 ecx, eax, 49
  00126	89 8d 64 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0012c	83 bd 64 fe ff
	ff 32		 cmp	 DWORD PTR $T1[ebp], 50	; 00000032H
  00133	73 02		 jae	 SHORT $LN9@EGAnsRegDL
  00135	eb 05		 jmp	 SHORT $LN10@EGAnsRegDL
$LN9@EGAnsRegDL:
  00137	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN10@EGAnsRegDL:
  0013c	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00142	c6 44 15 b0 00	 mov	 BYTE PTR _szGIFT_NAME$[ebp+edx], 0

; 4809 : 
; 4810 : 	// 서버의 모든 사용자들에게 공지를 보내준다.
; 4811 : 	CHAR szText[256] = {0,};

  00147	68 00 01 00 00	 push	 256			; 00000100H
  0014c	6a 00		 push	 0
  0014e	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _memset
  0015a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4812 : 	wsprintf(szText, "[다크로드 기념 이벤트] %s 님께서 %s 경품에 당첨되셨습니다.",

  0015d	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  00160	50		 push	 eax
  00161	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  00164	51		 push	 ecx
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@IPBEOKOL@?$FL?$LE?Y?E?$KJ?$LH?N?$LF?e?5?$LB?b?$LD?d?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC?$LM@
  0016a	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR _szText$[ebp]
  00170	52		 push	 edx
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00177	83 c4 10	 add	 esp, 16			; 00000010H

; 4813 : 		szName,
; 4814 : 		szGIFT_NAME
; 4815 : 		);
; 4816 : 
; 4817 : 	AllSendServerMsg(szText);

  0017a	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00186	83 c4 04	 add	 esp, 4

; 4818 : 
; 4819 : 	LogAddTD("[DarkLord Heart Event] [%s][%s] Success to Register OffLine Gift (GIFT:%s)",

  00189	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  0018c	50		 push	 eax
  0018d	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  00190	51		 push	 ecx
  00191	8d 55 f0	 lea	 edx, DWORD PTR _szAccountID$[ebp]
  00194	52		 push	 edx
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOBBOLBI@?$FLDarkLord?5Heart?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001a0	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@EGAnsRegDL:

; 4820 : 		szAccountID,
; 4821 : 		szName,
; 4822 : 		szGIFT_NAME
; 4823 : 		);
; 4824 : }

  001a3	5f		 pop	 edi
  001a4	5e		 pop	 esi
  001a5	5b		 pop	 ebx
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a9	33 cd		 xor	 ecx, ebp
  001ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c3		 ret	 0
?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z ENDP ; EGAnsRegDLOfflineGift
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGReqRegDLOfflineGift@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGReqRegDLOfflineGift@@YAXH@Z PROC			; EGReqRegDLOfflineGift, COMDAT

; 4761 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4762 : 	if (!gObjIsConnected(iIndex)) {

  00013	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	75 05		 jne	 SHORT $LN2@EGReqRegDL

; 4763 : 		return;

  00023	e9 8d 00 00 00	 jmp	 $LN1@EGReqRegDL
$LN2@EGReqRegDL:

; 4764 : 	}
; 4765 : 
; 4766 : 	PMSG_REQ_REG_DL_OFFLINE_GIFT pMsg;
; 4767 : 	pMsg.h.c = 0xC1;

  00028	c6 45 d8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 4768 : 	pMsg.h.headcode = 0x16;

  0002c	c6 45 da 16	 mov	 BYTE PTR _pMsg$[ebp+2], 22 ; 00000016H

; 4769 : 	pMsg.h.size = sizeof(pMsg);

  00030	c6 45 d9 24	 mov	 BYTE PTR _pMsg$[ebp+1], 36 ; 00000024H

; 4770 : 
; 4771 : 	memcpy (pMsg.szUID, gObj[iIndex].AccountID, sizeof(pMsg.szUID));

  00034	6a 0b		 push	 11			; 0000000bH
  00036	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00043	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00047	52		 push	 edx
  00048	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _memcpy
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4772 : 	memcpy (pMsg.szNAME, gObj[iIndex].Name, sizeof(pMsg.szNAME));

  00054	6a 0b		 push	 11			; 0000000bH
  00056	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00063	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00067	52		 push	 edx
  00068	8d 45 ee	 lea	 eax, DWORD PTR _pMsg$[ebp+22]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _memcpy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4773 : 	pMsg.wServerCode = gGameServerCode / 20;

  00074	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0007b	99		 cdq
  0007c	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00081	f7 f9		 idiv	 ecx
  00083	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 4774 : 	pMsg.iINDEX = iIndex;

  00087	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0008a	89 45 dc	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 4775 : 
; 4776 : 	pMsg.szUID[sizeof(pMsg.szUID)-1]		= 0;

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	6b c8 0a	 imul	 ecx, eax, 10
  00095	c6 44 0d e0 00	 mov	 BYTE PTR _pMsg$[ebp+ecx+8], 0

; 4777 : 	pMsg.szNAME[sizeof(pMsg.szNAME)-1]		= 0;

  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	6b c8 0a	 imul	 ecx, eax, 10
  000a2	c6 44 0d ee 00	 mov	 BYTE PTR _pMsg$[ebp+ecx+22], 0

; 4778 : 
; 4779 : 	DataSendEventChip((char *) &pMsg, sizeof(pMsg));	

  000a7	6a 24		 push	 36			; 00000024H
  000a9	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  000b2	83 c4 08	 add	 esp, 8
$LN1@EGReqRegDL:

; 4780 : }

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bb	33 cd		 xor	 ecx, ebp
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
?EGReqRegDLOfflineGift@@YAXH@Z ENDP			; EGReqRegDLOfflineGift
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z
_TEXT	SEGMENT
$T1 = -412						; size = 4
$T2 = -408						; size = 4
$T3 = -404						; size = 4
_szText$ = -336						; size = 256
_szGIFT_NAME$ = -80					; size = 50
_szName$ = -28						; size = 11
_szAccountID$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z PROC ; EGAnsRegCCOfflineGift, COMDAT

; 4713 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 01 00
	00		 sub	 esp, 412		; 0000019cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 4714 : 	if (lpMsg == NULL) {

  00016	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  0001a	75 05		 jne	 SHORT $LN2@EGAnsRegCC

; 4715 : 		return;

  0001c	e9 8e 01 00 00	 jmp	 $LN4@EGAnsRegCC
$LN2@EGAnsRegCC:

; 4716 : 	}
; 4717 : 
; 4718 : 	if (lpMsg->iResultCode == 0) {					// 선물 등록에 실패하였으면 그냥 나간다.

  00021	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00024	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00028	75 05		 jne	 SHORT $LN3@EGAnsRegCC

; 4719 : 		return;

  0002a	e9 80 01 00 00	 jmp	 $LN4@EGAnsRegCC
$LN3@EGAnsRegCC:

; 4720 : 	}
; 4721 : 
; 4722 : 	CHAR szAccountID[MAX_IDSTRING+1] = {0,};

  0002f	33 c0		 xor	 eax, eax
  00031	89 45 f0	 mov	 DWORD PTR _szAccountID$[ebp], eax
  00034	89 45 f4	 mov	 DWORD PTR _szAccountID$[ebp+4], eax
  00037	66 89 45 f8	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  0003b	88 45 fa	 mov	 BYTE PTR _szAccountID$[ebp+10], al

; 4723 : 	CHAR szName[MAX_IDSTRING+1] = {0,};

  0003e	33 c0		 xor	 eax, eax
  00040	89 45 e4	 mov	 DWORD PTR _szName$[ebp], eax
  00043	89 45 e8	 mov	 DWORD PTR _szName$[ebp+4], eax
  00046	66 89 45 ec	 mov	 WORD PTR _szName$[ebp+8], ax
  0004a	88 45 ee	 mov	 BYTE PTR _szName$[ebp+10], al

; 4724 : 	CHAR szGIFT_NAME[50] = {0,};

  0004d	6a 32		 push	 50			; 00000032H
  0004f	6a 00		 push	 0
  00051	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _memset
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4725 : 	
; 4726 : 	memset (szAccountID, 0, sizeof(szAccountID));

  0005d	6a 0b		 push	 11			; 0000000bH
  0005f	6a 00		 push	 0
  00061	8d 45 f0	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _memset
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4727 : 	memset (szName, 0, sizeof(szName));

  0006d	6a 0b		 push	 11			; 0000000bH
  0006f	6a 00		 push	 0
  00071	8d 45 e4	 lea	 eax, DWORD PTR _szName$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _memset
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4728 : 	memset (szGIFT_NAME, 0, sizeof(szGIFT_NAME));

  0007d	6a 32		 push	 50			; 00000032H
  0007f	6a 00		 push	 0
  00081	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _memset
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4729 : 
; 4730 : 	memcpy (szAccountID, lpMsg->szUID, sizeof(szAccountID));

  0008d	6a 0b		 push	 11			; 0000000bH
  0008f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00092	83 c0 08	 add	 eax, 8
  00095	50		 push	 eax
  00096	8d 4d f0	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 _memcpy
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4731 : 	memcpy (szName, lpMsg->szNAME, sizeof(szName));

  000a2	6a 0b		 push	 11			; 0000000bH
  000a4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a7	83 c0 16	 add	 eax, 22			; 00000016H
  000aa	50		 push	 eax
  000ab	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 _memcpy
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4732 : 	memcpy (szGIFT_NAME, lpMsg->szGIFT_NAME, sizeof(szGIFT_NAME));

  000b7	6a 32		 push	 50			; 00000032H
  000b9	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000bc	83 c0 28	 add	 eax, 40			; 00000028H
  000bf	50		 push	 eax
  000c0	8d 4d b0	 lea	 ecx, DWORD PTR _szGIFT_NAME$[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _memcpy
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4733 : 
; 4734 : 	szAccountID[sizeof(szAccountID)-1]	= 0;

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	6b c8 0a	 imul	 ecx, eax, 10
  000d4	89 8d 6c fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  000da	83 bd 6c fe ff
	ff 0b		 cmp	 DWORD PTR $T3[ebp], 11	; 0000000bH
  000e1	73 02		 jae	 SHORT $LN5@EGAnsRegCC
  000e3	eb 05		 jmp	 SHORT $LN6@EGAnsRegCC
$LN5@EGAnsRegCC:
  000e5	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN6@EGAnsRegCC:
  000ea	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  000f0	c6 44 15 f0 00	 mov	 BYTE PTR _szAccountID$[ebp+edx], 0

; 4735 : 	szName[sizeof(szName)-1]			= 0;

  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	6b c8 0a	 imul	 ecx, eax, 10
  000fd	89 8d 68 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00103	83 bd 68 fe ff
	ff 0b		 cmp	 DWORD PTR $T2[ebp], 11	; 0000000bH
  0010a	73 02		 jae	 SHORT $LN7@EGAnsRegCC
  0010c	eb 05		 jmp	 SHORT $LN8@EGAnsRegCC
$LN7@EGAnsRegCC:
  0010e	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN8@EGAnsRegCC:
  00113	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  00119	c6 44 15 e4 00	 mov	 BYTE PTR _szName$[ebp+edx], 0

; 4736 : 	szGIFT_NAME[sizeof(szGIFT_NAME)-1]	= 0;

  0011e	b8 01 00 00 00	 mov	 eax, 1
  00123	6b c8 31	 imul	 ecx, eax, 49
  00126	89 8d 64 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0012c	83 bd 64 fe ff
	ff 32		 cmp	 DWORD PTR $T1[ebp], 50	; 00000032H
  00133	73 02		 jae	 SHORT $LN9@EGAnsRegCC
  00135	eb 05		 jmp	 SHORT $LN10@EGAnsRegCC
$LN9@EGAnsRegCC:
  00137	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN10@EGAnsRegCC:
  0013c	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00142	c6 44 15 b0 00	 mov	 BYTE PTR _szGIFT_NAME$[ebp+edx], 0

; 4737 : 
; 4738 : 	// 서버의 모든 사용자들에게 공지를 보내준다.
; 4739 : 	CHAR szText[256] = {0,};

  00147	68 00 01 00 00	 push	 256			; 00000100H
  0014c	6a 00		 push	 0
  0014e	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 _memset
  0015a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4740 : 	wsprintf(szText, lMsg.Get(1610),				// "%s 님께서 %s 상품에 당첨되셨습니다."

  0015d	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  00160	50		 push	 eax
  00161	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  00164	51		 push	 ecx
  00165	68 4a 06 00 00	 push	 1610			; 0000064aH
  0016a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00175	50		 push	 eax
  00176	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR _szText$[ebp]
  0017c	52		 push	 edx
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00183	83 c4 10	 add	 esp, 16			; 00000010H

; 4741 : 		szName,
; 4742 : 		szGIFT_NAME
; 4743 : 		);
; 4744 : 
; 4745 : 	AllSendServerMsg(szText);

  00186	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00192	83 c4 04	 add	 esp, 4

; 4746 : 
; 4747 : 	LogAddTD("[Chaos Castle] [%s][%s] Success to Register OffLine Gift (GIFT:%s)",

  00195	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  00198	50		 push	 eax
  00199	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  0019c	51		 push	 ecx
  0019d	8d 55 f0	 lea	 edx, DWORD PTR _szAccountID$[ebp]
  001a0	52		 push	 edx
  001a1	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MNBMBKBB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success@
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001ac	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@EGAnsRegCC:

; 4748 : 		szAccountID,
; 4749 : 		szName,
; 4750 : 		szGIFT_NAME
; 4751 : 		);
; 4752 : }

  001af	5f		 pop	 edi
  001b0	5e		 pop	 esi
  001b1	5b		 pop	 ebx
  001b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b5	33 cd		 xor	 ecx, ebp
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c3		 ret	 0
?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z ENDP ; EGAnsRegCCOfflineGift
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGReqRegCCOfflineGift@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGReqRegCCOfflineGift@@YAXH@Z PROC			; EGReqRegCCOfflineGift, COMDAT

; 4690 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4691 : 	if (!gObjIsConnected(iIndex)) {

  00013	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	75 05		 jne	 SHORT $LN2@EGReqRegCC

; 4692 : 		return;

  00023	e9 8d 00 00 00	 jmp	 $LN1@EGReqRegCC
$LN2@EGReqRegCC:

; 4693 : 	}
; 4694 : 
; 4695 : 	PMSG_REQ_REG_CC_OFFLINE_GIFT pMsg;
; 4696 : 	pMsg.h.c = 0xC1;

  00028	c6 45 d8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 4697 : 	pMsg.h.headcode = 0x15;

  0002c	c6 45 da 15	 mov	 BYTE PTR _pMsg$[ebp+2], 21 ; 00000015H

; 4698 : 	pMsg.h.size = sizeof(pMsg);

  00030	c6 45 d9 24	 mov	 BYTE PTR _pMsg$[ebp+1], 36 ; 00000024H

; 4699 : 
; 4700 : 	memcpy (pMsg.szUID, gObj[iIndex].AccountID, sizeof(pMsg.szUID));

  00034	6a 0b		 push	 11			; 0000000bH
  00036	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00043	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00047	52		 push	 edx
  00048	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _memcpy
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4701 : 	memcpy (pMsg.szNAME, gObj[iIndex].Name, sizeof(pMsg.szNAME));

  00054	6a 0b		 push	 11			; 0000000bH
  00056	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00063	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00067	52		 push	 edx
  00068	8d 45 ee	 lea	 eax, DWORD PTR _pMsg$[ebp+22]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _memcpy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4702 : 	pMsg.wServerCode = gGameServerCode / 20;

  00074	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0007b	99		 cdq
  0007c	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00081	f7 f9		 idiv	 ecx
  00083	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 4703 : 	pMsg.iINDEX = iIndex;

  00087	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0008a	89 45 dc	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 4704 : 
; 4705 : 	pMsg.szUID[sizeof(pMsg.szUID)-1]		= 0;

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	6b c8 0a	 imul	 ecx, eax, 10
  00095	c6 44 0d e0 00	 mov	 BYTE PTR _pMsg$[ebp+ecx+8], 0

; 4706 : 	pMsg.szNAME[sizeof(pMsg.szNAME)-1]		= 0;

  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	6b c8 0a	 imul	 ecx, eax, 10
  000a2	c6 44 0d ee 00	 mov	 BYTE PTR _pMsg$[ebp+ecx+22], 0

; 4707 : 
; 4708 : 	DataSendEventChip((char *) &pMsg, sizeof(pMsg));

  000a7	6a 24		 push	 36			; 00000024H
  000a9	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  000b2	83 c4 08	 add	 esp, 8
$LN1@EGReqRegCC:

; 4709 : }

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bb	33 cd		 xor	 ecx, ebp
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
?EGReqRegCCOfflineGift@@YAXH@Z ENDP			; EGReqRegCCOfflineGift
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z
_TEXT	SEGMENT
_pMsgSend$ = -36					; size = 5
_szName$ = -28						; size = 11
_szAccountID$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z PROC ; EGAnsBloodCastleEnterCount, COMDAT

; 4200 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4201 : 	if (lpMsg == NULL) {

  00013	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00017	75 05		 jne	 SHORT $LN2@EGAnsBlood

; 4202 : 		return;

  00019	e9 d8 00 00 00	 jmp	 $LN1@EGAnsBlood
$LN2@EGAnsBlood:

; 4203 : 	}
; 4204 : 
; 4205 : 	if (!gObjIsConnected(lpMsg->iObjIndex)) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00021	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax
  0002f	75 05		 jne	 SHORT $LN3@EGAnsBlood

; 4206 : 		return;

  00031	e9 c0 00 00 00	 jmp	 $LN1@EGAnsBlood
$LN3@EGAnsBlood:

; 4207 : 	}
; 4208 : 
; 4209 : 	CHAR szAccountID[MAX_IDSTRING+1] = {0,};

  00036	33 c0		 xor	 eax, eax
  00038	89 45 f0	 mov	 DWORD PTR _szAccountID$[ebp], eax
  0003b	89 45 f4	 mov	 DWORD PTR _szAccountID$[ebp+4], eax
  0003e	66 89 45 f8	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  00042	88 45 fa	 mov	 BYTE PTR _szAccountID$[ebp+10], al

; 4210 : 	CHAR szName[MAX_IDSTRING+1] = {0,};

  00045	33 c0		 xor	 eax, eax
  00047	89 45 e4	 mov	 DWORD PTR _szName$[ebp], eax
  0004a	89 45 e8	 mov	 DWORD PTR _szName$[ebp+4], eax
  0004d	66 89 45 ec	 mov	 WORD PTR _szName$[ebp+8], ax
  00051	88 45 ee	 mov	 BYTE PTR _szName$[ebp+10], al

; 4211 : 	memcpy (szAccountID, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  00054	6a 0a		 push	 10			; 0000000aH
  00056	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00059	83 c0 03	 add	 eax, 3
  0005c	50		 push	 eax
  0005d	8d 4d f0	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 _memcpy
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4212 : 	memcpy (szName, lpMsg->GameID, sizeof(lpMsg->GameID));

  00069	6a 0a		 push	 10			; 0000000aH
  0006b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0006e	83 c0 0d	 add	 eax, 13			; 0000000dH
  00071	50		 push	 eax
  00072	8d 4d e4	 lea	 ecx, DWORD PTR _szName$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 _memcpy
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4213 : 
; 4214 : 	if (strcmp(gObj[lpMsg->iObjIndex].AccountID, szAccountID) ||

  0007e	8d 45 f0	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00085	69 51 1c a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+28], 7072
  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00091	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _strcmp
  0009b	83 c4 08	 add	 esp, 8
  0009e	85 c0		 test	 eax, eax
  000a0	75 24		 jne	 SHORT $LN5@EGAnsBlood
  000a2	8d 45 e4	 lea	 eax, DWORD PTR _szName$[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000a9	69 51 1c a0 1b
	00 00		 imul	 edx, DWORD PTR [ecx+28], 7072
  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b5	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 _strcmp
  000bf	83 c4 08	 add	 esp, 8
  000c2	85 c0		 test	 eax, eax
  000c4	74 02		 je	 SHORT $LN4@EGAnsBlood
$LN5@EGAnsBlood:

; 4215 : 		strcmp(gObj[lpMsg->iObjIndex].Name, szName)
; 4216 : 		)
; 4217 : 	{
; 4218 : 		// 최초 블러드캐슬 남은 횟수를 요청했던 케릭이 아니라면 보내지 않음
; 4219 : 		return;

  000c6	eb 2e		 jmp	 SHORT $LN1@EGAnsBlood
$LN4@EGAnsBlood:

; 4220 : 	}
; 4221 : 
; 4222 : 	// 클라이언트에게 남은 횟수를 보내준다.
; 4223 : 	PMSG_ANS_CL_ENTERCOUNT pMsgSend;
; 4224 : 	pMsgSend.h.c = 0xC1;

  000c8	c6 45 dc c1	 mov	 BYTE PTR _pMsgSend$[ebp], 193 ; 000000c1H

; 4225 : 	pMsgSend.h.headcode = 0x9F;

  000cc	c6 45 de 9f	 mov	 BYTE PTR _pMsgSend$[ebp+2], 159 ; 0000009fH

; 4226 : 	pMsgSend.h.size = sizeof(pMsgSend);

  000d0	c6 45 dd 05	 mov	 BYTE PTR _pMsgSend$[ebp+1], 5

; 4227 : 	pMsgSend.btEventType = 2;	// 블러드캐슬

  000d4	c6 45 df 02	 mov	 BYTE PTR _pMsgSend$[ebp+3], 2

; 4228 : 	pMsgSend.btLeftEnterCount = lpMsg->iLeftCount;

  000d8	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000db	8a 48 20	 mov	 cl, BYTE PTR [eax+32]
  000de	88 4d e0	 mov	 BYTE PTR _pMsgSend$[ebp+4], cl

; 4229 : 
; 4230 : 	DataSend (lpMsg->iObjIndex, (LPBYTE) &pMsgSend, sizeof(pMsgSend));

  000e1	6a 05		 push	 5
  000e3	8d 45 dc	 lea	 eax, DWORD PTR _pMsgSend$[ebp]
  000e6	50		 push	 eax
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000ea	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@EGAnsBlood:

; 4231 : }

  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fc	33 cd		 xor	 ecx, ebp
  000fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z ENDP ; EGAnsBloodCastleEnterCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGReqBloodCastleEnterCount@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGReqBloodCastleEnterCount@@YAXH@Z PROC		; EGReqBloodCastleEnterCount, COMDAT

; 4164 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4165 : 	if (!gObjIsConnected(iIndex)) {

  00013	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	75 05		 jne	 SHORT $LN2@EGReqBlood

; 4166 : 		return;

  00023	e9 ef 00 00 00	 jmp	 $LN1@EGReqBlood
$LN2@EGReqBlood:

; 4167 : 	}
; 4168 : 
; 4169 : 	PMSG_REQ_BLOODCASTLE_ENTERCOUNT pMsg;
; 4170 : 	pMsg.h.c = 0xC1;

  00028	c6 45 dc c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 4171 : 	pMsg.h.headcode = 0x0B;

  0002c	c6 45 de 0b	 mov	 BYTE PTR _pMsg$[ebp+2], 11 ; 0000000bH

; 4172 : 	pMsg.h.size = sizeof(pMsg);

  00030	c6 45 dd 20	 mov	 BYTE PTR _pMsg$[ebp+1], 32 ; 00000020H

; 4173 : 
; 4174 : 	memcpy (pMsg.AccountID, gObj[iIndex].AccountID, sizeof(pMsg.AccountID));

  00034	6a 0a		 push	 10			; 0000000aH
  00036	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00043	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00047	52		 push	 edx
  00048	8d 45 df	 lea	 eax, DWORD PTR _pMsg$[ebp+3]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _memcpy
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4175 : 	memcpy (pMsg.GameID, gObj[iIndex].Name, sizeof(pMsg.GameID));

  00054	6a 0a		 push	 10			; 0000000aH
  00056	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00063	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00067	52		 push	 edx
  00068	8d 45 e9	 lea	 eax, DWORD PTR _pMsg$[ebp+13]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _memcpy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4176 : 	pMsg.ServerCode = gGameServerCode / 20;

  00074	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0007b	99		 cdq
  0007c	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00081	f7 f9		 idiv	 ecx
  00083	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 4177 : 	pMsg.iObjIndex = iIndex;

  00086	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00089	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+28], eax

; 4178 : 
; 4179 : 
; 4180 : 	// 실제로 랭킹서버에 전송하는 부분
; 4181 : 	if( !IsDevilSquareEventConnected && !DevilSquareEventConnect )

  0008c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00093	75 5d		 jne	 SHORT $LN3@EGReqBlood
  00095	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  0009c	75 54		 jne	 SHORT $LN3@EGReqBlood

; 4182 : 	{
; 4183 : 		wsRServerCli.Close();

  0009e	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000a3	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 4184 : 		wsRServerCli.CreateSocket(ghWnd);

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000ad	50		 push	 eax
  000ae	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000b3	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 4185 : 		if( GMRankingServerConnect(gDevilSquareEventServerIp, WM_ASS_RANKINGCLIMSG) == FALSE )

  000b8	68 0c 04 00 00	 push	 1036			; 0000040cH
  000bd	68 00 00 00 00	 push	 OFFSET ?gDevilSquareEventServerIp@@3PADA ; gDevilSquareEventServerIp
  000c2	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000c7	83 c4 08	 add	 esp, 8
  000ca	85 c0		 test	 eax, eax
  000cc	75 1a		 jne	 SHORT $LN4@EGReqBlood

; 4186 : 		{
; 4187 : 			IsDevilSquareEventConnected = 0;

  000ce	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected

; 4188 : 			LogAddTD("Can not connect Ranking Server");

  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e3	83 c4 04	 add	 esp, 4

; 4189 : 			return;

  000e6	eb 2f		 jmp	 SHORT $LN1@EGReqBlood
$LN4@EGReqBlood:

; 4190 : 		}
; 4191 : 		IsDevilSquareEventConnected = 1;

  000e8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN3@EGReqBlood:

; 4192 : 	}
; 4193 : 
; 4194 : 	if( !DevilSquareEventConnect && IsDevilSquareEventConnected )

  000f2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  000f9	75 1c		 jne	 SHORT $LN1@EGReqBlood
  000fb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00102	74 13		 je	 SHORT $LN1@EGReqBlood

; 4195 : 		wsRServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  00104	0f b6 45 dd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00108	50		 push	 eax
  00109	8d 4d dc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0010c	51		 push	 ecx
  0010d	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  00112	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN1@EGReqBlood:

; 4196 : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011d	33 cd		 xor	 ecx, ebp
  0011f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
?EGReqBloodCastleEnterCount@@YAXH@Z ENDP		; EGReqBloodCastleEnterCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGBloodCastleEnterCountOn@@YAXH@Z
_TEXT	SEGMENT
_pMsg$1 = -64						; size = 28
_bRETVAL$2 = -36					; size = 4
_pMsg$3 = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGBloodCastleEnterCountOn@@YAXH@Z PROC			; EGBloodCastleEnterCountOn, COMDAT

; 4115 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 4116 : 	if (gObjIsConnected(iIndex) == FALSE) {

  00016	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001f	83 c4 04	 add	 esp, 4
  00022	85 c0		 test	 eax, eax
  00024	75 05		 jne	 SHORT $LN2@EGBloodCas

; 4117 : 		// 입장제한 정보를 받았는데 상대방이 접속 종료했다.
; 4118 : 		return;

  00026	e9 08 01 00 00	 jmp	 $LN1@EGBloodCas
$LN2@EGBloodCas:

; 4119 : 	}
; 4120 : 
; 4121 : 	if (!DevilSquareEventConnect) {

  0002b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  00032	0f 85 fb 00 00
	00		 jne	 $LN1@EGBloodCas

; 4122 : 		if (IsDevilSquareEventConnected) {

  00038	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  0003f	74 6e		 je	 SHORT $LN4@EGBloodCas

; 4123 : 			// 랭킹서버에 입장 카운트를 증가시킨다
; 4124 : 			PMSG_REQ_BLOODCASTLECOUNTON pMsg;
; 4125 : 			pMsg.h.c = 0xC1;

  00041	c6 45 e0 c1	 mov	 BYTE PTR _pMsg$3[ebp], 193 ; 000000c1H

; 4126 : 			pMsg.h.headcode = 0x09;

  00045	c6 45 e2 09	 mov	 BYTE PTR _pMsg$3[ebp+2], 9

; 4127 : 			pMsg.h.size = sizeof(pMsg);

  00049	c6 45 e1 1c	 mov	 BYTE PTR _pMsg$3[ebp+1], 28 ; 0000001cH

; 4128 : 			memcpy (pMsg.AccountID, gObj[iIndex].AccountID, MAX_IDSTRING);

  0004d	6a 0a		 push	 10			; 0000000aH
  0004f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005c	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00060	52		 push	 edx
  00061	8d 45 e3	 lea	 eax, DWORD PTR _pMsg$3[ebp+3]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _memcpy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4129 : 			memcpy (pMsg.GameID, gObj[iIndex].Name, MAX_IDSTRING);

  0006d	6a 0a		 push	 10			; 0000000aH
  0006f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007c	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00080	52		 push	 edx
  00081	8d 45 ed	 lea	 eax, DWORD PTR _pMsg$3[ebp+13]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _memcpy
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4130 : 			pMsg.ServerCode = gGameServerCode;

  0008d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00094	89 45 f8	 mov	 DWORD PTR _pMsg$3[ebp+24], eax

; 4131 : 
; 4132 : 			wsRServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  00097	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$3[ebp+1]
  0009b	50		 push	 eax
  0009c	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$3[ebp]
  0009f	51		 push	 ecx
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  000a5	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 4133 : 		}

  000aa	e9 84 00 00 00	 jmp	 $LN1@EGBloodCas
$LN4@EGBloodCas:

; 4134 : 		else {
; 4135 : 			BOOL bRETVAL = GMRankingServerConnect(gDevilSquareEventServerIp, WM_USER+12);	// WM_ASS_RANKINGCLIMSG

  000af	68 0c 04 00 00	 push	 1036			; 0000040cH
  000b4	68 00 00 00 00	 push	 OFFSET ?gDevilSquareEventServerIp@@3PADA ; gDevilSquareEventServerIp
  000b9	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000be	83 c4 08	 add	 esp, 8
  000c1	89 45 dc	 mov	 DWORD PTR _bRETVAL$2[ebp], eax

; 4136 : 			if (bRETVAL == TRUE) {

  000c4	83 7d dc 01	 cmp	 DWORD PTR _bRETVAL$2[ebp], 1
  000c8	75 69		 jne	 SHORT $LN1@EGBloodCas

; 4137 : 				// 랭킹서버에 입장 카운트를 증가시킨다
; 4138 : 				PMSG_REQ_BLOODCASTLECOUNTON pMsg;
; 4139 : 				pMsg.h.c = 0xC1;

  000ca	c6 45 c0 c1	 mov	 BYTE PTR _pMsg$1[ebp], 193 ; 000000c1H

; 4140 : 				pMsg.h.headcode = 0x09;

  000ce	c6 45 c2 09	 mov	 BYTE PTR _pMsg$1[ebp+2], 9

; 4141 : 				pMsg.h.size = sizeof(pMsg);

  000d2	c6 45 c1 1c	 mov	 BYTE PTR _pMsg$1[ebp+1], 28 ; 0000001cH

; 4142 : 				memcpy (pMsg.AccountID, gObj[iIndex].AccountID, MAX_IDSTRING);

  000d6	6a 0a		 push	 10			; 0000000aH
  000d8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e5	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000e9	52		 push	 edx
  000ea	8d 45 c3	 lea	 eax, DWORD PTR _pMsg$1[ebp+3]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 _memcpy
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4143 : 				memcpy (pMsg.GameID, gObj[iIndex].Name, MAX_IDSTRING);

  000f6	6a 0a		 push	 10			; 0000000aH
  000f8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00105	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00109	52		 push	 edx
  0010a	8d 45 cd	 lea	 eax, DWORD PTR _pMsg$1[ebp+13]
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 _memcpy
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4144 : 				pMsg.ServerCode = gGameServerCode;

  00116	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0011d	89 45 d8	 mov	 DWORD PTR _pMsg$1[ebp+24], eax

; 4145 : 
; 4146 : 				wsRServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  00120	0f b6 45 c1	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00124	50		 push	 eax
  00125	8d 4d c0	 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  00128	51		 push	 ecx
  00129	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  0012e	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN1@EGBloodCas:

; 4147 : 			}
; 4148 : 		}
; 4149 : 	}
; 4150 : }

  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00139	33 cd		 xor	 ecx, ebp
  0013b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
?EGBloodCastleEnterCountOn@@YAXH@Z ENDP			; EGBloodCastleEnterCountOn
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EGBloodCastleEnterCountCheck@@YAXPAUPMSG_ANS_BLOODCASTLEENTERCHECK@@@Z
_TEXT	SEGMENT
tv171 = -360						; size = 4
tv275 = -356						; size = 4
tv172 = -356						; size = 4
_szTemp$ = -288						; size = 256
_iBC_INDEX$ = -32					; size = 4
_iRESULT$ = -28						; size = 4
_pResult$ = -24						; size = 4
_dwITEM_SERIAL$ = -20					; size = 4
_iITEM_LEVEL$ = -16					; size = 4
_btInvisibleCourtItemPos$ = -10				; size = 1
_btBridgeNumber$ = -9					; size = 1
_iIndex$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?EGBloodCastleEnterCountCheck@@YAXPAUPMSG_ANS_BLOODCASTLEENTERCHECK@@@Z PROC ; EGBloodCastleEnterCountCheck, COMDAT

; 3745 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3746 : 	INT iIndex = lpMsg->iObjIndex;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00019	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0001c	89 4d f8	 mov	 DWORD PTR _iIndex$[ebp], ecx

; 3747 : 
; 3748 : 	if (gObjIsConnected(iIndex) == FALSE) {

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	75 05		 jne	 SHORT $LN4@EGBloodCas

; 3749 : 		// 입장제한 정보를 받았는데 상대방이 접속 종료했다.
; 3750 : 		return;

  0002f	e9 19 05 00 00	 jmp	 $LN1@EGBloodCas
$LN4@EGBloodCas:

; 3751 : 	}
; 3752 : 
; 3753 : 	if (iIndex < ALLOC_USEROBJECTSTART) {

  00034	81 7d f8 00 19
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 6400 ; 00001900H
  0003b	7d 05		 jge	 SHORT $LN5@EGBloodCas

; 3754 : 		// 이 인덱스 이하는 사람이 아니므로 끝낸다.
; 3755 : 		return;

  0003d	e9 0b 05 00 00	 jmp	 $LN1@EGBloodCas
$LN5@EGBloodCas:

; 3756 : 	}
; 3757 : 
; 3758 : 	BYTE btBridgeNumber = lpMsg->iBridgeNumber-1;

  00042	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00045	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00048	83 e9 01	 sub	 ecx, 1
  0004b	88 4d f7	 mov	 BYTE PTR _btBridgeNumber$[ebp], cl

; 3759 : 	BYTE btInvisibleCourtItemPos = lpMsg->iItemPos;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00051	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
  00054	88 4d f6	 mov	 BYTE PTR _btInvisibleCourtItemPos$[ebp], cl

; 3760 : 	INT	 iITEM_LEVEL = 0;

  00057	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0

; 3761 : 	DWORD dwITEM_SERIAL = 0;

  0005e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], 0

; 3762 : 
; 3763 : 	PMSG_RESULT_MOVEBLOODCASTLE pResult;
; 3764 : 	PHeadSetB((LPBYTE)&pResult, 0x9A, sizeof(pResult));

  00065	6a 04		 push	 4
  00067	68 9a 00 00 00	 push	 154			; 0000009aH
  0006c	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3765 : 	pResult.Result = 0;

  00078	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 3766 : 
; 3767 : 	
; 3768 : #ifdef ADD_PK_USER_ENTER_LIMIT_EVENT_MAP_20060411
; 3769 : 	// *>. 카오 유저는 입장할 수 없다.
; 3770 : #ifdef UPDATE_PK_SYSTEM_20070302	// 카오 유저는 입장할 수 없다.
; 3771 : 	BOOL	PKFlag = FALSE;
; 3772 : 	if(gObj[iIndex].PartyNumber >= 0)	// 파티에 속할경우
; 3773 : 	{
; 3774 : 		if( gParty.GetPKPartyPenalty(gObj[iIndex].PartyNumber) >= PK_LEVEL_DEFAULT+2)
; 3775 : 		{
; 3776 : 			PKFlag = TRUE;
; 3777 : 		}
; 3778 : 	}
; 3779 : 	else
; 3780 : 	{
; 3781 : 		if(gObj[iIndex].m_PK_Level >= PK_LEVEL_DEFAULT+1)
; 3782 : 		{
; 3783 : 			PKFlag = TRUE;
; 3784 : 		}
; 3785 : 	}
; 3786 : 	
; 3787 : 	if(PKFlag == TRUE)
; 3788 : #else	// UPDATE_PK_SYSTEM_20070302
; 3789 : 	if( gObj[iIndex].m_PK_Level >= PK_LEVEL_DEFAULT + 1 )

  0007c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00089	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00091	83 fa 04	 cmp	 edx, 4
  00094	7c 1e		 jl	 SHORT $LN6@EGBloodCas

; 3790 : #endif	// UPDATE_PK_SYSTEM_20070302
; 3791 : 	{
; 3792 : 		pResult.Result = 7;

  00096	c6 45 eb 07	 mov	 BYTE PTR _pResult$[ebp+3], 7

; 3793 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0009a	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0009e	50		 push	 eax
  0009f	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000a2	51		 push	 ecx
  000a3	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3794 : 		return;

  000af	e9 99 04 00 00	 jmp	 $LN1@EGBloodCas
$LN6@EGBloodCas:

; 3795 : 	}
; 3796 : #endif
; 3797 : 
; 3798 : 	// *> . 일일 입장 횟수를 초과하였다.
; 3799 : 	if (lpMsg->bEnterCheck == 0) {

  000b4	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000b7	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000bb	75 1e		 jne	 SHORT $LN7@EGBloodCas

; 3800 : 		pResult.Result = 6;

  000bd	c6 45 eb 06	 mov	 BYTE PTR _pResult$[ebp+3], 6

; 3801 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  000c1	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000c5	50		 push	 eax
  000c6	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3802 : 		return;

  000d6	e9 72 04 00 00	 jmp	 $LN1@EGBloodCas
$LN7@EGBloodCas:

; 3803 : 	}
; 3804 : 	
; 3805 : 	
; 3806 : 	// P.S.> . 이 아래에서 실패할 경우 캐슬입장수를 무조건 -1 해주어야 한다.
; 3807 : 
; 3808 : 	// 1 . 지금이 들어갈 수 있는 시간인지 확인한다.
; 3809 : 	if (!g_BloodCastle.CheckCanEnter(btBridgeNumber)) {

  000db	0f b6 45 f7	 movzx	 eax, BYTE PTR _btBridgeNumber$[ebp]
  000df	50		 push	 eax
  000e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000e5	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  000ea	0f b6 c8	 movzx	 ecx, al
  000ed	85 c9		 test	 ecx, ecx
  000ef	75 1e		 jne	 SHORT $LN8@EGBloodCas

; 3810 : 		pResult.Result = 2;

  000f1	c6 45 eb 02	 mov	 BYTE PTR _pResult$[ebp+3], 2

; 3811 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  000f5	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000f9	50		 push	 eax
  000fa	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000fd	51		 push	 ecx
  000fe	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3812 : 		return;

  0010a	e9 3e 04 00 00	 jmp	 $LN1@EGBloodCas
$LN8@EGBloodCas:

; 3813 : 	}
; 3814 : 
; 3815 : 
; 3816 : 	// 2 . 케릭터의 인벤의 해당 위치에 투명망토 아이템이 있는지 확인한다.
; 3817 : 	if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].IsItem() == TRUE )

  0010f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00116	0f b6 4d f6	 movzx	 ecx, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  0011a	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00120	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00126	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0012d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00132	83 f8 01	 cmp	 eax, 1
  00135	0f 85 04 01 00
	00		 jne	 $LN9@EGBloodCas

; 3818 : 	{
; 3819 : 		if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM(13, 18) )	// 투명방토가 존재한다면

  0013b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00142	0f b6 4d f6	 movzx	 ecx, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  00146	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0014c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00152	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00159	0f bf 74 10 06	 movsx	 esi, WORD PTR [eax+edx+6]
  0015e	6a 12		 push	 18			; 00000012H
  00160	6a 0d		 push	 13			; 0000000dH
  00162	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00167	83 c4 08	 add	 esp, 8
  0016a	3b f0		 cmp	 esi, eax
  0016c	0f 85 ad 00 00
	00		 jne	 $LN11@EGBloodCas

; 3820 : 		{
; 3821 : 			iITEM_LEVEL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Level;				// 아이템 레벨을 얻는다.

  00172	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00179	0f b6 4d f6	 movzx	 ecx, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  0017d	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00183	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00189	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00190	0f bf 4c 10 08	 movsx	 ecx, WORD PTR [eax+edx+8]
  00195	89 4d f0	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], ecx

; 3822 : 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;			// 아이템 시리얼을 얻는다.

  00198	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0019f	0f b6 4d f6	 movzx	 ecx, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  001a3	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001af	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  001b6	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  001b9	89 4d ec	 mov	 DWORD PTR _dwITEM_SERIAL$[ebp], ecx

; 3823 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 투명망토 레벨체크 변경
; 3824 : 			if (!CHECK_LIMIT(iITEM_LEVEL, MAX_BLOODCASTLE_BRIDGE_COUNT+1)) {		// 0 < iITEM_LEVEL < 8
; 3825 : #else
; 3826 : 			if (!CHECK_LIMIT(iITEM_LEVEL, 8)) {		// 0 < iITEM_LEVEL < 8

  001bc	83 7d f0 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  001c0	7d 0c		 jge	 SHORT $LN31@EGBloodCas
  001c2	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv172[ebp], 0
  001cc	eb 28		 jmp	 SHORT $LN32@EGBloodCas
$LN31@EGBloodCas:
  001ce	83 7d f0 07	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 7
  001d2	7e 0c		 jle	 SHORT $LN29@EGBloodCas
  001d4	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv171[ebp], 0
  001de	eb 0a		 jmp	 SHORT $LN30@EGBloodCas
$LN29@EGBloodCas:
  001e0	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv171[ebp], 1
$LN30@EGBloodCas:
  001ea	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR tv171[ebp]
  001f0	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv172[ebp], eax
$LN32@EGBloodCas:
  001f6	83 bd 9c fe ff
	ff 00		 cmp	 DWORD PTR tv172[ebp], 0
  001fd	75 1e		 jne	 SHORT $LN13@EGBloodCas

; 3827 : #endif
; 3828 : 				pResult.Result = 1;

  001ff	c6 45 eb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 3829 : 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00203	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00207	50		 push	 eax
  00208	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0020b	51		 push	 ecx
  0020c	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0020f	52		 push	 edx
  00210	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00215	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3830 : 				return;

  00218	e9 30 03 00 00	 jmp	 $LN1@EGBloodCas
$LN13@EGBloodCas:

; 3831 : 			}
; 3832 : 		}

  0021d	eb 1e		 jmp	 SHORT $LN12@EGBloodCas
$LN11@EGBloodCas:

; 3833 : #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 3834 : 		// 블러드 캐슬 자유 입장권 추가
; 3835 : 		else if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 47 )
; 3836 : 			&& gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 0
; 3837 : 			)
; 3838 : 		{
; 3839 : 			iITEM_LEVEL = 10;
; 3840 : 
; 3841 : #ifdef MODIFY_MASTER_LEVEL_SYSTEM_20080414
; 3842 : 			if( g_MasterLevelSystem.IsMasterLevelUser( &gObj[iIndex] ) )
; 3843 : 			{
; 3844 : 				iITEM_LEVEL		= MAX_BLOODCASTLE_BRIDGE_COUNT;
; 3845 : 				//iITEM_LEVEL	= MAX_DEVILSQUARE - 1;
; 3846 : 			} else {
; 3847 : #endif // MODIFY_MASTER_LEVEL_SYSTEM_20080414
; 3848 : 				for( int i = 0 ; i < MAX_BLOODCASTLE_BRIDGE_COUNT + 1 ; i++ )
; 3849 : 				{
; 3850 : 					if( g_BloodCastle.CheckEnterLevel( iIndex, i + 1 ) == 0 )
; 3851 : 					{
; 3852 : 						iITEM_LEVEL = i + 1;
; 3853 : 						break;
; 3854 : 					}
; 3855 : 				}
; 3856 : #ifdef MODIFY_MASTER_LEVEL_SYSTEM_20080414
; 3857 : 			}
; 3858 : #endif // MODIFY_MASTER_LEVEL_SYSTEM_20080414
; 3859 : 			
; 3860 : 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;
; 3861 : 		}
; 3862 : #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 3863 : 		else {
; 3864 : 			pResult.Result = 1;

  0021f	c6 45 eb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 3865 : 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00223	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00227	50		 push	 eax
  00228	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0022b	51		 push	 ecx
  0022c	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0022f	52		 push	 edx
  00230	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00235	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3866 : 			return;

  00238	e9 10 03 00 00	 jmp	 $LN1@EGBloodCas
$LN12@EGBloodCas:

; 3867 : 		}
; 3868 : 	}

  0023d	eb 1e		 jmp	 SHORT $LN10@EGBloodCas
$LN9@EGBloodCas:

; 3869 : 	else {
; 3870 : 		pResult.Result = 1;

  0023f	c6 45 eb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 3871 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00243	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00247	50		 push	 eax
  00248	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0024b	51		 push	 ecx
  0024c	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0024f	52		 push	 edx
  00250	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00255	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3872 : 		return;

  00258	e9 f0 02 00 00	 jmp	 $LN1@EGBloodCas
$LN10@EGBloodCas:

; 3873 : 	}
; 3874 : 
; 3875 : 	// 3 . 아이템이 존재하므로 이제 해당 케릭의 레벨과 맞는지 확인한다.
; 3876 : 	INT iRESULT = g_BloodCastle.CheckEnterLevel(iIndex, iITEM_LEVEL);

  0025d	8b 45 f0	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  00260	50		 push	 eax
  00261	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00264	51		 push	 ecx
  00265	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0026a	e8 00 00 00 00	 call	 ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CheckEnterLevel
  0026f	89 45 e4	 mov	 DWORD PTR _iRESULT$[ebp], eax

; 3877 : 
; 3878 : 	if (!iRESULT) {					// 레벨이 맞다.

  00272	83 7d e4 00	 cmp	 DWORD PTR _iRESULT$[ebp], 0
  00276	75 1b		 jne	 SHORT $LN14@EGBloodCas

; 3879 : 		pResult.Result = 0;

  00278	c6 45 eb 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 3880 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0027c	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00280	50		 push	 eax
  00281	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00284	51		 push	 ecx
  00285	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00288	52		 push	 edx
  00289	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0028e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3881 : 	}

  00291	eb 51		 jmp	 SHORT $LN15@EGBloodCas
$LN14@EGBloodCas:

; 3882 : 	else if (iRESULT == -1) {		// 내 레벨이 낮다.

  00293	83 7d e4 ff	 cmp	 DWORD PTR _iRESULT$[ebp], -1
  00297	75 20		 jne	 SHORT $LN16@EGBloodCas

; 3883 : 		pResult.Result = 4;

  00299	c6 45 eb 04	 mov	 BYTE PTR _pResult$[ebp+3], 4

; 3884 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0029d	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002a1	50		 push	 eax
  002a2	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  002a5	51		 push	 ecx
  002a6	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  002a9	52		 push	 edx
  002aa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3885 : 		return;

  002b2	e9 96 02 00 00	 jmp	 $LN1@EGBloodCas

; 3886 : 	}

  002b7	eb 2b		 jmp	 SHORT $LN15@EGBloodCas
$LN16@EGBloodCas:

; 3887 : 	else if (iRESULT == 1) {		// 내 레벨이 높다.

  002b9	83 7d e4 01	 cmp	 DWORD PTR _iRESULT$[ebp], 1
  002bd	75 20		 jne	 SHORT $LN18@EGBloodCas

; 3888 : 		pResult.Result = 3;

  002bf	c6 45 eb 03	 mov	 BYTE PTR _pResult$[ebp+3], 3

; 3889 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  002c3	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002c7	50		 push	 eax
  002c8	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  002cb	51		 push	 ecx
  002cc	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  002cf	52		 push	 edx
  002d0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3890 : 		return;

  002d8	e9 70 02 00 00	 jmp	 $LN1@EGBloodCas

; 3891 : 	}

  002dd	eb 05		 jmp	 SHORT $LN15@EGBloodCas
$LN18@EGBloodCas:

; 3892 : 	else return;					// 다른 에러임.

  002df	e9 69 02 00 00	 jmp	 $LN1@EGBloodCas
$LN15@EGBloodCas:

; 3893 : 
; 3894 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3895 : 	// *> . 파티원를 맺고있지 않거나 파티원이 3명 이하라면 입장할 수 없다.
; 3896 : /*
; 3897 : 	if( gObj[iIndex].PartyNumber >= 0 )
; 3898 : 	{
; 3899 : 		int iPartyUsers = gParty.GetCount(gObj[iIndex].PartyNumber);
; 3900 : 		if (iPartyUsers < 3) {
; 3901 : 			// 파티원이 3명 이하라면 입장할 수 없다.
; 3902 : 			pResult.Result = 5;		// !!! . 새로운 결과값 필요
; 3903 : 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 3904 : 			return;
; 3905 : 		}
; 3906 : 	}
; 3907 : 	else {
; 3908 : 		// 파티가 없다면 입장할 수 없다.
; 3909 : 		pResult.Result = 5;			// !!! . 새로운 결과값 필요
; 3910 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 3911 : 		return;
; 3912 : 	}
; 3913 : */
; 3914 : #endif
; 3915 : 
; 3916 : /*
; 3917 : #ifdef APPLY_TESTSERVER
; 3918 : 	// 4 . 혹시 실제 대천사의 절대무기를 소지하고 있는지 확인한다. -> 있으면 못들어감
; 3919 : 	if (g_BloodCastle.CheckUserHaveUlimateWeapon(iIndex)) {
; 3920 : 		LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) tried to Enter Castle but Have Ultimate Weapon", 
; 3921 : 			iITEM_LEVEL,
; 3922 : 			gObj[iIndex].AccountID,
; 3923 : 			gObj[iIndex].Name
; 3924 : 			);
; 3925 : 
; 3926 : #ifdef MODIFY_NOTICE_20040325
; 3927 : 		TNotice::MakeNoticeMsg( &pNotice, 1, "절대무기를 소지하고 있으므로 블러드캐슬에 입장하실 수 없습니다.");
; 3928 : 		TNotice::SendNoticeToUser( iIndex, &pNotice )
; 3929 : #else
; 3930 : 		PMSG_NOTICE	pNotice;
; 3931 : 		pNotice.type = 1;
; 3932 : 		strcpy(pNotice.Notice, "절대무기를 소지하고 있으므로 블러드캐슬에 입장하실 수 없습니다.");
; 3933 : 		PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 3934 : 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 3935 : #endif
; 3936 : 		return;
; 3937 : 	}
; 3938 : #endif	
; 3939 : */
; 3940 : 
; 3941 : 
; 3942 : 	// 5 . 해당 광장에 인원제한에 걸리지 않는지 확인한다.
; 3943 : #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 3944 : 	INT iBC_INDEX = g_BloodCastle.EnterUserBridge(btBridgeNumber, iIndex);
; 3945 : #else
; 3946 : 	INT iBC_INDEX = g_BloodCastle.EnterUserBridge(iITEM_LEVEL-1, iIndex);

  002e4	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  002e7	50		 push	 eax
  002e8	8b 4d f0	 mov	 ecx, DWORD PTR _iITEM_LEVEL$[ebp]
  002eb	83 e9 01	 sub	 ecx, 1
  002ee	51		 push	 ecx
  002ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  002f4	e8 00 00 00 00	 call	 ?EnterUserBridge@CBloodCastle@@QAEHHH@Z ; CBloodCastle::EnterUserBridge
  002f9	89 45 e0	 mov	 DWORD PTR _iBC_INDEX$[ebp], eax

; 3947 : #endif
; 3948 : 	if (iBC_INDEX == -1) {

  002fc	83 7d e0 ff	 cmp	 DWORD PTR _iBC_INDEX$[ebp], -1
  00300	75 1e		 jne	 SHORT $LN20@EGBloodCas

; 3949 : 		pResult.Result = 5;

  00302	c6 45 eb 05	 mov	 BYTE PTR _pResult$[ebp+3], 5

; 3950 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00306	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0030a	50		 push	 eax
  0030b	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0030e	51		 push	 ecx
  0030f	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00312	52		 push	 edx
  00313	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00318	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3951 : 		return;

  0031b	e9 2d 02 00 00	 jmp	 $LN1@EGBloodCas
$LN20@EGBloodCas:

; 3952 : 	}
; 3953 : 
; 3954 : 	// !!> 성공 -> 아이템 없애고 사용자를 블러드 캐슬로 이동시킨다.
; 3955 : 
; 3956 : 	// *> . 아이템 삭제
; 3957 : #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 3958 : 	if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 18 )
; 3959 : 		|| ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 47 ) && gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability == 1 )
; 3960 : 		)
; 3961 : 	{
; 3962 : 		gObjInventoryDeleteItem(iIndex, btInvisibleCourtItemPos);
; 3963 : 		GCInventoryItemDeleteSend(iIndex, btInvisibleCourtItemPos, 1);
; 3964 : 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 3965 : 	}
; 3966 : 	// 블러드 캐슬 자유 입장권
; 3967 : 	else if( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == MAKE_ITEMNUM( 13, 47 )
; 3968 : 		&& gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 1 )
; 3969 : 	{
; 3970 : 		gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability--;
; 3971 : 
; 3972 : 		GCItemDurSend2( iIndex, btInvisibleCourtItemPos, gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability, 0 );
; 3973 : 	}
; 3974 : #else
; 3975 : 	gObjInventoryDeleteItem(iIndex, btInvisibleCourtItemPos);

  00320	0f b6 45 f6	 movzx	 eax, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  00324	50		 push	 eax
  00325	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00328	51		 push	 ecx
  00329	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0032e	83 c4 08	 add	 esp, 8

; 3976 : 	GCInventoryItemDeleteSend(iIndex, btInvisibleCourtItemPos, 1);

  00331	6a 01		 push	 1
  00333	0f b6 45 f6	 movzx	 eax, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  00337	50		 push	 eax
  00338	8b 4d f8	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0033b	51		 push	 ecx
  0033c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00341	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3977 : 	DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00344	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00348	50		 push	 eax
  00349	8d 4d e8	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0034c	51		 push	 ecx
  0034d	8b 55 f8	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00350	52		 push	 edx
  00351	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00356	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3978 : #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 3979 : 
; 3980 : 	// *> . 사용자의 블러드 캐슬정보 초기화
; 3981 : #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 3982 : 	gObj[iIndex].m_cBloodCastleIndex = btBridgeNumber;
; 3983 : #else
; 3984 : 	gObj[iIndex].m_cBloodCastleIndex = iITEM_LEVEL-1;

  00359	8b 45 f0	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  0035c	83 e8 01	 sub	 eax, 1
  0035f	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00366	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0036c	88 84 0a d2 0c
	00 00		 mov	 BYTE PTR [edx+ecx+3282], al

; 3985 : #endif
; 3986 : 	gObj[iIndex].m_cBloodCastleSubIndex = iBC_INDEX;

  00373	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0037a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00380	8a 55 e0	 mov	 dl, BYTE PTR _iBC_INDEX$[ebp]
  00383	88 94 01 d3 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3283], dl

; 3987 : 	gObj[iIndex].m_iBloodCastleEXP = 0;

  0038a	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00391	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00397	c7 84 01 d4 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3284], 0

; 3988 : 
; 3989 : #ifdef BLOOD_DEVILSQUARE_TRADE_BUG_FIX
; 3990 : 	gObj[iIndex].m_IfState.state = 0;	

  003a2	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  003a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003af	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  003b6	80 e2 f3	 and	 dl, 243			; 000000f3H
  003b9	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  003c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003c6	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 3991 : 	gObj[iIndex].m_IfState.type = 0;

  003cd	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  003d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003da	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  003e1	80 e2 0f	 and	 dl, 15			; 0000000fH
  003e4	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  003eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f1	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 3992 : 	gObj[iIndex].m_IfState.use =  0;

  003f8	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  003ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00405	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0040c	80 e2 fc	 and	 dl, 252			; 000000fcH
  0040f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00416	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0041c	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 3993 : #endif
; 3994 : 	// *> . 파티를 맺고 있었다면 파티를  강제로 탈퇴시킴
; 3995 : /*	if( gObj[iIndex].PartyNumber >= 0 )
; 3996 : 	{
; 3997 : 		PMSG_PARTYDELUSER pMsg;
; 3998 : 		
; 3999 : 		int pindex = gParty.GetIndex(gObj[iIndex].PartyNumber, iIndex, gObj[iIndex].DBNumber);
; 4000 : 		if( pindex >= 0 )
; 4001 : 		{
; 4002 : 			pMsg.Number = pindex;
; 4003 : 			CGPartyDelUser( &pMsg, iIndex);
; 4004 : 		}
; 4005 : 	}
; 4006 : */
; 4007 : 	// *> . 만약을 대비하여 퀘스트 아이템들을 삭제한다.
; 4008 : 	g_BloodCastle.SearchUserDeleteQuestItem(iIndex);

  00423	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00426	50		 push	 eax
  00427	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0042c	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 4009 : 
; 4010 : 	// *> . 블러드캐슬로 이동하기 전에 DB에 이동카운트 증가시킴
; 4011 : 	EGBloodCastleEnterCountOn (iIndex);

  00431	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00434	50		 push	 eax
  00435	e8 00 00 00 00	 call	 ?EGBloodCastleEnterCountOn@@YAXH@Z ; EGBloodCastleEnterCountOn
  0043a	83 c4 04	 add	 esp, 4

; 4012 : 
; 4013 : 	// *> . 사용자 블러드 캐슬로 이동
; 4014 : 	CHAR szTemp [256];
; 4015 : #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 4016 : 	wsprintf(szTemp, lMsg.Get(1171), btBridgeNumber+1);			// "당신은 제 %d 블러드캐슬에 오셨습니다."
; 4017 : #else
; 4018 : 	wsprintf(szTemp, lMsg.Get(1171), iITEM_LEVEL);				// "당신은 제 %d 블러드캐슬에 오셨습니다."

  0043d	8b 45 f0	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  00440	50		 push	 eax
  00441	68 93 04 00 00	 push	 1171			; 00000493H
  00446	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0044b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00451	50		 push	 eax
  00452	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00458	51		 push	 ecx
  00459	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0045f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4019 : #endif
; 4020 : 	GCServerMsgStringSend(szTemp, iIndex, 1);

  00462	6a 01		 push	 1
  00464	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00467	50		 push	 eax
  00468	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0046e	51		 push	 ecx
  0046f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00474	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4021 : 
; 4022 : #ifdef BLOODCASTLE_EXTEND_20040314
; 4023 : 	#ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 4024 : 	if (btBridgeNumber+1 == iITEM_LEVEL) {
; 4025 : 		switch(iITEM_LEVEL) {
; 4026 : 		case 1 :		// 1캐슬
; 4027 : 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_1);
; 4028 : 			break;
; 4029 : 		case 2 :		// 2캐슬
; 4030 : 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_2);
; 4031 : 			break;
; 4032 : 		case 3 :		// 3캐슬
; 4033 : 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_3);
; 4034 : 			break;
; 4035 : 		case 4 :		// 4캐슬
; 4036 : 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_4);
; 4037 : 			break;
; 4038 : 		case 5 :		// 5캐슬
; 4039 : 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_5);
; 4040 : 			break;
; 4041 : 		case 6 :		// 6캐슬
; 4042 : 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_6);
; 4043 : 			break;
; 4044 : 		case 7 :		// 7캐슬
; 4045 : 			gObjMoveGate(iIndex, GATE_BLOODCASTLE_7);
; 4046 : 			break;
; 4047 : 		}
; 4048 : 	}
; 4049 : 	else if (btBridgeNumber+1 == 7 && iITEM_LEVEL == 6) {
; 4050 : 		// 7캐슬
; 4051 : 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_7);
; 4052 : 	}
; 4053 : 	#else // else USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 4054 : 	switch(iITEM_LEVEL) {

  00477	8b 45 f0	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  0047a	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv275[ebp], eax
  00480	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR tv275[ebp]
  00486	83 e9 01	 sub	 ecx, 1
  00489	89 8d 9c fe ff
	ff		 mov	 DWORD PTR tv275[ebp], ecx
  0048f	83 bd 9c fe ff
	ff 06		 cmp	 DWORD PTR tv275[ebp], 6
  00496	77 7b		 ja	 SHORT $LN2@EGBloodCas
  00498	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR tv275[ebp]
  0049e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN33@EGBloodCas[edx*4]
$LN21@EGBloodCas:

; 4055 : 	case 1 :		// 1캐슬
; 4056 : 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_1);

  004a5	6a 42		 push	 66			; 00000042H
  004a7	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004aa	50		 push	 eax
  004ab	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  004b0	83 c4 08	 add	 esp, 8

; 4057 : 		break;

  004b3	eb 5e		 jmp	 SHORT $LN2@EGBloodCas
$LN22@EGBloodCas:

; 4058 : 	case 2 :		// 2캐슬
; 4059 : 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_2);

  004b5	6a 43		 push	 67			; 00000043H
  004b7	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004ba	50		 push	 eax
  004bb	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  004c0	83 c4 08	 add	 esp, 8

; 4060 : 		break;

  004c3	eb 4e		 jmp	 SHORT $LN2@EGBloodCas
$LN23@EGBloodCas:

; 4061 : 	case 3 :		// 3캐슬
; 4062 : 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_3);

  004c5	6a 44		 push	 68			; 00000044H
  004c7	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004ca	50		 push	 eax
  004cb	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  004d0	83 c4 08	 add	 esp, 8

; 4063 : 		break;

  004d3	eb 3e		 jmp	 SHORT $LN2@EGBloodCas
$LN24@EGBloodCas:

; 4064 : 	case 4 :		// 4캐슬
; 4065 : 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_4);

  004d5	6a 45		 push	 69			; 00000045H
  004d7	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004da	50		 push	 eax
  004db	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  004e0	83 c4 08	 add	 esp, 8

; 4066 : 		break;

  004e3	eb 2e		 jmp	 SHORT $LN2@EGBloodCas
$LN25@EGBloodCas:

; 4067 : 	case 5 :		// 5캐슬
; 4068 : 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_5);

  004e5	6a 46		 push	 70			; 00000046H
  004e7	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004ea	50		 push	 eax
  004eb	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  004f0	83 c4 08	 add	 esp, 8

; 4069 : 		break;

  004f3	eb 1e		 jmp	 SHORT $LN2@EGBloodCas
$LN26@EGBloodCas:

; 4070 : 	case 6 :		// 6캐슬
; 4071 : 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_6);

  004f5	6a 47		 push	 71			; 00000047H
  004f7	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004fa	50		 push	 eax
  004fb	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00500	83 c4 08	 add	 esp, 8

; 4072 : 		break;

  00503	eb 0e		 jmp	 SHORT $LN2@EGBloodCas
$LN27@EGBloodCas:

; 4073 : 	case 7 :		// 7캐슬
; 4074 : 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_7);

  00505	6a 50		 push	 80			; 00000050H
  00507	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0050a	50		 push	 eax
  0050b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00510	83 c4 08	 add	 esp, 8
$LN2@EGBloodCas:

; 4075 : 		break;
; 4076 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 8캐슬 이동
; 4077 : 	case 8 :		// 8캐슬
; 4078 : 		gObjMoveGate(iIndex, GATE_BLOODCASTLE_8);
; 4079 : 		break;
; 4080 : #endif
; 4081 : 	}
; 4082 : 	#endif // USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 4083 : #else // else BLOODCASTLE_EXTEND_20040314
; 4084 : 	gObjMoveGate(iIndex, GATE_BLOODCASTLE_1 + iITEM_LEVEL - 1);	// 실제로는 해당 다리의 대기실로 이동
; 4085 : #endif // BLOODCASTLE_EXTEND_20040314
; 4086 : 
; 4087 : #ifdef EXTEND_LOG_SYSTEM_06_20070308
; 4088 : 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 4089 : 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%u), PCRoom:%d", 
; 4090 : 	#else
; 4091 : 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%d), PCRoom:%d", 
; 4092 : 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 4093 : 		iITEM_LEVEL, 
; 4094 : 		gObj[iIndex].AccountID,
; 4095 : 		gObj[iIndex].Name,
; 4096 : 		dwITEM_SERIAL,
; 4097 : 		gObj[iIndex].m_bPCBangUser
; 4098 : 		);
; 4099 : #else
; 4100 : 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 4101 : 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%u)", 
; 4102 : 	#else
; 4103 : 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%d)", 

  00513	8b 45 ec	 mov	 eax, DWORD PTR _dwITEM_SERIAL$[ebp]
  00516	50		 push	 eax
  00517	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  0051e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00524	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00528	50		 push	 eax
  00529	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00530	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00536	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0053a	50		 push	 eax
  0053b	8b 4d f0	 mov	 ecx, DWORD PTR _iITEM_LEVEL$[ebp]
  0053e	51		 push	 ecx
  0053f	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
  00544	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0054a	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@EGBloodCas:

; 4104 : 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 4105 : 		iITEM_LEVEL, 
; 4106 : 		gObj[iIndex].AccountID,
; 4107 : 		gObj[iIndex].Name,
; 4108 : 		dwITEM_SERIAL
; 4109 : 		);
; 4110 : #endif // EXTEND_LOG_SYSTEM_06_20070308
; 4111 : }

  0054d	5f		 pop	 edi
  0054e	5e		 pop	 esi
  0054f	5b		 pop	 ebx
  00550	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00553	33 cd		 xor	 ecx, ebp
  00555	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0055a	8b e5		 mov	 esp, ebp
  0055c	5d		 pop	 ebp
  0055d	c3		 ret	 0
  0055e	66 90		 npad	 2
$LN33@EGBloodCas:
  00560	00 00 00 00	 DD	 $LN21@EGBloodCas
  00564	00 00 00 00	 DD	 $LN22@EGBloodCas
  00568	00 00 00 00	 DD	 $LN23@EGBloodCas
  0056c	00 00 00 00	 DD	 $LN24@EGBloodCas
  00570	00 00 00 00	 DD	 $LN25@EGBloodCas
  00574	00 00 00 00	 DD	 $LN26@EGBloodCas
  00578	00 00 00 00	 DD	 $LN27@EGBloodCas
?EGBloodCastleEnterCountCheck@@YAXPAUPMSG_ANS_BLOODCASTLEENTERCHECK@@@Z ENDP ; EGBloodCastleEnterCountCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?FriendShipItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iRND$1 = -40						; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?FriendShipItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z PROC	; FriendShipItemBoxOpen, COMDAT

; 1801 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1802 : 	float dur;
; 1803 : 	int type, level, x, y;
; 1804 : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1805 : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1806 : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1807 : 	int DropItemNum;
; 1808 : 
; 1809 : //	if( !g_bDoRingEvent)	return;								// 반지 이벤트와 별도로 동작하도록
; 1810 : 
; 1811 : 
; 1812 : 	// 전사의 반지를 던질 때는 무조건 우정의돌 드롭  (한국 ~ 2004.03.30)
; 1813 : //	int iMaxHitUser = lpObj->m_Index;
; 1814 : //	int iType = ItemGetNumberMake(14, 21);	
; 1815 : //	int iItemLevel = 2;
; 1816 : //	ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE) lpObj->X, (BYTE) lpObj->Y, iType, iItemLevel, (BYTE)0, 0, 0, 0, iMaxHitUser);
; 1817 : 
; 1818 : 
; 1819 : #ifdef UPDATE_LOWLEVEL_SUPPORT_RING_20070119	// 용사, 전사(우정의 돌)의 반지 추가/수정
; 1820 : 	if( FriendShipItemBag->GetBagCount() > 0 )
; 1821 : #else
; 1822 : 	if( RingEventItemBag->GetBagCount() > 0 )

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RingEventItemBag@@3PAVCItemBag@@A ; RingEventItemBag
  00024	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00029	85 c0		 test	 eax, eax
  0002b	0f 8e 45 02 00
	00		 jle	 $LN3@FriendShip

; 1823 : #endif
; 1824 : 	{
; 1825 : 		// 9/10 의 확률로 이벤트용 아이템 증정
; 1826 : 		//if( (rand()%10) < 9 )
; 1827 : 		if(1)

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	0f 84 38 02 00
	00		 je	 $LN3@FriendShip

; 1828 : 		{
; 1829 : #ifdef UPDATE_LOWLEVEL_SUPPORT_RING_20070119	// 용사, 전사(우정의 돌)의 반지 추가/수정
; 1830 : 			DropItemNum = (rand()%FriendShipItemBag->GetBagCount());
; 1831 : #else
; 1832 : 			DropItemNum = (rand()%RingEventItemBag->GetBagCount());

  0003e	e8 00 00 00 00	 call	 _rand
  00043	8b f0		 mov	 esi, eax
  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RingEventItemBag@@3PAVCItemBag@@A ; RingEventItemBag
  0004b	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00050	8b c8		 mov	 ecx, eax
  00052	8b c6		 mov	 eax, esi
  00054	99		 cdq
  00055	f7 f9		 idiv	 ecx
  00057	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 1833 : #endif			
; 1834 : 			dur  = 0;

  0005a	0f 57 c0	 xorps	 xmm0, xmm0
  0005d	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 1835 : 			x    = lpObj->X;

  00062	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00065	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0006c	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1836 : 			y    = lpObj->Y;

  0006f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00072	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00079	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1837 : 
; 1838 : #ifdef UPDATE_LOWLEVEL_SUPPORT_RING_20070119	// 용사, 전사(우정의 돌)의 반지 추가/수정
; 1839 : 			// 레벨이 7 ~ 9 까지
; 1840 : 			level= FriendShipItemBag->GetLevel(DropItemNum)+(rand()%3);
; 1841 : #else
; 1842 : 			INT iRND = rand()%100;

  0007c	e8 00 00 00 00	 call	 _rand
  00081	99		 cdq
  00082	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00087	f7 f9		 idiv	 ecx
  00089	89 55 d8	 mov	 DWORD PTR _iRND$1[ebp], edx

; 1843 : 
; 1844 : 			if (iRND < 5) {			// 5%

  0008c	83 7d d8 05	 cmp	 DWORD PTR _iRND$1[ebp], 5
  00090	7d 09		 jge	 SHORT $LN4@FriendShip

; 1845 : 				level = 9;

  00092	c7 45 f4 09 00
	00 00		 mov	 DWORD PTR _level$[ebp], 9

; 1846 : 			}

  00099	eb 25		 jmp	 SHORT $LN9@FriendShip
$LN4@FriendShip:

; 1847 : 			else if (iRND < 20) {	// 15%

  0009b	83 7d d8 14	 cmp	 DWORD PTR _iRND$1[ebp], 20 ; 00000014H
  0009f	7d 09		 jge	 SHORT $LN6@FriendShip

; 1848 : 				level = 8;

  000a1	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _level$[ebp], 8

; 1849 : 			}

  000a8	eb 16		 jmp	 SHORT $LN9@FriendShip
$LN6@FriendShip:

; 1850 : 			else if (iRND < 50) {	// 30%

  000aa	83 7d d8 32	 cmp	 DWORD PTR _iRND$1[ebp], 50 ; 00000032H
  000ae	7d 09		 jge	 SHORT $LN8@FriendShip

; 1851 : 				level = 7;

  000b0	c7 45 f4 07 00
	00 00		 mov	 DWORD PTR _level$[ebp], 7

; 1852 : 			}

  000b7	eb 07		 jmp	 SHORT $LN9@FriendShip
$LN8@FriendShip:

; 1853 : 			else {					// 50%
; 1854 : 				level = 6;

  000b9	c7 45 f4 06 00
	00 00		 mov	 DWORD PTR _level$[ebp], 6
$LN9@FriendShip:

; 1855 : 			}
; 1856 : #endif	// UPDATE_LOWLEVEL_SUPPORT_RING_20070119
; 1857 : 
; 1858 : #ifdef UPDATE_LOWLEVEL_SUPPORT_RING_20070119	// 용사, 전사(우정의 돌)의 반지 추가/수정
; 1859 : 			type = ItemGetNumberMake(FriendShipItemBag->GetType(DropItemNum), FriendShipItemBag->GetIndex(DropItemNum));
; 1860 : #else
; 1861 : 			type = ItemGetNumberMake(RingEventItemBag->GetType(DropItemNum), RingEventItemBag->GetIndex(DropItemNum));

  000c0	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000c3	50		 push	 eax
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RingEventItemBag@@3PAVCItemBag@@A ; RingEventItemBag
  000ca	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  000cf	0f b6 c8	 movzx	 ecx, al
  000d2	51		 push	 ecx
  000d3	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  000d6	52		 push	 edx
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RingEventItemBag@@3PAVCItemBag@@A ; RingEventItemBag
  000dd	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  000e2	0f b6 c0	 movzx	 eax, al
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000eb	83 c4 08	 add	 esp, 8
  000ee	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 1862 : #endif
; 1863 : 
; 1864 : 			Option1 = 1;			// 스킬

  000f1	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1

; 1865 : 			Option2 = rand()%2;		// 행운

  000f8	e8 00 00 00 00	 call	 _rand
  000fd	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00102	79 05		 jns	 SHORT $LN17@FriendShip
  00104	48		 dec	 eax
  00105	83 c8 fe	 or	 eax, -2			; fffffffeH
  00108	40		 inc	 eax
$LN17@FriendShip:
  00109	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 1866 : 
; 1867 : 			if( (rand()%5) < 1 )	// 추가옵션

  0010c	e8 00 00 00 00	 call	 _rand
  00111	99		 cdq
  00112	b9 05 00 00 00	 mov	 ecx, 5
  00117	f7 f9		 idiv	 ecx
  00119	83 fa 01	 cmp	 edx, 1
  0011c	7d 09		 jge	 SHORT $LN10@FriendShip

; 1868 : 			{
; 1869 : 				Option3 = 3;

  0011e	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 1870 : 			}

  00125	eb 10		 jmp	 SHORT $LN11@FriendShip
$LN10@FriendShip:

; 1871 : 			else Option3 = (rand()%3);

  00127	e8 00 00 00 00	 call	 _rand
  0012c	99		 cdq
  0012d	b9 03 00 00 00	 mov	 ecx, 3
  00132	f7 f9		 idiv	 ecx
  00134	89 55 e0	 mov	 DWORD PTR _Option3$[ebp], edx
$LN11@FriendShip:

; 1872 : 			
; 1873 : 			// 혼석, 축석, 영석은 레벨이 없게
; 1874 : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 1875 : 				(type == MAKE_ITEMNUM(14, 13)) ||

  00137	6a 0f		 push	 15			; 0000000fH
  00139	6a 0c		 push	 12			; 0000000cH
  0013b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00140	83 c4 08	 add	 esp, 8
  00143	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00146	74 22		 je	 SHORT $LN13@FriendShip
  00148	6a 0d		 push	 13			; 0000000dH
  0014a	6a 0e		 push	 14			; 0000000eH
  0014c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00151	83 c4 08	 add	 esp, 8
  00154	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00157	74 11		 je	 SHORT $LN13@FriendShip
  00159	6a 0e		 push	 14			; 0000000eH
  0015b	6a 0e		 push	 14			; 0000000eH
  0015d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00162	83 c4 08	 add	 esp, 8
  00165	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00168	75 1c		 jne	 SHORT $LN12@FriendShip
$LN13@FriendShip:

; 1876 : 				(type == MAKE_ITEMNUM(14, 14)) )
; 1877 : 			{	
; 1878 : 				Option1 = 0; 

  0016a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1879 : 				Option2 = 0;

  00171	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1880 : 				Option3 = 0;

  00178	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1881 : 				level   = 0;

  0017f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN12@FriendShip:

; 1882 : 			}
; 1883 : 
; 1884 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 1885 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 1886 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 1887 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 1888 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 1889 : 				(type == MAKE_ITEMNUM(13, 12)) ||

  00186	6a 00		 push	 0
  00188	6a 0d		 push	 13			; 0000000dH
  0018a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0018f	83 c4 08	 add	 esp, 8
  00192	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00195	74 66		 je	 SHORT $LN15@FriendShip
  00197	6a 01		 push	 1
  00199	6a 0d		 push	 13			; 0000000dH
  0019b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001a0	83 c4 08	 add	 esp, 8
  001a3	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001a6	74 55		 je	 SHORT $LN15@FriendShip
  001a8	6a 02		 push	 2
  001aa	6a 0d		 push	 13			; 0000000dH
  001ac	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001b1	83 c4 08	 add	 esp, 8
  001b4	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001b7	74 44		 je	 SHORT $LN15@FriendShip
  001b9	6a 08		 push	 8
  001bb	6a 0d		 push	 13			; 0000000dH
  001bd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001c2	83 c4 08	 add	 esp, 8
  001c5	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001c8	74 33		 je	 SHORT $LN15@FriendShip
  001ca	6a 09		 push	 9
  001cc	6a 0d		 push	 13			; 0000000dH
  001ce	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001d3	83 c4 08	 add	 esp, 8
  001d6	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001d9	74 22		 je	 SHORT $LN15@FriendShip
  001db	6a 0c		 push	 12			; 0000000cH
  001dd	6a 0d		 push	 13			; 0000000dH
  001df	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e4	83 c4 08	 add	 esp, 8
  001e7	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ea	74 11		 je	 SHORT $LN15@FriendShip
  001ec	6a 0d		 push	 13			; 0000000dH
  001ee	6a 0d		 push	 13			; 0000000dH
  001f0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f5	83 c4 08	 add	 esp, 8
  001f8	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001fb	75 07		 jne	 SHORT $LN14@FriendShip
$LN15@FriendShip:

; 1890 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 1891 : 			{	// 반지류는 레벨 0
; 1892 : 				level   = 0;

  001fd	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN14@FriendShip:

; 1893 : 			}
; 1894 : 			
; 1895 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);

  00204	6a 00		 push	 0
  00206	6a 00		 push	 0
  00208	6a 00		 push	 0
  0020a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0020d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020f	51		 push	 ecx
  00210	0f b6 55 e0	 movzx	 edx, BYTE PTR _Option3$[ebp]
  00214	52		 push	 edx
  00215	0f b6 45 e4	 movzx	 eax, BYTE PTR _Option2$[ebp]
  00219	50		 push	 eax
  0021a	0f b6 4d e8	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  0021e	51		 push	 ecx
  0021f	f3 0f 2c 55 fc	 cvttss2si edx, DWORD PTR _dur$[ebp]
  00224	0f b6 c2	 movzx	 eax, dl
  00227	50		 push	 eax
  00228	0f b6 4d f4	 movzx	 ecx, BYTE PTR _level$[ebp]
  0022c	51		 push	 ecx
  0022d	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  00230	52		 push	 edx
  00231	0f b6 45 ec	 movzx	 eax, BYTE PTR _y$[ebp]
  00235	50		 push	 eax
  00236	0f b6 4d f0	 movzx	 ecx, BYTE PTR _x$[ebp]
  0023a	51		 push	 ecx
  0023b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0023e	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00245	50		 push	 eax
  00246	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00249	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024b	52		 push	 edx
  0024c	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00251	83 c4 38	 add	 esp, 56			; 00000038H

; 1896 : 
; 1897 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 1898 : 			CItem EventItem;
; 1899 : 			EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 1900 : 			LogAddTD("[%s][%s][FriendShip Ring Event](%d,%d,%d) ItemDrop : Item:%s %d Level:%d op1:%d op2:%d op3:%d",
; 1901 : 				lpObj->AccountID, lpObj->Name,
; 1902 : 				lpObj->MapNumber, lpObj->X, lpObj->Y,
; 1903 : 				EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 1904 : #else
; 1905 : 			LogAddTD("[FriendShip Ring Event] ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  00254	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  00257	50		 push	 eax
  00258	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  0025b	51		 push	 ecx
  0025c	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  0025f	52		 push	 edx
  00260	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  00263	50		 push	 eax
  00264	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00267	51		 push	 ecx
  00268	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@CFBKDBPL@?$FLFriendShip?5Ring?5Event?$FN?5ItemDro@
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00273	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@FriendShip:

; 1906 : 			return;
; 1907 : #endif // EXTEND_LOG_SYSTEM_20060202
; 1908 : 			return;
; 1909 : 		}
; 1910 : 	}
; 1911 : 	//x    = lpObj->X;
; 1912 : 	//y    = lpObj->Y;	
; 1913 : 	//MapC[lpObj->MapNumber].MoneyItemDrop(100000, x ,y);	
; 1914 : }

  00276	5f		 pop	 edi
  00277	5e		 pop	 esi
  00278	5b		 pop	 ebx
  00279	8b e5		 mov	 esp, ebp
  0027b	5d		 pop	 ebp
  0027c	c3		 ret	 0
?FriendShipItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; FriendShipItemBoxOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?RingEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iRND$1 = -40						; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?RingEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z PROC	; RingEventItemBoxOpen, COMDAT

; 1626 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1627 : 	float dur;
; 1628 : 	int type, level, x, y;
; 1629 : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1630 : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1631 : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1632 : 	int DropItemNum;
; 1633 : 
; 1634 : //	if( !g_bDoRingEvent)	return;								// 반지 이벤트와 별도로 동작하도록
; 1635 : 
; 1636 : 
; 1637 : #ifndef FRIENDSHIP_EVENT_RING_BOX_20040211
; 1638 : 	if (rand()%g_iRingDropGiftRate == 0) {
; 1639 : 		// --- SendEventGiftWinner() ---						// 반지를 던진 경품을 탄다.
; 1640 : 		if( lpObj->UseEventServer )
; 1641 : 		return;
; 1642 : 
; 1643 : 		lpObj->UseEventServer = TRUE;
; 1644 : 
; 1645 : 		PMSG_REQ_REG_RINGGIFT pMsg;
; 1646 : 
; 1647 : 		PHeadSetB((LPBYTE)&pMsg, 0x10, sizeof(pMsg));
; 1648 : 
; 1649 : 		pMsg.iINDEX = lpObj->m_Index;
; 1650 : 		memcpy (pMsg.szUID, lpObj->AccountID, MAX_IDSTRING);
; 1651 : 		pMsg.szUID[sizeof(pMsg.szUID)] = 0;
; 1652 : 		pMsg.btGiftKind = 0;
; 1653 : 
; 1654 : 		DataSendEventChip((char*)&pMsg, sizeof(pMsg));
; 1655 : 
; 1656 : 		LogAddTD("[Ring Event] [%s][%s] Request to Register Gift - Gift Kind (%d)", lpObj->AccountID, lpObj->Name, 0);
; 1657 : 		// --- SendEventGiftWinner() ---
; 1658 : 		return;
; 1659 : 	}
; 1660 : #else // else FRIENDSHIP_EVENT_RING_BOX_20040211
; 1661 : 	// 용사의 반지를 던질 때는 무조건 우정의돌 드롭 (한국 ~ 2004.03.30)
; 1662 : //	int iMaxHitUser = lpObj->m_Index;
; 1663 : //	int iType = ItemGetNumberMake(14, 21);	
; 1664 : //	int iItemLevel = 2;
; 1665 : //	ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE) lpObj->X, (BYTE) lpObj->Y, iType, iItemLevel, (BYTE)0, 0, 0, 0, iMaxHitUser);
; 1666 : #endif // FRIENDSHIP_EVENT_RING_BOX_20040211
; 1667 : 
; 1668 : 	if( RingEventItemBag->GetBagCount() > 0 )

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RingEventItemBag@@3PAVCItemBag@@A ; RingEventItemBag
  00024	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00029	85 c0		 test	 eax, eax
  0002b	0f 8e 50 02 00
	00		 jle	 $LN3@RingEventI

; 1669 : 	{
; 1670 : 		// 9/10 의 확률로 이벤트용 아이템 증정
; 1671 : //		if( (rand()%10) < g_XMasEvent_ItemDropRateForStarOfXMas )
; 1672 : 		if( (rand()%10) < 9 )

  00031	e8 00 00 00 00	 call	 _rand
  00036	99		 cdq
  00037	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0003c	f7 f9		 idiv	 ecx
  0003e	83 fa 09	 cmp	 edx, 9
  00041	0f 8d 3a 02 00
	00		 jge	 $LN3@RingEventI

; 1673 : 		{
; 1674 : 			DropItemNum = (rand()%RingEventItemBag->GetBagCount());

  00047	e8 00 00 00 00	 call	 _rand
  0004c	8b f0		 mov	 esi, eax
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RingEventItemBag@@3PAVCItemBag@@A ; RingEventItemBag
  00054	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00059	8b c8		 mov	 ecx, eax
  0005b	8b c6		 mov	 eax, esi
  0005d	99		 cdq
  0005e	f7 f9		 idiv	 ecx
  00060	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 1675 : 			dur  = 0;

  00063	0f 57 c0	 xorps	 xmm0, xmm0
  00066	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 1676 : 			x    = lpObj->X;

  0006b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00075	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1677 : 			y    = lpObj->Y;

  00078	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007b	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00082	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1678 : 
; 1679 : 			INT iRND = rand()%100;

  00085	e8 00 00 00 00	 call	 _rand
  0008a	99		 cdq
  0008b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00090	f7 f9		 idiv	 ecx
  00092	89 55 d8	 mov	 DWORD PTR _iRND$1[ebp], edx

; 1680 : 
; 1681 : 			if (iRND < 5) {			// 5%

  00095	83 7d d8 05	 cmp	 DWORD PTR _iRND$1[ebp], 5
  00099	7d 09		 jge	 SHORT $LN4@RingEventI

; 1682 : 				level = 9;

  0009b	c7 45 f4 09 00
	00 00		 mov	 DWORD PTR _level$[ebp], 9

; 1683 : 			}

  000a2	eb 25		 jmp	 SHORT $LN9@RingEventI
$LN4@RingEventI:

; 1684 : 			else if (iRND < 20) {	// 15%

  000a4	83 7d d8 14	 cmp	 DWORD PTR _iRND$1[ebp], 20 ; 00000014H
  000a8	7d 09		 jge	 SHORT $LN6@RingEventI

; 1685 : 				level = 8;

  000aa	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _level$[ebp], 8

; 1686 : 			}

  000b1	eb 16		 jmp	 SHORT $LN9@RingEventI
$LN6@RingEventI:

; 1687 : 			else if (iRND < 50) {	// 30%

  000b3	83 7d d8 32	 cmp	 DWORD PTR _iRND$1[ebp], 50 ; 00000032H
  000b7	7d 09		 jge	 SHORT $LN8@RingEventI

; 1688 : 				level = 7;

  000b9	c7 45 f4 07 00
	00 00		 mov	 DWORD PTR _level$[ebp], 7

; 1689 : 			}

  000c0	eb 07		 jmp	 SHORT $LN9@RingEventI
$LN8@RingEventI:

; 1690 : 			else {					// 50%
; 1691 : 				level = 6;

  000c2	c7 45 f4 06 00
	00 00		 mov	 DWORD PTR _level$[ebp], 6
$LN9@RingEventI:

; 1692 : 			}
; 1693 : 
; 1694 : /*			
; 1695 : 			if (rand()%100 < 30) {
; 1696 : 				// + 6
; 1697 : 				level = 6;
; 1698 : 			}
; 1699 : 			else if (rand()%100 < 12) {
; 1700 : 				// + 7
; 1701 : 				level = 7;
; 1702 : 			}
; 1703 : 			else if (rand()%100 < 5) {
; 1704 : 				// + 8
; 1705 : 				level = 8;
; 1706 : 			}
; 1707 : 			else if (rand()%100 < 2) {
; 1708 : 				// + 9
; 1709 : 				level = 9;
; 1710 : 			}
; 1711 : 			else {
; 1712 : 				// + 5
; 1713 : 				level = 5;
; 1714 : 			}
; 1715 : */
; 1716 : 			type = ItemGetNumberMake(RingEventItemBag->GetType(DropItemNum), RingEventItemBag->GetIndex(DropItemNum));

  000c9	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000cc	50		 push	 eax
  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RingEventItemBag@@3PAVCItemBag@@A ; RingEventItemBag
  000d3	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  000d8	0f b6 c8	 movzx	 ecx, al
  000db	51		 push	 ecx
  000dc	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  000df	52		 push	 edx
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RingEventItemBag@@3PAVCItemBag@@A ; RingEventItemBag
  000e6	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  000eb	0f b6 c0	 movzx	 eax, al
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000f4	83 c4 08	 add	 esp, 8
  000f7	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 1717 : 
; 1718 : 			Option1 = 1;			// 스킬

  000fa	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1

; 1719 : 			Option2 = rand()%2;		// 행운

  00101	e8 00 00 00 00	 call	 _rand
  00106	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0010b	79 05		 jns	 SHORT $LN17@RingEventI
  0010d	48		 dec	 eax
  0010e	83 c8 fe	 or	 eax, -2			; fffffffeH
  00111	40		 inc	 eax
$LN17@RingEventI:
  00112	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 1720 : 
; 1721 : 			if( (rand()%5) < 1 )	// 추가옵션

  00115	e8 00 00 00 00	 call	 _rand
  0011a	99		 cdq
  0011b	b9 05 00 00 00	 mov	 ecx, 5
  00120	f7 f9		 idiv	 ecx
  00122	83 fa 01	 cmp	 edx, 1
  00125	7d 09		 jge	 SHORT $LN10@RingEventI

; 1722 : 			{
; 1723 : 				Option3 = 3;

  00127	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 1724 : 			}

  0012e	eb 10		 jmp	 SHORT $LN11@RingEventI
$LN10@RingEventI:

; 1725 : 			else Option3 = (rand()%3);

  00130	e8 00 00 00 00	 call	 _rand
  00135	99		 cdq
  00136	b9 03 00 00 00	 mov	 ecx, 3
  0013b	f7 f9		 idiv	 ecx
  0013d	89 55 e0	 mov	 DWORD PTR _Option3$[ebp], edx
$LN11@RingEventI:

; 1726 : 			
; 1727 : /*			
; 1728 : 			if( (rand()%100) < 70 ) {
; 1729 : 				Option1 = 1;	// 스킬
; 1730 : 			}
; 1731 : 
; 1732 : 			if( (rand()%100) < 4 ) {
; 1733 : 				Option2 = 1;	// 행운
; 1734 : 			}
; 1735 : 			
; 1736 : 			int option3rand = (rand()%100);
; 1737 : 			int	optionc		= (rand()%3);
; 1738 : 
; 1739 : 			switch( optionc )
; 1740 : 			{	// 꽝 80%
; 1741 : 			case 0 :
; 1742 : 				if( option3rand < 4 ) Option3 = 3;	// 옵션
; 1743 : 				break;
; 1744 : 			case 1 :
; 1745 : 				if( option3rand < 10 ) Option3 = 2;	// 옵션
; 1746 : 				break;
; 1747 : 			case 2 :
; 1748 : 				if( option3rand < 20 ) Option3 = 1;	// 옵션
; 1749 : 				break;
; 1750 : 			}
; 1751 : */
; 1752 : 
; 1753 : 			// 혼석, 축석, 영석은 레벨이 없게
; 1754 : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 1755 : 				(type == MAKE_ITEMNUM(14, 13)) ||

  00140	6a 0f		 push	 15			; 0000000fH
  00142	6a 0c		 push	 12			; 0000000cH
  00144	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00149	83 c4 08	 add	 esp, 8
  0014c	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0014f	74 22		 je	 SHORT $LN13@RingEventI
  00151	6a 0d		 push	 13			; 0000000dH
  00153	6a 0e		 push	 14			; 0000000eH
  00155	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0015a	83 c4 08	 add	 esp, 8
  0015d	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00160	74 11		 je	 SHORT $LN13@RingEventI
  00162	6a 0e		 push	 14			; 0000000eH
  00164	6a 0e		 push	 14			; 0000000eH
  00166	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0016b	83 c4 08	 add	 esp, 8
  0016e	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00171	75 1c		 jne	 SHORT $LN12@RingEventI
$LN13@RingEventI:

; 1756 : 				(type == MAKE_ITEMNUM(14, 14)) )
; 1757 : 			{	
; 1758 : 				Option1 = 0; 

  00173	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1759 : 				Option2 = 0;

  0017a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1760 : 				Option3 = 0;

  00181	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1761 : 				level   = 0;

  00188	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN12@RingEventI:

; 1762 : 			}
; 1763 : 
; 1764 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 1765 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 1766 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 1767 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 1768 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 1769 : 				(type == MAKE_ITEMNUM(13, 12)) ||

  0018f	6a 00		 push	 0
  00191	6a 0d		 push	 13			; 0000000dH
  00193	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00198	83 c4 08	 add	 esp, 8
  0019b	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0019e	74 66		 je	 SHORT $LN15@RingEventI
  001a0	6a 01		 push	 1
  001a2	6a 0d		 push	 13			; 0000000dH
  001a4	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001a9	83 c4 08	 add	 esp, 8
  001ac	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001af	74 55		 je	 SHORT $LN15@RingEventI
  001b1	6a 02		 push	 2
  001b3	6a 0d		 push	 13			; 0000000dH
  001b5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001ba	83 c4 08	 add	 esp, 8
  001bd	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001c0	74 44		 je	 SHORT $LN15@RingEventI
  001c2	6a 08		 push	 8
  001c4	6a 0d		 push	 13			; 0000000dH
  001c6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001cb	83 c4 08	 add	 esp, 8
  001ce	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001d1	74 33		 je	 SHORT $LN15@RingEventI
  001d3	6a 09		 push	 9
  001d5	6a 0d		 push	 13			; 0000000dH
  001d7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001dc	83 c4 08	 add	 esp, 8
  001df	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001e2	74 22		 je	 SHORT $LN15@RingEventI
  001e4	6a 0c		 push	 12			; 0000000cH
  001e6	6a 0d		 push	 13			; 0000000dH
  001e8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001ed	83 c4 08	 add	 esp, 8
  001f0	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001f3	74 11		 je	 SHORT $LN15@RingEventI
  001f5	6a 0d		 push	 13			; 0000000dH
  001f7	6a 0d		 push	 13			; 0000000dH
  001f9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001fe	83 c4 08	 add	 esp, 8
  00201	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00204	75 07		 jne	 SHORT $LN14@RingEventI
$LN15@RingEventI:

; 1770 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 1771 : 			{	// 반지류는 레벨 0
; 1772 : 				level   = 0;

  00206	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN14@RingEventI:

; 1773 : 			}
; 1774 : 
; 1775 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);

  0020d	6a 00		 push	 0
  0020f	6a 00		 push	 0
  00211	6a 00		 push	 0
  00213	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00216	8b 08		 mov	 ecx, DWORD PTR [eax]
  00218	51		 push	 ecx
  00219	0f b6 55 e0	 movzx	 edx, BYTE PTR _Option3$[ebp]
  0021d	52		 push	 edx
  0021e	0f b6 45 e4	 movzx	 eax, BYTE PTR _Option2$[ebp]
  00222	50		 push	 eax
  00223	0f b6 4d e8	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  00227	51		 push	 ecx
  00228	f3 0f 2c 55 fc	 cvttss2si edx, DWORD PTR _dur$[ebp]
  0022d	0f b6 c2	 movzx	 eax, dl
  00230	50		 push	 eax
  00231	0f b6 4d f4	 movzx	 ecx, BYTE PTR _level$[ebp]
  00235	51		 push	 ecx
  00236	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  00239	52		 push	 edx
  0023a	0f b6 45 ec	 movzx	 eax, BYTE PTR _y$[ebp]
  0023e	50		 push	 eax
  0023f	0f b6 4d f0	 movzx	 ecx, BYTE PTR _x$[ebp]
  00243	51		 push	 ecx
  00244	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00247	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0024e	50		 push	 eax
  0024f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00252	8b 11		 mov	 edx, DWORD PTR [ecx]
  00254	52		 push	 edx
  00255	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0025a	83 c4 38	 add	 esp, 56			; 00000038H

; 1776 : 
; 1777 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 1778 : 			CItem EventItem;
; 1779 : 			EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 1780 : 			LogAddTD("[%s][%s][Ring Event](%d,%d,%d) ItemDrop : Item:%s %d Level:%d op1:%d op2:%d op3:%d",
; 1781 : 				lpObj->AccountID, lpObj->Name,
; 1782 : 				lpObj->MapNumber, lpObj->X, lpObj->Y,
; 1783 : 				EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 1784 : #else
; 1785 : 			LogAddTD("[Ring Event] ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  0025d	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  00260	50		 push	 eax
  00261	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  00264	51		 push	 ecx
  00265	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  00268	52		 push	 edx
  00269	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  0026c	50		 push	 eax
  0026d	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00270	51		 push	 ecx
  00271	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@CACDLGAI@?$FLRing?5Event?$FN?5ItemDrop?5?3?5Item?3?$CFd@
  00276	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0027c	83 c4 18	 add	 esp, 24			; 00000018H

; 1786 : #endif
; 1787 : 			return;

  0027f	eb 42		 jmp	 SHORT $LN1@RingEventI
$LN3@RingEventI:

; 1788 : 		}
; 1789 : 	}
; 1790 : 	x    = lpObj->X;

  00281	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00284	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0028b	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1791 : 	y    = lpObj->Y;	

  0028e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00291	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00298	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1792 : 	MapC[lpObj->MapNumber].MoneyItemDrop(100000, x ,y);

  0029b	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  0029e	50		 push	 eax
  0029f	8b 4d f0	 mov	 ecx, DWORD PTR _x$[ebp]
  002a2	51		 push	 ecx
  002a3	68 a0 86 01 00	 push	 100000			; 000186a0H
  002a8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002ab	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  002b2	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  002b8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  002be	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN1@RingEventI:

; 1793 : }

  002c3	5f		 pop	 edi
  002c4	5e		 pop	 esi
  002c5	5b		 pop	 ebx
  002c6	8b e5		 mov	 esp, ebp
  002c8	5d		 pop	 ebp
  002c9	c3		 ret	 0
?RingEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; RingEventItemBoxOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
tv64 = -128						; size = 4
_ExItemCount$1 = -60					; size = 4
_NormalItemCount$2 = -56				; size = 4
_EledoradoBox$ = -52					; size = 4
_ExItemDropRate$ = -48					; size = 4
_ItemDropRate$ = -44					; size = 4
_ExOption$ = -40					; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_boxtype$ = 12						; size = 4
_addlevel$ = 16						; size = 4
_money$ = 20						; size = 4
?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z PROC	; EledoradoBoxOpenEven, COMDAT

; 604  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 605  : 	float dur;
; 606  : 	int type, level, x, y;
; 607  : 	int Option1 = 0;

  0000c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 608  : 	int Option2 = 0;

  00013	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 609  : 	int Option3 = 0;

  0001a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 610  : 	int DropItemNum = -1;

  00021	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _DropItemNum$[ebp], -1

; 611  : 	int ExOption = 0;

  00028	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ExOption$[ebp], 0

; 612  : 
; 613  : 	int ItemDropRate = 0;

  0002f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _ItemDropRate$[ebp], 0

; 614  : 	int ExItemDropRate = 0;

  00036	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _ExItemDropRate$[ebp], 0

; 615  : 
; 616  : 	CItemBag* EledoradoBox = NULL;

  0003d	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _EledoradoBox$[ebp], 0

; 617  : 
; 618  : 	switch(boxtype)

  00044	8b 45 0c	 mov	 eax, DWORD PTR _boxtype$[ebp]
  00047	89 45 80	 mov	 DWORD PTR tv64[ebp], eax
  0004a	8b 4d 80	 mov	 ecx, DWORD PTR tv64[ebp]
  0004d	83 e9 08	 sub	 ecx, 8
  00050	89 4d 80	 mov	 DWORD PTR tv64[ebp], ecx
  00053	83 7d 80 04	 cmp	 DWORD PTR tv64[ebp], 4
  00057	0f 87 8a 00 00
	00		 ja	 $LN2@EledoradoB
  0005d	8b 55 80	 mov	 edx, DWORD PTR tv64[ebp]
  00060	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN35@EledoradoB[edx*4]
$LN4@EledoradoB:

; 619  : 	{
; 620  : 		case 8:
; 621  : 			{
; 622  : 				EledoradoBox = GoldGoblenItemBag;

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GoldGoblenItemBag@@3PAVCItemBag@@A ; GoldGoblenItemBag
  0006c	89 45 cc	 mov	 DWORD PTR _EledoradoBox$[ebp], eax

; 623  : 				ItemDropRate = gEledoradoGoldGoblenItemDropRate;

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoGoldGoblenItemDropRate@@3HA ; gEledoradoGoldGoblenItemDropRate
  00074	89 45 d4	 mov	 DWORD PTR _ItemDropRate$[ebp], eax

; 624  : 				ExItemDropRate = gEledoradoGoldGoblenExItemDropRate;

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoGoldGoblenExItemDropRate@@3HA ; gEledoradoGoldGoblenExItemDropRate
  0007c	89 45 d0	 mov	 DWORD PTR _ExItemDropRate$[ebp], eax

; 625  : 			}
; 626  : 		break;

  0007f	eb 66		 jmp	 SHORT $LN2@EledoradoB
$LN5@EledoradoB:

; 627  : 		case 9:
; 628  : 			{
; 629  : 				EledoradoBox = TitanItemBag;

  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?TitanItemBag@@3PAVCItemBag@@A ; TitanItemBag
  00086	89 45 cc	 mov	 DWORD PTR _EledoradoBox$[ebp], eax

; 630  : 				ItemDropRate = gEledoradoTitanItemDropRate;

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoTitanItemDropRate@@3HA ; gEledoradoTitanItemDropRate
  0008e	89 45 d4	 mov	 DWORD PTR _ItemDropRate$[ebp], eax

; 631  : 				ExItemDropRate = gEledoradoTitanExItemDropRate;

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoTitanExItemDropRate@@3HA ; gEledoradoTitanExItemDropRate
  00096	89 45 d0	 mov	 DWORD PTR _ExItemDropRate$[ebp], eax

; 632  : 			}
; 633  : 		break;

  00099	eb 4c		 jmp	 SHORT $LN2@EledoradoB
$LN6@EledoradoB:

; 634  : 		case 10:
; 635  : 			{
; 636  : 				EledoradoBox = GoldDerconItemBag;

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GoldDerconItemBag@@3PAVCItemBag@@A ; GoldDerconItemBag
  000a0	89 45 cc	 mov	 DWORD PTR _EledoradoBox$[ebp], eax

; 637  : 				ItemDropRate = gEledoradoGoldDerconItemDropRate;

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoGoldDerconItemDropRate@@3HA ; gEledoradoGoldDerconItemDropRate
  000a8	89 45 d4	 mov	 DWORD PTR _ItemDropRate$[ebp], eax

; 638  : 				ExItemDropRate = gEledoradoGoldDerconExItemDropRate;

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoGoldDerconExItemDropRate@@3HA ; gEledoradoGoldDerconExItemDropRate
  000b0	89 45 d0	 mov	 DWORD PTR _ExItemDropRate$[ebp], eax

; 639  : 			}
; 640  : 		break;

  000b3	eb 32		 jmp	 SHORT $LN2@EledoradoB
$LN7@EledoradoB:

; 641  : 		case 11:
; 642  : 			{
; 643  : 				EledoradoBox = DevilLizardKingItemBag;

  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DevilLizardKingItemBag@@3PAVCItemBag@@A ; DevilLizardKingItemBag
  000ba	89 45 cc	 mov	 DWORD PTR _EledoradoBox$[ebp], eax

; 644  : 				ItemDropRate = gEledoradoDevilLizardKingItemDropRate;

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoDevilLizardKingItemDropRate@@3HA ; gEledoradoDevilLizardKingItemDropRate
  000c2	89 45 d4	 mov	 DWORD PTR _ItemDropRate$[ebp], eax

; 645  : 				ExItemDropRate = gEledoradoDevilLizardKingExItemDropRate;

  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoDevilLizardKingExItemDropRate@@3HA ; gEledoradoDevilLizardKingExItemDropRate
  000ca	89 45 d0	 mov	 DWORD PTR _ExItemDropRate$[ebp], eax

; 646  : 			}
; 647  : 		break;

  000cd	eb 18		 jmp	 SHORT $LN2@EledoradoB
$LN8@EledoradoB:

; 648  : 		case 12:
; 649  : 			{
; 650  : 				EledoradoBox = KanturItemBag;

  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?KanturItemBag@@3PAVCItemBag@@A ; KanturItemBag
  000d4	89 45 cc	 mov	 DWORD PTR _EledoradoBox$[ebp], eax

; 651  : 				ItemDropRate = gEledoradoDevilTantarosItemDropRate;

  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoDevilTantarosItemDropRate@@3HA ; gEledoradoDevilTantarosItemDropRate
  000dc	89 45 d4	 mov	 DWORD PTR _ItemDropRate$[ebp], eax

; 652  : 				ExItemDropRate = gEledoradoDevilTantarosExItemDropRate;

  000df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEledoradoDevilTantarosExItemDropRate@@3HA ; gEledoradoDevilTantarosExItemDropRate
  000e4	89 45 d0	 mov	 DWORD PTR _ExItemDropRate$[ebp], eax
$LN2@EledoradoB:

; 653  : 			}
; 654  : 		break;
; 655  : 	}
; 656  : 	
; 657  : 	if( !EledoradoBox )

  000e7	83 7d cc 00	 cmp	 DWORD PTR _EledoradoBox$[ebp], 0
  000eb	75 05		 jne	 SHORT $LN9@EledoradoB

; 658  : 		return;	

  000ed	e9 9e 04 00 00	 jmp	 $LN1@EledoradoB
$LN9@EledoradoB:

; 659  : 
; 660  : 	if( EledoradoBox->GetBagCount() > 0 )

  000f2	8b 4d cc	 mov	 ecx, DWORD PTR _EledoradoBox$[ebp]
  000f5	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  000fa	85 c0		 test	 eax, eax
  000fc	0f 8e 4d 04 00
	00		 jle	 $LN33@EledoradoB

; 661  : 	{
; 662  : 		// 아이템 드롭 확률 결정
; 663  : 		if( (rand()%100) < ItemDropRate )

  00102	e8 00 00 00 00	 call	 _rand
  00107	99		 cdq
  00108	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0010d	f7 f9		 idiv	 ecx
  0010f	3b 55 d4	 cmp	 edx, DWORD PTR _ItemDropRate$[ebp]
  00112	0f 8d 37 04 00
	00		 jge	 $LN33@EledoradoB

; 664  : 		{
; 665  : 			int NormalItemCount = EledoradoBox->GetNormalItemCount();

  00118	8b 4d cc	 mov	 ecx, DWORD PTR _EledoradoBox$[ebp]
  0011b	e8 00 00 00 00	 call	 ?GetNormalItemCount@CItemBag@@QAEHXZ ; CItemBag::GetNormalItemCount
  00120	89 45 c8	 mov	 DWORD PTR _NormalItemCount$2[ebp], eax

; 666  : 			int ExItemCount = EledoradoBox->GetExItemCount();

  00123	8b 4d cc	 mov	 ecx, DWORD PTR _EledoradoBox$[ebp]
  00126	e8 00 00 00 00	 call	 ?GetExItemCount@CItemBag@@QAEHXZ ; CItemBag::GetExItemCount
  0012b	89 45 c4	 mov	 DWORD PTR _ExItemCount$1[ebp], eax

; 667  : 
; 668  : 			if( ExItemCount > 0 && (rand()%100) < ExItemDropRate )

  0012e	83 7d c4 00	 cmp	 DWORD PTR _ExItemCount$1[ebp], 0
  00132	0f 8e b4 01 00
	00		 jle	 $LN12@EledoradoB
  00138	e8 00 00 00 00	 call	 _rand
  0013d	99		 cdq
  0013e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00143	f7 f9		 idiv	 ecx
  00145	3b 55 d0	 cmp	 edx, DWORD PTR _ExItemDropRate$[ebp]
  00148	0f 8d 9e 01 00
	00		 jge	 $LN12@EledoradoB

; 669  : 			{	// 엑설런트 아이템
; 670  : 				DropItemNum = (rand()%ExItemCount)+NormalItemCount;

  0014e	e8 00 00 00 00	 call	 _rand
  00153	99		 cdq
  00154	f7 7d c4	 idiv	 DWORD PTR _ExItemCount$1[ebp]
  00157	03 55 c8	 add	 edx, DWORD PTR _NormalItemCount$2[ebp]
  0015a	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 671  : 				dur  = 0;

  0015d	0f 57 c0	 xorps	 xmm0, xmm0
  00160	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 672  : 				x    = lpObj->X;

  00165	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00168	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0016f	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 673  : 				y    = lpObj->Y;

  00172	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00175	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0017c	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 674  : 				
; 675  : 				level= 0;

  0017f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 676  : 				
; 677  : 				type = ItemGetNumberMake(EledoradoBox->GetType(DropItemNum), EledoradoBox->GetIndex(DropItemNum));

  00186	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00189	50		 push	 eax
  0018a	8b 4d cc	 mov	 ecx, DWORD PTR _EledoradoBox$[ebp]
  0018d	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  00192	0f b6 c8	 movzx	 ecx, al
  00195	51		 push	 ecx
  00196	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  00199	52		 push	 edx
  0019a	8b 4d cc	 mov	 ecx, DWORD PTR _EledoradoBox$[ebp]
  0019d	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  001a2	0f b6 c0	 movzx	 eax, al
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  001ab	83 c4 08	 add	 esp, 8
  001ae	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 678  : 				
; 679  : 				Option1 = 1;

  001b1	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1

; 680  : 				Option2 = rand()%2;

  001b8	e8 00 00 00 00	 call	 _rand
  001bd	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001c2	79 05		 jns	 SHORT $LN36@EledoradoB
  001c4	48		 dec	 eax
  001c5	83 c8 fe	 or	 eax, -2			; fffffffeH
  001c8	40		 inc	 eax
$LN36@EledoradoB:
  001c9	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 681  : 
; 682  : 				if( !Option2 || !Option1 )

  001cc	83 7d e4 00	 cmp	 DWORD PTR _Option2$[ebp], 0
  001d0	74 06		 je	 SHORT $LN15@EledoradoB
  001d2	83 7d e8 00	 cmp	 DWORD PTR _Option1$[ebp], 0
  001d6	75 2b		 jne	 SHORT $LN17@EledoradoB
$LN15@EledoradoB:

; 683  : 				{	// 둘중의 하나가 0이면 
; 684  : 					if( (rand()%5) < 1 )

  001d8	e8 00 00 00 00	 call	 _rand
  001dd	99		 cdq
  001de	b9 05 00 00 00	 mov	 ecx, 5
  001e3	f7 f9		 idiv	 ecx
  001e5	83 fa 01	 cmp	 edx, 1
  001e8	7d 09		 jge	 SHORT $LN16@EledoradoB

; 685  : 					{
; 686  : 						Option3 = 3;

  001ea	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 687  : 					}

  001f1	eb 10		 jmp	 SHORT $LN17@EledoradoB
$LN16@EledoradoB:

; 688  : 					else Option3 = (rand()%3);

  001f3	e8 00 00 00 00	 call	 _rand
  001f8	99		 cdq
  001f9	b9 03 00 00 00	 mov	 ecx, 3
  001fe	f7 f9		 idiv	 ecx
  00200	89 55 e0	 mov	 DWORD PTR _Option3$[ebp], edx
$LN17@EledoradoB:

; 689  : 				}
; 690  : #ifdef NEW_SKILL_FORSKYLAND
; 691  : 				ExOption = NewOptionRand(0);

  00203	6a 00		 push	 0
  00205	e8 00 00 00 00	 call	 ?NewOptionRand@@YAEH@Z	; NewOptionRand
  0020a	83 c4 04	 add	 esp, 4
  0020d	0f b6 c0	 movzx	 eax, al
  00210	89 45 d8	 mov	 DWORD PTR _ExOption$[ebp], eax

; 692  : #endif
; 693  : 				// 혼석, 축석, 영석은 레벨이 없게
; 694  : 				if( (type == MAKE_ITEMNUM(12, 15)) ||
; 695  : 					(type == MAKE_ITEMNUM(14, 13)) ||

  00213	6a 0f		 push	 15			; 0000000fH
  00215	6a 0c		 push	 12			; 0000000cH
  00217	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0021c	83 c4 08	 add	 esp, 8
  0021f	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00222	74 22		 je	 SHORT $LN19@EledoradoB
  00224	6a 0d		 push	 13			; 0000000dH
  00226	6a 0e		 push	 14			; 0000000eH
  00228	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0022d	83 c4 08	 add	 esp, 8
  00230	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00233	74 11		 je	 SHORT $LN19@EledoradoB
  00235	6a 0e		 push	 14			; 0000000eH
  00237	6a 0e		 push	 14			; 0000000eH
  00239	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0023e	83 c4 08	 add	 esp, 8
  00241	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00244	75 23		 jne	 SHORT $LN18@EledoradoB
$LN19@EledoradoB:

; 696  : 					(type == MAKE_ITEMNUM(14, 14)) )				
; 697  : 				{	
; 698  : 					Option1 = 0; 

  00246	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 699  : 					Option2 = 0;

  0024d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 700  : 					Option3 = 0;

  00254	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 701  : 					level   = 0;

  0025b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 702  : 					ExOption = 0;

  00262	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ExOption$[ebp], 0
$LN18@EledoradoB:

; 703  : 				}
; 704  : 				
; 705  : 				if( (type == MAKE_ITEMNUM(13, 0)) ||
; 706  : 					(type == MAKE_ITEMNUM(13, 1)) ||				
; 707  : 					(type == MAKE_ITEMNUM(13, 2)) ||
; 708  : 					(type == MAKE_ITEMNUM(13, 8)) ||
; 709  : 					(type == MAKE_ITEMNUM(13, 9)) ||
; 710  : 					(type == MAKE_ITEMNUM(13, 12)) ||

  00269	6a 00		 push	 0
  0026b	6a 0d		 push	 13			; 0000000dH
  0026d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00272	83 c4 08	 add	 esp, 8
  00275	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00278	74 66		 je	 SHORT $LN21@EledoradoB
  0027a	6a 01		 push	 1
  0027c	6a 0d		 push	 13			; 0000000dH
  0027e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00283	83 c4 08	 add	 esp, 8
  00286	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00289	74 55		 je	 SHORT $LN21@EledoradoB
  0028b	6a 02		 push	 2
  0028d	6a 0d		 push	 13			; 0000000dH
  0028f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00294	83 c4 08	 add	 esp, 8
  00297	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0029a	74 44		 je	 SHORT $LN21@EledoradoB
  0029c	6a 08		 push	 8
  0029e	6a 0d		 push	 13			; 0000000dH
  002a0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002a5	83 c4 08	 add	 esp, 8
  002a8	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  002ab	74 33		 je	 SHORT $LN21@EledoradoB
  002ad	6a 09		 push	 9
  002af	6a 0d		 push	 13			; 0000000dH
  002b1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002b6	83 c4 08	 add	 esp, 8
  002b9	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  002bc	74 22		 je	 SHORT $LN21@EledoradoB
  002be	6a 0c		 push	 12			; 0000000cH
  002c0	6a 0d		 push	 13			; 0000000dH
  002c2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002c7	83 c4 08	 add	 esp, 8
  002ca	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  002cd	74 11		 je	 SHORT $LN21@EledoradoB
  002cf	6a 0d		 push	 13			; 0000000dH
  002d1	6a 0d		 push	 13			; 0000000dH
  002d3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002d8	83 c4 08	 add	 esp, 8
  002db	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  002de	75 07		 jne	 SHORT $LN20@EledoradoB
$LN21@EledoradoB:

; 711  : 					(type == MAKE_ITEMNUM(13, 13)) )
; 712  : 				{	// 반지류는 레벨 0
; 713  : 					level   = 0;

  002e0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN20@EledoradoB:

; 714  : 				}			
; 715  : 			}

  002e7	e9 de 01 00 00	 jmp	 $LN31@EledoradoB
$LN12@EledoradoB:

; 716  : 			else if(NormalItemCount > 0)

  002ec	83 7d c8 00	 cmp	 DWORD PTR _NormalItemCount$2[ebp], 0
  002f0	0f 8e d4 01 00
	00		 jle	 $LN31@EledoradoB

; 717  : 			{	// 일반 아이템
; 718  : 				DropItemNum = (rand()%NormalItemCount);

  002f6	e8 00 00 00 00	 call	 _rand
  002fb	99		 cdq
  002fc	f7 7d c8	 idiv	 DWORD PTR _NormalItemCount$2[ebp]
  002ff	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 719  : 				dur  = 0;

  00302	0f 57 c0	 xorps	 xmm0, xmm0
  00305	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 720  : 				x    = lpObj->X;

  0030a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030d	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00314	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 721  : 				y    = lpObj->Y;

  00317	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031a	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00321	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 722  : 				
; 723  : 				if( addlevel != 0 )

  00324	83 7d 10 00	 cmp	 DWORD PTR _addlevel$[ebp], 0
  00328	74 1f		 je	 SHORT $LN23@EledoradoB

; 724  : 					level= EledoradoBox->GetLevel(DropItemNum)+(rand()%addlevel);

  0032a	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  0032d	50		 push	 eax
  0032e	8b 4d cc	 mov	 ecx, DWORD PTR _EledoradoBox$[ebp]
  00331	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  00336	0f b6 f0	 movzx	 esi, al
  00339	e8 00 00 00 00	 call	 _rand
  0033e	99		 cdq
  0033f	f7 7d 10	 idiv	 DWORD PTR _addlevel$[ebp]
  00342	03 f2		 add	 esi, edx
  00344	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi
  00347	eb 12		 jmp	 SHORT $LN24@EledoradoB
$LN23@EledoradoB:

; 725  : 				else
; 726  : 					level= EledoradoBox->GetLevel(DropItemNum);

  00349	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  0034c	50		 push	 eax
  0034d	8b 4d cc	 mov	 ecx, DWORD PTR _EledoradoBox$[ebp]
  00350	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  00355	0f b6 c8	 movzx	 ecx, al
  00358	89 4d f4	 mov	 DWORD PTR _level$[ebp], ecx
$LN24@EledoradoB:

; 727  : 
; 728  : 				
; 729  : 				type = ItemGetNumberMake(EledoradoBox->GetType(DropItemNum), EledoradoBox->GetIndex(DropItemNum));

  0035b	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  0035e	50		 push	 eax
  0035f	8b 4d cc	 mov	 ecx, DWORD PTR _EledoradoBox$[ebp]
  00362	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  00367	0f b6 c8	 movzx	 ecx, al
  0036a	51		 push	 ecx
  0036b	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  0036e	52		 push	 edx
  0036f	8b 4d cc	 mov	 ecx, DWORD PTR _EledoradoBox$[ebp]
  00372	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  00377	0f b6 c0	 movzx	 eax, al
  0037a	50		 push	 eax
  0037b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00380	83 c4 08	 add	 esp, 8
  00383	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 730  : 				
; 731  : 				Option1 = rand()%2;

  00386	e8 00 00 00 00	 call	 _rand
  0038b	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00390	79 05		 jns	 SHORT $LN37@EledoradoB
  00392	48		 dec	 eax
  00393	83 c8 fe	 or	 eax, -2			; fffffffeH
  00396	40		 inc	 eax
$LN37@EledoradoB:
  00397	89 45 e8	 mov	 DWORD PTR _Option1$[ebp], eax

; 732  : 				Option2 = rand()%2;

  0039a	e8 00 00 00 00	 call	 _rand
  0039f	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  003a4	79 05		 jns	 SHORT $LN38@EledoradoB
  003a6	48		 dec	 eax
  003a7	83 c8 fe	 or	 eax, -2			; fffffffeH
  003aa	40		 inc	 eax
$LN38@EledoradoB:
  003ab	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 733  : 
; 734  : 				if( !Option2 || !Option1 )

  003ae	83 7d e4 00	 cmp	 DWORD PTR _Option2$[ebp], 0
  003b2	74 06		 je	 SHORT $LN26@EledoradoB
  003b4	83 7d e8 00	 cmp	 DWORD PTR _Option1$[ebp], 0
  003b8	75 2b		 jne	 SHORT $LN28@EledoradoB
$LN26@EledoradoB:

; 735  : 				{	// 둘중의 하나가 0이면 
; 736  : 					if( (rand()%5) < 1 )

  003ba	e8 00 00 00 00	 call	 _rand
  003bf	99		 cdq
  003c0	b9 05 00 00 00	 mov	 ecx, 5
  003c5	f7 f9		 idiv	 ecx
  003c7	83 fa 01	 cmp	 edx, 1
  003ca	7d 09		 jge	 SHORT $LN27@EledoradoB

; 737  : 					{
; 738  : 						Option3 = 3;

  003cc	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 739  : 					}

  003d3	eb 10		 jmp	 SHORT $LN28@EledoradoB
$LN27@EledoradoB:

; 740  : 					else Option3 = (rand()%3);

  003d5	e8 00 00 00 00	 call	 _rand
  003da	99		 cdq
  003db	b9 03 00 00 00	 mov	 ecx, 3
  003e0	f7 f9		 idiv	 ecx
  003e2	89 55 e0	 mov	 DWORD PTR _Option3$[ebp], edx
$LN28@EledoradoB:

; 741  : 				}
; 742  : 
; 743  : 				// 혼석, 축석, 영석, 생석은 레벨이 없게
; 744  : 				if( (type == MAKE_ITEMNUM(12, 15)) ||
; 745  : 					(type == MAKE_ITEMNUM(14, 13)) ||
; 746  : 					(type == MAKE_ITEMNUM(14, 14)) || 

  003e5	6a 0f		 push	 15			; 0000000fH
  003e7	6a 0c		 push	 12			; 0000000cH
  003e9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003ee	83 c4 08	 add	 esp, 8
  003f1	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  003f4	74 33		 je	 SHORT $LN30@EledoradoB
  003f6	6a 0d		 push	 13			; 0000000dH
  003f8	6a 0e		 push	 14			; 0000000eH
  003fa	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003ff	83 c4 08	 add	 esp, 8
  00402	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00405	74 22		 je	 SHORT $LN30@EledoradoB
  00407	6a 0e		 push	 14			; 0000000eH
  00409	6a 0e		 push	 14			; 0000000eH
  0040b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00410	83 c4 08	 add	 esp, 8
  00413	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00416	74 11		 je	 SHORT $LN30@EledoradoB
  00418	6a 10		 push	 16			; 00000010H
  0041a	6a 0e		 push	 14			; 0000000eH
  0041c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00421	83 c4 08	 add	 esp, 8
  00424	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00427	75 23		 jne	 SHORT $LN29@EledoradoB
$LN30@EledoradoB:

; 747  : 					(type == MAKE_ITEMNUM(14, 16)) )				
; 748  : 				{	
; 749  : 					Option1 = 0; 

  00429	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 750  : 					Option2 = 0;

  00430	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 751  : 					Option3 = 0;

  00437	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 752  : 					level   = 0;

  0043e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 753  : 					ExOption = 0;

  00445	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ExOption$[ebp], 0
$LN29@EledoradoB:

; 754  : 				}
; 755  : 				
; 756  : 				if( (type == MAKE_ITEMNUM(13, 0)) ||
; 757  : 					(type == MAKE_ITEMNUM(13, 1)) ||				
; 758  : 					(type == MAKE_ITEMNUM(13, 2)) ||
; 759  : 					(type == MAKE_ITEMNUM(13, 8)) ||
; 760  : 					(type == MAKE_ITEMNUM(13, 9)) ||
; 761  : 					(type == MAKE_ITEMNUM(13, 12)) ||

  0044c	6a 00		 push	 0
  0044e	6a 0d		 push	 13			; 0000000dH
  00450	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00455	83 c4 08	 add	 esp, 8
  00458	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0045b	74 66		 je	 SHORT $LN32@EledoradoB
  0045d	6a 01		 push	 1
  0045f	6a 0d		 push	 13			; 0000000dH
  00461	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00466	83 c4 08	 add	 esp, 8
  00469	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0046c	74 55		 je	 SHORT $LN32@EledoradoB
  0046e	6a 02		 push	 2
  00470	6a 0d		 push	 13			; 0000000dH
  00472	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00477	83 c4 08	 add	 esp, 8
  0047a	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0047d	74 44		 je	 SHORT $LN32@EledoradoB
  0047f	6a 08		 push	 8
  00481	6a 0d		 push	 13			; 0000000dH
  00483	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00488	83 c4 08	 add	 esp, 8
  0048b	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0048e	74 33		 je	 SHORT $LN32@EledoradoB
  00490	6a 09		 push	 9
  00492	6a 0d		 push	 13			; 0000000dH
  00494	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00499	83 c4 08	 add	 esp, 8
  0049c	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0049f	74 22		 je	 SHORT $LN32@EledoradoB
  004a1	6a 0c		 push	 12			; 0000000cH
  004a3	6a 0d		 push	 13			; 0000000dH
  004a5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  004aa	83 c4 08	 add	 esp, 8
  004ad	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  004b0	74 11		 je	 SHORT $LN32@EledoradoB
  004b2	6a 0d		 push	 13			; 0000000dH
  004b4	6a 0d		 push	 13			; 0000000dH
  004b6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  004bb	83 c4 08	 add	 esp, 8
  004be	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  004c1	75 07		 jne	 SHORT $LN31@EledoradoB
$LN32@EledoradoB:

; 762  : 					(type == MAKE_ITEMNUM(13, 13)) )
; 763  : 				{	// 반지류는 레벨 0
; 764  : 					level   = 0;

  004c3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN31@EledoradoB:

; 765  : 				}			
; 766  : 			}
; 767  : 
; 768  : 			if(DropItemNum != -1)

  004ca	83 7d dc ff	 cmp	 DWORD PTR _DropItemNum$[ebp], -1
  004ce	74 7f		 je	 SHORT $LN33@EledoradoB

; 769  : 			{
; 770  : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index, ExOption);

  004d0	6a 00		 push	 0
  004d2	6a 00		 push	 0
  004d4	0f b6 45 d8	 movzx	 eax, BYTE PTR _ExOption$[ebp]
  004d8	50		 push	 eax
  004d9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004dc	8b 11		 mov	 edx, DWORD PTR [ecx]
  004de	52		 push	 edx
  004df	0f b6 45 e0	 movzx	 eax, BYTE PTR _Option3$[ebp]
  004e3	50		 push	 eax
  004e4	0f b6 4d e4	 movzx	 ecx, BYTE PTR _Option2$[ebp]
  004e8	51		 push	 ecx
  004e9	0f b6 55 e8	 movzx	 edx, BYTE PTR _Option1$[ebp]
  004ed	52		 push	 edx
  004ee	f3 0f 2c 45 fc	 cvttss2si eax, DWORD PTR _dur$[ebp]
  004f3	0f b6 c8	 movzx	 ecx, al
  004f6	51		 push	 ecx
  004f7	0f b6 55 f4	 movzx	 edx, BYTE PTR _level$[ebp]
  004fb	52		 push	 edx
  004fc	8b 45 f8	 mov	 eax, DWORD PTR _type$[ebp]
  004ff	50		 push	 eax
  00500	0f b6 4d ec	 movzx	 ecx, BYTE PTR _y$[ebp]
  00504	51		 push	 ecx
  00505	0f b6 55 f0	 movzx	 edx, BYTE PTR _x$[ebp]
  00509	52		 push	 edx
  0050a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0050d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00514	51		 push	 ecx
  00515	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00518	8b 02		 mov	 eax, DWORD PTR [edx]
  0051a	50		 push	 eax
  0051b	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00520	83 c4 38	 add	 esp, 56			; 00000038H

; 771  : 
; 772  : #ifdef EXTEND_LOG_SYSTEM_20060202
; 773  : 				CItem EventItem;
; 774  : 				EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 775  : 
; 776  : 				LogAddTD("[%s][%s][Lucky Box Item Drop][Eledorado Box] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 777  : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 778  : 					EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 779  : #else
; 780  : 				LogAddTD("EleDoradoBox-%d Event ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d ex:%d", boxtype, type, level, Option1, Option2, Option3, ExOption);

  00523	8b 45 d8	 mov	 eax, DWORD PTR _ExOption$[ebp]
  00526	50		 push	 eax
  00527	8b 4d e0	 mov	 ecx, DWORD PTR _Option3$[ebp]
  0052a	51		 push	 ecx
  0052b	8b 55 e4	 mov	 edx, DWORD PTR _Option2$[ebp]
  0052e	52		 push	 edx
  0052f	8b 45 e8	 mov	 eax, DWORD PTR _Option1$[ebp]
  00532	50		 push	 eax
  00533	8b 4d f4	 mov	 ecx, DWORD PTR _level$[ebp]
  00536	51		 push	 ecx
  00537	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  0053a	52		 push	 edx
  0053b	8b 45 0c	 mov	 eax, DWORD PTR _boxtype$[ebp]
  0053e	50		 push	 eax
  0053f	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@LDELBCFF@EleDoradoBox?9?$CFd?5Event?5ItemDrop?5@
  00544	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0054a	83 c4 20	 add	 esp, 32			; 00000020H

; 781  : #endif
; 782  : 				return;

  0054d	eb 41		 jmp	 SHORT $LN1@EledoradoB
$LN33@EledoradoB:

; 783  : 			}
; 784  : 		}
; 785  : 	}
; 786  : 	x    = lpObj->X;

  0054f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00552	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00559	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 787  : 	y    = lpObj->Y;	

  0055c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0055f	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00566	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 788  : 	MapC[lpObj->MapNumber].MoneyItemDrop(money, x ,y);	

  00569	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  0056c	50		 push	 eax
  0056d	8b 4d f0	 mov	 ecx, DWORD PTR _x$[ebp]
  00570	51		 push	 ecx
  00571	8b 55 14	 mov	 edx, DWORD PTR _money$[ebp]
  00574	52		 push	 edx
  00575	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00578	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0057f	69 c9 8c 04 05
	00		 imul	 ecx, ecx, 328844
  00585	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0058b	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN1@EledoradoB:

; 789  : }

  00590	5f		 pop	 edi
  00591	5e		 pop	 esi
  00592	5b		 pop	 ebx
  00593	8b e5		 mov	 esp, ebp
  00595	5d		 pop	 ebp
  00596	c3		 ret	 0
  00597	90		 npad	 1
$LN35@EledoradoB:
  00598	00 00 00 00	 DD	 $LN4@EledoradoB
  0059c	00 00 00 00	 DD	 $LN5@EledoradoB
  005a0	00 00 00 00	 DD	 $LN6@EledoradoB
  005a4	00 00 00 00	 DD	 $LN7@EledoradoB
  005a8	00 00 00 00	 DD	 $LN8@EledoradoB
?EledoradoBoxOpenEven@@YAXPAVOBJECTSTRUCT@@HHH@Z ENDP	; EledoradoBoxOpenEven
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?EventChipOpenEven@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ServerCmd$1 = -48					; size = 7
_ExOption$ = -40					; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?EventChipOpenEven@@YAXPAVOBJECTSTRUCT@@@Z PROC		; EventChipOpenEven, COMDAT

; 795  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 796  : 	float dur;
; 797  : 	int type, level, x, y;
; 798  : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 799  : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 800  : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 801  : 	int DropItemNum;
; 802  : 	int ExOption = 0;

  0001e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ExOption$[ebp], 0

; 803  : 
; 804  : 	if( (rand()%100) < g_EventChipDropRateForBoxOfGold )

  00025	e8 00 00 00 00	 call	 _rand
  0002a	99		 cdq
  0002b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00030	f7 f9		 idiv	 ecx
  00032	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_EventChipDropRateForBoxOfGold@@3HA ; g_EventChipDropRateForBoxOfGold
  00038	0f 8d a0 00 00
	00		 jge	 $LN2@EventChipO

; 805  : 	{
; 806  : 		dur  = 255;

  0003e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00046	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 807  : 		x    = lpObj->X;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00055	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 808  : 		y    = lpObj->Y;

  00058	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005b	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00062	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 809  : 		level= 0;	// 황금의 상자

  00065	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 810  : 		type = ItemGetNumberMake(14, 21);

  0006c	6a 15		 push	 21			; 00000015H
  0006e	6a 0e		 push	 14			; 0000000eH
  00070	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00075	83 c4 08	 add	 esp, 8
  00078	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 811  : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);		

  0007b	6a 00		 push	 0
  0007d	6a 00		 push	 0
  0007f	6a 00		 push	 0
  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	0f b6 55 e0	 movzx	 edx, BYTE PTR _Option3$[ebp]
  0008b	52		 push	 edx
  0008c	0f b6 45 e4	 movzx	 eax, BYTE PTR _Option2$[ebp]
  00090	50		 push	 eax
  00091	0f b6 4d e8	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  00095	51		 push	 ecx
  00096	f3 0f 2c 55 fc	 cvttss2si edx, DWORD PTR _dur$[ebp]
  0009b	0f b6 c2	 movzx	 eax, dl
  0009e	50		 push	 eax
  0009f	0f b6 4d f4	 movzx	 ecx, BYTE PTR _level$[ebp]
  000a3	51		 push	 ecx
  000a4	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  000a7	52		 push	 edx
  000a8	0f b6 45 ec	 movzx	 eax, BYTE PTR _y$[ebp]
  000ac	50		 push	 eax
  000ad	0f b6 4d f0	 movzx	 ecx, BYTE PTR _x$[ebp]
  000b1	51		 push	 ecx
  000b2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b5	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000bc	50		 push	 eax
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  000c8	83 c4 38	 add	 esp, 56			; 00000038H

; 812  : 		LogAdd("EventChip Event ItemDrop Rena");

  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@CCIJBOCK@EventChip?5Event?5ItemDrop?5Rena@
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d6	83 c4 04	 add	 esp, 4

; 813  : 		return;

  000d9	e9 08 03 00 00	 jmp	 $LN1@EventChipO
$LN2@EventChipO:

; 814  : 	}
; 815  : 
; 816  : 	if( !LuckboxItemBag )

  000de	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A, 0 ; LuckboxItemBag
  000e5	75 05		 jne	 SHORT $LN3@EventChipO

; 817  : 		return;

  000e7	e9 fa 02 00 00	 jmp	 $LN1@EventChipO
$LN3@EventChipO:

; 818  : 
; 819  : 	if( LuckboxItemBag->GetBagCount() > 0 )

  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  000f2	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  000f7	85 c0		 test	 eax, eax
  000f9	0f 8e a5 02 00
	00		 jle	 $LN5@EventChipO

; 820  : 	{
; 821  : 		// 2/20 의 확률로 이벤트용 아이템 증정
; 822  : 		if( (rand()%20) < g_ItemDropRateForBoxOfGold )

  000ff	e8 00 00 00 00	 call	 _rand
  00104	99		 cdq
  00105	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0010a	f7 f9		 idiv	 ecx
  0010c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_ItemDropRateForBoxOfGold@@3HA ; g_ItemDropRateForBoxOfGold
  00112	0f 8d 8c 02 00
	00		 jge	 $LN5@EventChipO

; 823  : 		{
; 824  : 			DropItemNum = (rand()%LuckboxItemBag->GetBagCount());

  00118	e8 00 00 00 00	 call	 _rand
  0011d	8b f0		 mov	 esi, eax
  0011f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  00125	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  0012a	8b c8		 mov	 ecx, eax
  0012c	8b c6		 mov	 eax, esi
  0012e	99		 cdq
  0012f	f7 f9		 idiv	 ecx
  00131	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 825  : 			dur  = 0;

  00134	0f 57 c0	 xorps	 xmm0, xmm0
  00137	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 826  : 			x    = lpObj->X;

  0013c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013f	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00146	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 827  : 			y    = lpObj->Y;			

  00149	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014c	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00153	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 828  : 
; 829  : 			// ItemBag에서는 레벨이 4부터 설정되어 있다 (4 - 5)
; 830  : 			level= LuckboxItemBag->GetLevel(DropItemNum)+(rand()%2);

  00156	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00159	50		 push	 eax
  0015a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  00160	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  00165	0f b6 f0	 movzx	 esi, al
  00168	e8 00 00 00 00	 call	 _rand
  0016d	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00172	79 05		 jns	 SHORT $LN15@EventChipO
  00174	48		 dec	 eax
  00175	83 c8 fe	 or	 eax, -2			; fffffffeH
  00178	40		 inc	 eax
$LN15@EventChipO:
  00179	03 f0		 add	 esi, eax
  0017b	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi

; 831  : 			
; 832  : 			type = ItemGetNumberMake(LuckboxItemBag->GetType(DropItemNum), LuckboxItemBag->GetIndex(DropItemNum));

  0017e	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00181	50		 push	 eax
  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  00188	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  0018d	0f b6 c8	 movzx	 ecx, al
  00190	51		 push	 ecx
  00191	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  00194	52		 push	 edx
  00195	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  0019b	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  001a0	0f b6 c0	 movzx	 eax, al
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  001a9	83 c4 08	 add	 esp, 8
  001ac	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 833  : 			
; 834  : 			Option1 = rand()%2;

  001af	e8 00 00 00 00	 call	 _rand
  001b4	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001b9	79 05		 jns	 SHORT $LN16@EventChipO
  001bb	48		 dec	 eax
  001bc	83 c8 fe	 or	 eax, -2			; fffffffeH
  001bf	40		 inc	 eax
$LN16@EventChipO:
  001c0	89 45 e8	 mov	 DWORD PTR _Option1$[ebp], eax

; 835  : 			Option2 = rand()%2;

  001c3	e8 00 00 00 00	 call	 _rand
  001c8	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001cd	79 05		 jns	 SHORT $LN17@EventChipO
  001cf	48		 dec	 eax
  001d0	83 c8 fe	 or	 eax, -2			; fffffffeH
  001d3	40		 inc	 eax
$LN17@EventChipO:
  001d4	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 836  : 
; 837  : 			if( !Option2 || !Option1 )

  001d7	83 7d e4 00	 cmp	 DWORD PTR _Option2$[ebp], 0
  001db	74 06		 je	 SHORT $LN7@EventChipO
  001dd	83 7d e8 00	 cmp	 DWORD PTR _Option1$[ebp], 0
  001e1	75 2b		 jne	 SHORT $LN9@EventChipO
$LN7@EventChipO:

; 838  : 			{	// 둘중의 하나가 0이면 
; 839  : 				if( (rand()%5) < 1 )

  001e3	e8 00 00 00 00	 call	 _rand
  001e8	99		 cdq
  001e9	b9 05 00 00 00	 mov	 ecx, 5
  001ee	f7 f9		 idiv	 ecx
  001f0	83 fa 01	 cmp	 edx, 1
  001f3	7d 09		 jge	 SHORT $LN8@EventChipO

; 840  : 				{
; 841  : 					Option3 = 3;

  001f5	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 842  : 				}

  001fc	eb 10		 jmp	 SHORT $LN9@EventChipO
$LN8@EventChipO:

; 843  : 				else Option3 = (rand()%3);

  001fe	e8 00 00 00 00	 call	 _rand
  00203	99		 cdq
  00204	b9 03 00 00 00	 mov	 ecx, 3
  00209	f7 f9		 idiv	 ecx
  0020b	89 55 e0	 mov	 DWORD PTR _Option3$[ebp], edx
$LN9@EventChipO:

; 844  : 			}			
; 845  : 
; 846  : 			// 혼석, 축석, 영석은 레벨이 없게
; 847  : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 848  : 				(type == MAKE_ITEMNUM(14, 13)) ||

  0020e	6a 0f		 push	 15			; 0000000fH
  00210	6a 0c		 push	 12			; 0000000cH
  00212	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00217	83 c4 08	 add	 esp, 8
  0021a	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0021d	74 22		 je	 SHORT $LN11@EventChipO
  0021f	6a 0d		 push	 13			; 0000000dH
  00221	6a 0e		 push	 14			; 0000000eH
  00223	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00228	83 c4 08	 add	 esp, 8
  0022b	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0022e	74 11		 je	 SHORT $LN11@EventChipO
  00230	6a 0e		 push	 14			; 0000000eH
  00232	6a 0e		 push	 14			; 0000000eH
  00234	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00239	83 c4 08	 add	 esp, 8
  0023c	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0023f	75 23		 jne	 SHORT $LN10@EventChipO
$LN11@EventChipO:

; 849  : 				(type == MAKE_ITEMNUM(14, 14)) )				
; 850  : 			{	
; 851  : 				Option1 = 0; 

  00241	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 852  : 				Option2 = 0;

  00248	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 853  : 				Option3 = 0;

  0024f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 854  : 				level   = 0;

  00256	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 855  : 				ExOption = 0;

  0025d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ExOption$[ebp], 0
$LN10@EventChipO:

; 856  : 			}
; 857  : 			
; 858  : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 859  : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 860  : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 861  : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 862  : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 863  : 				(type == MAKE_ITEMNUM(13, 12)) ||

  00264	6a 00		 push	 0
  00266	6a 0d		 push	 13			; 0000000dH
  00268	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0026d	83 c4 08	 add	 esp, 8
  00270	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00273	74 66		 je	 SHORT $LN13@EventChipO
  00275	6a 01		 push	 1
  00277	6a 0d		 push	 13			; 0000000dH
  00279	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0027e	83 c4 08	 add	 esp, 8
  00281	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00284	74 55		 je	 SHORT $LN13@EventChipO
  00286	6a 02		 push	 2
  00288	6a 0d		 push	 13			; 0000000dH
  0028a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0028f	83 c4 08	 add	 esp, 8
  00292	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00295	74 44		 je	 SHORT $LN13@EventChipO
  00297	6a 08		 push	 8
  00299	6a 0d		 push	 13			; 0000000dH
  0029b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002a0	83 c4 08	 add	 esp, 8
  002a3	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  002a6	74 33		 je	 SHORT $LN13@EventChipO
  002a8	6a 09		 push	 9
  002aa	6a 0d		 push	 13			; 0000000dH
  002ac	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002b1	83 c4 08	 add	 esp, 8
  002b4	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  002b7	74 22		 je	 SHORT $LN13@EventChipO
  002b9	6a 0c		 push	 12			; 0000000cH
  002bb	6a 0d		 push	 13			; 0000000dH
  002bd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002c2	83 c4 08	 add	 esp, 8
  002c5	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  002c8	74 11		 je	 SHORT $LN13@EventChipO
  002ca	6a 0d		 push	 13			; 0000000dH
  002cc	6a 0d		 push	 13			; 0000000dH
  002ce	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002d3	83 c4 08	 add	 esp, 8
  002d6	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  002d9	75 07		 jne	 SHORT $LN12@EventChipO
$LN13@EventChipO:

; 864  : 				(type == MAKE_ITEMNUM(13, 13)) )
; 865  : 			{	// 반지류는 레벨 0
; 866  : 				level   = 0;

  002db	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN12@EventChipO:

; 867  : 			}			
; 868  : 
; 869  : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index, ExOption);

  002e2	6a 00		 push	 0
  002e4	6a 00		 push	 0
  002e6	0f b6 45 d8	 movzx	 eax, BYTE PTR _ExOption$[ebp]
  002ea	50		 push	 eax
  002eb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f0	52		 push	 edx
  002f1	0f b6 45 e0	 movzx	 eax, BYTE PTR _Option3$[ebp]
  002f5	50		 push	 eax
  002f6	0f b6 4d e4	 movzx	 ecx, BYTE PTR _Option2$[ebp]
  002fa	51		 push	 ecx
  002fb	0f b6 55 e8	 movzx	 edx, BYTE PTR _Option1$[ebp]
  002ff	52		 push	 edx
  00300	f3 0f 2c 45 fc	 cvttss2si eax, DWORD PTR _dur$[ebp]
  00305	0f b6 c8	 movzx	 ecx, al
  00308	51		 push	 ecx
  00309	0f b6 55 f4	 movzx	 edx, BYTE PTR _level$[ebp]
  0030d	52		 push	 edx
  0030e	8b 45 f8	 mov	 eax, DWORD PTR _type$[ebp]
  00311	50		 push	 eax
  00312	0f b6 4d ec	 movzx	 ecx, BYTE PTR _y$[ebp]
  00316	51		 push	 ecx
  00317	0f b6 55 f0	 movzx	 edx, BYTE PTR _x$[ebp]
  0031b	52		 push	 edx
  0031c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00326	51		 push	 ecx
  00327	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0032a	8b 02		 mov	 eax, DWORD PTR [edx]
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00332	83 c4 38	 add	 esp, 56			; 00000038H

; 870  : 
; 871  : 			// 팡파레..
; 872  : 			PMSG_SERVERCMD	ServerCmd;
; 873  : 			PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  00335	6a 07		 push	 7
  00337	6a 40		 push	 64			; 00000040H
  00339	68 f3 00 00 00	 push	 243			; 000000f3H
  0033e	8d 45 d0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00347	83 c4 10	 add	 esp, 16			; 00000010H

; 874  : 
; 875  : 			ServerCmd.CmdType = 2;	// 팡파레

  0034a	c6 45 d4 02	 mov	 BYTE PTR _ServerCmd$1[ebp+4], 2

; 876  : 			ServerCmd.X = x;

  0034e	8a 45 f0	 mov	 al, BYTE PTR _x$[ebp]
  00351	88 45 d5	 mov	 BYTE PTR _ServerCmd$1[ebp+5], al

; 877  : 			ServerCmd.Y = y;

  00354	8a 45 ec	 mov	 al, BYTE PTR _y$[ebp]
  00357	88 45 d6	 mov	 BYTE PTR _ServerCmd$1[ebp+6], al

; 878  : 			MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  0035a	6a 07		 push	 7
  0035c	8d 45 d0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  0035f	50		 push	 eax
  00360	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00363	51		 push	 ecx
  00364	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00369	83 c4 0c	 add	 esp, 12			; 0000000cH

; 879  : 			DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  0036c	6a 07		 push	 7
  0036e	8d 45 d0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  00371	50		 push	 eax
  00372	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00375	8b 11		 mov	 edx, DWORD PTR [ecx]
  00377	52		 push	 edx
  00378	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0037d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 880  : 
; 881  : #ifdef EXTEND_LOG_SYSTEM_20060202
; 882  : 			CItem EventItem;
; 883  : 			EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 884  : 
; 885  : 			LogAddTD("[%s][%s][Lucky Box Item Drop][Event Chip] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 886  : 				lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 887  : 				EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 888  : #else
; 889  : 			LogAdd("EventChip Event BoxOfGold ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  00380	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  00383	50		 push	 eax
  00384	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  00387	51		 push	 ecx
  00388	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  0038b	52		 push	 edx
  0038c	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  0038f	50		 push	 eax
  00390	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00393	51		 push	 ecx
  00394	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@GGABLOBN@EventChip?5Event?5BoxOfGold?5ItemD@
  00399	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0039f	83 c4 18	 add	 esp, 24			; 00000018H

; 890  : #endif
; 891  : 			return;

  003a2	eb 42		 jmp	 SHORT $LN1@EventChipO
$LN5@EventChipO:

; 892  : 		}
; 893  : 	}
; 894  : 	x    = lpObj->X;

  003a4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a7	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  003ae	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 895  : 	y    = lpObj->Y;	

  003b1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b4	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  003bb	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 896  : 	MapC[lpObj->MapNumber].MoneyItemDrop(1000, x ,y);	

  003be	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  003c1	50		 push	 eax
  003c2	8b 4d f0	 mov	 ecx, DWORD PTR _x$[ebp]
  003c5	51		 push	 ecx
  003c6	68 e8 03 00 00	 push	 1000			; 000003e8H
  003cb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003ce	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  003d5	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  003db	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  003e1	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN1@EventChipO:

; 897  : }

  003e6	5f		 pop	 edi
  003e7	5e		 pop	 esi
  003e8	5b		 pop	 ebx
  003e9	8b e5		 mov	 esp, ebp
  003eb	5d		 pop	 ebp
  003ec	c3		 ret	 0
?EventChipOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; EventChipOpenEven
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?SilverMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ServerCmd$1 = -48					; size = 7
_ExOption$ = -40					; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?SilverMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z PROC	; SilverMedalOpenEven, COMDAT

; 1002 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1003 : 	float dur;
; 1004 : 	int type, level, x, y;
; 1005 : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1006 : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1007 : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1008 : 	int DropItemNum;
; 1009 : 	int ExOption = 0;

  0001e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ExOption$[ebp], 0

; 1010 : 
; 1011 : 	if( !SilverMedalItemBag )

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SilverMedalItemBag@@3PAVCItemBag@@A, 0 ; SilverMedalItemBag
  0002c	75 05		 jne	 SHORT $LN2@SilverMeda

; 1012 : 		return;

  0002e	e9 f7 02 00 00	 jmp	 $LN1@SilverMeda
$LN2@SilverMeda:

; 1013 : 
; 1014 : 	if( SilverMedalItemBag->GetBagCount() > 0 )

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SilverMedalItemBag@@3PAVCItemBag@@A ; SilverMedalItemBag
  00039	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  0003e	85 c0		 test	 eax, eax
  00040	0f 8e a2 02 00
	00		 jle	 $LN4@SilverMeda

; 1015 : 	{
; 1016 : 		// 2/20 의 확률로 이벤트용 아이템 증정
; 1017 : 		if( (rand()%20) < g_ItemDropRateForSilverMedal )

  00046	e8 00 00 00 00	 call	 _rand
  0004b	99		 cdq
  0004c	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00051	f7 f9		 idiv	 ecx
  00053	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_ItemDropRateForSilverMedal@@3HA ; g_ItemDropRateForSilverMedal
  00059	0f 8d 89 02 00
	00		 jge	 $LN4@SilverMeda

; 1018 : 		{
; 1019 : 			DropItemNum = (rand()%SilverMedalItemBag->GetBagCount());

  0005f	e8 00 00 00 00	 call	 _rand
  00064	8b f0		 mov	 esi, eax
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SilverMedalItemBag@@3PAVCItemBag@@A ; SilverMedalItemBag
  0006c	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00071	8b c8		 mov	 ecx, eax
  00073	8b c6		 mov	 eax, esi
  00075	99		 cdq
  00076	f7 f9		 idiv	 ecx
  00078	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 1020 : 			dur  = 0;

  0007b	0f 57 c0	 xorps	 xmm0, xmm0
  0007e	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 1021 : 			x    = lpObj->X;

  00083	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00086	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0008d	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1022 : 			y    = lpObj->Y;			

  00090	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00093	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0009a	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1023 : 
; 1024 : 			// ItemBag에서는 레벨이 3부터 설정되어 있다 (3 - 6)
; 1025 : 			level= SilverMedalItemBag->GetLevel(DropItemNum)+(rand()%4);

  0009d	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000a0	50		 push	 eax
  000a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SilverMedalItemBag@@3PAVCItemBag@@A ; SilverMedalItemBag
  000a7	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  000ac	0f b6 f0	 movzx	 esi, al
  000af	e8 00 00 00 00	 call	 _rand
  000b4	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000b9	79 05		 jns	 SHORT $LN14@SilverMeda
  000bb	48		 dec	 eax
  000bc	83 c8 fc	 or	 eax, -4			; fffffffcH
  000bf	40		 inc	 eax
$LN14@SilverMeda:
  000c0	03 f0		 add	 esi, eax
  000c2	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi

; 1026 : 			
; 1027 : 			type = ItemGetNumberMake(SilverMedalItemBag->GetType(DropItemNum), SilverMedalItemBag->GetIndex(DropItemNum));

  000c5	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000c8	50		 push	 eax
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SilverMedalItemBag@@3PAVCItemBag@@A ; SilverMedalItemBag
  000cf	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  000d4	0f b6 c8	 movzx	 ecx, al
  000d7	51		 push	 ecx
  000d8	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  000db	52		 push	 edx
  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SilverMedalItemBag@@3PAVCItemBag@@A ; SilverMedalItemBag
  000e2	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  000e7	0f b6 c0	 movzx	 eax, al
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000f0	83 c4 08	 add	 esp, 8
  000f3	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 1028 : 			
; 1029 : 			
; 1030 : 			Option1 = rand()%2;

  000f6	e8 00 00 00 00	 call	 _rand
  000fb	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00100	79 05		 jns	 SHORT $LN15@SilverMeda
  00102	48		 dec	 eax
  00103	83 c8 fe	 or	 eax, -2			; fffffffeH
  00106	40		 inc	 eax
$LN15@SilverMeda:
  00107	89 45 e8	 mov	 DWORD PTR _Option1$[ebp], eax

; 1031 : 			Option2 = rand()%2;

  0010a	e8 00 00 00 00	 call	 _rand
  0010f	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00114	79 05		 jns	 SHORT $LN16@SilverMeda
  00116	48		 dec	 eax
  00117	83 c8 fe	 or	 eax, -2			; fffffffeH
  0011a	40		 inc	 eax
$LN16@SilverMeda:
  0011b	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 1032 : 
; 1033 : 			if( !Option2 || !Option1 )

  0011e	83 7d e4 00	 cmp	 DWORD PTR _Option2$[ebp], 0
  00122	74 06		 je	 SHORT $LN6@SilverMeda
  00124	83 7d e8 00	 cmp	 DWORD PTR _Option1$[ebp], 0
  00128	75 2b		 jne	 SHORT $LN8@SilverMeda
$LN6@SilverMeda:

; 1034 : 			{	// 둘중의 하나가 0이면 
; 1035 : 				if( (rand()%5) < 1 )

  0012a	e8 00 00 00 00	 call	 _rand
  0012f	99		 cdq
  00130	b9 05 00 00 00	 mov	 ecx, 5
  00135	f7 f9		 idiv	 ecx
  00137	83 fa 01	 cmp	 edx, 1
  0013a	7d 09		 jge	 SHORT $LN7@SilverMeda

; 1036 : 				{
; 1037 : 					Option3 = 3;

  0013c	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 1038 : 				}

  00143	eb 10		 jmp	 SHORT $LN8@SilverMeda
$LN7@SilverMeda:

; 1039 : 				else Option3 = (rand()%3);

  00145	e8 00 00 00 00	 call	 _rand
  0014a	99		 cdq
  0014b	b9 03 00 00 00	 mov	 ecx, 3
  00150	f7 f9		 idiv	 ecx
  00152	89 55 e0	 mov	 DWORD PTR _Option3$[ebp], edx
$LN8@SilverMeda:

; 1040 : 			}			
; 1041 : 
; 1042 : 			// 혼석, 축석, 영석은 레벨이 없게
; 1043 : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 1044 : 				(type == MAKE_ITEMNUM(14, 13)) ||

  00155	6a 0f		 push	 15			; 0000000fH
  00157	6a 0c		 push	 12			; 0000000cH
  00159	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0015e	83 c4 08	 add	 esp, 8
  00161	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00164	74 22		 je	 SHORT $LN10@SilverMeda
  00166	6a 0d		 push	 13			; 0000000dH
  00168	6a 0e		 push	 14			; 0000000eH
  0016a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0016f	83 c4 08	 add	 esp, 8
  00172	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00175	74 11		 je	 SHORT $LN10@SilverMeda
  00177	6a 0e		 push	 14			; 0000000eH
  00179	6a 0e		 push	 14			; 0000000eH
  0017b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00180	83 c4 08	 add	 esp, 8
  00183	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00186	75 23		 jne	 SHORT $LN9@SilverMeda
$LN10@SilverMeda:

; 1045 : 				(type == MAKE_ITEMNUM(14, 14)) )				
; 1046 : 			{	
; 1047 : 				Option1 = 0; 

  00188	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1048 : 				Option2 = 0;

  0018f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1049 : 				Option3 = 0;

  00196	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1050 : 				level   = 0;

  0019d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 1051 : 				ExOption = 0;

  001a4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ExOption$[ebp], 0
$LN9@SilverMeda:

; 1052 : 			}
; 1053 : 			
; 1054 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 1055 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 1056 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 1057 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 1058 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 1059 : 				(type == MAKE_ITEMNUM(13, 12)) ||

  001ab	6a 00		 push	 0
  001ad	6a 0d		 push	 13			; 0000000dH
  001af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001b4	83 c4 08	 add	 esp, 8
  001b7	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ba	74 66		 je	 SHORT $LN12@SilverMeda
  001bc	6a 01		 push	 1
  001be	6a 0d		 push	 13			; 0000000dH
  001c0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001c5	83 c4 08	 add	 esp, 8
  001c8	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001cb	74 55		 je	 SHORT $LN12@SilverMeda
  001cd	6a 02		 push	 2
  001cf	6a 0d		 push	 13			; 0000000dH
  001d1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001d6	83 c4 08	 add	 esp, 8
  001d9	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001dc	74 44		 je	 SHORT $LN12@SilverMeda
  001de	6a 08		 push	 8
  001e0	6a 0d		 push	 13			; 0000000dH
  001e2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e7	83 c4 08	 add	 esp, 8
  001ea	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ed	74 33		 je	 SHORT $LN12@SilverMeda
  001ef	6a 09		 push	 9
  001f1	6a 0d		 push	 13			; 0000000dH
  001f3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f8	83 c4 08	 add	 esp, 8
  001fb	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001fe	74 22		 je	 SHORT $LN12@SilverMeda
  00200	6a 0c		 push	 12			; 0000000cH
  00202	6a 0d		 push	 13			; 0000000dH
  00204	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00209	83 c4 08	 add	 esp, 8
  0020c	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0020f	74 11		 je	 SHORT $LN12@SilverMeda
  00211	6a 0d		 push	 13			; 0000000dH
  00213	6a 0d		 push	 13			; 0000000dH
  00215	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0021a	83 c4 08	 add	 esp, 8
  0021d	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00220	75 07		 jne	 SHORT $LN11@SilverMeda
$LN12@SilverMeda:

; 1060 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 1061 : 			{	// 반지류는 레벨 0
; 1062 : 				level   = 0;

  00222	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN11@SilverMeda:

; 1063 : 			}			
; 1064 : 
; 1065 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);

  00229	6a 00		 push	 0
  0022b	6a 00		 push	 0
  0022d	6a 00		 push	 0
  0022f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00232	8b 08		 mov	 ecx, DWORD PTR [eax]
  00234	51		 push	 ecx
  00235	0f b6 55 e0	 movzx	 edx, BYTE PTR _Option3$[ebp]
  00239	52		 push	 edx
  0023a	0f b6 45 e4	 movzx	 eax, BYTE PTR _Option2$[ebp]
  0023e	50		 push	 eax
  0023f	0f b6 4d e8	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  00243	51		 push	 ecx
  00244	f3 0f 2c 55 fc	 cvttss2si edx, DWORD PTR _dur$[ebp]
  00249	0f b6 c2	 movzx	 eax, dl
  0024c	50		 push	 eax
  0024d	0f b6 4d f4	 movzx	 ecx, BYTE PTR _level$[ebp]
  00251	51		 push	 ecx
  00252	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  00255	52		 push	 edx
  00256	0f b6 45 ec	 movzx	 eax, BYTE PTR _y$[ebp]
  0025a	50		 push	 eax
  0025b	0f b6 4d f0	 movzx	 ecx, BYTE PTR _x$[ebp]
  0025f	51		 push	 ecx
  00260	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00263	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0026a	50		 push	 eax
  0026b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0026e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00270	52		 push	 edx
  00271	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00276	83 c4 38	 add	 esp, 56			; 00000038H

; 1066 : 
; 1067 : 			// 팡파레..
; 1068 : 			PMSG_SERVERCMD	ServerCmd;
; 1069 : 			PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  00279	6a 07		 push	 7
  0027b	6a 40		 push	 64			; 00000040H
  0027d	68 f3 00 00 00	 push	 243			; 000000f3H
  00282	8d 45 d0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0028b	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 
; 1071 : 			ServerCmd.CmdType = 2;	// 팡파레

  0028e	c6 45 d4 02	 mov	 BYTE PTR _ServerCmd$1[ebp+4], 2

; 1072 : 			ServerCmd.X = x;

  00292	8a 45 f0	 mov	 al, BYTE PTR _x$[ebp]
  00295	88 45 d5	 mov	 BYTE PTR _ServerCmd$1[ebp+5], al

; 1073 : 			ServerCmd.Y = y;

  00298	8a 45 ec	 mov	 al, BYTE PTR _y$[ebp]
  0029b	88 45 d6	 mov	 BYTE PTR _ServerCmd$1[ebp+6], al

; 1074 : 			MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  0029e	6a 07		 push	 7
  002a0	8d 45 d0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  002a3	50		 push	 eax
  002a4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002a7	51		 push	 ecx
  002a8	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  002ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1075 : 			DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  002b0	6a 07		 push	 7
  002b2	8d 45 d0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  002b5	50		 push	 eax
  002b6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  002bb	52		 push	 edx
  002bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1076 : 
; 1077 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 1078 : 			CItem EventItem;
; 1079 : 			EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 1080 : 
; 1081 : 			LogAddTD("[%s][%s][Lucky Box Item Drop][Silver Medal] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 1082 : 				lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 1083 : 				EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 1084 : #else
; 1085 : 			LogAdd("Medal Event SilverMedal ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  002c4	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  002c7	50		 push	 eax
  002c8	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  002cb	51		 push	 ecx
  002cc	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  002cf	52		 push	 edx
  002d0	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  002d3	50		 push	 eax
  002d4	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  002d7	51		 push	 ecx
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@JIIDGOIJ@Medal?5Event?5SilverMedal?5ItemDro@
  002dd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002e3	83 c4 18	 add	 esp, 24			; 00000018H

; 1086 : #endif
; 1087 : 			return;

  002e6	eb 42		 jmp	 SHORT $LN1@SilverMeda
$LN4@SilverMeda:

; 1088 : 		}
; 1089 : 	}
; 1090 : 	x    = lpObj->X;

  002e8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002eb	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  002f2	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1091 : 	y    = lpObj->Y;	

  002f5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f8	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  002ff	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1092 : #ifdef MODIFY_MEDAL_EVENT_ZEN_20050829
; 1093 : 	MapC[lpObj->MapNumber].MoneyItemDrop(2005, x ,y);	
; 1094 : #else
; 1095 : 	MapC[lpObj->MapNumber].MoneyItemDrop(100000, x ,y);	

  00302	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  00305	50		 push	 eax
  00306	8b 4d f0	 mov	 ecx, DWORD PTR _x$[ebp]
  00309	51		 push	 ecx
  0030a	68 a0 86 01 00	 push	 100000			; 000186a0H
  0030f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00312	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00319	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  0031f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00325	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN1@SilverMeda:

; 1096 : //	MapC[lpObj->MapNumber].MoneyItemDrop(5100, x ,y);	
; 1097 : #endif
; 1098 : }

  0032a	5f		 pop	 edi
  0032b	5e		 pop	 esi
  0032c	5b		 pop	 ebx
  0032d	8b e5		 mov	 esp, ebp
  0032f	5d		 pop	 ebp
  00330	c3		 ret	 0
?SilverMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; SilverMedalOpenEven
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?GoldMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ServerCmd$1 = -48					; size = 7
_ExOption$ = -40					; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?GoldMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z PROC		; GoldMedalOpenEven, COMDAT

; 901  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 902  : 	float dur;
; 903  : 	int type, level, x, y;
; 904  : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 905  : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 906  : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 907  : 	int DropItemNum;
; 908  : 	int ExOption = 0;

  0001e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ExOption$[ebp], 0

; 909  : 
; 910  : 	if( !GoldMedalItemBag )

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GoldMedalItemBag@@3PAVCItemBag@@A, 0 ; GoldMedalItemBag
  0002c	75 05		 jne	 SHORT $LN2@GoldMedalO

; 911  : 		return;

  0002e	e9 fa 02 00 00	 jmp	 $LN1@GoldMedalO
$LN2@GoldMedalO:

; 912  : 
; 913  : 	if( GoldMedalItemBag->GetBagCount() > 0 )

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GoldMedalItemBag@@3PAVCItemBag@@A ; GoldMedalItemBag
  00039	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  0003e	85 c0		 test	 eax, eax
  00040	0f 8e a5 02 00
	00		 jle	 $LN4@GoldMedalO

; 914  : 	{
; 915  : 		// 2/20 의 확률로 이벤트용 아이템 증정
; 916  : 		if( (rand()%20) < g_ItemDropRateForGoldMedal )

  00046	e8 00 00 00 00	 call	 _rand
  0004b	99		 cdq
  0004c	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00051	f7 f9		 idiv	 ecx
  00053	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_ItemDropRateForGoldMedal@@3HA ; g_ItemDropRateForGoldMedal
  00059	0f 8d 8c 02 00
	00		 jge	 $LN4@GoldMedalO

; 917  : 		{
; 918  : 			DropItemNum = (rand()%GoldMedalItemBag->GetBagCount());

  0005f	e8 00 00 00 00	 call	 _rand
  00064	8b f0		 mov	 esi, eax
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GoldMedalItemBag@@3PAVCItemBag@@A ; GoldMedalItemBag
  0006c	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00071	8b c8		 mov	 ecx, eax
  00073	8b c6		 mov	 eax, esi
  00075	99		 cdq
  00076	f7 f9		 idiv	 ecx
  00078	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 919  : 			dur  = 0;

  0007b	0f 57 c0	 xorps	 xmm0, xmm0
  0007e	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 920  : 			x    = lpObj->X;

  00083	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00086	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0008d	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 921  : 			y    = lpObj->Y;			

  00090	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00093	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0009a	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 922  : 
; 923  : 			// ItemBag에서는 레벨이 3부터 설정되어 있다 (3 - 6)
; 924  : //			level= GoldMedalItemBag->GetLevel(DropItemNum)+(rand()%3);		// 20050901 - 태국 이벤트 관련 (b4nfter)
; 925  : 			level= GoldMedalItemBag->GetLevel(DropItemNum)+(rand()%4);

  0009d	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000a0	50		 push	 eax
  000a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GoldMedalItemBag@@3PAVCItemBag@@A ; GoldMedalItemBag
  000a7	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  000ac	0f b6 f0	 movzx	 esi, al
  000af	e8 00 00 00 00	 call	 _rand
  000b4	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000b9	79 05		 jns	 SHORT $LN14@GoldMedalO
  000bb	48		 dec	 eax
  000bc	83 c8 fc	 or	 eax, -4			; fffffffcH
  000bf	40		 inc	 eax
$LN14@GoldMedalO:
  000c0	03 f0		 add	 esi, eax
  000c2	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi

; 926  : 			
; 927  : 			type = ItemGetNumberMake(GoldMedalItemBag->GetType(DropItemNum), GoldMedalItemBag->GetIndex(DropItemNum));

  000c5	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000c8	50		 push	 eax
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GoldMedalItemBag@@3PAVCItemBag@@A ; GoldMedalItemBag
  000cf	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  000d4	0f b6 c8	 movzx	 ecx, al
  000d7	51		 push	 ecx
  000d8	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  000db	52		 push	 edx
  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GoldMedalItemBag@@3PAVCItemBag@@A ; GoldMedalItemBag
  000e2	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  000e7	0f b6 c0	 movzx	 eax, al
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000f0	83 c4 08	 add	 esp, 8
  000f3	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 928  : 			
; 929  : 			Option1 = rand()%2;

  000f6	e8 00 00 00 00	 call	 _rand
  000fb	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00100	79 05		 jns	 SHORT $LN15@GoldMedalO
  00102	48		 dec	 eax
  00103	83 c8 fe	 or	 eax, -2			; fffffffeH
  00106	40		 inc	 eax
$LN15@GoldMedalO:
  00107	89 45 e8	 mov	 DWORD PTR _Option1$[ebp], eax

; 930  : 			Option2 = rand()%2;

  0010a	e8 00 00 00 00	 call	 _rand
  0010f	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00114	79 05		 jns	 SHORT $LN16@GoldMedalO
  00116	48		 dec	 eax
  00117	83 c8 fe	 or	 eax, -2			; fffffffeH
  0011a	40		 inc	 eax
$LN16@GoldMedalO:
  0011b	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 931  : 
; 932  : 			if( !Option2 || !Option1 )

  0011e	83 7d e4 00	 cmp	 DWORD PTR _Option2$[ebp], 0
  00122	74 06		 je	 SHORT $LN6@GoldMedalO
  00124	83 7d e8 00	 cmp	 DWORD PTR _Option1$[ebp], 0
  00128	75 2b		 jne	 SHORT $LN8@GoldMedalO
$LN6@GoldMedalO:

; 933  : 			{	// 둘중의 하나가 0이면 
; 934  : 				if( (rand()%5) < 1 )

  0012a	e8 00 00 00 00	 call	 _rand
  0012f	99		 cdq
  00130	b9 05 00 00 00	 mov	 ecx, 5
  00135	f7 f9		 idiv	 ecx
  00137	83 fa 01	 cmp	 edx, 1
  0013a	7d 09		 jge	 SHORT $LN7@GoldMedalO

; 935  : 				{
; 936  : 					Option3 = 3;

  0013c	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 937  : 				}

  00143	eb 10		 jmp	 SHORT $LN8@GoldMedalO
$LN7@GoldMedalO:

; 938  : 				else Option3 = (rand()%3);

  00145	e8 00 00 00 00	 call	 _rand
  0014a	99		 cdq
  0014b	b9 03 00 00 00	 mov	 ecx, 3
  00150	f7 f9		 idiv	 ecx
  00152	89 55 e0	 mov	 DWORD PTR _Option3$[ebp], edx
$LN8@GoldMedalO:

; 939  : 			}			
; 940  : 
; 941  : 			// 혼석, 축석, 영석은 레벨이 없게
; 942  : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 943  : 				(type == MAKE_ITEMNUM(14, 13)) ||

  00155	6a 0f		 push	 15			; 0000000fH
  00157	6a 0c		 push	 12			; 0000000cH
  00159	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0015e	83 c4 08	 add	 esp, 8
  00161	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00164	74 22		 je	 SHORT $LN10@GoldMedalO
  00166	6a 0d		 push	 13			; 0000000dH
  00168	6a 0e		 push	 14			; 0000000eH
  0016a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0016f	83 c4 08	 add	 esp, 8
  00172	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00175	74 11		 je	 SHORT $LN10@GoldMedalO
  00177	6a 0e		 push	 14			; 0000000eH
  00179	6a 0e		 push	 14			; 0000000eH
  0017b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00180	83 c4 08	 add	 esp, 8
  00183	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00186	75 23		 jne	 SHORT $LN9@GoldMedalO
$LN10@GoldMedalO:

; 944  : 				(type == MAKE_ITEMNUM(14, 14)) )				
; 945  : 			{	
; 946  : 				Option1 = 0; 

  00188	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 947  : 				Option2 = 0;

  0018f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 948  : 				Option3 = 0;

  00196	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 949  : 				level   = 0;

  0019d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 950  : 				ExOption = 0;

  001a4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _ExOption$[ebp], 0
$LN9@GoldMedalO:

; 951  : 			}
; 952  : 			
; 953  : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 954  : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 955  : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 956  : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 957  : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 958  : 				(type == MAKE_ITEMNUM(13, 12)) ||

  001ab	6a 00		 push	 0
  001ad	6a 0d		 push	 13			; 0000000dH
  001af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001b4	83 c4 08	 add	 esp, 8
  001b7	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ba	74 66		 je	 SHORT $LN12@GoldMedalO
  001bc	6a 01		 push	 1
  001be	6a 0d		 push	 13			; 0000000dH
  001c0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001c5	83 c4 08	 add	 esp, 8
  001c8	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001cb	74 55		 je	 SHORT $LN12@GoldMedalO
  001cd	6a 02		 push	 2
  001cf	6a 0d		 push	 13			; 0000000dH
  001d1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001d6	83 c4 08	 add	 esp, 8
  001d9	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001dc	74 44		 je	 SHORT $LN12@GoldMedalO
  001de	6a 08		 push	 8
  001e0	6a 0d		 push	 13			; 0000000dH
  001e2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e7	83 c4 08	 add	 esp, 8
  001ea	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ed	74 33		 je	 SHORT $LN12@GoldMedalO
  001ef	6a 09		 push	 9
  001f1	6a 0d		 push	 13			; 0000000dH
  001f3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f8	83 c4 08	 add	 esp, 8
  001fb	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001fe	74 22		 je	 SHORT $LN12@GoldMedalO
  00200	6a 0c		 push	 12			; 0000000cH
  00202	6a 0d		 push	 13			; 0000000dH
  00204	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00209	83 c4 08	 add	 esp, 8
  0020c	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0020f	74 11		 je	 SHORT $LN12@GoldMedalO
  00211	6a 0d		 push	 13			; 0000000dH
  00213	6a 0d		 push	 13			; 0000000dH
  00215	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0021a	83 c4 08	 add	 esp, 8
  0021d	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00220	75 07		 jne	 SHORT $LN11@GoldMedalO
$LN12@GoldMedalO:

; 959  : 				(type == MAKE_ITEMNUM(13, 13)) )
; 960  : 			{	// 반지류는 레벨 0
; 961  : 				level   = 0;

  00222	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN11@GoldMedalO:

; 962  : 			}			
; 963  : 
; 964  : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index, ExOption);

  00229	6a 00		 push	 0
  0022b	6a 00		 push	 0
  0022d	0f b6 45 d8	 movzx	 eax, BYTE PTR _ExOption$[ebp]
  00231	50		 push	 eax
  00232	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00235	8b 11		 mov	 edx, DWORD PTR [ecx]
  00237	52		 push	 edx
  00238	0f b6 45 e0	 movzx	 eax, BYTE PTR _Option3$[ebp]
  0023c	50		 push	 eax
  0023d	0f b6 4d e4	 movzx	 ecx, BYTE PTR _Option2$[ebp]
  00241	51		 push	 ecx
  00242	0f b6 55 e8	 movzx	 edx, BYTE PTR _Option1$[ebp]
  00246	52		 push	 edx
  00247	f3 0f 2c 45 fc	 cvttss2si eax, DWORD PTR _dur$[ebp]
  0024c	0f b6 c8	 movzx	 ecx, al
  0024f	51		 push	 ecx
  00250	0f b6 55 f4	 movzx	 edx, BYTE PTR _level$[ebp]
  00254	52		 push	 edx
  00255	8b 45 f8	 mov	 eax, DWORD PTR _type$[ebp]
  00258	50		 push	 eax
  00259	0f b6 4d ec	 movzx	 ecx, BYTE PTR _y$[ebp]
  0025d	51		 push	 ecx
  0025e	0f b6 55 f0	 movzx	 edx, BYTE PTR _x$[ebp]
  00262	52		 push	 edx
  00263	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00266	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0026d	51		 push	 ecx
  0026e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00271	8b 02		 mov	 eax, DWORD PTR [edx]
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00279	83 c4 38	 add	 esp, 56			; 00000038H

; 965  : 
; 966  : 			// 팡파레..
; 967  : 			PMSG_SERVERCMD	ServerCmd;
; 968  : 			PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  0027c	6a 07		 push	 7
  0027e	6a 40		 push	 64			; 00000040H
  00280	68 f3 00 00 00	 push	 243			; 000000f3H
  00285	8d 45 d0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  00288	50		 push	 eax
  00289	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0028e	83 c4 10	 add	 esp, 16			; 00000010H

; 969  : 
; 970  : 			ServerCmd.CmdType = 2;	// 팡파레

  00291	c6 45 d4 02	 mov	 BYTE PTR _ServerCmd$1[ebp+4], 2

; 971  : 			ServerCmd.X = x;

  00295	8a 45 f0	 mov	 al, BYTE PTR _x$[ebp]
  00298	88 45 d5	 mov	 BYTE PTR _ServerCmd$1[ebp+5], al

; 972  : 			ServerCmd.Y = y;

  0029b	8a 45 ec	 mov	 al, BYTE PTR _y$[ebp]
  0029e	88 45 d6	 mov	 BYTE PTR _ServerCmd$1[ebp+6], al

; 973  : 			MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  002a1	6a 07		 push	 7
  002a3	8d 45 d0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  002a6	50		 push	 eax
  002a7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002aa	51		 push	 ecx
  002ab	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  002b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 974  : 			DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  002b3	6a 07		 push	 7
  002b5	8d 45 d0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  002b8	50		 push	 eax
  002b9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  002be	52		 push	 edx
  002bf	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 975  : 
; 976  : #ifdef EXTEND_LOG_SYSTEM_20060202
; 977  : 			CItem EventItem;
; 978  : 			EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 979  : 
; 980  : 			LogAddTD("[%s][%s][Lucky Box Item Drop][Gold Medal] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 981  : 				lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 982  : 				EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 983  : #else
; 984  : 			LogAdd("Medal Event GoldMedal ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  002c7	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  002ca	50		 push	 eax
  002cb	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  002ce	51		 push	 ecx
  002cf	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  002d2	52		 push	 edx
  002d3	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  002d6	50		 push	 eax
  002d7	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  002da	51		 push	 ecx
  002db	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@JBCAMEJ@Medal?5Event?5GoldMedal?5ItemDrop?5@
  002e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002e6	83 c4 18	 add	 esp, 24			; 00000018H

; 985  : #endif
; 986  : 			return;

  002e9	eb 42		 jmp	 SHORT $LN1@GoldMedalO
$LN4@GoldMedalO:

; 987  : 		}
; 988  : 	}
; 989  : 	x    = lpObj->X;

  002eb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ee	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  002f5	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 990  : 	y    = lpObj->Y;	

  002f8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002fb	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00302	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 991  : #ifdef MODIFY_MEDAL_EVENT_ZEN_20050829
; 992  : 	MapC[lpObj->MapNumber].MoneyItemDrop(2005, x ,y);	
; 993  : #else
; 994  : 	MapC[lpObj->MapNumber].MoneyItemDrop(100000, x ,y);	

  00305	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  00308	50		 push	 eax
  00309	8b 4d f0	 mov	 ecx, DWORD PTR _x$[ebp]
  0030c	51		 push	 ecx
  0030d	68 a0 86 01 00	 push	 100000			; 000186a0H
  00312	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00315	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0031c	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00322	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00328	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN1@GoldMedalO:

; 995  : //	MapC[lpObj->MapNumber].MoneyItemDrop(5100, x ,y);	
; 996  : #endif
; 997  : }

  0032d	5f		 pop	 edi
  0032e	5e		 pop	 esi
  0032f	5b		 pop	 ebx
  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c3		 ret	 0
?GoldMedalOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; GoldMedalOpenEven
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?KundunEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@EEE@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_btMapNumber$ = 12					; size = 1
_cX$ = 16						; size = 1
_cY$ = 20						; size = 1
?KundunEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@EEE@Z PROC	; KundunEventItemBoxOpen, COMDAT

; 2159 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2160 : 
; 2161 : 	KundunEventItemBag->DropKundunEventItem(lpObj->m_Index, btMapNumber, cX, cY);

  00009	0f b6 45 14	 movzx	 eax, BYTE PTR _cY$[ebp]
  0000d	50		 push	 eax
  0000e	0f b6 4d 10	 movzx	 ecx, BYTE PTR _cX$[ebp]
  00012	51		 push	 ecx
  00013	0f b6 55 0c	 movzx	 edx, BYTE PTR _btMapNumber$[ebp]
  00017	52		 push	 edx
  00018	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	51		 push	 ecx
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?KundunEventItemBag@@3PAVCItemBagEx@@A ; KundunEventItemBag
  00024	e8 00 00 00 00	 call	 ?DropKundunEventItem@CItemBagEx@@QAEHHEEE@Z ; CItemBagEx::DropKundunEventItem

; 2162 : 
; 2163 : }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?KundunEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@EEE@Z ENDP	; KundunEventItemBoxOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?DarkLordHeartItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv147 = -112						; size = 4
tv143 = -112						; size = 4
_iOption3Rand$1 = -44					; size = 4
_DropItemRate$ = -40					; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?DarkLordHeartItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z PROC	; DarkLordHeartItemBoxOpen, COMDAT

; 1922 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1923 : 	float dur;
; 1924 : 	int type, level, x, y;
; 1925 : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1926 : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1927 : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1928 : 	int DropItemNum;
; 1929 : 	int DropItemRate	= 0;						// 아이템 드롭 확률이 모두 다르다.

  0001e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _DropItemRate$[ebp], 0

; 1930 : 	
; 1931 : 
; 1932 : 	if (((DWORD)rand())%60000 < g_iDarkLordHeartOffEventRate) {

  00025	e8 00 00 00 00	 call	 _rand
  0002a	33 d2		 xor	 edx, edx
  0002c	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  00031	f7 f1		 div	 ecx
  00033	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iDarkLordHeartOffEventRate@@3HA ; g_iDarkLordHeartOffEventRate
  00039	73 22		 jae	 SHORT $LN2@DarkLordHe

; 1933 : 		// 오프라인 상품에 당첨되었다 -> 등록을 시도한다.
; 1934 : 
; 1935 : 		if (lpObj->Level > 100) {					// 레벨이 100을 넘으면 경품에 당첨될 수 없다.

  0003b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003e	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00045	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00048	7e 05		 jle	 SHORT $LN3@DarkLordHe

; 1936 : 			return;

  0004a	e9 fa 02 00 00	 jmp	 $LN1@DarkLordHe
$LN3@DarkLordHe:

; 1937 : 		}
; 1938 : 
; 1939 : 		EGReqRegDLOfflineGift (lpObj->m_Index);

  0004f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00052	8b 08		 mov	 ecx, DWORD PTR [eax]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ?EGReqRegDLOfflineGift@@YAXH@Z ; EGReqRegDLOfflineGift
  0005a	83 c4 04	 add	 esp, 4
$LN2@DarkLordHe:

; 1940 : 	}
; 1941 : 
; 1942 : 	if( DarkLordHeartItemBag->GetBagCount() > 0 )

  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DarkLordHeartItemBag@@3PAVCItemBag@@A ; DarkLordHeartItemBag
  00063	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00068	85 c0		 test	 eax, eax
  0006a	0f 8e 97 02 00
	00		 jle	 $LN5@DarkLordHe

; 1943 : 	{
; 1944 : 		DropItemNum		= (rand()%DarkLordHeartItemBag->GetBagCount());

  00070	e8 00 00 00 00	 call	 _rand
  00075	8b f0		 mov	 esi, eax
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DarkLordHeartItemBag@@3PAVCItemBag@@A ; DarkLordHeartItemBag
  0007d	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00082	8b c8		 mov	 ecx, eax
  00084	8b c6		 mov	 eax, esi
  00086	99		 cdq
  00087	f7 f9		 idiv	 ecx
  00089	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 1945 : 		DropItemRate	= DarkLordHeartItemBag->GetOp1(DropItemNum);			// Option1 (스킬) 부분을 드롭확률로 사용한다.

  0008c	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  0008f	50		 push	 eax
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DarkLordHeartItemBag@@3PAVCItemBag@@A ; DarkLordHeartItemBag
  00096	e8 00 00 00 00	 call	 ?GetOp1@CItemBag@@QAEEH@Z ; CItemBag::GetOp1
  0009b	0f b6 c8	 movzx	 ecx, al
  0009e	89 4d d8	 mov	 DWORD PTR _DropItemRate$[ebp], ecx

; 1946 : 
; 1947 : 		// 아이템에 지정된 드롭확률 적용
; 1948 : 	#ifndef FOR_NEW_TESTSERVER		
; 1949 : 		if( (rand()%100) < DropItemRate && lpObj->Level <= 100)

  000a1	e8 00 00 00 00	 call	 _rand
  000a6	99		 cdq
  000a7	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000ac	f7 f9		 idiv	 ecx
  000ae	3b 55 d8	 cmp	 edx, DWORD PTR _DropItemRate$[ebp]
  000b1	0f 8d 50 02 00
	00		 jge	 $LN5@DarkLordHe
  000b7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ba	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000c1	83 f9 64	 cmp	 ecx, 100		; 00000064H
  000c4	0f 8f 3d 02 00
	00		 jg	 $LN5@DarkLordHe

; 1950 : 	#else // else FOR_NEW_TESTSERVER
; 1951 : 		if( (rand()%100) < DropItemRate)
; 1952 : 	#endif // FOR_NEW_TESTSERVER
; 1953 : //		if( (rand()%100) < DropItemRate)
; 1954 : 		{
; 1955 : 			level			= DarkLordHeartItemBag->GetLevel(DropItemNum);

  000ca	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000cd	50		 push	 eax
  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DarkLordHeartItemBag@@3PAVCItemBag@@A ; DarkLordHeartItemBag
  000d4	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  000d9	0f b6 c8	 movzx	 ecx, al
  000dc	89 4d f4	 mov	 DWORD PTR _level$[ebp], ecx

; 1956 : 
; 1957 : 			dur  = 0;

  000df	0f 57 c0	 xorps	 xmm0, xmm0
  000e2	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 1958 : 			x    = lpObj->X;

  000e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ea	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000f1	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1959 : 			y    = lpObj->Y;

  000f4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f7	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000fe	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1960 : 
; 1961 : 			type = ItemGetNumberMake(DarkLordHeartItemBag->GetType(DropItemNum), DarkLordHeartItemBag->GetIndex(DropItemNum));

  00101	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00104	50		 push	 eax
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DarkLordHeartItemBag@@3PAVCItemBag@@A ; DarkLordHeartItemBag
  0010b	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  00110	0f b6 c8	 movzx	 ecx, al
  00113	51		 push	 ecx
  00114	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  00117	52		 push	 edx
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DarkLordHeartItemBag@@3PAVCItemBag@@A ; DarkLordHeartItemBag
  0011e	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  00123	0f b6 c0	 movzx	 eax, al
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0012c	83 c4 08	 add	 esp, 8
  0012f	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 1962 : 
; 1963 : 			Option1 = (rand()%100 < 70) ? 1 : 0;		// 스킬

  00132	e8 00 00 00 00	 call	 _rand
  00137	99		 cdq
  00138	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0013d	f7 f9		 idiv	 ecx
  0013f	83 fa 46	 cmp	 edx, 70			; 00000046H
  00142	7d 09		 jge	 SHORT $LN17@DarkLordHe
  00144	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv143[ebp], 1
  0014b	eb 07		 jmp	 SHORT $LN18@DarkLordHe
$LN17@DarkLordHe:
  0014d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv143[ebp], 0
$LN18@DarkLordHe:
  00154	8b 55 90	 mov	 edx, DWORD PTR tv143[ebp]
  00157	89 55 e8	 mov	 DWORD PTR _Option1$[ebp], edx

; 1964 : 			Option2 = (rand()%100 < 10) ? 1 : 0;		// 행운

  0015a	e8 00 00 00 00	 call	 _rand
  0015f	99		 cdq
  00160	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00165	f7 f9		 idiv	 ecx
  00167	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0016a	7d 09		 jge	 SHORT $LN19@DarkLordHe
  0016c	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv147[ebp], 1
  00173	eb 07		 jmp	 SHORT $LN20@DarkLordHe
$LN19@DarkLordHe:
  00175	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv147[ebp], 0
$LN20@DarkLordHe:
  0017c	8b 55 90	 mov	 edx, DWORD PTR tv147[ebp]
  0017f	89 55 e4	 mov	 DWORD PTR _Option2$[ebp], edx

; 1965 : 
; 1966 : 			int iOption3Rand = rand()%20;

  00182	e8 00 00 00 00	 call	 _rand
  00187	99		 cdq
  00188	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0018d	f7 f9		 idiv	 ecx
  0018f	89 55 d4	 mov	 DWORD PTR _iOption3Rand$1[ebp], edx

; 1967 : 			if (iOption3Rand < 1) {

  00192	83 7d d4 01	 cmp	 DWORD PTR _iOption3Rand$1[ebp], 1
  00196	7d 09		 jge	 SHORT $LN6@DarkLordHe

; 1968 : 				Option3 = 3;							// + 12

  00198	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 1969 : 			}

  0019f	eb 25		 jmp	 SHORT $LN11@DarkLordHe
$LN6@DarkLordHe:

; 1970 : 			else if (iOption3Rand < 5) {

  001a1	83 7d d4 05	 cmp	 DWORD PTR _iOption3Rand$1[ebp], 5
  001a5	7d 09		 jge	 SHORT $LN8@DarkLordHe

; 1971 : 				Option3 = 2;							// + 8

  001a7	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 2

; 1972 : 			}

  001ae	eb 16		 jmp	 SHORT $LN11@DarkLordHe
$LN8@DarkLordHe:

; 1973 : 			else if (iOption3Rand < 9) {

  001b0	83 7d d4 09	 cmp	 DWORD PTR _iOption3Rand$1[ebp], 9
  001b4	7d 09		 jge	 SHORT $LN10@DarkLordHe

; 1974 : 				Option3 = 1;							// + 4

  001b6	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 1

; 1975 : 			}

  001bd	eb 07		 jmp	 SHORT $LN11@DarkLordHe
$LN10@DarkLordHe:

; 1976 : 			else {
; 1977 : 				Option3 = 0;							// 없음

  001bf	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0
$LN11@DarkLordHe:

; 1978 : 			}
; 1979 : 			
; 1980 : 			// 혼석, 축석, 영석은 레벨이 없게
; 1981 : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 1982 : 				(type == MAKE_ITEMNUM(14, 13)) ||

  001c6	6a 0f		 push	 15			; 0000000fH
  001c8	6a 0c		 push	 12			; 0000000cH
  001ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001cf	83 c4 08	 add	 esp, 8
  001d2	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001d5	74 22		 je	 SHORT $LN13@DarkLordHe
  001d7	6a 0d		 push	 13			; 0000000dH
  001d9	6a 0e		 push	 14			; 0000000eH
  001db	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e0	83 c4 08	 add	 esp, 8
  001e3	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001e6	74 11		 je	 SHORT $LN13@DarkLordHe
  001e8	6a 0e		 push	 14			; 0000000eH
  001ea	6a 0e		 push	 14			; 0000000eH
  001ec	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f1	83 c4 08	 add	 esp, 8
  001f4	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001f7	75 1c		 jne	 SHORT $LN12@DarkLordHe
$LN13@DarkLordHe:

; 1983 : 				(type == MAKE_ITEMNUM(14, 14)) )
; 1984 : 			{	
; 1985 : 				Option1 = 0; 

  001f9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1986 : 				Option2 = 0;

  00200	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1987 : 				Option3 = 0;

  00207	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1988 : 				level   = 0;

  0020e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN12@DarkLordHe:

; 1989 : 			}
; 1990 : 
; 1991 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 1992 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 1993 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 1994 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 1995 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 1996 : 				(type == MAKE_ITEMNUM(13, 12)) ||

  00215	6a 00		 push	 0
  00217	6a 0d		 push	 13			; 0000000dH
  00219	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0021e	83 c4 08	 add	 esp, 8
  00221	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00224	74 66		 je	 SHORT $LN15@DarkLordHe
  00226	6a 01		 push	 1
  00228	6a 0d		 push	 13			; 0000000dH
  0022a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0022f	83 c4 08	 add	 esp, 8
  00232	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00235	74 55		 je	 SHORT $LN15@DarkLordHe
  00237	6a 02		 push	 2
  00239	6a 0d		 push	 13			; 0000000dH
  0023b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00240	83 c4 08	 add	 esp, 8
  00243	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00246	74 44		 je	 SHORT $LN15@DarkLordHe
  00248	6a 08		 push	 8
  0024a	6a 0d		 push	 13			; 0000000dH
  0024c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00251	83 c4 08	 add	 esp, 8
  00254	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00257	74 33		 je	 SHORT $LN15@DarkLordHe
  00259	6a 09		 push	 9
  0025b	6a 0d		 push	 13			; 0000000dH
  0025d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00262	83 c4 08	 add	 esp, 8
  00265	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00268	74 22		 je	 SHORT $LN15@DarkLordHe
  0026a	6a 0c		 push	 12			; 0000000cH
  0026c	6a 0d		 push	 13			; 0000000dH
  0026e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00273	83 c4 08	 add	 esp, 8
  00276	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00279	74 11		 je	 SHORT $LN15@DarkLordHe
  0027b	6a 0d		 push	 13			; 0000000dH
  0027d	6a 0d		 push	 13			; 0000000dH
  0027f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00284	83 c4 08	 add	 esp, 8
  00287	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0028a	75 07		 jne	 SHORT $LN14@DarkLordHe
$LN15@DarkLordHe:

; 1997 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 1998 : 			{	// 반지류는 레벨 0
; 1999 : 				level   = 0;

  0028c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN14@DarkLordHe:

; 2000 : 			}
; 2001 : 
; 2002 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);

  00293	6a 00		 push	 0
  00295	6a 00		 push	 0
  00297	6a 00		 push	 0
  00299	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0029e	51		 push	 ecx
  0029f	0f b6 55 e0	 movzx	 edx, BYTE PTR _Option3$[ebp]
  002a3	52		 push	 edx
  002a4	0f b6 45 e4	 movzx	 eax, BYTE PTR _Option2$[ebp]
  002a8	50		 push	 eax
  002a9	0f b6 4d e8	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  002ad	51		 push	 ecx
  002ae	f3 0f 2c 55 fc	 cvttss2si edx, DWORD PTR _dur$[ebp]
  002b3	0f b6 c2	 movzx	 eax, dl
  002b6	50		 push	 eax
  002b7	0f b6 4d f4	 movzx	 ecx, BYTE PTR _level$[ebp]
  002bb	51		 push	 ecx
  002bc	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  002bf	52		 push	 edx
  002c0	0f b6 45 ec	 movzx	 eax, BYTE PTR _y$[ebp]
  002c4	50		 push	 eax
  002c5	0f b6 4d f0	 movzx	 ecx, BYTE PTR _x$[ebp]
  002c9	51		 push	 ecx
  002ca	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002cd	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  002d4	50		 push	 eax
  002d5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  002da	52		 push	 edx
  002db	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  002e0	83 c4 38	 add	 esp, 56			; 00000038H

; 2003 : 
; 2004 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 2005 : 			CItem EventItem;
; 2006 : 			EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 2007 : 
; 2008 : 			LogAddTD("[%s][%s][Lucky Box Item Drop][Darklord Heart] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 2009 : 				lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 2010 : 				EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 2011 : #else
; 2012 : 			LogAdd("[DarkLord Heart Event] ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  002e3	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  002e6	50		 push	 eax
  002e7	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  002ea	51		 push	 ecx
  002eb	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  002ee	52		 push	 edx
  002ef	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  002f2	50		 push	 eax
  002f3	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  002f6	51		 push	 ecx
  002f7	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@PJJCECOB@?$FLDarkLord?5Heart?5Event?$FN?5ItemDrop@
  002fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00302	83 c4 18	 add	 esp, 24			; 00000018H

; 2013 : #endif
; 2014 : 			return;

  00305	eb 42		 jmp	 SHORT $LN1@DarkLordHe
$LN5@DarkLordHe:

; 2015 : 		}
; 2016 : 	}
; 2017 : 	
; 2018 : 	x    = lpObj->X;

  00307	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030a	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00311	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 2019 : 	y    = lpObj->Y;	

  00314	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00317	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0031e	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 2020 : 	MapC[lpObj->MapNumber].MoneyItemDrop(10000, x ,y);	

  00321	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  00324	50		 push	 eax
  00325	8b 4d f0	 mov	 ecx, DWORD PTR _x$[ebp]
  00328	51		 push	 ecx
  00329	68 10 27 00 00	 push	 10000			; 00002710H
  0032e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00331	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00338	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  0033e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00344	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN1@DarkLordHe:

; 2021 : }

  00349	5f		 pop	 edi
  0034a	5e		 pop	 esi
  0034b	5b		 pop	 ebx
  0034c	8b e5		 mov	 esp, ebp
  0034e	5d		 pop	 ebp
  0034f	c3		 ret	 0
?DarkLordHeartItemBoxOpen@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; DarkLordHeartItemBoxOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?HeartOfLoveOpenEven@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ServerCmd$1 = -44					; size = 7
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?HeartOfLoveOpenEven@@YAXPAVOBJECTSTRUCT@@@Z PROC	; HeartOfLoveOpenEven, COMDAT

; 1102 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1103 : 	float dur;
; 1104 : 	int type, level, x, y;
; 1105 : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1106 : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1107 : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1108 : 	int DropItemNum;
; 1109 : 
; 1110 : 	if( !HeartOfLoveItemBag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?HeartOfLoveItemBag@@3PAVCItemBag@@A, 0 ; HeartOfLoveItemBag
  00025	75 05		 jne	 SHORT $LN2@HeartOfLov

; 1111 : 		return;	

  00027	e9 1f 03 00 00	 jmp	 $LN1@HeartOfLov
$LN2@HeartOfLov:

; 1112 : 
; 1113 : 
; 1114 : 	if( HeartOfLoveItemBag->GetBagCount() > 0 )

  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeartOfLoveItemBag@@3PAVCItemBag@@A ; HeartOfLoveItemBag
  00032	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00037	85 c0		 test	 eax, eax
  00039	0f 8e ca 02 00
	00		 jle	 $LN4@HeartOfLov

; 1115 : 	{
; 1116 : 		// 2/20 의 확률로 이벤트용 아이템 증정
; 1117 : 		if( (rand()%20) < g_ItemDropRateForgHeartOfLove )

  0003f	e8 00 00 00 00	 call	 _rand
  00044	99		 cdq
  00045	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0004a	f7 f9		 idiv	 ecx
  0004c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_ItemDropRateForgHeartOfLove@@3HA ; g_ItemDropRateForgHeartOfLove
  00052	0f 8d b1 02 00
	00		 jge	 $LN4@HeartOfLov

; 1118 : 		{
; 1119 : 			DropItemNum = (rand()%HeartOfLoveItemBag->GetBagCount());

  00058	e8 00 00 00 00	 call	 _rand
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeartOfLoveItemBag@@3PAVCItemBag@@A ; HeartOfLoveItemBag
  00065	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  0006a	8b c8		 mov	 ecx, eax
  0006c	8b c6		 mov	 eax, esi
  0006e	99		 cdq
  0006f	f7 f9		 idiv	 ecx
  00071	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 1120 : 			dur  = 0;

  00074	0f 57 c0	 xorps	 xmm0, xmm0
  00077	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 1121 : 			x    = lpObj->X;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007f	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00086	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1122 : 			y    = lpObj->Y;			

  00089	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00093	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1123 : 
; 1124 : 			// Option은 3-7까지 (ItemBag4에는 레벨 3으로 설정되어 있다
; 1125 : 			if( gLanguage == 0 )

  00096	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLanguage@@3HA, 0 ; gLanguage
  0009d	75 2a		 jne	 SHORT $LN5@HeartOfLov

; 1126 : 			{	// 한국은 레벨 5 - 7까지
; 1127 : 				level= HeartOfLoveItemBag->GetLevel(DropItemNum)+(rand()%2);

  0009f	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000a2	50		 push	 eax
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeartOfLoveItemBag@@3PAVCItemBag@@A ; HeartOfLoveItemBag
  000a9	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  000ae	0f b6 f0	 movzx	 esi, al
  000b1	e8 00 00 00 00	 call	 _rand
  000b6	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000bb	79 05		 jns	 SHORT $LN16@HeartOfLov
  000bd	48		 dec	 eax
  000be	83 c8 fe	 or	 eax, -2			; fffffffeH
  000c1	40		 inc	 eax
$LN16@HeartOfLov:
  000c2	03 f0		 add	 esi, eax
  000c4	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi

; 1128 : 			}

  000c7	eb 24		 jmp	 SHORT $LN6@HeartOfLov
$LN5@HeartOfLov:

; 1129 : 			else
; 1130 : 			{
; 1131 : 				level= HeartOfLoveItemBag->GetLevel(DropItemNum)+(rand()%5);

  000c9	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000cc	50		 push	 eax
  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeartOfLoveItemBag@@3PAVCItemBag@@A ; HeartOfLoveItemBag
  000d3	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  000d8	0f b6 f0	 movzx	 esi, al
  000db	e8 00 00 00 00	 call	 _rand
  000e0	99		 cdq
  000e1	b9 05 00 00 00	 mov	 ecx, 5
  000e6	f7 f9		 idiv	 ecx
  000e8	03 f2		 add	 esi, edx
  000ea	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi
$LN6@HeartOfLov:

; 1132 : 			}
; 1133 : 			
; 1134 : 			type = ItemGetNumberMake(HeartOfLoveItemBag->GetType(DropItemNum), HeartOfLoveItemBag->GetIndex(DropItemNum));

  000ed	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000f0	50		 push	 eax
  000f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeartOfLoveItemBag@@3PAVCItemBag@@A ; HeartOfLoveItemBag
  000f7	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  000fc	0f b6 c8	 movzx	 ecx, al
  000ff	51		 push	 ecx
  00100	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  00103	52		 push	 edx
  00104	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeartOfLoveItemBag@@3PAVCItemBag@@A ; HeartOfLoveItemBag
  0010a	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  0010f	0f b6 c0	 movzx	 eax, al
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00118	83 c4 08	 add	 esp, 8
  0011b	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 1135 : 			
; 1136 : 			Option1 = rand()%2;

  0011e	e8 00 00 00 00	 call	 _rand
  00123	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00128	79 05		 jns	 SHORT $LN17@HeartOfLov
  0012a	48		 dec	 eax
  0012b	83 c8 fe	 or	 eax, -2			; fffffffeH
  0012e	40		 inc	 eax
$LN17@HeartOfLov:
  0012f	89 45 e8	 mov	 DWORD PTR _Option1$[ebp], eax

; 1137 : 			Option2 = rand()%2;

  00132	e8 00 00 00 00	 call	 _rand
  00137	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0013c	79 05		 jns	 SHORT $LN18@HeartOfLov
  0013e	48		 dec	 eax
  0013f	83 c8 fe	 or	 eax, -2			; fffffffeH
  00142	40		 inc	 eax
$LN18@HeartOfLov:
  00143	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 1138 : 
; 1139 : 			if( !Option2 || !Option1 )

  00146	83 7d e4 00	 cmp	 DWORD PTR _Option2$[ebp], 0
  0014a	74 06		 je	 SHORT $LN8@HeartOfLov
  0014c	83 7d e8 00	 cmp	 DWORD PTR _Option1$[ebp], 0
  00150	75 2b		 jne	 SHORT $LN10@HeartOfLov
$LN8@HeartOfLov:

; 1140 : 			{	// 둘중의 하나가 0이면 
; 1141 : 				if( (rand()%5) < 1 )

  00152	e8 00 00 00 00	 call	 _rand
  00157	99		 cdq
  00158	b9 05 00 00 00	 mov	 ecx, 5
  0015d	f7 f9		 idiv	 ecx
  0015f	83 fa 01	 cmp	 edx, 1
  00162	7d 09		 jge	 SHORT $LN9@HeartOfLov

; 1142 : 				{
; 1143 : 					Option3 = 3;

  00164	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 1144 : 				}

  0016b	eb 10		 jmp	 SHORT $LN10@HeartOfLov
$LN9@HeartOfLov:

; 1145 : 				else Option3 = (rand()%3);

  0016d	e8 00 00 00 00	 call	 _rand
  00172	99		 cdq
  00173	b9 03 00 00 00	 mov	 ecx, 3
  00178	f7 f9		 idiv	 ecx
  0017a	89 55 e0	 mov	 DWORD PTR _Option3$[ebp], edx
$LN10@HeartOfLov:

; 1146 : 			}
; 1147 : 
; 1148 : 			// 혼석, 축석, 영석은 레벨이 없게
; 1149 : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 1150 : 				(type == MAKE_ITEMNUM(14, 13)) ||

  0017d	6a 0f		 push	 15			; 0000000fH
  0017f	6a 0c		 push	 12			; 0000000cH
  00181	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00186	83 c4 08	 add	 esp, 8
  00189	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0018c	74 22		 je	 SHORT $LN12@HeartOfLov
  0018e	6a 0d		 push	 13			; 0000000dH
  00190	6a 0e		 push	 14			; 0000000eH
  00192	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00197	83 c4 08	 add	 esp, 8
  0019a	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0019d	74 11		 je	 SHORT $LN12@HeartOfLov
  0019f	6a 0e		 push	 14			; 0000000eH
  001a1	6a 0e		 push	 14			; 0000000eH
  001a3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001a8	83 c4 08	 add	 esp, 8
  001ab	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ae	75 1c		 jne	 SHORT $LN11@HeartOfLov
$LN12@HeartOfLov:

; 1151 : 				(type == MAKE_ITEMNUM(14, 14)) )				
; 1152 : 			{	
; 1153 : 				Option1 = 0; 

  001b0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1154 : 				Option2 = 0;

  001b7	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1155 : 				Option3 = 0;

  001be	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1156 : 				level   = 0;

  001c5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN11@HeartOfLov:

; 1157 : 			}
; 1158 : 			
; 1159 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 1160 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 1161 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 1162 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 1163 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 1164 : 				(type == MAKE_ITEMNUM(13, 12)) ||

  001cc	6a 00		 push	 0
  001ce	6a 0d		 push	 13			; 0000000dH
  001d0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001d5	83 c4 08	 add	 esp, 8
  001d8	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001db	74 66		 je	 SHORT $LN14@HeartOfLov
  001dd	6a 01		 push	 1
  001df	6a 0d		 push	 13			; 0000000dH
  001e1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e6	83 c4 08	 add	 esp, 8
  001e9	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ec	74 55		 je	 SHORT $LN14@HeartOfLov
  001ee	6a 02		 push	 2
  001f0	6a 0d		 push	 13			; 0000000dH
  001f2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f7	83 c4 08	 add	 esp, 8
  001fa	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001fd	74 44		 je	 SHORT $LN14@HeartOfLov
  001ff	6a 08		 push	 8
  00201	6a 0d		 push	 13			; 0000000dH
  00203	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00208	83 c4 08	 add	 esp, 8
  0020b	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0020e	74 33		 je	 SHORT $LN14@HeartOfLov
  00210	6a 09		 push	 9
  00212	6a 0d		 push	 13			; 0000000dH
  00214	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00219	83 c4 08	 add	 esp, 8
  0021c	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0021f	74 22		 je	 SHORT $LN14@HeartOfLov
  00221	6a 0c		 push	 12			; 0000000cH
  00223	6a 0d		 push	 13			; 0000000dH
  00225	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0022a	83 c4 08	 add	 esp, 8
  0022d	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00230	74 11		 je	 SHORT $LN14@HeartOfLov
  00232	6a 0d		 push	 13			; 0000000dH
  00234	6a 0d		 push	 13			; 0000000dH
  00236	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0023b	83 c4 08	 add	 esp, 8
  0023e	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00241	75 07		 jne	 SHORT $LN13@HeartOfLov
$LN14@HeartOfLov:

; 1165 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 1166 : 			{	// 반지류는 레벨 0
; 1167 : 				level   = 0;

  00243	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN13@HeartOfLov:

; 1168 : 			}
; 1169 : 
; 1170 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);

  0024a	6a 00		 push	 0
  0024c	6a 00		 push	 0
  0024e	6a 00		 push	 0
  00250	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00253	8b 08		 mov	 ecx, DWORD PTR [eax]
  00255	51		 push	 ecx
  00256	0f b6 55 e0	 movzx	 edx, BYTE PTR _Option3$[ebp]
  0025a	52		 push	 edx
  0025b	0f b6 45 e4	 movzx	 eax, BYTE PTR _Option2$[ebp]
  0025f	50		 push	 eax
  00260	0f b6 4d e8	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  00264	51		 push	 ecx
  00265	f3 0f 2c 55 fc	 cvttss2si edx, DWORD PTR _dur$[ebp]
  0026a	0f b6 c2	 movzx	 eax, dl
  0026d	50		 push	 eax
  0026e	0f b6 4d f4	 movzx	 ecx, BYTE PTR _level$[ebp]
  00272	51		 push	 ecx
  00273	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  00276	52		 push	 edx
  00277	0f b6 45 ec	 movzx	 eax, BYTE PTR _y$[ebp]
  0027b	50		 push	 eax
  0027c	0f b6 4d f0	 movzx	 ecx, BYTE PTR _x$[ebp]
  00280	51		 push	 ecx
  00281	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00284	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0028b	50		 push	 eax
  0028c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0028f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00291	52		 push	 edx
  00292	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00297	83 c4 38	 add	 esp, 56			; 00000038H

; 1171 : 
; 1172 : 			// 폭죽..
; 1173 : 			PMSG_SERVERCMD	ServerCmd;
; 1174 : 			PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  0029a	6a 07		 push	 7
  0029c	6a 40		 push	 64			; 00000040H
  0029e	68 f3 00 00 00	 push	 243			; 000000f3H
  002a3	8d 45 d4	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  002a6	50		 push	 eax
  002a7	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  002ac	83 c4 10	 add	 esp, 16			; 00000010H

; 1175 : 
; 1176 : 			ServerCmd.CmdType = 0;

  002af	c6 45 d8 00	 mov	 BYTE PTR _ServerCmd$1[ebp+4], 0

; 1177 : 			ServerCmd.X = x;

  002b3	8a 45 f0	 mov	 al, BYTE PTR _x$[ebp]
  002b6	88 45 d9	 mov	 BYTE PTR _ServerCmd$1[ebp+5], al

; 1178 : 			ServerCmd.Y = y;

  002b9	8a 45 ec	 mov	 al, BYTE PTR _y$[ebp]
  002bc	88 45 da	 mov	 BYTE PTR _ServerCmd$1[ebp+6], al

; 1179 : 			MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  002bf	6a 07		 push	 7
  002c1	8d 45 d4	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  002c4	50		 push	 eax
  002c5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c8	51		 push	 ecx
  002c9	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  002ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1180 : 			DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  002d1	6a 07		 push	 7
  002d3	8d 45 d4	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  002d6	50		 push	 eax
  002d7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002da	8b 11		 mov	 edx, DWORD PTR [ecx]
  002dc	52		 push	 edx
  002dd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1181 : 
; 1182 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 1183 : 			CItem EventItem;
; 1184 : 			EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 1185 : 
; 1186 : 			LogAddTD("[%s][%s][Lucky Box Item Drop][Heart Of Love] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 1187 : 				lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 1188 : 				EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 1189 : #else
; 1190 : 			LogAdd("FireCracker Event ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  002e5	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  002e8	50		 push	 eax
  002e9	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  002ec	51		 push	 ecx
  002ed	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  002f0	52		 push	 edx
  002f1	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  002f4	50		 push	 eax
  002f5	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  002f8	51		 push	 ecx
  002f9	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@CEAEOAKG@FireCracker?5Event?5ItemDrop?5?3?5It@
  002fe	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00304	83 c4 18	 add	 esp, 24			; 00000018H

; 1191 : #endif
; 1192 : 			return;

  00307	eb 42		 jmp	 SHORT $LN1@HeartOfLov
$LN4@HeartOfLov:

; 1193 : 		}
; 1194 : 	}
; 1195 : 	x    = lpObj->X;

  00309	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030c	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00313	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1196 : 	y    = lpObj->Y;	

  00316	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00319	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00320	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1197 : 	MapC[lpObj->MapNumber].MoneyItemDrop(1004, x ,y);	

  00323	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  00326	50		 push	 eax
  00327	8b 4d f0	 mov	 ecx, DWORD PTR _x$[ebp]
  0032a	51		 push	 ecx
  0032b	68 ec 03 00 00	 push	 1004			; 000003ecH
  00330	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00333	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0033a	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00340	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00346	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN1@HeartOfLov:

; 1198 : }

  0034b	5f		 pop	 edi
  0034c	5e		 pop	 esi
  0034d	5b		 pop	 ebx
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
?HeartOfLoveOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; HeartOfLoveOpenEven
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?FireCrackerOpenEven@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ServerCmd$1 = -52					; size = 7
_ServerCmd$2 = -44					; size = 7
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?FireCrackerOpenEven@@YAXPAVOBJECTSTRUCT@@@Z PROC	; FireCrackerOpenEven, COMDAT

; 1202 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1203 : 	float dur;
; 1204 : 	int type, level, x, y;
; 1205 : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1206 : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1207 : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1208 : 	int DropItemNum;
; 1209 : 
; 1210 : #ifdef MODIFY_DROP_ITEM_OF_FIRE_CRACKER_EVENT_20050316
; 1211 : 	if( gOnlyFireCrackerEffectUse )
; 1212 : 	{	// 폭죽 효과만 사용한다
; 1213 : 		PMSG_SERVERCMD	ServerCmd;
; 1214 : 		PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			
; 1215 : 
; 1216 : 		ServerCmd.CmdType = 0;
; 1217 : 		ServerCmd.X = (BYTE)lpObj->X;
; 1218 : 		ServerCmd.Y = (BYTE)lpObj->Y;
; 1219 : 		MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 1220 : 		DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 1221 : 		return;
; 1222 : 	}
; 1223 : 
; 1224 : 	if( gFireCrackerEvent )
; 1225 : 	{
; 1226 : 		if( !FireCrackerItemBag )
; 1227 : 			return;
; 1228 : 
; 1229 : 		if( FireCrackerItemBag->GetBagCount() > 0 )
; 1230 : 		{
; 1231 : 			// 2/10 의 확률로 이벤트용 아이템 증정
; 1232 : 			if( (rand()%10) < g_ItemDropRateForgFireCracker )
; 1233 : 			{
; 1234 : 				DropItemNum = (rand()%FireCrackerItemBag->GetBagCount());
; 1235 : 				dur  = 0;
; 1236 : 				x    = lpObj->X;
; 1237 : 				y    = lpObj->Y;			
; 1238 : 
; 1239 : 				// Option은 3-7까지 (ItemBag4에는 레벨 3으로 설정되어 있다
; 1240 : 				if( gLanguage == 0 )
; 1241 : 				{	// 한국은 레벨 5 - 7까지
; 1242 : 					level= FireCrackerItemBag->GetLevel(DropItemNum)+(rand()%2);
; 1243 : 				}
; 1244 : 				else
; 1245 : 				{
; 1246 : 					level= FireCrackerItemBag->GetLevel(DropItemNum)+(rand()%5);
; 1247 : 				}
; 1248 : 				
; 1249 : 				type = ItemGetNumberMake(FireCrackerItemBag->GetType(DropItemNum), FireCrackerItemBag->GetIndex(DropItemNum));
; 1250 : 				
; 1251 : 				Option1 = rand()%2;
; 1252 : 				Option2 = rand()%2;
; 1253 : 
; 1254 : 				if( !Option2 || !Option1 )
; 1255 : 				{	// 둘중의 하나가 0이면 
; 1256 : 					if( (rand()%5) < 1 )
; 1257 : 					{
; 1258 : 						Option3 = 3;
; 1259 : 					}
; 1260 : 					else Option3 = (rand()%3);
; 1261 : 				}
; 1262 : 
; 1263 : 				// 혼석, 축석, 영석은 레벨이 없게
; 1264 : 				if( (type == MAKE_ITEMNUM(12, 15)) ||
; 1265 : 					(type == MAKE_ITEMNUM(14, 13)) ||
; 1266 : 					(type == MAKE_ITEMNUM(14, 14)) )				
; 1267 : 				{	
; 1268 : 					Option1 = 0;
; 1269 : 					Option2 = 0;
; 1270 : 					Option3 = 0;
; 1271 : 					level   = 0;
; 1272 : 				}
; 1273 : 				
; 1274 : 				if( (type == MAKE_ITEMNUM(13, 0)) ||
; 1275 : 					(type == MAKE_ITEMNUM(13, 1)) ||				
; 1276 : 					(type == MAKE_ITEMNUM(13, 2)) ||
; 1277 : 					(type == MAKE_ITEMNUM(13, 8)) ||
; 1278 : 					(type == MAKE_ITEMNUM(13, 9)) ||
; 1279 : 					(type == MAKE_ITEMNUM(13, 12)) ||
; 1280 : 					(type == MAKE_ITEMNUM(13, 13)) )
; 1281 : 				{	// 반지류는 레벨 0
; 1282 : 					level = 0;
; 1283 : 				}
; 1284 : 
; 1285 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);
; 1286 : 
; 1287 : 				// 폭죽..
; 1288 : 				PMSG_SERVERCMD	ServerCmd;
; 1289 : 				PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			
; 1290 : 
; 1291 : 				ServerCmd.CmdType = 0;
; 1292 : 				ServerCmd.X = x;
; 1293 : 				ServerCmd.Y = y;
; 1294 : 				MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 1295 : 				DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 1296 : 
; 1297 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 1298 : 				CItem EventItem;
; 1299 : 				EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 1300 : 
; 1301 : 				LogAddTD("[%s][%s][Lucky Box Item Drop][Fire Cracker] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 1302 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 1303 : 					EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 1304 : #else
; 1305 : 				LogAdd("FireCracker Event ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );
; 1306 : #endif
; 1307 : 				return;
; 1308 : 			}
; 1309 : 		}
; 1310 : 	}
; 1311 : 
; 1312 : #else // else MODIFY_DROP_ITEM_OF_FIRE_CRACKER_EVENT_20050316
; 1313 : 	if( gOnlyFireCrackerEffectUse )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gOnlyFireCrackerEffectUse@@3HA, 0 ; gOnlyFireCrackerEffectUse
  00025	74 5c		 je	 SHORT $LN2@FireCracke

; 1314 : 	{	// 폭죽 효과만 사용한다
; 1315 : 		PMSG_SERVERCMD	ServerCmd;
; 1316 : 		PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  00027	6a 07		 push	 7
  00029	6a 40		 push	 64			; 00000040H
  0002b	68 f3 00 00 00	 push	 243			; 000000f3H
  00030	8d 45 d4	 lea	 eax, DWORD PTR _ServerCmd$2[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 1317 : 
; 1318 : 		ServerCmd.CmdType = 0;

  0003c	c6 45 d8 00	 mov	 BYTE PTR _ServerCmd$2[ebp+4], 0

; 1319 : 		ServerCmd.X = (BYTE)lpObj->X;

  00040	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00043	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00049	88 4d d9	 mov	 BYTE PTR _ServerCmd$2[ebp+5], cl

; 1320 : 		ServerCmd.Y = (BYTE)lpObj->Y;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004f	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00055	88 4d da	 mov	 BYTE PTR _ServerCmd$2[ebp+6], cl

; 1321 : 		MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00058	6a 07		 push	 7
  0005a	8d 45 d4	 lea	 eax, DWORD PTR _ServerCmd$2[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1322 : 		DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  0006a	6a 07		 push	 7
  0006c	8d 45 d4	 lea	 eax, DWORD PTR _ServerCmd$2[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00073	8b 11		 mov	 edx, DWORD PTR [ecx]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1323 : 		return;

  0007e	e9 2d 03 00 00	 jmp	 $LN1@FireCracke
$LN2@FireCracke:

; 1324 : 	}
; 1325 : 
; 1326 : 	if( !FireCrackerItemBag )

  00083	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?FireCrackerItemBag@@3PAVCItemBag@@A, 0 ; FireCrackerItemBag
  0008a	75 05		 jne	 SHORT $LN3@FireCracke

; 1327 : 		return;

  0008c	e9 1f 03 00 00	 jmp	 $LN1@FireCracke
$LN3@FireCracke:

; 1328 : 
; 1329 : 	if( FireCrackerItemBag->GetBagCount() > 0 )

  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?FireCrackerItemBag@@3PAVCItemBag@@A ; FireCrackerItemBag
  00097	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  0009c	85 c0		 test	 eax, eax
  0009e	0f 8e ca 02 00
	00		 jle	 $LN5@FireCracke

; 1330 : 	{
; 1331 : 		// 2/10 의 확률로 이벤트용 아이템 증정
; 1332 : 		if( (rand()%10) < g_ItemDropRateForgFireCracker )

  000a4	e8 00 00 00 00	 call	 _rand
  000a9	99		 cdq
  000aa	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000af	f7 f9		 idiv	 ecx
  000b1	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_ItemDropRateForgFireCracker@@3HA ; g_ItemDropRateForgFireCracker
  000b7	0f 8d b1 02 00
	00		 jge	 $LN5@FireCracke

; 1333 : 		{
; 1334 : 			DropItemNum = (rand()%FireCrackerItemBag->GetBagCount());

  000bd	e8 00 00 00 00	 call	 _rand
  000c2	8b f0		 mov	 esi, eax
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?FireCrackerItemBag@@3PAVCItemBag@@A ; FireCrackerItemBag
  000ca	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  000cf	8b c8		 mov	 ecx, eax
  000d1	8b c6		 mov	 eax, esi
  000d3	99		 cdq
  000d4	f7 f9		 idiv	 ecx
  000d6	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 1335 : 			dur  = 0;

  000d9	0f 57 c0	 xorps	 xmm0, xmm0
  000dc	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 1336 : 			x    = lpObj->X;

  000e1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e4	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000eb	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1337 : 			y    = lpObj->Y;			

  000ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f1	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000f8	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1338 : 
; 1339 : 			// Option은 3-7까지 (ItemBag4에는 레벨 3으로 설정되어 있다
; 1340 : 			if( gLanguage == 0 )

  000fb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLanguage@@3HA, 0 ; gLanguage
  00102	75 2a		 jne	 SHORT $LN6@FireCracke

; 1341 : 			{	// 한국은 레벨 5 - 7까지
; 1342 : 				level= FireCrackerItemBag->GetLevel(DropItemNum)+(rand()%2);

  00104	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00107	50		 push	 eax
  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?FireCrackerItemBag@@3PAVCItemBag@@A ; FireCrackerItemBag
  0010e	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  00113	0f b6 f0	 movzx	 esi, al
  00116	e8 00 00 00 00	 call	 _rand
  0011b	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00120	79 05		 jns	 SHORT $LN17@FireCracke
  00122	48		 dec	 eax
  00123	83 c8 fe	 or	 eax, -2			; fffffffeH
  00126	40		 inc	 eax
$LN17@FireCracke:
  00127	03 f0		 add	 esi, eax
  00129	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi

; 1343 : 			}

  0012c	eb 24		 jmp	 SHORT $LN7@FireCracke
$LN6@FireCracke:

; 1344 : 			else
; 1345 : 			{
; 1346 : 				level= FireCrackerItemBag->GetLevel(DropItemNum)+(rand()%5);

  0012e	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00131	50		 push	 eax
  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?FireCrackerItemBag@@3PAVCItemBag@@A ; FireCrackerItemBag
  00138	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  0013d	0f b6 f0	 movzx	 esi, al
  00140	e8 00 00 00 00	 call	 _rand
  00145	99		 cdq
  00146	b9 05 00 00 00	 mov	 ecx, 5
  0014b	f7 f9		 idiv	 ecx
  0014d	03 f2		 add	 esi, edx
  0014f	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi
$LN7@FireCracke:

; 1347 : 			}
; 1348 : 			
; 1349 : 			type = ItemGetNumberMake(FireCrackerItemBag->GetType(DropItemNum), FireCrackerItemBag->GetIndex(DropItemNum));

  00152	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00155	50		 push	 eax
  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?FireCrackerItemBag@@3PAVCItemBag@@A ; FireCrackerItemBag
  0015c	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  00161	0f b6 c8	 movzx	 ecx, al
  00164	51		 push	 ecx
  00165	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  00168	52		 push	 edx
  00169	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?FireCrackerItemBag@@3PAVCItemBag@@A ; FireCrackerItemBag
  0016f	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  00174	0f b6 c0	 movzx	 eax, al
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0017d	83 c4 08	 add	 esp, 8
  00180	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 1350 : 			
; 1351 : 			Option1 = rand()%2;

  00183	e8 00 00 00 00	 call	 _rand
  00188	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0018d	79 05		 jns	 SHORT $LN18@FireCracke
  0018f	48		 dec	 eax
  00190	83 c8 fe	 or	 eax, -2			; fffffffeH
  00193	40		 inc	 eax
$LN18@FireCracke:
  00194	89 45 e8	 mov	 DWORD PTR _Option1$[ebp], eax

; 1352 : 			Option2 = rand()%2;

  00197	e8 00 00 00 00	 call	 _rand
  0019c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001a1	79 05		 jns	 SHORT $LN19@FireCracke
  001a3	48		 dec	 eax
  001a4	83 c8 fe	 or	 eax, -2			; fffffffeH
  001a7	40		 inc	 eax
$LN19@FireCracke:
  001a8	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 1353 : 
; 1354 : 			if( !Option2 || !Option1 )

  001ab	83 7d e4 00	 cmp	 DWORD PTR _Option2$[ebp], 0
  001af	74 06		 je	 SHORT $LN9@FireCracke
  001b1	83 7d e8 00	 cmp	 DWORD PTR _Option1$[ebp], 0
  001b5	75 2b		 jne	 SHORT $LN11@FireCracke
$LN9@FireCracke:

; 1355 : 			{	// 둘중의 하나가 0이면 
; 1356 : 				if( (rand()%5) < 1 )

  001b7	e8 00 00 00 00	 call	 _rand
  001bc	99		 cdq
  001bd	b9 05 00 00 00	 mov	 ecx, 5
  001c2	f7 f9		 idiv	 ecx
  001c4	83 fa 01	 cmp	 edx, 1
  001c7	7d 09		 jge	 SHORT $LN10@FireCracke

; 1357 : 				{
; 1358 : 					Option3 = 3;

  001c9	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 1359 : 				}

  001d0	eb 10		 jmp	 SHORT $LN11@FireCracke
$LN10@FireCracke:

; 1360 : 				else Option3 = (rand()%3);

  001d2	e8 00 00 00 00	 call	 _rand
  001d7	99		 cdq
  001d8	b9 03 00 00 00	 mov	 ecx, 3
  001dd	f7 f9		 idiv	 ecx
  001df	89 55 e0	 mov	 DWORD PTR _Option3$[ebp], edx
$LN11@FireCracke:

; 1361 : 			}
; 1362 : 
; 1363 : 			// 혼석, 축석, 영석은 레벨이 없게
; 1364 : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 1365 : 				(type == MAKE_ITEMNUM(14, 13)) ||

  001e2	6a 0f		 push	 15			; 0000000fH
  001e4	6a 0c		 push	 12			; 0000000cH
  001e6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001eb	83 c4 08	 add	 esp, 8
  001ee	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001f1	74 22		 je	 SHORT $LN13@FireCracke
  001f3	6a 0d		 push	 13			; 0000000dH
  001f5	6a 0e		 push	 14			; 0000000eH
  001f7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001fc	83 c4 08	 add	 esp, 8
  001ff	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00202	74 11		 je	 SHORT $LN13@FireCracke
  00204	6a 0e		 push	 14			; 0000000eH
  00206	6a 0e		 push	 14			; 0000000eH
  00208	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0020d	83 c4 08	 add	 esp, 8
  00210	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00213	75 1c		 jne	 SHORT $LN12@FireCracke
$LN13@FireCracke:

; 1366 : 				(type == MAKE_ITEMNUM(14, 14)) )				
; 1367 : 			{	
; 1368 : 				Option1 = 0;

  00215	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 1369 : 				Option2 = 0;

  0021c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 1370 : 				Option3 = 0;

  00223	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 1371 : 				level   = 0;

  0022a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN12@FireCracke:

; 1372 : 			}
; 1373 : 			
; 1374 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 1375 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 1376 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 1377 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 1378 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 1379 : 				(type == MAKE_ITEMNUM(13, 12)) ||

  00231	6a 00		 push	 0
  00233	6a 0d		 push	 13			; 0000000dH
  00235	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0023a	83 c4 08	 add	 esp, 8
  0023d	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00240	74 66		 je	 SHORT $LN15@FireCracke
  00242	6a 01		 push	 1
  00244	6a 0d		 push	 13			; 0000000dH
  00246	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0024b	83 c4 08	 add	 esp, 8
  0024e	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00251	74 55		 je	 SHORT $LN15@FireCracke
  00253	6a 02		 push	 2
  00255	6a 0d		 push	 13			; 0000000dH
  00257	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0025c	83 c4 08	 add	 esp, 8
  0025f	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00262	74 44		 je	 SHORT $LN15@FireCracke
  00264	6a 08		 push	 8
  00266	6a 0d		 push	 13			; 0000000dH
  00268	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0026d	83 c4 08	 add	 esp, 8
  00270	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00273	74 33		 je	 SHORT $LN15@FireCracke
  00275	6a 09		 push	 9
  00277	6a 0d		 push	 13			; 0000000dH
  00279	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0027e	83 c4 08	 add	 esp, 8
  00281	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00284	74 22		 je	 SHORT $LN15@FireCracke
  00286	6a 0c		 push	 12			; 0000000cH
  00288	6a 0d		 push	 13			; 0000000dH
  0028a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0028f	83 c4 08	 add	 esp, 8
  00292	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00295	74 11		 je	 SHORT $LN15@FireCracke
  00297	6a 0d		 push	 13			; 0000000dH
  00299	6a 0d		 push	 13			; 0000000dH
  0029b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002a0	83 c4 08	 add	 esp, 8
  002a3	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  002a6	75 07		 jne	 SHORT $LN14@FireCracke
$LN15@FireCracke:

; 1380 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 1381 : 			{	// 반지류는 레벨 0
; 1382 : 				level   = 0;

  002a8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN14@FireCracke:

; 1383 : 			}
; 1384 : 
; 1385 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);

  002af	6a 00		 push	 0
  002b1	6a 00		 push	 0
  002b3	6a 00		 push	 0
  002b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ba	51		 push	 ecx
  002bb	0f b6 55 e0	 movzx	 edx, BYTE PTR _Option3$[ebp]
  002bf	52		 push	 edx
  002c0	0f b6 45 e4	 movzx	 eax, BYTE PTR _Option2$[ebp]
  002c4	50		 push	 eax
  002c5	0f b6 4d e8	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  002c9	51		 push	 ecx
  002ca	f3 0f 2c 55 fc	 cvttss2si edx, DWORD PTR _dur$[ebp]
  002cf	0f b6 c2	 movzx	 eax, dl
  002d2	50		 push	 eax
  002d3	0f b6 4d f4	 movzx	 ecx, BYTE PTR _level$[ebp]
  002d7	51		 push	 ecx
  002d8	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  002db	52		 push	 edx
  002dc	0f b6 45 ec	 movzx	 eax, BYTE PTR _y$[ebp]
  002e0	50		 push	 eax
  002e1	0f b6 4d f0	 movzx	 ecx, BYTE PTR _x$[ebp]
  002e5	51		 push	 ecx
  002e6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002e9	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  002f0	50		 push	 eax
  002f1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f6	52		 push	 edx
  002f7	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  002fc	83 c4 38	 add	 esp, 56			; 00000038H

; 1386 : 
; 1387 : 			// 폭죽..
; 1388 : 			PMSG_SERVERCMD	ServerCmd;
; 1389 : 			PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  002ff	6a 07		 push	 7
  00301	6a 40		 push	 64			; 00000040H
  00303	68 f3 00 00 00	 push	 243			; 000000f3H
  00308	8d 45 cc	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  0030b	50		 push	 eax
  0030c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00311	83 c4 10	 add	 esp, 16			; 00000010H

; 1390 : 
; 1391 : 			ServerCmd.CmdType = 0;

  00314	c6 45 d0 00	 mov	 BYTE PTR _ServerCmd$1[ebp+4], 0

; 1392 : 			ServerCmd.X = x;

  00318	8a 45 f0	 mov	 al, BYTE PTR _x$[ebp]
  0031b	88 45 d1	 mov	 BYTE PTR _ServerCmd$1[ebp+5], al

; 1393 : 			ServerCmd.Y = y;

  0031e	8a 45 ec	 mov	 al, BYTE PTR _y$[ebp]
  00321	88 45 d2	 mov	 BYTE PTR _ServerCmd$1[ebp+6], al

; 1394 : 			MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00324	6a 07		 push	 7
  00326	8d 45 cc	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  00329	50		 push	 eax
  0032a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0032d	51		 push	 ecx
  0032e	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00333	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1395 : 			DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00336	6a 07		 push	 7
  00338	8d 45 cc	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  0033b	50		 push	 eax
  0033c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0033f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00341	52		 push	 edx
  00342	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00347	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1396 : 
; 1397 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 1398 : 				CItem EventItem;
; 1399 : 				EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 1400 : 
; 1401 : 				LogAddTD("[%s][%s][Lucky Box Item Drop][Fire Cracker] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 1402 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 1403 : 					EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 1404 : #else
; 1405 : 				LogAdd("FireCracker Event ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  0034a	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  0034d	50		 push	 eax
  0034e	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  00351	51		 push	 ecx
  00352	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  00355	52		 push	 edx
  00356	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  00359	50		 push	 eax
  0035a	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  0035d	51		 push	 ecx
  0035e	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@CEAEOAKG@FireCracker?5Event?5ItemDrop?5?3?5It@
  00363	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00369	83 c4 18	 add	 esp, 24			; 00000018H

; 1406 : #endif
; 1407 : 			return;

  0036c	eb 42		 jmp	 SHORT $LN1@FireCracke
$LN5@FireCracke:

; 1408 : 		}
; 1409 : 	}
; 1410 : 	
; 1411 : #endif // MODIFY_DROP_ITEM_OF_FIRE_CRACKER_EVENT_20050316
; 1412 : 
; 1413 : 	x    = lpObj->X;

  0036e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00371	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00378	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 1414 : 	y    = lpObj->Y;	

  0037b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037e	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00385	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 1415 : 
; 1416 : #ifdef FOR_THAILAND
; 1417 : 	#ifdef EVENT_SONGKRAN_2005_20050316
; 1418 : 
; 1419 : 	if( HeartOfLoveItemBag->GetBagCount() > 0 )
; 1420 : 	{
; 1421 : 		// 2/20 의 확률로 이벤트용 아이템 증정
; 1422 : 		if( (rand()%20) < g_ItemDropRateForgHeartOfLove )
; 1423 : 		{
; 1424 : 			DropItemNum = (rand()%HeartOfLoveItemBag->GetBagCount());
; 1425 : 			dur  = 0;
; 1426 : 
; 1427 : 			// Option은 3-7까지 (ItemBag4에는 레벨 3으로 설정되어 있다
; 1428 : 			if( gLanguage == 0 )
; 1429 : 			{	// 한국은 레벨 5 - 7까지
; 1430 : 				level= HeartOfLoveItemBag->GetLevel(DropItemNum)+(rand()%2);
; 1431 : 			}
; 1432 : 			else
; 1433 : 			{
; 1434 : 				level= HeartOfLoveItemBag->GetLevel(DropItemNum)+(rand()%5);
; 1435 : 			}
; 1436 : 			
; 1437 : 			type = ItemGetNumberMake(HeartOfLoveItemBag->GetType(DropItemNum), HeartOfLoveItemBag->GetIndex(DropItemNum));
; 1438 : 			
; 1439 : 			Option1 = rand()%2;
; 1440 : 			Option2 = rand()%2;
; 1441 : 
; 1442 : 			if( !Option2 || !Option1 )
; 1443 : 			{	// 둘중의 하나가 0이면 
; 1444 : 				if( (rand()%5) < 1 )
; 1445 : 				{
; 1446 : 					Option3 = 3;
; 1447 : 				}
; 1448 : 				else Option3 = (rand()%3);
; 1449 : 			}
; 1450 : 
; 1451 : 			// 혼석, 축석, 영석은 레벨이 없게
; 1452 : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 1453 : 				(type == MAKE_ITEMNUM(14, 13)) ||
; 1454 : 				(type == MAKE_ITEMNUM(14, 14)) )				
; 1455 : 			{	
; 1456 : 				Option1 = 0; 
; 1457 : 				Option2 = 0;
; 1458 : 				Option3 = 0;
; 1459 : 				level   = 0;
; 1460 : 			}
; 1461 : 			
; 1462 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 1463 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 1464 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 1465 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 1466 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 1467 : 				(type == MAKE_ITEMNUM(13, 12)) ||
; 1468 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 1469 : 			{	// 반지류는 레벨 0
; 1470 : 				level   = 0;
; 1471 : 			}
; 1472 : 
; 1473 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);
; 1474 : 
; 1475 : 			// 폭죽..
; 1476 : 			PMSG_SERVERCMD	ServerCmd;
; 1477 : 			PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			
; 1478 : 
; 1479 : 			ServerCmd.CmdType = 0;
; 1480 : 			ServerCmd.X = x;
; 1481 : 			ServerCmd.Y = y;
; 1482 : 			MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 1483 : 			DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 1484 : 
; 1485 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 1486 : 				CItem EventItem;
; 1487 : 				EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 1488 : 
; 1489 : 				LogAddTD("[%s][%s][Lucky Box Item Drop][Fire Cracker] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 1490 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 1491 : 					EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 1492 : #else
; 1493 : 				LogAdd("FireCracker Event ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );
; 1494 : #endif
; 1495 : 			return;
; 1496 : 		}
; 1497 : 	}
; 1498 : 	
; 1499 : 	// 젠만 드롭하는 경우
; 1500 : 
; 1501 : 	// 폭죽..
; 1502 : 	PMSG_SERVERCMD	ServerCmd;
; 1503 : 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));
; 1504 : 
; 1505 : 	ServerCmd.CmdType = 0;
; 1506 : 	ServerCmd.X = (BYTE)lpObj->X;
; 1507 : 	ServerCmd.Y = (BYTE)lpObj->Y;
; 1508 : 	MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 1509 : 	DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));
; 1510 : 
; 1511 : 	MapC[lpObj->MapNumber].MoneyItemDrop(2548, x ,y);
; 1512 : 	
; 1513 : 	#else // else EVENT_SONGKRAN_2005_20050316
; 1514 : 		MapC[lpObj->MapNumber].MoneyItemDrop(50000, x ,y);
; 1515 : 	
; 1516 : 	#endif // EVENT_SONGKRAN_2005_20050316
; 1517 : 
; 1518 : #else // else FOR_THAILAND
; 1519 : 
; 1520 : 	MapC[lpObj->MapNumber].MoneyItemDrop(2004, x ,y);

  00388	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  0038b	50		 push	 eax
  0038c	8b 4d f0	 mov	 ecx, DWORD PTR _x$[ebp]
  0038f	51		 push	 ecx
  00390	68 d4 07 00 00	 push	 2004			; 000007d4H
  00395	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00398	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0039f	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  003a5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  003ab	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN1@FireCracke:

; 1521 : 
; 1522 : #endif // FOR_THAILAND
; 1523 : }

  003b0	5f		 pop	 edi
  003b1	5e		 pop	 esi
  003b2	5b		 pop	 ebx
  003b3	8b e5		 mov	 esp, ebp
  003b5	5d		 pop	 ebp
  003b6	c3		 ret	 0
?FireCrackerOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; FireCrackerOpenEven
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?StarOfXMasOpenEven@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?StarOfXMasOpenEven@@YAXPAVOBJECTSTRUCT@@@Z PROC	; StarOfXMasOpenEven, COMDAT

; 1528 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1529 : 
; 1530 : #ifdef EVENT_ITEMBAG_UPGRADE
; 1531 : 	StarOfXMasItemBag->DropItem(lpObj->m_Index);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?StarOfXMasItemBag@@3PAVCItemBagEx@@A ; StarOfXMasItemBag
  00015	e8 00 00 00 00	 call	 ?DropItem@CItemBagEx@@QAEHH@Z ; CItemBagEx::DropItem

; 1532 : 
; 1533 : #else // else EVENT_ITEMBAG_UPGRADE
; 1534 : 	float dur;
; 1535 : 	int type, level, x, y;
; 1536 : 	int Option1 = 0;
; 1537 : 	int Option2 = 0;
; 1538 : 	int Option3 = 0;
; 1539 : 	int DropItemNum;
; 1540 : 
; 1541 : 	if( !StarOfXMasItemBag )
; 1542 : 		return;
; 1543 : 
; 1544 : 	if( StarOfXMasItemBag->GetBagCount() > 0 )
; 1545 : 	{
; 1546 : 		// 2/10 의 확률로 이벤트용 아이템 증정
; 1547 : 		if( (rand()%10) < g_XMasEvent_ItemDropRateForStarOfXMas )
; 1548 : 		{
; 1549 : 			DropItemNum = (rand()%StarOfXMasItemBag->GetBagCount());
; 1550 : 			dur  = 0;
; 1551 : 			x    = lpObj->X;
; 1552 : 			y    = lpObj->Y;			
; 1553 : 
; 1554 : 			// Option은 3-7까지 (ItemBag4에는 레벨 3으로 설정되어 있다
; 1555 : 	#ifdef FOR_CHINA
; 1556 : 			if( rand()%100 < 2 )
; 1557 : 			{
; 1558 : 				level= 8;
; 1559 : 			}
; 1560 : 			else
; 1561 : 			{
; 1562 : 				level= StarOfXMasItemBag->GetLevel(DropItemNum)+(rand()%5);
; 1563 : 			}
; 1564 : 	#else // else FOR_CHINA
; 1565 : 			level= StarOfXMasItemBag->GetLevel(DropItemNum)+(rand()%5);
; 1566 : 	#endif // FOR_CHINA
; 1567 : 			
; 1568 : 			type = ItemGetNumberMake(StarOfXMasItemBag->GetType(DropItemNum), StarOfXMasItemBag->GetIndex(DropItemNum));
; 1569 : 			
; 1570 : 			Option1 = rand()%2;
; 1571 : 			Option2 = rand()%2;
; 1572 : 
; 1573 : 			if( (rand()%5) < 1 )
; 1574 : 			{
; 1575 : 				Option3 = 3;
; 1576 : 			}
; 1577 : 			else Option3 = (rand()%3);
; 1578 : 
; 1579 : 			// 혼석, 축석, 영석은 레벨이 없게
; 1580 : 			if( (type == MAKE_ITEMNUM(12, 15)) ||
; 1581 : 				(type == MAKE_ITEMNUM(14, 13)) ||
; 1582 : 				(type == MAKE_ITEMNUM(14, 14)) )
; 1583 : 			{	
; 1584 : 				Option1 = 0; 
; 1585 : 				Option2 = 0;
; 1586 : 				Option3 = 0;
; 1587 : 				level   = 0;
; 1588 : 			}
; 1589 : 
; 1590 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 1591 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 1592 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 1593 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 1594 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 1595 : 				(type == MAKE_ITEMNUM(13, 12)) ||
; 1596 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 1597 : 			{	// 반지류는 레벨 0
; 1598 : 				level   = 0;
; 1599 : 			}
; 1600 : 
; 1601 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);
; 1602 : 
; 1603 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 1604 : 			CItem EventItem;
; 1605 : 			EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 1606 : 
; 1607 : 			LogAddTD("[%s][%s][Lucky Box Item Drop][Star Of XMas] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 1608 : 				lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 1609 : 				EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 1610 : #else
; 1611 : 			LogAdd("XMas Event ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );
; 1612 : #endif
; 1613 : 			return;
; 1614 : 		}
; 1615 : 	}
; 1616 : 	x    = lpObj->X;
; 1617 : 	y    = lpObj->Y;	
; 1618 : 	MapC[lpObj->MapNumber].MoneyItemDrop(1225, x ,y);	
; 1619 : #endif // EVENT_ITEMBAG_UPGRADE
; 1620 : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?StarOfXMasOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; StarOfXMasOpenEven
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?AttackEvent55BagOpen@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv136 = -116						; size = 4
_MaxHitUser$1 = -48					; size = 4
_optionc$2 = -44					; size = 4
_optionrand$3 = -40					; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?AttackEvent55BagOpen@@YAHPAVOBJECTSTRUCT@@@Z PROC	; AttackEvent55BagOpen, COMDAT

; 2474 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2475 : 	float dur;
; 2476 : 	int type, level, x, y;
; 2477 : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 2478 : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 2479 : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 2480 : 	int DropItemNum;
; 2481 : 
; 2482 : 	if( !Mon55 )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?Mon55@@3PAVCItemBag@@A, 0 ; Mon55
  00025	75 07		 jne	 SHORT $LN4@AttackEven

; 2483 : 		return FALSE;

  00027	33 c0		 xor	 eax, eax
  00029	e9 96 02 00 00	 jmp	 $LN1@AttackEven
$LN4@AttackEven:

; 2484 : 
; 2485 : 	if( Mon55->GetBagCount() > 0 )

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon55@@3PAVCItemBag@@A ; Mon55
  00034	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00039	85 c0		 test	 eax, eax
  0003b	0f 8e 81 02 00
	00		 jle	 $LN5@AttackEven

; 2486 : 	{
; 2487 : 		// 2/10 의 확률로 이벤트용 아이템 증정
; 2488 : 		//if( (rand()%10) < 2 )
; 2489 : 		{
; 2490 : 			DropItemNum = (rand()%Mon55->GetBagCount());

  00041	e8 00 00 00 00	 call	 _rand
  00046	8b f0		 mov	 esi, eax
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon55@@3PAVCItemBag@@A ; Mon55
  0004e	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00053	8b c8		 mov	 ecx, eax
  00055	8b c6		 mov	 eax, esi
  00057	99		 cdq
  00058	f7 f9		 idiv	 ecx
  0005a	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 2491 : 			dur  = 0;

  0005d	0f 57 c0	 xorps	 xmm0, xmm0
  00060	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 2492 : 			x    = lpObj->X;

  00065	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00068	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0006f	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 2493 : 			y    = lpObj->Y;

  00072	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00075	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0007c	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 2494 : 
; 2495 : 			level= Mon55->GetLevel(DropItemNum)+(rand()%2);

  0007f	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00082	50		 push	 eax
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon55@@3PAVCItemBag@@A ; Mon55
  00089	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  0008e	0f b6 f0	 movzx	 esi, al
  00091	e8 00 00 00 00	 call	 _rand
  00096	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0009b	79 05		 jns	 SHORT $LN19@AttackEven
  0009d	48		 dec	 eax
  0009e	83 c8 fe	 or	 eax, -2			; fffffffeH
  000a1	40		 inc	 eax
$LN19@AttackEven:
  000a2	03 f0		 add	 esi, eax
  000a4	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi

; 2496 : 			type = ItemGetNumberMake(Mon55->GetType(DropItemNum), Mon55->GetIndex(DropItemNum));

  000a7	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000aa	50		 push	 eax
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon55@@3PAVCItemBag@@A ; Mon55
  000b1	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  000b6	0f b6 c8	 movzx	 ecx, al
  000b9	51		 push	 ecx
  000ba	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  000bd	52		 push	 edx
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon55@@3PAVCItemBag@@A ; Mon55
  000c4	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  000c9	0f b6 c0	 movzx	 eax, al
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000d2	83 c4 08	 add	 esp, 8
  000d5	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 2497 : 			
; 2498 : 			if((rand()%100) < 6 ) Option1 = 1;

  000d8	e8 00 00 00 00	 call	 _rand
  000dd	99		 cdq
  000de	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000e3	f7 f9		 idiv	 ecx
  000e5	83 fa 06	 cmp	 edx, 6
  000e8	7d 07		 jge	 SHORT $LN6@AttackEven
  000ea	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1
$LN6@AttackEven:

; 2499 : 			if((rand()%100) < 4 ) Option2 = 1;

  000f1	e8 00 00 00 00	 call	 _rand
  000f6	99		 cdq
  000f7	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000fc	f7 f9		 idiv	 ecx
  000fe	83 fa 04	 cmp	 edx, 4
  00101	7d 07		 jge	 SHORT $LN7@AttackEven
  00103	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN7@AttackEven:

; 2500 : 
; 2501 : 			int optionrand, optionc;
; 2502 : 
; 2503 : 			optionc = (rand()%3);

  0010a	e8 00 00 00 00	 call	 _rand
  0010f	99		 cdq
  00110	b9 03 00 00 00	 mov	 ecx, 3
  00115	f7 f9		 idiv	 ecx
  00117	89 55 d4	 mov	 DWORD PTR _optionc$2[ebp], edx

; 2504 : 			optionrand = (rand()%100);

  0011a	e8 00 00 00 00	 call	 _rand
  0011f	99		 cdq
  00120	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00125	f7 f9		 idiv	 ecx
  00127	89 55 d8	 mov	 DWORD PTR _optionrand$3[ebp], edx

; 2505 : 			
; 2506 : 			switch( optionc )

  0012a	8b 45 d4	 mov	 eax, DWORD PTR _optionc$2[ebp]
  0012d	89 45 8c	 mov	 DWORD PTR tv136[ebp], eax
  00130	83 7d 8c 00	 cmp	 DWORD PTR tv136[ebp], 0
  00134	74 0e		 je	 SHORT $LN8@AttackEven
  00136	83 7d 8c 01	 cmp	 DWORD PTR tv136[ebp], 1
  0013a	74 17		 je	 SHORT $LN10@AttackEven
  0013c	83 7d 8c 02	 cmp	 DWORD PTR tv136[ebp], 2
  00140	74 20		 je	 SHORT $LN12@AttackEven
  00142	eb 2b		 jmp	 SHORT $LN2@AttackEven
$LN8@AttackEven:

; 2507 : 			{
; 2508 : 			case 0 :
; 2509 : 				if( optionrand < 4 ) Option3 = 3;	// 옵션

  00144	83 7d d8 04	 cmp	 DWORD PTR _optionrand$3[ebp], 4
  00148	7d 07		 jge	 SHORT $LN9@AttackEven
  0014a	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3
$LN9@AttackEven:

; 2510 : 				break;

  00151	eb 1c		 jmp	 SHORT $LN2@AttackEven
$LN10@AttackEven:

; 2511 : 			case 1 :
; 2512 : 				if( optionrand < 8 ) Option3 = 2;	// 옵션

  00153	83 7d d8 08	 cmp	 DWORD PTR _optionrand$3[ebp], 8
  00157	7d 07		 jge	 SHORT $LN11@AttackEven
  00159	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 2
$LN11@AttackEven:

; 2513 : 				break;

  00160	eb 0d		 jmp	 SHORT $LN2@AttackEven
$LN12@AttackEven:

; 2514 : 			case 2 :
; 2515 : 				if( optionrand < 12 ) Option3 = 1;	// 옵션

  00162	83 7d d8 0c	 cmp	 DWORD PTR _optionrand$3[ebp], 12 ; 0000000cH
  00166	7d 07		 jge	 SHORT $LN13@AttackEven
  00168	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 1
$LN13@AttackEven:
$LN2@AttackEven:

; 2516 : 				break;
; 2517 : 			}
; 2518 : 
; 2519 : 
; 2520 : 			// 혼석, 축석, 영석은 레벨이 없게
; 2521 : 			if( (type == MAKE_ITEMNUM(12,15)) ||
; 2522 : 				(type == MAKE_ITEMNUM(14,13)) ||

  0016f	6a 0f		 push	 15			; 0000000fH
  00171	6a 0c		 push	 12			; 0000000cH
  00173	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00178	83 c4 08	 add	 esp, 8
  0017b	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0017e	74 22		 je	 SHORT $LN15@AttackEven
  00180	6a 0d		 push	 13			; 0000000dH
  00182	6a 0e		 push	 14			; 0000000eH
  00184	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00189	83 c4 08	 add	 esp, 8
  0018c	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0018f	74 11		 je	 SHORT $LN15@AttackEven
  00191	6a 0e		 push	 14			; 0000000eH
  00193	6a 0e		 push	 14			; 0000000eH
  00195	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0019a	83 c4 08	 add	 esp, 8
  0019d	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001a0	75 1c		 jne	 SHORT $LN14@AttackEven
$LN15@AttackEven:

; 2523 : 				(type == MAKE_ITEMNUM(14,14)) )
; 2524 : 			{	
; 2525 : 				Option1 = 0; 

  001a2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 2526 : 				Option2 = 0;

  001a9	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 2527 : 				Option3 = 0;

  001b0	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 2528 : 				level   = 0;

  001b7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN14@AttackEven:

; 2529 : 			}
; 2530 : 
; 2531 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 2532 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 2533 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 2534 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 2535 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 2536 : 				(type == MAKE_ITEMNUM(13, 12)) ||

  001be	6a 00		 push	 0
  001c0	6a 0d		 push	 13			; 0000000dH
  001c2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001c7	83 c4 08	 add	 esp, 8
  001ca	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001cd	74 66		 je	 SHORT $LN17@AttackEven
  001cf	6a 01		 push	 1
  001d1	6a 0d		 push	 13			; 0000000dH
  001d3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001d8	83 c4 08	 add	 esp, 8
  001db	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001de	74 55		 je	 SHORT $LN17@AttackEven
  001e0	6a 02		 push	 2
  001e2	6a 0d		 push	 13			; 0000000dH
  001e4	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e9	83 c4 08	 add	 esp, 8
  001ec	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ef	74 44		 je	 SHORT $LN17@AttackEven
  001f1	6a 08		 push	 8
  001f3	6a 0d		 push	 13			; 0000000dH
  001f5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001fa	83 c4 08	 add	 esp, 8
  001fd	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00200	74 33		 je	 SHORT $LN17@AttackEven
  00202	6a 09		 push	 9
  00204	6a 0d		 push	 13			; 0000000dH
  00206	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0020b	83 c4 08	 add	 esp, 8
  0020e	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00211	74 22		 je	 SHORT $LN17@AttackEven
  00213	6a 0c		 push	 12			; 0000000cH
  00215	6a 0d		 push	 13			; 0000000dH
  00217	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0021c	83 c4 08	 add	 esp, 8
  0021f	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00222	74 11		 je	 SHORT $LN17@AttackEven
  00224	6a 0d		 push	 13			; 0000000dH
  00226	6a 0d		 push	 13			; 0000000dH
  00228	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0022d	83 c4 08	 add	 esp, 8
  00230	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00233	75 07		 jne	 SHORT $LN16@AttackEven
$LN17@AttackEven:

; 2537 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 2538 : 			{	// 반지류는 레벨 0
; 2539 : 				level   = 0;

  00235	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN16@AttackEven:

; 2540 : 			}
; 2541 : 
; 2542 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0023c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00245	83 c4 04	 add	 esp, 4
  00248	89 45 d0	 mov	 DWORD PTR _MaxHitUser$1[ebp], eax

; 2543 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  0024b	6a 00		 push	 0
  0024d	6a 00		 push	 0
  0024f	6a 00		 push	 0
  00251	8b 45 d0	 mov	 eax, DWORD PTR _MaxHitUser$1[ebp]
  00254	50		 push	 eax
  00255	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00259	51		 push	 ecx
  0025a	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  0025e	52		 push	 edx
  0025f	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00263	50		 push	 eax
  00264	f3 0f 2c 4d fc	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00269	0f b6 d1	 movzx	 edx, cl
  0026c	52		 push	 edx
  0026d	0f b6 45 f4	 movzx	 eax, BYTE PTR _level$[ebp]
  00271	50		 push	 eax
  00272	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00275	51		 push	 ecx
  00276	0f b6 55 ec	 movzx	 edx, BYTE PTR _y$[ebp]
  0027a	52		 push	 edx
  0027b	0f b6 45 f0	 movzx	 eax, BYTE PTR _x$[ebp]
  0027f	50		 push	 eax
  00280	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00283	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0028a	52		 push	 edx
  0028b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00290	51		 push	 ecx
  00291	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00296	83 c4 38	 add	 esp, 56			; 00000038H

; 2544 : 			LogAdd("Event ItemDrop(55) : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  00299	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  0029c	50		 push	 eax
  0029d	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  002a0	51		 push	 ecx
  002a1	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  002a4	52		 push	 edx
  002a5	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  002a8	50		 push	 eax
  002a9	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  002ac	51		 push	 ecx
  002ad	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@OLPGIACC@Event?5ItemDrop?$CI55?$CJ?5?3?5Item?3?$CFd?5Le@
  002b2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002b8	83 c4 18	 add	 esp, 24			; 00000018H

; 2545 : 			return TRUE;

  002bb	b8 01 00 00 00	 mov	 eax, 1
  002c0	eb 02		 jmp	 SHORT $LN1@AttackEven
$LN5@AttackEven:

; 2546 : 		}
; 2547 : 	}
; 2548 : 	//LogAdd("가방에서 주기 실패 %d", Mon55->GetBagCount());
; 2549 : 	return FALSE;

  002c2	33 c0		 xor	 eax, eax
$LN1@AttackEven:

; 2550 : }

  002c4	5f		 pop	 edi
  002c5	5e		 pop	 esi
  002c6	5b		 pop	 ebx
  002c7	8b e5		 mov	 esp, ebp
  002c9	5d		 pop	 ebp
  002ca	c3		 ret	 0
?AttackEvent55BagOpen@@YAHPAVOBJECTSTRUCT@@@Z ENDP	; AttackEvent55BagOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?AttackEvent53BagOpen@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv133 = -116						; size = 4
_MaxHitUser$1 = -48					; size = 4
_optionc$2 = -44					; size = 4
_optionrand$3 = -40					; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?AttackEvent53BagOpen@@YAHPAVOBJECTSTRUCT@@@Z PROC	; AttackEvent53BagOpen, COMDAT

; 2396 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2397 : 	float dur;
; 2398 : 	int type, level, x, y;
; 2399 : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 2400 : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 2401 : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 2402 : 	int DropItemNum;
; 2403 : 
; 2404 : 	if( !Mon53 )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?Mon53@@3PAVCItemBag@@A, 0 ; Mon53
  00025	75 07		 jne	 SHORT $LN4@AttackEven

; 2405 : 		return FALSE;

  00027	33 c0		 xor	 eax, eax
  00029	e9 83 02 00 00	 jmp	 $LN1@AttackEven
$LN4@AttackEven:

; 2406 : 
; 2407 : 	if( Mon53->GetBagCount() > 0 )

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon53@@3PAVCItemBag@@A ; Mon53
  00034	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00039	85 c0		 test	 eax, eax
  0003b	0f 8e 6e 02 00
	00		 jle	 $LN5@AttackEven

; 2408 : 	{
; 2409 : 		// 2/10 의 확률로 이벤트용 아이템 증정
; 2410 : 		//if( (rand()%10) < 2 )
; 2411 : 		{
; 2412 : 			DropItemNum = (rand()%Mon53->GetBagCount());

  00041	e8 00 00 00 00	 call	 _rand
  00046	8b f0		 mov	 esi, eax
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon53@@3PAVCItemBag@@A ; Mon53
  0004e	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00053	8b c8		 mov	 ecx, eax
  00055	8b c6		 mov	 eax, esi
  00057	99		 cdq
  00058	f7 f9		 idiv	 ecx
  0005a	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 2413 : 			dur  = 0;

  0005d	0f 57 c0	 xorps	 xmm0, xmm0
  00060	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 2414 : 			x    = lpObj->X;

  00065	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00068	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0006f	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 2415 : 			y    = lpObj->Y;

  00072	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00075	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0007c	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 2416 : 
; 2417 : 			level= Mon53->GetLevel(DropItemNum);

  0007f	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00082	50		 push	 eax
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon53@@3PAVCItemBag@@A ; Mon53
  00089	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  0008e	0f b6 c8	 movzx	 ecx, al
  00091	89 4d f4	 mov	 DWORD PTR _level$[ebp], ecx

; 2418 : 			type = ItemGetNumberMake(Mon53->GetType(DropItemNum), Mon53->GetIndex(DropItemNum));

  00094	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00097	50		 push	 eax
  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon53@@3PAVCItemBag@@A ; Mon53
  0009e	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  000a3	0f b6 c8	 movzx	 ecx, al
  000a6	51		 push	 ecx
  000a7	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  000aa	52		 push	 edx
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?Mon53@@3PAVCItemBag@@A ; Mon53
  000b1	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  000b6	0f b6 c0	 movzx	 eax, al
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000bf	83 c4 08	 add	 esp, 8
  000c2	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 2419 : 			
; 2420 : 			if((rand()%100) < 6 ) Option1 = 1;

  000c5	e8 00 00 00 00	 call	 _rand
  000ca	99		 cdq
  000cb	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000d0	f7 f9		 idiv	 ecx
  000d2	83 fa 06	 cmp	 edx, 6
  000d5	7d 07		 jge	 SHORT $LN6@AttackEven
  000d7	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1
$LN6@AttackEven:

; 2421 : 			if((rand()%100) < 4 ) Option2 = 1;

  000de	e8 00 00 00 00	 call	 _rand
  000e3	99		 cdq
  000e4	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000e9	f7 f9		 idiv	 ecx
  000eb	83 fa 04	 cmp	 edx, 4
  000ee	7d 07		 jge	 SHORT $LN7@AttackEven
  000f0	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN7@AttackEven:

; 2422 : 
; 2423 : 			int optionrand, optionc;
; 2424 : 
; 2425 : 			optionc = (rand()%3);

  000f7	e8 00 00 00 00	 call	 _rand
  000fc	99		 cdq
  000fd	b9 03 00 00 00	 mov	 ecx, 3
  00102	f7 f9		 idiv	 ecx
  00104	89 55 d4	 mov	 DWORD PTR _optionc$2[ebp], edx

; 2426 : 			optionrand = (rand()%100);

  00107	e8 00 00 00 00	 call	 _rand
  0010c	99		 cdq
  0010d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00112	f7 f9		 idiv	 ecx
  00114	89 55 d8	 mov	 DWORD PTR _optionrand$3[ebp], edx

; 2427 : 			
; 2428 : 			switch( optionc )

  00117	8b 45 d4	 mov	 eax, DWORD PTR _optionc$2[ebp]
  0011a	89 45 8c	 mov	 DWORD PTR tv133[ebp], eax
  0011d	83 7d 8c 00	 cmp	 DWORD PTR tv133[ebp], 0
  00121	74 0e		 je	 SHORT $LN8@AttackEven
  00123	83 7d 8c 01	 cmp	 DWORD PTR tv133[ebp], 1
  00127	74 17		 je	 SHORT $LN10@AttackEven
  00129	83 7d 8c 02	 cmp	 DWORD PTR tv133[ebp], 2
  0012d	74 20		 je	 SHORT $LN12@AttackEven
  0012f	eb 2b		 jmp	 SHORT $LN2@AttackEven
$LN8@AttackEven:

; 2429 : 			{
; 2430 : 			case 0 :
; 2431 : 				if( optionrand < 4 ) Option3 = 3;	// 옵션

  00131	83 7d d8 04	 cmp	 DWORD PTR _optionrand$3[ebp], 4
  00135	7d 07		 jge	 SHORT $LN9@AttackEven
  00137	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3
$LN9@AttackEven:

; 2432 : 				break;

  0013e	eb 1c		 jmp	 SHORT $LN2@AttackEven
$LN10@AttackEven:

; 2433 : 			case 1 :
; 2434 : 				if( optionrand < 8 ) Option3 = 2;	// 옵션

  00140	83 7d d8 08	 cmp	 DWORD PTR _optionrand$3[ebp], 8
  00144	7d 07		 jge	 SHORT $LN11@AttackEven
  00146	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 2
$LN11@AttackEven:

; 2435 : 				break;

  0014d	eb 0d		 jmp	 SHORT $LN2@AttackEven
$LN12@AttackEven:

; 2436 : 			case 2 :
; 2437 : 				if( optionrand < 12 ) Option3 = 1;	// 옵션

  0014f	83 7d d8 0c	 cmp	 DWORD PTR _optionrand$3[ebp], 12 ; 0000000cH
  00153	7d 07		 jge	 SHORT $LN13@AttackEven
  00155	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 1
$LN13@AttackEven:
$LN2@AttackEven:

; 2438 : 				break;
; 2439 : 			}
; 2440 : 			// 혼석, 축석, 영석은 레벨이 없게
; 2441 : 			if( (type == MAKE_ITEMNUM(12,15)) ||
; 2442 : 				(type == MAKE_ITEMNUM(14,13)) ||

  0015c	6a 0f		 push	 15			; 0000000fH
  0015e	6a 0c		 push	 12			; 0000000cH
  00160	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00165	83 c4 08	 add	 esp, 8
  00168	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0016b	74 22		 je	 SHORT $LN15@AttackEven
  0016d	6a 0d		 push	 13			; 0000000dH
  0016f	6a 0e		 push	 14			; 0000000eH
  00171	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00176	83 c4 08	 add	 esp, 8
  00179	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0017c	74 11		 je	 SHORT $LN15@AttackEven
  0017e	6a 0e		 push	 14			; 0000000eH
  00180	6a 0e		 push	 14			; 0000000eH
  00182	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00187	83 c4 08	 add	 esp, 8
  0018a	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0018d	75 1c		 jne	 SHORT $LN14@AttackEven
$LN15@AttackEven:

; 2443 : 				(type == MAKE_ITEMNUM(14,14)) )
; 2444 : 			{	
; 2445 : 				Option1 = 0; 

  0018f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 2446 : 				Option2 = 0;

  00196	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 2447 : 				Option3 = 0;

  0019d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 2448 : 				level   = 0;

  001a4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN14@AttackEven:

; 2449 : 			}
; 2450 : 			
; 2451 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 2452 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 2453 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 2454 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 2455 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 2456 : 				(type == MAKE_ITEMNUM(13, 12)) ||

  001ab	6a 00		 push	 0
  001ad	6a 0d		 push	 13			; 0000000dH
  001af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001b4	83 c4 08	 add	 esp, 8
  001b7	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ba	74 66		 je	 SHORT $LN17@AttackEven
  001bc	6a 01		 push	 1
  001be	6a 0d		 push	 13			; 0000000dH
  001c0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001c5	83 c4 08	 add	 esp, 8
  001c8	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001cb	74 55		 je	 SHORT $LN17@AttackEven
  001cd	6a 02		 push	 2
  001cf	6a 0d		 push	 13			; 0000000dH
  001d1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001d6	83 c4 08	 add	 esp, 8
  001d9	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001dc	74 44		 je	 SHORT $LN17@AttackEven
  001de	6a 08		 push	 8
  001e0	6a 0d		 push	 13			; 0000000dH
  001e2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e7	83 c4 08	 add	 esp, 8
  001ea	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001ed	74 33		 je	 SHORT $LN17@AttackEven
  001ef	6a 09		 push	 9
  001f1	6a 0d		 push	 13			; 0000000dH
  001f3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f8	83 c4 08	 add	 esp, 8
  001fb	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001fe	74 22		 je	 SHORT $LN17@AttackEven
  00200	6a 0c		 push	 12			; 0000000cH
  00202	6a 0d		 push	 13			; 0000000dH
  00204	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00209	83 c4 08	 add	 esp, 8
  0020c	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0020f	74 11		 je	 SHORT $LN17@AttackEven
  00211	6a 0d		 push	 13			; 0000000dH
  00213	6a 0d		 push	 13			; 0000000dH
  00215	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0021a	83 c4 08	 add	 esp, 8
  0021d	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00220	75 07		 jne	 SHORT $LN16@AttackEven
$LN17@AttackEven:

; 2457 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 2458 : 			{	// 반지류는 레벨 0
; 2459 : 				level   = 0;

  00222	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN16@AttackEven:

; 2460 : 			}
; 2461 : 			
; 2462 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00229	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00232	83 c4 04	 add	 esp, 4
  00235	89 45 d0	 mov	 DWORD PTR _MaxHitUser$1[ebp], eax

; 2463 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00238	6a 00		 push	 0
  0023a	6a 00		 push	 0
  0023c	6a 00		 push	 0
  0023e	8b 45 d0	 mov	 eax, DWORD PTR _MaxHitUser$1[ebp]
  00241	50		 push	 eax
  00242	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00246	51		 push	 ecx
  00247	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  0024b	52		 push	 edx
  0024c	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00250	50		 push	 eax
  00251	f3 0f 2c 4d fc	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00256	0f b6 d1	 movzx	 edx, cl
  00259	52		 push	 edx
  0025a	0f b6 45 f4	 movzx	 eax, BYTE PTR _level$[ebp]
  0025e	50		 push	 eax
  0025f	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00262	51		 push	 ecx
  00263	0f b6 55 ec	 movzx	 edx, BYTE PTR _y$[ebp]
  00267	52		 push	 edx
  00268	0f b6 45 f0	 movzx	 eax, BYTE PTR _x$[ebp]
  0026c	50		 push	 eax
  0026d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00270	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00277	52		 push	 edx
  00278	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0027b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027d	51		 push	 ecx
  0027e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00283	83 c4 38	 add	 esp, 56			; 00000038H

; 2464 : 			LogAdd("Event ItemDrop(53) : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  00286	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  00289	50		 push	 eax
  0028a	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  0028d	51		 push	 ecx
  0028e	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  00291	52		 push	 edx
  00292	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  00295	50		 push	 eax
  00296	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00299	51		 push	 ecx
  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@KCOPLAHJ@Event?5ItemDrop?$CI53?$CJ?5?3?5Item?3?$CFd?5Le@
  0029f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002a5	83 c4 18	 add	 esp, 24			; 00000018H

; 2465 : 			return TRUE;

  002a8	b8 01 00 00 00	 mov	 eax, 1
  002ad	eb 02		 jmp	 SHORT $LN1@AttackEven
$LN5@AttackEven:

; 2466 : 		}
; 2467 : 	}
; 2468 : 	//LogAdd("가방에서 주기 실패 %d", Mon53->GetBagCount());
; 2469 : 	return FALSE;

  002af	33 c0		 xor	 eax, eax
$LN1@AttackEven:

; 2470 : }

  002b1	5f		 pop	 edi
  002b2	5e		 pop	 esi
  002b3	5b		 pop	 ebx
  002b4	8b e5		 mov	 esp, ebp
  002b6	5d		 pop	 ebp
  002b7	c3		 ret	 0
?AttackEvent53BagOpen@@YAHPAVOBJECTSTRUCT@@@Z ENDP	; AttackEvent53BagOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?LuckyBoxOpenEven@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -40						; size = 4
_DropItemNum$ = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_level$ = -12						; size = 4
_type$ = -8						; size = 4
_dur$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?LuckyBoxOpenEven@@YAXPAVOBJECTSTRUCT@@@Z PROC		; LuckyBoxOpenEven, COMDAT

; 2312 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2313 : 	float dur;
; 2314 : 	int type, level, x, y;
; 2315 : 	int Option1 = 0;

  00009	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 2316 : 	int Option2 = 0;

  00010	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 2317 : 	int Option3 = 0;

  00017	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 2318 : 	int DropItemNum;
; 2319 : 
; 2320 : 	if( !LuckboxItemBag )

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A, 0 ; LuckboxItemBag
  00025	75 05		 jne	 SHORT $LN5@LuckyBoxOp

; 2321 : 		return;

  00027	e9 fc 02 00 00	 jmp	 $LN1@LuckyBoxOp
$LN5@LuckyBoxOp:

; 2322 : 
; 2323 : 	if( LuckboxItemBag->GetBagCount() > 0 )

  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  00032	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00037	85 c0		 test	 eax, eax
  00039	0f 8e 4b 02 00
	00		 jle	 $LN7@LuckyBoxOp

; 2324 : 	{
; 2325 : 		// 2/10 의 확률로 이벤트용 아이템 증정
; 2326 : 		if( (rand()%10) < 2 )

  0003f	e8 00 00 00 00	 call	 _rand
  00044	99		 cdq
  00045	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0004a	f7 f9		 idiv	 ecx
  0004c	83 fa 02	 cmp	 edx, 2
  0004f	0f 8d 35 02 00
	00		 jge	 $LN7@LuckyBoxOp

; 2327 : 		{
; 2328 : 			DropItemNum = (rand()%LuckboxItemBag->GetBagCount());

  00055	e8 00 00 00 00	 call	 _rand
  0005a	8b f0		 mov	 esi, eax
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  00062	e8 00 00 00 00	 call	 ?GetBagCount@CItemBag@@QAEHXZ ; CItemBag::GetBagCount
  00067	8b c8		 mov	 ecx, eax
  00069	8b c6		 mov	 eax, esi
  0006b	99		 cdq
  0006c	f7 f9		 idiv	 ecx
  0006e	89 55 dc	 mov	 DWORD PTR _DropItemNum$[ebp], edx

; 2329 : 			dur  = 0;

  00071	0f 57 c0	 xorps	 xmm0, xmm0
  00074	f3 0f 11 45 fc	 movss	 DWORD PTR _dur$[ebp], xmm0

; 2330 : 			x    = lpObj->X;

  00079	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007c	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00083	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 2331 : 			y    = lpObj->Y;

  00086	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00089	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00090	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 2332 : 			
; 2333 : 
; 2334 : 			level= LuckboxItemBag->GetLevel(DropItemNum)+(rand()%2);

  00093	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  00096	50		 push	 eax
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  0009d	e8 00 00 00 00	 call	 ?GetLevel@CItemBag@@QAEEH@Z ; CItemBag::GetLevel
  000a2	0f b6 f0	 movzx	 esi, al
  000a5	e8 00 00 00 00	 call	 _rand
  000aa	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000af	79 05		 jns	 SHORT $LN15@LuckyBoxOp
  000b1	48		 dec	 eax
  000b2	83 c8 fe	 or	 eax, -2			; fffffffeH
  000b5	40		 inc	 eax
$LN15@LuckyBoxOp:
  000b6	03 f0		 add	 esi, eax
  000b8	89 75 f4	 mov	 DWORD PTR _level$[ebp], esi

; 2335 : 			
; 2336 : 			type = ItemGetNumberMake(LuckboxItemBag->GetType(DropItemNum), LuckboxItemBag->GetIndex(DropItemNum));

  000bb	8b 45 dc	 mov	 eax, DWORD PTR _DropItemNum$[ebp]
  000be	50		 push	 eax
  000bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  000c5	e8 00 00 00 00	 call	 ?GetIndex@CItemBag@@QAEEH@Z ; CItemBag::GetIndex
  000ca	0f b6 c8	 movzx	 ecx, al
  000cd	51		 push	 ecx
  000ce	8b 55 dc	 mov	 edx, DWORD PTR _DropItemNum$[ebp]
  000d1	52		 push	 edx
  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LuckboxItemBag@@3PAVCItemBag@@A ; LuckboxItemBag
  000d8	e8 00 00 00 00	 call	 ?GetType@CItemBag@@QAEEH@Z ; CItemBag::GetType
  000dd	0f b6 c0	 movzx	 eax, al
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000e6	83 c4 08	 add	 esp, 8
  000e9	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 2337 : 			
; 2338 : 			Option1 = rand()%2;

  000ec	e8 00 00 00 00	 call	 _rand
  000f1	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000f6	79 05		 jns	 SHORT $LN16@LuckyBoxOp
  000f8	48		 dec	 eax
  000f9	83 c8 fe	 or	 eax, -2			; fffffffeH
  000fc	40		 inc	 eax
$LN16@LuckyBoxOp:
  000fd	89 45 e8	 mov	 DWORD PTR _Option1$[ebp], eax

; 2339 : 			Option2 = rand()%2;

  00100	e8 00 00 00 00	 call	 _rand
  00105	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0010a	79 05		 jns	 SHORT $LN17@LuckyBoxOp
  0010c	48		 dec	 eax
  0010d	83 c8 fe	 or	 eax, -2			; fffffffeH
  00110	40		 inc	 eax
$LN17@LuckyBoxOp:
  00111	89 45 e4	 mov	 DWORD PTR _Option2$[ebp], eax

; 2340 : 			if( (rand()%5) < 1 )

  00114	e8 00 00 00 00	 call	 _rand
  00119	99		 cdq
  0011a	b9 05 00 00 00	 mov	 ecx, 5
  0011f	f7 f9		 idiv	 ecx
  00121	83 fa 01	 cmp	 edx, 1
  00124	7d 09		 jge	 SHORT $LN8@LuckyBoxOp

; 2341 : 			{
; 2342 : 				Option3 = 3;

  00126	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3

; 2343 : 			}

  0012d	eb 17		 jmp	 SHORT $LN9@LuckyBoxOp
$LN8@LuckyBoxOp:

; 2344 : 			else Option3 = 1+(rand()%2);

  0012f	e8 00 00 00 00	 call	 _rand
  00134	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00139	79 05		 jns	 SHORT $LN18@LuckyBoxOp
  0013b	48		 dec	 eax
  0013c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0013f	40		 inc	 eax
$LN18@LuckyBoxOp:
  00140	83 c0 01	 add	 eax, 1
  00143	89 45 e0	 mov	 DWORD PTR _Option3$[ebp], eax
$LN9@LuckyBoxOp:

; 2345 : 
; 2346 : 			// 혼석, 축석, 영석은 레벨이 없게
; 2347 : 			if( (type == MAKE_ITEMNUM(12,15)) ||
; 2348 : 				(type == MAKE_ITEMNUM(14,13)) ||

  00146	6a 0f		 push	 15			; 0000000fH
  00148	6a 0c		 push	 12			; 0000000cH
  0014a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0014f	83 c4 08	 add	 esp, 8
  00152	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00155	74 22		 je	 SHORT $LN11@LuckyBoxOp
  00157	6a 0d		 push	 13			; 0000000dH
  00159	6a 0e		 push	 14			; 0000000eH
  0015b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00160	83 c4 08	 add	 esp, 8
  00163	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00166	74 11		 je	 SHORT $LN11@LuckyBoxOp
  00168	6a 0e		 push	 14			; 0000000eH
  0016a	6a 0e		 push	 14			; 0000000eH
  0016c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00171	83 c4 08	 add	 esp, 8
  00174	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  00177	75 1c		 jne	 SHORT $LN10@LuckyBoxOp
$LN11@LuckyBoxOp:

; 2349 : 				(type == MAKE_ITEMNUM(14,14)) )
; 2350 : 			{	
; 2351 : 				Option1 = 0; 

  00179	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 2352 : 				Option2 = 0;

  00180	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 2353 : 				Option3 = 0;

  00187	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 2354 : 				level   = 0;

  0018e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN10@LuckyBoxOp:

; 2355 : 			}
; 2356 : 
; 2357 : 			if( (type == MAKE_ITEMNUM(13, 0)) ||
; 2358 : 				(type == MAKE_ITEMNUM(13, 1)) ||				
; 2359 : 				(type == MAKE_ITEMNUM(13, 2)) ||
; 2360 : 				(type == MAKE_ITEMNUM(13, 8)) ||
; 2361 : 				(type == MAKE_ITEMNUM(13, 9)) ||
; 2362 : 				(type == MAKE_ITEMNUM(13, 12)) ||

  00195	6a 00		 push	 0
  00197	6a 0d		 push	 13			; 0000000dH
  00199	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0019e	83 c4 08	 add	 esp, 8
  001a1	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001a4	74 66		 je	 SHORT $LN13@LuckyBoxOp
  001a6	6a 01		 push	 1
  001a8	6a 0d		 push	 13			; 0000000dH
  001aa	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001af	83 c4 08	 add	 esp, 8
  001b2	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001b5	74 55		 je	 SHORT $LN13@LuckyBoxOp
  001b7	6a 02		 push	 2
  001b9	6a 0d		 push	 13			; 0000000dH
  001bb	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001c0	83 c4 08	 add	 esp, 8
  001c3	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001c6	74 44		 je	 SHORT $LN13@LuckyBoxOp
  001c8	6a 08		 push	 8
  001ca	6a 0d		 push	 13			; 0000000dH
  001cc	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001d1	83 c4 08	 add	 esp, 8
  001d4	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001d7	74 33		 je	 SHORT $LN13@LuckyBoxOp
  001d9	6a 09		 push	 9
  001db	6a 0d		 push	 13			; 0000000dH
  001dd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e2	83 c4 08	 add	 esp, 8
  001e5	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001e8	74 22		 je	 SHORT $LN13@LuckyBoxOp
  001ea	6a 0c		 push	 12			; 0000000cH
  001ec	6a 0d		 push	 13			; 0000000dH
  001ee	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f3	83 c4 08	 add	 esp, 8
  001f6	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  001f9	74 11		 je	 SHORT $LN13@LuckyBoxOp
  001fb	6a 0d		 push	 13			; 0000000dH
  001fd	6a 0d		 push	 13			; 0000000dH
  001ff	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00204	83 c4 08	 add	 esp, 8
  00207	39 45 f8	 cmp	 DWORD PTR _type$[ebp], eax
  0020a	75 07		 jne	 SHORT $LN12@LuckyBoxOp
$LN13@LuckyBoxOp:

; 2363 : 				(type == MAKE_ITEMNUM(13, 13)) )
; 2364 : 			{	// 반지류는 레벨 0
; 2365 : 				level   = 0;

  0020c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN12@LuckyBoxOp:

; 2366 : 			}
; 2367 : 
; 2368 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, lpObj->m_Index);

  00213	6a 00		 push	 0
  00215	6a 00		 push	 0
  00217	6a 00		 push	 0
  00219	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0021c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021e	51		 push	 ecx
  0021f	0f b6 55 e0	 movzx	 edx, BYTE PTR _Option3$[ebp]
  00223	52		 push	 edx
  00224	0f b6 45 e4	 movzx	 eax, BYTE PTR _Option2$[ebp]
  00228	50		 push	 eax
  00229	0f b6 4d e8	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  0022d	51		 push	 ecx
  0022e	f3 0f 2c 55 fc	 cvttss2si edx, DWORD PTR _dur$[ebp]
  00233	0f b6 c2	 movzx	 eax, dl
  00236	50		 push	 eax
  00237	0f b6 4d f4	 movzx	 ecx, BYTE PTR _level$[ebp]
  0023b	51		 push	 ecx
  0023c	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  0023f	52		 push	 edx
  00240	0f b6 45 ec	 movzx	 eax, BYTE PTR _y$[ebp]
  00244	50		 push	 eax
  00245	0f b6 4d f0	 movzx	 ecx, BYTE PTR _x$[ebp]
  00249	51		 push	 ecx
  0024a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0024d	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00254	50		 push	 eax
  00255	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00258	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025a	52		 push	 edx
  0025b	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00260	83 c4 38	 add	 esp, 56			; 00000038H

; 2369 : 
; 2370 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 2371 : 			CItem EventItem;
; 2372 : 			EventItem.Convert( type, Option1, Option2, Option3, 0, 1 );
; 2373 : 
; 2374 : 			LogAddTD("[%s][%s][Lucky Box Item Drop] : (%d)(X:%d/Y:%d) Item:%s(%d) Level:%d Op1:%d Op2:%d Op3:%d",
; 2375 : 				lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 2376 : 				EventItem.GetName(), type, level, Option1, Option2, Option3 );
; 2377 : #else
; 2378 : 			LogAdd("Event ItemDrop : Item:%d Level:%d op1:%d op2:%d op3:%d", type, level, Option1, Option2, Option3 );

  00263	8b 45 e0	 mov	 eax, DWORD PTR _Option3$[ebp]
  00266	50		 push	 eax
  00267	8b 4d e4	 mov	 ecx, DWORD PTR _Option2$[ebp]
  0026a	51		 push	 ecx
  0026b	8b 55 e8	 mov	 edx, DWORD PTR _Option1$[ebp]
  0026e	52		 push	 edx
  0026f	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  00272	50		 push	 eax
  00273	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00276	51		 push	 ecx
  00277	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@MGHNDFPH@Event?5ItemDrop?5?3?5Item?3?$CFd?5Level?3@
  0027c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00282	83 c4 18	 add	 esp, 24			; 00000018H

; 2379 : #endif
; 2380 : 			return;

  00285	e9 9e 00 00 00	 jmp	 $LN1@LuckyBoxOp
$LN7@LuckyBoxOp:

; 2381 : 		}
; 2382 : 	}
; 2383 : 	
; 2384 : 	for( int n=0; n<3+(rand()%4); n++)

  0028a	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00291	eb 09		 jmp	 SHORT $LN4@LuckyBoxOp
$LN2@LuckyBoxOp:
  00293	8b 45 d8	 mov	 eax, DWORD PTR _n$1[ebp]
  00296	83 c0 01	 add	 eax, 1
  00299	89 45 d8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@LuckyBoxOp:
  0029c	e8 00 00 00 00	 call	 _rand
  002a1	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  002a6	79 05		 jns	 SHORT $LN19@LuckyBoxOp
  002a8	48		 dec	 eax
  002a9	83 c8 fc	 or	 eax, -4			; fffffffcH
  002ac	40		 inc	 eax
$LN19@LuckyBoxOp:
  002ad	83 c0 03	 add	 eax, 3
  002b0	39 45 d8	 cmp	 DWORD PTR _n$1[ebp], eax
  002b3	7d 73		 jge	 SHORT $LN3@LuckyBoxOp

; 2385 : 	{
; 2386 : 		x    = lpObj->X-2;

  002b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b8	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  002bf	83 e9 02	 sub	 ecx, 2
  002c2	89 4d f0	 mov	 DWORD PTR _x$[ebp], ecx

; 2387 : 		y    = lpObj->Y-2;

  002c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c8	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  002cf	83 e9 02	 sub	 ecx, 2
  002d2	89 4d ec	 mov	 DWORD PTR _y$[ebp], ecx

; 2388 : 		x   += rand()%3;

  002d5	e8 00 00 00 00	 call	 _rand
  002da	99		 cdq
  002db	b9 03 00 00 00	 mov	 ecx, 3
  002e0	f7 f9		 idiv	 ecx
  002e2	03 55 f0	 add	 edx, DWORD PTR _x$[ebp]
  002e5	89 55 f0	 mov	 DWORD PTR _x$[ebp], edx

; 2389 : 		y   += rand()%3;

  002e8	e8 00 00 00 00	 call	 _rand
  002ed	99		 cdq
  002ee	b9 03 00 00 00	 mov	 ecx, 3
  002f3	f7 f9		 idiv	 ecx
  002f5	03 55 ec	 add	 edx, DWORD PTR _y$[ebp]
  002f8	89 55 ec	 mov	 DWORD PTR _y$[ebp], edx

; 2390 : 		MapC[lpObj->MapNumber].MoneyItemDrop(1000, x ,y);

  002fb	8b 45 ec	 mov	 eax, DWORD PTR _y$[ebp]
  002fe	50		 push	 eax
  002ff	8b 4d f0	 mov	 ecx, DWORD PTR _x$[ebp]
  00302	51		 push	 ecx
  00303	68 e8 03 00 00	 push	 1000			; 000003e8H
  00308	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0030b	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00312	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00318	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0031e	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 2391 : 	}

  00323	e9 6b ff ff ff	 jmp	 $LN2@LuckyBoxOp
$LN3@LuckyBoxOp:
$LN1@LuckyBoxOp:

; 2392 : }

  00328	5f		 pop	 edi
  00329	5e		 pop	 esi
  0032a	5b		 pop	 ebx
  0032b	8b e5		 mov	 esp, ebp
  0032d	5d		 pop	 ebp
  0032e	c3		 ret	 0
?LuckyBoxOpenEven@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; LuckyBoxOpenEven
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ItemBag.h
;	COMDAT ?GetExItemCount@CItemBag@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExItemCount@CItemBag@@QAEHXZ PROC			; CItemBag::GetExItemCount, COMDAT
; _this$ = ecx

; 73   : 	int	GetExItemCount(){return BagExItemCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 80 90 03 00
	00		 mov	 eax, DWORD PTR [eax+912]
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetExItemCount@CItemBag@@QAEHXZ ENDP			; CItemBag::GetExItemCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ItemBag.h
;	COMDAT ?GetNormalItemCount@CItemBag@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNormalItemCount@CItemBag@@QAEHXZ PROC		; CItemBag::GetNormalItemCount, COMDAT
; _this$ = ecx

; 72   : 	int	GetNormalItemCount(){return BagNormalItemCount;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 80 8c 03 00
	00		 mov	 eax, DWORD PTR [eax+908]
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetNormalItemCount@CItemBag@@QAEHXZ ENDP		; CItemBag::GetNormalItemCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ItemBag.h
;	COMDAT ?GetBagCount@CItemBag@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBagCount@CItemBag@@QAEHXZ PROC			; CItemBag::GetBagCount, COMDAT
; _this$ = ecx

; 62   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 		return BagObjectCount;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 80 88 03 00
	00		 mov	 eax, DWORD PTR [eax+904]

; 64   : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?GetBagCount@CItemBag@@QAEHXZ ENDP			; CItemBag::GetBagCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Event.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
