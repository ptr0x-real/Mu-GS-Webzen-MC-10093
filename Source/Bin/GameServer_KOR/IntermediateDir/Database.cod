; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	_vsprintf
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
PUBLIC	?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0CDataBase@@QAE@XZ				; CDataBase::CDataBase
PUBLIC	??1CDataBase@@QAE@XZ				; CDataBase::~CDataBase
PUBLIC	?Connect@CDataBase@@QAE_NPBD000@Z		; CDataBase::Connect
PUBLIC	?Connect@CDataBase@@QAE_NPBD@Z			; CDataBase::Connect
PUBLIC	?Reconnect@CDataBase@@QAE_NXZ			; CDataBase::Reconnect
PUBLIC	?Exec@CDataBase@@QAE_NPBD@Z			; CDataBase::Exec
PUBLIC	?ExecFormat@CDataBase@@QAA_NPBDZZ		; CDataBase::ExecFormat
PUBLIC	?FindCol@CDataBase@@QAEHPBD@Z			; CDataBase::FindCol
PUBLIC	?GetInt@CDataBase@@QAEHH@Z			; CDataBase::GetInt
PUBLIC	?GetInt@CDataBase@@QAEHPBD@Z			; CDataBase::GetInt
PUBLIC	?GetInt64@CDataBase@@QAE_JH@Z			; CDataBase::GetInt64
PUBLIC	?GetInt64@CDataBase@@QAE_JPBD@Z			; CDataBase::GetInt64
PUBLIC	?GetFloat@CDataBase@@QAEMH@Z			; CDataBase::GetFloat
PUBLIC	?GetFloat@CDataBase@@QAEMPBD@Z			; CDataBase::GetFloat
PUBLIC	?GetStr@CDataBase@@QAEXHPAD@Z			; CDataBase::GetStr
PUBLIC	?GetStr@CDataBase@@QAEXPBDPAD@Z			; CDataBase::GetStr
PUBLIC	?GetIntExec@CDataBase@@QAEHPAD@Z		; CDataBase::GetIntExec
PUBLIC	?GetFloatExec@CDataBase@@QAEMPAD@Z		; CDataBase::GetFloatExec
PUBLIC	?GetStrExec@CDataBase@@QAE_NPAD0@Z		; CDataBase::GetStrExec
PUBLIC	?GetAsBinary@CDataBase@@QAEHPADPAE@Z		; CDataBase::GetAsBinary
PUBLIC	?SetAsBinary@CDataBase@@QAEXPADPAEK@Z		; CDataBase::SetAsBinary
PUBLIC	?Fetch@CDataBase@@QAEFXZ			; CDataBase::Fetch
PUBLIC	?Clear@CDataBase@@QAEXXZ			; CDataBase::Clear
PUBLIC	?OnError@CDataBase@@UAAXPBDZZ			; CDataBase::OnError
PUBLIC	?OnQuery@CDataBase@@UAAXPBDZZ			; CDataBase::OnQuery
PUBLIC	?OnMessage@CDataBase@@UAAXPBDZZ			; CDataBase::OnMessage
PUBLIC	?Diagnostic@CDataBase@@QAEXXZ			; CDataBase::Diagnostic
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7CDataBase@@6B@				; CDataBase::`vftable'
PUBLIC	??_C@_05OAJIOINI@08S01@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_0DH@KALJNAIN@DRIVER?$DNSQL?5Server?$DLServer?$DN?$CFs?$DLDAT@ ; `string'
PUBLIC	??_C@_0CO@NNKEKGNI@DATABASE?$DN?$CFs?$DLDRIVER?$DNSQL?5Server?$DLS@ ; `string'
PUBLIC	??_C@_0CJ@NLJNDEGA@Voc?j?5excedeu?5o?5n?zmero?5m?aximo?5de@ ; `string'
PUBLIC	??_R4CDataBase@@6B@				; CDataBase::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDataBase@@@8				; CDataBase `RTTI Type Descriptor'
PUBLIC	??_R3CDataBase@@8				; CDataBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDataBase@@8				; CDataBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDataBase@@8			; CDataBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@c2c80000
PUBLIC	__real@c2ca0000
PUBLIC	__real@c2cc0000
PUBLIC	__real@c2ce0000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	__stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_atof:PROC
EXTRN	_atoi:PROC
EXTRN	__atoi64:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_SQLAllocHandle@12:PROC
EXTRN	_SQLBindCol@24:PROC
EXTRN	_SQLCloseCursor@4:PROC
EXTRN	_SQLDescribeCol@36:PROC
EXTRN	_SQLDisconnect@4:PROC
EXTRN	_SQLExecDirect@12:PROC
EXTRN	_SQLFetch@4:PROC
EXTRN	_SQLFreeHandle@8:PROC
EXTRN	_SQLFreeStmt@8:PROC
EXTRN	_SQLGetData@24:PROC
EXTRN	_SQLGetDiagRec@32:PROC
EXTRN	_SQLNumResultCols@8:PROC
EXTRN	_SQLParamData@8:PROC
EXTRN	_SQLPutData@12:PROC
EXTRN	_SQLRowCount@8:PROC
EXTRN	_SQLSetEnvAttr@16:PROC
EXTRN	_SQLDriverConnect@32:PROC
EXTRN	_SQLBindParameter@40:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __real@c2ce0000
CONST	SEGMENT
__real@c2ce0000 DD 0c2ce0000r			; -103
CONST	ENDS
;	COMDAT __real@c2cc0000
CONST	SEGMENT
__real@c2cc0000 DD 0c2cc0000r			; -102
CONST	ENDS
;	COMDAT __real@c2ca0000
CONST	SEGMENT
__real@c2ca0000 DD 0c2ca0000r			; -101
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CDataBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDataBase@@8 DD FLAT:??_R0?AVCDataBase@@@8 ; CDataBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDataBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CDataBase@@8
rdata$r	SEGMENT
??_R2CDataBase@@8 DD FLAT:??_R1A@?0A@EA@CDataBase@@8	; CDataBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDataBase@@8
rdata$r	SEGMENT
??_R3CDataBase@@8 DD 00H				; CDataBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDataBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDataBase@@@8
data$r	SEGMENT
??_R0?AVCDataBase@@@8 DD FLAT:??_7type_info@@6B@	; CDataBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDataBase@@', 00H
data$r	ENDS
;	COMDAT ??_R4CDataBase@@6B@
rdata$r	SEGMENT
??_R4CDataBase@@6B@ DD 00H				; CDataBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDataBase@@@8
	DD	FLAT:??_R3CDataBase@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CJ@NLJNDEGA@Voc?j?5excedeu?5o?5n?zmero?5m?aximo?5de@
CONST	SEGMENT
??_C@_0CJ@NLJNDEGA@Voc?j?5excedeu?5o?5n?zmero?5m?aximo?5de@ DB 'Voc', 0eaH
	DB	' excedeu o n', 0faH, 'mero m', 0e1H, 'ximo de colunas!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NNKEKGNI@DATABASE?$DN?$CFs?$DLDRIVER?$DNSQL?5Server?$DLS@
CONST	SEGMENT
??_C@_0CO@NNKEKGNI@DATABASE?$DN?$CFs?$DLDRIVER?$DNSQL?5Server?$DLS@ DB 'D'
	DB	'ATABASE=%s;DRIVER=SQL Server;Server=(local);', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KALJNAIN@DRIVER?$DNSQL?5Server?$DLServer?$DN?$CFs?$DLDAT@
CONST	SEGMENT
??_C@_0DH@KALJNAIN@DRIVER?$DNSQL?5Server?$DLServer?$DN?$CFs?$DLDAT@ DB 'D'
	DB	'RIVER=SQL Server;Server=%s;DATABASE=%s;UID=%s;PWD=%s;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_05OAJIOINI@08S01@
CONST	SEGMENT
??_C@_05OAJIOINI@08S01@ DB '08S01', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CDataBase@@6B@
CONST	SEGMENT
??_7CDataBase@@6B@ DD FLAT:??_R4CDataBase@@6B@		; CDataBase::`vftable'
	DD	FLAT:?OnError@CDataBase@@UAAXPBDZZ
	DD	FLAT:?OnQuery@CDataBase@@UAAXPBDZZ
	DD	FLAT:?OnMessage@CDataBase@@UAAXPBDZZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	83 c0 23	 add	 eax, 35			; 00000023H
  0000f	89 45 fc	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  00012	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00015	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00018	77 05		 ja	 SHORT $LN8@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  0001a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001f	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002e	83 7d f8 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00032	74 02		 je	 SHORT $LN7@Allocate_m
  00034	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00036	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0003b	33 c0		 xor	 eax, eax
  0003d	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  0003f	33 c0		 xor	 eax, eax
  00041	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00046	83 c0 23	 add	 eax, 35			; 00000023H
  00049	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0004c	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	6b c8 ff	 imul	 ecx, eax, -1
  00057	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00060	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00009	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00010	72 0e		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00012	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0001b	83 c4 04	 add	 esp, 4
  0001e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00020	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00024	74 0e		 je	 SHORT $LN3@Allocate

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002f	83 c4 04	 add	 esp, 4
  00032	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00034	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 0

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {
; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 66   : }

  00010	5f		 pop	 edi
  00011	5e		 pop	 esi
  00012	5b		 pop	 ebx
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00028	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0002f	72 10		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00031	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  00034	50		 push	 eax
  00035	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0003e	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8

; 222  : }

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
$T1 = -68						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 42   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 43   :     // return larger of _Left and _Right
; 44   :     return _Left < _Right ? _Right : _Left;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	73 08		 jae	 SHORT $LN3@max
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00018	89 45 b8	 mov	 DWORD PTR tv65[ebp], eax
  0001b	eb 06		 jmp	 SHORT $LN4@max
$LN3@max:
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00020	89 4d b8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@max:
  00023	8b 55 b8	 mov	 edx, DWORD PTR tv65[ebp]
  00026	89 55 bc	 mov	 DWORD PTR $T1[ebp], edx
  00029	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]

; 45   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  :     return _Ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
$T1 = -68						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 67   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 68   :     // return smaller of _Left and _Right
; 69   :     return _Right < _Left ? _Right : _Left;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	73 08		 jae	 SHORT $LN3@min
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00018	89 45 b8	 mov	 DWORD PTR tv65[ebp], eax
  0001b	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00020	89 4d b8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00023	8b 55 b8	 mov	 edx, DWORD PTR tv65[ebp]
  00026	89 55 bc	 mov	 DWORD PTR $T1[ebp], edx
  00029	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]

; 70   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__New_ptr$ = -20					; size = 4
__Al$ = -16						; size = 4
__New_capacity$ = -12					; size = 4
__Old_capacity$ = -8					; size = 4
_this$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4218 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4219 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4220 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4221 :         if (_New_size > max_size()) {

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00014	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00017	76 05		 jbe	 SHORT $LN2@Reallocate

; 4222 :             _Xlen_string(); // result too long

  00019	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4223 :         }
; 4224 : 
; 4225 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00024	89 4d f8	 mov	 DWORD PTR __Old_capacity$[ebp], ecx

; 4226 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00027	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00033	89 45 f4	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4227 :         auto& _Al                     = _Getal();

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0003e	89 45 f0	 mov	 DWORD PTR __Al$[ebp], eax

; 4228 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00041	8b 45 f4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	50		 push	 eax
  00048	8b 4d f0	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004b	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  00050	89 45 ec	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4229 :         _Mypair._Myval2._Orphan_all();

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4230 :         _Mypair._Myval2._Mysize = _New_size;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00061	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4231 :         _Mypair._Myval2._Myres  = _New_capacity;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0006a	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4232 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  0006d	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 ec	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0007e	83 c4 04	 add	 esp, 4
  00081	50		 push	 eax
  00082	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  00085	e8 00 00 00 00	 call	 ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()

; 4233 :         if (_BUF_SIZE <= _Old_capacity) {

  0008a	83 7d f8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0008e	72 1f		 jb	 SHORT $LN3@Reallocate

; 4234 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00090	8b 45 f8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	50		 push	 eax
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	52		 push	 edx
  0009d	8b 4d f0	 mov	 ecx, DWORD PTR __Al$[ebp]
  000a0	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4235 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d ec	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ab	89 08		 mov	 DWORD PTR [eax], ecx

; 4236 :         } else {

  000ad	eb 10		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4237 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000af	8d 45 ec	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	51		 push	 ecx
  000b7	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000bc	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4238 :         }
; 4239 : 
; 4240 :         return *this;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4241 :     }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$ = ecx

; 2976 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2977 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::copy
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00020	c6 45 bb 00	 mov	 BYTE PTR $T1[ebp], 0
  00024	8d 45 bb	 lea	 eax, DWORD PTR $T1[ebp]
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0002b	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00034	83 c4 08	 add	 esp, 8

; 2979 :             },

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 267  : void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 268  :     _Obj.~_Ty();
; 269  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.h
;	COMDAT ?Diagnostic@CDataBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Diagnostic@CDataBase@@QAEXXZ PROC			; CDataBase::Diagnostic, COMDAT
; _this$ = ecx

; 66   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 67   : 		if (SQLGetDiagRec(SQL_HANDLE_STMT, m_hStmt, m_SQLErrorCount, m_SqlState, & m_NativeError, 
; 68   : 			m_szMsg, sizeof(m_szMsg), & m_MsgOutLen) != SQL_NO_DATA)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	05 28 7f 00 00	 add	 eax, 32552		; 00007f28H
  00014	50		 push	 eax
  00015	68 f4 01 00 00	 push	 500			; 000001f4H
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	81 c1 3c 7b 00
	00		 add	 ecx, 31548		; 00007b3cH
  00023	51		 push	 ecx
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	81 c2 2c 7f 00
	00		 add	 edx, 32556		; 00007f2cH
  0002d	52		 push	 edx
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	05 30 7d 00 00	 add	 eax, 32048		; 00007d30H
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	0f b7 91 24 7f
	00 00		 movzx	 edx, WORD PTR [ecx+32548]
  00041	52		 push	 edx
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00048	51		 push	 ecx
  00049	6a 03		 push	 3
  0004b	e8 00 00 00 00	 call	 _SQLGetDiagRec@32
  00050	0f bf d0	 movsx	 edx, ax
  00053	83 fa 64	 cmp	 edx, 100		; 00000064H
  00056	74 56		 je	 SHORT $LN2@Diagnostic

; 69   : 		{
; 70   : 			m_SQLErrorCount++;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 88 24 7f 00
	00		 mov	 ecx, DWORD PTR [eax+32548]
  00061	83 c1 01	 add	 ecx, 1
  00064	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00067	89 8a 24 7f 00
	00		 mov	 DWORD PTR [edx+32548], ecx

; 71   : 
; 72   : 			memcpy(m_szTemp, m_szMsg , m_MsgOutLen);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	0f bf 88 28 7f
	00 00		 movsx	 ecx, WORD PTR [eax+32552]
  00077	51		 push	 ecx
  00078	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007b	81 c2 3c 7b 00
	00		 add	 edx, 31548		; 00007b3cH
  00081	52		 push	 edx
  00082	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00085	05 48 79 00 00	 add	 eax, 31048		; 00007948H
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _memcpy
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   : 
; 74   : 			OnError(m_szTemp);

  00093	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00096	05 48 79 00 00	 add	 eax, 31048		; 00007948H
  0009b	50		 push	 eax
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	50		 push	 eax
  000a5	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000a7	ff d1		 call	 ecx
  000a9	83 c4 08	 add	 esp, 8

; 75   : 		}

  000ac	eb 0d		 jmp	 SHORT $LN3@Diagnostic
$LN2@Diagnostic:

; 76   : 		else m_SQLErrorCount = 1;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	c7 80 24 7f 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+32548], 1
$LN3@Diagnostic:

; 77   : 
; 78   : 		if (strcmp((LPCTSTR)m_SqlState, "08S01") == 0)

  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_05OAJIOINI@08S01@
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	05 30 7d 00 00	 add	 eax, 32048		; 00007d30H
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _strcmp
  000ce	83 c4 08	 add	 esp, 8
  000d1	85 c0		 test	 eax, eax
  000d3	75 08		 jne	 SHORT $LN1@Diagnostic

; 79   : 		{
; 80   : 			Reconnect();

  000d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?Reconnect@CDataBase@@QAE_NXZ ; CDataBase::Reconnect
$LN1@Diagnostic:

; 81   : 		}
; 82   : 	};

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
?Diagnostic@CDataBase@@QAEXXZ ENDP			; CDataBase::Diagnostic
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.h
;	COMDAT ?OnMessage@CDataBase@@UAAXPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
_szMessage$ = 12					; size = 4
?OnMessage@CDataBase@@UAAXPBDZZ PROC			; CDataBase::OnMessage, COMDAT

; 63   : 	virtual void OnMessage(const char * szMessage, ...){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?OnMessage@CDataBase@@UAAXPBDZZ ENDP			; CDataBase::OnMessage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.h
;	COMDAT ?OnQuery@CDataBase@@UAAXPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
_szMessage$ = 12					; size = 4
?OnQuery@CDataBase@@UAAXPBDZZ PROC			; CDataBase::OnQuery, COMDAT

; 62   : 	virtual	void OnQuery(const char * szMessage, ...){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?OnQuery@CDataBase@@UAAXPBDZZ ENDP			; CDataBase::OnQuery
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.h
;	COMDAT ?OnError@CDataBase@@UAAXPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
_szMessage$ = 12					; size = 4
?OnError@CDataBase@@UAAXPBDZZ PROC			; CDataBase::OnError, COMDAT

; 61   : 	virtual	void OnError(const char * szMessage, ...){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?OnError@CDataBase@@UAAXPBDZZ ENDP			; CDataBase::OnError
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.h
;	COMDAT ?Clear@CDataBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CDataBase@@QAEXXZ PROC				; CDataBase::Clear, COMDAT
; _this$ = ecx

; 59   : 	void		inline Clear( ){ SQLCloseCursor( m_hStmt ) ; SQLFreeStmt( m_hStmt , SQL_CLOSE ); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _SQLCloseCursor@4
  00018	6a 00		 push	 0
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _SQLFreeStmt@8
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?Clear@CDataBase@@QAEXXZ ENDP				; CDataBase::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.h
;	COMDAT ?Fetch@CDataBase@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Fetch@CDataBase@@QAEFXZ PROC				; CDataBase::Fetch, COMDAT
; _this$ = ecx

; 58   : 	SQLRETURN	inline Fetch( ){ return SQLFetch( m_hStmt ); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 _SQLFetch@4
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?Fetch@CDataBase@@QAEFXZ ENDP				; CDataBase::Fetch
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?SetAsBinary@CDataBase@@QAEXPADPAEK@Z
_TEXT	SEGMENT
_lOfs$ = -10024						; size = 4
_Result$ = -10020					; size = 2
_cBUFFER$ = -10016					; size = 10000
_pToken$ = -16						; size = 4
_cbValueSize$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpszStatement$ = 8					; size = 4
_lpBinaryBuffer$ = 12					; size = 4
_BinaryBufferSize$ = 16					; size = 4
?SetAsBinary@CDataBase@@QAEXPADPAEK@Z PROC		; CDataBase::SetAsBinary, COMDAT
; _this$ = ecx

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 28 29 00 00	 mov	 eax, 10536		; 00002928H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 457  : 
; 458  : 	this->Clear( );

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 459  : 
; 460  : 	SQLINTEGER cbValueSize = -0x64 - BinaryBufferSize;

  00025	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  0002a	2b 45 10	 sub	 eax, DWORD PTR _BinaryBufferSize$[ebp]
  0002d	89 45 f4	 mov	 DWORD PTR _cbValueSize$[ebp], eax

; 461  : 	SQLPOINTER pToken;
; 462  : 	BYTE cBUFFER[10000];
; 463  : 	SQLRETURN Result;
; 464  : 
; 465  : 	SQLBindParameter(m_hStmt, 1, SQL_PARAM_INPUT,

  00030	8d 45 f4	 lea	 eax, DWORD PTR _cbValueSize$[ebp]
  00033	50		 push	 eax
  00034	6a 00		 push	 0
  00036	6a 01		 push	 1
  00038	6a 00		 push	 0
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _BinaryBufferSize$[ebp]
  0003d	51		 push	 ecx
  0003e	6a fc		 push	 -4			; fffffffcH
  00040	6a fe		 push	 -2			; fffffffeH
  00042	6a 01		 push	 1
  00044	6a 01		 push	 1
  00046	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00049	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _SQLBindParameter@40

; 466  : 		SQL_C_BINARY , SQL_LONGVARBINARY, BinaryBufferSize, 0, (SQLPOINTER)1, 0, &cbValueSize);
; 467  : 
; 468  : 	OnQuery(lpszStatement);

  00052	8b 45 08	 mov	 eax, DWORD PTR _lpszStatement$[ebp]
  00055	50		 push	 eax
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00062	ff d1		 call	 ecx
  00064	83 c4 08	 add	 esp, 8

; 469  : 	SQLExecDirect(m_hStmt, (SQLTCHAR *)lpszStatement, SQL_NTS);

  00067	6a fd		 push	 -3			; fffffffdH
  00069	8b 45 08	 mov	 eax, DWORD PTR _lpszStatement$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 _SQLExecDirect@12

; 470  : 	Result = SQLParamData(m_hStmt, &pToken);

  00079	8d 45 f0	 lea	 eax, DWORD PTR _pToken$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _SQLParamData@8
  00089	66 89 85 dc d8
	ff ff		 mov	 WORD PTR _Result$[ebp], ax

; 471  : 
; 472  : 	int lOfs=0;

  00090	c7 85 d8 d8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0
$LN2@SetAsBinar:

; 473  : 
; 474  : 	while ( Result == SQL_NEED_DATA )

  0009a	0f bf 85 dc d8
	ff ff		 movsx	 eax, WORD PTR _Result$[ebp]
  000a1	83 f8 63	 cmp	 eax, 99			; 00000063H
  000a4	75 60		 jne	 SHORT $LN3@SetAsBinar

; 475  : 	{
; 476  : 		memcpy(cBUFFER, lpBinaryBuffer, sizeof(cBUFFER));

  000a6	68 10 27 00 00	 push	 10000			; 00002710H
  000ab	8b 45 0c	 mov	 eax, DWORD PTR _lpBinaryBuffer$[ebp]
  000ae	50		 push	 eax
  000af	8d 8d e0 d8 ff
	ff		 lea	 ecx, DWORD PTR _cBUFFER$[ebp]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 _memcpy
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 477  : 		Result = SQLPutData(m_hStmt, cBUFFER, BinaryBufferSize);

  000be	8b 45 10	 mov	 eax, DWORD PTR _BinaryBufferSize$[ebp]
  000c1	50		 push	 eax
  000c2	8d 8d e0 d8 ff
	ff		 lea	 ecx, DWORD PTR _cBUFFER$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000cc	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _SQLPutData@12
  000d5	66 89 85 dc d8
	ff ff		 mov	 WORD PTR _Result$[ebp], ax

; 478  : 		Result = SQLParamData(m_hStmt, &pToken);

  000dc	8d 45 f0	 lea	 eax, DWORD PTR _pToken$[ebp]
  000df	50		 push	 eax
  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000e6	52		 push	 edx
  000e7	e8 00 00 00 00	 call	 _SQLParamData@8
  000ec	66 89 85 dc d8
	ff ff		 mov	 WORD PTR _Result$[ebp], ax

; 479  : 		lOfs += sizeof(cBUFFER);

  000f3	8b 85 d8 d8 ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000f9	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  000fe	89 85 d8 d8 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 480  : 	}

  00104	eb 94		 jmp	 SHORT $LN2@SetAsBinar
$LN3@SetAsBinar:

; 481  : 
; 482  : 	SQLParamData(m_hStmt, &pToken);

  00106	8d 45 f0	 lea	 eax, DWORD PTR _pToken$[ebp]
  00109	50		 push	 eax
  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00110	52		 push	 edx
  00111	e8 00 00 00 00	 call	 _SQLParamData@8

; 483  : 	this->Clear( );

  00116	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 484  : }

  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx
  00121	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00124	33 cd		 xor	 ecx, ebp
  00126	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 0c 00	 ret	 12			; 0000000cH
?SetAsBinary@CDataBase@@QAEXPADPAEK@Z ENDP		; CDataBase::SetAsBinary
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetAsBinary@CDataBase@@QAEHPADPAE@Z
_TEXT	SEGMENT
_SQLResult$ = -10028					; size = 2
_SQLLen$ = -10024					; size = 4
_lOfs$ = -10020						; size = 4
_SQLBinary$ = -10016					; size = 10000
_BufLen$ = -16						; size = 4
_pSQLBuf$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpszStatement$ = 8					; size = 4
_lpszReturnBuffer$ = 12					; size = 4
?GetAsBinary@CDataBase@@QAEHPADPAE@Z PROC		; CDataBase::GetAsBinary, COMDAT
; _this$ = ecx

; 393  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 2c 29 00 00	 mov	 eax, 10540		; 0000292cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 394  : 	SQLCHAR * pSQLBuf;
; 395  : 	SQLINTEGER BufLen;
; 396  : 	SQLCHAR SQLBinary[10000];
; 397  : 	SQLINTEGER lOfs = 0;

  0001d	c7 85 dc d8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 398  : 	SQLINTEGER SQLLen;
; 399  : 	SQLRETURN SQLResult;
; 400  : 
; 401  : 	this->Clear( );

  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 402  : 
; 403  : 	OnQuery(lpszStatement);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _lpszStatement$[ebp]
  00032	50		 push	 eax
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 11		 mov	 edx, DWORD PTR [ecx]
  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0003f	ff d1		 call	 ecx
  00041	83 c4 08	 add	 esp, 8

; 404  : 
; 405  : 	SQLResult = SQLExecDirect(m_hStmt, (SQLTCHAR *)lpszStatement, SQL_NTS);

  00044	6a fd		 push	 -3			; fffffffdH
  00046	8b 45 08	 mov	 eax, DWORD PTR _lpszStatement$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 _SQLExecDirect@12
  00056	66 89 85 d4 d8
	ff ff		 mov	 WORD PTR _SQLResult$[ebp], ax

; 406  : 
; 407  : 
; 408  : 	if ( SQLResult != SQL_SUCCESS )

  0005d	0f bf 85 d4 d8
	ff ff		 movsx	 eax, WORD PTR _SQLResult$[ebp]
  00064	85 c0		 test	 eax, eax
  00066	74 10		 je	 SHORT $LN2@GetAsBinar

; 409  : 	{
; 410  : 		Diagnostic();

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?Diagnostic@CDataBase@@QAEXXZ ; CDataBase::Diagnostic

; 411  : 		return -1;

  00070	83 c8 ff	 or	 eax, -1
  00073	e9 ed 00 00 00	 jmp	 $LN1@GetAsBinar
$LN2@GetAsBinar:

; 412  : 	}
; 413  : 
; 414  : 	while ( true )

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	85 c0		 test	 eax, eax
  0007f	0f 84 dd 00 00
	00		 je	 $LN3@GetAsBinar

; 415  : 	{
; 416  : 		SQLResult = SQLFetch(m_hStmt);

  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 _SQLFetch@4
  00091	66 89 85 d4 d8
	ff ff		 mov	 WORD PTR _SQLResult$[ebp], ax

; 417  : 
; 418  : 		if ( SQLResult == SQL_NO_DATA )

  00098	0f bf 85 d4 d8
	ff ff		 movsx	 eax, WORD PTR _SQLResult$[ebp]
  0009f	83 f8 64	 cmp	 eax, 100		; 00000064H
  000a2	75 05		 jne	 SHORT $LN7@GetAsBinar

; 419  : 			break;

  000a4	e9 b9 00 00 00	 jmp	 $LN3@GetAsBinar
$LN7@GetAsBinar:

; 420  : 
; 421  : 		pSQLBuf = lpszReturnBuffer;

  000a9	8b 45 0c	 mov	 eax, DWORD PTR _lpszReturnBuffer$[ebp]
  000ac	89 45 f4	 mov	 DWORD PTR _pSQLBuf$[ebp], eax
$LN4@GetAsBinar:

; 422  : 
; 423  : 		while ( true )

  000af	b8 01 00 00 00	 mov	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	0f 84 a1 00 00
	00		 je	 $LN5@GetAsBinar

; 424  : 		{
; 425  : 
; 426  : 			SQLResult = SQLGetData(m_hStmt,

  000bc	8d 85 d8 d8 ff
	ff		 lea	 eax, DWORD PTR _SQLLen$[ebp]
  000c2	50		 push	 eax
  000c3	68 10 27 00 00	 push	 10000			; 00002710H
  000c8	8d 8d e0 d8 ff
	ff		 lea	 ecx, DWORD PTR _SQLBinary$[ebp]
  000ce	51		 push	 ecx
  000cf	6a fe		 push	 -2			; fffffffeH
  000d1	6a 01		 push	 1
  000d3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _SQLGetData@24
  000df	66 89 85 d4 d8
	ff ff		 mov	 WORD PTR _SQLResult$[ebp], ax

; 427  : 				1, SQL_C_BINARY , SQLBinary, sizeof(SQLBinary), &SQLLen);
; 428  : 
; 429  : 			if ( SQLResult == SQL_NO_DATA )

  000e6	0f bf 85 d4 d8
	ff ff		 movsx	 eax, WORD PTR _SQLResult$[ebp]
  000ed	83 f8 64	 cmp	 eax, 100		; 00000064H
  000f0	75 02		 jne	 SHORT $LN8@GetAsBinar

; 430  : 				break;

  000f2	eb 69		 jmp	 SHORT $LN5@GetAsBinar
$LN8@GetAsBinar:

; 431  : 
; 432  : 			if ( SQLLen == -1 )

  000f4	83 bd d8 d8 ff
	ff ff		 cmp	 DWORD PTR _SQLLen$[ebp], -1
  000fb	75 0c		 jne	 SHORT $LN9@GetAsBinar

; 433  : 			{
; 434  : 				Clear();

  000fd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 435  : 				return 0;

  00105	33 c0		 xor	 eax, eax
  00107	eb 5c		 jmp	 SHORT $LN1@GetAsBinar
$LN9@GetAsBinar:

; 436  : 			}
; 437  : 
; 438  : 			if ( SQLResult == SQL_SUCCESS )

  00109	0f bf 85 d4 d8
	ff ff		 movsx	 eax, WORD PTR _SQLResult$[ebp]
  00110	85 c0		 test	 eax, eax
  00112	75 0b		 jne	 SHORT $LN10@GetAsBinar

; 439  : 			{
; 440  : 				BufLen = SQLLen;

  00114	8b 85 d8 d8 ff
	ff		 mov	 eax, DWORD PTR _SQLLen$[ebp]
  0011a	89 45 f0	 mov	 DWORD PTR _BufLen$[ebp], eax

; 441  : 			}

  0011d	eb 07		 jmp	 SHORT $LN11@GetAsBinar
$LN10@GetAsBinar:

; 442  : 			else
; 443  : 			{
; 444  : 				BufLen = sizeof(SQLBinary);

  0011f	c7 45 f0 10 27
	00 00		 mov	 DWORD PTR _BufLen$[ebp], 10000 ; 00002710H
$LN11@GetAsBinar:

; 445  : 			}
; 446  : 
; 447  : 			lOfs += BufLen;

  00126	8b 85 dc d8 ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0012c	03 45 f0	 add	 eax, DWORD PTR _BufLen$[ebp]
  0012f	89 85 dc d8 ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 448  : 			memcpy(pSQLBuf, SQLBinary, BufLen);

  00135	8b 45 f0	 mov	 eax, DWORD PTR _BufLen$[ebp]
  00138	50		 push	 eax
  00139	8d 8d e0 d8 ff
	ff		 lea	 ecx, DWORD PTR _SQLBinary$[ebp]
  0013f	51		 push	 ecx
  00140	8b 55 f4	 mov	 edx, DWORD PTR _pSQLBuf$[ebp]
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 _memcpy
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH

; 449  : 			pSQLBuf = &pSQLBuf[lOfs];

  0014c	8b 45 f4	 mov	 eax, DWORD PTR _pSQLBuf$[ebp]
  0014f	03 85 dc d8 ff
	ff		 add	 eax, DWORD PTR _lOfs$[ebp]
  00155	89 45 f4	 mov	 DWORD PTR _pSQLBuf$[ebp], eax

; 450  : 		}

  00158	e9 52 ff ff ff	 jmp	 $LN4@GetAsBinar
$LN5@GetAsBinar:

; 451  : 	}

  0015d	e9 16 ff ff ff	 jmp	 $LN2@GetAsBinar
$LN3@GetAsBinar:

; 452  : 	return BufLen;

  00162	8b 45 f0	 mov	 eax, DWORD PTR _BufLen$[ebp]
$LN1@GetAsBinar:

; 453  : }

  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	33 cd		 xor	 ecx, ebp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c2 08 00	 ret	 8
?GetAsBinary@CDataBase@@QAEHPADPAE@Z ENDP		; CDataBase::GetAsBinary
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetStrExec@CDataBase@@QAE_NPAD0@Z
_TEXT	SEGMENT
_Return$ = -5						; size = 1
_this$ = -4						; size = 4
_szQuery$ = 8						; size = 4
_buf$ = 12						; size = 4
?GetStrExec@CDataBase@@QAE_NPAD0@Z PROC			; CDataBase::GetStrExec, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 369  : 	bool Return = false;

  0000c	c6 45 fb 00	 mov	 BYTE PTR _Return$[ebp], 0

; 370  : 
; 371  : 	if (Exec(szQuery))

  00010	8b 45 08	 mov	 eax, DWORD PTR _szQuery$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?Exec@CDataBase@@QAE_NPBD@Z ; CDataBase::Exec
  0001c	0f b6 c8	 movzx	 ecx, al
  0001f	85 c9		 test	 ecx, ecx
  00021	74 43		 je	 SHORT $LN2@GetStrExec

; 372  : 	{
; 373  : 		if (Fetch() != SQL_NO_DATA)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?Fetch@CDataBase@@QAEFXZ ; CDataBase::Fetch
  0002b	98		 cwde
  0002c	83 f8 64	 cmp	 eax, 100		; 00000064H
  0002f	74 1c		 je	 SHORT $LN4@GetStrExec

; 374  : 		{
; 375  : 			GetStr(1,buf);

  00031	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00034	50		 push	 eax
  00035	6a 01		 push	 1
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetStr@CDataBase@@QAEXHPAD@Z ; CDataBase::GetStr

; 376  : 			this->Clear( );

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 377  : 			Return = true;

  00047	c6 45 fb 01	 mov	 BYTE PTR _Return$[ebp], 1

; 378  : 		}

  0004b	eb 17		 jmp	 SHORT $LN5@GetStrExec
$LN4@GetStrExec:

; 379  : 		else
; 380  : 		{
; 381  : 			this->Clear( );

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 382  : 			buf[0] = '\0';

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	6b c8 00	 imul	 ecx, eax, 0
  0005d	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00060	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
$LN5@GetStrExec:

; 383  : 		}
; 384  : 	}

  00064	eb 0f		 jmp	 SHORT $LN3@GetStrExec
$LN2@GetStrExec:

; 385  : 	else
; 386  : 	{
; 387  : 		buf[0] = '\0';

  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	6b c8 00	 imul	 ecx, eax, 0
  0006e	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00071	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0
$LN3@GetStrExec:

; 388  : 	}
; 389  : 	return Return;

  00075	8a 45 fb	 mov	 al, BYTE PTR _Return$[ebp]

; 390  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
?GetStrExec@CDataBase@@QAE_NPAD0@Z ENDP			; CDataBase::GetStrExec
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetFloatExec@CDataBase@@QAEMPAD@Z
_TEXT	SEGMENT
_Return$ = -8						; size = 4
_this$ = -4						; size = 4
_szQuery$ = 8						; size = 4
?GetFloatExec@CDataBase@@QAEMPAD@Z PROC			; CDataBase::GetFloatExec, COMDAT
; _this$ = ecx

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 346  : 	float Return = - 103;

  0000c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2ce0000
  00014	f3 0f 11 45 f8	 movss	 DWORD PTR _Return$[ebp], xmm0

; 347  : 
; 348  : 	if (Exec(szQuery)) 

  00019	8b 45 08	 mov	 eax, DWORD PTR _szQuery$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?Exec@CDataBase@@QAE_NPBD@Z ; CDataBase::Exec
  00025	0f b6 c8	 movzx	 ecx, al
  00028	85 c9		 test	 ecx, ecx
  0002a	74 3a		 je	 SHORT $LN4@GetFloatEx

; 349  : 	{
; 350  : 		if (Fetch() != SQL_NO_DATA)

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?Fetch@CDataBase@@QAEFXZ ; CDataBase::Fetch
  00034	98		 cwde
  00035	83 f8 64	 cmp	 eax, 100		; 00000064H
  00038	74 17		 je	 SHORT $LN3@GetFloatEx

; 351  : 		{	
; 352  : 			Return = GetFloat(1);

  0003a	6a 01		 push	 1
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?GetFloat@CDataBase@@QAEMH@Z ; CDataBase::GetFloat
  00044	d9 5d f8	 fstp	 DWORD PTR _Return$[ebp]

; 353  : 
; 354  : 			this->Clear( );

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 355  : 		}

  0004f	eb 15		 jmp	 SHORT $LN4@GetFloatEx
$LN3@GetFloatEx:

; 356  : 		else
; 357  : 		{
; 358  : 			this->Clear( );

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 359  : 
; 360  : 			Return = - 101;

  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2ca0000
  00061	f3 0f 11 45 f8	 movss	 DWORD PTR _Return$[ebp], xmm0
$LN4@GetFloatEx:

; 361  : 		}
; 362  : 	}
; 363  : 
; 364  : 	return Return;

  00066	d9 45 f8	 fld	 DWORD PTR _Return$[ebp]

; 365  : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
?GetFloatExec@CDataBase@@QAEMPAD@Z ENDP			; CDataBase::GetFloatExec
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetIntExec@CDataBase@@QAEHPAD@Z
_TEXT	SEGMENT
_Return$ = -8						; size = 4
_this$ = -4						; size = 4
_szQuery$ = 8						; size = 4
?GetIntExec@CDataBase@@QAEHPAD@Z PROC			; CDataBase::GetIntExec, COMDAT
; _this$ = ecx

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 325  : 	int Return = - 103;

  0000c	c7 45 f8 99 ff
	ff ff		 mov	 DWORD PTR _Return$[ebp], -103 ; ffffff99H

; 326  : 
; 327  : 	if (Exec(szQuery)) 

  00013	8b 45 08	 mov	 eax, DWORD PTR _szQuery$[ebp]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Exec@CDataBase@@QAE_NPBD@Z ; CDataBase::Exec
  0001f	0f b6 c8	 movzx	 ecx, al
  00022	85 c9		 test	 ecx, ecx
  00024	74 34		 je	 SHORT $LN2@GetIntExec

; 328  : 	{
; 329  : 		if (Fetch() != SQL_NO_DATA)

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Fetch@CDataBase@@QAEFXZ ; CDataBase::Fetch
  0002e	98		 cwde
  0002f	83 f8 64	 cmp	 eax, 100		; 00000064H
  00032	74 17		 je	 SHORT $LN3@GetIntExec

; 330  : 		{	
; 331  : 			Return = GetInt(1);

  00034	6a 01		 push	 1
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?GetInt@CDataBase@@QAEHH@Z ; CDataBase::GetInt
  0003e	89 45 f8	 mov	 DWORD PTR _Return$[ebp], eax

; 332  : 			this->Clear( );

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 333  : 		}

  00049	eb 0f		 jmp	 SHORT $LN2@GetIntExec
$LN3@GetIntExec:

; 334  : 		else
; 335  : 		{
; 336  : 			this->Clear( );

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 337  : 			Return = - 101;

  00053	c7 45 f8 9b ff
	ff ff		 mov	 DWORD PTR _Return$[ebp], -101 ; ffffff9bH
$LN2@GetIntExec:

; 338  : 		}
; 339  : 	}
; 340  : 
; 341  : 	return Return;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _Return$[ebp]

; 342  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?GetIntExec@CDataBase@@QAEHPAD@Z ENDP			; CDataBase::GetIntExec
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetStr@CDataBase@@QAEXPBDPAD@Z
_TEXT	SEGMENT
_n$ = -8						; size = 4
_this$ = -4						; size = 4
_sCol$ = 8						; size = 4
_buf$ = 12						; size = 4
?GetStr@CDataBase@@QAEXPBDPAD@Z PROC			; CDataBase::GetStr, COMDAT
; _this$ = ecx

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 309  : 	int n = -1;

  0000c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _n$[ebp], -1

; 310  : 
; 311  : 	n = FindCol(sCol);

  00013	8b 45 08	 mov	 eax, DWORD PTR _sCol$[ebp]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?FindCol@CDataBase@@QAEHPBD@Z ; CDataBase::FindCol
  0001f	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 312  : 
; 313  : 	if (n == -1)

  00022	83 7d f8 ff	 cmp	 DWORD PTR _n$[ebp], -1
  00026	75 11		 jne	 SHORT $LN2@GetStr

; 314  : 	{
; 315  : 		buf[0] = '\0';

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	6b c8 00	 imul	 ecx, eax, 0
  00030	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00033	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 316  : 	} 

  00037	eb 10		 jmp	 SHORT $LN1@GetStr
$LN2@GetStr:

; 317  : 	else 
; 318  : 	{
; 319  : 		GetStr(n, buf);

  00039	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00040	51		 push	 ecx
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?GetStr@CDataBase@@QAEXHPAD@Z ; CDataBase::GetStr
$LN1@GetStr:

; 320  : 	}
; 321  : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?GetStr@CDataBase@@QAEXPBDPAD@Z ENDP			; CDataBase::GetStr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetStr@CDataBase@@QAEXHPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nCol$ = 8						; size = 4
_buf$ = 12						; size = 4
?GetStr@CDataBase@@QAEXHPAD@Z PROC			; CDataBase::GetStr, COMDAT
; _this$ = ecx

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 291  : 	if (nCol > m_nCol)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  00013	39 4d 08	 cmp	 DWORD PTR _nCol$[ebp], ecx
  00016	7e 11		 jle	 SHORT $LN2@GetStr

; 292  : 	{
; 293  : 		buf[0] = '\0';

  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	6b c8 00	 imul	 ecx, eax, 0
  00020	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00023	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 294  : 		return;

  00027	eb 3a		 jmp	 SHORT $LN1@GetStr
$LN2@GetStr:

; 295  : 	}
; 296  : 
; 297  : 	if (m_lCol[nCol] == SQL_NULL_DATA) 

  00029	8b 45 08	 mov	 eax, DWORD PTR _nCol$[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 bc 81 40 77
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+30528], -1
  00037	75 11		 jne	 SHORT $LN3@GetStr

; 298  : 	{
; 299  : 		buf[0] = '\0';

  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	6b c8 00	 imul	 ecx, eax, 0
  00041	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00044	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 300  : 	} 

  00048	eb 19		 jmp	 SHORT $LN1@GetStr
$LN3@GetStr:

; 301  : 	else 
; 302  : 	{
; 303  : 		lstrcpy(buf, m_Col[nCol]);

  0004a	69 45 08 ff 00
	00 00		 imul	 eax, DWORD PTR _nCol$[ebp], 255
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8d 54 01 1a	 lea	 edx, DWORD PTR [ecx+eax+26]
  00058	52		 push	 edx
  00059	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0005c	50		 push	 eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8
$LN1@GetStr:

; 304  : 	}
; 305  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?GetStr@CDataBase@@QAEXHPAD@Z ENDP			; CDataBase::GetStr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetFloat@CDataBase@@QAEMPBD@Z
_TEXT	SEGMENT
_n$ = -12						; size = 4
_Return$ = -8						; size = 4
_this$ = -4						; size = 4
_sCol$ = 8						; size = 4
?GetFloat@CDataBase@@QAEMPBD@Z PROC			; CDataBase::GetFloat, COMDAT
; _this$ = ecx

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 276  : 	float Return	= - 102;

  0000c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2cc0000
  00014	f3 0f 11 45 f8	 movss	 DWORD PTR _Return$[ebp], xmm0

; 277  : 	int n			= -1;

  00019	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _n$[ebp], -1

; 278  : 
; 279  : 	n = FindCol(sCol);

  00020	8b 45 08	 mov	 eax, DWORD PTR _sCol$[ebp]
  00023	50		 push	 eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?FindCol@CDataBase@@QAEHPBD@Z ; CDataBase::FindCol
  0002c	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax

; 280  : 
; 281  : 	if (n != -1)

  0002f	83 7d f4 ff	 cmp	 DWORD PTR _n$[ebp], -1
  00033	74 0f		 je	 SHORT $LN2@GetFloat

; 282  : 	{
; 283  : 		Return = GetFloat(n);

  00035	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00038	50		 push	 eax
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?GetFloat@CDataBase@@QAEMH@Z ; CDataBase::GetFloat
  00041	d9 5d f8	 fstp	 DWORD PTR _Return$[ebp]
$LN2@GetFloat:

; 284  : 	}
; 285  : 
; 286  : 	return Return;

  00044	d9 45 f8	 fld	 DWORD PTR _Return$[ebp]

; 287  : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?GetFloat@CDataBase@@QAEMPBD@Z ENDP			; CDataBase::GetFloat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetFloat@CDataBase@@QAEMH@Z
_TEXT	SEGMENT
_Return$ = -8						; size = 4
_this$ = -4						; size = 4
_nCol$ = 8						; size = 4
?GetFloat@CDataBase@@QAEMH@Z PROC			; CDataBase::GetFloat, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 257  : 	float Return = - 102;

  0000c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2cc0000
  00014	f3 0f 11 45 f8	 movss	 DWORD PTR _Return$[ebp], xmm0

; 258  : 
; 259  : 	if (nCol <= m_nCol)

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  00020	39 4d 08	 cmp	 DWORD PTR _nCol$[ebp], ecx
  00023	7f 39		 jg	 SHORT $LN4@GetFloat

; 260  : 	{ 
; 261  : 		if (m_lCol[nCol] != SQL_NULL_DATA)

  00025	8b 45 08	 mov	 eax, DWORD PTR _nCol$[ebp]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	83 bc 81 40 77
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+30528], -1
  00033	74 1c		 je	 SHORT $LN3@GetFloat

; 262  : 		{
; 263  : 			Return = (float)atof(m_Col[nCol]);

  00035	69 45 08 ff 00
	00 00		 imul	 eax, DWORD PTR _nCol$[ebp], 255
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8d 54 01 1a	 lea	 edx, DWORD PTR [ecx+eax+26]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 _atof
  00049	83 c4 04	 add	 esp, 4
  0004c	d9 5d f8	 fstp	 DWORD PTR _Return$[ebp]

; 264  : 		}

  0004f	eb 0d		 jmp	 SHORT $LN4@GetFloat
$LN3@GetFloat:

; 265  : 		else
; 266  : 		{
; 267  : 			Return = - 100;

  00051	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2c80000
  00059	f3 0f 11 45 f8	 movss	 DWORD PTR _Return$[ebp], xmm0
$LN4@GetFloat:

; 268  : 		}
; 269  : 	}
; 270  : 
; 271  : 	return Return;

  0005e	d9 45 f8	 fld	 DWORD PTR _Return$[ebp]

; 272  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?GetFloat@CDataBase@@QAEMH@Z ENDP			; CDataBase::GetFloat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetInt64@CDataBase@@QAE_JPBD@Z
_TEXT	SEGMENT
_n$ = -16						; size = 4
_Return$ = -12						; size = 8
_this$ = -4						; size = 4
_sCol$ = 8						; size = 4
?GetInt64@CDataBase@@QAE_JPBD@Z PROC			; CDataBase::GetInt64, COMDAT
; _this$ = ecx

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 242  : 	__int64 Return = - 102;

  0000c	c7 45 f4 9a ff
	ff ff		 mov	 DWORD PTR _Return$[ebp], -102 ; ffffff9aH
  00013	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _Return$[ebp+4], -1

; 243  : 	int n		= -1;

  0001a	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _n$[ebp], -1

; 244  : 
; 245  : 	n = FindCol(sCol);

  00021	8b 45 08	 mov	 eax, DWORD PTR _sCol$[ebp]
  00024	50		 push	 eax
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?FindCol@CDataBase@@QAEHPBD@Z ; CDataBase::FindCol
  0002d	89 45 f0	 mov	 DWORD PTR _n$[ebp], eax

; 246  : 
; 247  : 	if (n != -1)

  00030	83 7d f0 ff	 cmp	 DWORD PTR _n$[ebp], -1
  00034	74 12		 je	 SHORT $LN2@GetInt64

; 248  : 	{
; 249  : 		Return = GetInt64(n);

  00036	8b 45 f0	 mov	 eax, DWORD PTR _n$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?GetInt64@CDataBase@@QAE_JH@Z ; CDataBase::GetInt64
  00042	89 45 f4	 mov	 DWORD PTR _Return$[ebp], eax
  00045	89 55 f8	 mov	 DWORD PTR _Return$[ebp+4], edx
$LN2@GetInt64:

; 250  : 	}
; 251  : 
; 252  : 	return Return;

  00048	8b 45 f4	 mov	 eax, DWORD PTR _Return$[ebp]
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _Return$[ebp+4]

; 253  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?GetInt64@CDataBase@@QAE_JPBD@Z ENDP			; CDataBase::GetInt64
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetInt64@CDataBase@@QAE_JH@Z
_TEXT	SEGMENT
_Return$ = -12						; size = 8
_this$ = -4						; size = 4
_nCol$ = 8						; size = 4
?GetInt64@CDataBase@@QAE_JH@Z PROC			; CDataBase::GetInt64, COMDAT
; _this$ = ecx

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 223  : 	__int64 Return = - 102;

  0000c	c7 45 f4 9a ff
	ff ff		 mov	 DWORD PTR _Return$[ebp], -102 ; ffffff9aH
  00013	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _Return$[ebp+4], -1

; 224  : 
; 225  : 	if (nCol <= m_nCol)

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  00021	39 4d 08	 cmp	 DWORD PTR _nCol$[ebp], ecx
  00024	7f 3d		 jg	 SHORT $LN2@GetInt64

; 226  : 	{
; 227  : 		if (m_lCol[nCol] != SQL_NULL_DATA)

  00026	8b 45 08	 mov	 eax, DWORD PTR _nCol$[ebp]
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 bc 81 40 77
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+30528], -1
  00034	74 1f		 je	 SHORT $LN3@GetInt64

; 228  : 		{
; 229  : 			Return = _atoi64(m_Col[nCol]);

  00036	69 45 08 ff 00
	00 00		 imul	 eax, DWORD PTR _nCol$[ebp], 255
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	8d 54 01 1a	 lea	 edx, DWORD PTR [ecx+eax+26]
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 __atoi64
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 f4	 mov	 DWORD PTR _Return$[ebp], eax
  00050	89 55 f8	 mov	 DWORD PTR _Return$[ebp+4], edx

; 230  : 		}

  00053	eb 0e		 jmp	 SHORT $LN2@GetInt64
$LN3@GetInt64:

; 231  : 		else
; 232  : 		{
; 233  : 			Return = - 100;

  00055	c7 45 f4 9c ff
	ff ff		 mov	 DWORD PTR _Return$[ebp], -100 ; ffffff9cH
  0005c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _Return$[ebp+4], -1
$LN2@GetInt64:

; 234  : 		}
; 235  : 	}
; 236  : 
; 237  : 	return Return;

  00063	8b 45 f4	 mov	 eax, DWORD PTR _Return$[ebp]
  00066	8b 55 f8	 mov	 edx, DWORD PTR _Return$[ebp+4]

; 238  : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
?GetInt64@CDataBase@@QAE_JH@Z ENDP			; CDataBase::GetInt64
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetInt@CDataBase@@QAEHPBD@Z
_TEXT	SEGMENT
_n$ = -12						; size = 4
_Return$ = -8						; size = 4
_this$ = -4						; size = 4
_sCol$ = 8						; size = 4
?GetInt@CDataBase@@QAEHPBD@Z PROC			; CDataBase::GetInt, COMDAT
; _this$ = ecx

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 	int Return = - 102;

  0000c	c7 45 f8 9a ff
	ff ff		 mov	 DWORD PTR _Return$[ebp], -102 ; ffffff9aH

; 209  : 	int n		= -1;

  00013	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _n$[ebp], -1

; 210  : 
; 211  : 	n = FindCol(sCol);

  0001a	8b 45 08	 mov	 eax, DWORD PTR _sCol$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?FindCol@CDataBase@@QAEHPBD@Z ; CDataBase::FindCol
  00026	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax

; 212  : 
; 213  : 	if (n != -1)

  00029	83 7d f4 ff	 cmp	 DWORD PTR _n$[ebp], -1
  0002d	74 0f		 je	 SHORT $LN2@GetInt

; 214  : 	{
; 215  : 		Return = GetInt(n);

  0002f	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00032	50		 push	 eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetInt@CDataBase@@QAEHH@Z ; CDataBase::GetInt
  0003b	89 45 f8	 mov	 DWORD PTR _Return$[ebp], eax
$LN2@GetInt:

; 216  : 	}
; 217  : 
; 218  : 	return Return;

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _Return$[ebp]

; 219  : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?GetInt@CDataBase@@QAEHPBD@Z ENDP			; CDataBase::GetInt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?GetInt@CDataBase@@QAEHH@Z
_TEXT	SEGMENT
_Return$ = -8						; size = 4
_this$ = -4						; size = 4
_nCol$ = 8						; size = 4
?GetInt@CDataBase@@QAEHH@Z PROC				; CDataBase::GetInt, COMDAT
; _this$ = ecx

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 	int Return = - 102;

  0000c	c7 45 f8 9a ff
	ff ff		 mov	 DWORD PTR _Return$[ebp], -102 ; ffffff9aH

; 190  : 
; 191  : 	if (nCol <= m_nCol)

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  0001a	39 4d 08	 cmp	 DWORD PTR _nCol$[ebp], ecx
  0001d	7f 33		 jg	 SHORT $LN2@GetInt

; 192  : 	{
; 193  : 		if (m_lCol[nCol] != SQL_NULL_DATA)

  0001f	8b 45 08	 mov	 eax, DWORD PTR _nCol$[ebp]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 bc 81 40 77
	00 00 ff	 cmp	 DWORD PTR [ecx+eax*4+30528], -1
  0002d	74 1c		 je	 SHORT $LN3@GetInt

; 194  : 		{
; 195  : 			Return = atoi(m_Col[nCol]);

  0002f	69 45 08 ff 00
	00 00		 imul	 eax, DWORD PTR _nCol$[ebp], 255
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8d 54 01 1a	 lea	 edx, DWORD PTR [ecx+eax+26]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 _atoi
  00043	83 c4 04	 add	 esp, 4
  00046	89 45 f8	 mov	 DWORD PTR _Return$[ebp], eax

; 196  : 		}

  00049	eb 07		 jmp	 SHORT $LN2@GetInt
$LN3@GetInt:

; 197  : 		else
; 198  : 		{
; 199  : 			Return = - 100;

  0004b	c7 45 f8 9c ff
	ff ff		 mov	 DWORD PTR _Return$[ebp], -100 ; ffffff9cH
$LN2@GetInt:

; 200  : 		}
; 201  : 	}
; 202  : 
; 203  : 	return Return;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _Return$[ebp]

; 204  : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?GetInt@CDataBase@@QAEHH@Z ENDP				; CDataBase::GetInt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?FindCol@CDataBase@@QAEHPBD@Z
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_iReturn$ = -8						; size = 4
_this$ = -4						; size = 4
_szName$ = 8						; size = 4
?FindCol@CDataBase@@QAEHPBD@Z PROC			; CDataBase::FindCol, COMDAT
; _this$ = ecx

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : 	int iReturn = -1;

  0000c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iReturn$[ebp], -1

; 175  : 
; 176  : 	for (int i = 0 ; i < m_nCol ; i++)

  00013	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@FindCol
$LN2@FindCol:
  0001c	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@FindCol:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  0002c	39 4d f4	 cmp	 DWORD PTR _i$1[ebp], ecx
  0002f	7d 29		 jge	 SHORT $LN3@FindCol

; 177  : 	{
; 178  : 		if (_stricmp(szName, (LPCTSTR)m_ColName[i]) == 0)

  00031	6b 45 f4 32	 imul	 eax, DWORD PTR _i$1[ebp], 50
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8d 94 01 b6 63
	00 00		 lea	 edx, DWORD PTR [ecx+eax+25526]
  0003f	52		 push	 edx
  00040	8b 45 08	 mov	 eax, DWORD PTR _szName$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 __stricmp
  00049	83 c4 08	 add	 esp, 8
  0004c	85 c0		 test	 eax, eax
  0004e	75 08		 jne	 SHORT $LN5@FindCol

; 179  : 		{
; 180  : 			iReturn = i;

  00050	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00053	89 45 f8	 mov	 DWORD PTR _iReturn$[ebp], eax

; 181  : 			break;

  00056	eb 02		 jmp	 SHORT $LN3@FindCol
$LN5@FindCol:

; 182  : 		}
; 183  : 	}

  00058	eb c2		 jmp	 SHORT $LN2@FindCol
$LN3@FindCol:

; 184  : 	return iReturn;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _iReturn$[ebp]

; 185  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?FindCol@CDataBase@@QAEHPBD@Z ENDP			; CDataBase::FindCol
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?ExecFormat@CDataBase@@QAA_NPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
_szQuery$ = 12						; size = 4
?ExecFormat@CDataBase@@QAA_NPBDZZ PROC			; CDataBase::ExecFormat, COMDAT

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 165  : 	va_start( m_pArgs , szQuery );

  00009	8d 45 10	 lea	 eax, DWORD PTR _szQuery$[ebp+4]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	89 81 30 7f 00
	00		 mov	 DWORD PTR [ecx+32560], eax

; 166  : 	vsprintf( m_szTemp , szQuery , m_pArgs );

  00015	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 88 30 7f 00
	00		 mov	 ecx, DWORD PTR [eax+32560]
  0001e	51		 push	 ecx
  0001f	8b 55 0c	 mov	 edx, DWORD PTR _szQuery$[ebp]
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00026	05 48 79 00 00	 add	 eax, 31048		; 00007948H
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _vsprintf
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 	va_end( m_pArgs );

  00034	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 80 30 7f 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+32560], 0

; 168  : 
; 169  : 	return Exec( m_szTemp );

  00041	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00044	05 48 79 00 00	 add	 eax, 31048		; 00007948H
  00049	50		 push	 eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?Exec@CDataBase@@QAE_NPBD@Z ; CDataBase::Exec

; 170  : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?ExecFormat@CDataBase@@QAA_NPBDZZ ENDP			; CDataBase::ExecFormat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?Exec@CDataBase@@QAE_NPBD@Z
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_bReturn$ = -5						; size = 1
_this$ = -4						; size = 4
_szQuery$ = 8						; size = 4
?Exec@CDataBase@@QAE_NPBD@Z PROC			; CDataBase::Exec, COMDAT
; _this$ = ecx

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 	bool bReturn = false;

  0000c	c6 45 fb 00	 mov	 BYTE PTR _bReturn$[ebp], 0

; 122  : 
; 123  : 	this->Clear( );

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 124  : 
; 125  : 	m_Return = SQLExecDirect(m_hStmt, (SQLCHAR *)szQuery, SQL_NTS);

  00018	6a fd		 push	 -3			; fffffffdH
  0001a	8b 45 08	 mov	 eax, DWORD PTR _szQuery$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 _SQLExecDirect@12
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 126  : 
; 127  : 	OnQuery( szQuery );

  00031	8b 45 08	 mov	 eax, DWORD PTR _szQuery$[ebp]
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00041	ff d1		 call	 ecx
  00043	83 c4 08	 add	 esp, 8

; 128  : 
; 129  : 	if((m_Return == SQL_SUCCESS) || (m_Return == SQL_SUCCESS_WITH_INFO) || (m_Return == SQL_NO_DATA))

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0004d	85 c9		 test	 ecx, ecx
  0004f	74 1c		 je	 SHORT $LN7@Exec
  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00058	83 f9 01	 cmp	 ecx, 1
  0005b	74 10		 je	 SHORT $LN7@Exec
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00064	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00067	0f 85 f3 00 00
	00		 jne	 $LN5@Exec
$LN7@Exec:

; 130  : 	{
; 131  : 		SQLRowCount(m_hStmt, & m_AfftedRowCount);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	83 c0 04	 add	 eax, 4
  00073	50		 push	 eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 _SQLRowCount@8

; 132  : 		SQLNumResultCols(m_hStmt, & m_nCol);

  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 18	 add	 eax, 24			; 00000018H
  00086	50		 push	 eax
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0008d	52		 push	 edx
  0008e	e8 00 00 00 00	 call	 _SQLNumResultCols@8

; 133  : 
; 134  : 		if (m_nCol > 100)

  00093	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00096	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  0009a	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0009d	7e 1a		 jle	 SHORT $LN8@Exec

; 135  : 		{
; 136  : 			OnError("Voc excedeu o nmero mximo de colunas!");

  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NLJNDEGA@Voc?j?5excedeu?5o?5n?zmero?5m?aximo?5de@
  000a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	52		 push	 edx
  000ad	8b 01		 mov	 eax, DWORD PTR [ecx]
  000af	ff d0		 call	 eax
  000b1	83 c4 08	 add	 esp, 8

; 137  : 		}

  000b4	e9 a5 00 00 00	 jmp	 $LN9@Exec
$LN8@Exec:

; 138  : 		else if(m_nCol == 0)

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  000c0	85 c9		 test	 ecx, ecx
  000c2	75 11		 jne	 SHORT $LN10@Exec

; 139  : 		{
; 140  : 			this->Clear( );

  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?Clear@CDataBase@@QAEXXZ ; CDataBase::Clear

; 141  : 
; 142  : 			bReturn = true;

  000cc	c6 45 fb 01	 mov	 BYTE PTR _bReturn$[ebp], 1

; 143  : 		}

  000d0	e9 89 00 00 00	 jmp	 $LN9@Exec
$LN10@Exec:

; 144  : 		else
; 145  : 		{
; 146  : 			for (int i = 0 ; i < m_nCol ; i++)

  000d5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  000dc	eb 09		 jmp	 SHORT $LN4@Exec
$LN2@Exec:
  000de	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  000e1	83 c0 01	 add	 eax, 1
  000e4	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Exec:
  000e7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	0f bf 48 18	 movsx	 ecx, WORD PTR [eax+24]
  000ee	39 4d f4	 cmp	 DWORD PTR _i$1[ebp], ecx
  000f1	7d 67		 jge	 SHORT $LN3@Exec

; 147  : 			{
; 148  : 				SQLBindCol(m_hStmt, i+1, SQL_C_CHAR, m_Col[i], 255, & m_lCol[i]);

  000f3	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	8d 94 81 40 77
	00 00		 lea	 edx, DWORD PTR [ecx+eax*4+30528]
  00100	52		 push	 edx
  00101	68 ff 00 00 00	 push	 255			; 000000ffH
  00106	69 45 f4 ff 00
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 255
  0010d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	8d 54 01 1a	 lea	 edx, DWORD PTR [ecx+eax+26]
  00114	52		 push	 edx
  00115	6a 01		 push	 1
  00117	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  0011a	83 c0 01	 add	 eax, 1
  0011d	50		 push	 eax
  0011e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00124	52		 push	 edx
  00125	e8 00 00 00 00	 call	 _SQLBindCol@24

; 149  : 				SQLDescribeCol(m_hStmt, i+1, m_ColName[i], 30, NULL, NULL, NULL, NULL, NULL);

  0012a	6a 00		 push	 0
  0012c	6a 00		 push	 0
  0012e	6a 00		 push	 0
  00130	6a 00		 push	 0
  00132	6a 00		 push	 0
  00134	6a 1e		 push	 30			; 0000001eH
  00136	6b 45 f4 32	 imul	 eax, DWORD PTR _i$1[ebp], 50
  0013a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	8d 94 01 b6 63
	00 00		 lea	 edx, DWORD PTR [ecx+eax+25526]
  00144	52		 push	 edx
  00145	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00148	83 c0 01	 add	 eax, 1
  0014b	50		 push	 eax
  0014c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00152	52		 push	 edx
  00153	e8 00 00 00 00	 call	 _SQLDescribeCol@36

; 150  : 			}

  00158	eb 84		 jmp	 SHORT $LN2@Exec
$LN3@Exec:

; 151  : 
; 152  : 			bReturn = true;

  0015a	c6 45 fb 01	 mov	 BYTE PTR _bReturn$[ebp], 1
$LN9@Exec:

; 153  : 		}
; 154  : 	}

  0015e	eb 08		 jmp	 SHORT $LN6@Exec
$LN5@Exec:

; 155  : 	else
; 156  : 	{
; 157  : 		Diagnostic();

  00160	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00163	e8 00 00 00 00	 call	 ?Diagnostic@CDataBase@@QAEXXZ ; CDataBase::Diagnostic
$LN6@Exec:

; 158  : 	}
; 159  : 
; 160  : 	return bReturn;

  00168	8a 45 fb	 mov	 al, BYTE PTR _bReturn$[ebp]

; 161  : }

  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 04 00	 ret	 4
?Exec@CDataBase@@QAE_NPBD@Z ENDP			; CDataBase::Exec
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?Reconnect@CDataBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reconnect@CDataBase@@QAE_NXZ PROC			; CDataBase::Reconnect, COMDAT
; _this$ = ecx

; 108  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 	if(m_strDnsName.length() == 0)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	81 c1 30 79 00
	00		 add	 ecx, 31024		; 00007930H
  00015	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  0001a	85 c0		 test	 eax, eax
  0001c	75 48		 jne	 SHORT $LN2@Reconnect

; 110  : 	{
; 111  : 		return Connect(m_strHost.c_str(), m_strDataBase.c_str(), m_strUser.c_str(), m_strPassword.c_str());

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 00 79 00
	00		 add	 ecx, 30976		; 00007900H
  00027	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0002c	50		 push	 eax
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	81 c1 e8 78 00
	00		 add	 ecx, 30952		; 000078e8H
  00036	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0003b	50		 push	 eax
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	81 c1 18 79 00
	00		 add	 ecx, 31000		; 00007918H
  00045	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 d0 78 00
	00		 add	 ecx, 30928		; 000078d0H
  00054	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00059	50		 push	 eax
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?Connect@CDataBase@@QAE_NPBD000@Z ; CDataBase::Connect
  00062	eb 19		 jmp	 SHORT $LN1@Reconnect

; 112  : 	}

  00064	eb 17		 jmp	 SHORT $LN1@Reconnect
$LN2@Reconnect:

; 113  : 	else
; 114  : 	{
; 115  : 		return Connect(m_strDnsName.c_str());

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	81 c1 30 79 00
	00		 add	 ecx, 31024		; 00007930H
  0006f	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00074	50		 push	 eax
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?Connect@CDataBase@@QAE_NPBD@Z ; CDataBase::Connect
$LN1@Reconnect:

; 116  : 	}
; 117  : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?Reconnect@CDataBase@@QAE_NXZ ENDP			; CDataBase::Reconnect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?Connect@CDataBase@@QAE_NPBD@Z
_TEXT	SEGMENT
_szSQLMsg$ = -2532					; size = 1000
_szSQLState$ = -1532					; size = 1000
_OutCon$ = -532						; size = 255
_InCon$ = -276						; size = 255
_cbOutCon$ = -20					; size = 2
_iRecored$ = -16					; size = 4
_bReturn$ = -9						; size = 1
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_szDnsName$ = 8						; size = 4
?Connect@CDataBase@@QAE_NPBD@Z PROC			; CDataBase::Connect, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 0b 00
	00		 sub	 esp, 2852		; 00000b24H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : 	bool bReturn						= false;

  00019	c6 45 f7 00	 mov	 BYTE PTR _bReturn$[ebp], 0

; 71   : 	int	iRecored						= 1;

  0001d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _iRecored$[ebp], 1

; 72   :     SQLSMALLINT cbOutCon				= 0;

  00024	33 c0		 xor	 eax, eax
  00026	66 89 45 ec	 mov	 WORD PTR _cbOutCon$[ebp], ax

; 73   : 
; 74   : 	SQLCHAR InCon[255]					= {0};

  0002a	68 ff 00 00 00	 push	 255			; 000000ffH
  0002f	6a 00		 push	 0
  00031	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _InCon$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _memset
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 75   : 	SQLCHAR OutCon[255]					= {0};

  00040	68 ff 00 00 00	 push	 255			; 000000ffH
  00045	6a 00		 push	 0
  00047	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _OutCon$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _memset
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 76   : 	SQLWCHAR szSQLState[500]	        = {0};

  00056	68 e8 03 00 00	 push	 1000			; 000003e8H
  0005b	6a 00		 push	 0
  0005d	8d 85 04 fa ff
	ff		 lea	 eax, DWORD PTR _szSQLState$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memset
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 77   : 	SQLWCHAR szSQLMsg[500]		        = {0};

  0006c	68 e8 03 00 00	 push	 1000			; 000003e8H
  00071	6a 00		 push	 0
  00073	8d 85 1c f6 ff
	ff		 lea	 eax, DWORD PTR _szSQLMsg$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _memset
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   : 
; 79   : 	SQLAllocHandle(SQL_HANDLE_DBC, m_hEnv, & m_hDbc);

  00082	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00085	83 c0 10	 add	 eax, 16			; 00000010H
  00088	50		 push	 eax
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0008f	52		 push	 edx
  00090	6a 02		 push	 2
  00092	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 80   : 
; 81   : 	wsprintf((char *)InCon, "DATABASE=%s;DRIVER=SQL Server;Server=(local);", szDnsName);

  00097	8b 45 08	 mov	 eax, DWORD PTR _szDnsName$[ebp]
  0009a	50		 push	 eax
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@NNKEKGNI@DATABASE?$DN?$CFs?$DLDRIVER?$DNSQL?5Server?$DLS@
  000a0	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _InCon$[ebp]
  000a6	51		 push	 ecx
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   : 
; 83   : 	OnMessage((char *)InCon);

  000b0	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _InCon$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000c3	ff d1		 call	 ecx
  000c5	83 c4 08	 add	 esp, 8

; 84   : 
; 85   : 	m_Return = SQLDriverConnect(m_hDbc, NULL, InCon, sizeof(InCon), OutCon,

  000c8	6a 00		 push	 0
  000ca	8d 45 ec	 lea	 eax, DWORD PTR _cbOutCon$[ebp]
  000cd	50		 push	 eax
  000ce	68 ff 00 00 00	 push	 255			; 000000ffH
  000d3	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _OutCon$[ebp]
  000d9	51		 push	 ecx
  000da	68 ff 00 00 00	 push	 255			; 000000ffH
  000df	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _InCon$[ebp]
  000e5	52		 push	 edx
  000e6	6a 00		 push	 0
  000e8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ee	51		 push	 ecx
  000ef	e8 00 00 00 00	 call	 _SQLDriverConnect@32
  000f4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000f7	66 89 42 08	 mov	 WORD PTR [edx+8], ax

; 86   : 		sizeof(OutCon), & cbOutCon, SQL_DRIVER_NOPROMPT);
; 87   : 
; 88   : 	if((m_Return == SQL_SUCCESS) || (m_Return == SQL_SUCCESS_WITH_INFO))

  000fb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fe	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00102	85 c9		 test	 ecx, ecx
  00104	74 0c		 je	 SHORT $LN3@Connect
  00106	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00109	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0010d	83 f9 01	 cmp	 ecx, 1
  00110	75 55		 jne	 SHORT $LN2@Connect
$LN3@Connect:

; 89   : 	{
; 90   : 		m_Return = SQLAllocHandle(SQL_HANDLE_STMT, m_hDbc, & m_hStmt);

  00112	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00115	83 c0 14	 add	 eax, 20			; 00000014H
  00118	50		 push	 eax
  00119	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0011f	52		 push	 edx
  00120	6a 03		 push	 3
  00122	e8 00 00 00 00	 call	 _SQLAllocHandle@12
  00127	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 91   : 
; 92   : 		if((m_Return == SQL_SUCCESS) || (m_Return == SQL_SUCCESS_WITH_INFO))

  0012e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00131	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00135	85 c9		 test	 ecx, ecx
  00137	74 0c		 je	 SHORT $LN6@Connect
  00139	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0013c	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00140	83 f9 01	 cmp	 ecx, 1
  00143	75 18		 jne	 SHORT $LN4@Connect
$LN6@Connect:

; 93   : 		{
; 94   : 			m_strDnsName = szDnsName;

  00145	8b 45 08	 mov	 eax, DWORD PTR _szDnsName$[ebp]
  00148	50		 push	 eax
  00149	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	81 c1 30 79 00
	00		 add	 ecx, 31024		; 00007930H
  00152	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 95   : 
; 96   : 			bReturn  = true;

  00157	c6 45 f7 01	 mov	 BYTE PTR _bReturn$[ebp], 1

; 97   : 		}

  0015b	eb 0a		 jmp	 SHORT $LN2@Connect
$LN4@Connect:

; 98   : 		else
; 99   : 		{
; 100  : 			m_hStmt = 0;

  0015d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00160	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
$LN2@Connect:

; 101  : 		}
; 102  : 	}
; 103  : 
; 104  : 	return bReturn;

  00167	8a 45 f7	 mov	 al, BYTE PTR _bReturn$[ebp]

; 105  : }

  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00170	33 cd		 xor	 ecx, ebp
  00172	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c2 04 00	 ret	 4
?Connect@CDataBase@@QAE_NPBD@Z ENDP			; CDataBase::Connect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?Connect@CDataBase@@QAE_NPBD000@Z
_TEXT	SEGMENT
_szSQLMsg$ = -2532					; size = 1000
_szSQLState$ = -1532					; size = 1000
_OutCon$ = -532						; size = 255
_InCon$ = -276						; size = 255
_cbOutCon$ = -20					; size = 2
_iRecored$ = -16					; size = 4
_bReturn$ = -9						; size = 1
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_szHost$ = 8						; size = 4
_szDataBase$ = 12					; size = 4
_szUser$ = 16						; size = 4
_szPassword$ = 20					; size = 4
?Connect@CDataBase@@QAE_NPBD000@Z PROC			; CDataBase::Connect, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 0b 00
	00		 sub	 esp, 2852		; 00000b24H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 	bool bReturn						= false;

  00019	c6 45 f7 00	 mov	 BYTE PTR _bReturn$[ebp], 0

; 28   : 	int	iRecored						= 1;

  0001d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _iRecored$[ebp], 1

; 29   :     SQLSMALLINT cbOutCon				= 0;

  00024	33 c0		 xor	 eax, eax
  00026	66 89 45 ec	 mov	 WORD PTR _cbOutCon$[ebp], ax

; 30   : 
; 31   : 	SQLCHAR InCon[255]					= {0};

  0002a	68 ff 00 00 00	 push	 255			; 000000ffH
  0002f	6a 00		 push	 0
  00031	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _InCon$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _memset
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32   : 	SQLCHAR OutCon[255]					= {0};

  00040	68 ff 00 00 00	 push	 255			; 000000ffH
  00045	6a 00		 push	 0
  00047	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _OutCon$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _memset
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33   : 	SQLWCHAR szSQLState[500]	        = {0};

  00056	68 e8 03 00 00	 push	 1000			; 000003e8H
  0005b	6a 00		 push	 0
  0005d	8d 85 04 fa ff
	ff		 lea	 eax, DWORD PTR _szSQLState$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memset
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 34   : 	SQLWCHAR szSQLMsg[500]		        = {0};

  0006c	68 e8 03 00 00	 push	 1000			; 000003e8H
  00071	6a 00		 push	 0
  00073	8d 85 1c f6 ff
	ff		 lea	 eax, DWORD PTR _szSQLMsg$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _memset
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 35   : 
; 36   : 	SQLAllocHandle(SQL_HANDLE_DBC, m_hEnv, & m_hDbc);

  00082	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00085	83 c0 10	 add	 eax, 16			; 00000010H
  00088	50		 push	 eax
  00089	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0008f	52		 push	 edx
  00090	6a 02		 push	 2
  00092	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 37   : 
; 38   : 	wsprintf((char *)InCon, "DRIVER=SQL Server;Server=%s;DATABASE=%s;UID=%s;PWD=%s;", szHost,

  00097	8b 45 14	 mov	 eax, DWORD PTR _szPassword$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d 10	 mov	 ecx, DWORD PTR _szUser$[ebp]
  0009e	51		 push	 ecx
  0009f	8b 55 0c	 mov	 edx, DWORD PTR _szDataBase$[ebp]
  000a2	52		 push	 edx
  000a3	8b 45 08	 mov	 eax, DWORD PTR _szHost$[ebp]
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@KALJNAIN@DRIVER?$DNSQL?5Server?$DLServer?$DN?$CFs?$DLDAT@
  000ac	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _InCon$[ebp]
  000b2	51		 push	 ecx
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000b9	83 c4 18	 add	 esp, 24			; 00000018H

; 39   : 		szDataBase, szUser, szPassword);
; 40   : 
; 41   : 	OnMessage((char *)InCon);

  000bc	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _InCon$[ebp]
  000c2	50		 push	 eax
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000cf	ff d1		 call	 ecx
  000d1	83 c4 08	 add	 esp, 8

; 42   : 
; 43   : 	m_Return = SQLDriverConnect(m_hDbc, NULL, InCon, sizeof(InCon), OutCon,

  000d4	6a 00		 push	 0
  000d6	8d 45 ec	 lea	 eax, DWORD PTR _cbOutCon$[ebp]
  000d9	50		 push	 eax
  000da	68 ff 00 00 00	 push	 255			; 000000ffH
  000df	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _OutCon$[ebp]
  000e5	51		 push	 ecx
  000e6	68 ff 00 00 00	 push	 255			; 000000ffH
  000eb	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _InCon$[ebp]
  000f1	52		 push	 edx
  000f2	6a 00		 push	 0
  000f4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000fa	51		 push	 ecx
  000fb	e8 00 00 00 00	 call	 _SQLDriverConnect@32
  00100	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00103	66 89 42 08	 mov	 WORD PTR [edx+8], ax

; 44   : 		sizeof(OutCon), & cbOutCon, SQL_DRIVER_NOPROMPT);
; 45   : 
; 46   : 	if((m_Return == SQL_SUCCESS) || (m_Return == SQL_SUCCESS_WITH_INFO))

  00107	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0010e	85 c9		 test	 ecx, ecx
  00110	74 10		 je	 SHORT $LN3@Connect
  00112	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00115	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00119	83 f9 01	 cmp	 ecx, 1
  0011c	0f 85 8b 00 00
	00		 jne	 $LN2@Connect
$LN3@Connect:

; 47   : 	{
; 48   : 		m_Return = SQLAllocHandle(SQL_HANDLE_STMT, m_hDbc, & m_hStmt);

  00122	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00125	83 c0 14	 add	 eax, 20			; 00000014H
  00128	50		 push	 eax
  00129	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0012f	52		 push	 edx
  00130	6a 03		 push	 3
  00132	e8 00 00 00 00	 call	 _SQLAllocHandle@12
  00137	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 49   : 
; 50   : 		if((m_Return == SQL_SUCCESS) || (m_Return == SQL_SUCCESS_WITH_INFO))

  0013e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00141	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00145	85 c9		 test	 ecx, ecx
  00147	74 0c		 je	 SHORT $LN6@Connect
  00149	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0014c	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00150	83 f9 01	 cmp	 ecx, 1
  00153	75 4e		 jne	 SHORT $LN4@Connect
$LN6@Connect:

; 51   : 		{
; 52   : 			m_strHost = szHost;

  00155	8b 45 08	 mov	 eax, DWORD PTR _szHost$[ebp]
  00158	50		 push	 eax
  00159	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	81 c1 d0 78 00
	00		 add	 ecx, 30928		; 000078d0H
  00162	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 53   : 			m_strDataBase = szDataBase;

  00167	8b 45 0c	 mov	 eax, DWORD PTR _szDataBase$[ebp]
  0016a	50		 push	 eax
  0016b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	81 c1 18 79 00
	00		 add	 ecx, 31000		; 00007918H
  00174	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 54   : 			m_strUser = szUser;

  00179	8b 45 10	 mov	 eax, DWORD PTR _szUser$[ebp]
  0017c	50		 push	 eax
  0017d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	81 c1 e8 78 00
	00		 add	 ecx, 30952		; 000078e8H
  00186	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 55   : 			m_strPassword = szPassword;

  0018b	8b 45 14	 mov	 eax, DWORD PTR _szPassword$[ebp]
  0018e	50		 push	 eax
  0018f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00192	81 c1 00 79 00
	00		 add	 ecx, 30976		; 00007900H
  00198	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 56   : 
; 57   : 			bReturn  = true;

  0019d	c6 45 f7 01	 mov	 BYTE PTR _bReturn$[ebp], 1

; 58   : 		}

  001a1	eb 0a		 jmp	 SHORT $LN2@Connect
$LN4@Connect:

; 59   : 		else
; 60   : 		{
; 61   : 			m_hStmt = 0;

  001a3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a6	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
$LN2@Connect:

; 62   : 		}
; 63   : 	}
; 64   : 
; 65   : 	return bReturn;

  001ad	8a 45 f7	 mov	 al, BYTE PTR _bReturn$[ebp]

; 66   : }

  001b0	5f		 pop	 edi
  001b1	5e		 pop	 esi
  001b2	5b		 pop	 ebx
  001b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b6	33 cd		 xor	 ecx, ebp
  001b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c2 10 00	 ret	 16			; 00000010H
?Connect@CDataBase@@QAE_NPBD000@Z ENDP			; CDataBase::Connect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ??1CDataBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CDataBase@@QAE@XZ PROC				; CDataBase::~CDataBase, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDataBase@@6B@

; 19   : 	if (m_hStmt)SQLFreeHandle(SQL_HANDLE_STMT, m_hStmt);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0001c	74 0e		 je	 SHORT $LN2@CDataBase
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00024	51		 push	 ecx
  00025	6a 03		 push	 3
  00027	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$LN2@CDataBase:

; 20   : 	if (m_hDbc) SQLDisconnect(m_hDbc);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00033	74 0c		 je	 SHORT $LN3@CDataBase
  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 _SQLDisconnect@4
$LN3@CDataBase:

; 21   : 	if (m_hDbc) SQLFreeHandle(SQL_HANDLE_DBC, m_hDbc);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00048	74 0e		 je	 SHORT $LN4@CDataBase
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00050	51		 push	 ecx
  00051	6a 02		 push	 2
  00053	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$LN4@CDataBase:

; 22   : 	if (m_hEnv) SQLFreeHandle(SQL_HANDLE_ENV, m_hEnv);

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0005f	74 0e		 je	 SHORT $LN1@CDataBase
  00061	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00067	51		 push	 ecx
  00068	6a 01		 push	 1
  0006a	e8 00 00 00 00	 call	 _SQLFreeHandle@8
$LN1@CDataBase:

; 23   : }

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	81 c1 30 79 00
	00		 add	 ecx, 31024		; 00007930H
  00078	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	81 c1 18 79 00
	00		 add	 ecx, 31000		; 00007918H
  00086	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	81 c1 00 79 00
	00		 add	 ecx, 30976		; 00007900H
  00094	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	81 c1 e8 78 00
	00		 add	 ecx, 30952		; 000078e8H
  000a2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	81 c1 d0 78 00
	00		 add	 ecx, 30928		; 000078d0H
  000b0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
??1CDataBase@@QAE@XZ ENDP				; CDataBase::~CDataBase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ??0CDataBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CDataBase@@QAE@XZ PROC				; CDataBase::CDataBase, COMDAT
; _this$ = ecx

; 4    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDataBase@@6B@
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	81 c1 d0 78 00
	00		 add	 ecx, 30928		; 000078d0H
  0001e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 e8 78 00
	00		 add	 ecx, 30952		; 000078e8H
  0002c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 c1 00 79 00
	00		 add	 ecx, 30976		; 00007900H
  0003a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	81 c1 18 79 00
	00		 add	 ecx, 31000		; 00007918H
  00048	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	81 c1 30 79 00
	00		 add	 ecx, 31024		; 00007930H
  00056	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 5    : 	m_SQLErrorCount		= 1;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 80 24 7f 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+32548], 1

; 6    : 	m_AfftedRowCount 	= -1;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 7    : 	m_Return			= SQL_SUCCESS;

  00072	33 c0		 xor	 eax, eax
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 8    : 
; 9    : 	memset(m_szTemp, 0, sizeof(m_szTemp));

  0007b	68 f4 01 00 00	 push	 500			; 000001f4H
  00080	6a 00		 push	 0
  00082	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00085	05 48 79 00 00	 add	 eax, 31048		; 00007948H
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _memset
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10   : 	memset(m_szMsg,0 , sizeof(m_szMsg));

  00093	68 f4 01 00 00	 push	 500			; 000001f4H
  00098	6a 00		 push	 0
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	05 3c 7b 00 00	 add	 eax, 31548		; 00007b3cH
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 _memset
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11   : 	memset(m_SqlState, 0, sizeof(m_SqlState));

  000ab	68 f4 01 00 00	 push	 500			; 000001f4H
  000b0	6a 00		 push	 0
  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	05 30 7d 00 00	 add	 eax, 32048		; 00007d30H
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _memset
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12   : 
; 13   : 	SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, & m_hEnv);

  000c3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c9	50		 push	 eax
  000ca	6a 00		 push	 0
  000cc	6a 01		 push	 1
  000ce	e8 00 00 00 00	 call	 _SQLAllocHandle@12

; 14   : 	SQLSetEnvAttr(m_hEnv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3,SQL_IS_INTEGER);

  000d3	6a fa		 push	 -6			; fffffffaH
  000d5	6a 03		 push	 3
  000d7	68 c8 00 00 00	 push	 200			; 000000c8H
  000dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000e2	51		 push	 ecx
  000e3	e8 00 00 00 00	 call	 _SQLSetEnvAttr@16

; 15   : }

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
??0CDataBase@@QAE@XZ ENDP				; CDataBase::CDataBase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4328 :     const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4330 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4324 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4325 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4326 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T2 = -89						; size = 1
__Al$3 = -24						; size = 4
__Ptr$4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4299 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 4300 :         _Mypair._Myval2._Orphan_all();

  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4301 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00033	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	74 35		 je	 SHORT $LN2@Tidy_deall

; 4302 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  00042	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	89 4d ec	 mov	 DWORD PTR __Ptr$4[ebp], ecx

; 4303 :             auto& _Al          = _Getal();

  0004a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00052	89 45 e8	 mov	 DWORD PTR __Al$3[ebp], eax

; 4304 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  0005e	83 c4 04	 add	 esp, 4

; 4305 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00061	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00067	83 c1 01	 add	 ecx, 1
  0006a	51		 push	 ecx
  0006b	8b 55 ec	 mov	 edx, DWORD PTR __Ptr$4[ebp]
  0006e	52		 push	 edx
  0006f	8b 4d e8	 mov	 ecx, DWORD PTR __Al$3[ebp]
  00072	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 4306 :         }
; 4307 : 
; 4308 :         _Mypair._Myval2._Mysize = 0;

  00077	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4309 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00081	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00084	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4310 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4311 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0008b	c6 45 a7 00	 mov	 BYTE PTR $T2[ebp], 0
  0008f	8d 45 a7	 lea	 eax, DWORD PTR $T2[ebp]
  00092	50		 push	 eax
  00093	b9 01 00 00 00	 mov	 ecx, 1
  00098	6b d1 00	 imul	 edx, ecx, 0
  0009b	03 55 f0	 add	 edx, DWORD PTR _this$[ebp]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  000a4	83 c4 08	 add	 esp, 8

; 4312 :     }

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
  000b9	cc		 int	 3
  000ba	cc		 int	 3
  000bb	cc		 int	 3
  000bc	cc		 int	 3
  000bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4292 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4293 :         _Mypair._Myval2._Mysize = 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00020	c6 45 bb 00	 mov	 BYTE PTR $T1[ebp], 0
  00024	8d 45 bb	 lea	 eax, DWORD PTR $T1[ebp]
  00027	50		 push	 eax
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	6b d1 00	 imul	 edx, ecx, 0
  00030	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00039	83 c4 08	 add	 esp, 8

; 4297 :     }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4213 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4214 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00014	50		 push	 eax
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4215 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4200 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4201 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  0000c	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000f	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4202 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00012	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00015	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00018	76 05		 jbe	 SHORT $LN2@Calculate_

; 4203 :             return _Max;

  0001a	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001d	eb 31		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4204 :         }
; 4205 : 
; 4206 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00022	d1 e8		 shr	 eax, 1
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00027	2b c8		 sub	 ecx, eax
  00029	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  0002c	76 05		 jbe	 SHORT $LN3@Calculate_

; 4207 :             return _Max;

  0002e	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	eb 1d		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4208 :         }
; 4209 : 
; 4210 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00033	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00036	d1 e8		 shr	 eax, 1
  00038	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  0003b	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
  0003e	8d 4d b8	 lea	 ecx, DWORD PTR $T1[ebp]
  00041	51		 push	 ecx
  00042	8d 55 fc	 lea	 edx, DWORD PTR __Masked$[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  0004b	83 c4 08	 add	 esp, 8
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4211 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
$T3 = -80						; size = 4
__Storage_max$ = -12					; size = 4
__Alloc_max$ = -8					; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3689 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3690 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 f8	 mov	 DWORD PTR __Alloc_max$[ebp], eax

; 3691 :         const size_type _Storage_max = // can always store small string

  00020	c7 45 b0 10 00
	00 00		 mov	 DWORD PTR $T3[ebp], 16	; 00000010H
  00027	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  0002a	50		 push	 eax
  0002b	8d 4d f8	 lea	 ecx, DWORD PTR __Alloc_max$[ebp]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00034	83 c4 08	 add	 esp, 8
  00037	8b 10		 mov	 edx, DWORD PTR [eax]
  00039	89 55 f4	 mov	 DWORD PTR __Storage_max$[ebp], edx

; 3692 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3693 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0003f	83 e8 01	 sub	 eax, 1
  00042	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax
  00045	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  0004a	89 45 a8	 mov	 DWORD PTR $T1[ebp], eax
  0004d	8d 4d ac	 lea	 ecx, DWORD PTR $T2[ebp]
  00050	51		 push	 ecx
  00051	8d 55 a8	 lea	 edx, DWORD PTR $T1[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  0005a	83 c4 08	 add	 esp, 8
  0005d	8b 00		 mov	 eax, DWORD PTR [eax]

; 3694 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3695 :         );
; 3696 :     }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 3681 :     _NODISCARD size_type length() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3682 :         return _Mypair._Myval2._Mysize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 3683 :     }

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3667 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3668 :         return _Mypair._Myval2._Myptr();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 3669 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2983 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2984 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  0001e	83 c4 04	 add	 esp, 4
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00025	51		 push	 ecx
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2985 :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -74						; size = 1
$T2 = -73						; size = 1
__Old_ptr$3 = -8					; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2964 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2965 :         // assign [_Ptr, _Ptr + _Count)
; 2966 :         if (_Count <= _Mypair._Myval2._Myres) {

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00012	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00015	77 44		 ja	 SHORT $LN2@assign

; 2967 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001f	89 45 f8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax

; 2968 :             _Mypair._Myval2._Mysize = _Count;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00028	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2969 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f8	 mov	 edx, DWORD PTR __Old_ptr$3[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Narrow_char_traits<char,int>::move
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2970 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003f	c6 45 b7 00	 mov	 BYTE PTR $T2[ebp], 0
  00043	8d 45 b7	 lea	 eax, DWORD PTR $T2[ebp]
  00046	50		 push	 eax
  00047	8b 4d f8	 mov	 ecx, DWORD PTR __Old_ptr$3[ebp]
  0004a	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00053	83 c4 08	 add	 esp, 8

; 2971 :             return *this;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	eb 1a		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 2972 :         }
; 2973 : 
; 2974 :         return _Reallocate_for(

  0005b	33 c0		 xor	 eax, eax
  0005d	88 45 b6	 mov	 BYTE PTR $T1[ebp], al
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00063	51		 push	 ecx
  00064	0f b6 55 b6	 movzx	 edx, BYTE PTR $T1[ebp]
  00068	52		 push	 edx
  00069	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 2975 :             _Count,
; 2976 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2977 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2978 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2979 :             },
; 2980 :             _Ptr);
; 2981 :     }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2799 :     basic_string& operator=(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2800 :         return assign(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2801 :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2722 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2723 :         _Tidy_deallocate();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2724 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2725 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2726 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2727 :         _Mypair._Myval2._Myproxy = nullptr;
; 2728 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2729 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2730 :     }

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -82						; size = 1
$T3 = -81						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2287 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	0f b6 45 af	 movzx	 eax, BYTE PTR $T3[ebp]
  0002f	50		 push	 eax
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2288 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00038	8d 45 ae	 lea	 eax, DWORD PTR $T2[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2289 :         _Tidy_init();

  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2290 :     }

  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2180 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2178 :         _Bxty() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -72						; size = 4
_this$ = -4						; size = 4
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2152 :     bool _Large_string_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2153 :         return _BUF_SIZE <= _Myres;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00013	72 09		 jb	 SHORT $LN3@Large_stri
  00015	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@Large_stri
$LN3@Large_stri:
  0001e	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@Large_stri:
  00025	8a 45 b8	 mov	 al, BYTE PTR tv66[ebp]

; 2154 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2143 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2144 :         const value_type* _Result = _Bx._Buf;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2145 :         if (_Large_string_engaged()) {

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 11		 je	 SHORT $LN2@Myptr

; 2146 :             _Result = _Unfancy(_Bx._Ptr);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2147 :         }
; 2148 : 
; 2149 :         return _Result;

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2150 :     }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2134 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2135 :         value_type* _Result = _Bx._Buf;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2136 :         if (_Large_string_engaged()) {

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 11		 je	 SHORT $LN2@Myptr

; 2137 :             _Result = _Unfancy(_Bx._Ptr);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0002c	83 c4 04	 add	 esp, 4
  0002f	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2138 :         }
; 2139 : 
; 2140 :         return _Result;

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2141 :     }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	83 c8 ff	 or	 eax, -1

; 704  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YAII@Z ; std::_Get_size_of_n<1>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00019	83 c4 08	 add	 esp, 8

; 804  :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2200 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2201 :     _Xlength_error("string too long");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  0000e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2202 : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 372  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 373  :         _Left = _Right;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 10		 mov	 BYTE PTR [eax], dl

; 374  :     }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::move, COMDAT

; 361  :         const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 362  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 363  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 364  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?move@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Narrow_char_traits<char,int>::copy, COMDAT

; 326  :         const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 327  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 328  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _memcpy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 329  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?copy@?$_Narrow_char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Narrow_char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 305  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 306  :         // find length of null-terminated string
; 307  : #if _HAS_CXX17
; 308  : #ifdef __cpp_char8_t
; 309  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 310  : #if _HAS_U8_INTRINSICS
; 311  :             return __builtin_u8strlen(_First);
; 312  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 313  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 314  : #endif // _HAS_U8_INTRINSICS
; 315  :         } else
; 316  : #endif // __cpp_char8_t
; 317  :         {
; 318  :             return __builtin_strlen(_First);
; 319  :         }
; 320  : #else // _HAS_CXX17
; 321  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4

; 322  : #endif // _HAS_CXX17
; 323  :     }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1067 :     void _Alloc_proxy(const _Fake_allocator&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1065 :     void _Orphan_all() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 990  : _NODISCARD constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 991  :     // convert size_t to size_t, unchanged
; 992  :     return _Len;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 993  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -16					; size = 4
__Min_back_shift$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 c1 23	 add	 ecx, 35			; 00000023H
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00014	89 0a		 mov	 DWORD PTR [edx], ecx

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00016	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 4d fc	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001e	b8 04 00 00 00	 mov	 eax, 4
  00023	6b c8 ff	 imul	 ecx, eax, -1
  00026	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00029	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002c	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002f	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00036	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  0003e	89 4d f0	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00041	83 7d f0 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00045	72 08		 jb	 SHORT $LN7@Adjust_man
  00047	83 7d f0 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  0004b	77 02		 ja	 SHORT $LN7@Adjust_man
  0004d	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00054	33 c0		 xor	 eax, eax
  00056	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00058	33 c0		 xor	 eax, eax
  0005a	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  00062	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 76   :     __declspec(allocator) static void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 77   :         return ::operator new(_Bytes);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00012	83 c4 04	 add	 esp, 4

; 78   :     }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 554  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 555  :         return INT_MAX;

  00009	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 556  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -76						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 321  :     _THROW(bad_array_new_length{});

  00009	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  00011	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00016	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :         : bad_alloc("bad array new length")

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :         : exception(_Message, 1)

  0000c	6a 01		 push	 1
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	74 0b		 je	 SHORT $LN3@what
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 b8	 mov	 DWORD PTR tv69[ebp], edx
  0001e	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  00020	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00027	8b 45 b8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ___std_exception_destroy
  00021	83 c4 04	 add	 esp, 4

; 91   :     }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c0 04	 add	 eax, 4
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0002c	83 c1 04	 add	 ecx, 4
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ___std_exception_copy
  00035	83 c4 08	 add	 esp, 8

; 74   :     }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00028	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 68   :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1477 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1478 :         #pragma warning(push)
; 1479 :         #pragma warning(disable: 4996) // Deprecation
; 1480 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);

  00009	8b 45 10	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	6a ff		 push	 -1
  00015	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 __vsnprintf_l
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 1481 :         #pragma warning(pop)
; 1482 :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 168  :         (void)_Size;
; 169  :         return _Where;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\Database.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
