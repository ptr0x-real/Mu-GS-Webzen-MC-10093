; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?g_btCastleEntranceMapXY@@3QAY03$$CBEA DB 0dH		; g_btCastleEntranceMapXY
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
?g_btCastleBridgeMapXY@@3QAY03$$CBEA DB 0dH		; g_btCastleBridgeMapXY
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
?g_btCastleDoorMapXY@@3QAY123$$CBEA DB 0dH		; g_btCastleDoorMapXY
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
?g_iQuestWinExpendZEN@@3QAY01$$CBHA DD 04e20H		; g_iQuestWinExpendZEN
	DD	02710H
	DD	0c350H
	DD	061a8H
	DD	0186a0H
	DD	0c350H
	DD	0249f0H
	DD	013880H
	DD	030d40H
	DD	0186a0H
	DD	03d090H
	DD	01d4c0H
	DD	03d090H
	DD	01d4c0H
?g_iBC_ChoasMixSuccessRate@@3QBHB DD 050H		; g_iBC_ChoasMixSuccessRate
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
?g_iBC_ChoasMixMoney@@3QBHB DD 0c350H			; g_iBC_ChoasMixMoney
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	0927c0H
	DD	0cf850H
?g_iBC_EventScore_Fail@@3QBHB DD 0fffffed4H		; g_iBC_EventScore_Fail
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
?g_iBC_EventScore@@3QAY04$$CBHA DD 0258H		; g_iBC_EventScore
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
?g_iBC_Party_EventPoint@@3QBHB DD 05H			; g_iBC_Party_EventPoint
	DD	0aH
	DD	0fH
	DD	014H
	DD	01eH
?g_iBC_Add_Exp@@3QAY03$$CBHA DD 04e20H			; g_iBC_Add_Exp
	DD	04e20H
	DD	01388H
	DD	0a0H
	DD	0c350H
	DD	0c350H
	DD	02710H
	DD	0b4H
	DD	013880H
	DD	013880H
	DD	03a98H
	DD	0c8H
	DD	015f90H
	DD	015f90H
	DD	04e20H
	DD	0dcH
	DD	0186a0H
	DD	0186a0H
	DD	061a8H
	DD	0f0H
	DD	01adb0H
	DD	01adb0H
	DD	07530H
	DD	0104H
	DD	01d4c0H
	DD	01d4c0H
	DD	088b8H
	DD	0118H
?g_iBC_MONSTER_CHANGE_STATE@@3QAY02$$CBHA DD 0aH	; g_iBC_MONSTER_CHANGE_STATE
	DD	014H
	DD	0ffffffecH
	DD	014H
	DD	028H
	DD	0ffffffceH
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?_ARGB@@YAKEEEE@Z				; _ARGB
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?CheckChoasMixItem@CBloodCastle@@QAEHH@Z	; CBloodCastle::CheckChoasMixItem
PUBLIC	?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::BloodCastleChaosMix
PUBLIC	?AddExperience@CBloodCastle@@QAE_NHH@Z		; CBloodCastle::AddExperience
PUBLIC	?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardEXP
PUBLIC	?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardZEN
PUBLIC	?DropChaosGem@CBloodCastle@@QAEXHH@Z		; CBloodCastle::DropChaosGem
PUBLIC	?SendRewardScore@CBloodCastle@@QAEXHHHH@Z	; CBloodCastle::SendRewardScore
PUBLIC	?GiveReward_Win@CBloodCastle@@QAEXHH@Z		; CBloodCastle::GiveReward_Win
PUBLIC	?GiveReward_Fail@CBloodCastle@@QAEXH@Z		; CBloodCastle::GiveReward_Fail
PUBLIC	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
PUBLIC	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z	; CBloodCastle::SearchUserDropQuestItem
PUBLIC	?SetUserState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetUserState
PUBLIC	?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo
PUBLIC	?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo
PUBLIC	?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleDoorBlockInfo
PUBLIC	?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z	; CBloodCastle::SendAllUserAnyMsg
PUBLIC	?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z	; CBloodCastle::SendBridgeAnyMsg
PUBLIC	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z	; CBloodCastle::SendNoticeMessage
PUBLIC	?SendNoticeScore@CBloodCastle@@QAEXH@Z		; CBloodCastle::SendNoticeScore
PUBLIC	?SendNoticeState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SendNoticeState
PUBLIC	?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserBridgeMember
PUBLIC	?BlockCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleEntrance
PUBLIC	?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleEntrance
PUBLIC	?BlockCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleBridge
PUBLIC	?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleBridge
PUBLIC	?BlockCastleDoor@CBloodCastle@@QAEXH@Z		; CBloodCastle::BlockCastleDoor
PUBLIC	?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleDoor
PUBLIC	?SetMonsterKillCount@CBloodCastle@@QAEXH@Z	; CBloodCastle::SetMonsterKillCount
PUBLIC	?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillCount
PUBLIC	?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillSuccess
PUBLIC	?CheckBossKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillCount
PUBLIC	?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillSuccess
PUBLIC	?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckEveryUserDie
PUBLIC	?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckAngelKingExist
PUBLIC	?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetWhoGotUltimateWeapon
PUBLIC	?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentLiveUserCount
PUBLIC	?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z	; CBloodCastle::DropItemDirectly
PUBLIC	?ClearMonster@CBloodCastle@@QAEXH_N@Z		; CBloodCastle::ClearMonster
PUBLIC	?SetMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetMonster
PUBLIC	?SetBossMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetBossMonster
PUBLIC	?SetSaintStatue@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetSaintStatue
PUBLIC	?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z	; CBloodCastle::LeaveUserBridge
PUBLIC	?EnterUserBridge@CBloodCastle@@QAEHHH@Z		; CBloodCastle::EnterUserBridge
PUBLIC	?LevelUp@CBloodCastle@@QAEHHHH@Z		; CBloodCastle::LevelUp
PUBLIC	?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z	; CBloodCastle::CheckUsersOnConnect
PUBLIC	?GetCurrentState@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetCurrentState
PUBLIC	?GetRemainTime@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetRemainTime
PUBLIC	?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentRemainSec
PUBLIC	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z		; CBloodCastle::CheckEnterLevel
PUBLIC	?CheckEnterItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckEnterItem
PUBLIC	?CheckQuestItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckQuestItem
PUBLIC	?CheckWalk@CBloodCastle@@QAE_NHHH@Z		; CBloodCastle::CheckWalk
PUBLIC	?CheckCanEnter@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanEnter
PUBLIC	?CheckCanParty@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanParty
PUBLIC	?CheckPlayStart@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPlayStart
PUBLIC	?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ; CBloodCastle::CheckQuestItemSerial
PUBLIC	?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckUserHaveUlimateWeapon
PUBLIC	?CheckWinnerExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerExist
PUBLIC	?CheckWinnerValid@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerValid
PUBLIC	?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserWinnerParty
PUBLIC	?CheckPartyExist@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPartyExist
PUBLIC	?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
PUBLIC	?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::SetBridgeWinner
PUBLIC	?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
PUBLIC	?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
PUBLIC	?ChangeMonsterState@CBloodCastle@@QAEXHH@Z	; CBloodCastle::ChangeMonsterState
PUBLIC	?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateWin
PUBLIC	?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateFail
PUBLIC	?Run@CBloodCastle@@QAEXXZ			; CBloodCastle::Run
PUBLIC	?Init@CBloodCastle@@QAEX_N@Z			; CBloodCastle::Init
PUBLIC	?Load@CBloodCastle@@QAEXPAD@Z			; CBloodCastle::Load
PUBLIC	?LoadItemDropRate@CBloodCastle@@QAEXXZ		; CBloodCastle::LoadItemDropRate
PUBLIC	?SetState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetState
PUBLIC	??0CBloodCastle@@QAE@XZ				; CBloodCastle::CBloodCastle
PUBLIC	??1CBloodCastle@@UAE@XZ				; CBloodCastle::~CBloodCastle
PUBLIC	??0?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >
PUBLIC	?deallocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEXQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@QAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::max_size
PUBLIC	??0?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >
PUBLIC	??1?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::~list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >
PUBLIC	?begin@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::begin
PUBLIC	?size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::size
PUBLIC	?max_size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::max_size
PUBLIC	?push_back@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXABUBLOODCASTLE_REWARD@@@Z ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::push_back
PUBLIC	?clear@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::clear
PUBLIC	?_Tidy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal
PUBLIC	?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal
PUBLIC	??0?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >
PUBLIC	?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >::_Orphan_non_end
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Get_first
PUBLIC	?CheckSync@CBloodCastle@@IAEXH@Z		; CBloodCastle::CheckSync
PUBLIC	?ClearBridgeData@CBloodCastle@@IAEXH@Z		; CBloodCastle::ClearBridgeData
PUBLIC	?ProcState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_None
PUBLIC	?ProcState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_Closed
PUBLIC	?ProcState_Playing@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_Playing
PUBLIC	?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_PlayEnd
PUBLIC	?SetState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_None
PUBLIC	?SetState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Closed
PUBLIC	?SetState_Playing@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Playing
PUBLIC	?SetState_PlayEnd@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_PlayEnd
PUBLIC	?BlockSector@CBloodCastle@@IAEXHHHHH@Z		; CBloodCastle::BlockSector
PUBLIC	?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z	; CBloodCastle::ReleaseSector
PUBLIC	?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z	; CBloodCastle::GetAliveUserTotalEXP
PUBLIC	??_GCBloodCastle@@UAEPAXI@Z			; CBloodCastle::`scalar deleting destructor'
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::operator--
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEABUBLOODCASTLE_REWARD@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator*
PUBLIC	?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_Seek_to
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_REWARD@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator*
PUBLIC	?_Unwrapped@?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_Unwrapped
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >
PUBLIC	??$advance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z ; std::advance<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,int>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Free_non_head<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
PUBLIC	??$_Emplace@ABUBLOODCASTLE_REWARD@@@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@QAU21@ABUBLOODCASTLE_REWARD@@@Z ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Emplace<BLOODCASTLE_REWARD const &>
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1><>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Freenode0<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
PUBLIC	??$_Get_size_of_n@$0BE@@std@@YAII@Z		; std::_Get_size_of_n<20>
PUBLIC	??$move@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z ; std::move<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > &>
PUBLIC	??$_Get_unwrapped_n@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YA@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z ; std::_Get_unwrapped_n<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,int>
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator++
PUBLIC	??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator--
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >
PUBLIC	??$move@AAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > &>
PUBLIC	??$_Seek_wrapped@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@@Z ; std::_Seek_wrapped<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Freenode<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Transfer_before
PUBLIC	??$forward@ABUBLOODCASTLE_REWARD@@@std@@YAABUBLOODCASTLE_REWARD@@ABU1@@Z ; std::forward<BLOODCASTLE_REWARD const &>
PUBLIC	??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > ><BLOODCASTLE_REWARD const &>
PUBLIC	??$addressof@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAPAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<BLOODCASTLE_REWARD,void *> *>
PUBLIC	??$forward@AAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<BLOODCASTLE_REWARD,void *> * &>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * const &>
PUBLIC	??$addressof@UBLOODCASTLE_REWARD@@@std@@YAPAUBLOODCASTLE_REWARD@@AAU1@@Z ; std::addressof<BLOODCASTLE_REWARD>
PUBLIC	??$destroy@UBLOODCASTLE_REWARD@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::destroy<BLOODCASTLE_REWARD>
PUBLIC	??$construct@UBLOODCASTLE_REWARD@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::construct<BLOODCASTLE_REWARD,BLOODCASTLE_REWARD const &>
PUBLIC	??$forward@ABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z ; std::forward<std::_List_node<BLOODCASTLE_REWARD,void *> * const &>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CBloodCastle@@6B@				; CBloodCastle::`vftable'
PUBLIC	?g_BloodCastle@@3VCBloodCastle@@A		; g_BloodCastle
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5F@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end@				; `string'
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@	; `string'
PUBLIC	??_C@_0BB@IGLHFEOF@commonserver?4cfg@		; `string'
PUBLIC	??_C@_0BB@DHAFCNAC@BloodCastleEvent@		; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo@		; `string'
PUBLIC	??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate@	; `string'
PUBLIC	??_C@_0BC@NGLLHLOE@BloodBoneDropRate@		; `string'
PUBLIC	??_C@_0O@PBCFFJJH@StoneDropRate@		; `string'
PUBLIC	??_C@_0O@FHPHMJJK@StoneItemDrop@		; `string'
PUBLIC	??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5T@ ; `string'
PUBLIC	??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chan@ ; `string'
PUBLIC	??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ ; `string'
PUBLIC	??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ ; `string'
PUBLIC	??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ ; `string'
PUBLIC	??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ ; `string'
PUBLIC	??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinner@ ; `string'
PUBLIC	??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinner@ ; `string'
PUBLIC	??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ ; `string'
PUBLIC	??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CL@ ; `string'
PUBLIC	??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PL@ ; `string'
PUBLIC	??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PL@ ; `string'
PUBLIC	??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@ ; `string'
PUBLIC	??_C@_0N@FFCGFOPA@?E?u?$LI?m?$LI?A?E?d?5Mix@	; `string'
PUBLIC	??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@ ; `string'
PUBLIC	??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@ ; `string'
PUBLIC	??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@ ; `string'
PUBLIC	??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@ ; `string'
PUBLIC	??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@ ; `string'
PUBLIC	??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0FD@ECDGNEKE@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5@ ; `string'
PUBLIC	??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Rele@ ; `string'
PUBLIC	??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Send@ ; `string'
PUBLIC	??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@ ; `string'
PUBLIC	??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@ ; `string'
PUBLIC	??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@ ; `string'
PUBLIC	??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Part@ ; `string'
PUBLIC	??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@ ; `string'
PUBLIC	??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@ ; `string'
PUBLIC	??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5@ ; `string'
PUBLIC	??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Q@ ; `string'
PUBLIC	??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@ ; `string'
PUBLIC	??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kil@ ; `string'
PUBLIC	??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8@ ; `string'
PUBLIC	??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5@ ; `string'
PUBLIC	??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropIte@ ; `string'
PUBLIC	??_C@_04BGCMBJDA@Item@				; `string'
PUBLIC	??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ ; `string'
PUBLIC	??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ ; `string'
PUBLIC	??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ ; `string'
PUBLIC	??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ ; `string'
PUBLIC	??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ ; `string'
PUBLIC	??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fi@ ; `string'
PUBLIC	??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fi@ ; `string'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_R4CBloodCastle@@6B@				; CBloodCastle::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBloodCastle@@@8			; CBloodCastle `RTTI Type Descriptor'
PUBLIC	??_R3CBloodCastle@@8				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBloodCastle@@8				; CBloodCastle::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBloodCastle@@8			; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@42c80000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	__localtime64:PROC
EXTRN	__time64:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjSetPosMonster@@YAHHH@Z:PROC		; gObjSetPosMonster
EXTRN	?LevelSmallConvert@@YAEHH@Z:PROC		; LevelSmallConvert
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?gObjGetStatPointState@@YAXHAAF0@Z:PROC		; gObjGetStatPointState
EXTRN	?gObjNextExpCal@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; gObjNextExpCal
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?GCLevelUpMsgSend@@YAXHGGGGGFF@Z:PROC		; GCLevelUpMsgSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?GCUserChaosBoxSend@@YAXPAVOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
EXTRN	?SendNoticeToUser@TNotice@@SAXHPAX@Z:PROC	; TNotice::SendNoticeToUser
EXTRN	??_ECBloodCastle@@UAEPAXI@Z:PROC		; CBloodCastle::`vector deleting destructor'
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z:PROC	; MapClass::ItemDrop
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?LogChaosItem@CMixSystem@@QAEXPAVOBJECTSTRUCT@@PAD@Z:PROC ; CMixSystem::LogChaosItem
EXTRN	?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z:PROC ; GJSetCharacterInfo
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z:PROC	; ItemSerialCreateSend
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_GlobalConfig@@3VCGlobalConfig@@A:BYTE	; g_GlobalConfig
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?DevilSquareEventConnect@@3HA:DWORD		; DevilSquareEventConnect
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?g_bBloodCastle@@3HA:DWORD			; g_bBloodCastle
EXTRN	?g_iBloodCastle_StartHour@@3HA:DWORD		; g_iBloodCastle_StartHour
EXTRN	?g_bStoneItemDrop@@3HA:DWORD			; g_bStoneItemDrop
EXTRN	?g_iStoneDropRate@@3HA:DWORD			; g_iStoneDropRate
EXTRN	?g_iAngelKingsPaperDropRate@@3HA:DWORD		; g_iAngelKingsPaperDropRate
EXTRN	?g_iBloodBoneDropRate@@3HA:DWORD		; g_iBloodBoneDropRate
EXTRN	?gDevilSquareEventServerIp@@3PADA:BYTE		; gDevilSquareEventServerIp
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?wsRServerCli@@3VwsJoinServerCli@@A:BYTE	; wsRServerCli
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_BloodCastle@@3VCBloodCastle@@A DB 0e74H DUP (?)	; g_BloodCastle
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
_BSS	ENDS
CRT$XCU	SEGMENT
?g_BloodCastle$initializer$@@3P6AXXZA DD FLAT:??__Eg_BloodCastle@@YAXXZ ; g_BloodCastle$initializer$
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CBloodCastle@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBloodCastle@@8 DD FLAT:??_R0?AVCBloodCastle@@@8 ; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R2CBloodCastle@@8
rdata$r	SEGMENT
??_R2CBloodCastle@@8 DD FLAT:??_R1A@?0A@EA@CBloodCastle@@8 ; CBloodCastle::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CBloodCastle@@8
rdata$r	SEGMENT
??_R3CBloodCastle@@8 DD 00H				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBloodCastle@@@8
data$r	SEGMENT
??_R0?AVCBloodCastle@@@8 DD FLAT:??_7type_info@@6B@	; CBloodCastle `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBloodCastle@@', 00H
data$r	ENDS
;	COMDAT ??_R4CBloodCastle@@6B@
rdata$r	SEGMENT
??_R4CBloodCastle@@6B@ DD 00H				; CBloodCastle::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBloodCastle@@@8
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fi@
CONST	SEGMENT
??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fi@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State :'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fi@
CONST	SEGMENT
??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fi@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
CONST	SEGMENT
??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_US'
	DB	'ER_INDEX].MapNumber)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
CONST	SEGMENT
??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m'
	DB	'_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBlood'
	DB	'CastleIndex == -1) ...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
CONST	SEGMENT
??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIs'
	DB	'Connected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDE'
	DB	'X)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
CONST	SEGMENT
??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_Bridg'
	DB	'eData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
CONST	SEGMENT
??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGCMBJDA@Item@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item@ DB 'Item', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropIte@
CONST	SEGMENT
??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropIte@ DB '['
	DB	'Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeInde'
	DB	'x wrong - %d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5@
CONST	SEGMENT
??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5@ DB '['
	DB	'Blood Castle] (%d) Angel King - gObjAdd() failed (no space to'
	DB	' add monster, result:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8@
CONST	SEGMENT
??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8@ DB '['
	DB	'Blood Castle] (%d) Angel King''s Monster Position Doesn''t Ex'
	DB	'ist', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success('
	DB	'Max Boss Kill Count:%d / Boss Kill Count:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max K'
	DB	'ill Count:%d / Kill Count:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kil@
CONST	SEGMENT
??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kil@ DB '['
	DB	'Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Curre'
	DB	'nt Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@
CONST	SEGMENT
??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@ DB 'Can not connec'
	DB	't Ranking Server', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Q@
CONST	SEGMENT
??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Q@ DB '['
	DB	'Blood Castle] (%d) Send User Quest Fail Message (Account:%s, '
	DB	'Name:%s [State:%d], MapNumber:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5@
CONST	SEGMENT
??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5@ DB '['
	DB	'Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, '
	DB	'Score:%d, ExtEXP:%d, LeftTime:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon '
	DB	'(%d) but Failed - Time Out', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@
CONST	SEGMENT
??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@ DB '['
	DB	'Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:'
	DB	'%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:'
	DB	'%d, MapNumber:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@
CONST	SEGMENT
??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@ DB '['
	DB	'Blood Castle] (%d) Quest Complete - All Alive User''s Total E'
	DB	'XP:%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Part@
CONST	SEGMENT
??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Part@ DB '['
	DB	'Blood Castle] (%d) Winner Party Point - Alive Party Member : '
	DB	'%d, Alive Party Point : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@
CONST	SEGMENT
??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@ DB '[B'
	DB	'lood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@
CONST	SEGMENT
??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%d-%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@
CONST	SEGMENT
??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Delete Angel Kin'
	DB	'g''s Weapon (%d) [Serial:%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Send@
CONST	SEGMENT
??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Send@ DB '[B'
	DB	'lood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:%'
	DB	'd/Live:%d, (%d,%d,%d,%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Rele@
CONST	SEGMENT
??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Rele@ DB '[B'
	DB	'lood Castle][Bug Tracer] ReleaseCastleBridge-> %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5@
CONST	SEGMENT
??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5@ DB '['
	DB	'%s][%s] LevelUp PlusStatQuest Clear AddStat %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@ECDGNEKE@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CF@
CONST	SEGMENT
??_C@_0FD@ECDGNEKE@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CF@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %uz %d MonsterIndex '
	DB	': %d, EventType : %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) It''s not Saint Statue( Map:%d'
	DB	', BloodCastleIndex:%d, Type:%d )', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@
CONST	SEGMENT
??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@ DB '['
	DB	0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H, ' Mix] [%s][%s'
	DB	'] CBMix Fail %d Money : %d-%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@
CONST	SEGMENT
??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@ DB '['
	DB	0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H, ' Mix] [%s][%s'
	DB	'] CBMix Success %d Money : %d-%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@
CONST	SEGMENT
??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s'
	DB	', Level:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@
CONST	SEGMENT
??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Le'
	DB	'vel:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@
CONST	SEGMENT
??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Nam'
	DB	'e:%s, Level:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFCGFOPA@?E?u?$LI?m?$LI?A?E?d?5Mix@
CONST	SEGMENT
??_C@_0N@FFCGFOPA@?E?u?$LI?m?$LI?A?E?d?5Mix@ DB 0c5H, 0f5H, 0b8H, 0edH, 0b8H
	DB	0c1H, 0c5H, 0e4H, ' Mix', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@
CONST	SEGMENT
??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PL@
CONST	SEGMENT
??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PL@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYEND', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PL@
CONST	SEGMENT
??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PL@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CL@
CONST	SEGMENT
??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CL@ DB '['
	DB	'Blood Castle] (%d) SetState CLOSED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
CONST	SEGMENT
??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Time Out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinner@
CONST	SEGMENT
??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinner@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinner@
CONST	SEGMENT
??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinner@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == '
	DB	'true', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
CONST	SEGMENT
??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Every User Ou'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
CONST	SEGMENT
??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Saint Status [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
CONST	SEGMENT
??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Castle Door [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
CONST	SEGMENT
??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chan@
CONST	SEGMENT
??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chan@ DB '['
	DB	'Blood Castle] (%d) Bridge Change Bridge Attribute -> Open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5T@
CONST	SEGMENT
??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5T@ DB '['
	DB	'Blood Castle] (%d) Sync Open Time. [%d] min remain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHPHMJJK@StoneItemDrop@
CONST	SEGMENT
??_C@_0O@FHPHMJJK@StoneItemDrop@ DB 'StoneItemDrop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBCFFJJH@StoneDropRate@
CONST	SEGMENT
??_C@_0O@PBCFFJJH@StoneDropRate@ DB 'StoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NGLLHLOE@BloodBoneDropRate@
CONST	SEGMENT
??_C@_0BC@NGLLHLOE@BloodBoneDropRate@ DB 'BloodBoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate@
CONST	SEGMENT
??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate@ DB 'AngelKingsPaperDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DHAFCNAC@BloodCastleEvent@
CONST	SEGMENT
??_C@_0BB@DHAFCNAC@BloodCastleEvent@ DB 'BloodCastleEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGLHFEOF@commonserver?4cfg@
CONST	SEGMENT
??_C@_0BB@IGLHFEOF@commonserver?4cfg@ DB 'commonserver.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end@
CONST	SEGMENT
??_C@_03JBJLGPFL@end@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5F@
CONST	SEGMENT
??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5F@ DB '[Blood'
	DB	' Castle] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7CBloodCastle@@6B@
CONST	SEGMENT
??_7CBloodCastle@@6B@ DD FLAT:??_R4CBloodCastle@@6B@	; CBloodCastle::`vftable'
	DD	FLAT:??_ECBloodCastle@@UAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A DD 0fH ; g_sttBLOODCASTLE_LEVEL
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z$0
__ehfuncinfo$??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CBloodCastle@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CBloodCastle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBloodCastle@@QAE@XZ$0
__ehfuncinfo$??0CBloodCastle@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CBloodCastle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_List_node<BLOODCASTLE_REWARD,void *> * const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_List_node<BLOODCASTLE_REWARD,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@UBLOODCASTLE_REWARD@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UBLOODCASTLE_REWARD@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::construct<BLOODCASTLE_REWARD,BLOODCASTLE_REWARD const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 0a		 push	 10			; 0000000aH
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABUBLOODCASTLE_REWARD@@@std@@YAABUBLOODCASTLE_REWARD@@ABU1@@Z ; std::forward<BLOODCASTLE_REWARD const &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 0a		 mov	 DWORD PTR [edx], ecx
  0002d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00030	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00033	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  00037	66 89 42 08	 mov	 WORD PTR [edx+8], ax

; 695  :     }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$construct@UBLOODCASTLE_REWARD@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::construct<BLOODCASTLE_REWARD,BLOODCASTLE_REWARD const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$destroy@UBLOODCASTLE_REWARD@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UBLOODCASTLE_REWARD@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::destroy<BLOODCASTLE_REWARD>, COMDAT

; 698  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 699  :         _Ptr->~_Uty();
; 700  :     }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$destroy@UBLOODCASTLE_REWARD@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::destroy<BLOODCASTLE_REWARD>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@UBLOODCASTLE_REWARD@@@std@@YAPAUBLOODCASTLE_REWARD@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UBLOODCASTLE_REWARD@@@std@@YAPAUBLOODCASTLE_REWARD@@AAU1@@Z PROC ; std::addressof<BLOODCASTLE_REWARD>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@UBLOODCASTLE_REWARD@@@std@@YAPAUBLOODCASTLE_REWARD@@AAU1@@Z ENDP ; std::addressof<BLOODCASTLE_REWARD>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAPAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<BLOODCASTLE_REWARD,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@ABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAABQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z ; std::forward<std::_List_node<BLOODCASTLE_REWARD,void *> * const &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *>, COMDAT

; 267  : void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 268  :     _Obj.~_Ty();
; 269  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<BLOODCASTLE_REWARD,void *> * &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<BLOODCASTLE_REWARD,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAPAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAPAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<BLOODCASTLE_REWARD,void *> *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAPAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<BLOODCASTLE_REWARD,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > ><BLOODCASTLE_REWARD const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Allocate

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00046	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$forward@ABUBLOODCASTLE_REWARD@@@std@@YAABUBLOODCASTLE_REWARD@@ABU1@@Z ; std::forward<BLOODCASTLE_REWARD const &>
  0004f	83 c4 04	 add	 esp, 4
  00052	50		 push	 eax
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00059	83 c2 08	 add	 edx, 8
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ??$addressof@UBLOODCASTLE_REWARD@@@std@@YAPAUBLOODCASTLE_REWARD@@AAU1@@Z ; std::addressof<BLOODCASTLE_REWARD>
  00062	83 c4 04	 add	 esp, 4
  00065	50		 push	 eax
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$construct@UBLOODCASTLE_REWARD@@ABU1@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::construct<BLOODCASTLE_REWARD,BLOODCASTLE_REWARD const &>
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 588  :     }

  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > ><BLOODCASTLE_REWARD const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABUBLOODCASTLE_REWARD@@@std@@YAABUBLOODCASTLE_REWARD@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUBLOODCASTLE_REWARD@@@std@@YAABUBLOODCASTLE_REWARD@@ABU1@@Z PROC ; std::forward<BLOODCASTLE_REWARD const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUBLOODCASTLE_REWARD@@@std@@YAABUBLOODCASTLE_REWARD@@ABU1@@Z ENDP ; std::forward<BLOODCASTLE_REWARD const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Result$ = -12						; size = 4
__Insert_after$ = -8					; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	89 4d f8	 mov	 DWORD PTR __Insert_after$[ebp], ecx

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00015	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * const &>
  00025	83 c4 08	 add	 esp, 8

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00028	8d 45 f8	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	83 c2 04	 add	 edx, 4
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * const &>
  0003b	83 c4 08	 add	 esp, 8

; 603  :         const auto _Result    = this->_Ptr;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00044	89 4d f4	 mov	 DWORD PTR __Result$[ebp], ecx

; 604  :         this->_Ptr            = pointer{};

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00051	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp]
  00060	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00062	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 21		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	83 c1 08	 add	 ecx, 8
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$addressof@UBLOODCASTLE_REWARD@@@std@@YAPAUBLOODCASTLE_REWARD@@AAU1@@Z ; std::addressof<BLOODCASTLE_REWARD>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ??$destroy@UBLOODCASTLE_REWARD@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::destroy<BLOODCASTLE_REWARD>
  00052	83 c4 08	 add	 esp, 8
$LN1@List_node_:

; 593  :         }
; 594  :     }

  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
  0006f	cc		 int	 3
  00070	cc		 int	 3
  00071	cc		 int	 3
  00072	cc		 int	 3
  00073	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >, COMDAT
; _this$ = ecx

; 1051 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         if (_Ptr) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 13		 je	 SHORT $LN3@Alloc_cons

; 1053 :             _Al.deallocate(_Ptr, 1);

  00034	6a 01		 push	 1
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	51		 push	 ecx
  0003d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEXQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::deallocate
$LN3@Alloc_cons:

; 1054 :         }
; 1055 :     }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1046 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1047 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1048 :         _Ptr = _Al.allocate(1);

  00016	6a 01		 push	 1
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::allocate
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1049 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >, COMDAT
; _this$ = ecx

; 1040 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Freenode<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >, COMDAT

; 316  :     static void _Freenode(_Alnode& _Al, _Nodeptr _Ptr) noexcept { // destroy all members in _Ptr and deallocate with _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	83 c0 08	 add	 eax, 8
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$addressof@UBLOODCASTLE_REWARD@@@std@@YAPAUBLOODCASTLE_REWARD@@AAU1@@Z ; std::addressof<BLOODCASTLE_REWARD>
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$destroy@UBLOODCASTLE_REWARD@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@QAUBLOODCASTLE_REWARD@@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::destroy<BLOODCASTLE_REWARD>
  00041	83 c4 08	 add	 esp, 8

; 318  :         _Freenode0(_Al, _Ptr);

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00047	50		 push	 eax
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Freenode0<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
  00051	83 c4 08	 add	 esp, 8

; 319  :     }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Freenode<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@@Z PROC ; std::_Seek_wrapped<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > >, COMDAT

; 1417 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1418 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1419 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __UIt$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d bc	 mov	 DWORD PTR $T1[ebp], ecx
  00011	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00014	52		 push	 edx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __It$[ebp]
  00018	e8 00 00 00 00	 call	 ?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_Seek_to

; 1420 :     } else {
; 1421 :         _It = static_cast<_UIter&&>(_UIt);
; 1422 :     }
; 1423 : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Seek_wrapped@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@@Z ENDP ; std::_Seek_wrapped<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1468 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator--, COMDAT
; _this$ = ecx

; 118  :     _List_unchecked_iterator& operator--() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :         _Mybase::operator--();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::operator--

; 120  :         return *this;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 121  :     }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator++, COMDAT
; _this$ = ecx

; 107  :     _List_unchecked_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 108  :         _Mybase::operator++();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::operator++

; 109  :         return *this;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 110  :     }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped_n@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YA@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Get_unwrapped_n@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YA@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z PROC ; std::_Get_unwrapped_n<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,int>, COMDAT

; 1335 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1336 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1337 :         return _It + 0;
; 1338 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1339 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1340 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1341 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1342 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1343 : 
; 1344 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1345 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1346 :             "integer overflow");
; 1347 :         (void) _COff;
; 1348 : 
; 1349 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1350 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1351 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1352 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1353 :         return static_cast<_Iter&&>(_It)._Unwrapped();

  00009	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __It$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Unwrapped@?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_Unwrapped
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1354 :     } else {
; 1355 :         // pass through iterator that doesn't participate in checking
; 1356 :         return static_cast<_Iter&&>(_It);
; 1357 :     }
; 1358 : }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Get_unwrapped_n@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YA@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z ENDP ; std::_Get_unwrapped_n<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1468 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BE@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BE@@std@@YAII@Z PROC		; std::_Get_size_of_n<20>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 cc cc
	cc 0c		 mov	 DWORD PTR __Max_possible$1[ebp], 214748364 ; 0cccccccH

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 cc cc
	cc 0c		 cmp	 DWORD PTR __Count$[ebp], 214748364 ; 0cccccccH
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	6b 45 08 14	 imul	 eax, DWORD PTR __Count$[ebp], 20
$LN3@Get_size_o:

; 66   : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Get_size_of_n@$0BE@@std@@YAII@Z ENDP		; std::_Get_size_of_n<20>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Freenode0<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *>
  00031	83 c4 04	 add	 esp, 4

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *>
  00040	83 c4 04	 add	 esp, 4

; 312  :         allocator_traits<_Alnode>::deallocate(_Al, _Ptr, 1);

  00043	6a 01		 push	 1
  00045	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@QAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::deallocate
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  :     }

  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Freenode0<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAPAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<BLOODCASTLE_REWARD,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@AAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@YAAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<BLOODCASTLE_REWARD,void *> * &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Emplace@ABUBLOODCASTLE_REWARD@@@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@QAU21@ABUBLOODCASTLE_REWARD@@@Z
_TEXT	SEGMENT
tv82 = -92						; size = 4
tv80 = -88						; size = 4
$T1 = -84						; size = 4
__Op$ = -16						; size = 8
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABUBLOODCASTLE_REWARD@@@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@QAU21@ABUBLOODCASTLE_REWARD@@@Z PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Emplace<BLOODCASTLE_REWARD const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::max_size
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  00020	39 01		 cmp	 DWORD PTR [ecx], eax
  00022	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  00029	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1016 :         }
; 1017 : 
; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal
  00036	89 45 a8	 mov	 DWORD PTR tv80[ebp], eax
  00039	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??$forward@ABUBLOODCASTLE_REWARD@@@std@@YAABUBLOODCASTLE_REWARD@@ABU1@@Z ; std::forward<BLOODCASTLE_REWARD const &>
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 a4	 mov	 DWORD PTR tv82[ebp], eax
  00048	8b 4d a4	 mov	 ecx, DWORD PTR tv82[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 a8	 mov	 edx, DWORD PTR tv80[ebp]
  0004f	52		 push	 edx
  00050	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  00053	e8 00 00 00 00	 call	 ??$?0ABUBLOODCASTLE_REWARD@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@ABUBLOODCASTLE_REWARD@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > ><BLOODCASTLE_REWARD const &>

; 1019 :         ++_Mysize;

  00058	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005d	83 c1 01	 add	 ecx, 1
  00060	8b 55 f8	 mov	 edx, DWORD PTR __Mysize$[ebp]
  00063	89 0a		 mov	 DWORD PTR [edx], ecx

; 1020 :         return _Op._Transfer_before(_Where);

  00065	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00068	50		 push	 eax
  00069	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::_Transfer_before
  00071	89 45 ac	 mov	 DWORD PTR $T1[ebp], eax
  00074	8d 4d f0	 lea	 ecx, DWORD PTR __Op$[ebp]
  00077	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
  0007c	8b 45 ac	 mov	 eax, DWORD PTR $T1[ebp]
$LN3@Emplace:

; 1021 :     }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
??$_Emplace@ABUBLOODCASTLE_REWARD@@@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@QAU21@ABUBLOODCASTLE_REWARD@@@Z ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Emplace<BLOODCASTLE_REWARD const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Pnext$1 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Free_non_head<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 324  :         _Head->_Prev->_Next = nullptr;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0001d	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00022	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  00025	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00029	74 1a		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	89 4d f8	 mov	 DWORD PTR __Pnext$1[ebp], ecx

; 329  :             _Freenode(_Al, _Pnode);

  00033	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00036	50		 push	 eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Freenode<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
  00040	83 c4 08	 add	 esp, 8

; 330  :         }

  00043	eb da		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Free_non_head<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$advance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z
_TEXT	SEGMENT
__Need_rewrap$1 = -9					; size = 1
_$S24$2 = -8						; size = 4
__UWhere$3 = -4						; size = 4
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z PROC ; std::advance<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,int>, COMDAT

; 1642 : _CONSTEXPR17 void advance(_InIt& _Where, _Diff _Off) { // increment iterator by offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1643 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1644 :         _Where += _Off;
; 1645 :     } else {
; 1646 :         if constexpr (is_signed_v<_Diff> && !_Is_bidi_iter_v<_InIt>) {
; 1647 :             _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 1648 :         }
; 1649 : 
; 1650 :         auto&& _UWhere              = _Get_unwrapped_n(_STD move(_Where), _Off);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$move@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z ; std::move<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > &>
  00016	83 c4 04	 add	 esp, 4
  00019	50		 push	 eax
  0001a	8d 55 f8	 lea	 edx, DWORD PTR _$S24$2[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Get_unwrapped_n@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YA@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z ; std::_Get_unwrapped_n<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,int>
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	8d 45 f8	 lea	 eax, DWORD PTR _$S24$2[ebp]
  00029	89 45 fc	 mov	 DWORD PTR __UWhere$3[ebp], eax

; 1651 :         constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(_STD move(_Where), _Off))>;

  0002c	c6 45 f7 01	 mov	 BYTE PTR __Need_rewrap$1[ebp], 1

; 1652 : 
; 1653 :         if constexpr (is_signed_v<_Diff> && _Is_bidi_iter_v<_InIt>) {
; 1654 :             for (; _Off < 0; ++_Off) {

  00030	eb 09		 jmp	 SHORT $LN4@advance
$LN2@advance:
  00032	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00035	83 c0 01	 add	 eax, 1
  00038	89 45 0c	 mov	 DWORD PTR __Off$[ebp], eax
$LN4@advance:
  0003b	83 7d 0c 00	 cmp	 DWORD PTR __Off$[ebp], 0
  0003f	7d 0a		 jge	 SHORT $LN3@advance

; 1655 :                 --_UWhere;

  00041	8b 4d fc	 mov	 ecx, DWORD PTR __UWhere$3[ebp]
  00044	e8 00 00 00 00	 call	 ??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator--

; 1656 :             }

  00049	eb e7		 jmp	 SHORT $LN2@advance
$LN3@advance:

; 1657 :         }
; 1658 : 
; 1659 :         for (; 0 < _Off; --_Off) {

  0004b	eb 09		 jmp	 SHORT $LN7@advance
$LN5@advance:
  0004d	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00050	83 e8 01	 sub	 eax, 1
  00053	89 45 0c	 mov	 DWORD PTR __Off$[ebp], eax
$LN7@advance:
  00056	83 7d 0c 00	 cmp	 DWORD PTR __Off$[ebp], 0
  0005a	7e 0a		 jle	 SHORT $LN6@advance

; 1660 :             ++_UWhere;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __UWhere$3[ebp]
  0005f	e8 00 00 00 00	 call	 ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator++

; 1661 :         }

  00064	eb e7		 jmp	 SHORT $LN5@advance
$LN6@advance:

; 1662 : 
; 1663 :         if constexpr (_Need_rewrap) {
; 1664 :             _Seek_wrapped(_Where, _STD move(_UWhere));

  00066	8b 45 fc	 mov	 eax, DWORD PTR __UWhere$3[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$move@AAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@AAV10@@Z ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > &>
  0006f	83 c4 04	 add	 esp, 4
  00072	50		 push	 eax
  00073	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ??$_Seek_wrapped@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@@Z ; std::_Seek_wrapped<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > > >
  0007c	83 c4 08	 add	 esp, 8

; 1665 :         }
; 1666 :     }
; 1667 : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$advance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z ENDP ; std::advance<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Unwrapped@?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Unwrapped@?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 270  :     _NODISCARD _List_unchecked_iterator<_Mylist> _Unwrapped() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 271  :         return _List_unchecked_iterator<_Mylist>(this->_Ptr, static_cast<const _Mylist*>(this->_Getcont()));

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
  00014	50		 push	 eax
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 272  :     }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?_Unwrapped@?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_REWARD@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_REWARD@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator*, COMDAT
; _this$ = ecx

; 238  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEABUBLOODCASTLE_REWARD@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator*

; 240  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_REWARD@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__It$ = 8						; size = 4
?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_Seek_to, COMDAT
; _this$ = ecx

; 218  :     void _Seek_to(const _List_unchecked_const_iterator<_Mylist> _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 219  :         this->_Ptr = _It._Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __It$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 220  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?_Seek_to@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEABUBLOODCASTLE_REWARD@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEABUBLOODCASTLE_REWARD@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator*, COMDAT
; _this$ = ecx

; 145  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : #if _ITERATOR_DEBUG_LEVEL == 2
; 147  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 148  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 149  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 150  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 151  : 
; 152  :         return this->_Ptr->_Myval;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	83 c0 08	 add	 eax, 8

; 153  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEABUBLOODCASTLE_REWARD@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 62   :     _List_unchecked_const_iterator& operator--() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   :         _Ptr = _Ptr->_Prev;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00017	89 02		 mov	 DWORD PTR [edx], eax

; 64   :         return *this;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 65   :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _List_unchecked_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :         _Ptr = _Ptr->_Next;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 01		 mov	 eax, DWORD PTR [ecx]
  00016	89 02		 mov	 DWORD PTR [edx], eax

; 53   :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 54   :     }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 41   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1  - 

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1  - 

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2  - 

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2  - 

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3  - 

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3  - 

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4  - 

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4  - 

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5  - 

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5  - 

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6  - 

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6  - 

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\Readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fg_BloodCastle@@YAXXZ
text$yd	SEGMENT
??__Fg_BloodCastle@@YAXXZ PROC				; `dynamic atexit destructor for 'g_BloodCastle'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0000e	e8 00 00 00 00	 call	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_BloodCastle@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_BloodCastle''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ??__Eg_BloodCastle@@YAXXZ
text$di	SEGMENT
??__Eg_BloodCastle@@YAXXZ PROC				; `dynamic initializer for 'g_BloodCastle'', COMDAT

; 8    : CBloodCastle			g_BloodCastle;		//    

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0000e	e8 00 00 00 00	 call	 ??0CBloodCastle@@QAE@XZ	; CBloodCastle::CBloodCastle
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_BloodCastle@@YAXXZ ; `dynamic atexit destructor for 'g_BloodCastle''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_BloodCastle@@YAXXZ ENDP				; `dynamic initializer for 'g_BloodCastle''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCBloodCastle@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBloodCastle@@UAEPAXI@Z PROC			; CBloodCastle::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 74 0e 00 00	 push	 3700			; 00000e74H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GCBloodCastle@@UAEPAXI@Z ENDP			; CBloodCastle::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z
_TEXT	SEGMENT
tv149 = -84						; size = 4
tv66 = -84						; size = 4
tv150 = -80						; size = 4
tv67 = -80						; size = 4
_i$1 = -12						; size = 4
_iRET_EXP$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z PROC	; CBloodCastle::GetAliveUserTotalEXP, COMDAT
; _this$ = ecx

; 2884 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2885 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN11@GetAliveUs
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN12@GetAliveUs
$LN11@GetAliveUs:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN9@GetAliveUs
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN10@GetAliveUs
$LN9@GetAliveUs:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN10@GetAliveUs:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN12@GetAliveUs:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 07		 jne	 SHORT $LN5@GetAliveUs

; 2886 : 		return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 0d 01 00 00	 jmp	 $LN1@GetAliveUs
$LN5@GetAliveUs:

; 2887 : 
; 2888 : 	int iRET_EXP = 0;

  00044	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRET_EXP$[ebp], 0

; 2889 : 
; 2890 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  0004b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN4@GetAliveUs
$LN2@GetAliveUs:
  00054	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@GetAliveUs:
  0005d	83 7d f4 0a	 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  00061	0f 8d e7 00 00
	00		 jge	 $LN3@GetAliveUs

; 2891 : 		if ((m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) && (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > 2)) {

  00067	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00075	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00079	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  0007e	0f 84 c5 00 00
	00		 je	 $LN6@GetAliveUs
  00084	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00092	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00096	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0009e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a4	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  000a9	0f 8e 9a 00 00
	00		 jle	 $LN6@GetAliveUs

; 2892 : 			if (CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber)) {

  000af	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000bd	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000c1	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cf	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  000d7	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  000da	7d 09		 jge	 SHORT $LN15@GetAliveUs
  000dc	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv150[ebp], 0
  000e3	eb 42		 jmp	 SHORT $LN16@GetAliveUs
$LN15@GetAliveUs:
  000e5	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  000ec	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ef	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  000f3	6b 4d f4 14	 imul	 ecx, DWORD PTR _i$1[ebp], 20
  000f7	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00104	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  0010c	83 f9 11	 cmp	 ecx, 17			; 00000011H
  0010f	7e 09		 jle	 SHORT $LN13@GetAliveUs
  00111	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
  00118	eb 07		 jmp	 SHORT $LN14@GetAliveUs
$LN13@GetAliveUs:
  0011a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv149[ebp], 1
$LN14@GetAliveUs:
  00121	8b 55 ac	 mov	 edx, DWORD PTR tv149[ebp]
  00124	89 55 b0	 mov	 DWORD PTR tv150[ebp], edx
$LN16@GetAliveUs:
  00127	83 7d b0 00	 cmp	 DWORD PTR tv150[ebp], 0
  0012b	74 1c		 je	 SHORT $LN6@GetAliveUs

; 2893 : 				iRET_EXP += m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  0012d	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00134	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00137	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0013b	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0013f	8b 4d f8	 mov	 ecx, DWORD PTR _iRET_EXP$[ebp]
  00142	03 4c 02 1c	 add	 ecx, DWORD PTR [edx+eax+28]
  00146	89 4d f8	 mov	 DWORD PTR _iRET_EXP$[ebp], ecx
$LN6@GetAliveUs:

; 2894 : 			}
; 2895 : 		}
; 2896 : 	}

  00149	e9 06 ff ff ff	 jmp	 $LN2@GetAliveUs
$LN3@GetAliveUs:

; 2897 : 
; 2898 : 	return iRET_EXP;

  0014e	8b 45 f8	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
$LN1@GetAliveUs:

; 2899 : }

  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	5b		 pop	 ebx
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c2 04 00	 ret	 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ENDP	; CBloodCastle::GetAliveUserTotalEXP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
_j$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::ReleaseSector, COMDAT
; _this$ = ecx

; 2654 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2655 : 	if(!CHECK_BLOODCASTLE(iMAP_NUM))

  0000c	83 7d 08 0b	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 11 ; 0000000bH
  00010	7d 09		 jge	 SHORT $LN12@ReleaseSec
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN13@ReleaseSec
$LN12@ReleaseSec:
  0001b	83 7d 08 11	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 17 ; 00000011H
  0001f	7e 09		 jle	 SHORT $LN10@ReleaseSec
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN11@ReleaseSec
$LN10@ReleaseSec:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN11@ReleaseSec:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN13@ReleaseSec:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 02		 jne	 SHORT $LN8@ReleaseSec

; 2656 : 		return;

  0003d	eb 74		 jmp	 SHORT $LN1@ReleaseSec
$LN8@ReleaseSec:

; 2657 : 
; 2658 : 	for (INT i = iSTART_X ; i <= iEND_X ; i++) {

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _iSTART_X$[ebp]
  00042	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
  00045	eb 09		 jmp	 SHORT $LN4@ReleaseSec
$LN2@ReleaseSec:
  00047	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@ReleaseSec:
  00050	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00053	3b 45 14	 cmp	 eax, DWORD PTR _iEND_X$[ebp]
  00056	7f 5b		 jg	 SHORT $LN1@ReleaseSec

; 2659 : 		for (INT j = iSTART_Y ; j <= iEND_Y ; j++) {

  00058	8b 45 10	 mov	 eax, DWORD PTR _iSTART_Y$[ebp]
  0005b	89 45 f4	 mov	 DWORD PTR _j$1[ebp], eax
  0005e	eb 09		 jmp	 SHORT $LN7@ReleaseSec
$LN5@ReleaseSec:
  00060	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 f4	 mov	 DWORD PTR _j$1[ebp], eax
$LN7@ReleaseSec:
  00069	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  0006c	3b 45 18	 cmp	 eax, DWORD PTR _iEND_Y$[ebp]
  0006f	7f 40		 jg	 SHORT $LN6@ReleaseSec

; 2660 : 			MapC[iMAP_NUM].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] &= ~((BYTE) MAP_ATTR_BLOCK);

  00071	69 45 08 8c 04
	05 00		 imul	 eax, DWORD PTR _iMAP_NUM$[ebp], 328844
  00078	8b 4d f4	 mov	 ecx, DWORD PTR _j$1[ebp]
  0007b	c1 e1 08	 shl	 ecx, 8
  0007e	03 4d f8	 add	 ecx, DWORD PTR _i$2[ebp]
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00087	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  0008b	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  0008f	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00092	69 55 08 8c 04
	05 00		 imul	 edx, DWORD PTR _iMAP_NUM$[ebp], 328844
  00099	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  0009c	c1 e0 08	 shl	 eax, 8
  0009f	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  000a2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000a8	8b 54 16 10	 mov	 edx, DWORD PTR [esi+edx+16]
  000ac	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2661 : 		}

  000af	eb af		 jmp	 SHORT $LN5@ReleaseSec
$LN6@ReleaseSec:

; 2662 : 	}

  000b1	eb 94		 jmp	 SHORT $LN2@ReleaseSec
$LN1@ReleaseSec:

; 2663 : }

  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 14 00	 ret	 20			; 00000014H
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::ReleaseSector
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?BlockSector@CBloodCastle@@IAEXHHHHH@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
_j$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?BlockSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::BlockSector, COMDAT
; _this$ = ecx

; 2635 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2636 : 	if(!CHECK_BLOODCASTLE(iMAP_NUM))

  0000c	83 7d 08 0b	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 11 ; 0000000bH
  00010	7d 09		 jge	 SHORT $LN12@BlockSecto
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN13@BlockSecto
$LN12@BlockSecto:
  0001b	83 7d 08 11	 cmp	 DWORD PTR _iMAP_NUM$[ebp], 17 ; 00000011H
  0001f	7e 09		 jle	 SHORT $LN10@BlockSecto
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN11@BlockSecto
$LN10@BlockSecto:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN11@BlockSecto:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN13@BlockSecto:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 02		 jne	 SHORT $LN8@BlockSecto

; 2637 : 		return;

  0003d	eb 74		 jmp	 SHORT $LN1@BlockSecto
$LN8@BlockSecto:

; 2638 : 
; 2639 : 	for (INT i = iSTART_X ; i <= iEND_X ; i++) {

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _iSTART_X$[ebp]
  00042	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
  00045	eb 09		 jmp	 SHORT $LN4@BlockSecto
$LN2@BlockSecto:
  00047	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@BlockSecto:
  00050	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00053	3b 45 14	 cmp	 eax, DWORD PTR _iEND_X$[ebp]
  00056	7f 5b		 jg	 SHORT $LN1@BlockSecto

; 2640 : 		for (INT j = iSTART_Y ; j <= iEND_Y ; j++) {

  00058	8b 45 10	 mov	 eax, DWORD PTR _iSTART_Y$[ebp]
  0005b	89 45 f4	 mov	 DWORD PTR _j$1[ebp], eax
  0005e	eb 09		 jmp	 SHORT $LN7@BlockSecto
$LN5@BlockSecto:
  00060	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 f4	 mov	 DWORD PTR _j$1[ebp], eax
$LN7@BlockSecto:
  00069	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  0006c	3b 45 18	 cmp	 eax, DWORD PTR _iEND_Y$[ebp]
  0006f	7f 40		 jg	 SHORT $LN6@BlockSecto

; 2641 : 			MapC[iMAP_NUM].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] |= (BYTE) MAP_ATTR_BLOCK;

  00071	69 45 08 8c 04
	05 00		 imul	 eax, DWORD PTR _iMAP_NUM$[ebp], 328844
  00078	8b 4d f4	 mov	 ecx, DWORD PTR _j$1[ebp]
  0007b	c1 e1 08	 shl	 ecx, 8
  0007e	03 4d f8	 add	 ecx, DWORD PTR _i$2[ebp]
  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00087	8b 44 02 10	 mov	 eax, DWORD PTR [edx+eax+16]
  0008b	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  0008f	83 c9 04	 or	 ecx, 4
  00092	69 55 08 8c 04
	05 00		 imul	 edx, DWORD PTR _iMAP_NUM$[ebp], 328844
  00099	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  0009c	c1 e0 08	 shl	 eax, 8
  0009f	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  000a2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000a8	8b 54 16 10	 mov	 edx, DWORD PTR [esi+edx+16]
  000ac	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2642 : 		}

  000af	eb af		 jmp	 SHORT $LN5@BlockSecto
$LN6@BlockSecto:

; 2643 : 	}

  000b1	eb 94		 jmp	 SHORT $LN2@BlockSecto
$LN1@BlockSecto:

; 2644 : }

  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 14 00	 ret	 20			; 00000014H
?BlockSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::BlockSector
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetState_PlayEnd@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv139 = -80						; size = 4
tv66 = -80						; size = 4
tv140 = -76						; size = 4
tv67 = -76						; size = 4
_n$1 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_PlayEnd, COMDAT
; _this$ = ecx

; 1175 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1176 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN10@SetState_P
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN11@SetState_P
$LN10@SetState_P:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN8@SetState_P
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN9@SetState_P
$LN8@SetState_P:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@SetState_P:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN11@SetState_P:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@SetState_P

; 1177 : 		return;

  0003d	e9 fa 00 00 00	 jmp	 $LN1@SetState_P
$LN5@SetState_P:

; 1178 : 
; 1179 : 	SendNoticeState(iBridgeIndex, BC_STATE_END);

  00042	6a 02		 push	 2
  00044	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00047	50		 push	 eax
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 1180 : 
; 1181 : 	ClearMonster(iBridgeIndex, false);

  00050	6a 00		 push	 0
  00052	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 1182 : 
; 1183 : 	m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  0005e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	c6 84 01 63 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+355], 0

; 1184 : 	m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = m_iBC_TIME_MIN_REST * 60 * 1000;		// BLOODCASTLE_STATE_PLAYEND -> BLOODCASTLE_STATE_CLOSED   

  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	6b 88 2c 0e 00
	00 3c		 imul	 ecx, DWORD PTR [eax+3628], 60
  0007a	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  00080	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	89 94 01 54 01
	00 00		 mov	 DWORD PTR [ecx+eax+340], edx

; 1185 : 
; 1186 : 	LogAddTD("[Blood Castle] (%d) SetState PLAYEND", iBridgeIndex+1);

  00091	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00094	83 c0 01	 add	 eax, 1
  00097	50		 push	 eax
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PL@
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a3	83 c4 08	 add	 esp, 8

; 1187 : 
; 1188 : 	for (int n=0 ; n < MAX_BLOODCASTLE_USER_COUNT ; n++) {

  000a6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  000ad	eb 09		 jmp	 SHORT $LN4@SetState_P
$LN2@SetState_P:
  000af	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  000b2	83 c0 01	 add	 eax, 1
  000b5	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@SetState_P:
  000b8	83 7d f8 0a	 cmp	 DWORD PTR _n$1[ebp], 10	; 0000000aH
  000bc	7d 7e		 jge	 SHORT $LN1@SetState_P

; 1189 : 		if (CHECK_LIMIT(m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex, MAX_OBJECT)) {

  000be	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000cc	6b 45 f8 14	 imul	 eax, DWORD PTR _n$1[ebp], 20
  000d0	83 7c 02 18 00	 cmp	 DWORD PTR [edx+eax+24], 0
  000d5	7d 09		 jge	 SHORT $LN14@SetState_P
  000d7	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
  000de	eb 32		 jmp	 SHORT $LN15@SetState_P
$LN14@SetState_P:
  000e0	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  000e7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ea	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  000ee	6b 4d f8 14	 imul	 ecx, DWORD PTR _n$1[ebp], 20
  000f2	81 7c 08 18 e7
	1c 00 00	 cmp	 DWORD PTR [eax+ecx+24], 7399 ; 00001ce7H
  000fa	7e 09		 jle	 SHORT $LN12@SetState_P
  000fc	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv139[ebp], 0
  00103	eb 07		 jmp	 SHORT $LN13@SetState_P
$LN12@SetState_P:
  00105	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv139[ebp], 1
$LN13@SetState_P:
  0010c	8b 55 b0	 mov	 edx, DWORD PTR tv139[ebp]
  0010f	89 55 b4	 mov	 DWORD PTR tv140[ebp], edx
$LN15@SetState_P:
  00112	83 7d b4 00	 cmp	 DWORD PTR tv140[ebp], 0
  00116	74 1f		 je	 SHORT $LN6@SetState_P

; 1190 : 			SearchUserDeleteQuestItem(m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex);

  00118	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00126	6b 45 f8 14	 imul	 eax, DWORD PTR _n$1[ebp], 20
  0012a	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0012e	51		 push	 ecx
  0012f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00132	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN6@SetState_P:

; 1191 : 		}
; 1192 : 	}

  00137	e9 73 ff ff ff	 jmp	 $LN2@SetState_P
$LN1@SetState_P:

; 1193 : 
; 1194 : //	 !! -    
; 1195 : //	SendNoticeScore(iBridgeIndex);
; 1196 : }

  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c2 04 00	 ret	 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_PlayEnd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetState_Playing@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv66 = -364						; size = 4
tv67 = -360						; size = 4
_n$1 = -292						; size = 4
_ServerCmd$ = -288					; size = 7
_pNotice$ = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Playing, COMDAT
; _this$ = ecx

; 1129 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1130 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00019	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0001d	7d 0c		 jge	 SHORT $LN10@SetState_P
  0001f	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00029	eb 28		 jmp	 SHORT $LN11@SetState_P
$LN10@SetState_P:
  0002b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0002f	7e 0c		 jle	 SHORT $LN8@SetState_P
  00031	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN9@SetState_P
$LN8@SetState_P:
  0003d	c7 85 94 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN9@SetState_P:
  00047	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN11@SetState_P:
  00053	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 05		 jne	 SHORT $LN5@SetState_P

; 1131 : 		return;

  0005c	e9 53 01 00 00	 jmp	 $LN1@SetState_P
$LN5@SetState_P:

; 1132 : 
; 1133 : 	m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  00061	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	c6 84 01 63 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+355], 0

; 1134 : 	m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = m_iBC_TIME_MIN_PLAY * 60 * 1000;			// BLOODCASTLE_STATE_PLAYING -> BLOODCASTLE_STATE_PLAYEND   

  00073	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00076	6b 88 28 0e 00
	00 3c		 imul	 ecx, DWORD PTR [eax+3624], 60
  0007d	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  00083	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	89 94 01 54 01
	00 00		 mov	 DWORD PTR [ecx+eax+340], edx

; 1135 : 	
; 1136 : 	// *> .           . ->         (2004.06.09)
; 1137 : 	CheckUsersOnConnect(iBridgeIndex);

  00094	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00097	50		 push	 eax
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ; CBloodCastle::CheckUsersOnConnect

; 1138 : 	
; 1139 : 	PMSG_NOTICE	pNotice;
; 1140 : 
; 1141 : #ifdef MODIFY_NOTICE_20040325
; 1142 : 	TNotice::MakeNoticeMsgEx( &pNotice, 1, lMsg.Get(1163), iBridgeIndex + 1, BC_MAX_START_WAIT_TERM );

  000a0	6a 3c		 push	 60			; 0000003cH
  000a2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000a5	83 c0 01	 add	 eax, 1
  000a8	50		 push	 eax
  000a9	68 8b 04 00 00	 push	 1163			; 0000048bH
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000b9	50		 push	 eax
  000ba	6a 01		 push	 1
  000bc	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  000c8	83 c4 14	 add	 esp, 20			; 00000014H

; 1143 : #else
; 1144 : 	pNotice.type = 1;
; 1145 : 	wsprintf(pNotice.Notice, lMsg.Get(1163), iBridgeIndex + 1, BC_MAX_START_WAIT_TERM);		// " %d     %d   ."
; 1146 : 	PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 1147 : #endif
; 1148 : 
; 1149 : 	SendBridgeAnyMsg ((LPBYTE) &pNotice, pNotice.h.size, iBridgeIndex);

  000cb	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000ce	50		 push	 eax
  000cf	0f b6 8d e9 fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$[ebp+1]
  000d6	51		 push	 ecx
  000d7	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$[ebp]
  000dd	52		 push	 edx
  000de	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 1150 : 
; 1151 : 	PMSG_SERVERCMD	ServerCmd;
; 1152 : 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  000e6	6a 07		 push	 7
  000e8	6a 40		 push	 64			; 00000040H
  000ea	68 f3 00 00 00	 push	 243			; 000000f3H
  000ef	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _ServerCmd$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  000fb	83 c4 10	 add	 esp, 16			; 00000010H

; 1153 : 	ServerCmd.CmdType = 1;

  000fe	c6 85 e4 fe ff
	ff 01		 mov	 BYTE PTR _ServerCmd$[ebp+4], 1

; 1154 : 	ServerCmd.X = 45;

  00105	c6 85 e5 fe ff
	ff 2d		 mov	 BYTE PTR _ServerCmd$[ebp+5], 45 ; 0000002dH

; 1155 : 	ServerCmd.Y = 0;

  0010c	c6 85 e6 fe ff
	ff 00		 mov	 BYTE PTR _ServerCmd$[ebp+6], 0

; 1156 : 	SendBridgeAnyMsg ((LPBYTE) &ServerCmd, ServerCmd.h.size, iBridgeIndex);

  00113	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00116	50		 push	 eax
  00117	0f b6 8d e1 fe
	ff ff		 movzx	 ecx, BYTE PTR _ServerCmd$[ebp+1]
  0011e	51		 push	 ecx
  0011f	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _ServerCmd$[ebp]
  00125	52		 push	 edx
  00126	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 1157 : 
; 1158 : 	//        .
; 1159 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0012e	c7 85 dc fe ff
	ff 00 19 00 00	 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00138	eb 0f		 jmp	 SHORT $LN4@SetState_P
$LN2@SetState_P:
  0013a	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 85 dc fe ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@SetState_P:
  00149	81 bd dc fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00153	7d 4a		 jge	 SHORT $LN3@SetState_P

; 1160 : 	{
; 1161 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 1162 : 		if( (gObj[n].MapNumber == GetMapNumByBCBridge( iBridgeIndex ) ) && (gObj[n].Connected > 2) ) {
; 1163 : #else
; 1164 : 		if( (gObj[n].MapNumber == MAP_INDEX_BLOODCASTLE1 + iBridgeIndex) && (gObj[n].Connected > 2) ) {

  00155	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0015f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00165	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0016d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00170	83 c0 0b	 add	 eax, 11			; 0000000bH
  00173	3b d0		 cmp	 edx, eax
  00175	75 26		 jne	 SHORT $LN6@SetState_P
  00177	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00181	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00187	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0018c	7e 0f		 jle	 SHORT $LN6@SetState_P

; 1165 : #endif
; 1166 : 			SearchUserDeleteQuestItem(n);

  0018e	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00194	50		 push	 eax
  00195	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN6@SetState_P:

; 1167 : 		}
; 1168 : 	}

  0019d	eb 9b		 jmp	 SHORT $LN2@SetState_P
$LN3@SetState_P:

; 1169 : 
; 1170 : 	LogAddTD("[Blood Castle] (%d) SetState PLAYING", iBridgeIndex+1);

  0019f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  001a2	83 c0 01	 add	 eax, 1
  001a5	50		 push	 eax
  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PL@
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b1	83 c4 08	 add	 esp, 8
$LN1@SetState_P:

; 1171 : }

  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi
  001b6	5b		 pop	 ebx
  001b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ba	33 cd		 xor	 ecx, ebp
  001bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c1	8b e5		 mov	 esp, ebp
  001c3	5d		 pop	 ebp
  001c4	c2 04 00	 ret	 4
?SetState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Playing
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetState_Closed@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv66 = -80						; size = 4
tv67 = -76						; size = 4
_n$1 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Closed, COMDAT
; _this$ = ecx

; 1086 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1087 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN10@SetState_C
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN11@SetState_C
$LN10@SetState_C:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN8@SetState_C
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN9@SetState_C
$LN8@SetState_C:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@SetState_C:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN11@SetState_C:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@SetState_C

; 1088 : 		return;

  0003d	e9 e3 00 00 00	 jmp	 $LN1@SetState_C
$LN5@SetState_C:

; 1089 : 
; 1090 : 	SendNoticeState(iBridgeIndex, BC_STATE_END);

  00042	6a 02		 push	 2
  00044	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00047	50		 push	 eax
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 1091 : 
; 1092 : 	ClearBridgeData(iBridgeIndex);

  00050	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 1093 : 
; 1094 : 	ClearMonster(iBridgeIndex, true);

  0005c	6a 01		 push	 1
  0005e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00061	50		 push	 eax
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 1095 : 
; 1096 : 	CheckAngelKingExist (iBridgeIndex);				//    ->  .

  0006a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckAngelKingExist

; 1097 : 
; 1098 : //	BlockSector(iBridgeIndex + MAP_INDEX_BLOODCASTLE1, 13,	77,	15,	78);		// !!>   ->     
; 1099 : 
; 1100 : 	//            .
; 1101 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00076	c7 45 f8 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  0007d	eb 09		 jmp	 SHORT $LN4@SetState_C
$LN2@SetState_C:
  0007f	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@SetState_C:
  00088	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  0008f	7d 4f		 jge	 SHORT $LN3@SetState_C

; 1102 : 	{
; 1103 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 1104 : 		int iMapNum = GetMapNumByBCBridge( iBridgeIndex );		
; 1105 : 		if( (gObj[n].MapNumber == iMapNum) && (gObj[n].Connected > 2) )
; 1106 : #else
; 1107 : 		if( (gObj[n].MapNumber == MAP_INDEX_BLOODCASTLE1 + iBridgeIndex) && (gObj[n].Connected > 2) )

  00091	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009e	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000a6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000a9	83 c0 0b	 add	 eax, 11			; 0000000bH
  000ac	3b d0		 cmp	 edx, eax
  000ae	75 2e		 jne	 SHORT $LN6@SetState_C
  000b0	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bd	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  000c2	7e 1a		 jle	 SHORT $LN6@SetState_C

; 1108 : #endif
; 1109 : 		{
; 1110 : 			SearchUserDeleteQuestItem(n);			

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  000c7	50		 push	 eax
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 1111 : 			gObjMoveGate(n, 22);

  000d0	6a 16		 push	 22			; 00000016H
  000d2	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000db	83 c4 08	 add	 esp, 8
$LN6@SetState_C:

; 1112 : 		}
; 1113 : 	}

  000de	eb 9f		 jmp	 SHORT $LN2@SetState_C
$LN3@SetState_C:

; 1114 : 
; 1115 : 	//     .
; 1116 : 	BlockCastleDoor(iBridgeIndex);

  000e0	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000e3	50		 push	 eax
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor

; 1117 : 	//      .
; 1118 : 	BlockCastleBridge(iBridgeIndex);

  000ec	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	e8 00 00 00 00	 call	 ?BlockCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleBridge

; 1119 : 	//      .
; 1120 : 	BlockCastleEntrance(iBridgeIndex);

  000f8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	e8 00 00 00 00	 call	 ?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleEntrance

; 1121 : 
; 1122 : 	CheckSync(iBridgeIndex);						// BLOODCASTLE_STATE_CLOSED -> BLOODCASTLE_STATE_PLAYING    

  00104	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00107	50		 push	 eax
  00108	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	e8 00 00 00 00	 call	 ?CheckSync@CBloodCastle@@IAEXH@Z ; CBloodCastle::CheckSync

; 1123 : 
; 1124 : 	LogAddTD("[Blood Castle] (%d) SetState CLOSED", iBridgeIndex+1);

  00110	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00113	83 c0 01	 add	 eax, 1
  00116	50		 push	 eax
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CL@
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00122	83 c4 08	 add	 esp, 8
$LN1@SetState_C:

; 1125 : }

  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	5b		 pop	 ebx
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c2 04 00	 ret	 4
?SetState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Closed
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetState_None@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv66 = -80						; size = 4
tv67 = -76						; size = 4
_n$1 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_None, COMDAT
; _this$ = ecx

; 1052 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1053 : 	//       (     .)
; 1054 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN10@SetState_N
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN11@SetState_N
$LN10@SetState_N:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN8@SetState_N
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN9@SetState_N
$LN8@SetState_N:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@SetState_N:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN11@SetState_N:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@SetState_N

; 1055 : 		return;

  0003d	e9 bc 00 00 00	 jmp	 $LN1@SetState_N
$LN5@SetState_N:

; 1056 : 
; 1057 : 	m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC	= -1;

  00042	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	c7 84 01 54 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+340], -1

; 1058 : 	m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT		= -1;

  00057	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	c7 84 01 58 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+344], -1

; 1059 : 
; 1060 : 	SendNoticeState(iBridgeIndex, BC_STATE_END);

  0006c	6a 02		 push	 2
  0006e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00071	50		 push	 eax
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 1061 : 
; 1062 : 	ClearBridgeData(iBridgeIndex);

  0007a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0007d	50		 push	 eax
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 1063 : 
; 1064 : 	ClearMonster(iBridgeIndex, true);

  00086	6a 01		 push	 1
  00088	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 1065 : 
; 1066 : 	//        .
; 1067 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00094	c7 45 f8 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  0009b	eb 09		 jmp	 SHORT $LN4@SetState_N
$LN2@SetState_N:
  0009d	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  000a0	83 c0 01	 add	 eax, 1
  000a3	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@SetState_N:
  000a6	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  000ad	7d 43		 jge	 SHORT $LN3@SetState_N

; 1068 : 	{
; 1069 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 1070 : 		int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 1071 : 		if( (gObj[n].MapNumber == iMapNum) && (gObj[n].Connected == 3) )
; 1072 : #else
; 1073 : 		if( (gObj[n].MapNumber == MAP_INDEX_BLOODCASTLE1 + iBridgeIndex) && (gObj[n].Connected == 3) )

  000af	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bc	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000c4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000c7	83 c0 0b	 add	 eax, 11			; 0000000bH
  000ca	3b d0		 cmp	 edx, eax
  000cc	75 22		 jne	 SHORT $LN6@SetState_N
  000ce	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  000d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000db	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  000e0	75 0e		 jne	 SHORT $LN6@SetState_N

; 1074 : #endif
; 1075 : 		{					
; 1076 : 			gObjMoveGate(n, 22);

  000e2	6a 16		 push	 22			; 00000016H
  000e4	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000ed	83 c4 08	 add	 esp, 8
$LN6@SetState_N:

; 1077 : 		}
; 1078 : 	}

  000f0	eb ab		 jmp	 SHORT $LN2@SetState_N
$LN3@SetState_N:

; 1079 : 
; 1080 : 	//     .
; 1081 : 	BlockCastleDoor(iBridgeIndex);

  000f2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor
$LN1@SetState_N:

; 1082 : }

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 04 00	 ret	 4
?SetState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_None
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_pMsg$1 = -12						; size = 4
_iTICK_MSEC$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_PlayEnd, COMDAT
; _this$ = ecx

; 1025 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1026 : //	INT iTICK_SEC = (GetTickCount() - m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT) / 1000;
; 1027 : 	INT iTICK_MSEC = (GetTickCount() - m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT);

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00012	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	2b 84 0a 58 01
	00 00		 sub	 eax, DWORD PTR [edx+ecx+344]
  00023	89 45 f8	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 1028 : 	
; 1029 : 	if (iTICK_MSEC >= 1000) {

  00026	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  0002d	0f 8c b8 00 00
	00		 jl	 $LN2@ProcState_

; 1030 : 		m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  00033	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 94 01 54 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+340]
  00044	2b 55 f8	 sub	 edx, DWORD PTR _iTICK_MSEC$[ebp]
  00047	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	89 94 01 54 01
	00 00		 mov	 DWORD PTR [ecx+eax+340], edx

; 1031 : 		m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0005e	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00065	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00068	89 84 0a 58 01
	00 00		 mov	 DWORD PTR [edx+ecx+344], eax

; 1032 : 
; 1033 : #if TESTSERVER == 1
; 1034 : 		//LogAddTD("[Blood Castle] (%d) - PLAY END Check Time. [%d] sec remain", iBridgeIndex+1, m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC/1000);
; 1035 : #endif
; 1036 : 		if ((m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30*1000) && (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0) && (!m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_QUIT)) {

  0006f	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	81 bc 01 54 01
	00 00 30 75 00
	00		 cmp	 DWORD PTR [ecx+eax+340], 30000 ; 00007530H
  00084	7f 65		 jg	 SHORT $LN2@ProcState_
  00086	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	83 bc 01 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+340], 0
  00098	7e 51		 jle	 SHORT $LN2@ProcState_
  0009a	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	0f b6 94 01 6a
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+362]
  000ac	85 d2		 test	 edx, edx
  000ae	75 3b		 jne	 SHORT $LN2@ProcState_

; 1037 : 			m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_QUIT = true;

  000b0	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	c6 84 01 6a 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+362], 1

; 1038 : 			PMSG_SET_DEVILSQUARE pMsg;
; 1039 : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof( pMsg ));

  000c2	6a 04		 push	 4
  000c4	68 92 00 00 00	 push	 146			; 00000092H
  000c9	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1040 : 			pMsg.Type = BC_MSG_BEFORE_QUIT;

  000d5	c6 45 f7 06	 mov	 BYTE PTR _pMsg$1[ebp+3], 6

; 1041 : 			SendBridgeAnyMsg ((LPBYTE)&pMsg, sizeof( pMsg ), iBridgeIndex);

  000d9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000dc	50		 push	 eax
  000dd	6a 04		 push	 4
  000df	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  000e2	51		 push	 ecx
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN2@ProcState_:

; 1042 : 		}
; 1043 : 	}
; 1044 : 
; 1045 : 	if (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0) {

  000eb	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	83 bc 01 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+340], 0
  000fd	7f 0e		 jg	 SHORT $LN1@ProcState_

; 1046 : 		SetState (iBridgeIndex, BLOODCASTLE_STATE_CLOSED);

  000ff	6a 01		 push	 1
  00101	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00104	50		 push	 eax
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN1@ProcState_:

; 1047 : 	}
; 1048 : }

  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 04 00	 ret	 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_PlayEnd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ProcState_Playing@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_pNotice$1 = -564					; size = 272
_pMsg$2 = -292						; size = 4
_pNotice$3 = -288					; size = 272
_pMsg$4 = -16						; size = 4
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Playing, COMDAT
; _this$ = ecx

; 841  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 02 00
	00		 sub	 esp, 692		; 000002b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 842  : //	INT iTICK_SEC = (GetTickCount() - m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT) / 1000;
; 843  : 	INT iTICK_MSEC = (GetTickCount() - m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT);

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0001f	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	2b 84 0a 58 01
	00 00		 sub	 eax, DWORD PTR [edx+ecx+344]
  00030	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 844  : 	
; 845  : 	if (iTICK_MSEC >= 1000) {

  00033	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  0003a	0f 8c e8 04 00
	00		 jl	 $LN2@ProcState_

; 846  : 		m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  00040	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 94 01 54 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+340]
  00051	2b 55 f4	 sub	 edx, DWORD PTR _iTICK_MSEC$[ebp]
  00054	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 94 01 54 01
	00 00		 mov	 DWORD PTR [ecx+eax+340], edx

; 847  : 		m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0006b	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00072	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00075	89 84 0a 58 01
	00 00		 mov	 DWORD PTR [edx+ecx+344], eax

; 848  : 
; 849  : #if TESTSERVER == 1
; 850  : 		//LogAddTD("[Blood Castle] (%d) - PLAYING Check Time. [%d] sec remain", iBridgeIndex+1, m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000);
; 851  : #endif
; 852  : 		if ((m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= (m_iBC_TIME_MIN_PLAY * 60 - BC_MAX_START_WAIT_TERM + 30) * 1000) && (!m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY)) {

  0007c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	6b 91 28 0e 00
	00 3c		 imul	 edx, DWORD PTR [ecx+3624], 60
  0008d	83 ea 1e	 sub	 edx, 30			; 0000001eH
  00090	69 ca e8 03 00
	00		 imul	 ecx, edx, 1000
  00096	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00099	39 8c 02 54 01
	00 00		 cmp	 DWORD PTR [edx+eax+340], ecx
  000a0	7f 51		 jg	 SHORT $LN3@ProcState_
  000a2	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	0f b6 94 01 68
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+360]
  000b4	85 d2		 test	 edx, edx
  000b6	75 3b		 jne	 SHORT $LN3@ProcState_

; 853  : 			m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY = true;

  000b8	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000bf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	c6 84 01 68 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+360], 1

; 854  : 			PMSG_SET_DEVILSQUARE pMsg;
; 855  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof( pMsg ));

  000ca	6a 04		 push	 4
  000cc	68 92 00 00 00	 push	 146			; 00000092H
  000d1	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$4[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 856  : 			pMsg.Type = BC_MSG_BEFORE_PLAY;

  000dd	c6 45 f3 04	 mov	 BYTE PTR _pMsg$4[ebp+3], 4

; 857  : 			SendBridgeAnyMsg ((LPBYTE)&pMsg, sizeof( pMsg ), iBridgeIndex);

  000e1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000e4	50		 push	 eax
  000e5	6a 04		 push	 4
  000e7	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$4[ebp]
  000ea	51		 push	 ecx
  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN3@ProcState_:

; 858  : 		}
; 859  : 
; 860  : 		if (m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE) {

  000f3	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	0f b6 94 01 60
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+352]
  00105	85 d2		 test	 edx, edx
  00107	74 71		 je	 SHORT $LN4@ProcState_

; 861  : 			if (m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN != -1) {

  00109	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00110	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	83 bc 01 80 01
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+384], -1
  0011b	74 5d		 je	 SHORT $LN4@ProcState_

; 862  : 				if (GetTickCount() > m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN) {

  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00123	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0012a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0012d	3b 84 0a 80 01
	00 00		 cmp	 eax, DWORD PTR [edx+ecx+384]
  00134	76 44		 jbe	 SHORT $LN4@ProcState_

; 863  : 					//  BC_MAX_TICK_DOOR_OPEN   ->   
; 864  : 					ReleaseCastleBridge(iBridgeIndex);						

  00136	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00139	50		 push	 eax
  0013a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	e8 00 00 00 00	 call	 ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleBridge

; 865  : 					SendCastleBridgeBlockInfo(iBridgeIndex, false);

  00142	6a 00		 push	 0
  00144	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00147	50		 push	 eax
  00148	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014b	e8 00 00 00 00	 call	 ?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo

; 866  : 					LogAddTD ("[Blood Castle] (%d) Bridge Change Bridge Attribute -> Open", iBridgeIndex+1);

  00150	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00153	83 c0 01	 add	 eax, 1
  00156	50		 push	 eax
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chan@
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00162	83 c4 08	 add	 esp, 8

; 867  : 
; 868  : 					m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = -1;

  00165	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0016c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	c7 84 01 80 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+384], -1
$LN4@ProcState_:

; 869  : 
; 870  : #ifdef ADD_LOG_BLOODCASTLE_DOOR_20070321
; 871  : 					if(m_BridgeData[iBridgeIndex].m_iDoorIndex == -1)
; 872  : 					{
; 873  : 						LogAddTD ("[Blood Castle] (%d) Door Not Subsist", iBridgeIndex+1);
; 874  : 					}
; 875  : 					else
; 876  : 					{
; 877  : 						LogAddTD ("[Blood Castle] (%d) Door Subsist (%d)(Name: %s)(Dieregen:%d)"
; 878  : 							, iBridgeIndex+1, m_BridgeData[iBridgeIndex].m_iDoorIndex
; 879  : 							, gObj[m_BridgeData[iBridgeIndex].m_iDoorIndex].Name
; 880  : 							, gObj[m_BridgeData[iBridgeIndex].m_iDoorIndex].DieRegen);
; 881  : 					}
; 882  : #endif
; 883  : 				}
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 		if ((m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= (m_iBC_TIME_MIN_PLAY * 60 - BC_MAX_START_WAIT_TERM) * 1000) && (!m_BridgeData[iBridgeIndex].m_bBC_PLAY_START)) {

  0017a	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00181	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00184	6b 91 28 0e 00
	00 3c		 imul	 edx, DWORD PTR [ecx+3624], 60
  0018b	83 ea 3c	 sub	 edx, 60			; 0000003cH
  0018e	69 ca e8 03 00
	00		 imul	 ecx, edx, 1000
  00194	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00197	39 8c 02 54 01
	00 00		 cmp	 DWORD PTR [edx+eax+340], ecx
  0019e	0f 8f ec 00 00
	00		 jg	 $LN7@ProcState_
  001a4	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	0f b6 94 01 65
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+357]
  001b6	85 d2		 test	 edx, edx
  001b8	0f 85 d2 00 00
	00		 jne	 $LN7@ProcState_

; 888  : 			//  
; 889  : 			m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = m_iBC_TIME_MIN_PLAY * 60 * 1000;		// BLOODCASTLE_STATE_PLAYING -> BLOODCASTLE_STATE_PLAYEND   

  001be	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001c1	6b 88 28 0e 00
	00 3c		 imul	 ecx, DWORD PTR [eax+3624], 60
  001c8	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  001ce	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001d5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d8	89 94 01 54 01
	00 00		 mov	 DWORD PTR [ecx+eax+340], edx

; 890  : 			m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = false;

  001df	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001e6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e9	c6 84 01 64 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+356], 0

; 891  : 
; 892  : 			//    !!
; 893  : 			PMSG_NOTICE	pNotice;
; 894  : 
; 895  : #ifdef MODIFY_NOTICE_20040325
; 896  : 			TNotice::MakeNoticeMsgEx( &pNotice, 0, lMsg.Get(1161), iBridgeIndex + 1 );

  001f1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  001f4	83 c0 01	 add	 eax, 1
  001f7	50		 push	 eax
  001f8	68 89 04 00 00	 push	 1161			; 00000489H
  001fd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00202	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00208	50		 push	 eax
  00209	6a 00		 push	 0
  0020b	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$3[ebp]
  00211	51		 push	 ecx
  00212	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  00217	83 c4 10	 add	 esp, 16			; 00000010H

; 897  : #else
; 898  : 			pNotice.type = 0;
; 899  : 			wsprintf(pNotice.Notice, lMsg.Get(1161), iBridgeIndex + 1);				// " %d    ."
; 900  : 			PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 901  : #endif
; 902  : 			SendBridgeAnyMsg ((LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  0021a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0021d	50		 push	 eax
  0021e	0f b6 8d e1 fe
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$3[ebp+1]
  00225	51		 push	 ecx
  00226	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _pNotice$3[ebp]
  0022c	52		 push	 edx
  0022d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00230	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 903  : 
; 904  : 
; 905  : 			//         .
; 906  : 			ReleaseCastleEntrance(iBridgeIndex);

  00235	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00238	50		 push	 eax
  00239	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	e8 00 00 00 00	 call	 ?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleEntrance

; 907  : 			SendCastleEntranceBlockInfo(iBridgeIndex, false);

  00241	6a 00		 push	 0
  00243	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00246	50		 push	 eax
  00247	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0024a	e8 00 00 00 00	 call	 ?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo

; 908  : 
; 909  : 			m_BridgeData[iBridgeIndex].m_bBC_PLAY_START = true;

  0024f	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00256	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00259	c6 84 01 65 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+357], 1

; 910  : 			SetMonster(iBridgeIndex);

  00261	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00264	50		 push	 eax
  00265	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00268	e8 00 00 00 00	 call	 ?SetMonster@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonster

; 911  : 
; 912  : 			
; 913  : 			//     .
; 914  : 			SendNoticeState(iBridgeIndex, BC_STATE_START);

  0026d	6a 00		 push	 0
  0026f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00272	50		 push	 eax
  00273	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00276	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 915  : 
; 916  : 			LogAddTD ("[Blood Castle] (%d) Blood Castle Quest Start", iBridgeIndex+1);

  0027b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0027e	83 c0 01	 add	 eax, 1
  00281	50		 push	 eax
  00282	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0028d	83 c4 08	 add	 esp, 8
$LN7@ProcState_:

; 917  : 		}
; 918  : 
; 919  : 
; 920  : 		if ((m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30 * 1000) && (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0) && (!m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END)) {

  00290	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00297	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0029a	81 bc 01 54 01
	00 00 30 75 00
	00		 cmp	 DWORD PTR [ecx+eax+340], 30000 ; 00007530H
  002a5	7f 6e		 jg	 SHORT $LN8@ProcState_
  002a7	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	83 bc 01 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+340], 0
  002b9	7e 5a		 jle	 SHORT $LN8@ProcState_
  002bb	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002c2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c5	0f b6 94 01 69
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+361]
  002cd	85 d2		 test	 edx, edx
  002cf	75 44		 jne	 SHORT $LN8@ProcState_

; 921  : 			m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END = true;

  002d1	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002d8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002db	c6 84 01 69 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+361], 1

; 922  : 			PMSG_SET_DEVILSQUARE pMsg;
; 923  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof( pMsg ));

  002e3	6a 04		 push	 4
  002e5	68 92 00 00 00	 push	 146			; 00000092H
  002ea	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$2[ebp]
  002f0	50		 push	 eax
  002f1	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  002f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 924  : 			pMsg.Type = BC_MSG_BEFORE_END;

  002f9	c6 85 df fe ff
	ff 05		 mov	 BYTE PTR _pMsg$2[ebp+3], 5

; 925  : 			SendBridgeAnyMsg ((LPBYTE)&pMsg, sizeof( pMsg ), iBridgeIndex);

  00300	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00303	50		 push	 eax
  00304	6a 04		 push	 4
  00306	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$2[ebp]
  0030c	51		 push	 ecx
  0030d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00310	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN8@ProcState_:

; 926  : 		}
; 927  : 
; 928  : 
; 929  : 		if (CheckEveryUserDie(iBridgeIndex)) {

  00315	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00318	50		 push	 eax
  00319	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0031c	e8 00 00 00 00	 call	 ?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckEveryUserDie
  00321	0f b6 c8	 movzx	 ecx, al
  00324	85 c9		 test	 ecx, ecx
  00326	0f 84 e0 00 00
	00		 je	 $LN9@ProcState_

; 930  : 			//      .
; 931  : 			PMSG_NOTICE	pNotice;
; 932  : 			
; 933  : #ifdef MODIFY_NOTICE_20040325
; 934  : 			TNotice::MakeNoticeMsg( &pNotice, 0, lMsg.Get(1162) );

  0032c	68 8a 04 00 00	 push	 1162			; 0000048aH
  00331	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00336	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0033c	50		 push	 eax
  0033d	6a 00		 push	 0
  0033f	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$1[ebp]
  00345	50		 push	 eax
  00346	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  0034b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 935  : #else
; 936  : 			pNotice.type = 0;
; 937  : 			wsprintf(pNotice.Notice, lMsg.Get(1162));								// "   ."
; 938  : 			PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 939  : #endif
; 940  : 			SendBridgeAnyMsg ((LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  0034e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00351	50		 push	 eax
  00352	0f b6 8d cd fd
	ff ff		 movzx	 ecx, BYTE PTR _pNotice$1[ebp+1]
  00359	51		 push	 ecx
  0035a	8d 95 cc fd ff
	ff		 lea	 edx, DWORD PTR _pNotice$1[ebp]
  00360	52		 push	 edx
  00361	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00364	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 941  : 
; 942  : 			LogAddTD ("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]", 

  00369	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00370	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00373	8d 94 01 b3 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+435]
  0037a	52		 push	 edx
  0037b	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00382	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00385	8d 94 01 a8 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+424]
  0038c	52		 push	 edx
  0038d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00390	83 c0 01	 add	 eax, 1
  00393	50		 push	 eax
  00394	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
  00399	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0039f	83 c4 10	 add	 esp, 16			; 00000010H

; 943  : 				iBridgeIndex+1, 
; 944  : 				m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID,
; 945  : 				m_BridgeData[iBridgeIndex].m_szKill_Door_CharName
; 946  : 				);
; 947  : 			LogAddTD ("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]",

  003a2	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  003a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ac	8d 94 01 c8 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+456]
  003b3	52		 push	 edx
  003b4	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  003bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003be	8d 94 01 a8 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+424]
  003c5	52		 push	 edx
  003c6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  003c9	83 c0 01	 add	 eax, 1
  003cc	50		 push	 eax
  003cd	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
  003d2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003d8	83 c4 10	 add	 esp, 16			; 00000010H

; 948  : 				iBridgeIndex+1, 
; 949  : 				m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID,
; 950  : 				m_BridgeData[iBridgeIndex].m_szKill_Status_CharName
; 951  : 				);
; 952  : 
; 953  : 			//    .
; 954  : 			GiveReward_Fail(iBridgeIndex);

  003db	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  003de	50		 push	 eax
  003df	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003e2	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 955  : 			
; 956  : 			SetState (iBridgeIndex, BLOODCASTLE_STATE_CLOSED);

  003e7	6a 01		 push	 1
  003e9	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  003ec	50		 push	 eax
  003ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003f0	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 957  : 
; 958  : 			LogAddTD ("[Blood Castle] (%d) Blood Castle Quest Failed -> Every User Out", iBridgeIndex+1);

  003f5	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  003f8	83 c0 01	 add	 eax, 1
  003fb	50		 push	 eax
  003fc	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
  00401	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00407	83 c4 08	 add	 esp, 8

; 959  : 		}

  0040a	eb 60		 jmp	 SHORT $LN10@ProcState_
$LN9@ProcState_:

; 960  : 		else {
; 961  : 			if (m_BridgeData[iBridgeIndex].m_bBC_PLAY_START) {

  0040c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00413	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00416	0f b6 94 01 65
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+357]
  0041e	85 d2		 test	 edx, edx
  00420	74 4a		 je	 SHORT $LN10@ProcState_

; 962  : 				//       .
; 963  : 				if ( !m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE || m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE )

  00422	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00429	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0042c	0f b6 94 01 62
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+354]
  00434	85 d2		 test	 edx, edx
  00436	74 16		 je	 SHORT $LN14@ProcState_
  00438	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0043f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00442	0f b6 94 01 61
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+353]
  0044a	85 d2		 test	 edx, edx
  0044c	74 10		 je	 SHORT $LN12@ProcState_
$LN14@ProcState_:

; 964  : 					SendNoticeState(iBridgeIndex, BC_STATE_PLAY);

  0044e	6a 01		 push	 1
  00450	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00453	50		 push	 eax
  00454	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00457	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState
  0045c	eb 0e		 jmp	 SHORT $LN10@ProcState_
$LN12@ProcState_:

; 965  : 				else
; 966  : 					SendNoticeState(iBridgeIndex, BC_STATE_PLAY_BOSS);

  0045e	6a 04		 push	 4
  00460	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00463	50		 push	 eax
  00464	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00467	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState
$LN10@ProcState_:

; 967  : 			}
; 968  : 		}
; 969  : 
; 970  : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 971  : 		//   
; 972  : 		if (CheckWinnerExist(iBridgeIndex) == true) {

  0046c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0046f	50		 push	 eax
  00470	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00473	e8 00 00 00 00	 call	 ?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerExist
  00478	0f b6 c8	 movzx	 ecx, al
  0047b	83 f9 01	 cmp	 ecx, 1
  0047e	0f 85 a4 00 00
	00		 jne	 $LN2@ProcState_

; 973  : 			if (CheckWinnerValid(iBridgeIndex) == true) {

  00484	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00487	50		 push	 eax
  00488	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0048b	e8 00 00 00 00	 call	 ?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerValid
  00490	0f b6 c8	 movzx	 ecx, al
  00493	83 f9 01	 cmp	 ecx, 1
  00496	75 5c		 jne	 SHORT $LN16@ProcState_

; 974  : 				//      (     )
; 975  : 				if (CheckWinnerPartyComplete(iBridgeIndex) == true) {

  00498	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0049b	50		 push	 eax
  0049c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0049f	e8 00 00 00 00	 call	 ?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
  004a4	0f b6 c8	 movzx	 ecx, al
  004a7	83 f9 01	 cmp	 ecx, 1
  004aa	75 46		 jne	 SHORT $LN18@ProcState_

; 976  : 					//      .
; 977  : 					GiveReward_Win(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX, iBridgeIndex);

  004ac	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  004af	50		 push	 eax
  004b0	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  004b7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  004ba	8b 84 0a 00 02
	00 00		 mov	 eax, DWORD PTR [edx+ecx+512]
  004c1	50		 push	 eax
  004c2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004c5	e8 00 00 00 00	 call	 ?GiveReward_Win@CBloodCastle@@QAEXHH@Z ; CBloodCastle::GiveReward_Win

; 978  : 
; 979  : 					//  .
; 980  : 					SetState(iBridgeIndex, BLOODCASTLE_STATE_PLAYEND);

  004ca	6a 03		 push	 3
  004cc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  004cf	50		 push	 eax
  004d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004d3	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 981  : 
; 982  : 					LogAddTD ("[Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == true", iBridgeIndex+1);

  004d8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  004db	83 c0 01	 add	 eax, 1
  004de	50		 push	 eax
  004df	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinner@
  004e4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004ea	83 c4 08	 add	 esp, 8

; 983  : 					return;

  004ed	e9 09 01 00 00	 jmp	 $LN1@ProcState_
$LN18@ProcState_:

; 984  : 				}
; 985  : 			}

  004f2	eb 34		 jmp	 SHORT $LN2@ProcState_
$LN16@ProcState_:

; 986  : 			else {
; 987  : 				//      .
; 988  : 				GiveReward_Fail(iBridgeIndex);

  004f4	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  004f7	50		 push	 eax
  004f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004fb	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 989  : 
; 990  : 				//  .
; 991  : 				SetState(iBridgeIndex, BLOODCASTLE_STATE_PLAYEND);

  00500	6a 03		 push	 3
  00502	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00505	50		 push	 eax
  00506	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00509	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 992  : 
; 993  : 				LogAddTD ("[Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false", iBridgeIndex+1);

  0050e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00511	83 c0 01	 add	 eax, 1
  00514	50		 push	 eax
  00515	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinner@
  0051a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00520	83 c4 08	 add	 esp, 8

; 994  : 				return;

  00523	e9 d3 00 00 00	 jmp	 $LN1@ProcState_
$LN2@ProcState_:

; 995  : 			}
; 996  : 		}
; 997  : #endif
; 998  : 	}
; 999  : 
; 1000 : 	if (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0) {

  00528	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0052f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00532	83 bc 01 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+340], 0
  0053a	0f 8f bb 00 00
	00		 jg	 $LN1@ProcState_

; 1001 : 		if (!m_BridgeData[iBridgeIndex].m_bBC_REWARDED) {

  00540	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00547	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0054a	0f b6 94 01 66
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+358]
  00552	85 d2		 test	 edx, edx
  00554	0f 85 93 00 00
	00		 jne	 $LN20@ProcState_

; 1002 : 			LogAddTD ("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]", 

  0055a	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00561	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00564	8d 94 01 b3 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+435]
  0056b	52		 push	 edx
  0056c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00573	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00576	8d 94 01 a8 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+424]
  0057d	52		 push	 edx
  0057e	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00581	83 c0 01	 add	 eax, 1
  00584	50		 push	 eax
  00585	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
  0058a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00590	83 c4 10	 add	 esp, 16			; 00000010H

; 1003 : 				iBridgeIndex+1, 
; 1004 : 				m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID,
; 1005 : 				m_BridgeData[iBridgeIndex].m_szKill_Door_CharName
; 1006 : 				);
; 1007 : 			LogAddTD ("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]",

  00593	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0059a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0059d	8d 94 01 c8 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+456]
  005a4	52		 push	 edx
  005a5	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  005ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005af	8d 94 01 d3 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+467]
  005b6	52		 push	 edx
  005b7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  005ba	83 c0 01	 add	 eax, 1
  005bd	50		 push	 eax
  005be	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
  005c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005c9	83 c4 10	 add	 esp, 16			; 00000010H

; 1008 : 				iBridgeIndex+1, 
; 1009 : 				m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID,
; 1010 : 				m_BridgeData[iBridgeIndex].m_szKill_Status_CharName
; 1011 : 				);
; 1012 : 
; 1013 : 			//    .
; 1014 : 			GiveReward_Fail(iBridgeIndex);

  005cc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  005cf	50		 push	 eax
  005d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005d3	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 1015 : 
; 1016 : 			LogAddTD ("[Blood Castle] (%d) Blood Castle Quest Failed -> Time Out", iBridgeIndex+1);

  005d8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  005db	83 c0 01	 add	 eax, 1
  005de	50		 push	 eax
  005df	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castl@
  005e4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005ea	83 c4 08	 add	 esp, 8
$LN20@ProcState_:

; 1017 : 		}
; 1018 : 
; 1019 : 		SetState (iBridgeIndex, BLOODCASTLE_STATE_PLAYEND);

  005ed	6a 03		 push	 3
  005ef	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  005f2	50		 push	 eax
  005f3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005f6	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN1@ProcState_:

; 1020 : 	}
; 1021 : }

  005fb	5f		 pop	 edi
  005fc	5e		 pop	 esi
  005fd	5b		 pop	 ebx
  005fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00601	33 cd		 xor	 ecx, ebp
  00603	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00608	8b e5		 mov	 esp, ebp
  0060a	5d		 pop	 ebp
  0060b	c2 04 00	 ret	 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Playing
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ProcState_Closed@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv247 = -364						; size = 4
tv234 = -364						; size = 4
tv248 = -360						; size = 4
tv235 = -360						; size = 4
_n$1 = -292						; size = 4
_pMsg$2 = -288						; size = 4
_pNotice$3 = -284					; size = 272
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Closed, COMDAT
; _this$ = ecx

; 766  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 767  : //	INT iTICK_SEC = (GetTickCount() - m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT) / 1000;
; 768  : 	INT iTICK_MSEC = (GetTickCount() - m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT);

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0001f	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	2b 84 0a 58 01
	00 00		 sub	 eax, DWORD PTR [edx+ecx+344]
  00030	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 769  : 	
; 770  : 	if (iTICK_MSEC >= 1000) {

  00033	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  0003a	0f 8c 82 03 00
	00		 jl	 $LN5@ProcState_

; 771  : 		m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  00040	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 94 01 54 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+340]
  00051	2b 55 f4	 sub	 edx, DWORD PTR _iTICK_MSEC$[ebp]
  00054	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 94 01 54 01
	00 00		 mov	 DWORD PTR [ecx+eax+340], edx

; 772  : 		m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0006b	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00072	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00075	89 84 0a 58 01
	00 00		 mov	 DWORD PTR [edx+ecx+344], eax

; 773  : 
; 774  : #if TESTSERVER == 1
; 775  : 		//LogAddTD("[Blood Castle] (%d) - CLOSED Check Time. [%d] sec remain", iBridgeIndex+1, m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000);
; 776  : #endif
; 777  : 		if (g_bBloodCastle) {

  0007c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  00083	0f 84 39 03 00
	00		 je	 $LN5@ProcState_

; 778  : 			if ( (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= m_iBC_TIME_MIN_OPEN * 60 * 1000) && (! m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER) ) {

  00089	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	6b 91 24 0e 00
	00 3c		 imul	 edx, DWORD PTR [ecx+3620], 60
  0009a	69 ca e8 03 00
	00		 imul	 ecx, edx, 1000
  000a0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	39 8c 02 54 01
	00 00		 cmp	 DWORD PTR [edx+eax+340], ecx
  000aa	7f 3a		 jg	 SHORT $LN7@ProcState_
  000ac	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000b3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	0f b6 94 01 63
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+355]
  000be	85 d2		 test	 edx, edx
  000c0	75 24		 jne	 SHORT $LN7@ProcState_

; 779  : 				//     .
; 780  : 				m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = true;

  000c2	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000c9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	c6 84 01 63 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+355], 1

; 781  : 				m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = true;

  000d4	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	c6 84 01 64 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+356], 1
$LN7@ProcState_:

; 782  : 			}
; 783  : 			
; 784  : 			// > .     . !!
; 785  : 			if ((m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= m_iBC_TIME_MIN_OPEN * 60 * 1000) && (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0) && (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / (60*1000) != m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT )) {	

  000e6	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	6b 91 24 0e 00
	00 3c		 imul	 edx, DWORD PTR [ecx+3620], 60
  000f7	69 ca e8 03 00
	00		 imul	 ecx, edx, 1000
  000fd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00100	39 8c 02 54 01
	00 00		 cmp	 DWORD PTR [edx+eax+340], ecx
  00107	0f 8f c2 00 00
	00		 jg	 $LN8@ProcState_
  0010d	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00114	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	83 bc 01 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+340], 0
  0011f	0f 8e aa 00 00
	00		 jle	 $LN8@ProcState_
  00125	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00136	99		 cdq
  00137	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  0013c	f7 f9		 idiv	 ecx
  0013e	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00145	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	3b 84 11 5c 01
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+348]
  0014f	74 7e		 je	 SHORT $LN8@ProcState_

; 786  : 				m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT = m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / (60*1000);

  00151	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00158	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00162	99		 cdq
  00163	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  00168	f7 f9		 idiv	 ecx
  0016a	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00171	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	89 84 11 5c 01
	00 00		 mov	 DWORD PTR [ecx+edx+348], eax

; 787  : 
; 788  : 				//   1 .
; 789  : 				if (!iBridgeIndex) {

  0017b	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0017f	75 4e		 jne	 SHORT $LN8@ProcState_

; 790  : 					//    1   =>   
; 791  : 					PMSG_NOTICE	pNotice;
; 792  : 
; 793  : #ifdef MODIFY_NOTICE_20040325
; 794  : 					TNotice::MakeNoticeMsgEx( &pNotice, 0, lMsg.Get(1160), m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT + 1);

  00181	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00188	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	8b 94 01 5c 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+348]
  00192	83 c2 01	 add	 edx, 1
  00195	52		 push	 edx
  00196	68 88 04 00 00	 push	 1160			; 00000488H
  0019b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001a6	50		 push	 eax
  001a7	6a 00		 push	 0
  001a9	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  001b5	83 c4 10	 add	 esp, 16			; 00000010H

; 795  : #else
; 796  : 					pNotice.type = 0;
; 797  : 					wsprintf(pNotice.Notice, lMsg.Get(1160), m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT + 1);		// "  %d  ."
; 798  : 					PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 799  : #endif
; 800  : 					SendAllUserAnyMsg ((LPBYTE) &pNotice, pNotice.h.size);

  001b8	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$3[ebp+1]
  001bf	50		 push	 eax
  001c0	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$3[ebp]
  001c6	51		 push	 ecx
  001c7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ca	e8 00 00 00 00	 call	 ?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ; CBloodCastle::SendAllUserAnyMsg
$LN8@ProcState_:

; 801  : 				}
; 802  : 			}
; 803  : 
; 804  : 			if ((m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30 * 1000) && (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0) && (!m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER)) {

  001cf	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001d6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	81 bc 01 54 01
	00 00 30 75 00
	00		 cmp	 DWORD PTR [ecx+eax+340], 30000 ; 00007530H
  001e4	0f 8f d8 01 00
	00		 jg	 $LN5@ProcState_
  001ea	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001f1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f4	83 bc 01 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+340], 0
  001fc	0f 8e c0 01 00
	00		 jle	 $LN5@ProcState_
  00202	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00209	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0020c	0f b6 94 01 67
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+359]
  00214	85 d2		 test	 edx, edx
  00216	0f 85 a6 01 00
	00		 jne	 $LN5@ProcState_

; 805  : 				m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER = true;

  0021c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00223	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00226	c6 84 01 67 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+359], 1

; 806  : 
; 807  : 				if (!iBridgeIndex) {

  0022e	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00232	0f 85 8a 01 00
	00		 jne	 $LN5@ProcState_

; 808  : 					//    1   =>   
; 809  : 					PMSG_SET_DEVILSQUARE pMsg;
; 810  : 					PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof( pMsg ));

  00238	6a 04		 push	 4
  0023a	68 92 00 00 00	 push	 146			; 00000092H
  0023f	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$2[ebp]
  00245	50		 push	 eax
  00246	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0024b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 811  : 					pMsg.Type = BC_MSG_BEFORE_ENTER;

  0024e	c6 85 e3 fe ff
	ff 03		 mov	 BYTE PTR _pMsg$2[ebp+3], 3

; 812  : 
; 813  : 					for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00255	c7 85 dc fe ff
	ff 00 19 00 00	 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  0025f	eb 0f		 jmp	 SHORT $LN4@ProcState_
$LN2@ProcState_:
  00261	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00267	83 c0 01	 add	 eax, 1
  0026a	89 85 dc fe ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@ProcState_:
  00270	81 bd dc fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  0027a	0f 8d 42 01 00
	00		 jge	 $LN5@ProcState_

; 814  : 					{
; 815  : 						if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) )

  00280	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0028a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00290	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00295	0f 85 22 01 00
	00		 jne	 $LN12@ProcState_
  0029b	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  002a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ab	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  002b0	83 fa 01	 cmp	 edx, 1
  002b3	0f 85 04 01 00
	00		 jne	 $LN12@ProcState_

; 816  : 						{
; 817  : 							if (!CHECK_BLOODCASTLE(gObj[n].MapNumber)
; 818  : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 819  : 								&& !CHECK_CHAOSCASTLE(gObj[n].MapNumber)	//      .

  002b9	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  002c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c9	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  002d1	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  002d4	7d 0c		 jge	 SHORT $LN20@ProcState_
  002d6	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
  002e0	eb 3f		 jmp	 SHORT $LN21@ProcState_
$LN20@ProcState_:
  002e2	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f2	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  002fa	83 fa 11	 cmp	 edx, 17			; 00000011H
  002fd	7e 0c		 jle	 SHORT $LN18@ProcState_
  002ff	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv234[ebp], 0
  00309	eb 0a		 jmp	 SHORT $LN19@ProcState_
$LN18@ProcState_:
  0030b	c7 85 94 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv234[ebp], 1
$LN19@ProcState_:
  00315	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv234[ebp]
  0031b	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv235[ebp], eax
$LN21@ProcState_:
  00321	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv235[ebp], 0
  00328	0f 85 8f 00 00
	00		 jne	 $LN12@ProcState_
  0032e	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00338	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0033e	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00346	83 fa 12	 cmp	 edx, 18			; 00000012H
  00349	7d 0c		 jge	 SHORT $LN24@ProcState_
  0034b	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv248[ebp], 0
  00355	eb 3f		 jmp	 SHORT $LN25@ProcState_
$LN24@ProcState_:
  00357	69 85 dc fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00361	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00367	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0036f	83 fa 17	 cmp	 edx, 23			; 00000017H
  00372	7e 0c		 jle	 SHORT $LN22@ProcState_
  00374	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv247[ebp], 0
  0037e	eb 0a		 jmp	 SHORT $LN23@ProcState_
$LN22@ProcState_:
  00380	c7 85 94 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv247[ebp], 1
$LN23@ProcState_:
  0038a	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv247[ebp]
  00390	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv248[ebp], eax
$LN25@ProcState_:
  00396	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv248[ebp], 0
  0039d	75 1e		 jne	 SHORT $LN12@ProcState_

; 820  : #endif
; 821  : 								)		//      .
; 822  : 								DataSend(n, (LPBYTE)&pMsg, pMsg.h.size);

  0039f	0f b6 85 e1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$2[ebp+1]
  003a6	50		 push	 eax
  003a7	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$2[ebp]
  003ad	51		 push	 ecx
  003ae	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _n$1[ebp]
  003b4	52		 push	 edx
  003b5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003ba	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@ProcState_:

; 823  : 						}
; 824  : 					}

  003bd	e9 9f fe ff ff	 jmp	 $LN2@ProcState_
$LN5@ProcState_:

; 825  : 				}
; 826  : 			}
; 827  : 		}
; 828  : 	}
; 829  : 
; 830  : 	if (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0) {

  003c2	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  003c9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003cc	83 bc 01 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+340], 0
  003d4	7f 27		 jg	 SHORT $LN1@ProcState_

; 831  : 		if (g_bBloodCastle)

  003d6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  003dd	74 10		 je	 SHORT $LN15@ProcState_

; 832  : 			SetState (iBridgeIndex, BLOODCASTLE_STATE_PLAYING);

  003df	6a 02		 push	 2
  003e1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  003e4	50		 push	 eax
  003e5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003e8	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
  003ed	eb 0e		 jmp	 SHORT $LN1@ProcState_
$LN15@ProcState_:

; 833  : 		else
; 834  : 			SetState (iBridgeIndex, BLOODCASTLE_STATE_CLOSED);

  003ef	6a 01		 push	 1
  003f1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  003f4	50		 push	 eax
  003f5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003f8	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN1@ProcState_:

; 835  : 	}
; 836  : 
; 837  : }

  003fd	5f		 pop	 edi
  003fe	5e		 pop	 esi
  003ff	5b		 pop	 ebx
  00400	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00403	33 cd		 xor	 ecx, ebp
  00405	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040a	8b e5		 mov	 esp, ebp
  0040c	5d		 pop	 ebp
  0040d	c2 04 00	 ret	 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Closed
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ProcState_None@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_None, COMDAT
; _this$ = ecx

; 760  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 761  : 	
; 762  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?ProcState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_None
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ClearBridgeData@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv66 = -80						; size = 4
tv67 = -76						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ClearBridgeData, COMDAT
; _this$ = ecx

; 616  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 617  : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN10@ClearBridg
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN11@ClearBridg
$LN10@ClearBridg:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN8@ClearBridg
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN9@ClearBridg
$LN8@ClearBridg:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@ClearBridg:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN11@ClearBridg:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@ClearBridg

; 618  : 		return;

  0003d	e9 a7 04 00 00	 jmp	 $LN1@ClearBridg
$LN5@ClearBridg:

; 619  : 
; 620  : 	m_BridgeData[iBridgeIndex].m_iTOTAL_EXP							= 0;

  00042	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	c7 84 01 3c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+316], 0

; 621  : 	m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT				= 0;

  00057	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	c7 84 01 74 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+372], 0

; 622  : 	m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT				= 0;

  0006c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	c7 84 01 78 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+376], 0

; 623  : 	m_BridgeData[iBridgeIndex].m_iBC_MONSTER_SUCCESS_MSG_COUNT		= 0;

  00081	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	c7 84 01 7c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+380], 0

; 624  : 	m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT			= 0;

  00096	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	c7 84 01 84 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+388], 0

; 625  : 	m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT		= 0;

  000ab	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	c7 84 01 88 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+392], 0

; 626  : 	m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT	= 0;

  000c0	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	c7 84 01 8c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+396], 0

; 627  : 	m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER				= 0;

  000d5	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	c6 84 01 98 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+408], 0

; 628  : 	m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN				= -1;

  000e7	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	c7 84 01 80 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+384], -1

; 629  : 	m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL				= -1;

  000fc	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00103	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	c7 84 01 90 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+400], -1

; 630  : 	m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX			= -1;

  00111	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00118	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	c7 84 01 94 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+404], -1

; 631  : 	m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS					= -1;

  00126	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	c7 84 01 48 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+328], -1

; 632  : 	m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT					= -1;

  0013b	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00142	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00145	c7 84 01 5c 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+348], -1

; 633  : 	m_BridgeData[iBridgeIndex].m_bCASTLE_DOOR_LIVE					= TRUE;

  00150	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00157	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	c7 84 01 4c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+332], 1

; 634  : 	m_BridgeData[iBridgeIndex].m_bBC_REWARDED						= FALSE;

  00165	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	c6 84 01 66 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+358], 0

; 635  : 	m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER				= FALSE;

  00177	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0017e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	c6 84 01 67 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+359], 0

; 636  : 	m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY				= FALSE;

  00189	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00190	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	c6 84 01 68 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+360], 0

; 637  : 	m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END					= FALSE;

  0019b	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	c6 84 01 69 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+361], 0

; 638  : 	m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_QUIT				= FALSE;

  001ad	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	c6 84 01 6a 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+362], 0

; 639  : 	m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER						= FALSE;

  001bf	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c9	c6 84 01 63 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+355], 0

; 640  : 	m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY						= FALSE;

  001d1	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	c6 84 01 64 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+356], 0

; 641  : 	m_BridgeData[iBridgeIndex].m_bBC_PLAY_START						= FALSE;

  001e3	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ed	c6 84 01 65 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+357], 0

; 642  : 	m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE			= FALSE;

  001f5	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	c6 84 01 60 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+352], 0

; 643  : 	m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE		= FALSE;

  00207	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0020e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00211	c6 84 01 61 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+353], 0

; 644  : 
; 645  : 	m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE		= FALSE;

  00219	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00220	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00223	c6 84 01 62 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+354], 0

; 646  : 	
; 647  : 
; 648  : 	m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index			= -10;

  0022b	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00232	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00235	c7 84 01 a4 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+420], -10 ; fffffff6H

; 649  : 	m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party			= -10;

  00240	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00247	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024a	c7 84 01 a0 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+416], -10 ; fffffff6H

; 650  : 	m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index		= -10;

  00255	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0025c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	c7 84 01 c4 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+452], -10 ; fffffff6H

; 651  : 	m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party		= -10;

  0026a	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00271	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00274	c7 84 01 c0 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+448], -10 ; fffffff6H

; 652  : 	m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index			= -10;

  0027f	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00286	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00289	c7 84 01 e4 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+484], -10 ; fffffff6H

; 653  : 	m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party			= -10;

  00294	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0029b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029e	c7 84 01 e0 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [ecx+eax+480], -10 ; fffffff6H

; 654  : 
; 655  : 	memset(m_BridgeData[iBridgeIndex].m_szKill_Door_CharName, '\0', MAX_IDSTRING+1);

  002a9	6a 0b		 push	 11			; 0000000bH
  002ab	6a 00		 push	 0
  002ad	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b7	8d 94 01 b3 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+435]
  002be	52		 push	 edx
  002bf	e8 00 00 00 00	 call	 _memset
  002c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 656  : 	memset(m_BridgeData[iBridgeIndex].m_szKill_Status_CharName, '\0', MAX_IDSTRING+1);

  002c7	6a 0b		 push	 11			; 0000000bH
  002c9	6a 00		 push	 0
  002cb	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d5	8d 94 01 c8 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+456]
  002dc	52		 push	 edx
  002dd	e8 00 00 00 00	 call	 _memset
  002e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 657  : 	memset(m_BridgeData[iBridgeIndex].m_szWin_Quest_CharName, '\0', MAX_IDSTRING+1);

  002e5	6a 0b		 push	 11			; 0000000bH
  002e7	6a 00		 push	 0
  002e9	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f3	8d 94 01 e8 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+488]
  002fa	52		 push	 edx
  002fb	e8 00 00 00 00	 call	 _memset
  00300	83 c4 0c	 add	 esp, 12			; 0000000cH

; 658  : 
; 659  : 	memset(m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, '\0', MAX_IDSTRING+1);

  00303	6a 0b		 push	 11			; 0000000bH
  00305	6a 00		 push	 0
  00307	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0030e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00311	8d 94 01 a8 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+424]
  00318	52		 push	 edx
  00319	e8 00 00 00 00	 call	 _memset
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  : 	memset(m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID, '\0', MAX_IDSTRING+1);

  00321	6a 0b		 push	 11			; 0000000bH
  00323	6a 00		 push	 0
  00325	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0032c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0032f	8d 94 01 d3 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+467]
  00336	52		 push	 edx
  00337	e8 00 00 00 00	 call	 _memset
  0033c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 661  : 	memset(m_BridgeData[iBridgeIndex].m_szWin_Quest_AccountID, '\0', MAX_IDSTRING+1);

  0033f	6a 0b		 push	 11			; 0000000bH
  00341	6a 00		 push	 0
  00343	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0034a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0034d	8d 94 01 f3 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+499]
  00354	52		 push	 edx
  00355	e8 00 00 00 00	 call	 _memset
  0035a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 662  : 	
; 663  : 	for (INT i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  0035d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00364	eb 09		 jmp	 SHORT $LN4@ClearBridg
$LN2@ClearBridg:
  00366	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00369	83 c0 01	 add	 eax, 1
  0036c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@ClearBridg:
  0036f	83 7d f8 0a	 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  00373	0f 8d 70 01 00
	00		 jge	 $LN1@ClearBridg

; 664  : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) {

  00379	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00380	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00383	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00387	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0038b	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  00390	0f 84 a3 00 00
	00		 je	 $LN6@ClearBridg

; 665  : 			gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  00396	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0039d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a0	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  003a4	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  003a8	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  003b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b6	c7 84 0a d4 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [edx+ecx+3284], 0

; 666  : 			gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  003c1	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  003c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003cb	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  003cf	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  003d3	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  003db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003e1	c6 84 0a d2 0c
	00 00 ff	 mov	 BYTE PTR [edx+ecx+3282], -1

; 667  : 			gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  003e9	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  003f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003f3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  003f7	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  003fb	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00403	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00409	c6 84 0a d3 0c
	00 00 ff	 mov	 BYTE PTR [edx+ecx+3283], -1

; 668  : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 669  : 			gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  00411	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00418	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0041b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0041f	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00423	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0042b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00431	c6 84 0a d8 0c
	00 00 00	 mov	 BYTE PTR [edx+ecx+3288], 0
$LN6@ClearBridg:

; 670  : #endif
; 671  : 		}
; 672  : 
; 673  : 		m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP					= 0;

  00439	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00440	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00443	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00447	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0044b	c7 44 02 1c 00
	00 00 00	 mov	 DWORD PTR [edx+eax+28], 0

; 674  : 		m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore				= 0;

  00453	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0045a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0045d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00461	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00465	c7 44 02 20 00
	00 00 00	 mov	 DWORD PTR [edx+eax+32], 0

; 675  : 		m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex				= -1;

  0046d	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00474	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00477	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0047b	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0047f	c7 44 02 18 ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+24], -1

; 676  : 		m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState			= BC_USER_ALIVE;

  00487	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0048e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00491	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00495	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00499	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0

; 677  : 		m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg			= false;

  004a1	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  004a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ab	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  004af	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  004b3	c6 44 02 28 00	 mov	 BYTE PTR [edx+eax+40], 0

; 678  : 		m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak	= false;

  004b8	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  004bf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004c2	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  004c6	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  004ca	c6 44 02 29 00	 mov	 BYTE PTR [edx+eax+41], 0

; 679  : 
; 680  : #ifdef BLOODCASTLE_SENDPOINT_BUGFIX_20040604
; 681  : 		memset(m_BridgeData[iBridgeIndex].m_UserData[i].m_szAccountID, 0, sizeof(m_BridgeData[iBridgeIndex].m_UserData[i].m_szAccountID));
; 682  : 		memset(m_BridgeData[iBridgeIndex].m_UserData[i].m_szCharName, 0, sizeof(m_BridgeData[iBridgeIndex].m_UserData[i].m_szCharName));
; 683  : 		m_BridgeData[iBridgeIndex].m_UserData[i].m_iCharClass = -1;
; 684  : 		m_BridgeData[iBridgeIndex].m_UserData[i].m_iBloodCastleIndex = -1;
; 685  : 		m_BridgeData[iBridgeIndex].m_UserData[i].m_iBloodCastleSubIndex = -1;
; 686  : #endif	
; 687  : 
; 688  : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 689  : 		m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  004cf	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  004d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004d9	c7 84 01 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+512], -1

; 690  : #endif
; 691  : 		
; 692  : #ifdef ADD_LOG_BLOODCASTLE_DOOR_20070321
; 693  : 		m_BridgeData[iBridgeIndex].m_iDoorIndex				= -1;
; 694  : #endif
; 695  : 	}

  004e4	e9 7d fe ff ff	 jmp	 $LN2@ClearBridg
$LN1@ClearBridg:

; 696  : }

  004e9	5f		 pop	 edi
  004ea	5e		 pop	 esi
  004eb	5b		 pop	 ebx
  004ec	8b e5		 mov	 esp, ebp
  004ee	5d		 pop	 ebp
  004ef	c2 04 00	 ret	 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ClearBridgeData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckSync@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv76 = -88						; size = 4
tv66 = -88						; size = 4
tv79 = -84						; size = 4
tv77 = -84						; size = 4
tv67 = -84						; size = 4
_ltime$ = -16						; size = 8
_today$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckSync@CBloodCastle@@IAEXH@Z PROC			; CBloodCastle::CheckSync, COMDAT
; _this$ = ecx

; 523  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 524  : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN19@CheckSync
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN20@CheckSync
$LN19@CheckSync:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN17@CheckSync
  00021	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN18@CheckSync
$LN17@CheckSync:
  0002a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN18@CheckSync:
  00031	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN20@CheckSync:
  00037	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN4@CheckSync

; 525  : 		return;

  0003d	e9 66 02 00 00	 jmp	 $LN1@CheckSync
$LN4@CheckSync:

; 526  : 	
; 527  : 	
; 528  : #if TESTSERVER == 1
; 529  : 	//  
; 530  : 	//m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = m_iBC_TIME_MIN_OPEN * 60 * 1000 ;
; 531  : 
; 532  : #ifdef FOR_ONAIR
; 533  : 	m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (m_iBC_TIME_MIN_OPEN + 5) * 60 * 1000 ;
; 534  : #else
; 535  : 	m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (m_iBC_TIME_MIN_OPEN + 1) * 60 * 1000 ;
; 536  : #endif
; 537  : 	m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();
; 538  : #else
; 539  : 	
; 540  : 	struct tm * today;
; 541  : 	time_t ltime;
; 542  : 	
; 543  : 	time( &ltime );

  00042	8d 45 f0	 lea	 eax, DWORD PTR _ltime$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _time
  0004b	83 c4 04	 add	 esp, 4

; 544  : 	today = localtime( &ltime );

  0004e	8d 45 f0	 lea	 eax, DWORD PTR _ltime$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _localtime
  00057	83 c4 04	 add	 esp, 4
  0005a	89 45 f8	 mov	 DWORD PTR _today$[ebp], eax

; 545  : 
; 546  : 	if(!CHECK_LIMIT(g_iBloodCastle_StartHour-1,2))

  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_iBloodCastle_StartHour@@3HA ; g_iBloodCastle_StartHour
  00062	83 e8 01	 sub	 eax, 1
  00065	79 09		 jns	 SHORT $LN23@CheckSync
  00067	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  0006e	eb 24		 jmp	 SHORT $LN24@CheckSync
$LN23@CheckSync:
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_iBloodCastle_StartHour@@3HA ; g_iBloodCastle_StartHour
  00076	83 e9 01	 sub	 ecx, 1
  00079	83 f9 01	 cmp	 ecx, 1
  0007c	7e 09		 jle	 SHORT $LN21@CheckSync
  0007e	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  00085	eb 07		 jmp	 SHORT $LN22@CheckSync
$LN21@CheckSync:
  00087	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
$LN22@CheckSync:
  0008e	8b 55 a8	 mov	 edx, DWORD PTR tv76[ebp]
  00091	89 55 ac	 mov	 DWORD PTR tv77[ebp], edx
$LN24@CheckSync:
  00094	83 7d ac 00	 cmp	 DWORD PTR tv77[ebp], 0
  00098	75 0a		 jne	 SHORT $LN5@CheckSync

; 547  : 		g_iBloodCastle_StartHour = 1;

  0009a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iBloodCastle_StartHour@@3HA, 1 ; g_iBloodCastle_StartHour
$LN5@CheckSync:

; 548  : 
; 549  : 	switch(g_iBloodCastle_StartHour) {

  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_iBloodCastle_StartHour@@3HA ; g_iBloodCastle_StartHour
  000a9	89 45 ac	 mov	 DWORD PTR tv79[ebp], eax
  000ac	83 7d ac 02	 cmp	 DWORD PTR tv79[ebp], 2
  000b0	74 05		 je	 SHORT $LN6@CheckSync
  000b2	e9 05 01 00 00	 jmp	 $LN12@CheckSync
$LN6@CheckSync:

; 550  : 	case 2 :	// 2
; 551  : 		{
; 552  : #ifdef UPDATE_DEVIL_SQUARE_START_TIME_20070511	//     
; 553  : #ifdef UPDATE_BLOODECASTLE_SCADULE_20070702
; 554  : 			if( (today->tm_hour%2) == g_iBloodCastle_odd_Even_Hour)
; 555  : #else
; 556  : 			if( (today->tm_hour%2) )
; 557  : #endif
; 558  : #else
; 559  : 			if( !(today->tm_hour%2) )

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  000ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000bd	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  000c3	79 05		 jns	 SHORT $LN25@CheckSync
  000c5	49		 dec	 ecx
  000c6	83 c9 fe	 or	 ecx, -2			; fffffffeH
  000c9	41		 inc	 ecx
$LN25@CheckSync:
  000ca	85 c9		 test	 ecx, ecx
  000cc	75 6c		 jne	 SHORT $LN7@CheckSync

; 560  : #endif
; 561  : 			{
; 562  : 				// 
; 563  : 				if ((today->tm_min * 60 + today->tm_sec) >= 30 * 60) {

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  000d1	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  000d5	8b 55 f8	 mov	 edx, DWORD PTR _today$[ebp]
  000d8	03 0a		 add	 ecx, DWORD PTR [edx]
  000da	81 f9 08 07 00
	00		 cmp	 ecx, 1800		; 00000708H
  000e0	7c 2c		 jl	 SHORT $LN9@CheckSync

; 564  : 					// 30  -> 2  30 
; 565  : 					m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (((60*2 + 30) * 60) - (today->tm_min * 60 + today->tm_sec)) * 1000;

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  000e5	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  000e9	8b 55 f8	 mov	 edx, DWORD PTR _today$[ebp]
  000ec	03 0a		 add	 ecx, DWORD PTR [edx]
  000ee	b8 28 23 00 00	 mov	 eax, 9000		; 00002328H
  000f3	2b c1		 sub	 eax, ecx
  000f5	69 c8 e8 03 00
	00		 imul	 ecx, eax, 1000
  000fb	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00102	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00105	89 8c 10 54 01
	00 00		 mov	 DWORD PTR [eax+edx+340], ecx

; 566  : 				}

  0010c	eb 2a		 jmp	 SHORT $LN10@CheckSync
$LN9@CheckSync:

; 567  : 				else {
; 568  : 					// 30   -> 
; 569  : 					m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = ((30*60) - (today->tm_min * 60 + today->tm_sec)) * 1000;

  0010e	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  00111	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  00115	8b 55 f8	 mov	 edx, DWORD PTR _today$[ebp]
  00118	03 0a		 add	 ecx, DWORD PTR [edx]
  0011a	b8 08 07 00 00	 mov	 eax, 1800		; 00000708H
  0011f	2b c1		 sub	 eax, ecx
  00121	69 c8 e8 03 00
	00		 imul	 ecx, eax, 1000
  00127	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  0012e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00131	89 8c 10 54 01
	00 00		 mov	 DWORD PTR [eax+edx+340], ecx
$LN10@CheckSync:

; 570  : 				}
; 571  : 			}

  00138	eb 2a		 jmp	 SHORT $LN8@CheckSync
$LN7@CheckSync:

; 572  : 			else
; 573  : 			{
; 574  : 				// 
; 575  : 				m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (((60 + 30) * 60) - (today->tm_min * 60 + today->tm_sec)) * 1000;

  0013a	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  0013d	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  00141	8b 55 f8	 mov	 edx, DWORD PTR _today$[ebp]
  00144	03 0a		 add	 ecx, DWORD PTR [edx]
  00146	b8 18 15 00 00	 mov	 eax, 5400		; 00001518H
  0014b	2b c1		 sub	 eax, ecx
  0014d	69 c8 e8 03 00
	00		 imul	 ecx, eax, 1000
  00153	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  0015a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015d	89 8c 10 54 01
	00 00		 mov	 DWORD PTR [eax+edx+340], ecx
$LN8@CheckSync:

; 576  : 			}
; 577  : 			
; 578  : 			if( m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 0 )

  00164	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0016b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	83 bc 01 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+340], 0
  00176	7d 28		 jge	 SHORT $LN11@CheckSync

; 579  : 			{
; 580  : 				m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC += (60 * 60) * 1000;

  00178	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0017f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	8b 94 01 54 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+340]
  00189	81 c2 80 ee 36
	00		 add	 edx, 3600000		; 0036ee80H
  0018f	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00196	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	89 94 01 54 01
	00 00		 mov	 DWORD PTR [ecx+eax+340], edx
$LN11@CheckSync:

; 581  : 			}
; 582  : 			
; 583  : 			m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001a6	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  001ad	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001b0	89 84 0a 58 01
	00 00		 mov	 DWORD PTR [edx+ecx+344], eax

; 584  : 		}
; 585  : 		break;

  001b7	e9 bd 00 00 00	 jmp	 $LN2@CheckSync
$LN12@CheckSync:

; 586  : 	case 1 :	// 1
; 587  : 	default:
; 588  : 		{
; 589  : 			if ((today->tm_min * 60 + today->tm_sec) >= 30 * 60) {

  001bc	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  001bf	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  001c3	8b 55 f8	 mov	 edx, DWORD PTR _today$[ebp]
  001c6	03 0a		 add	 ecx, DWORD PTR [edx]
  001c8	81 f9 08 07 00
	00		 cmp	 ecx, 1800		; 00000708H
  001ce	7c 2c		 jl	 SHORT $LN13@CheckSync

; 590  : 				// 30  -> 1  30 
; 591  : 				m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = ((60*60) + (30*60) - (today->tm_min * 60 + today->tm_sec)) * 1000;

  001d0	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  001d3	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  001d7	8b 55 f8	 mov	 edx, DWORD PTR _today$[ebp]
  001da	03 0a		 add	 ecx, DWORD PTR [edx]
  001dc	b8 18 15 00 00	 mov	 eax, 5400		; 00001518H
  001e1	2b c1		 sub	 eax, ecx
  001e3	69 c8 e8 03 00
	00		 imul	 ecx, eax, 1000
  001e9	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  001f0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001f3	89 8c 10 54 01
	00 00		 mov	 DWORD PTR [eax+edx+340], ecx

; 592  : 			}

  001fa	eb 2a		 jmp	 SHORT $LN14@CheckSync
$LN13@CheckSync:

; 593  : 			else {
; 594  : 				// 30   -> 
; 595  : 				m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = ((30*60) - (today->tm_min * 60 + today->tm_sec)) * 1000;

  001fc	8b 45 f8	 mov	 eax, DWORD PTR _today$[ebp]
  001ff	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  00203	8b 55 f8	 mov	 edx, DWORD PTR _today$[ebp]
  00206	03 0a		 add	 ecx, DWORD PTR [edx]
  00208	b8 08 07 00 00	 mov	 eax, 1800		; 00000708H
  0020d	2b c1		 sub	 eax, ecx
  0020f	69 c8 e8 03 00
	00		 imul	 ecx, eax, 1000
  00215	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  0021c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0021f	89 8c 10 54 01
	00 00		 mov	 DWORD PTR [eax+edx+340], ecx
$LN14@CheckSync:

; 596  : 			}
; 597  : 
; 598  : 			if( m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 0 )

  00226	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0022d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00230	83 bc 01 54 01
	00 00 00	 cmp	 DWORD PTR [ecx+eax+340], 0
  00238	7d 28		 jge	 SHORT $LN15@CheckSync

; 599  : 			{
; 600  : 				m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC += ((60 * 60)) * 1000;

  0023a	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00241	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00244	8b 94 01 54 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+340]
  0024b	81 c2 80 ee 36
	00		 add	 edx, 3600000		; 0036ee80H
  00251	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00258	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0025b	89 94 01 54 01
	00 00		 mov	 DWORD PTR [ecx+eax+340], edx
$LN15@CheckSync:

; 601  : 			}
; 602  : 
; 603  : 			m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00262	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00268	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0026f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00272	89 84 0a 58 01
	00 00		 mov	 DWORD PTR [edx+ecx+344], eax
$LN2@CheckSync:

; 604  : 		}
; 605  : 		break;
; 606  : 	}
; 607  : 	
; 608  : 	LogAddTD("[Blood Castle] (%d) Sync Open Time. [%d] min remain", iBridgeIndex+1, m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / (60 * 1000));

  00279	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00280	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00283	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  0028a	99		 cdq
  0028b	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  00290	f7 f9		 idiv	 ecx
  00292	50		 push	 eax
  00293	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00296	83 c2 01	 add	 edx, 1
  00299	52		 push	 edx
  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@JOEGJLEF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5T@
  0029f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002a5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CheckSync:

; 609  : #endif
; 610  : 
; 611  : }

  002a8	5f		 pop	 edi
  002a9	5e		 pop	 esi
  002aa	5b		 pop	 ebx
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c2 04 00	 ret	 4
?CheckSync@CBloodCastle@@IAEXH@Z ENDP			; CBloodCastle::CheckSync
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ PROC ; std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >::_Orphan_non_end, COMDAT
; _this$ = ecx

; 377  :     void _Orphan_non_end() noexcept { // orphan iterators except end()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 378  : #if _ITERATOR_DEBUG_LEVEL == 2
; 379  :         _Lockit _Lock(_LOCK_DEBUG);
; 380  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 381  :         const auto _Head          = _Myhead;
; 382  :         while (*_Pnext) {
; 383  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 384  :             if (static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr == _Head) { // iterator is end(), move on
; 385  :                 _Pnext = _Pnextnext;
; 386  :             } else { // orphan the iterator
; 387  :                 (*_Pnext)->_Myproxy = nullptr;
; 388  :                 *_Pnext             = *_Pnextnext;
; 389  :             }
; 390  :         }
; 391  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 392  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ ENDP ; std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >::_Orphan_non_end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >, COMDAT
; _this$ = ecx

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal, COMDAT
; _this$ = ecx

; 1790 :     const _Alnode& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1791 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Get_first

; 1792 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal, COMDAT
; _this$ = ecx

; 1786 :     _Alnode& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Get_first

; 1788 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Newhead$ = -20					; size = 4
__Al$ = -16						; size = 4
__Proxy$ = -10						; size = 1
_$S23$ = -9						; size = 1
__Alproxy$ = -8						; size = 4
_this$ = -4						; size = 4
?_Alloc_sentinel_and_proxy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  0000c	8d 45 f7	 lea	 eax, DWORD PTR _$S23$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1773 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	50		 push	 eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  00019	51		 push	 ecx
  0001a	8d 4d f6	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 1774 :         auto& _Al     = _Getal();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal
  0002a	89 45 f0	 mov	 DWORD PTR __Al$[ebp], eax

; 1775 :         auto _Newhead = _Al.allocate(1);

  0002d	6a 01		 push	 1
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::allocate
  00037	89 45 ec	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  0003a	8d 45 ec	 lea	 eax, DWORD PTR __Newhead$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * &>
  00047	83 c4 08	 add	 esp, 8

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0004a	8d 45 ec	 lea	 eax, DWORD PTR __Newhead$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00051	83 c1 04	 add	 ecx, 4
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<BLOODCASTLE_REWARD,void *> *,std::_List_node<BLOODCASTLE_REWARD,void *> * &>
  0005a	83 c4 08	 add	 esp, 8

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d ec	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00063	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 :         _Proxy._Release();

  00065	8d 4d f6	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 1780 :     }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?_Tidy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__My_data$ = -12					; size = 4
__Al$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1437 :         auto& _Al      = _Getal();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal
  00014	89 45 f8	 mov	 DWORD PTR __Al$[ebp], eax

; 1438 :         auto& _My_data = _Mypair._Myval2;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00025	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	8b 55 f8	 mov	 edx, DWORD PTR __Al$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Free_non_head<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
  00034	83 c4 08	 add	 esp, 8

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  00037	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	51		 push	 ecx
  0003d	8b 55 f8	 mov	 edx, DWORD PTR __Al$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Freenode0<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
  00046	83 c4 08	 add	 esp, 8

; 1442 :     }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?_Tidy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?clear@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1428 :         _My_data._Orphan_non_end();

  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Orphan_non_end@?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ ; std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >::_Orphan_non_end

; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	51		 push	 ecx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@1@PAU01@@Z ; std::_List_node<BLOODCASTLE_REWARD,void *>::_Free_non_head<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >
  0002e	83 c4 08	 add	 esp, 8

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00031	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00039	8b 02		 mov	 eax, DWORD PTR [edx]
  0003b	89 01		 mov	 DWORD PTR [ecx], eax

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1432 :         _My_data._Mysize        = 0;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1433 :     }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?clear@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?push_back@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXABUBLOODCASTLE_REWARD@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXABUBLOODCASTLE_REWARD@@@Z PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::push_back, COMDAT
; _this$ = ecx

; 1251 :     void push_back(const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	52		 push	 edx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$_Emplace@ABUBLOODCASTLE_REWARD@@@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@QAU21@ABUBLOODCASTLE_REWARD@@@Z ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Emplace<BLOODCASTLE_REWARD const &>

; 1253 :     }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?push_back@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXABUBLOODCASTLE_REWARD@@@Z ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?max_size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::max_size, COMDAT
; _this$ = ecx

; 1194 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1195 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@ABEABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1196 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1197 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::size, COMDAT
; _this$ = ecx

; 1190 :     _NODISCARD size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1191 :         return _Mypair._Myval2._Mysize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1192 :     }

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ?begin@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::begin, COMDAT
; _this$ = ecx

; 1091 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	8b 02		 mov	 eax, DWORD PTR [edx]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QAE@PAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@1@@Z
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1093 :     }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?begin@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??1?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::~list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::~list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\list
;	COMDAT ??0?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
??0?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ PROC ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T1[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1>::_Compressed_pair<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >,std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> >,1><>

; 805  :         _Alloc_sentinel_and_proxy();

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@AAEXXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::_Alloc_sentinel_and_proxy

; 806  :     }

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ENDP ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@QAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@QAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::deallocate, COMDAT

; 687  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 688  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 689  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00009	6b 45 10 14	 imul	 eax, DWORD PTR __Count$[ebp], 20
  0000d	50		 push	 eax
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00017	83 c4 08	 add	 esp, 8

; 690  :     }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@2@QAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BE@@std@@YAII@Z ; std::_Get_size_of_n<20>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEPAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEXQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEXQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	6b 45 0c 14	 imul	 eax, DWORD PTR __Count$[ebp], 20
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8

; 804  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAEXQAU?$_List_node@UBLOODCASTLE_REWARD@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$_List_node@UBLOODCASTLE_REWARD@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >::allocator<std::_List_node<BLOODCASTLE_REWARD,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ??1CBloodCastle@@UAE@XZ
_TEXT	SEGMENT
_i$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CBloodCastle@@UAE@XZ PROC				; CBloodCastle::~CBloodCastle, COMDAT
; _this$ = ecx

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CBloodCastle@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CBloodCastle@@6B@

; 124  : 	for (int i = 0 ; i < MAX_BLOODCASTLE_BRIDGE_COUNT ; i++) {

  00034	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@CBloodCast
$LN2@CBloodCast:
  0003d	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 ec	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@CBloodCast:
  00046	83 7d ec 07	 cmp	 DWORD PTR _i$2[ebp], 7
  0004a	7d 17		 jge	 SHORT $LN1@CBloodCast

; 125  : 		DeleteCriticalSection (& m_BridgeData[i].m_critUserData);

  0004c	69 45 ec 04 02
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 516
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0005a	52		 push	 edx
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 126  : 	}

  00061	eb da		 jmp	 SHORT $LN2@CBloodCast
$LN1@CBloodCast:

; 127  : }

  00063	68 00 00 00 00	 push	 OFFSET ??1?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::~list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >
  00068	6a 07		 push	 7
  0006a	6a 08		 push	 8
  0006c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	05 3c 0e 00 00	 add	 eax, 3644		; 00000e3cH
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
  0008c	cc		 int	 3
  0008d	cc		 int	 3
  0008e	cc		 int	 3
  0008f	cc		 int	 3
  00090	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CBloodCastle@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CBloodCastle@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CBloodCastle@@UAE@XZ ENDP				; CBloodCastle::~CBloodCastle
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ??0CBloodCastle@@QAE@XZ
_TEXT	SEGMENT
_i$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CBloodCastle@@QAE@XZ PROC				; CBloodCastle::CBloodCastle, COMDAT
; _this$ = ecx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CBloodCastle@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CBloodCastle@@6B@
  00034	68 00 00 00 00	 push	 OFFSET ??1?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::~list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >
  00039	68 00 00 00 00	 push	 OFFSET ??0?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >
  0003e	6a 07		 push	 7
  00040	6a 08		 push	 8
  00042	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00045	05 3c 0e 00 00	 add	 eax, 3644		; 00000e3cH
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 	m_bBC_EVENT_ENABLE = false;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	c6 80 20 0e 00
	00 00		 mov	 BYTE PTR [eax+3616], 0

; 90   : 
; 91   : 	m_iBC_TIME_MIN_OPEN = 10;		//    

  00061	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00064	c7 80 24 0e 00
	00 0a 00 00 00	 mov	 DWORD PTR [eax+3620], 10 ; 0000000aH

; 92   : 
; 93   : 	m_iBC_NORMAL_ITEM_DROP = 100;

  0006e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00071	c7 80 30 0e 00
	00 64 00 00 00	 mov	 DWORD PTR [eax+3632], 100 ; 00000064H

; 94   : 	m_iBC_EXCEL_ITEM_DROP = 1200;

  0007b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	c7 80 34 0e 00
	00 b0 04 00 00	 mov	 DWORD PTR [eax+3636], 1200 ; 000004b0H

; 95   : 	m_iBC_MONSTER_REGEN = 0;

  00088	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	c7 80 38 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3640], 0

; 96   : 
; 97   : 	for (int i = 0 ; i < MAX_BLOODCASTLE_BRIDGE_COUNT ; i++) {

  00095	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0009c	eb 09		 jmp	 SHORT $LN4@CBloodCast
$LN2@CBloodCast:
  0009e	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  000a1	83 c0 01	 add	 eax, 1
  000a4	89 45 ec	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@CBloodCast:
  000a7	83 7d ec 07	 cmp	 DWORD PTR _i$2[ebp], 7
  000ab	0f 8d cf 00 00
	00		 jge	 $LN1@CBloodCast

; 98   : 		m_BridgeData[i].m_iBC_STATE = BLOODCASTLE_STATE_NONE;

  000b1	69 45 ec 04 02
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 516
  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	c7 84 01 50 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+336], 0

; 99   : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 100  : 		m_BridgeData[i].m_iMapNumber = GetMapNumByBCBridge( i );
; 101  : #else
; 102  : 		m_BridgeData[i].m_iMapNumber = MAP_INDEX_BLOODCASTLE1 + i;

  000c6	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  000c9	83 c0 0b	 add	 eax, 11			; 0000000bH
  000cc	69 4d ec 04 02
	00 00		 imul	 ecx, DWORD PTR _i$2[ebp], 516
  000d3	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	89 84 0a 40 01
	00 00		 mov	 DWORD PTR [edx+ecx+320], eax

; 103  : #endif
; 104  : 		m_BridgeData[i].m_iBridgeIndex = i;

  000dd	69 45 ec 04 02
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 516
  000e4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	8b 55 ec	 mov	 edx, DWORD PTR _i$2[ebp]
  000ea	89 94 01 44 01
	00 00		 mov	 DWORD PTR [ecx+eax+324], edx

; 105  : 		m_BridgeData[i].m_iBC_REMAIN_MSEC = -1;

  000f1	69 45 ec 04 02
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 516
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	c7 84 01 54 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+340], -1

; 106  : 		m_BridgeData[i].m_iBC_TICK_COUNT = -1;

  00106	69 45 ec 04 02
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 516
  0010d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	c7 84 01 58 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+344], -1

; 107  : 		m_BridgeData[i].m_nSaintStatuePosNum = -1;

  0011b	69 45 ec 04 02
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 516
  00122	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	c7 84 01 34 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+308], -1

; 108  : 		m_BridgeData[i].m_nCastleDoorPosNum = -1;

  00130	69 45 ec 04 02
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 516
  00137	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	c7 84 01 38 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+312], -1

; 109  : 		m_BridgeData[i].m_iAngelKingPosNum = -1;

  00145	69 45 ec 04 02
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 516
  0014c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	c7 84 01 9c 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+412], -1

; 110  : 		
; 111  : 	#ifdef UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 112  : 		m_BridgeData[i].m_fRewardExpRate = 1.0f;
; 113  : 	#endif //UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 114  : 			
; 115  : 		InitializeCriticalSection (& m_BridgeData[i].m_critUserData);

  0015a	69 45 ec 04 02
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 516
  00161	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00164	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00168	52		 push	 edx
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 116  : 
; 117  : 		ClearBridgeData(i);

  0016f	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  00172	50		 push	 eax
  00173	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 118  : 	}

  0017b	e9 1e ff ff ff	 jmp	 $LN2@CBloodCast
$LN1@CBloodCast:

; 119  : }

  00180	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00187	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0018a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0018d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00194	59		 pop	 ecx
  00195	5f		 pop	 edi
  00196	5e		 pop	 esi
  00197	5b		 pop	 ebx
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBloodCastle@@QAE@XZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::~list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >
  00005	6a 07		 push	 7
  00007	6a 08		 push	 8
  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 3c 0e 00 00	 add	 eax, 3644		; 00000e3cH
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00017	c3		 ret	 0
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??0CBloodCastle@@QAE@XZ:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CBloodCastle@@QAE@XZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CBloodCastle@@QAE@XZ ENDP				; CBloodCastle::CBloodCastle
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv79 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iBC_STATE$ = 12					; size = 4
?SetState@CBloodCastle@@QAEXHH@Z PROC			; CBloodCastle::SetState, COMDAT
; _this$ = ecx

; 700  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN15@SetState
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN16@SetState
$LN15@SetState:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN13@SetState
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN14@SetState
$LN13@SetState:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN14@SetState:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN16@SetState:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 02		 jne	 SHORT $LN4@SetState

; 702  : 		return;

  0003d	eb 7c		 jmp	 SHORT $LN1@SetState
$LN4@SetState:

; 703  : 
; 704  : 	if ((iBC_STATE < BLOODCASTLE_STATE_NONE) || (iBC_STATE > BLOODCASTLE_STATE_PLAYEND))

  0003f	83 7d 0c 00	 cmp	 DWORD PTR _iBC_STATE$[ebp], 0
  00043	7c 06		 jl	 SHORT $LN6@SetState
  00045	83 7d 0c 03	 cmp	 DWORD PTR _iBC_STATE$[ebp], 3
  00049	7e 02		 jle	 SHORT $LN5@SetState
$LN6@SetState:

; 705  : 		return;

  0004b	eb 6e		 jmp	 SHORT $LN1@SetState
$LN5@SetState:

; 706  : 
; 707  : 	m_BridgeData[iBridgeIndex].m_iBC_STATE = iBC_STATE;

  0004d	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	8b 55 0c	 mov	 edx, DWORD PTR _iBC_STATE$[ebp]
  0005a	89 94 01 50 01
	00 00		 mov	 DWORD PTR [ecx+eax+336], edx

; 708  : 
; 709  : 	switch(m_BridgeData[iBridgeIndex].m_iBC_STATE) {

  00061	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8b 94 01 50 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+336]
  00072	89 55 b8	 mov	 DWORD PTR tv79[ebp], edx
  00075	83 7d b8 03	 cmp	 DWORD PTR tv79[ebp], 3
  00079	77 40		 ja	 SHORT $LN1@SetState
  0007b	8b 45 b8	 mov	 eax, DWORD PTR tv79[ebp]
  0007e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN17@SetState[eax*4]
$LN7@SetState:

; 710  : 	case BLOODCASTLE_STATE_NONE :
; 711  : 		SetState_None(iBridgeIndex);

  00085	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00088	50		 push	 eax
  00089	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?SetState_None@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_None

; 712  : 		break;

  00091	eb 28		 jmp	 SHORT $LN1@SetState
$LN8@SetState:

; 713  : 	case BLOODCASTLE_STATE_CLOSED :
; 714  : 		SetState_Closed(iBridgeIndex);

  00093	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00096	50		 push	 eax
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?SetState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Closed

; 715  : 		break;

  0009f	eb 1a		 jmp	 SHORT $LN1@SetState
$LN9@SetState:

; 716  : 	case BLOODCASTLE_STATE_PLAYING :
; 717  : 		SetState_Playing(iBridgeIndex);

  000a1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?SetState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Playing

; 718  : 		break;

  000ad	eb 0c		 jmp	 SHORT $LN1@SetState
$LN10@SetState:

; 719  : 	case BLOODCASTLE_STATE_PLAYEND :
; 720  : 		SetState_PlayEnd(iBridgeIndex);

  000af	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	e8 00 00 00 00	 call	 ?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_PlayEnd
$LN1@SetState:

; 721  : 		break;
; 722  : 	default:
; 723  : 		break;
; 724  : 	}
; 725  : }

  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 08 00	 ret	 8
$LN17@SetState:
  000c4	00 00 00 00	 DD	 $LN7@SetState
  000c8	00 00 00 00	 DD	 $LN8@SetState
  000cc	00 00 00 00	 DD	 $LN9@SetState
  000d0	00 00 00 00	 DD	 $LN10@SetState
?SetState@CBloodCastle@@QAEXHH@Z ENDP			; CBloodCastle::SetState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?LoadItemDropRate@CBloodCastle@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?LoadItemDropRate@CBloodCastle@@QAEXXZ PROC		; CBloodCastle::LoadItemDropRate, COMDAT
; _this$ = ecx

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 406  : 	//        .
; 407  : 	g_bBloodCastle				= GetPrivateProfileInt("GameServerInfo", "BloodCastleEvent", 0, gDirPath.GetNewPath("commonserver.cfg"));

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg@
  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00016	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0001b	50		 push	 eax
  0001c	6a 00		 push	 0
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DHAFCNAC@BloodCastleEvent@
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo@
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0002e	a3 00 00 00 00	 mov	 DWORD PTR ?g_bBloodCastle@@3HA, eax ; g_bBloodCastle

; 408  : 	g_iAngelKingsPaperDropRate	= GetPrivateProfileInt("GameServerInfo", "AngelKingsPaperDropRate", 0, gDirPath.GetNewPath("commonserver.cfg"));

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg@
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0003d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00042	50		 push	 eax
  00043	6a 00		 push	 0
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00055	a3 00 00 00 00	 mov	 DWORD PTR ?g_iAngelKingsPaperDropRate@@3HA, eax ; g_iAngelKingsPaperDropRate

; 409  : 	g_iBloodBoneDropRate		= GetPrivateProfileInt("GameServerInfo", "BloodBoneDropRate", 0, gDirPath.GetNewPath("commonserver.cfg"));

  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg@
  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00064	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00069	50		 push	 eax
  0006a	6a 00		 push	 0
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NGLLHLOE@BloodBoneDropRate@
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0007c	a3 00 00 00 00	 mov	 DWORD PTR ?g_iBloodBoneDropRate@@3HA, eax ; g_iBloodBoneDropRate

; 410  : 	g_iStoneDropRate			= GetPrivateProfileInt("GameServerInfo", "StoneDropRate", 0, gDirPath.GetNewPath("commonserver.cfg"));

  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg@
  00086	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0008b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00090	50		 push	 eax
  00091	6a 00		 push	 0
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PBCFFJJH@StoneDropRate@
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo@
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000a3	a3 00 00 00 00	 mov	 DWORD PTR ?g_iStoneDropRate@@3HA, eax ; g_iStoneDropRate

; 411  : 	g_bStoneItemDrop			= GetPrivateProfileInt("GameServerInfo", "StoneItemDrop", 0, gDirPath.GetNewPath("commonserver.cfg"));

  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IGLHFEOF@commonserver?4cfg@
  000ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000b2	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000b7	50		 push	 eax
  000b8	6a 00		 push	 0
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FHPHMJJK@StoneItemDrop@
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  000ca	a3 00 00 00 00	 mov	 DWORD PTR ?g_bStoneItemDrop@@3HA, eax ; g_bStoneItemDrop

; 412  : }

  000cf	5f		 pop	 edi
  000d0	5e		 pop	 esi
  000d1	5b		 pop	 ebx
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
?LoadItemDropRate@CBloodCastle@@QAEXXZ ENDP		; CBloodCastle::LoadItemDropRate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?Load@CBloodCastle@@QAEXPAD@Z
_TEXT	SEGMENT
tv210 = -112						; size = 4
tv150 = -112						; size = 4
tv211 = -108						; size = 4
tv200 = -108						; size = 4
tv196 = -108						; size = 4
tv151 = -108						; size = 4
_reward$1 = -40						; size = 10
_i$2 = -28						; size = 4
_iBridgeNum$ = -24					; size = 4
_BridgeCount$ = -20					; size = 4
_type$ = -16						; size = 4
_Token$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
?Load@CBloodCastle@@QAEXPAD@Z PROC			; CBloodCastle::Load, COMDAT
; _this$ = ecx

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 210  : 	// *> .     .
; 211  : 	if((SMDFile=fopen(filename,"r")) == NULL)	

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  0001b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _fopen
  00024	83 c4 08	 add	 esp, 8
  00027	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  00033	75 16		 jne	 SHORT $LN13@Load

; 212  : 	{
; 213  : 		MsgBox("[Blood Castle] Info file Load Fail [%s]", filename);

  00035	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5F@
  0003e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00043	83 c4 08	 add	 esp, 8

; 214  : 		return ;

  00046	e9 f2 04 00 00	 jmp	 $LN1@Load
$LN13@Load:

; 215  : 	}
; 216  : 	SMDToken Token;
; 217  : 	
; 218  : 	int type = -1;

  0004b	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1

; 219  : 	int BridgeCount = -1;

  00052	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _BridgeCount$[ebp], -1

; 220  : 	int iBridgeNum;
; 221  : 
; 222  : 	for(int i = 0;i < MAX_BLOODCASTLE_BRIDGE_COUNT;++i)

  00059	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00060	eb 09		 jmp	 SHORT $LN4@Load
$LN2@Load:
  00062	8b 45 e4	 mov	 eax, DWORD PTR _i$2[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 e4	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@Load:
  0006b	83 7d e4 07	 cmp	 DWORD PTR _i$2[ebp], 7
  0006f	7d 14		 jge	 SHORT $LN3@Load

; 223  : 		m_LST_BLOODCASTLE_REWARD[i].clear();

  00071	8b 45 e4	 mov	 eax, DWORD PTR _i$2[ebp]
  00074	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8d 8c c1 3c 0e
	00 00		 lea	 ecx, DWORD PTR [ecx+eax*8+3644]
  0007e	e8 00 00 00 00	 call	 ?clear@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::clear
  00083	eb dd		 jmp	 SHORT $LN2@Load
$LN3@Load:

; 224  : 	
; 225  : 	while( true )

  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	85 c0		 test	 eax, eax
  0008c	0f 84 8b 04 00
	00		 je	 $LN6@Load

; 226  : 	{
; 227  : 		Token = (*GetToken)();

  00092	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00097	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 228  : 		if(Token == END) break;

  0009a	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  0009e	75 05		 jne	 SHORT $LN14@Load
  000a0	e9 78 04 00 00	 jmp	 $LN6@Load
$LN14@Load:

; 229  : 		type = (int)TokenNumber;

  000a5	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000ad	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax
$LN7@Load:

; 230  : 		while(1)

  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	85 c0		 test	 eax, eax
  000b7	0f 84 5b 04 00
	00		 je	 $LN8@Load

; 231  : 		{				
; 232  : 			if( type == 0 )

  000bd	83 7d f0 00	 cmp	 DWORD PTR _type$[ebp], 0
  000c1	75 6b		 jne	 SHORT $LN15@Load

; 233  : 			{	//   
; 234  : 				Token = (*GetToken)();

  000c3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000c8	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 235  : 				if(strcmp("end",TokenString)==NULL) break;

  000cb	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  000d5	e8 00 00 00 00	 call	 _strcmp
  000da	83 c4 08	 add	 esp, 8
  000dd	85 c0		 test	 eax, eax
  000df	75 05		 jne	 SHORT $LN17@Load
  000e1	e9 32 04 00 00	 jmp	 $LN8@Load
$LN17@Load:

; 236  : 
; 237  : 				m_iBC_TIME_MIN_OPEN = (int)TokenNumber;

  000e6	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	89 81 24 0e 00
	00		 mov	 DWORD PTR [ecx+3620], eax

; 238  : 				Token = (*GetToken)(); m_iBC_TIME_MIN_PLAY = (int)TokenNumber;

  000f7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000fc	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  000ff	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00107	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	89 81 28 0e 00
	00		 mov	 DWORD PTR [ecx+3624], eax

; 239  : 				Token = (*GetToken)(); m_iBC_TIME_MIN_REST = (int)TokenNumber;

  00110	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00115	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00118	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00120	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	89 81 2c 0e 00
	00		 mov	 DWORD PTR [ecx+3628], eax

; 240  : 			}

  00129	e9 e5 03 00 00	 jmp	 $LN12@Load
$LN15@Load:

; 241  : 			else if( type == 1 )

  0012e	83 7d f0 01	 cmp	 DWORD PTR _type$[ebp], 1
  00132	75 6b		 jne	 SHORT $LN18@Load

; 242  : 			{	//      ,   
; 243  : 				Token = (*GetToken)();

  00134	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00139	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 244  : 				if(strcmp("end",TokenString)==NULL) break;

  0013c	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00146	e8 00 00 00 00	 call	 _strcmp
  0014b	83 c4 08	 add	 esp, 8
  0014e	85 c0		 test	 eax, eax
  00150	75 05		 jne	 SHORT $LN20@Load
  00152	e9 c1 03 00 00	 jmp	 $LN8@Load
$LN20@Load:

; 245  : 
; 246  : 				m_iBC_NORMAL_ITEM_DROP = (int)TokenNumber;			

  00157	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0015f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	89 81 30 0e 00
	00		 mov	 DWORD PTR [ecx+3632], eax

; 247  : 				Token = (*GetToken)(); m_iBC_EXCEL_ITEM_DROP	= (int)TokenNumber;

  00168	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0016d	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00170	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00178	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017b	89 81 34 0e 00
	00		 mov	 DWORD PTR [ecx+3636], eax

; 248  : 				Token = (*GetToken)(); m_iBC_MONSTER_REGEN		= (int)TokenNumber;

  00181	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00186	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00189	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00191	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	89 81 38 0e 00
	00		 mov	 DWORD PTR [ecx+3640], eax

; 249  : 			}

  0019a	e9 74 03 00 00	 jmp	 $LN12@Load
$LN18@Load:

; 250  : 			else if( type == 2 )

  0019f	83 7d f0 02	 cmp	 DWORD PTR _type$[ebp], 2
  001a3	0f 85 dd 00 00
	00		 jne	 $LN21@Load

; 251  : 			{
; 252  : 				Token = (*GetToken)();

  001a9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001ae	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 253  : 				if(strcmp("end",TokenString)==NULL) break;

  001b1	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  001b6	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  001bb	e8 00 00 00 00	 call	 _strcmp
  001c0	83 c4 08	 add	 esp, 8
  001c3	85 c0		 test	 eax, eax
  001c5	75 05		 jne	 SHORT $LN23@Load
  001c7	e9 4c 03 00 00	 jmp	 $LN8@Load
$LN23@Load:

; 254  : 
; 255  : 				iBridgeNum = (int)TokenNumber;

  001cc	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001d4	89 45 e8	 mov	 DWORD PTR _iBridgeNum$[ebp], eax

; 256  : 				
; 257  : 				if (CHECK_LIMIT(iBridgeNum, MAX_BLOODCASTLE_BRIDGE_COUNT)) {

  001d7	83 7d e8 00	 cmp	 DWORD PTR _iBridgeNum$[ebp], 0
  001db	7d 09		 jge	 SHORT $LN39@Load
  001dd	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv151[ebp], 0
  001e4	eb 1c		 jmp	 SHORT $LN40@Load
$LN39@Load:
  001e6	83 7d e8 06	 cmp	 DWORD PTR _iBridgeNum$[ebp], 6
  001ea	7e 09		 jle	 SHORT $LN37@Load
  001ec	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv150[ebp], 0
  001f3	eb 07		 jmp	 SHORT $LN38@Load
$LN37@Load:
  001f5	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv150[ebp], 1
$LN38@Load:
  001fc	8b 45 90	 mov	 eax, DWORD PTR tv150[ebp]
  001ff	89 45 94	 mov	 DWORD PTR tv151[ebp], eax
$LN40@Load:
  00202	83 7d 94 00	 cmp	 DWORD PTR tv151[ebp], 0
  00206	74 69		 je	 SHORT $LN24@Load

; 258  : 					Token = (*GetToken)(); m_BridgeData[iBridgeNum].m_iCastleStatueHealth = (float)TokenNumber;

  00208	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0020d	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00210	69 45 e8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeNum$[ebp], 516
  00217	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0021a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  00222	f3 0f 11 84 01
	6c 01 00 00	 movss	 DWORD PTR [ecx+eax+364], xmm0

; 259  : 					Token = (*GetToken)(); m_BridgeData[iBridgeNum].m_iCastleDoorHealth = (float)TokenNumber;

  0022b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00230	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00233	69 45 e8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeNum$[ebp], 516
  0023a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  00245	f3 0f 11 84 01
	70 01 00 00	 movss	 DWORD PTR [ecx+eax+368], xmm0

; 260  : 					Token = (*GetToken)(); m_BridgeData[iBridgeNum].m_iDropItemCount = TokenNumber;

  0024e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00253	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00256	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0025e	69 4d e8 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeNum$[ebp], 516
  00265	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00268	89 84 0a 04 02
	00 00		 mov	 DWORD PTR [edx+ecx+516], eax

; 261  : 				}

  0026f	eb 10		 jmp	 SHORT $LN25@Load
$LN24@Load:

; 262  : 				else {
; 263  : 					Token = (*GetToken)();

  00271	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00276	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 264  : 					Token = (*GetToken)();

  00279	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0027e	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
$LN25@Load:

; 265  : 				}
; 266  : 			}

  00281	e9 8d 02 00 00	 jmp	 $LN12@Load
$LN21@Load:

; 267  : #ifdef UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 268  : 			else if( type == 3 )
; 269  : 			{	//     
; 270  : 				Token = (*GetToken)();
; 271  : 				if( strcmp("end", TokenString) == NULL ) break;
; 272  : 
; 273  : 				iBridgeNum = (int)TokenNumber;
; 274  : 				
; 275  : 				if( CHECK_LIMIT(iBridgeNum, MAX_BLOODCASTLE_BRIDGE_COUNT) ) {
; 276  : 					Token = (*GetToken)();
; 277  : 					m_BridgeData[iBridgeNum].m_fRewardExpRate = (FLOAT)TokenNumber;
; 278  : 				}
; 279  : 				else Token = (*GetToken)();
; 280  : 			}
; 281  : #endif //UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 282  : #ifdef UPDATE_BLOODECASTLE_SCADULE_20080624
; 283  : 			else if( type == 4 )
; 284  : 			{
; 285  : 				BLOODCASTLE_STARTTIME startTime;
; 286  : 
; 287  : 				Token = (*GetToken)();
; 288  : 				if(strcmp("end",TokenString)==NULL) break;
; 289  : 
; 290  : 				startTime.nHour = (int)TokenNumber;
; 291  : 				Token = (*GetToken)(); startTime.nMin = (int)TokenNumber;			
; 292  : 
; 293  : 				m_LST_BLOODCASTLE_START_TIME.push_back(startTime);
; 294  : 
; 295  : 			}
; 296  : #endif	// UPDATE_BLOODECASTLE_SCADULE_20080624			
; 297  : 			else if( type == 5 )

  00286	83 7d f0 05	 cmp	 DWORD PTR _type$[ebp], 5
  0028a	0f 85 88 01 00
	00		 jne	 $LN26@Load

; 298  : 			{
; 299  : 				Token = (*GetToken)();

  00290	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00295	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 300  : 				if(strcmp("end",TokenString)==NULL) break;

  00298	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  002a2	e8 00 00 00 00	 call	 _strcmp
  002a7	83 c4 08	 add	 esp, 8
  002aa	85 c0		 test	 eax, eax
  002ac	75 05		 jne	 SHORT $LN28@Load
  002ae	e9 65 02 00 00	 jmp	 $LN8@Load
$LN28@Load:

; 301  : 
; 302  : 				iBridgeNum = (int)TokenNumber;

  002b3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002bb	89 45 e8	 mov	 DWORD PTR _iBridgeNum$[ebp], eax
$LN9@Load:

; 303  : 
; 304  : 				while(true)

  002be	b8 01 00 00 00	 mov	 eax, 1
  002c3	85 c0		 test	 eax, eax
  002c5	0f 84 48 01 00
	00		 je	 $LN10@Load

; 305  : 				{
; 306  : 					BLOODCASTLE_REWARD reward;
; 307  : 
; 308  : 					Token = (*GetToken)();

  002cb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002d0	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 309  : 					if(strcmp("end",TokenString)==NULL) break;

  002d3	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  002d8	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  002dd	e8 00 00 00 00	 call	 _strcmp
  002e2	83 c4 08	 add	 esp, 8
  002e5	85 c0		 test	 eax, eax
  002e7	75 05		 jne	 SHORT $LN29@Load
  002e9	e9 25 01 00 00	 jmp	 $LN10@Load
$LN29@Load:

; 310  : 
; 311  : 					reward.item_type = (unsigned short)TokenNumber;

  002ee	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002f6	66 89 45 d8	 mov	 WORD PTR _reward$1[ebp], ax

; 312  : 
; 313  : 					Token = (*GetToken)();

  002fa	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002ff	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 314  : 					reward.item_type = ItemGetNumberMake(reward.item_type, (int)TokenNumber);

  00302	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0030a	50		 push	 eax
  0030b	0f b7 4d d8	 movzx	 ecx, WORD PTR _reward$1[ebp]
  0030f	51		 push	 ecx
  00310	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00315	83 c4 08	 add	 esp, 8
  00318	66 89 45 d8	 mov	 WORD PTR _reward$1[ebp], ax

; 315  : 
; 316  : 					Token = (*GetToken)();

  0031c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00321	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 317  : 					reward.item_level = (char)TokenNumber;

  00324	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0032c	88 45 da	 mov	 BYTE PTR _reward$1[ebp+2], al

; 318  : 
; 319  : 					Token = (*GetToken)();

  0032f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00334	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 320  : 					reward.is_skill = TokenNumber > 0;

  00337	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  0033f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00346	76 09		 jbe	 SHORT $LN41@Load
  00348	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv196[ebp], 1
  0034f	eb 07		 jmp	 SHORT $LN42@Load
$LN41@Load:
  00351	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv196[ebp], 0
$LN42@Load:
  00358	8a 45 94	 mov	 al, BYTE PTR tv196[ebp]
  0035b	88 45 db	 mov	 BYTE PTR _reward$1[ebp+3], al

; 321  : 
; 322  : 					Token = (*GetToken)();

  0035e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00363	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 323  : 					reward.is_luck = TokenNumber > 0;

  00366	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  0036e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00375	76 09		 jbe	 SHORT $LN43@Load
  00377	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv200[ebp], 1
  0037e	eb 07		 jmp	 SHORT $LN44@Load
$LN43@Load:
  00380	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv200[ebp], 0
$LN44@Load:
  00387	8a 45 94	 mov	 al, BYTE PTR tv200[ebp]
  0038a	88 45 dc	 mov	 BYTE PTR _reward$1[ebp+4], al

; 324  : 
; 325  : 					Token = (*GetToken)();

  0038d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00392	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 326  : 					reward.option = (char)TokenNumber;

  00395	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0039d	88 45 dd	 mov	 BYTE PTR _reward$1[ebp+5], al

; 327  : 
; 328  : 					Token = (*GetToken)();

  003a0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003a5	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 329  : 					reward.exc_option = (char)TokenNumber;

  003a8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003b0	88 45 de	 mov	 BYTE PTR _reward$1[ebp+6], al

; 330  : 
; 331  : 					Token = (*GetToken)();

  003b3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003b8	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 332  : 					reward.max_drop_rate = (unsigned short)TokenNumber;

  003bb	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003c3	66 89 45 e0	 mov	 WORD PTR _reward$1[ebp+8], ax

; 333  : 
; 334  : 					if (CHECK_LIMIT(iBridgeNum, MAX_BLOODCASTLE_BRIDGE_COUNT))

  003c7	83 7d e8 00	 cmp	 DWORD PTR _iBridgeNum$[ebp], 0
  003cb	7d 09		 jge	 SHORT $LN47@Load
  003cd	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv211[ebp], 0
  003d4	eb 1c		 jmp	 SHORT $LN48@Load
$LN47@Load:
  003d6	83 7d e8 06	 cmp	 DWORD PTR _iBridgeNum$[ebp], 6
  003da	7e 09		 jle	 SHORT $LN45@Load
  003dc	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv210[ebp], 0
  003e3	eb 07		 jmp	 SHORT $LN46@Load
$LN45@Load:
  003e5	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv210[ebp], 1
$LN46@Load:
  003ec	8b 45 90	 mov	 eax, DWORD PTR tv210[ebp]
  003ef	89 45 94	 mov	 DWORD PTR tv211[ebp], eax
$LN48@Load:
  003f2	83 7d 94 00	 cmp	 DWORD PTR tv211[ebp], 0
  003f6	74 16		 je	 SHORT $LN30@Load

; 335  : 						m_LST_BLOODCASTLE_REWARD[iBridgeNum].push_back(reward);

  003f8	8d 45 d8	 lea	 eax, DWORD PTR _reward$1[ebp]
  003fb	50		 push	 eax
  003fc	8b 4d e8	 mov	 ecx, DWORD PTR _iBridgeNum$[ebp]
  003ff	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00402	8d 8c ca 3c 0e
	00 00		 lea	 ecx, DWORD PTR [edx+ecx*8+3644]
  00409	e8 00 00 00 00	 call	 ?push_back@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAEXABUBLOODCASTLE_REWARD@@@Z ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::push_back
$LN30@Load:

; 336  : 				};

  0040e	e9 ab fe ff ff	 jmp	 $LN9@Load
$LN10@Load:

; 337  : 			}

  00413	e9 fb 00 00 00	 jmp	 $LN12@Load
$LN26@Load:

; 338  : 			else if( type == 6 )

  00418	83 7d f0 06	 cmp	 DWORD PTR _type$[ebp], 6
  0041c	0f 85 f1 00 00
	00		 jne	 $LN12@Load

; 339  : 			{
; 340  : 				Token = (*GetToken)();

  00422	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00427	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 341  : 				if(strcmp("end",TokenString)==NULL) break;

  0042a	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  0042f	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00434	e8 00 00 00 00	 call	 _strcmp
  00439	83 c4 08	 add	 esp, 8
  0043c	85 c0		 test	 eax, eax
  0043e	75 05		 jne	 SHORT $LN32@Load
  00440	e9 d3 00 00 00	 jmp	 $LN8@Load
$LN32@Load:

; 342  : 
; 343  : 				iBridgeNum = (int)TokenNumber;

  00445	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0044d	89 45 e8	 mov	 DWORD PTR _iBridgeNum$[ebp], eax
$LN11@Load:

; 344  : 
; 345  : 				while(true)

  00450	b8 01 00 00 00	 mov	 eax, 1
  00455	85 c0		 test	 eax, eax
  00457	0f 84 b6 00 00
	00		 je	 $LN12@Load

; 346  : 				{
; 347  : 					Token = (*GetToken)();

  0045d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00462	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 348  : 					if(strcmp("end",TokenString)==NULL) break;

  00465	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  0046a	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  0046f	e8 00 00 00 00	 call	 _strcmp
  00474	83 c4 08	 add	 esp, 8
  00477	85 c0		 test	 eax, eax
  00479	75 05		 jne	 SHORT $LN33@Load
  0047b	e9 93 00 00 00	 jmp	 $LN12@Load
$LN33@Load:

; 349  : 
; 350  : 					if(iBridgeNum >= 0 && iBridgeNum < MAX_BLOODCASTLE_BRIDGE_COUNT)

  00480	83 7d e8 00	 cmp	 DWORD PTR _iBridgeNum$[ebp], 0
  00484	7c 70		 jl	 SHORT $LN34@Load
  00486	83 7d e8 07	 cmp	 DWORD PTR _iBridgeNum$[ebp], 7
  0048a	7d 6a		 jge	 SHORT $LN34@Load

; 351  : 					{
; 352  : 						g_sttBLOODCASTLE_LEVEL[iBridgeNum].iLOWER_BOUND = TokenNumber;

  0048c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00494	8b 4d e8	 mov	 ecx, DWORD PTR _iBridgeNum$[ebp]
  00497	c1 e1 04	 shl	 ecx, 4
  0049a	89 81 00 00 00
	00		 mov	 DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[ecx], eax

; 353  : 
; 354  : 						Token = (*GetToken)();

  004a0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004a5	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 355  : 						g_sttBLOODCASTLE_LEVEL[iBridgeNum].iUPPER_BOUND = TokenNumber;

  004a8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004b0	8b 4d e8	 mov	 ecx, DWORD PTR _iBridgeNum$[ebp]
  004b3	c1 e1 04	 shl	 ecx, 4
  004b6	89 81 04 00 00
	00		 mov	 DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[ecx+4], eax

; 356  : 
; 357  : 						Token = (*GetToken)();

  004bc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004c1	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 358  : 						g_sttBLOODCASTLE_LEVEL[iBridgeNum].iLOWER_BOUND_MAGUMSA = TokenNumber;

  004c4	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004cc	8b 4d e8	 mov	 ecx, DWORD PTR _iBridgeNum$[ebp]
  004cf	c1 e1 04	 shl	 ecx, 4
  004d2	89 81 08 00 00
	00		 mov	 DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[ecx+8], eax

; 359  : 
; 360  : 						Token = (*GetToken)();

  004d8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004dd	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 361  : 						g_sttBLOODCASTLE_LEVEL[iBridgeNum].iUPPER_BOUND_MAGUMSA = TokenNumber;

  004e0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004e8	8b 4d e8	 mov	 ecx, DWORD PTR _iBridgeNum$[ebp]
  004eb	c1 e1 04	 shl	 ecx, 4
  004ee	89 81 0c 00 00
	00		 mov	 DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[ecx+12], eax

; 362  : 					}

  004f4	eb 18		 jmp	 SHORT $LN35@Load
$LN34@Load:

; 363  : 					else
; 364  : 					{
; 365  : 						Token = (*GetToken)();

  004f6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004fb	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 366  : 						Token = (*GetToken)();

  004fe	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00503	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 367  : 						Token = (*GetToken)();

  00506	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0050b	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
$LN35@Load:

; 368  : 					}
; 369  : 				};

  0050e	e9 3d ff ff ff	 jmp	 $LN11@Load
$LN12@Load:

; 370  : 			}
; 371  : 		}

  00513	e9 98 fb ff ff	 jmp	 $LN7@Load
$LN8@Load:

; 372  : 	}

  00518	e9 68 fb ff ff	 jmp	 $LN3@Load
$LN6@Load:

; 373  : 
; 374  : 	fclose(SMDFile);

  0051d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00522	50		 push	 eax
  00523	e8 00 00 00 00	 call	 _fclose
  00528	83 c4 04	 add	 esp, 4

; 375  : 
; 376  : 	LogAdd("%s file load!", filename);

  0052b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0052e	50		 push	 eax
  0052f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@
  00534	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0053a	83 c4 08	 add	 esp, 8
$LN1@Load:

; 377  : 
; 378  : // grooving      
; 379  : #if TESTSERVER == 1 && defined(UPDATE_BLOODECASTLE_SCADULE_20080624)
; 380  : 
; 381  : 	m_iBC_TIME_MIN_OPEN = 1;
; 382  : 	m_iBC_TIME_MIN_PLAY = 5;
; 383  : 	
; 384  : 	BLOODCASTLE_STARTTIME startTime;
; 385  : 
; 386  : 	m_LST_BLOODCASTLE_START_TIME.clear();
; 387  : 
; 388  : 	for( int i = 0; i < 24; i++)
; 389  : 	{
; 390  : 		startTime.nHour = i;
; 391  : 		
; 392  : 		for( int j = 0; j < 60; j+= 6 )
; 393  : 		{
; 394  : 			startTime.nMin = j;
; 395  : 			
; 396  : 			m_LST_BLOODCASTLE_START_TIME.push_back(startTime);
; 397  : 		}
; 398  : 	}			
; 399  : #endif//TESTSERVER
; 400  : 
; 401  : }

  0053d	5f		 pop	 edi
  0053e	5e		 pop	 esi
  0053f	5b		 pop	 ebx
  00540	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00543	33 cd		 xor	 ecx, ebp
  00545	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0054a	8b e5		 mov	 esp, ebp
  0054c	5d		 pop	 ebp
  0054d	c2 04 00	 ret	 4
?Load@CBloodCastle@@QAEXPAD@Z ENDP			; CBloodCastle::Load
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?Init@CBloodCastle@@QAEX_N@Z
_TEXT	SEGMENT
tv152 = -100						; size = 4
tv91 = -100						; size = 4
tv153 = -96						; size = 4
tv92 = -96						; size = 4
_i$1 = -28						; size = 4
_i$2 = -24						; size = 4
_btBloodCastleIndex$3 = -19				; size = 1
_btMapNumber$4 = -18					; size = 1
_btMonsterType$5 = -17					; size = 1
_n$6 = -16						; size = 4
_j$7 = -12						; size = 4
_i$8 = -8						; size = 4
_this$ = -4						; size = 4
_bEVENT_ENABLE$ = 8					; size = 1
?Init@CBloodCastle@@QAEX_N@Z PROC			; CBloodCastle::Init, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 	m_bBC_EVENT_ENABLE = bEVENT_ENABLE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 4d 08	 mov	 cl, BYTE PTR _bEVENT_ENABLE$[ebp]
  00012	88 88 20 0e 00
	00		 mov	 BYTE PTR [eax+3616], cl

; 133  : 
; 134  : 	// 1 .      .
; 135  : 	for (int i = 0 ; i < MAX_BLOODCASTLE_BRIDGE_COUNT ; i++) {

  00018	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  0001f	eb 09		 jmp	 SHORT $LN4@Init
$LN2@Init:
  00021	8b 45 f8	 mov	 eax, DWORD PTR _i$8[ebp]
  00024	83 c0 01	 add	 eax, 1
  00027	89 45 f8	 mov	 DWORD PTR _i$8[ebp], eax
$LN4@Init:
  0002a	83 7d f8 07	 cmp	 DWORD PTR _i$8[ebp], 7
  0002e	7d 4d		 jge	 SHORT $LN3@Init

; 136  : 		for (int j = 0 ; j < MAX_BLOODCASTLE_BOSS_COUNT ; j++) {

  00030	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$7[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN7@Init
$LN5@Init:
  00039	8b 45 f4	 mov	 eax, DWORD PTR _j$7[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f4	 mov	 DWORD PTR _j$7[ebp], eax
$LN7@Init:
  00042	83 7d f4 14	 cmp	 DWORD PTR _j$7[ebp], 20	; 00000014H
  00046	7d 33		 jge	 SHORT $LN6@Init

; 137  : 			m_BridgeData[i].m_iAngelKingPosNum = -1;

  00048	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _i$8[ebp], 516
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	c7 84 01 9c 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+412], -1

; 138  : 			m_BridgeData[i].m_nBossMonsterPosNum[j] = -1;

  0005d	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _i$8[ebp], 516
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0006b	8b 45 f4	 mov	 eax, DWORD PTR _j$7[ebp]
  0006e	c7 84 82 e0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax*4+224], -1

; 139  : 		}

  00079	eb be		 jmp	 SHORT $LN5@Init
$LN6@Init:

; 140  : 	}

  0007b	eb a4		 jmp	 SHORT $LN2@Init
$LN3@Init:

; 141  : 
; 142  : 	// 2 . MonsterSetBase.txt  , ,    .
; 143  : 	for( int n=0; n<gMSetBase.m_Count; n++)

  0007d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$6[ebp], 0
  00084	eb 09		 jmp	 SHORT $LN10@Init
$LN8@Init:
  00086	8b 45 f0	 mov	 eax, DWORD PTR _n$6[ebp]
  00089	83 c0 01	 add	 eax, 1
  0008c	89 45 f0	 mov	 DWORD PTR _n$6[ebp], eax
$LN10@Init:
  0008f	8b 45 f0	 mov	 eax, DWORD PTR _n$6[ebp]
  00092	3b 05 e4 0f 01
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+69604
  00098	0f 8d c0 01 00
	00		 jge	 $LN9@Init

; 144  : 	{
; 145  : 		if( CHECK_BLOODCASTLE(gMSetBase.m_Mp[n].m_MapNumber) )		//    

  0009e	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$6[ebp], 12
  000a2	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  000a9	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  000ac	7d 09		 jge	 SHORT $LN27@Init
  000ae	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
  000b5	eb 26		 jmp	 SHORT $LN28@Init
$LN27@Init:
  000b7	6b 55 f0 0c	 imul	 edx, DWORD PTR _n$6[ebp], 12
  000bb	0f b6 82 08 00
	00 00		 movzx	 eax, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edx+8]
  000c2	83 f8 11	 cmp	 eax, 17			; 00000011H
  000c5	7e 09		 jle	 SHORT $LN25@Init
  000c7	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  000ce	eb 07		 jmp	 SHORT $LN26@Init
$LN25@Init:
  000d0	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
$LN26@Init:
  000d7	8b 4d 9c	 mov	 ecx, DWORD PTR tv91[ebp]
  000da	89 4d a0	 mov	 DWORD PTR tv92[ebp], ecx
$LN28@Init:
  000dd	83 7d a0 00	 cmp	 DWORD PTR tv92[ebp], 0
  000e1	0f 84 72 01 00
	00		 je	 $LN17@Init

; 146  : 		{
; 147  : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//   			
; 148  : 			WORD btMonsterType = gMSetBase.m_Mp[n].m_Type;
; 149  : #else
; 150  : 			BYTE btMonsterType = gMSetBase.m_Mp[n].m_Type;

  000e7	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$6[ebp], 12
  000eb	8a 88 06 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  000f1	88 4d ef	 mov	 BYTE PTR _btMonsterType$5[ebp], cl

; 151  : #endif
; 152  : 			BYTE btMapNumber = gMSetBase.m_Mp[n].m_MapNumber;

  000f4	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$6[ebp], 12
  000f8	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  000fe	88 4d ee	 mov	 BYTE PTR _btMapNumber$4[ebp], cl

; 153  : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//   
; 154  : 			BYTE btBloodCastleIndex = GetBridgeIndexByMapNum( btMapNumber );
; 155  : #else
; 156  : 			BYTE btBloodCastleIndex = btMapNumber - MAP_INDEX_BLOODCASTLE1;

  00101	0f b6 45 ee	 movzx	 eax, BYTE PTR _btMapNumber$4[ebp]
  00105	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00108	88 45 ed	 mov	 BYTE PTR _btBloodCastleIndex$3[ebp], al

; 157  : #endif
; 158  : 
; 159  : 			if (btMonsterType == NPC_ANGELKING) {					//       . ->    .

  0010b	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  0010f	3d e8 00 00 00	 cmp	 eax, 232		; 000000e8H
  00114	75 26		 jne	 SHORT $LN18@Init

; 160  : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//   
; 161  : 				m_BridgeData[btBloodCastleIndex].m_iAngelKingPosNum = n;
; 162  : #else
; 163  : 				m_BridgeData[gMSetBase.m_Mp[n].m_MapNumber - MAP_INDEX_BLOODCASTLE1].m_iAngelKingPosNum = n;

  00116	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$6[ebp], 12
  0011a	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  00121	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00124	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0012a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	8b 4d f0	 mov	 ecx, DWORD PTR _n$6[ebp]
  00130	89 8c 10 9c 01
	00 00		 mov	 DWORD PTR [eax+edx+412], ecx

; 164  : #endif
; 165  : 				continue;

  00137	e9 4a ff ff ff	 jmp	 $LN8@Init
$LN18@Init:

; 166  : 			}
; 167  : 
; 168  : 			if (CHECK_LIMIT(btMonsterType-BC_SAINT_STATUE_1, 3)) {	//     .

  0013c	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  00140	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  00145	79 09		 jns	 SHORT $LN31@Init
  00147	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv153[ebp], 0
  0014e	eb 25		 jmp	 SHORT $LN32@Init
$LN31@Init:
  00150	0f b6 4d ef	 movzx	 ecx, BYTE PTR _btMonsterType$5[ebp]
  00154	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  0015a	83 f9 02	 cmp	 ecx, 2
  0015d	7e 09		 jle	 SHORT $LN29@Init
  0015f	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv152[ebp], 0
  00166	eb 07		 jmp	 SHORT $LN30@Init
$LN29@Init:
  00168	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv152[ebp], 1
$LN30@Init:
  0016f	8b 55 9c	 mov	 edx, DWORD PTR tv152[ebp]
  00172	89 55 a0	 mov	 DWORD PTR tv153[ebp], edx
$LN32@Init:
  00175	83 7d a0 00	 cmp	 DWORD PTR tv153[ebp], 0
  00179	74 1c		 je	 SHORT $LN19@Init

; 169  : 				m_BridgeData[btBloodCastleIndex].m_nSaintStatuePosNum = n;

  0017b	0f b6 45 ed	 movzx	 eax, BYTE PTR _btBloodCastleIndex$3[ebp]
  0017f	69 c8 04 02 00
	00		 imul	 ecx, eax, 516
  00185	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00188	8b 45 f0	 mov	 eax, DWORD PTR _n$6[ebp]
  0018b	89 84 0a 34 01
	00 00		 mov	 DWORD PTR [edx+ecx+308], eax

; 170  : 				continue;

  00192	e9 ef fe ff ff	 jmp	 $LN8@Init
$LN19@Init:

; 171  : 			}
; 172  : 
; 173  : 			if (btMonsterType == 131) {								//    .

  00197	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  0019b	3d 83 00 00 00	 cmp	 eax, 131		; 00000083H
  001a0	75 1c		 jne	 SHORT $LN20@Init

; 174  : 				m_BridgeData[btBloodCastleIndex].m_nCastleDoorPosNum = n;

  001a2	0f b6 45 ed	 movzx	 eax, BYTE PTR _btBloodCastleIndex$3[ebp]
  001a6	69 c8 04 02 00
	00		 imul	 ecx, eax, 516
  001ac	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001af	8b 45 f0	 mov	 eax, DWORD PTR _n$6[ebp]
  001b2	89 84 0a 38 01
	00 00		 mov	 DWORD PTR [edx+ecx+312], eax

; 175  : 				continue;

  001b9	e9 c8 fe ff ff	 jmp	 $LN8@Init
$LN20@Init:

; 176  : 			}
; 177  : 
; 178  : 			//      .
; 179  : 			if ((btMonsterType == 89) ||							// 1
; 180  : 				(btMonsterType == 95) ||							// 2
; 181  : 				(btMonsterType == 112) ||							// 3
; 182  : 				(btMonsterType == 118) ||							// 4
; 183  : 				(btMonsterType == 124) ||							// 5
; 184  : 				(btMonsterType == 130)								// 6
; 185  : #ifdef BLOODCASTLE_EXTEND_20040314
; 186  : 				|| (btMonsterType == 143)							// 7

  001be	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  001c2	83 f8 59	 cmp	 eax, 89			; 00000059H
  001c5	74 3a		 je	 SHORT $LN22@Init
  001c7	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  001cb	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  001ce	74 31		 je	 SHORT $LN22@Init
  001d0	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  001d4	83 f8 70	 cmp	 eax, 112		; 00000070H
  001d7	74 28		 je	 SHORT $LN22@Init
  001d9	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  001dd	83 f8 76	 cmp	 eax, 118		; 00000076H
  001e0	74 1f		 je	 SHORT $LN22@Init
  001e2	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  001e6	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  001e9	74 16		 je	 SHORT $LN22@Init
  001eb	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  001ef	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  001f4	74 0b		 je	 SHORT $LN22@Init
  001f6	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$5[ebp]
  001fa	3d 8f 00 00 00	 cmp	 eax, 143		; 0000008fH
  001ff	75 58		 jne	 SHORT $LN17@Init
$LN22@Init:

; 187  : #endif		
; 188  : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		//    
; 189  : 				|| (btMonsterType == 433)							// 8
; 190  : #endif				
; 191  : 				)
; 192  : 			{
; 193  : 				for (int i = 0 ; i < MAX_BLOODCASTLE_BOSS_COUNT ; i++) {

  00201	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00208	eb 09		 jmp	 SHORT $LN13@Init
$LN11@Init:
  0020a	8b 45 e8	 mov	 eax, DWORD PTR _i$2[ebp]
  0020d	83 c0 01	 add	 eax, 1
  00210	89 45 e8	 mov	 DWORD PTR _i$2[ebp], eax
$LN13@Init:
  00213	83 7d e8 14	 cmp	 DWORD PTR _i$2[ebp], 20	; 00000014H
  00217	7d 40		 jge	 SHORT $LN17@Init

; 194  : 					if (m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[i] == -1) {

  00219	0f b6 45 ed	 movzx	 eax, BYTE PTR _btBloodCastleIndex$3[ebp]
  0021d	69 c8 04 02 00
	00		 imul	 ecx, eax, 516
  00223	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00226	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0022a	8b 4d e8	 mov	 ecx, DWORD PTR _i$2[ebp]
  0022d	83 bc 88 e0 00
	00 00 ff	 cmp	 DWORD PTR [eax+ecx*4+224], -1
  00235	75 20		 jne	 SHORT $LN23@Init

; 195  : 						m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[i] = n;

  00237	0f b6 45 ed	 movzx	 eax, BYTE PTR _btBloodCastleIndex$3[ebp]
  0023b	69 c8 04 02 00
	00		 imul	 ecx, eax, 516
  00241	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00244	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00248	8b 4d e8	 mov	 ecx, DWORD PTR _i$2[ebp]
  0024b	8b 55 f0	 mov	 edx, DWORD PTR _n$6[ebp]
  0024e	89 94 88 e0 00
	00 00		 mov	 DWORD PTR [eax+ecx*4+224], edx

; 196  : 						break;

  00255	eb 02		 jmp	 SHORT $LN17@Init
$LN23@Init:

; 197  : 					}
; 198  : 				}				

  00257	eb b1		 jmp	 SHORT $LN11@Init
$LN17@Init:

; 199  : 			}
; 200  : 		}
; 201  : 	}

  00259	e9 28 fe ff ff	 jmp	 $LN8@Init
$LN9@Init:

; 202  : 
; 203  : 	for ( int i = 0 ; i < MAX_BLOODCASTLE_BRIDGE_COUNT ; i++)

  0025e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00265	eb 09		 jmp	 SHORT $LN16@Init
$LN14@Init:
  00267	8b 45 e4	 mov	 eax, DWORD PTR _i$1[ebp]
  0026a	83 c0 01	 add	 eax, 1
  0026d	89 45 e4	 mov	 DWORD PTR _i$1[ebp], eax
$LN16@Init:
  00270	83 7d e4 07	 cmp	 DWORD PTR _i$1[ebp], 7
  00274	7d 10		 jge	 SHORT $LN1@Init

; 204  : 		SetState(i, BLOODCASTLE_STATE_CLOSED);

  00276	6a 01		 push	 1
  00278	8b 45 e4	 mov	 eax, DWORD PTR _i$1[ebp]
  0027b	50		 push	 eax
  0027c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0027f	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
  00284	eb e1		 jmp	 SHORT $LN14@Init
$LN1@Init:

; 205  : }

  00286	5f		 pop	 edi
  00287	5e		 pop	 esi
  00288	5b		 pop	 ebx
  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c2 04 00	 ret	 4
?Init@CBloodCastle@@QAEX_N@Z ENDP			; CBloodCastle::Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?Run@CBloodCastle@@QAEXXZ
_TEXT	SEGMENT
tv73 = -76						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?Run@CBloodCastle@@QAEXXZ PROC				; CBloodCastle::Run, COMDAT
; _this$ = ecx

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 730  : 	if (m_bBC_EVENT_ENABLE) {

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 88 20 0e
	00 00		 movzx	 ecx, BYTE PTR [eax+3616]
  00016	85 c9		 test	 ecx, ecx
  00018	74 74		 je	 SHORT $LN1@Run

; 731  : 	
; 732  : 		for (INT i = 0 ; i < MAX_BLOODCASTLE_BRIDGE_COUNT ; i++) {

  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00021	eb 09		 jmp	 SHORT $LN4@Run
$LN2@Run:
  00023	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00026	83 c0 01	 add	 eax, 1
  00029	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Run:
  0002c	83 7d f8 07	 cmp	 DWORD PTR _i$1[ebp], 7
  00030	7d 5c		 jge	 SHORT $LN1@Run

; 733  : 			switch (m_BridgeData[i].m_iBC_STATE) {

  00032	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 516
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	8b 94 01 50 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+336]
  00043	89 55 b4	 mov	 DWORD PTR tv73[ebp], edx
  00046	83 7d b4 03	 cmp	 DWORD PTR tv73[ebp], 3
  0004a	77 40		 ja	 SHORT $LN5@Run
  0004c	8b 45 b4	 mov	 eax, DWORD PTR tv73[ebp]
  0004f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@Run[eax*4]
$LN8@Run:

; 734  : 			case BLOODCASTLE_STATE_NONE :
; 735  : 				ProcState_None(i);

  00056	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00059	50		 push	 eax
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?ProcState_None@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_None

; 736  : 				break;

  00062	eb 28		 jmp	 SHORT $LN5@Run
$LN9@Run:

; 737  : 			case BLOODCASTLE_STATE_CLOSED :
; 738  : 				ProcState_Closed(i);

  00064	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00067	50		 push	 eax
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?ProcState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Closed

; 739  : 				break;

  00070	eb 1a		 jmp	 SHORT $LN5@Run
$LN10@Run:

; 740  : 			case BLOODCASTLE_STATE_PLAYING :
; 741  : 				ProcState_Playing(i);

  00072	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00075	50		 push	 eax
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ?ProcState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Playing

; 742  : 				break;

  0007e	eb 0c		 jmp	 SHORT $LN5@Run
$LN11@Run:

; 743  : 			case BLOODCASTLE_STATE_PLAYEND :
; 744  : 				ProcState_PlayEnd(i);

  00080	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00083	50		 push	 eax
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_PlayEnd
$LN5@Run:

; 745  : 				break;
; 746  : 			default:
; 747  : 				break;
; 748  : 			}
; 749  : 		}

  0008c	eb 95		 jmp	 SHORT $LN2@Run
$LN1@Run:

; 750  : 
; 751  : #ifdef AUTH_GAMESERVER_CHECKKEY
; 752  : 	if( szAuthKey[13] != AUTH_CHECK_13 )
; 753  : 		DestroyGIocp();
; 754  : #endif
; 755  : 	}
; 756  : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
  00095	0f 1f 00	 npad	 3
$LN14@Run:
  00098	00 00 00 00	 DD	 $LN8@Run
  0009c	00 00 00 00	 DD	 $LN9@Run
  000a0	00 00 00 00	 DD	 $LN10@Run
  000a4	00 00 00 00	 DD	 $LN11@Run
?Run@CBloodCastle@@QAEXXZ ENDP				; CBloodCastle::Run
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv186 = -84						; size = 4
tv66 = -84						; size = 4
tv187 = -80						; size = 4
tv179 = -80						; size = 4
tv67 = -80						; size = 4
_lpObj$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateFail, COMDAT
; _this$ = ecx

; 5229 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 5230 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN23@FixUsersPl
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN24@FixUsersPl
$LN23@FixUsersPl:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN21@FixUsersPl
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN22@FixUsersPl
$LN21@FixUsersPl:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN22@FixUsersPl:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN24@FixUsersPl:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN7@FixUsersPl

; 5231 : 		return;

  0003d	e9 3f 02 00 00	 jmp	 $LN1@FixUsersPl
$LN7@FixUsersPl:

; 5232 : 
; 5233 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN4@FixUsersPl
$LN2@FixUsersPl:
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@FixUsersPl:
  00054	83 7d f8 0a	 cmp	 DWORD PTR _i$2[ebp], 10	; 0000000aH
  00058	0f 8d 23 02 00
	00		 jge	 $LN3@FixUsersPl

; 5234 : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1) {

  0005e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0006c	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00070	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  00075	75 02		 jne	 SHORT $LN8@FixUsersPl

; 5235 : 			//   
; 5236 : 			continue;

  00077	eb d2		 jmp	 SHORT $LN2@FixUsersPl
$LN8@FixUsersPl:

; 5237 : 		}
; 5238 : 
; 5239 : 		if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < 3) {

  00079	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00087	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0008b	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00093	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00099	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  0009e	7d 02		 jge	 SHORT $LN9@FixUsersPl

; 5240 : 			//    
; 5241 : 			continue;

  000a0	eb a9		 jmp	 SHORT $LN2@FixUsersPl
$LN9@FixUsersPl:

; 5242 : 		}
; 5243 : 
; 5244 : 		if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1) || 
; 5245 : 			(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1) ||

  000a2	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000b0	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  000b4	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c2	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  000ca	83 f8 ff	 cmp	 eax, -1
  000cd	74 5a		 je	 SHORT $LN11@FixUsersPl
  000cf	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000dd	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  000e1	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ef	0f be 84 0a d3
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3283]
  000f7	83 f8 ff	 cmp	 eax, -1
  000fa	74 2d		 je	 SHORT $LN11@FixUsersPl
  000fc	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00103	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0010a	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0010e	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00116	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011c	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  00124	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00127	74 05		 je	 SHORT $LN10@FixUsersPl
$LN11@FixUsersPl:

; 5246 : 			(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex)
; 5247 : 			) 
; 5248 : 		{
; 5249 : 			//    
; 5250 : 			continue;

  00129	e9 1d ff ff ff	 jmp	 $LN2@FixUsersPl
$LN10@FixUsersPl:

; 5251 : 		}
; 5252 : 		
; 5253 : 		LPOBJECTSTRUCT lpObj = &gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];

  0012e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00135	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0013c	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00140	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00148	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014e	89 4d f4	 mov	 DWORD PTR _lpObj$1[ebp], ecx

; 5254 : 		
; 5255 : 		switch (m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState) {

  00151	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00158	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0015f	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00163	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  00167	89 4d b0	 mov	 DWORD PTR tv179[ebp], ecx
  0016a	83 7d b0 03	 cmp	 DWORD PTR tv179[ebp], 3
  0016e	74 1e		 je	 SHORT $LN15@FixUsersPl
  00170	83 7d b0 04	 cmp	 DWORD PTR tv179[ebp], 4
  00174	0f 84 ae 00 00
	00		 je	 $LN19@FixUsersPl
  0017a	e9 c3 00 00 00	 jmp	 $LN5@FixUsersPl

; 5256 : 		case BC_USER_ALIVE :				// 	
; 5257 : 			{
; 5258 : 				//  
; 5259 : 			}
; 5260 : 			break;

  0017f	e9 be 00 00 00	 jmp	 $LN5@FixUsersPl

; 5261 : 		case BC_USER_DEAD :					// 
; 5262 : 			{
; 5263 : 				//  
; 5264 : 			}
; 5265 : 			break;

  00184	e9 b9 00 00 00	 jmp	 $LN5@FixUsersPl

; 5266 : 		case BC_USER_WINNER :				// 
; 5267 : 			{
; 5268 : 				//  
; 5269 : 			}
; 5270 : 			break;

  00189	e9 b4 00 00 00	 jmp	 $LN5@FixUsersPl
$LN15@FixUsersPl:

; 5271 : 		case BC_USER_WINNER_PARTY_ALIVE :	//  ( )
; 5272 : 			{
; 5273 : 				//    
; 5274 : 				if (!CHECK_BLOODCASTLE(lpObj->MapNumber) ||
; 5275 : 					lpObj->Live == 0 ||

  0018e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00191	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00198	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0019b	7d 09		 jge	 SHORT $LN27@FixUsersPl
  0019d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv187[ebp], 0
  001a4	eb 25		 jmp	 SHORT $LN28@FixUsersPl
$LN27@FixUsersPl:
  001a6	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$1[ebp]
  001a9	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  001b0	83 f8 11	 cmp	 eax, 17			; 00000011H
  001b3	7e 09		 jle	 SHORT $LN25@FixUsersPl
  001b5	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv186[ebp], 0
  001bc	eb 07		 jmp	 SHORT $LN26@FixUsersPl
$LN25@FixUsersPl:
  001be	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv186[ebp], 1
$LN26@FixUsersPl:
  001c5	8b 4d ac	 mov	 ecx, DWORD PTR tv186[ebp]
  001c8	89 4d b0	 mov	 DWORD PTR tv187[ebp], ecx
$LN28@FixUsersPl:
  001cb	83 7d b0 00	 cmp	 DWORD PTR tv187[ebp], 0
  001cf	74 1f		 je	 SHORT $LN18@FixUsersPl
  001d1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  001d4	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  001d8	85 c9		 test	 ecx, ecx
  001da	74 14		 je	 SHORT $LN18@FixUsersPl
  001dc	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  001df	f3 0f 5a 80 bc
	00 00 00	 cvtss2sd xmm0, DWORD PTR [eax+188]
  001e7	0f 57 c9	 xorps	 xmm1, xmm1
  001ea	66 0f 2f c8	 comisd	 xmm1, xmm0
  001ee	72 1c		 jb	 SHORT $LN16@FixUsersPl
$LN18@FixUsersPl:

; 5276 : 					lpObj->Life <= 0.0
; 5277 : 					)
; 5278 : 				{
; 5279 : 					m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_DEAD;

  001f0	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001fa	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  001fe	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00202	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1

; 5280 : 				}

  0020a	eb 1a		 jmp	 SHORT $LN17@FixUsersPl
$LN16@FixUsersPl:

; 5281 : 				else {
; 5282 : 					m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_ALIVE;

  0020c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00213	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00216	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0021a	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0021e	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0
$LN17@FixUsersPl:

; 5283 : 				}
; 5284 : 			}
; 5285 : 			break;

  00226	eb 1a		 jmp	 SHORT $LN5@FixUsersPl
$LN19@FixUsersPl:

; 5286 : 		case BC_USER_WINNER_PARTY_DEAD :	//  ( )
; 5287 : 			{
; 5288 : 				// 
; 5289 : 				m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_DEAD;

  00228	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0022f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00232	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00236	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0023a	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1
$LN5@FixUsersPl:

; 5290 : 			}
; 5291 : 			break;
; 5292 : 		}
; 5293 : 
; 5294 : 		LogAddTD ("[Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State : %d", 

  00242	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00249	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00250	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00254	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  00258	51		 push	 ecx
  00259	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$1[ebp]
  0025c	83 c2 73	 add	 edx, 115		; 00000073H
  0025f	52		 push	 edx
  00260	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00263	83 c0 68	 add	 eax, 104		; 00000068H
  00266	50		 push	 eax
  00267	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0026a	83 c1 01	 add	 ecx, 1
  0026d	51		 push	 ecx
  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fi@
  00273	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00279	83 c4 14	 add	 esp, 20			; 00000014H

; 5295 : 			iBridgeIndex+1,
; 5296 : 			lpObj->AccountID,
; 5297 : 			lpObj->Name,
; 5298 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState
; 5299 : 			);
; 5300 : 	}

  0027c	e9 ca fd ff ff	 jmp	 $LN2@FixUsersPl
$LN3@FixUsersPl:
$LN1@FixUsersPl:

; 5301 : }

  00281	5f		 pop	 edi
  00282	5e		 pop	 esi
  00283	5b		 pop	 ebx
  00284	8b e5		 mov	 esp, ebp
  00286	5d		 pop	 ebp
  00287	c2 04 00	 ret	 4
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateFail
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv349 = -84						; size = 4
tv322 = -84						; size = 4
tv300 = -84						; size = 4
tv281 = -84						; size = 4
tv257 = -84						; size = 4
tv237 = -84						; size = 4
tv208 = -84						; size = 4
tv189 = -84						; size = 4
tv66 = -84						; size = 4
tv350 = -80						; size = 4
tv323 = -80						; size = 4
tv301 = -80						; size = 4
tv282 = -80						; size = 4
tv258 = -80						; size = 4
tv238 = -80						; size = 4
tv209 = -80						; size = 4
tv190 = -80						; size = 4
tv184 = -80						; size = 4
tv67 = -80						; size = 4
_lpObj$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateWin, COMDAT
; _this$ = ecx

; 5093 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 5094 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN36@FixUsersPl
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN37@FixUsersPl
$LN36@FixUsersPl:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN34@FixUsersPl
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN35@FixUsersPl
$LN34@FixUsersPl:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN35@FixUsersPl:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN37@FixUsersPl:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN7@FixUsersPl

; 5095 : 		return;

  0003d	e9 d2 05 00 00	 jmp	 $LN1@FixUsersPl
$LN7@FixUsersPl:

; 5096 : 
; 5097 : 	if (m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1) {			//  

  00042	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 bc 01 48 01
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+328], -1
  00054	0f 84 ba 05 00
	00		 je	 $LN3@FixUsersPl

; 5098 : 
; 5099 : 		for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00061	eb 09		 jmp	 SHORT $LN4@FixUsersPl
$LN2@FixUsersPl:
  00063	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@FixUsersPl:
  0006c	83 7d f8 0a	 cmp	 DWORD PTR _i$2[ebp], 10	; 0000000aH
  00070	0f 8d 9e 05 00
	00		 jge	 $LN3@FixUsersPl

; 5100 : 			if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1) {

  00076	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00084	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00088	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  0008d	75 02		 jne	 SHORT $LN9@FixUsersPl

; 5101 : 				//   
; 5102 : 				continue;

  0008f	eb d2		 jmp	 SHORT $LN2@FixUsersPl
$LN9@FixUsersPl:

; 5103 : 			}
; 5104 : 
; 5105 : 			if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < 3) {

  00091	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0009f	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  000a3	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b1	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  000b6	7d 02		 jge	 SHORT $LN10@FixUsersPl

; 5106 : 				//    
; 5107 : 				continue;

  000b8	eb a9		 jmp	 SHORT $LN2@FixUsersPl
$LN10@FixUsersPl:

; 5108 : 			}
; 5109 : 
; 5110 : 			if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1) || 
; 5111 : 				(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1) ||

  000ba	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000c8	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  000cc	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000da	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  000e2	83 f8 ff	 cmp	 eax, -1
  000e5	74 5a		 je	 SHORT $LN12@FixUsersPl
  000e7	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000f5	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  000f9	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00101	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00107	0f be 84 0a d3
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3283]
  0010f	83 f8 ff	 cmp	 eax, -1
  00112	74 2d		 je	 SHORT $LN12@FixUsersPl
  00114	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0011b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00122	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00126	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0012e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00134	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  0013c	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0013f	74 05		 je	 SHORT $LN11@FixUsersPl
$LN12@FixUsersPl:

; 5112 : 				(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex)
; 5113 : 				) 
; 5114 : 			{
; 5115 : 				//    
; 5116 : 				continue;

  00141	e9 1d ff ff ff	 jmp	 $LN2@FixUsersPl
$LN11@FixUsersPl:

; 5117 : 			}
; 5118 : 			
; 5119 : 			LPOBJECTSTRUCT lpObj = &gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];

  00146	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0014d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00154	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00158	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00160	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00166	89 4d f4	 mov	 DWORD PTR _lpObj$1[ebp], ecx

; 5120 : 			
; 5121 : 			switch (m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState) {

  00169	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00170	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00173	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00177	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0017b	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  0017f	89 4d b0	 mov	 DWORD PTR tv184[ebp], ecx
  00182	83 7d b0 04	 cmp	 DWORD PTR tv184[ebp], 4
  00186	0f 87 49 04 00
	00		 ja	 $LN5@FixUsersPl
  0018c	8b 55 b0	 mov	 edx, DWORD PTR tv184[ebp]
  0018f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN70@FixUsersPl[edx*4]
$LN13@FixUsersPl:

; 5122 : 			case BC_USER_ALIVE :				// 	
; 5123 : 				{
; 5124 : 					//     
; 5125 : 					if ((CHECK_LIMIT(lpObj->PartyNumber, MAX_PARTY)) &&

  00196	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00199	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  001a0	7d 09		 jge	 SHORT $LN40@FixUsersPl
  001a2	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv190[ebp], 0
  001a9	eb 25		 jmp	 SHORT $LN41@FixUsersPl
$LN40@FixUsersPl:
  001ab	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$1[ebp]
  001ae	81 b9 88 02 00
	00 e7 1c 00 00	 cmp	 DWORD PTR [ecx+648], 7399 ; 00001ce7H
  001b8	7e 09		 jle	 SHORT $LN38@FixUsersPl
  001ba	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv189[ebp], 0
  001c1	eb 07		 jmp	 SHORT $LN39@FixUsersPl
$LN38@FixUsersPl:
  001c3	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv189[ebp], 1
$LN39@FixUsersPl:
  001ca	8b 55 ac	 mov	 edx, DWORD PTR tv189[ebp]
  001cd	89 55 b0	 mov	 DWORD PTR tv190[ebp], edx
$LN41@FixUsersPl:
  001d0	83 7d b0 00	 cmp	 DWORD PTR tv190[ebp], 0
  001d4	0f 84 cd 00 00
	00		 je	 $LN14@FixUsersPl
  001da	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  001ef	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f8	8b 80 88 02 00
	00		 mov	 eax, DWORD PTR [eax+648]
  001fe	3b 84 11 88 02
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+648]
  00205	0f 85 9c 00 00
	00		 jne	 $LN14@FixUsersPl

; 5126 : 						(lpObj->PartyNumber == gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber)
; 5127 : 						) 
; 5128 : 					{
; 5129 : 						//  .
; 5130 : 						if (CHECK_BLOODCASTLE(lpObj->MapNumber) &&
; 5131 : 							lpObj->Live == 1 &&

  0020b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  0020e	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00215	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00218	7d 09		 jge	 SHORT $LN44@FixUsersPl
  0021a	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv209[ebp], 0
  00221	eb 25		 jmp	 SHORT $LN45@FixUsersPl
$LN44@FixUsersPl:
  00223	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$1[ebp]
  00226	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0022d	83 f8 11	 cmp	 eax, 17			; 00000011H
  00230	7e 09		 jle	 SHORT $LN42@FixUsersPl
  00232	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv208[ebp], 0
  00239	eb 07		 jmp	 SHORT $LN43@FixUsersPl
$LN42@FixUsersPl:
  0023b	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv208[ebp], 1
$LN43@FixUsersPl:
  00242	8b 4d ac	 mov	 ecx, DWORD PTR tv208[ebp]
  00245	89 4d b0	 mov	 DWORD PTR tv209[ebp], ecx
$LN45@FixUsersPl:
  00248	83 7d b0 00	 cmp	 DWORD PTR tv209[ebp], 0
  0024c	74 3d		 je	 SHORT $LN16@FixUsersPl
  0024e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00251	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00255	83 f9 01	 cmp	 ecx, 1
  00258	75 31		 jne	 SHORT $LN16@FixUsersPl
  0025a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  0025d	f3 0f 5a 80 bc
	00 00 00	 cvtss2sd xmm0, DWORD PTR [eax+188]
  00265	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0026d	76 1c		 jbe	 SHORT $LN16@FixUsersPl

; 5132 : 							lpObj->Life > 0.0
; 5133 : 							)
; 5134 : 						{
; 5135 : 							m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_WINNER_PARTY_ALIVE;

  0026f	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00276	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00279	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0027d	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00281	c7 44 02 24 03
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 3

; 5136 : 						}

  00289	eb 1a		 jmp	 SHORT $LN17@FixUsersPl
$LN16@FixUsersPl:

; 5137 : 						else {
; 5138 : 							m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_WINNER_PARTY_DEAD;

  0028b	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00292	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00295	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00299	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0029d	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN17@FixUsersPl:

; 5139 : 						}
; 5140 : 					}

  002a5	eb 7c		 jmp	 SHORT $LN18@FixUsersPl
$LN14@FixUsersPl:

; 5141 : 					else {
; 5142 : 						//     .
; 5143 : 						if (!CHECK_BLOODCASTLE(lpObj->MapNumber) ||
; 5144 : 							lpObj->Live == 0 ||

  002a7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  002aa	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  002b1	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  002b4	7d 09		 jge	 SHORT $LN48@FixUsersPl
  002b6	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv238[ebp], 0
  002bd	eb 25		 jmp	 SHORT $LN49@FixUsersPl
$LN48@FixUsersPl:
  002bf	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$1[ebp]
  002c2	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  002c9	83 f8 11	 cmp	 eax, 17			; 00000011H
  002cc	7e 09		 jle	 SHORT $LN46@FixUsersPl
  002ce	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv237[ebp], 0
  002d5	eb 07		 jmp	 SHORT $LN47@FixUsersPl
$LN46@FixUsersPl:
  002d7	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv237[ebp], 1
$LN47@FixUsersPl:
  002de	8b 4d ac	 mov	 ecx, DWORD PTR tv237[ebp]
  002e1	89 4d b0	 mov	 DWORD PTR tv238[ebp], ecx
$LN49@FixUsersPl:
  002e4	83 7d b0 00	 cmp	 DWORD PTR tv238[ebp], 0
  002e8	74 1f		 je	 SHORT $LN19@FixUsersPl
  002ea	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  002ed	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  002f1	85 c9		 test	 ecx, ecx
  002f3	74 14		 je	 SHORT $LN19@FixUsersPl
  002f5	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  002f8	f3 0f 5a 80 bc
	00 00 00	 cvtss2sd xmm0, DWORD PTR [eax+188]
  00300	0f 57 c9	 xorps	 xmm1, xmm1
  00303	66 0f 2f c8	 comisd	 xmm1, xmm0
  00307	72 1a		 jb	 SHORT $LN18@FixUsersPl
$LN19@FixUsersPl:

; 5145 : 							lpObj->Life <= 0.0
; 5146 : 							)
; 5147 : 						{
; 5148 : 							m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_DEAD;

  00309	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00310	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00313	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00317	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0031b	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1
$LN18@FixUsersPl:

; 5149 : 						}
; 5150 : 					}
; 5151 : 				}
; 5152 : 				break;

  00323	e9 ad 02 00 00	 jmp	 $LN5@FixUsersPl
$LN20@FixUsersPl:

; 5153 : 			case BC_USER_DEAD :					// 
; 5154 : 				{
; 5155 : 					//    
; 5156 : 					if ((CHECK_LIMIT(lpObj->PartyNumber, MAX_PARTY)) &&

  00328	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  0032b	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  00332	7d 09		 jge	 SHORT $LN52@FixUsersPl
  00334	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv258[ebp], 0
  0033b	eb 25		 jmp	 SHORT $LN53@FixUsersPl
$LN52@FixUsersPl:
  0033d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$1[ebp]
  00340	81 b9 88 02 00
	00 e7 1c 00 00	 cmp	 DWORD PTR [ecx+648], 7399 ; 00001ce7H
  0034a	7e 09		 jle	 SHORT $LN50@FixUsersPl
  0034c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv257[ebp], 0
  00353	eb 07		 jmp	 SHORT $LN51@FixUsersPl
$LN50@FixUsersPl:
  00355	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv257[ebp], 1
$LN51@FixUsersPl:
  0035c	8b 55 ac	 mov	 edx, DWORD PTR tv257[ebp]
  0035f	89 55 b0	 mov	 DWORD PTR tv258[ebp], edx
$LN53@FixUsersPl:
  00362	83 7d b0 00	 cmp	 DWORD PTR tv258[ebp], 0
  00366	74 47		 je	 SHORT $LN21@FixUsersPl
  00368	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0036f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00372	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  0037d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00380	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00386	8b 80 88 02 00
	00		 mov	 eax, DWORD PTR [eax+648]
  0038c	3b 84 11 88 02
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+648]
  00393	75 1a		 jne	 SHORT $LN21@FixUsersPl

; 5157 : 						(lpObj->PartyNumber == gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber)
; 5158 : 						) 
; 5159 : 					{
; 5160 : 						//  .
; 5161 : 						m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_WINNER_PARTY_DEAD;

  00395	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0039c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0039f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  003a3	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  003a7	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN21@FixUsersPl:

; 5162 : 					}
; 5163 : 				}
; 5164 : 				break;

  003af	e9 21 02 00 00	 jmp	 $LN5@FixUsersPl

; 5165 : 			case BC_USER_WINNER :				// 
; 5166 : 				{
; 5167 : 					//     ( CheckWinnerValid()     )
; 5168 : 				}
; 5169 : 				break;

  003b4	e9 1c 02 00 00	 jmp	 $LN5@FixUsersPl
$LN23@FixUsersPl:

; 5170 : 			case BC_USER_WINNER_PARTY_ALIVE :	//  ( )
; 5171 : 				{
; 5172 : 					//         ,  
; 5173 : 					if ((CHECK_LIMIT(lpObj->PartyNumber, MAX_PARTY)) &&

  003b9	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  003bc	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  003c3	7d 09		 jge	 SHORT $LN56@FixUsersPl
  003c5	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv282[ebp], 0
  003cc	eb 25		 jmp	 SHORT $LN57@FixUsersPl
$LN56@FixUsersPl:
  003ce	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$1[ebp]
  003d1	81 b9 88 02 00
	00 e7 1c 00 00	 cmp	 DWORD PTR [ecx+648], 7399 ; 00001ce7H
  003db	7e 09		 jle	 SHORT $LN54@FixUsersPl
  003dd	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv281[ebp], 0
  003e4	eb 07		 jmp	 SHORT $LN55@FixUsersPl
$LN54@FixUsersPl:
  003e6	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv281[ebp], 1
$LN55@FixUsersPl:
  003ed	8b 55 ac	 mov	 edx, DWORD PTR tv281[ebp]
  003f0	89 55 b0	 mov	 DWORD PTR tv282[ebp], edx
$LN57@FixUsersPl:
  003f3	83 7d b0 00	 cmp	 DWORD PTR tv282[ebp], 0
  003f7	0f 84 b2 00 00
	00		 je	 $LN24@FixUsersPl
  003fd	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00404	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00407	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  00412	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00415	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0041b	8b 80 88 02 00
	00		 mov	 eax, DWORD PTR [eax+648]
  00421	3b 84 11 88 02
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+648]
  00428	0f 85 81 00 00
	00		 jne	 $LN24@FixUsersPl

; 5174 : 						(lpObj->PartyNumber == gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber)
; 5175 : 						) 
; 5176 : 					{
; 5177 : 						//  .
; 5178 : 						if (!CHECK_BLOODCASTLE(lpObj->MapNumber) ||
; 5179 : 							lpObj->Live == 0 ||

  0042e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00431	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00438	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0043b	7d 09		 jge	 SHORT $LN60@FixUsersPl
  0043d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv301[ebp], 0
  00444	eb 25		 jmp	 SHORT $LN61@FixUsersPl
$LN60@FixUsersPl:
  00446	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$1[ebp]
  00449	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00450	83 f8 11	 cmp	 eax, 17			; 00000011H
  00453	7e 09		 jle	 SHORT $LN58@FixUsersPl
  00455	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv300[ebp], 0
  0045c	eb 07		 jmp	 SHORT $LN59@FixUsersPl
$LN58@FixUsersPl:
  0045e	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv300[ebp], 1
$LN59@FixUsersPl:
  00465	8b 4d ac	 mov	 ecx, DWORD PTR tv300[ebp]
  00468	89 4d b0	 mov	 DWORD PTR tv301[ebp], ecx
$LN61@FixUsersPl:
  0046b	83 7d b0 00	 cmp	 DWORD PTR tv301[ebp], 0
  0046f	74 1f		 je	 SHORT $LN27@FixUsersPl
  00471	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00474	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00478	85 c9		 test	 ecx, ecx
  0047a	74 14		 je	 SHORT $LN27@FixUsersPl
  0047c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  0047f	f3 0f 5a 80 bc
	00 00 00	 cvtss2sd xmm0, DWORD PTR [eax+188]
  00487	0f 57 c9	 xorps	 xmm1, xmm1
  0048a	66 0f 2f c8	 comisd	 xmm1, xmm0
  0048e	72 1a		 jb	 SHORT $LN26@FixUsersPl
$LN27@FixUsersPl:

; 5180 : 							lpObj->Life <= 0.0
; 5181 : 							)
; 5182 : 						{
; 5183 : 							m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_WINNER_PARTY_DEAD;

  00490	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00497	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0049a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0049e	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  004a2	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN26@FixUsersPl:

; 5184 : 						}
; 5185 : 					}

  004aa	e9 9a 00 00 00	 jmp	 $LN29@FixUsersPl
$LN24@FixUsersPl:

; 5186 : 					else {
; 5187 : 						//    
; 5188 : 						if (CHECK_BLOODCASTLE(lpObj->MapNumber) &&
; 5189 : 							lpObj->Live == 1 &&

  004af	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  004b2	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  004b9	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  004bc	7d 09		 jge	 SHORT $LN64@FixUsersPl
  004be	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv323[ebp], 0
  004c5	eb 25		 jmp	 SHORT $LN65@FixUsersPl
$LN64@FixUsersPl:
  004c7	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$1[ebp]
  004ca	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  004d1	83 f8 11	 cmp	 eax, 17			; 00000011H
  004d4	7e 09		 jle	 SHORT $LN62@FixUsersPl
  004d6	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv322[ebp], 0
  004dd	eb 07		 jmp	 SHORT $LN63@FixUsersPl
$LN62@FixUsersPl:
  004df	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv322[ebp], 1
$LN63@FixUsersPl:
  004e6	8b 4d ac	 mov	 ecx, DWORD PTR tv322[ebp]
  004e9	89 4d b0	 mov	 DWORD PTR tv323[ebp], ecx
$LN65@FixUsersPl:
  004ec	83 7d b0 00	 cmp	 DWORD PTR tv323[ebp], 0
  004f0	74 3d		 je	 SHORT $LN28@FixUsersPl
  004f2	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  004f5	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  004f9	83 f9 01	 cmp	 ecx, 1
  004fc	75 31		 jne	 SHORT $LN28@FixUsersPl
  004fe	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00501	f3 0f 5a 80 bc
	00 00 00	 cvtss2sd xmm0, DWORD PTR [eax+188]
  00509	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00511	76 1c		 jbe	 SHORT $LN28@FixUsersPl

; 5190 : 							lpObj->Life > 0.0
; 5191 : 							)
; 5192 : 						{
; 5193 : 							m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_ALIVE;

  00513	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0051a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0051d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00521	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00525	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0

; 5194 : 						}

  0052d	eb 1a		 jmp	 SHORT $LN29@FixUsersPl
$LN28@FixUsersPl:

; 5195 : 						else {
; 5196 : 							m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_DEAD;

  0052f	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00536	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00539	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0053d	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00541	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1
$LN29@FixUsersPl:

; 5197 : 						}
; 5198 : 					}
; 5199 : 				}
; 5200 : 				break;

  00549	e9 87 00 00 00	 jmp	 $LN5@FixUsersPl
$LN30@FixUsersPl:

; 5201 : 			case BC_USER_WINNER_PARTY_DEAD :	//  ( )
; 5202 : 				{
; 5203 : 					//         
; 5204 : 					if (!(CHECK_LIMIT(lpObj->PartyNumber, MAX_PARTY)) ||

  0054e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  00551	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  00558	7d 09		 jge	 SHORT $LN68@FixUsersPl
  0055a	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv350[ebp], 0
  00561	eb 25		 jmp	 SHORT $LN69@FixUsersPl
$LN68@FixUsersPl:
  00563	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$1[ebp]
  00566	81 b9 88 02 00
	00 e7 1c 00 00	 cmp	 DWORD PTR [ecx+648], 7399 ; 00001ce7H
  00570	7e 09		 jle	 SHORT $LN66@FixUsersPl
  00572	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv349[ebp], 0
  00579	eb 07		 jmp	 SHORT $LN67@FixUsersPl
$LN66@FixUsersPl:
  0057b	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv349[ebp], 1
$LN67@FixUsersPl:
  00582	8b 55 ac	 mov	 edx, DWORD PTR tv349[ebp]
  00585	89 55 b0	 mov	 DWORD PTR tv350[ebp], edx
$LN69@FixUsersPl:
  00588	83 7d b0 00	 cmp	 DWORD PTR tv350[ebp], 0
  0058c	74 2d		 je	 SHORT $LN32@FixUsersPl
  0058e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00595	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00598	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  005a3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  005a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ac	8b 80 88 02 00
	00		 mov	 eax, DWORD PTR [eax+648]
  005b2	3b 84 11 88 02
	00 00		 cmp	 eax, DWORD PTR [ecx+edx+648]
  005b9	74 1a		 je	 SHORT $LN31@FixUsersPl
$LN32@FixUsersPl:

; 5205 : 						(lpObj->PartyNumber != gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber)
; 5206 : 						) 
; 5207 : 					{
; 5208 : 						//    
; 5209 : 						m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_DEAD;

  005bb	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  005c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c5	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  005c9	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  005cd	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1
$LN31@FixUsersPl:
$LN5@FixUsersPl:

; 5210 : 					}
; 5211 : 				}
; 5212 : 				break;
; 5213 : 			}
; 5214 : 
; 5215 : 			LogAddTD ("[Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : %d", 

  005d5	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  005dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005df	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  005e3	6b 45 f8 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  005e7	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  005eb	51		 push	 ecx
  005ec	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$1[ebp]
  005ef	83 c2 73	 add	 edx, 115		; 00000073H
  005f2	52		 push	 edx
  005f3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$1[ebp]
  005f6	83 c0 68	 add	 eax, 104		; 00000068H
  005f9	50		 push	 eax
  005fa	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  005fd	83 c1 01	 add	 ecx, 1
  00600	51		 push	 ecx
  00601	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fi@
  00606	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0060c	83 c4 14	 add	 esp, 20			; 00000014H

; 5216 : 				iBridgeIndex+1,
; 5217 : 				lpObj->AccountID,
; 5218 : 				lpObj->Name,
; 5219 : 				m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState
; 5220 : 				);
; 5221 : 		}

  0060f	e9 4f fa ff ff	 jmp	 $LN2@FixUsersPl
$LN3@FixUsersPl:
$LN1@FixUsersPl:

; 5222 : 	}
; 5223 : }

  00614	5f		 pop	 edi
  00615	5e		 pop	 esi
  00616	5b		 pop	 ebx
  00617	8b e5		 mov	 esp, ebp
  00619	5d		 pop	 ebp
  0061a	c2 04 00	 ret	 4
  0061d	0f 1f 00	 npad	 3
$LN70@FixUsersPl:
  00620	00 00 00 00	 DD	 $LN13@FixUsersPl
  00624	00 00 00 00	 DD	 $LN20@FixUsersPl
  00628	00 00 00 00	 DD	 $LN5@FixUsersPl
  0062c	00 00 00 00	 DD	 $LN23@FixUsersPl
  00630	00 00 00 00	 DD	 $LN30@FixUsersPl
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateWin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ChangeMonsterState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv66 = -92						; size = 4
tv67 = -88						; size = 4
_lpMA$ = -20						; size = 4
_iAddDefense$ = -16					; size = 4
_iAddDamageMin$ = -12					; size = 4
_iAddDamageMax$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::ChangeMonsterState, COMDAT
; _this$ = ecx

; 5039 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 5040 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN10@ChangeMons
  00012	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN11@ChangeMons
$LN10@ChangeMons:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN8@ChangeMons
  00021	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN9@ChangeMons
$LN8@ChangeMons:
  0002a	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@ChangeMons:
  00031	8b 45 a4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN11@ChangeMons:
  00037	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN2@ChangeMons

; 5041 : 		return;

  0003d	e9 5e 01 00 00	 jmp	 $LN1@ChangeMons
$LN2@ChangeMons:

; 5042 : 	}
; 5043 : 	
; 5044 : /*
; 5045 : 	if (!gObjIsConnected(iIndex))
; 5046 : 		return;
; 5047 : 
; 5048 : 	if (gObj[iIndex].Type != OBJTYPE_MONSTER ||
; 5049 : 		!CHECK_BLOODCASTLE(gObj[iIndex].MapNumber)
; 5050 : 		)
; 5051 : 		return;
; 5052 : */
; 5053 : 
; 5054 : 	INT iAddDamageMax	= 0;

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iAddDamageMax$[ebp], 0

; 5055 : 	INT iAddDamageMin	= 0;

  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iAddDamageMin$[ebp], 0

; 5056 : 	INT iAddDefense		= 0;

  00050	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iAddDefense$[ebp], 0

; 5057 : 	if (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 5*60*1000) {

  00057	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	81 bc 01 54 01
	00 00 e0 93 04
	00		 cmp	 DWORD PTR [ecx+eax+340], 300000 ; 000493e0H
  0006c	7d 4f		 jge	 SHORT $LN3@ChangeMons

; 5058 : 		//   5  (10)
; 5059 : 		iAddDamageMin	= g_iBC_MONSTER_CHANGE_STATE[1][0];

  0006e	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00073	c1 e0 00	 shl	 eax, 0
  00076	b9 04 00 00 00	 mov	 ecx, 4
  0007b	6b d1 00	 imul	 edx, ecx, 0
  0007e	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_MONSTER_CHANGE_STATE@@3QAY02$$CBHA[eax+edx]
  00085	89 45 f4	 mov	 DWORD PTR _iAddDamageMin$[ebp], eax

; 5060 : 		iAddDamageMax	= g_iBC_MONSTER_CHANGE_STATE[1][1];

  00088	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0008d	c1 e0 00	 shl	 eax, 0
  00090	b9 04 00 00 00	 mov	 ecx, 4
  00095	c1 e1 00	 shl	 ecx, 0
  00098	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?g_iBC_MONSTER_CHANGE_STATE@@3QAY02$$CBHA[eax+ecx]
  0009f	89 55 f8	 mov	 DWORD PTR _iAddDamageMax$[ebp], edx

; 5061 : 		iAddDefense		= g_iBC_MONSTER_CHANGE_STATE[1][2];

  000a2	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000a7	c1 e0 00	 shl	 eax, 0
  000aa	b9 04 00 00 00	 mov	 ecx, 4
  000af	d1 e1		 shl	 ecx, 1
  000b1	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?g_iBC_MONSTER_CHANGE_STATE@@3QAY02$$CBHA[eax+ecx]
  000b8	89 55 f0	 mov	 DWORD PTR _iAddDefense$[ebp], edx

; 5062 : 	}

  000bb	eb 64		 jmp	 SHORT $LN4@ChangeMons
$LN3@ChangeMons:

; 5063 : 	else if (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 10*60*1000) {

  000bd	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	81 bc 01 54 01
	00 00 c0 27 09
	00		 cmp	 DWORD PTR [ecx+eax+340], 600000 ; 000927c0H
  000d2	7d 4d		 jge	 SHORT $LN4@ChangeMons

; 5064 : 		//   10  (5)
; 5065 : 		iAddDamageMin	= g_iBC_MONSTER_CHANGE_STATE[0][0];

  000d4	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000d9	6b c8 00	 imul	 ecx, eax, 0
  000dc	ba 04 00 00 00	 mov	 edx, 4
  000e1	6b c2 00	 imul	 eax, edx, 0
  000e4	8b 8c 01 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_iBC_MONSTER_CHANGE_STATE@@3QAY02$$CBHA[ecx+eax]
  000eb	89 4d f4	 mov	 DWORD PTR _iAddDamageMin$[ebp], ecx

; 5066 : 		iAddDamageMax	= g_iBC_MONSTER_CHANGE_STATE[0][1];

  000ee	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000f3	6b c8 00	 imul	 ecx, eax, 0
  000f6	ba 04 00 00 00	 mov	 edx, 4
  000fb	c1 e2 00	 shl	 edx, 0
  000fe	8b 84 11 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_MONSTER_CHANGE_STATE@@3QAY02$$CBHA[ecx+edx]
  00105	89 45 f8	 mov	 DWORD PTR _iAddDamageMax$[ebp], eax

; 5067 : 		iAddDefense		= g_iBC_MONSTER_CHANGE_STATE[0][2];

  00108	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0010d	6b c8 00	 imul	 ecx, eax, 0
  00110	ba 04 00 00 00	 mov	 edx, 4
  00115	d1 e2		 shl	 edx, 1
  00117	8b 84 11 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_MONSTER_CHANGE_STATE@@3QAY02$$CBHA[ecx+edx]
  0011e	89 45 f0	 mov	 DWORD PTR _iAddDefense$[ebp], eax
$LN4@ChangeMons:

; 5068 : 	}
; 5069 : 
; 5070 : /*
; 5071 : 	if (!iAddDamageMin &&
; 5072 : 		!iAddDamageMax &&
; 5073 : 		!iAddDefense
; 5074 : 		)
; 5075 : 		return;
; 5076 : */
; 5077 : 
; 5078 : 	LPMONSTER_ATTRIBUTE lpMA;
; 5079 : 	lpMA = gMAttr.GetAttr(gObj[iIndex].Class);	

  00121	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012e	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00136	52		 push	 edx
  00137	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  0013c	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  00141	89 45 ec	 mov	 DWORD PTR _lpMA$[ebp], eax

; 5080 : 	if( lpMA == NULL ) {

  00144	83 7d ec 00	 cmp	 DWORD PTR _lpMA$[ebp], 0
  00148	75 02		 jne	 SHORT $LN6@ChangeMons

; 5081 : 		return;

  0014a	eb 54		 jmp	 SHORT $LN1@ChangeMons
$LN6@ChangeMons:

; 5082 : 	}
; 5083 : 
; 5084 : 	gObj[iIndex].m_AttackDamageMin	= lpMA->m_DamageMin + iAddDamageMin;

  0014c	8b 45 ec	 mov	 eax, DWORD PTR _lpMA$[ebp]
  0014f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00152	03 4d f4	 add	 ecx, DWORD PTR _iAddDamageMin$[ebp]
  00155	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00161	89 8c 10 b4 02
	00 00		 mov	 DWORD PTR [eax+edx+692], ecx

; 5085 : 	gObj[iIndex].m_AttackDamageMax	= lpMA->m_DamageMax + iAddDamageMax;

  00168	8b 45 ec	 mov	 eax, DWORD PTR _lpMA$[ebp]
  0016b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0016e	03 4d f8	 add	 ecx, DWORD PTR _iAddDamageMax$[ebp]
  00171	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00178	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017d	89 8c 10 b8 02
	00 00		 mov	 DWORD PTR [eax+edx+696], ecx

; 5086 : 	gObj[iIndex].m_Defense			= lpMA->m_Defense + iAddDefense;

  00184	8b 45 ec	 mov	 eax, DWORD PTR _lpMA$[ebp]
  00187	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0018a	03 4d f0	 add	 ecx, DWORD PTR _iAddDefense$[ebp]
  0018d	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00194	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00199	89 8c 10 e8 02
	00 00		 mov	 DWORD PTR [eax+edx+744], ecx
$LN1@ChangeMons:

; 5087 : }

  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi
  001a2	5b		 pop	 ebx
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c2 08 00	 ret	 8
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::ChangeMonsterState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv70 = -80						; size = 4
tv71 = -76						; size = 4
_iPartyComplete$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompletePoint, COMDAT
; _this$ = ecx

; 5025 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 5026 : 	int iPartyComplete = GetWinnerPartyCompleteCount(iBridgeIndex);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
  00018	89 45 f8	 mov	 DWORD PTR _iPartyComplete$[ebp], eax

; 5027 : 	iPartyComplete--;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
  0001e	83 e8 01	 sub	 eax, 1
  00021	89 45 f8	 mov	 DWORD PTR _iPartyComplete$[ebp], eax

; 5028 : 	if (CHECK_LIMIT(iPartyComplete, MAX_PARTYUSER)) {

  00024	79 09		 jns	 SHORT $LN6@GetWinnerP
  00026	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0002d	eb 1c		 jmp	 SHORT $LN7@GetWinnerP
$LN6@GetWinnerP:
  0002f	83 7d f8 04	 cmp	 DWORD PTR _iPartyComplete$[ebp], 4
  00033	7e 09		 jle	 SHORT $LN4@GetWinnerP
  00035	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  0003c	eb 07		 jmp	 SHORT $LN5@GetWinnerP
$LN4@GetWinnerP:
  0003e	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
$LN5@GetWinnerP:
  00045	8b 45 b0	 mov	 eax, DWORD PTR tv70[ebp]
  00048	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
$LN7@GetWinnerP:
  0004b	83 7d b4 00	 cmp	 DWORD PTR tv71[ebp], 0
  0004f	74 0c		 je	 SHORT $LN2@GetWinnerP

; 5029 : 		return g_iBC_Party_EventPoint[iPartyComplete];

  00051	8b 45 f8	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
  00054	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_Party_EventPoint@@3QBHB[eax*4]
  0005b	eb 02		 jmp	 SHORT $LN1@GetWinnerP
$LN2@GetWinnerP:

; 5030 : 	}
; 5031 : 	return 0;

  0005d	33 c0		 xor	 eax, eax
$LN1@GetWinnerP:

; 5032 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompletePoint
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv154 = -92						; size = 4
tv141 = -92						; size = 4
tv86 = -92						; size = 4
tv66 = -92						; size = 4
tv155 = -88						; size = 4
tv142 = -88						; size = 4
tv87 = -88						; size = 4
tv67 = -88						; size = 4
_iPartyUserIndex$1 = -20				; size = 4
_iUserIndex$ = -16					; size = 4
_iPartyComplete$ = -12					; size = 4
_iPartyIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompleteCount, COMDAT
; _this$ = ecx

; 4987 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4988 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN14@GetWinnerP
  00012	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN15@GetWinnerP
$LN14@GetWinnerP:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN12@GetWinnerP
  00021	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN13@GetWinnerP
$LN12@GetWinnerP:
  0002a	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN13@GetWinnerP:
  00031	8b 45 a4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN15@GetWinnerP:
  00037	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 07		 jne	 SHORT $LN5@GetWinnerP

; 4989 : 		return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 c3 01 00 00	 jmp	 $LN1@GetWinnerP
$LN5@GetWinnerP:

; 4990 : 	}
; 4991 : 
; 4992 : 	if (!gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)) {

  00044	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 94 01 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+512]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0005b	83 c4 04	 add	 esp, 4
  0005e	85 c0		 test	 eax, eax
  00060	75 07		 jne	 SHORT $LN6@GetWinnerP

; 4993 : 		return 0;

  00062	33 c0		 xor	 eax, eax
  00064	e9 9e 01 00 00	 jmp	 $LN1@GetWinnerP
$LN6@GetWinnerP:

; 4994 : 	}
; 4995 : 
; 4996 : 	int iPartyIndex = gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  00069	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00083	8b 8c 10 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+edx+648]
  0008a	89 4d f8	 mov	 DWORD PTR _iPartyIndex$[ebp], ecx

; 4997 : 	if (!CHECK_LIMIT(iPartyIndex, MAX_PARTY)) {						//    

  0008d	83 7d f8 00	 cmp	 DWORD PTR _iPartyIndex$[ebp], 0
  00091	7d 09		 jge	 SHORT $LN18@GetWinnerP
  00093	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  0009a	eb 1f		 jmp	 SHORT $LN19@GetWinnerP
$LN18@GetWinnerP:
  0009c	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _iPartyIndex$[ebp], 7399 ; 00001ce7H
  000a3	7e 09		 jle	 SHORT $LN16@GetWinnerP
  000a5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  000ac	eb 07		 jmp	 SHORT $LN17@GetWinnerP
$LN16@GetWinnerP:
  000ae	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
$LN17@GetWinnerP:
  000b5	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  000b8	89 45 a8	 mov	 DWORD PTR tv87[ebp], eax
$LN19@GetWinnerP:
  000bb	83 7d a8 00	 cmp	 DWORD PTR tv87[ebp], 0
  000bf	75 07		 jne	 SHORT $LN7@GetWinnerP

; 4998 : 		return 0;

  000c1	33 c0		 xor	 eax, eax
  000c3	e9 3f 01 00 00	 jmp	 $LN1@GetWinnerP
$LN7@GetWinnerP:

; 4999 : 	}
; 5000 : 
; 5001 : 	int iPartyComplete = 0;

  000c8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iPartyComplete$[ebp], 0

; 5002 : 	int iUserIndex;
; 5003 : 	for (int iPartyUserIndex = 0; iPartyUserIndex < MAX_PARTYUSER ; iPartyUserIndex++) {

  000cf	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iPartyUserIndex$1[ebp], 0
  000d6	eb 09		 jmp	 SHORT $LN4@GetWinnerP
$LN2@GetWinnerP:
  000d8	8b 45 ec	 mov	 eax, DWORD PTR _iPartyUserIndex$1[ebp]
  000db	83 c0 01	 add	 eax, 1
  000de	89 45 ec	 mov	 DWORD PTR _iPartyUserIndex$1[ebp], eax
$LN4@GetWinnerP:
  000e1	83 7d ec 05	 cmp	 DWORD PTR _iPartyUserIndex$1[ebp], 5
  000e5	0f 8d 19 01 00
	00		 jge	 $LN3@GetWinnerP

; 5004 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  000eb	6b 45 f8 30	 imul	 eax, DWORD PTR _iPartyIndex$[ebp], 48
  000ef	8b 4d ec	 mov	 ecx, DWORD PTR _iPartyUserIndex$1[ebp]
  000f2	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  000f9	89 55 f0	 mov	 DWORD PTR _iUserIndex$[ebp], edx

; 5005 : 		if (gObjIsConnected(iUserIndex)) {

  000fc	8b 45 f0	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00105	83 c4 04	 add	 esp, 4
  00108	85 c0		 test	 eax, eax
  0010a	0f 84 ef 00 00
	00		 je	 $LN8@GetWinnerP

; 5006 : 			if (CHECK_BLOODCASTLE(gObj[iUserIndex].MapNumber) && 
; 5007 : 				CHECK_LIMIT(gObj[iUserIndex].m_cBloodCastleIndex, MAX_BLOODCASTLE_BRIDGE_COUNT) &&

  00110	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011d	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00125	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00128	7d 09		 jge	 SHORT $LN22@GetWinnerP
  0012a	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
  00131	eb 30		 jmp	 SHORT $LN23@GetWinnerP
$LN22@GetWinnerP:
  00133	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00140	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00148	83 fa 11	 cmp	 edx, 17			; 00000011H
  0014b	7e 09		 jle	 SHORT $LN20@GetWinnerP
  0014d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
  00154	eb 07		 jmp	 SHORT $LN21@GetWinnerP
$LN20@GetWinnerP:
  00156	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv141[ebp], 1
$LN21@GetWinnerP:
  0015d	8b 45 a4	 mov	 eax, DWORD PTR tv141[ebp]
  00160	89 45 a8	 mov	 DWORD PTR tv142[ebp], eax
$LN23@GetWinnerP:
  00163	83 7d a8 00	 cmp	 DWORD PTR tv142[ebp], 0
  00167	0f 84 92 00 00
	00		 je	 $LN8@GetWinnerP
  0016d	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017a	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  00182	85 d2		 test	 edx, edx
  00184	7d 09		 jge	 SHORT $LN26@GetWinnerP
  00186	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv155[ebp], 0
  0018d	eb 30		 jmp	 SHORT $LN27@GetWinnerP
$LN26@GetWinnerP:
  0018f	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  00196	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019c	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  001a4	83 fa 06	 cmp	 edx, 6
  001a7	7e 09		 jle	 SHORT $LN24@GetWinnerP
  001a9	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv154[ebp], 0
  001b0	eb 07		 jmp	 SHORT $LN25@GetWinnerP
$LN24@GetWinnerP:
  001b2	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv154[ebp], 1
$LN25@GetWinnerP:
  001b9	8b 45 a4	 mov	 eax, DWORD PTR tv154[ebp]
  001bc	89 45 a8	 mov	 DWORD PTR tv155[ebp], eax
$LN27@GetWinnerP:
  001bf	83 7d a8 00	 cmp	 DWORD PTR tv155[ebp], 0
  001c3	74 3a		 je	 SHORT $LN8@GetWinnerP
  001c5	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  001cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d2	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  001d7	83 fa 01	 cmp	 edx, 1
  001da	75 23		 jne	 SHORT $LN8@GetWinnerP

; 5008 : 				gObj[iUserIndex].Live == 1) 
; 5009 : 			{
; 5010 : 				if (gObj[iUserIndex].m_bBloodCastleComplete == true) {

  001dc	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e9	0f b6 94 01 d8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3288]
  001f1	83 fa 01	 cmp	 edx, 1
  001f4	75 09		 jne	 SHORT $LN8@GetWinnerP

; 5011 : 					//  
; 5012 : 					iPartyComplete++;

  001f6	8b 45 f4	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
  001f9	83 c0 01	 add	 eax, 1
  001fc	89 45 f4	 mov	 DWORD PTR _iPartyComplete$[ebp], eax
$LN8@GetWinnerP:

; 5013 : 				}
; 5014 : 			}
; 5015 : 		}
; 5016 : 	}

  001ff	e9 d4 fe ff ff	 jmp	 $LN2@GetWinnerP
$LN3@GetWinnerP:

; 5017 : 	
; 5018 : 	return iPartyComplete;

  00204	8b 45 f4	 mov	 eax, DWORD PTR _iPartyComplete$[ebp]
$LN1@GetWinnerP:

; 5019 : }

  00207	5f		 pop	 edi
  00208	5e		 pop	 esi
  00209	5b		 pop	 ebx
  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c2 04 00	 ret	 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompleteCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
tv89 = -76						; size = 4
tv66 = -76						; size = 4
tv90 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::SetBridgeWinner, COMDAT
; _this$ = ecx

; 4962 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4963 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN9@SetBridgeW
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN10@SetBridgeW
$LN9@SetBridgeW:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN7@SetBridgeW
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN8@SetBridgeW
$LN7@SetBridgeW:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN8@SetBridgeW:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN10@SetBridgeW:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 07		 jne	 SHORT $LN2@SetBridgeW

; 4964 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	e9 ac 00 00 00	 jmp	 $LN1@SetBridgeW
$LN2@SetBridgeW:

; 4965 : 	}
; 4966 : 
; 4967 : 	if (gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)) {		//    

  00044	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 94 01 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+512]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0005b	83 c4 04	 add	 esp, 4
  0005e	85 c0		 test	 eax, eax
  00060	74 07		 je	 SHORT $LN3@SetBridgeW

; 4968 : 		return false;

  00062	32 c0		 xor	 al, al
  00064	e9 87 00 00 00	 jmp	 $LN1@SetBridgeW
$LN3@SetBridgeW:

; 4969 : 	}
; 4970 : 	
; 4971 : 	if (!gObjIsConnected(iIndex)) {

  00069	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00072	83 c4 04	 add	 esp, 4
  00075	85 c0		 test	 eax, eax
  00077	75 04		 jne	 SHORT $LN4@SetBridgeW

; 4972 : 		return false;

  00079	32 c0		 xor	 al, al
  0007b	eb 73		 jmp	 SHORT $LN1@SetBridgeW
$LN4@SetBridgeW:

; 4973 : 	}
; 4974 : 
; 4975 : 	if (!CHECK_BLOODCASTLE(gObj[iIndex].MapNumber)) {

  0007d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008a	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00092	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00095	7d 09		 jge	 SHORT $LN13@SetBridgeW
  00097	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
  0009e	eb 30		 jmp	 SHORT $LN14@SetBridgeW
$LN13@SetBridgeW:
  000a0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ad	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000b5	83 fa 11	 cmp	 edx, 17			; 00000011H
  000b8	7e 09		 jle	 SHORT $LN11@SetBridgeW
  000ba	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  000c1	eb 07		 jmp	 SHORT $LN12@SetBridgeW
$LN11@SetBridgeW:
  000c3	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
$LN12@SetBridgeW:
  000ca	8b 45 b4	 mov	 eax, DWORD PTR tv89[ebp]
  000cd	89 45 b8	 mov	 DWORD PTR tv90[ebp], eax
$LN14@SetBridgeW:
  000d0	83 7d b8 00	 cmp	 DWORD PTR tv90[ebp], 0
  000d4	75 04		 jne	 SHORT $LN5@SetBridgeW

; 4976 : 		return false;

  000d6	32 c0		 xor	 al, al
  000d8	eb 16		 jmp	 SHORT $LN1@SetBridgeW
$LN5@SetBridgeW:

; 4977 : 	}
; 4978 : 
; 4979 : 	m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = iIndex;

  000da	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  000e7	89 94 01 00 02
	00 00		 mov	 DWORD PTR [ecx+eax+512], edx

; 4980 : 	return true;

  000ee	b0 01		 mov	 al, 1
$LN1@SetBridgeW:

; 4981 : }

  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 08 00	 ret	 8
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::SetBridgeWinner
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv154 = -88						; size = 4
tv141 = -88						; size = 4
tv86 = -88						; size = 4
tv66 = -88						; size = 4
tv155 = -84						; size = 4
tv142 = -84						; size = 4
tv87 = -84						; size = 4
tv67 = -84						; size = 4
_iPartyUserIndex$1 = -16				; size = 4
_iUserIndex$ = -12					; size = 4
_iPartyIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckWinnerPartyComplete, COMDAT
; _this$ = ecx

; 4923 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4924 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN14@CheckWinne
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN15@CheckWinne
$LN14@CheckWinne:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN12@CheckWinne
  00021	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN13@CheckWinne
$LN12@CheckWinne:
  0002a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN13@CheckWinne:
  00031	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN15@CheckWinne:
  00037	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 07		 jne	 SHORT $LN5@CheckWinne

; 4925 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	e9 b7 01 00 00	 jmp	 $LN1@CheckWinne
$LN5@CheckWinne:

; 4926 : 	}
; 4927 : 
; 4928 : 	if (!gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)) {

  00044	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 94 01 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+512]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0005b	83 c4 04	 add	 esp, 4
  0005e	85 c0		 test	 eax, eax
  00060	75 07		 jne	 SHORT $LN6@CheckWinne

; 4929 : 		return false;

  00062	32 c0		 xor	 al, al
  00064	e9 92 01 00 00	 jmp	 $LN1@CheckWinne
$LN6@CheckWinne:

; 4930 : 	}
; 4931 : 
; 4932 : 	int iPartyIndex = gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  00069	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00083	8b 8c 10 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+edx+648]
  0008a	89 4d f8	 mov	 DWORD PTR _iPartyIndex$[ebp], ecx

; 4933 : 	if (!CHECK_LIMIT(iPartyIndex, MAX_PARTY)) {						//     

  0008d	83 7d f8 00	 cmp	 DWORD PTR _iPartyIndex$[ebp], 0
  00091	7d 09		 jge	 SHORT $LN18@CheckWinne
  00093	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  0009a	eb 1f		 jmp	 SHORT $LN19@CheckWinne
$LN18@CheckWinne:
  0009c	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _iPartyIndex$[ebp], 7399 ; 00001ce7H
  000a3	7e 09		 jle	 SHORT $LN16@CheckWinne
  000a5	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  000ac	eb 07		 jmp	 SHORT $LN17@CheckWinne
$LN16@CheckWinne:
  000ae	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
$LN17@CheckWinne:
  000b5	8b 45 a8	 mov	 eax, DWORD PTR tv86[ebp]
  000b8	89 45 ac	 mov	 DWORD PTR tv87[ebp], eax
$LN19@CheckWinne:
  000bb	83 7d ac 00	 cmp	 DWORD PTR tv87[ebp], 0
  000bf	75 07		 jne	 SHORT $LN7@CheckWinne

; 4934 : 		return true;

  000c1	b0 01		 mov	 al, 1
  000c3	e9 33 01 00 00	 jmp	 $LN1@CheckWinne
$LN7@CheckWinne:

; 4935 : 	}
; 4936 : 
; 4937 : 	int iUserIndex;
; 4938 : 	for (int iPartyUserIndex = 0; iPartyUserIndex < MAX_PARTYUSER ; iPartyUserIndex++) {

  000c8	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iPartyUserIndex$1[ebp], 0
  000cf	eb 09		 jmp	 SHORT $LN4@CheckWinne
$LN2@CheckWinne:
  000d1	8b 45 f0	 mov	 eax, DWORD PTR _iPartyUserIndex$1[ebp]
  000d4	83 c0 01	 add	 eax, 1
  000d7	89 45 f0	 mov	 DWORD PTR _iPartyUserIndex$1[ebp], eax
$LN4@CheckWinne:
  000da	83 7d f0 05	 cmp	 DWORD PTR _iPartyUserIndex$1[ebp], 5
  000de	0f 8d 15 01 00
	00		 jge	 $LN3@CheckWinne

; 4939 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  000e4	6b 45 f8 30	 imul	 eax, DWORD PTR _iPartyIndex$[ebp], 48
  000e8	8b 4d f0	 mov	 ecx, DWORD PTR _iPartyUserIndex$1[ebp]
  000eb	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  000f2	89 55 f4	 mov	 DWORD PTR _iUserIndex$[ebp], edx

; 4940 : 		if (gObjIsConnected(iUserIndex)) {

  000f5	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000fe	83 c4 04	 add	 esp, 4
  00101	85 c0		 test	 eax, eax
  00103	0f 84 eb 00 00
	00		 je	 $LN8@CheckWinne

; 4941 : 			if (CHECK_BLOODCASTLE(gObj[iUserIndex].MapNumber) && 
; 4942 : 				CHECK_LIMIT(gObj[iUserIndex].m_cBloodCastleIndex, MAX_BLOODCASTLE_BRIDGE_COUNT) &&

  00109	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  00110	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00116	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0011e	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00121	7d 09		 jge	 SHORT $LN22@CheckWinne
  00123	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
  0012a	eb 30		 jmp	 SHORT $LN23@CheckWinne
$LN22@CheckWinne:
  0012c	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  00133	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00139	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00141	83 fa 11	 cmp	 edx, 17			; 00000011H
  00144	7e 09		 jle	 SHORT $LN20@CheckWinne
  00146	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
  0014d	eb 07		 jmp	 SHORT $LN21@CheckWinne
$LN20@CheckWinne:
  0014f	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv141[ebp], 1
$LN21@CheckWinne:
  00156	8b 45 a8	 mov	 eax, DWORD PTR tv141[ebp]
  00159	89 45 ac	 mov	 DWORD PTR tv142[ebp], eax
$LN23@CheckWinne:
  0015c	83 7d ac 00	 cmp	 DWORD PTR tv142[ebp], 0
  00160	0f 84 8e 00 00
	00		 je	 $LN8@CheckWinne
  00166	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  0016d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00173	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  0017b	85 d2		 test	 edx, edx
  0017d	7d 09		 jge	 SHORT $LN26@CheckWinne
  0017f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv155[ebp], 0
  00186	eb 30		 jmp	 SHORT $LN27@CheckWinne
$LN26@CheckWinne:
  00188	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  0018f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00195	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  0019d	83 fa 06	 cmp	 edx, 6
  001a0	7e 09		 jle	 SHORT $LN24@CheckWinne
  001a2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv154[ebp], 0
  001a9	eb 07		 jmp	 SHORT $LN25@CheckWinne
$LN24@CheckWinne:
  001ab	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv154[ebp], 1
$LN25@CheckWinne:
  001b2	8b 45 a8	 mov	 eax, DWORD PTR tv154[ebp]
  001b5	89 45 ac	 mov	 DWORD PTR tv155[ebp], eax
$LN27@CheckWinne:
  001b8	83 7d ac 00	 cmp	 DWORD PTR tv155[ebp], 0
  001bc	74 36		 je	 SHORT $LN8@CheckWinne
  001be	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  001c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cb	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  001d0	83 fa 01	 cmp	 edx, 1
  001d3	75 1f		 jne	 SHORT $LN8@CheckWinne

; 4943 : 				gObj[iUserIndex].Live == 1) 
; 4944 : 			{
; 4945 : 				if (gObj[iUserIndex].m_bBloodCastleComplete == false) {

  001d5	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  001dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e2	0f b6 94 01 d8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3288]
  001ea	85 d2		 test	 edx, edx
  001ec	75 06		 jne	 SHORT $LN8@CheckWinne

; 4946 : 					//      
; 4947 : 					return false;

  001ee	32 c0		 xor	 al, al
  001f0	eb 09		 jmp	 SHORT $LN1@CheckWinne

; 4948 : 					break;

  001f2	eb 05		 jmp	 SHORT $LN3@CheckWinne
$LN8@CheckWinne:

; 4949 : 				}
; 4950 : 			}
; 4951 : 		}
; 4952 : 	}

  001f4	e9 d8 fe ff ff	 jmp	 $LN2@CheckWinne
$LN3@CheckWinne:

; 4953 : 	
; 4954 : 	return true;

  001f9	b0 01		 mov	 al, 1
$LN1@CheckWinne:

; 4955 : }

  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	8b e5		 mov	 esp, ebp
  00200	5d		 pop	 ebp
  00201	c2 04 00	 ret	 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckWinnerPartyComplete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckPartyExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv140 = -88						; size = 4
tv95 = -88						; size = 4
tv72 = -88						; size = 4
tv141 = -84						; size = 4
tv128 = -84						; size = 4
tv73 = -84						; size = 4
_iPartyUserIndex$1 = -16				; size = 4
_iUserIndex$ = -12					; size = 4
_iPartyIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPartyExist, COMDAT
; _this$ = ecx

; 4889 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4890 : 	if (gObjIsConnected(iIndex) == FALSE) {

  0000c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00015	83 c4 04	 add	 esp, 4
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN5@CheckParty

; 4891 : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	e9 85 01 00 00	 jmp	 $LN1@CheckParty
$LN5@CheckParty:

; 4892 : 	}
; 4893 : 
; 4894 : 	int iPartyIndex = gObj[iIndex].PartyNumber;

  00023	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00030	8b 94 01 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+648]
  00037	89 55 f8	 mov	 DWORD PTR _iPartyIndex$[ebp], edx

; 4895 : 	if (!CHECK_LIMIT(iPartyIndex, MAX_PARTY)) {						//    

  0003a	83 7d f8 00	 cmp	 DWORD PTR _iPartyIndex$[ebp], 0
  0003e	7d 09		 jge	 SHORT $LN13@CheckParty
  00040	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00047	eb 1f		 jmp	 SHORT $LN14@CheckParty
$LN13@CheckParty:
  00049	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _iPartyIndex$[ebp], 7399 ; 00001ce7H
  00050	7e 09		 jle	 SHORT $LN11@CheckParty
  00052	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  00059	eb 07		 jmp	 SHORT $LN12@CheckParty
$LN11@CheckParty:
  0005b	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
$LN12@CheckParty:
  00062	8b 45 a8	 mov	 eax, DWORD PTR tv72[ebp]
  00065	89 45 ac	 mov	 DWORD PTR tv73[ebp], eax
$LN14@CheckParty:
  00068	83 7d ac 00	 cmp	 DWORD PTR tv73[ebp], 0
  0006c	75 07		 jne	 SHORT $LN6@CheckParty

; 4896 : 		return false;

  0006e	32 c0		 xor	 al, al
  00070	e9 33 01 00 00	 jmp	 $LN1@CheckParty
$LN6@CheckParty:

; 4897 : 	}
; 4898 : 
; 4899 : 	int iUserIndex;
; 4900 : 	for (int iPartyUserIndex = 0; iPartyUserIndex < MAX_PARTYUSER ; iPartyUserIndex++) {

  00075	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iPartyUserIndex$1[ebp], 0
  0007c	eb 09		 jmp	 SHORT $LN4@CheckParty
$LN2@CheckParty:
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _iPartyUserIndex$1[ebp]
  00081	83 c0 01	 add	 eax, 1
  00084	89 45 f0	 mov	 DWORD PTR _iPartyUserIndex$1[ebp], eax
$LN4@CheckParty:
  00087	83 7d f0 05	 cmp	 DWORD PTR _iPartyUserIndex$1[ebp], 5
  0008b	0f 8d 15 01 00
	00		 jge	 $LN3@CheckParty

; 4901 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00091	6b 45 f8 30	 imul	 eax, DWORD PTR _iPartyIndex$[ebp], 48
  00095	8b 4d f0	 mov	 ecx, DWORD PTR _iPartyUserIndex$1[ebp]
  00098	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  0009f	89 55 f4	 mov	 DWORD PTR _iUserIndex$[ebp], edx

; 4902 : 		if (gObjIsConnected(iUserIndex)) {

  000a2	8b 45 f4	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000ab	83 c4 04	 add	 esp, 4
  000ae	85 c0		 test	 eax, eax
  000b0	0f 84 eb 00 00
	00		 je	 $LN7@CheckParty

; 4903 : 			if (CHECK_BLOODCASTLE(gObj[iUserIndex].MapNumber) && 
; 4904 : 				CHECK_LIMIT(gObj[iUserIndex].m_cBloodCastleIndex, MAX_BLOODCASTLE_BRIDGE_COUNT) &&

  000b6	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c3	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000cb	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  000ce	7d 09		 jge	 SHORT $LN17@CheckParty
  000d0	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], 0
  000d7	eb 30		 jmp	 SHORT $LN18@CheckParty
$LN17@CheckParty:
  000d9	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e6	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000ee	83 fa 11	 cmp	 edx, 17			; 00000011H
  000f1	7e 09		 jle	 SHORT $LN15@CheckParty
  000f3	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  000fa	eb 07		 jmp	 SHORT $LN16@CheckParty
$LN15@CheckParty:
  000fc	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
$LN16@CheckParty:
  00103	8b 45 a8	 mov	 eax, DWORD PTR tv95[ebp]
  00106	89 45 ac	 mov	 DWORD PTR tv128[ebp], eax
$LN18@CheckParty:
  00109	83 7d ac 00	 cmp	 DWORD PTR tv128[ebp], 0
  0010d	0f 84 8e 00 00
	00		 je	 $LN7@CheckParty
  00113	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00120	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  00128	85 d2		 test	 edx, edx
  0012a	7d 09		 jge	 SHORT $LN21@CheckParty
  0012c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
  00133	eb 30		 jmp	 SHORT $LN22@CheckParty
$LN21@CheckParty:
  00135	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00142	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  0014a	83 fa 06	 cmp	 edx, 6
  0014d	7e 09		 jle	 SHORT $LN19@CheckParty
  0014f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
  00156	eb 07		 jmp	 SHORT $LN20@CheckParty
$LN19@CheckParty:
  00158	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv140[ebp], 1
$LN20@CheckParty:
  0015f	8b 45 a8	 mov	 eax, DWORD PTR tv140[ebp]
  00162	89 45 ac	 mov	 DWORD PTR tv141[ebp], eax
$LN22@CheckParty:
  00165	83 7d ac 00	 cmp	 DWORD PTR tv141[ebp], 0
  00169	74 36		 je	 SHORT $LN7@CheckParty
  0016b	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  00172	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00178	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  0017d	83 fa 01	 cmp	 edx, 1
  00180	75 1f		 jne	 SHORT $LN7@CheckParty

; 4905 : 				gObj[iUserIndex].Live == 1) 
; 4906 : 			{
; 4907 : 				if (gObj[iUserIndex].m_bBloodCastleComplete == false) {

  00182	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  00189	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018f	0f b6 94 01 d8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3288]
  00197	85 d2		 test	 edx, edx
  00199	75 06		 jne	 SHORT $LN7@CheckParty

; 4908 : 					//      
; 4909 : 					return true;

  0019b	b0 01		 mov	 al, 1
  0019d	eb 09		 jmp	 SHORT $LN1@CheckParty

; 4910 : 					break;

  0019f	eb 05		 jmp	 SHORT $LN3@CheckParty
$LN7@CheckParty:

; 4911 : 				}
; 4912 : 			}
; 4913 : 		}
; 4914 : 	}

  001a1	e9 d8 fe ff ff	 jmp	 $LN2@CheckParty
$LN3@CheckParty:

; 4915 : 	
; 4916 : 	return false;

  001a6	32 c0		 xor	 al, al
$LN1@CheckParty:

; 4917 : }

  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c2 04 00	 ret	 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPartyExist
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
tv92 = -84						; size = 4
tv66 = -84						; size = 4
tv93 = -80						; size = 4
tv67 = -80						; size = 4
_iPartyIndex2$ = -12					; size = 4
_iPartyIndex1$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserWinnerParty, COMDAT
; _this$ = ecx

; 4855 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4856 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN9@CheckUserW
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN10@CheckUserW
$LN9@CheckUserW:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN7@CheckUserW
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN8@CheckUserW
$LN7@CheckUserW:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN8@CheckUserW:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN10@CheckUserW:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 07		 jne	 SHORT $LN2@CheckUserW

; 4857 : //		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckUserWinnerParty() - !CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)",	iBridgeIndex + 1);
; 4858 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	e9 b6 00 00 00	 jmp	 $LN1@CheckUserW
$LN2@CheckUserW:

; 4859 : 	}
; 4860 : 
; 4861 : 	if (!gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)) {

  00044	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 94 01 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+512]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0005b	83 c4 04	 add	 esp, 4
  0005e	85 c0		 test	 eax, eax
  00060	75 07		 jne	 SHORT $LN3@CheckUserW

; 4862 : //		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckUserWinnerParty() - !gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)",	iBridgeIndex + 1);
; 4863 : 		return false;

  00062	32 c0		 xor	 al, al
  00064	e9 91 00 00 00	 jmp	 $LN1@CheckUserW
$LN3@CheckUserW:

; 4864 : 	}
; 4865 : 	
; 4866 : 	if (!gObjIsConnected(iIndex)) {

  00069	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00072	83 c4 04	 add	 esp, 4
  00075	85 c0		 test	 eax, eax
  00077	75 04		 jne	 SHORT $LN4@CheckUserW

; 4867 : //		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckUserWinnerParty() - !gObjIsConnected(iIndex)",	iBridgeIndex + 1);
; 4868 : 		return false;

  00079	32 c0		 xor	 al, al
  0007b	eb 7d		 jmp	 SHORT $LN1@CheckUserW
$LN4@CheckUserW:

; 4869 : 	}
; 4870 : 
; 4871 : 	int iPartyIndex1 = gObj[iIndex].PartyNumber;

  0007d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008a	8b 94 01 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+648]
  00091	89 55 f8	 mov	 DWORD PTR _iPartyIndex1$[ebp], edx

; 4872 : 	int iPartyIndex2 = gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  00094	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ae	8b 8c 10 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+edx+648]
  000b5	89 4d f4	 mov	 DWORD PTR _iPartyIndex2$[ebp], ecx

; 4873 : 
; 4874 : 	if (CHECK_LIMIT(iPartyIndex1, MAX_PARTY) &&

  000b8	83 7d f8 00	 cmp	 DWORD PTR _iPartyIndex1$[ebp], 0
  000bc	7d 09		 jge	 SHORT $LN13@CheckUserW
  000be	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
  000c5	eb 1f		 jmp	 SHORT $LN14@CheckUserW
$LN13@CheckUserW:
  000c7	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _iPartyIndex1$[ebp], 7399 ; 00001ce7H
  000ce	7e 09		 jle	 SHORT $LN11@CheckUserW
  000d0	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
  000d7	eb 07		 jmp	 SHORT $LN12@CheckUserW
$LN11@CheckUserW:
  000d9	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
$LN12@CheckUserW:
  000e0	8b 45 ac	 mov	 eax, DWORD PTR tv92[ebp]
  000e3	89 45 b0	 mov	 DWORD PTR tv93[ebp], eax
$LN14@CheckUserW:
  000e6	83 7d b0 00	 cmp	 DWORD PTR tv93[ebp], 0
  000ea	74 0c		 je	 SHORT $LN5@CheckUserW
  000ec	8b 45 f8	 mov	 eax, DWORD PTR _iPartyIndex1$[ebp]
  000ef	3b 45 f4	 cmp	 eax, DWORD PTR _iPartyIndex2$[ebp]
  000f2	75 04		 jne	 SHORT $LN5@CheckUserW

; 4875 : 		iPartyIndex1 == iPartyIndex2
; 4876 : 		)
; 4877 : 	{
; 4878 : 		//    .
; 4879 : 		return true;

  000f4	b0 01		 mov	 al, 1
  000f6	eb 02		 jmp	 SHORT $LN1@CheckUserW
$LN5@CheckUserW:

; 4880 : 	}
; 4881 : 
; 4882 : 	return false;

  000f8	32 c0		 xor	 al, al
$LN1@CheckUserW:

; 4883 : }

  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 08 00	 ret	 8
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserWinnerParty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckWinnerValid@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv175 = -76						; size = 4
tv66 = -76						; size = 4
tv176 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerValid, COMDAT
; _this$ = ecx

; 4814 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4815 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN11@CheckWinne
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN12@CheckWinne
$LN11@CheckWinne:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN9@CheckWinne
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN10@CheckWinne
$LN9@CheckWinne:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN10@CheckWinne:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN12@CheckWinne:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 1c		 jne	 SHORT $LN2@CheckWinne

; 4816 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)",	iBridgeIndex + 1);

  0003d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	50		 push	 eax
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0004f	83 c4 08	 add	 esp, 8

; 4817 : 		return false;

  00052	32 c0		 xor	 al, al
  00054	e9 8a 01 00 00	 jmp	 $LN1@CheckWinne
$LN2@CheckWinne:

; 4818 : 	}
; 4819 : 
; 4820 : 	if (m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1) {

  00059	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	83 bc 01 00 02
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+512], -1
  0006b	75 1c		 jne	 SHORT $LN3@CheckWinne

; 4821 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1",	iBridgeIndex + 1);

  0006d	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00070	83 c0 01	 add	 eax, 1
  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0007f	83 c4 08	 add	 esp, 8

; 4822 : 		return false;

  00082	32 c0		 xor	 al, al
  00084	e9 5a 01 00 00	 jmp	 $LN1@CheckWinne
$LN3@CheckWinne:

; 4823 : 	}
; 4824 : 
; 4825 : 	//   
; 4826 : 	if (!gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)) {

  00089	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	8b 94 01 00 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+512]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000a0	83 c4 04	 add	 esp, 4
  000a3	85 c0		 test	 eax, eax
  000a5	75 1c		 jne	 SHORT $LN4@CheckWinne

; 4827 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)",	iBridgeIndex + 1);

  000a7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000aa	83 c0 01	 add	 eax, 1
  000ad	50		 push	 eax
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b9	83 c4 08	 add	 esp, 8

; 4828 : 		return false;

  000bc	32 c0		 xor	 al, al
  000be	e9 20 01 00 00	 jmp	 $LN1@CheckWinne
$LN4@CheckWinne:

; 4829 : 	}
; 4830 : 
; 4831 : 	//    
; 4832 : 	if ((gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) || 
; 4833 : 		(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleSubIndex == -1) ||

  000c3	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000dd	0f be 8c 10 d2
	0c 00 00	 movsx	 ecx, BYTE PTR [eax+edx+3282]
  000e5	83 f9 ff	 cmp	 ecx, -1
  000e8	74 4e		 je	 SHORT $LN6@CheckWinne
  000ea	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000f1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00104	0f be 8c 10 d3
	0c 00 00	 movsx	 ecx, BYTE PTR [eax+edx+3283]
  0010c	83 f9 ff	 cmp	 ecx, -1
  0010f	74 27		 je	 SHORT $LN6@CheckWinne
  00111	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00118	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  00126	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012b	0f be 8c 10 d2
	0c 00 00	 movsx	 ecx, BYTE PTR [eax+edx+3282]
  00133	3b 4d 08	 cmp	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00136	74 1c		 je	 SHORT $LN5@CheckWinne
$LN6@CheckWinne:

; 4834 : 		(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex != iBridgeIndex)
; 4835 : 		) 
; 4836 : 	{
; 4837 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) ...",	iBridgeIndex + 1);

  00138	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0013b	83 c0 01	 add	 eax, 1
  0013e	50		 push	 eax
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0014a	83 c4 08	 add	 esp, 8

; 4838 : 		return false;

  0014d	32 c0		 xor	 al, al
  0014f	e9 8f 00 00 00	 jmp	 $LN1@CheckWinne
$LN5@CheckWinne:

; 4839 : 	}
; 4840 : 
; 4841 : 	//    
; 4842 : 	if (!CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber)) {

  00154	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0015b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	69 94 01 00 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+512], 7072
  00169	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016e	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  00176	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00179	7d 09		 jge	 SHORT $LN15@CheckWinne
  0017b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv176[ebp], 0
  00182	eb 3e		 jmp	 SHORT $LN16@CheckWinne
$LN15@CheckWinne:
  00184	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  0018b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018e	69 8c 10 00 02
	00 00 a0 1b 00
	00		 imul	 ecx, DWORD PTR [eax+edx+512], 7072
  00199	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019f	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  001a7	83 f8 11	 cmp	 eax, 17			; 00000011H
  001aa	7e 09		 jle	 SHORT $LN13@CheckWinne
  001ac	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv175[ebp], 0
  001b3	eb 07		 jmp	 SHORT $LN14@CheckWinne
$LN13@CheckWinne:
  001b5	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv175[ebp], 1
$LN14@CheckWinne:
  001bc	8b 4d b4	 mov	 ecx, DWORD PTR tv175[ebp]
  001bf	89 4d b8	 mov	 DWORD PTR tv176[ebp], ecx
$LN16@CheckWinne:
  001c2	83 7d b8 00	 cmp	 DWORD PTR tv176[ebp], 0
  001c6	75 19		 jne	 SHORT $LN7@CheckWinne

; 4843 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber)",	iBridgeIndex + 1);

  001c8	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  001cb	83 c0 01	 add	 eax, 1
  001ce	50		 push	 eax
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastl@
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001da	83 c4 08	 add	 esp, 8

; 4844 : 		return false;

  001dd	32 c0		 xor	 al, al
  001df	eb 02		 jmp	 SHORT $LN1@CheckWinne
$LN7@CheckWinne:

; 4845 : 	}
; 4846 : 
; 4847 : 	return true;

  001e1	b0 01		 mov	 al, 1
$LN1@CheckWinne:

; 4848 : }

  001e3	5f		 pop	 edi
  001e4	5e		 pop	 esi
  001e5	5b		 pop	 ebx
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c2 04 00	 ret	 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerValid
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckWinnerExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerExist, COMDAT
; _this$ = ecx

; 4796 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4797 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN7@CheckWinne
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN8@CheckWinne
$LN7@CheckWinne:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN5@CheckWinne
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN6@CheckWinne
$LN5@CheckWinne:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN6@CheckWinne:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN8@CheckWinne:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@CheckWinne

; 4798 : //		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerExist() - !CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)",	iBridgeIndex + 1);
; 4799 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 1a		 jmp	 SHORT $LN1@CheckWinne
$LN2@CheckWinne:

; 4800 : 	}
; 4801 : 
; 4802 : 	if (m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX != -1) {

  00041	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	83 bc 01 00 02
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+512], -1
  00053	74 04		 je	 SHORT $LN3@CheckWinne

; 4803 : //		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerExist() - m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX != -1",	iBridgeIndex + 1);
; 4804 : 		return true;

  00055	b0 01		 mov	 al, 1
  00057	eb 02		 jmp	 SHORT $LN1@CheckWinne
$LN3@CheckWinne:

; 4805 : 	}
; 4806 : 
; 4807 : 	return false;

  00059	32 c0		 xor	 al, al
$LN1@CheckWinne:

; 4808 : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerExist
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
_x$1 = -12						; size = 4
_bRetVal$ = -5						; size = 1
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckUserHaveUlimateWeapon, COMDAT
; _this$ = ecx

; 4757 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4758 : 	if(!CHECK_LIMIT( iIndex, MAX_OBJECT ) )

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN14@CheckUserH
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN15@CheckUserH
$LN14@CheckUserH:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN12@CheckUserH
  00024	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN13@CheckUserH
$LN12@CheckUserH:
  0002d	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN13@CheckUserH:
  00034	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN15@CheckUserH:
  0003a	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 07		 jne	 SHORT $LN5@CheckUserH

; 4759 : 		return false;

  00040	32 c0		 xor	 al, al
  00042	e9 19 01 00 00	 jmp	 $LN1@CheckUserH
$LN5@CheckUserH:

; 4760 : 
; 4761 : 	if ((gObj[iIndex].Type != OBJTYPE_CHARACTER) || (gObj[iIndex].Connected <= 2))

  00047	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00054	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00059	83 fa 01	 cmp	 edx, 1
  0005c	75 14		 jne	 SHORT $LN7@CheckUserH
  0005e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006b	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00070	7f 07		 jg	 SHORT $LN6@CheckUserH
$LN7@CheckUserH:

; 4762 : 		return false;

  00072	32 c0		 xor	 al, al
  00074	e9 e7 00 00 00	 jmp	 $LN1@CheckUserH
$LN6@CheckUserH:

; 4763 : 
; 4764 : 	bool bRetVal = false;

  00079	c6 45 fb 00	 mov	 BYTE PTR _bRetVal$[ebp], 0

; 4765 : 
; 4766 : #ifdef PERSONAL_SHOP_20040113	//          
; 4767 : 	for(int x=0; x<MAX_INVENTORY_EXTEND; x++)

  0007d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 0
  00084	eb 09		 jmp	 SHORT $LN4@CheckUserH
$LN2@CheckUserH:
  00086	8b 45 f4	 mov	 eax, DWORD PTR _x$1[ebp]
  00089	83 c0 01	 add	 eax, 1
  0008c	89 45 f4	 mov	 DWORD PTR _x$1[ebp], eax
$LN4@CheckUserH:
  0008f	83 7d f4 6c	 cmp	 DWORD PTR _x$1[ebp], 108 ; 0000006cH
  00093	0f 8d c4 00 00
	00		 jge	 $LN3@CheckUserH

; 4768 : #else
; 4769 : 	for(int x=0; x<MAX_INVENTORY; x++)
; 4770 : #endif
; 4771 : 	{
; 4772 : 		if( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00099	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000a0	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  000a7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ad	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  000b4	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000b9	83 f8 01	 cmp	 eax, 1
  000bc	0f 85 96 00 00
	00		 jne	 $LN8@CheckUserH

; 4773 : 		{
; 4774 : 			if( 
; 4775 : 				(gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(0, 19)) ||	// 
; 4776 : 				(gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(5, 10)) ||	// 		

  000c2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000c9	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  000d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d6	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  000dd	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  000e2	6a 13		 push	 19			; 00000013H
  000e4	6a 00		 push	 0
  000e6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000eb	83 c4 08	 add	 esp, 8
  000ee	3b f0		 cmp	 esi, eax
  000f0	74 60		 je	 SHORT $LN10@CheckUserH
  000f2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000f9	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  00100	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00106	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  0010d	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00112	6a 0a		 push	 10			; 0000000aH
  00114	6a 05		 push	 5
  00116	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0011b	83 c4 08	 add	 esp, 8
  0011e	3b f0		 cmp	 esi, eax
  00120	74 30		 je	 SHORT $LN10@CheckUserH
  00122	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00129	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  00130	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00136	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  0013d	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00142	6a 12		 push	 18			; 00000012H
  00144	6a 04		 push	 4
  00146	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0014b	83 c4 08	 add	 esp, 8
  0014e	3b f0		 cmp	 esi, eax
  00150	75 06		 jne	 SHORT $LN8@CheckUserH
$LN10@CheckUserH:

; 4777 : 				(gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(4, 18))		// 			
; 4778 : 				)
; 4779 : 			{
; 4780 : 				//        
; 4781 : 				bRetVal = true;

  00152	c6 45 fb 01	 mov	 BYTE PTR _bRetVal$[ebp], 1

; 4782 : 				break;

  00156	eb 05		 jmp	 SHORT $LN3@CheckUserH
$LN8@CheckUserH:

; 4783 : 			}
; 4784 : 		}
; 4785 : 	}

  00158	e9 29 ff ff ff	 jmp	 $LN2@CheckUserH
$LN3@CheckUserH:

; 4786 : 
; 4787 : 	return bRetVal;

  0015d	8a 45 fb	 mov	 al, BYTE PTR _bRetVal$[ebp]
$LN1@CheckUserH:

; 4788 : }

  00160	5f		 pop	 edi
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c2 04 00	 ret	 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckUserHaveUlimateWeapon
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z
_TEXT	SEGMENT
tv131 = -80						; size = 4
tv66 = -80						; size = 4
tv132 = -76						; size = 4
tv67 = -76						; size = 4
_iITEM_LEVEL$1 = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_lpItem$ = 12						; size = 4
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z PROC ; CBloodCastle::CheckQuestItemSerial, COMDAT
; _this$ = ecx

; 1712 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1713 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN11@CheckQuest
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN12@CheckQuest
$LN11@CheckQuest:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN9@CheckQuest
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN10@CheckQuest
$LN9@CheckQuest:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN10@CheckQuest:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN12@CheckQuest:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 07		 jne	 SHORT $LN2@CheckQuest

; 1714 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	e9 9c 00 00 00	 jmp	 $LN1@CheckQuest
$LN2@CheckQuest:

; 1715 : 
; 1716 : 	if (m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == -1)

  00044	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 bc 01 90 01
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+400], -1
  00056	75 07		 jne	 SHORT $LN3@CheckQuest

; 1717 : 		return false;

  00058	32 c0		 xor	 al, al
  0005a	e9 81 00 00 00	 jmp	 $LN1@CheckQuest
$LN3@CheckQuest:

; 1718 : 
; 1719 : 	if( lpItem->IsItem() == TRUE )

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00062	83 c1 04	 add	 ecx, 4
  00065	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006a	83 f8 01	 cmp	 eax, 1
  0006d	75 6f		 jne	 SHORT $LN4@CheckQuest

; 1720 : 	{
; 1721 : 		if( lpItem->m_Type == MAKE_ITEMNUM(13, 19) )		//   

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00072	0f bf 70 0a	 movsx	 esi, WORD PTR [eax+10]
  00076	6a 13		 push	 19			; 00000013H
  00078	6a 0d		 push	 13			; 0000000dH
  0007a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007f	83 c4 08	 add	 esp, 8
  00082	3b f0		 cmp	 esi, eax
  00084	75 58		 jne	 SHORT $LN4@CheckQuest

; 1722 : 		{
; 1723 : 			INT iITEM_LEVEL = lpItem->m_Level;				//   .

  00086	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00089	0f bf 48 0c	 movsx	 ecx, WORD PTR [eax+12]
  0008d	89 4d f8	 mov	 DWORD PTR _iITEM_LEVEL$1[ebp], ecx

; 1724 : 
; 1725 : 			if (CHECK_LIMIT(iITEM_LEVEL, 3)) {

  00090	83 7d f8 00	 cmp	 DWORD PTR _iITEM_LEVEL$1[ebp], 0
  00094	7d 09		 jge	 SHORT $LN15@CheckQuest
  00096	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
  0009d	eb 1c		 jmp	 SHORT $LN16@CheckQuest
$LN15@CheckQuest:
  0009f	83 7d f8 02	 cmp	 DWORD PTR _iITEM_LEVEL$1[ebp], 2
  000a3	7e 09		 jle	 SHORT $LN13@CheckQuest
  000a5	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv131[ebp], 0
  000ac	eb 07		 jmp	 SHORT $LN14@CheckQuest
$LN13@CheckQuest:
  000ae	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
$LN14@CheckQuest:
  000b5	8b 45 b0	 mov	 eax, DWORD PTR tv131[ebp]
  000b8	89 45 b4	 mov	 DWORD PTR tv132[ebp], eax
$LN16@CheckQuest:
  000bb	83 7d b4 00	 cmp	 DWORD PTR tv132[ebp], 0
  000bf	74 1d		 je	 SHORT $LN4@CheckQuest

; 1726 : 				//   .
; 1727 : 				if (m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == lpItem->m_Number) {

  000c1	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  000ce	8b 84 01 90 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+400]
  000d5	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  000d8	75 04		 jne	 SHORT $LN4@CheckQuest

; 1728 : 					//    .
; 1729 : 					return true;

  000da	b0 01		 mov	 al, 1
  000dc	eb 02		 jmp	 SHORT $LN1@CheckQuest
$LN4@CheckQuest:

; 1730 : 				}
; 1731 : 			}
; 1732 : 		}
; 1733 : 	}
; 1734 : 
; 1735 : 	return false;

  000de	32 c0		 xor	 al, al
$LN1@CheckQuest:

; 1736 : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ENDP ; CBloodCastle::CheckQuestItemSerial
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckPlayStart@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPlayStart, COMDAT
; _this$ = ecx

; 1740 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1741 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN6@CheckPlayS
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN7@CheckPlayS
$LN6@CheckPlayS:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN4@CheckPlayS
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN5@CheckPlayS
$LN4@CheckPlayS:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN5@CheckPlayS:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@CheckPlayS:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@CheckPlayS

; 1742 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 11		 jmp	 SHORT $LN1@CheckPlayS
$LN2@CheckPlayS:

; 1743 : 
; 1744 : 	return m_BridgeData[iBridgeIndex].m_bBC_PLAY_START;

  00041	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8a 84 01 65 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+357]
$LN1@CheckPlayS:

; 1745 : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPlayStart
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckCanParty@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanParty, COMDAT
; _this$ = ecx

; 1703 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1704 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN6@CheckCanPa
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN7@CheckCanPa
$LN6@CheckCanPa:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN4@CheckCanPa
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN5@CheckCanPa
$LN4@CheckCanPa:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN5@CheckCanPa:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@CheckCanPa:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@CheckCanPa

; 1705 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 11		 jmp	 SHORT $LN1@CheckCanPa
$LN2@CheckCanPa:

; 1706 : 
; 1707 : 	return m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY;

  00041	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8a 84 01 64 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+356]
$LN1@CheckCanPa:

; 1708 : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanParty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckCanEnter@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanEnter, COMDAT
; _this$ = ecx

; 1694 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1695 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN6@CheckCanEn
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN7@CheckCanEn
$LN6@CheckCanEn:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN4@CheckCanEn
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN5@CheckCanEn
$LN4@CheckCanEn:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN5@CheckCanEn:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@CheckCanEn:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@CheckCanEn

; 1696 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 11		 jmp	 SHORT $LN1@CheckCanEn
$LN2@CheckCanEn:

; 1697 : 
; 1698 : 	return m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER;

  00041	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8a 84 01 63 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+355]
$LN1@CheckCanEn:

; 1699 : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanEnter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckWalk@CBloodCastle@@QAE_NHHH@Z
_TEXT	SEGMENT
tv79 = -80						; size = 4
tv66 = -80						; size = 4
tv80 = -76						; size = 4
tv67 = -76						; size = 4
_attr$1 = -5						; size = 1
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iMoveX$ = 12						; size = 4
_iMoveY$ = 16						; size = 4
?CheckWalk@CBloodCastle@@QAE_NHHH@Z PROC		; CBloodCastle::CheckWalk, COMDAT
; _this$ = ecx

; 1669 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1670 : 	if(!CHECK_LIMIT( iIndex, MAX_OBJECT ) )

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN11@CheckWalk
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN12@CheckWalk
$LN11@CheckWalk:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN9@CheckWalk
  00024	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN10@CheckWalk
$LN9@CheckWalk:
  0002d	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN10@CheckWalk:
  00034	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN12@CheckWalk:
  0003a	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 07		 jne	 SHORT $LN2@CheckWalk

; 1671 : 		return false;

  00040	32 c0		 xor	 al, al
  00042	e9 f1 00 00 00	 jmp	 $LN1@CheckWalk
$LN2@CheckWalk:

; 1672 : 
; 1673 : 	if(!CHECK_BLOODCASTLE(gObj[iIndex].MapNumber) )

  00047	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00054	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0005c	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  0005f	7d 09		 jge	 SHORT $LN15@CheckWalk
  00061	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00068	eb 30		 jmp	 SHORT $LN16@CheckWalk
$LN15@CheckWalk:
  0006a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00077	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0007f	83 fa 11	 cmp	 edx, 17			; 00000011H
  00082	7e 09		 jle	 SHORT $LN13@CheckWalk
  00084	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  0008b	eb 07		 jmp	 SHORT $LN14@CheckWalk
$LN13@CheckWalk:
  0008d	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN14@CheckWalk:
  00094	8b 45 b0	 mov	 eax, DWORD PTR tv79[ebp]
  00097	89 45 b4	 mov	 DWORD PTR tv80[ebp], eax
$LN16@CheckWalk:
  0009a	83 7d b4 00	 cmp	 DWORD PTR tv80[ebp], 0
  0009e	75 07		 jne	 SHORT $LN3@CheckWalk

; 1674 : 		return false;

  000a0	32 c0		 xor	 al, al
  000a2	e9 91 00 00 00	 jmp	 $LN1@CheckWalk
$LN3@CheckWalk:

; 1675 : 
; 1676 : 	if ((gObj[iIndex].Type != OBJTYPE_CHARACTER) || (gObj[iIndex].Connected <= 2))

  000a7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b4	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000b9	83 fa 01	 cmp	 edx, 1
  000bc	75 14		 jne	 SHORT $LN5@CheckWalk
  000be	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cb	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  000d0	7f 04		 jg	 SHORT $LN4@CheckWalk
$LN5@CheckWalk:

; 1677 : 		return false;

  000d2	32 c0		 xor	 al, al
  000d4	eb 62		 jmp	 SHORT $LN1@CheckWalk
$LN4@CheckWalk:

; 1678 : 	
; 1679 : 	if (this->GetCurrentState(gObj[iIndex].MapNumber) == BLOODCASTLE_STATE_CLOSED) {	//   (BLOODCASTLE_STATE_CLOSED ->  !!)

  000d6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e3	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000eb	52		 push	 edx
  000ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  000f4	83 f8 01	 cmp	 eax, 1
  000f7	75 3d		 jne	 SHORT $LN6@CheckWalk

; 1680 : //		if (CHECK_BLOODCASTLE(gObj[iIndex].MapNumber)) {								//   
; 1681 : 			
; 1682 : 		BYTE attr = MapC[gObj[iIndex].MapNumber].GetAttr(iMoveX, iMoveY);

  000f9	8b 45 10	 mov	 eax, DWORD PTR _iMoveY$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _iMoveX$[ebp]
  00100	51		 push	 ecx
  00101	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00108	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010d	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  00115	69 c9 8c 04 05
	00		 imul	 ecx, ecx, 328844
  0011b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00121	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00126	88 45 fb	 mov	 BYTE PTR _attr$1[ebp], al

; 1683 : 
; 1684 : 		if( ((attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE) )			//  

  00129	0f b6 45 fb	 movzx	 eax, BYTE PTR _attr$1[ebp]
  0012d	83 e0 01	 and	 eax, 1
  00130	75 04		 jne	 SHORT $LN6@CheckWalk

; 1685 : 			return true;					//    . (1>., 2>., 3>.)

  00132	b0 01		 mov	 al, 1
  00134	eb 02		 jmp	 SHORT $LN1@CheckWalk
$LN6@CheckWalk:

; 1686 : //		}
; 1687 : 	}
; 1688 : 
; 1689 : 	return false;

  00136	32 c0		 xor	 al, al
$LN1@CheckWalk:

; 1690 : }

  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 0c 00	 ret	 12			; 0000000cH
?CheckWalk@CBloodCastle@@QAE_NHHH@Z ENDP		; CBloodCastle::CheckWalk
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckQuestItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv79 = -84						; size = 4
tv66 = -84						; size = 4
tv80 = -80						; size = 4
tv67 = -80						; size = 4
_x$1 = -12						; size = 4
_iITEM_LEVEL$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckQuestItem, COMDAT
; _this$ = ecx

; 1621 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1622 : 	INT iITEM_LEVEL = -1;

  0000c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], -1

; 1623 : 
; 1624 : 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  00013	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00017	7d 09		 jge	 SHORT $LN18@CheckQuest
  00019	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00020	eb 1f		 jmp	 SHORT $LN19@CheckQuest
$LN18@CheckQuest:
  00022	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00029	7e 09		 jle	 SHORT $LN16@CheckQuest
  0002b	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN17@CheckQuest
$LN16@CheckQuest:
  00034	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN17@CheckQuest:
  0003b	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  0003e	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN19@CheckQuest:
  00041	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  00045	75 08		 jne	 SHORT $LN5@CheckQuest

; 1625 : 		return -1;

  00047	83 c8 ff	 or	 eax, -1
  0004a	e9 c8 01 00 00	 jmp	 $LN1@CheckQuest
$LN5@CheckQuest:

; 1626 : 
; 1627 : 	if (!CHECK_BLOODCASTLE(gObj[iIndex].MapNumber))

  0004f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00064	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00067	7d 09		 jge	 SHORT $LN22@CheckQuest
  00069	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00070	eb 30		 jmp	 SHORT $LN23@CheckQuest
$LN22@CheckQuest:
  00072	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007f	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00087	83 fa 11	 cmp	 edx, 17			; 00000011H
  0008a	7e 09		 jle	 SHORT $LN20@CheckQuest
  0008c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00093	eb 07		 jmp	 SHORT $LN21@CheckQuest
$LN20@CheckQuest:
  00095	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN21@CheckQuest:
  0009c	8b 45 ac	 mov	 eax, DWORD PTR tv79[ebp]
  0009f	89 45 b0	 mov	 DWORD PTR tv80[ebp], eax
$LN23@CheckQuest:
  000a2	83 7d b0 00	 cmp	 DWORD PTR tv80[ebp], 0
  000a6	75 08		 jne	 SHORT $LN6@CheckQuest

; 1628 : 		return -1;

  000a8	83 c8 ff	 or	 eax, -1
  000ab	e9 67 01 00 00	 jmp	 $LN1@CheckQuest
$LN6@CheckQuest:

; 1629 : 
; 1630 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 1631 : 	int iBridgeIndex = GetBridgeIndexByMapNum( gObj[iIndex].MapNumber );	
; 1632 : 	if (m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == -1)
; 1633 : #else
; 1634 : 	if (m_BridgeData[gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1].m_nBC_QUESTITEM_SERIAL == -1)

  000b0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bd	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000c5	83 ea 0b	 sub	 edx, 11			; 0000000bH
  000c8	69 c2 04 02 00
	00		 imul	 eax, edx, 516
  000ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	83 bc 01 90 01
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+400], -1
  000d9	75 08		 jne	 SHORT $LN7@CheckQuest

; 1635 : #endif
; 1636 : 		return -1;

  000db	83 c8 ff	 or	 eax, -1
  000de	e9 34 01 00 00	 jmp	 $LN1@CheckQuest
$LN7@CheckQuest:

; 1637 : 
; 1638 : 	if ((gObj[iIndex].Type != OBJTYPE_CHARACTER) || (gObj[iIndex].Connected <= 2))

  000e3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f0	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000f5	83 fa 01	 cmp	 edx, 1
  000f8	75 14		 jne	 SHORT $LN9@CheckQuest
  000fa	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00101	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00107	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0010c	7f 08		 jg	 SHORT $LN8@CheckQuest
$LN9@CheckQuest:

; 1639 : 		return -1;

  0010e	83 c8 ff	 or	 eax, -1
  00111	e9 01 01 00 00	 jmp	 $LN1@CheckQuest
$LN8@CheckQuest:

; 1640 : 
; 1641 : 	for(int x=0; x<MAX_INVENTORY; x++)

  00116	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 0
  0011d	eb 09		 jmp	 SHORT $LN4@CheckQuest
$LN2@CheckQuest:
  0011f	8b 45 f4	 mov	 eax, DWORD PTR _x$1[ebp]
  00122	83 c0 01	 add	 eax, 1
  00125	89 45 f4	 mov	 DWORD PTR _x$1[ebp], eax
$LN4@CheckQuest:
  00128	83 7d f4 4c	 cmp	 DWORD PTR _x$1[ebp], 76	; 0000004cH
  0012c	0f 8d e2 00 00
	00		 jge	 $LN3@CheckQuest

; 1642 : 	{
; 1643 : 		if( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00132	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00139	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  00140	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00146	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0014d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00152	83 f8 01	 cmp	 eax, 1
  00155	0f 85 b4 00 00
	00		 jne	 $LN10@CheckQuest

; 1644 : 		{
; 1645 : 			if( gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(13, 19) )		//   

  0015b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00162	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  00169	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016f	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00176	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0017b	6a 13		 push	 19			; 00000013H
  0017d	6a 0d		 push	 13			; 0000000dH
  0017f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00184	83 c4 08	 add	 esp, 8
  00187	3b f0		 cmp	 esi, eax
  00189	0f 85 80 00 00
	00		 jne	 $LN10@CheckQuest

; 1646 : 			{
; 1647 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 1648 : 				if (gObj[iIndex].pInventory[x].m_Number == m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL) {
; 1649 : #else
; 1650 : 				if (gObj[iIndex].pInventory[x].m_Number == m_BridgeData[gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1].m_nBC_QUESTITEM_SERIAL) {

  0018f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00196	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  0019d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a3	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  001aa	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  001b1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b7	0f b6 94 16 09
	01 00 00	 movzx	 edx, BYTE PTR [esi+edx+265]
  001bf	83 ea 0b	 sub	 edx, 11			; 0000000bH
  001c2	69 d2 04 02 00
	00		 imul	 edx, edx, 516
  001c8	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  001cb	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  001ce	3b 84 16 90 01
	00 00		 cmp	 eax, DWORD PTR [esi+edx+400]
  001d5	75 38		 jne	 SHORT $LN10@CheckQuest

; 1651 : #endif
; 1652 : 					//    
; 1653 : 					iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;			//   .

  001d7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001de	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  001e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001eb	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  001f2	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  001f7	89 4d f8	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], ecx

; 1654 : 
; 1655 : 					if ((iITEM_LEVEL < 0) || (iITEM_LEVEL > 2))

  001fa	83 7d f8 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  001fe	7c 06		 jl	 SHORT $LN14@CheckQuest
  00200	83 7d f8 02	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 2
  00204	7e 07		 jle	 SHORT $LN13@CheckQuest
$LN14@CheckQuest:

; 1656 : 						iITEM_LEVEL = -1;

  00206	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], -1
$LN13@CheckQuest:

; 1657 : 
; 1658 : 					break;

  0020d	eb 05		 jmp	 SHORT $LN3@CheckQuest
$LN10@CheckQuest:

; 1659 : 				}
; 1660 : 			}
; 1661 : 		}
; 1662 : 	}

  0020f	e9 0b ff ff ff	 jmp	 $LN2@CheckQuest
$LN3@CheckQuest:

; 1663 : 
; 1664 : 	return iITEM_LEVEL;

  00214	8b 45 f8	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
$LN1@CheckQuest:

; 1665 : }

  00217	5f		 pop	 edi
  00218	5e		 pop	 esi
  00219	5b		 pop	 ebx
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c2 04 00	 ret	 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckQuestItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckEnterItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv140 = -84						; size = 4
tv66 = -84						; size = 4
tv141 = -80						; size = 4
tv67 = -80						; size = 4
_x$1 = -12						; size = 4
_iITEM_LEVEL$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckEnterItem, COMDAT
; _this$ = ecx

; 1581 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1582 : 	INT iITEM_LEVEL = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0

; 1583 : 
; 1584 : 	if(!CHECK_LIMIT( iIndex, MAX_OBJECT ) )

  00013	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00017	7d 09		 jge	 SHORT $LN15@CheckEnter
  00019	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00020	eb 1f		 jmp	 SHORT $LN16@CheckEnter
$LN15@CheckEnter:
  00022	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00029	7e 09		 jle	 SHORT $LN13@CheckEnter
  0002b	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN14@CheckEnter
$LN13@CheckEnter:
  00034	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN14@CheckEnter:
  0003b	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  0003e	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN16@CheckEnter:
  00041	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  00045	75 07		 jne	 SHORT $LN5@CheckEnter

; 1585 : 		return 0;

  00047	33 c0		 xor	 eax, eax
  00049	e9 15 01 00 00	 jmp	 $LN1@CheckEnter
$LN5@CheckEnter:

; 1586 : 
; 1587 : 	if ((gObj[iIndex].Type != OBJTYPE_CHARACTER) || (gObj[iIndex].Connected <= 2))

  0004e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005b	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00060	83 fa 01	 cmp	 edx, 1
  00063	75 14		 jne	 SHORT $LN7@CheckEnter
  00065	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0006c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00072	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00077	7f 07		 jg	 SHORT $LN6@CheckEnter
$LN7@CheckEnter:

; 1588 : 		return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 e3 00 00 00	 jmp	 $LN1@CheckEnter
$LN6@CheckEnter:

; 1589 : 
; 1590 : 	for(int x=0; x<MAX_INVENTORY; x++)

  00080	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 0
  00087	eb 09		 jmp	 SHORT $LN4@CheckEnter
$LN2@CheckEnter:
  00089	8b 45 f4	 mov	 eax, DWORD PTR _x$1[ebp]
  0008c	83 c0 01	 add	 eax, 1
  0008f	89 45 f4	 mov	 DWORD PTR _x$1[ebp], eax
$LN4@CheckEnter:
  00092	83 7d f4 4c	 cmp	 DWORD PTR _x$1[ebp], 76	; 0000004cH
  00096	0f 8d c4 00 00
	00		 jge	 $LN3@CheckEnter

; 1591 : 	{
; 1592 : 		if( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  0009c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000a3	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  000aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b0	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  000b7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000bc	83 f8 01	 cmp	 eax, 1
  000bf	0f 85 96 00 00
	00		 jne	 $LN8@CheckEnter

; 1593 : 		{
; 1594 : 			if( gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(13, 18) )		//  

  000c5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000cc	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  000d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d9	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  000e0	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  000e5	6a 12		 push	 18			; 00000012H
  000e7	6a 0d		 push	 13			; 0000000dH
  000e9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ee	83 c4 08	 add	 esp, 8
  000f1	3b f0		 cmp	 esi, eax
  000f3	75 66		 jne	 SHORT $LN8@CheckEnter

; 1595 : 			{
; 1596 : 				iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;				//   .

  000f5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000fc	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$1[ebp], 168
  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00109	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00110	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  00115	89 4d f8	 mov	 DWORD PTR _iITEM_LEVEL$[ebp], ecx

; 1597 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 8  .
; 1598 : 				if (!CHECK_LIMIT(iITEM_LEVEL, MAX_BLOODCASTLE_BRIDGE_COUNT+1))
; 1599 : #else
; 1600 : 				if (!CHECK_LIMIT(iITEM_LEVEL, 8))

  00118	83 7d f8 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  0011c	7d 09		 jge	 SHORT $LN19@CheckEnter
  0011e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
  00125	eb 1c		 jmp	 SHORT $LN20@CheckEnter
$LN19@CheckEnter:
  00127	83 7d f8 07	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 7
  0012b	7e 09		 jle	 SHORT $LN17@CheckEnter
  0012d	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
  00134	eb 07		 jmp	 SHORT $LN18@CheckEnter
$LN17@CheckEnter:
  00136	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv140[ebp], 1
$LN18@CheckEnter:
  0013d	8b 45 ac	 mov	 eax, DWORD PTR tv140[ebp]
  00140	89 45 b0	 mov	 DWORD PTR tv141[ebp], eax
$LN20@CheckEnter:
  00143	83 7d b0 00	 cmp	 DWORD PTR tv141[ebp], 0
  00147	75 07		 jne	 SHORT $LN10@CheckEnter

; 1601 : #endif
; 1602 : 					iITEM_LEVEL = 0;

  00149	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iITEM_LEVEL$[ebp], 0
$LN10@CheckEnter:

; 1603 : 
; 1604 : 				if (iITEM_LEVEL)	return iITEM_LEVEL;

  00150	83 7d f8 00	 cmp	 DWORD PTR _iITEM_LEVEL$[ebp], 0
  00154	74 05		 je	 SHORT $LN8@CheckEnter
  00156	8b 45 f8	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
  00159	eb 08		 jmp	 SHORT $LN1@CheckEnter
$LN8@CheckEnter:

; 1605 : 			}
; 1606 : #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 1607 : 			//     
; 1608 : 			if( gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM( 13, 47 ) )
; 1609 : 			{
; 1610 : 				iITEM_LEVEL = 10;
; 1611 : 			}
; 1612 : #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 1613 : 		}
; 1614 : 	}

  0015b	e9 29 ff ff ff	 jmp	 $LN2@CheckEnter
$LN3@CheckEnter:

; 1615 : 
; 1616 : 	return iITEM_LEVEL;

  00160	8b 45 f8	 mov	 eax, DWORD PTR _iITEM_LEVEL$[ebp]
$LN1@CheckEnter:

; 1617 : }

  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5b		 pop	 ebx
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c2 04 00	 ret	 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckEnterItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CheckEnterLevel, COMDAT
; _this$ = ecx

; 1215 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1216 : 	if(!CHECK_LIMIT( iIndex, MAX_OBJECT ) )

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN21@CheckEnter
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN22@CheckEnter
$LN21@CheckEnter:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN19@CheckEnter
  00024	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN20@CheckEnter
$LN19@CheckEnter:
  0002d	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN20@CheckEnter:
  00034	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN22@CheckEnter:
  0003a	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 0a		 jne	 SHORT $LN2@CheckEnter

; 1217 : 		return 2;

  00040	b8 02 00 00 00	 mov	 eax, 2
  00045	e9 d8 01 00 00	 jmp	 $LN1@CheckEnter
$LN2@CheckEnter:

; 1218 : 
; 1219 : 	if ((gObj[iIndex].Type != OBJTYPE_CHARACTER) || (gObj[iIndex].Connected <= 2))

  0004a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00057	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0005c	83 fa 01	 cmp	 edx, 1
  0005f	75 14		 jne	 SHORT $LN4@CheckEnter
  00061	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006e	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00073	7f 0a		 jg	 SHORT $LN3@CheckEnter
$LN4@CheckEnter:

; 1220 : 		return 2;

  00075	b8 02 00 00 00	 mov	 eax, 2
  0007a	e9 a3 01 00 00	 jmp	 $LN1@CheckEnter
$LN3@CheckEnter:

; 1221 : 
; 1222 : #ifdef USER_ENTER_BLOODCASTLE7_WITH6_20040330
; 1223 : #ifdef DARKLORD_WORK
; 1224 : 	if (gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA) {
; 1225 : #else
; 1226 : 	if (gObj[iIndex].Class == CLASS_MAGUMSA) {
; 1227 : #endif
; 1228 : 		if (iLevel == 6) {	//   6
; 1229 : 			if ( (gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel].iLOWER_BOUND_MAGUMSA) && (gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel].iUPPER_BOUND_MAGUMSA)) {
; 1230 : 				//  7    .
; 1231 : 				return 0;
; 1232 : 			}
; 1233 : 		}
; 1234 : 	}
; 1235 : 	else {
; 1236 : 		if (iLevel == 6) {	//   6
; 1237 : 			if ( (gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel].iLOWER_BOUND) && (gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel].iUPPER_BOUND)) {
; 1238 : 				//  7    .
; 1239 : 				return 0;
; 1240 : 			}
; 1241 : 		}
; 1242 : 	}
; 1243 : #endif
; 1244 : 
; 1245 : #ifdef DARKLORD_WORK
; 1246 : 	if (gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA) {

  0007f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00086	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008c	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00094	83 fa 04	 cmp	 edx, 4
  00097	74 1e		 je	 SHORT $LN7@CheckEnter
  00099	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a6	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  000ae	83 fa 03	 cmp	 edx, 3
  000b1	0f 85 ba 00 00
	00		 jne	 $LN5@CheckEnter
$LN7@CheckEnter:

; 1247 : #else
; 1248 : 	if (gObj[iIndex].Class == CLASS_MAGUMSA) {
; 1249 : #endif
; 1250 : 		if ( (gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA) && (gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA))

  000b7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c4	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  000cc	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  000cf	83 e8 01	 sub	 eax, 1
  000d2	c1 e0 04	 shl	 eax, 4
  000d5	3b 90 08 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax+8]
  000db	7c 2f		 jl	 SHORT $LN8@CheckEnter
  000dd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ea	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  000f2	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  000f5	83 e8 01	 sub	 eax, 1
  000f8	c1 e0 04	 shl	 eax, 4
  000fb	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax+12]
  00101	7f 09		 jg	 SHORT $LN8@CheckEnter

; 1251 : 			return 0;		// .

  00103	33 c0		 xor	 eax, eax
  00105	e9 18 01 00 00	 jmp	 $LN1@CheckEnter
  0010a	eb 60		 jmp	 SHORT $LN9@CheckEnter
$LN8@CheckEnter:

; 1252 : 		else if (gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA)

  0010c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00119	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00121	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00124	83 e8 01	 sub	 eax, 1
  00127	c1 e0 04	 shl	 eax, 4
  0012a	3b 90 08 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax+8]
  00130	7d 0a		 jge	 SHORT $LN10@CheckEnter

; 1253 : 			return -1;		//   .

  00132	83 c8 ff	 or	 eax, -1
  00135	e9 e8 00 00 00	 jmp	 $LN1@CheckEnter
  0013a	eb 30		 jmp	 SHORT $LN9@CheckEnter
$LN10@CheckEnter:

; 1254 : 		else if (gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA)

  0013c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00149	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00151	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00154	83 e8 01	 sub	 eax, 1
  00157	c1 e0 04	 shl	 eax, 4
  0015a	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax+12]
  00160	7e 0a		 jle	 SHORT $LN9@CheckEnter

; 1255 : 			return 1;		//   .

  00162	b8 01 00 00 00	 mov	 eax, 1
  00167	e9 b6 00 00 00	 jmp	 $LN1@CheckEnter
$LN9@CheckEnter:

; 1256 : 	}

  0016c	e9 ac 00 00 00	 jmp	 $LN6@CheckEnter
$LN5@CheckEnter:

; 1257 : 	else {
; 1258 : 		if ( (gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND) && (gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND))

  00171	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00178	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017e	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00186	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00189	83 e8 01	 sub	 eax, 1
  0018c	c1 e0 04	 shl	 eax, 4
  0018f	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax]
  00195	7c 2c		 jl	 SHORT $LN13@CheckEnter
  00197	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0019e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a4	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  001ac	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  001af	83 e8 01	 sub	 eax, 1
  001b2	c1 e0 04	 shl	 eax, 4
  001b5	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax+4]
  001bb	7f 06		 jg	 SHORT $LN13@CheckEnter

; 1259 : 			return 0;		// .

  001bd	33 c0		 xor	 eax, eax
  001bf	eb 61		 jmp	 SHORT $LN1@CheckEnter
  001c1	eb 5a		 jmp	 SHORT $LN6@CheckEnter
$LN13@CheckEnter:

; 1260 : 		else if (gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND)

  001c3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d0	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  001d8	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  001db	83 e8 01	 sub	 eax, 1
  001de	c1 e0 04	 shl	 eax, 4
  001e1	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax]
  001e7	7d 07		 jge	 SHORT $LN15@CheckEnter

; 1261 : 			return -1;		//   .

  001e9	83 c8 ff	 or	 eax, -1
  001ec	eb 34		 jmp	 SHORT $LN1@CheckEnter
  001ee	eb 2d		 jmp	 SHORT $LN6@CheckEnter
$LN15@CheckEnter:

; 1262 : 		else if (gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND)

  001f0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001fd	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00205	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00208	83 e8 01	 sub	 eax, 1
  0020b	c1 e0 04	 shl	 eax, 4
  0020e	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax+4]
  00214	7e 07		 jle	 SHORT $LN6@CheckEnter

; 1263 : 			return 1;		//   .

  00216	b8 01 00 00 00	 mov	 eax, 1
  0021b	eb 05		 jmp	 SHORT $LN1@CheckEnter
$LN6@CheckEnter:

; 1264 : 	}
; 1265 : 
; 1266 : 	return 2;

  0021d	b8 02 00 00 00	 mov	 eax, 2
$LN1@CheckEnter:

; 1267 : }

  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx
  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c2 08 00	 ret	 8
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CheckEnterLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentRemainSec, COMDAT
; _this$ = ecx

; 1209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1210 : 	return m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  0000c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  0001d	99		 cdq
  0001e	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00023	f7 f9		 idiv	 ecx

; 1211 : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentRemainSec
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GetRemainTime@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv79 = -88						; size = 4
_ltime$1 = -20						; size = 8
_today$2 = -12						; size = 4
_iREMAIN_MINUTE$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetRemainTime@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetRemainTime, COMDAT
; _this$ = ecx

; 1855 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1856 : 	INT iREMAIN_MINUTE = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0

; 1857 : 
; 1858 : 	if (this->GetCurrentState(iBridgeIndex) == BLOODCASTLE_STATE_CLOSED) {

  00013	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  0001f	83 f8 01	 cmp	 eax, 1
  00022	75 2d		 jne	 SHORT $LN4@GetRemainT

; 1859 : 		iREMAIN_MINUTE = (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / (60 * 1000) - m_iBC_TIME_MIN_OPEN) + 1;

  00024	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00035	99		 cdq
  00036	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  0003b	f7 f9		 idiv	 ecx
  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	2b 82 24 0e 00
	00		 sub	 eax, DWORD PTR [edx+3620]
  00046	83 c0 01	 add	 eax, 1
  00049	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 1860 : 	}

  0004c	e9 29 01 00 00	 jmp	 $LN5@GetRemainT
$LN4@GetRemainT:

; 1861 : 	else {
; 1862 : 		struct tm * today;
; 1863 : 		time_t ltime;
; 1864 : 
; 1865 : 		time( &ltime );

  00051	8d 45 ec	 lea	 eax, DWORD PTR _ltime$1[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _time
  0005a	83 c4 04	 add	 esp, 4

; 1866 : 		today = localtime( &ltime );

  0005d	8d 45 ec	 lea	 eax, DWORD PTR _ltime$1[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _localtime
  00066	83 c4 04	 add	 esp, 4
  00069	89 45 f4	 mov	 DWORD PTR _today$2[ebp], eax

; 1867 : 
; 1868 : 		switch(g_iBloodCastle_StartHour) {

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_iBloodCastle_StartHour@@3HA ; g_iBloodCastle_StartHour
  00071	89 45 a8	 mov	 DWORD PTR tv79[ebp], eax
  00074	83 7d a8 02	 cmp	 DWORD PTR tv79[ebp], 2
  00078	74 05		 je	 SHORT $LN6@GetRemainT
  0007a	e9 9a 00 00 00	 jmp	 $LN12@GetRemainT
$LN6@GetRemainT:

; 1869 : 		case 2 :	// 2   30
; 1870 : 			{
; 1871 : #ifdef MODIFY_BLOODECASTLE_SCADULE_BUGFIX_20070710
; 1872 : 				if( (today->tm_hour%2) == g_iBloodCastle_odd_Even_Hour)
; 1873 : #else
; 1874 : 				if( !(today->tm_hour%2) )

  0007f	8b 45 f4	 mov	 eax, DWORD PTR _today$2[ebp]
  00082	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00085	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  0008b	79 05		 jns	 SHORT $LN17@GetRemainT
  0008d	49		 dec	 ecx
  0008e	83 c9 fe	 or	 ecx, -2			; fffffffeH
  00091	41		 inc	 ecx
$LN17@GetRemainT:
  00092	85 c9		 test	 ecx, ecx
  00094	75 54		 jne	 SHORT $LN7@GetRemainT

; 1875 : #endif	
; 1876 : 				{
; 1877 : 					// 
; 1878 : 					if ((today->tm_min * 60 + today->tm_sec) >= 30 * 60) {

  00096	8b 45 f4	 mov	 eax, DWORD PTR _today$2[ebp]
  00099	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  0009d	8b 55 f4	 mov	 edx, DWORD PTR _today$2[ebp]
  000a0	03 0a		 add	 ecx, DWORD PTR [edx]
  000a2	81 f9 08 07 00
	00		 cmp	 ecx, 1800		; 00000708H
  000a8	7c 20		 jl	 SHORT $LN9@GetRemainT

; 1879 : 						// 30  -> 2  30 
; 1880 : 						iREMAIN_MINUTE = (((60*2 + 30) * 60) - (today->tm_min * 60 + today->tm_sec)) / 60;

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _today$2[ebp]
  000ad	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  000b1	8b 55 f4	 mov	 edx, DWORD PTR _today$2[ebp]
  000b4	03 0a		 add	 ecx, DWORD PTR [edx]
  000b6	b8 28 23 00 00	 mov	 eax, 9000		; 00002328H
  000bb	2b c1		 sub	 eax, ecx
  000bd	99		 cdq
  000be	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000c3	f7 f9		 idiv	 ecx
  000c5	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 1881 : 					}

  000c8	eb 1e		 jmp	 SHORT $LN10@GetRemainT
$LN9@GetRemainT:

; 1882 : 					else {
; 1883 : 						// 30   -> 
; 1884 : 						iREMAIN_MINUTE  = ((30*60) - (today->tm_min * 60 + today->tm_sec)) / 60;

  000ca	8b 45 f4	 mov	 eax, DWORD PTR _today$2[ebp]
  000cd	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  000d1	8b 55 f4	 mov	 edx, DWORD PTR _today$2[ebp]
  000d4	03 0a		 add	 ecx, DWORD PTR [edx]
  000d6	b8 08 07 00 00	 mov	 eax, 1800		; 00000708H
  000db	2b c1		 sub	 eax, ecx
  000dd	99		 cdq
  000de	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000e3	f7 f9		 idiv	 ecx
  000e5	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN10@GetRemainT:

; 1885 : 					}
; 1886 : 				}

  000e8	eb 1e		 jmp	 SHORT $LN8@GetRemainT
$LN7@GetRemainT:

; 1887 : 				else
; 1888 : 				{
; 1889 : 					//  
; 1890 : 					iREMAIN_MINUTE = ((30*60) - (today->tm_min * 60 + today->tm_sec)) / 60;

  000ea	8b 45 f4	 mov	 eax, DWORD PTR _today$2[ebp]
  000ed	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  000f1	8b 55 f4	 mov	 edx, DWORD PTR _today$2[ebp]
  000f4	03 0a		 add	 ecx, DWORD PTR [edx]
  000f6	b8 08 07 00 00	 mov	 eax, 1800		; 00000708H
  000fb	2b c1		 sub	 eax, ecx
  000fd	99		 cdq
  000fe	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00103	f7 f9		 idiv	 ecx
  00105	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN8@GetRemainT:

; 1891 : 				}
; 1892 : 
; 1893 : 				if( iREMAIN_MINUTE < 0 )

  00108	83 7d f8 00	 cmp	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0
  0010c	7d 09		 jge	 SHORT $LN11@GetRemainT

; 1894 : 				{
; 1895 : 					iREMAIN_MINUTE += 60;

  0010e	8b 45 f8	 mov	 eax, DWORD PTR _iREMAIN_MINUTE$[ebp]
  00111	83 c0 3c	 add	 eax, 60			; 0000003cH
  00114	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN11@GetRemainT:

; 1896 : 				}
; 1897 : 			}
; 1898 : 			break;

  00117	eb 61		 jmp	 SHORT $LN5@GetRemainT
$LN12@GetRemainT:

; 1899 : 		case 1 :	// 1  30
; 1900 : 		default:
; 1901 : 			{
; 1902 : 				if ((today->tm_min * 60 + today->tm_sec) >= 30 * 60) {

  00119	8b 45 f4	 mov	 eax, DWORD PTR _today$2[ebp]
  0011c	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  00120	8b 55 f4	 mov	 edx, DWORD PTR _today$2[ebp]
  00123	03 0a		 add	 ecx, DWORD PTR [edx]
  00125	81 f9 08 07 00
	00		 cmp	 ecx, 1800		; 00000708H
  0012b	7c 20		 jl	 SHORT $LN13@GetRemainT

; 1903 : 					//  30  -> 1  30 
; 1904 : 					iREMAIN_MINUTE = ((60*60) + (30*60) - (today->tm_min * 60 + today->tm_sec)) / 60;

  0012d	8b 45 f4	 mov	 eax, DWORD PTR _today$2[ebp]
  00130	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  00134	8b 55 f4	 mov	 edx, DWORD PTR _today$2[ebp]
  00137	03 0a		 add	 ecx, DWORD PTR [edx]
  00139	b8 18 15 00 00	 mov	 eax, 5400		; 00001518H
  0013e	2b c1		 sub	 eax, ecx
  00140	99		 cdq
  00141	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00146	f7 f9		 idiv	 ecx
  00148	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax

; 1905 : 				}

  0014b	eb 1e		 jmp	 SHORT $LN14@GetRemainT
$LN13@GetRemainT:

; 1906 : 				else {
; 1907 : 					//  30   -> 
; 1908 : 					iREMAIN_MINUTE = ((30*60) - (today->tm_min * 60 + today->tm_sec)) / 60;

  0014d	8b 45 f4	 mov	 eax, DWORD PTR _today$2[ebp]
  00150	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  00154	8b 55 f4	 mov	 edx, DWORD PTR _today$2[ebp]
  00157	03 0a		 add	 ecx, DWORD PTR [edx]
  00159	b8 08 07 00 00	 mov	 eax, 1800		; 00000708H
  0015e	2b c1		 sub	 eax, ecx
  00160	99		 cdq
  00161	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00166	f7 f9		 idiv	 ecx
  00168	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN14@GetRemainT:

; 1909 : 				}
; 1910 : 
; 1911 : 				if( iREMAIN_MINUTE < 0 )

  0016b	83 7d f8 00	 cmp	 DWORD PTR _iREMAIN_MINUTE$[ebp], 0
  0016f	7d 09		 jge	 SHORT $LN5@GetRemainT

; 1912 : 				{
; 1913 : 					iREMAIN_MINUTE += 60;

  00171	8b 45 f8	 mov	 eax, DWORD PTR _iREMAIN_MINUTE$[ebp]
  00174	83 c0 3c	 add	 eax, 60			; 0000003cH
  00177	89 45 f8	 mov	 DWORD PTR _iREMAIN_MINUTE$[ebp], eax
$LN5@GetRemainT:

; 1914 : 				}
; 1915 : 			}
; 1916 : 			break;
; 1917 : 		}
; 1918 : 	}
; 1919 : 
; 1920 : 	return iREMAIN_MINUTE;

  0017a	8b 45 f8	 mov	 eax, DWORD PTR _iREMAIN_MINUTE$[ebp]

; 1921 : }

  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 04 00	 ret	 4
?GetRemainTime@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetRemainTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GetCurrentState@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetCurrentState@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentState, COMDAT
; _this$ = ecx

; 1200 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1201 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN6@GetCurrent
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN7@GetCurrent
$LN6@GetCurrent:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN4@GetCurrent
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN5@GetCurrent
$LN4@GetCurrent:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN5@GetCurrent:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@GetCurrent:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN2@GetCurrent

; 1202 : 		return -1;

  0003d	83 c8 ff	 or	 eax, -1
  00040	eb 11		 jmp	 SHORT $LN1@GetCurrent
$LN2@GetCurrent:

; 1203 : 
; 1204 : 	return m_BridgeData[iBridgeIndex].m_iBC_STATE;

  00042	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	8b 84 01 50 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+336]
$LN1@GetCurrent:

; 1205 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?GetCurrentState@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -80						; size = 4
tv67 = -76						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::CheckUsersOnConnect, COMDAT
; _this$ = ecx

; 2457 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2458 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN13@CheckUsers
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN14@CheckUsers
$LN13@CheckUsers:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN11@CheckUsers
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN12@CheckUsers
$LN11@CheckUsers:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN12@CheckUsers:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN14@CheckUsers:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@CheckUsers

; 2459 : 		return;

  0003d	e9 f3 00 00 00	 jmp	 $LN1@CheckUsers
$LN5@CheckUsers:

; 2460 : 	
; 2461 : 	EnterCriticalSection(& m_BridgeData[iBridgeIndex].m_critUserData);

  00042	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00050	52		 push	 edx
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 2462 : 	
; 2463 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00057	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0005e	eb 09		 jmp	 SHORT $LN4@CheckUsers
$LN2@CheckUsers:
  00060	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@CheckUsers:
  00069	83 7d f8 0a	 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  0006d	0f 8d ad 00 00
	00		 jge	 $LN3@CheckUsers

; 2464 : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) {

  00073	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00081	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00085	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  0008a	0f 84 8b 00 00
	00		 je	 $LN6@CheckUsers

; 2465 : 			//       .
; 2466 : 			if (!gObjIsConnected(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex))

  00090	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0009e	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000a2	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000ac	83 c4 04	 add	 esp, 4
  000af	85 c0		 test	 eax, eax
  000b1	75 1c		 jne	 SHORT $LN7@CheckUsers

; 2467 : 			{
; 2468 : 				m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  000b3	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000c1	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000c5	c7 44 02 18 ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+24], -1

; 2469 : 			}

  000cd	eb 4c		 jmp	 SHORT $LN6@CheckUsers
$LN7@CheckUsers:

; 2470 : 			else {
; 2471 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2472 : 				if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber != GetMapNumByBCBridge( iBridgeIndex ) ) {
; 2473 : #else
; 2474 : 				if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber != MAP_INDEX_BLOODCASTLE1 + iBridgeIndex) {

  000cf	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000dd	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000e1	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ef	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  000fa	83 c1 0b	 add	 ecx, 11			; 0000000bH
  000fd	3b c1		 cmp	 eax, ecx
  000ff	74 1a		 je	 SHORT $LN6@CheckUsers

; 2475 : #endif
; 2476 : 					m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  00101	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00108	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0010f	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00113	c7 44 02 18 ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+24], -1
$LN6@CheckUsers:

; 2477 : 				}
; 2478 : 			}
; 2479 : 		}
; 2480 : 	}

  0011b	e9 40 ff ff ff	 jmp	 $LN2@CheckUsers
$LN3@CheckUsers:

; 2481 : 
; 2482 : 	LeaveCriticalSection(& m_BridgeData[iBridgeIndex].m_critUserData);

  00120	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00127	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0012e	52		 push	 edx
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN1@CheckUsers:

; 2483 : }

  00135	5f		 pop	 edi
  00136	5e		 pop	 esi
  00137	5b		 pop	 ebx
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c2 04 00	 ret	 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::CheckUsersOnConnect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?LevelUp@CBloodCastle@@QAEHHHH@Z
_TEXT	SEGMENT
tv66 = -88						; size = 4
tv67 = -84						; size = 4
_MaxAddPoint$1 = -16					; size = 2
_AddPoint$2 = -12					; size = 2
_iLEFT_EXP$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iAddExp$ = 12						; size = 4
_iEventType$ = 16					; size = 4
?LevelUp@CBloodCastle@@QAEHHHH@Z PROC			; CBloodCastle::LevelUp, COMDAT
; _this$ = ecx

; 2336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2337 : 	if(!CHECK_LIMIT( iIndex, MAX_OBJECT ) )

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN14@LevelUp
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN15@LevelUp
$LN14@LevelUp:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN12@LevelUp
  00024	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN13@LevelUp
$LN12@LevelUp:
  0002d	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN13@LevelUp:
  00034	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN15@LevelUp:
  0003a	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 07		 jne	 SHORT $LN2@LevelUp

; 2338 : 		return 0;

  00040	33 c0		 xor	 eax, eax
  00042	e9 02 06 00 00	 jmp	 $LN1@LevelUp
$LN2@LevelUp:

; 2339 : 
; 2340 : 	INT iLEFT_EXP = 0;

  00047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iLEFT_EXP$[ebp], 0

; 2341 : 
; 2342 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//  MasterLevelUp 
; 2343 : 	//  .
; 2344 : 	if( g_MasterLevelSystem.MasterLevelUp( &gObj[iIndex], iAddExp, true ) )
; 2345 : 		return 0;
; 2346 : 
; 2347 : 	//    	
; 2348 : 	gObjSetExpPetItem( iIndex, iAddExp );
; 2349 : #endif // MASTER_LEVEL_UP_SYSTEM_20070912	
; 2350 : 
; 2351 : #ifdef MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 2352 : 	LogAddTD("Experience : Map[%d]-(%d,%d) [%s][%s](%d) %uz %d MonsterIndex : %d, EventType : %d", 

  0004e	8b 45 10	 mov	 eax, DWORD PTR _iEventType$[ebp]
  00051	50		 push	 eax
  00052	6a 00		 push	 0
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR _iAddExp$[ebp]
  00057	51		 push	 ecx
  00058	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00064	8b 8c 10 a8 00
	00 00		 mov	 ecx, DWORD PTR [eax+edx+168]
  0006b	51		 push	 ecx
  0006c	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00078	0f bf 8c 10 a0
	00 00 00	 movsx	 ecx, WORD PTR [eax+edx+160]
  00080	51		 push	 ecx
  00081	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008d	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00091	51		 push	 ecx
  00092	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009e	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  000a2	51		 push	 ecx
  000a3	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	0f bf 8c 10 04
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+260]
  000b7	51		 push	 ecx
  000b8	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c4	0f bf 8c 10 04
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+260]
  000cc	51		 push	 ecx
  000cd	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  000d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d9	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  000e1	51		 push	 ecx
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@ECDGNEKE@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CF@
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ed	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2353 : 		gObj[iIndex].MapNumber, gObj[iIndex].X, gObj[iIndex].X,
; 2354 : 		gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].Level, gObj[iIndex].Experience, iAddExp,
; 2355 : 		0, iEventType );
; 2356 : #endif
; 2357 : 	
; 2358 : 	//   MAX_LEVEL .
; 2359 : 	if( gObj[iIndex].Level >= g_GlobalConfig.m_iMaxLevel )

  000f0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fd	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00105	3b 15 c8 00 00
	00		 cmp	 edx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+200
  0010b	7c 33		 jl	 SHORT $LN3@LevelUp

; 2360 : 	{
; 2361 : 		GCServerMsgStringSend(lMsg.Get(1136), gObj[iIndex].m_Index, 1);

  0010d	6a 01		 push	 1
  0010f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011c	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0011f	52		 push	 edx
  00120	68 70 04 00 00	 push	 1136			; 00000470H
  00125	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2362 : 		return 0;

  00139	33 c0		 xor	 eax, eax
  0013b	e9 09 05 00 00	 jmp	 $LN1@LevelUp
$LN3@LevelUp:

; 2363 : 	}
; 2364 : 	
; 2365 : 	if( gObj[iIndex].Experience + iAddExp < gObj[iIndex].NextExp ) {

  00140	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014d	8b 94 01 a8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+168]
  00154	03 55 0c	 add	 edx, DWORD PTR _iAddExp$[ebp]
  00157	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00164	3b 94 01 ac 00
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+172]
  0016b	73 30		 jae	 SHORT $LN4@LevelUp

; 2366 : 		gObj[iIndex].Experience += iAddExp;

  0016d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017a	8b 94 01 a8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+168]
  00181	03 55 0c	 add	 edx, DWORD PTR _iAddExp$[ebp]
  00184	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0018b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00191	89 94 01 a8 00
	00 00		 mov	 DWORD PTR [ecx+eax+168], edx

; 2367 : 	}

  00198	e9 80 04 00 00	 jmp	 $LN5@LevelUp
$LN4@LevelUp:

; 2368 : 	else {
; 2369 : 		iLEFT_EXP = gObj[iIndex].Experience + iAddExp - gObj[iIndex].NextExp;

  0019d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001aa	8b 94 01 a8 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+168]
  001b1	03 55 0c	 add	 edx, DWORD PTR _iAddExp$[ebp]
  001b4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c1	2b 94 01 ac 00
	00 00		 sub	 edx, DWORD PTR [ecx+eax+172]
  001c8	89 55 f8	 mov	 DWORD PTR _iLEFT_EXP$[ebp], edx

; 2370 : 
; 2371 : 		gObj[iIndex].Experience = gObj[iIndex].NextExp;

  001cb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001d2	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  001d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001df	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e5	8b 84 06 ac 00
	00 00		 mov	 eax, DWORD PTR [esi+eax+172]
  001ec	89 84 0a a8 00
	00 00		 mov	 DWORD PTR [edx+ecx+168], eax

; 2372 : 		gObj[iIndex].Level += 1;

  001f3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00200	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00208	83 c2 01	 add	 edx, 1
  0020b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00212	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00218	66 89 94 01 a0
	00 00 00	 mov	 WORD PTR [ecx+eax+160], dx

; 2373 : #ifdef DARKLORD_WORK
; 2374 : 		if (gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA)

  00220	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00227	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0022d	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00235	83 fa 04	 cmp	 edx, 4
  00238	74 1a		 je	 SHORT $LN8@LevelUp
  0023a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00241	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00247	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  0024f	83 fa 03	 cmp	 edx, 3
  00252	75 30		 jne	 SHORT $LN6@LevelUp
$LN8@LevelUp:

; 2375 : #else
; 2376 : 		if(gObj[iIndex].Class == CLASS_MAGUMSA )
; 2377 : #endif
; 2378 :     		gObj[iIndex].LevelUpPoint += g_GlobalConfig.m_iSpecial_Points;

  00254	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00261	8b 94 01 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+164]
  00268	03 15 c0 00 00
	00		 add	 edx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+192
  0026e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00275	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027b	89 94 01 a4 00
	00 00		 mov	 DWORD PTR [ecx+eax+164], edx
  00282	eb 2e		 jmp	 SHORT $LN7@LevelUp
$LN6@LevelUp:

; 2379 : 		else
; 2380 :     		gObj[iIndex].LevelUpPoint += g_GlobalConfig.m_iNormal_Points;

  00284	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0028b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00291	8b 94 01 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+164]
  00298	03 15 bc 00 00
	00		 add	 edx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+188
  0029e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ab	89 94 01 a4 00
	00 00		 mov	 DWORD PTR [ecx+eax+164], edx
$LN7@LevelUp:

; 2381 : 		
; 2382 : #ifdef SECOND_QUEST	
; 2383 : 		if( gObj[iIndex].PlusStatQuestClear )

  002b2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002bf	0f b6 94 01 8c
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+140]
  002c7	85 d2		 test	 edx, edx
  002c9	74 75		 je	 SHORT $LN9@LevelUp

; 2384 : 		{	// +1     
; 2385 : 			gObj[iIndex].LevelUpPoint += g_GlobalConfig.m_iPowerUP_Points;

  002cb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d8	8b 94 01 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+164]
  002df	03 15 c4 00 00
	00		 add	 edx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+196
  002e5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f2	89 94 01 a4 00
	00 00		 mov	 DWORD PTR [ecx+eax+164], edx

; 2386 : 			LogAddTD("[%s][%s] LevelUp PlusStatQuest Clear AddStat %d", gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].LevelUpPoint);

  002f9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00300	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00306	8b 94 01 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+164]
  0030d	52		 push	 edx
  0030e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00315	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0031b	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0031f	52		 push	 edx
  00320	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0032d	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00331	52		 push	 edx
  00332	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5@
  00337	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0033d	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@LevelUp:

; 2387 : 		}
; 2388 : #endif		
; 2389 : 			
; 2390 : 		gObj[iIndex].MaxLife += DCInfo.DefClass[gObj[iIndex].Class].LevelLife;

  00340	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00347	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  0034e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00354	0f b7 8c 0a 9c
	00 00 00	 movzx	 ecx, WORD PTR [edx+ecx+156]
  0035c	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00362	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00368	f3 0f 10 84 01
	c0 00 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+192]
  00371	f3 0f 58 82 10
	00 00 00	 addss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+16]
  00379	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00380	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00385	f3 0f 11 84 10
	c0 00 00 00	 movss	 DWORD PTR [eax+edx+192], xmm0

; 2391 : 
; 2392 : 		if(g_GlobalConfig.m_bLimitLife && gObj[iIndex].MaxLife > g_GlobalConfig.m_iLimitLife)

  0038e	83 3d 48 00 00
	00 00		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+72, 0
  00395	74 41		 je	 SHORT $LN10@LevelUp
  00397	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0039e	f3 0f 2a 05 d0
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+208
  003a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ac	f3 0f 10 8c 01
	c0 00 00 00	 movss	 xmm1, DWORD PTR [ecx+eax+192]
  003b5	0f 2f c8	 comiss	 xmm1, xmm0
  003b8	76 1e		 jbe	 SHORT $LN10@LevelUp

; 2393 : 			gObj[iIndex].MaxLife = g_GlobalConfig.m_iLimitLife;

  003ba	f3 0f 2a 05 d0
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+208
  003c2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  003c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003cf	f3 0f 11 84 01
	c0 00 00 00	 movss	 DWORD PTR [ecx+eax+192], xmm0
$LN10@LevelUp:

; 2394 : 
; 2395 : 		gObj[iIndex].MaxMana += DCInfo.DefClass[gObj[iIndex].Class].LevelMana;

  003d8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  003df	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  003e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ec	0f b7 8c 0a 9c
	00 00 00	 movzx	 ecx, WORD PTR [edx+ecx+156]
  003f4	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  003fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00400	f3 0f 10 84 01
	d4 00 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+212]
  00409	f3 0f 58 82 1c
	00 00 00	 addss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+28]
  00411	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00418	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0041d	f3 0f 11 84 10
	d4 00 00 00	 movss	 DWORD PTR [eax+edx+212], xmm0

; 2396 : 		gObj[iIndex].Life = gObj[iIndex].MaxLife;

  00426	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0042d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00434	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0043a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00440	8b 84 06 c0 00
	00 00		 mov	 eax, DWORD PTR [esi+eax+192]
  00447	89 84 0a bc 00
	00 00		 mov	 DWORD PTR [edx+ecx+188], eax

; 2397 : 		gObj[iIndex].Mana = gObj[iIndex].MaxMana;	

  0044e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00455	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  0045c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00462	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00468	8b 84 06 d4 00
	00 00		 mov	 eax, DWORD PTR [esi+eax+212]
  0046f	89 84 0a d0 00
	00 00		 mov	 DWORD PTR [edx+ecx+208], eax

; 2398 : 		gObjNextExpCal(&gObj[iIndex]);

  00476	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0047d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00483	50		 push	 eax
  00484	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAVOBJECTSTRUCT@@@Z ; gObjNextExpCal
  00489	83 c4 04	 add	 esp, 4

; 2399 : 
; 2400 : #ifdef NEW_FORSKYLAND2
; 2401 : 		gObjSetBP(gObj[iIndex].m_Index);

  0048c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00493	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00499	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0049c	52		 push	 edx
  0049d	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  004a2	83 c4 04	 add	 esp, 4

; 2402 : #endif
; 2403 : 	
; 2404 : 
; 2405 : #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 2406 : 		GCLevelUpMsgSend(gObj[iIndex].m_Index);
; 2407 : #else
; 2408 : 		short AddPoint		= 0;

  004a5	33 c0		 xor	 eax, eax
  004a7	66 89 45 f4	 mov	 WORD PTR _AddPoint$2[ebp], ax

; 2409 : 		short MaxAddPoint	= 0;

  004ab	33 c0		 xor	 eax, eax
  004ad	66 89 45 f0	 mov	 WORD PTR _MaxAddPoint$1[ebp], ax

; 2410 : 		gObjGetStatPointState(gObj[iIndex].m_Index, AddPoint, MaxAddPoint);

  004b1	8d 45 f0	 lea	 eax, DWORD PTR _MaxAddPoint$1[ebp]
  004b4	50		 push	 eax
  004b5	8d 4d f4	 lea	 ecx, DWORD PTR _AddPoint$2[ebp]
  004b8	51		 push	 ecx
  004b9	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  004c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004c5	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  004c8	51		 push	 ecx
  004c9	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF0@Z ; gObjGetStatPointState
  004ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2411 : 		GCLevelUpMsgSend(gObj[iIndex].m_Index, gObj[iIndex].Level, gObj[iIndex].LevelUpPoint, 

  004d1	0f b7 45 f0	 movzx	 eax, WORD PTR _MaxAddPoint$1[ebp]
  004d5	50		 push	 eax
  004d6	0f b7 4d f4	 movzx	 ecx, WORD PTR _AddPoint$2[ebp]
  004da	51		 push	 ecx
  004db	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  004e2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  004e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ef	8b 94 11 ec 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+236]
  004f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004fc	03 94 01 f0 00
	00 00		 add	 edx, DWORD PTR [ecx+eax+240]
  00503	52		 push	 edx
  00504	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  0050b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00512	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00518	f3 0f 2a 84 01
	10 01 00 00	 cvtsi2ss xmm0, DWORD PTR [ecx+eax+272]
  00521	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00526	f3 0f 58 84 10
	d4 00 00 00	 addss	 xmm0, DWORD PTR [eax+edx+212]
  0052f	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00533	0f b7 d1	 movzx	 edx, cx
  00536	52		 push	 edx
  00537	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0053e	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00545	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0054b	f3 0f 2a 84 0a
	0c 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+268]
  00554	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0055a	f3 0f 58 84 01
	c0 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+192]
  00563	f3 0f 2c d0	 cvttss2si edx, xmm0
  00567	0f b7 c2	 movzx	 eax, dx
  0056a	50		 push	 eax
  0056b	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00572	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00578	0f b7 84 0a a4
	00 00 00	 movzx	 eax, WORD PTR [edx+ecx+164]
  00580	50		 push	 eax
  00581	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00588	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0058e	0f b7 84 0a a0
	00 00 00	 movzx	 eax, WORD PTR [edx+ecx+160]
  00596	50		 push	 eax
  00597	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  0059e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a4	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  005a7	50		 push	 eax
  005a8	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHGGGGGFF@Z ; GCLevelUpMsgSend
  005ad	83 c4 20	 add	 esp, 32			; 00000020H

; 2412 : 						 (WORD)(gObj[iIndex].MaxLife+gObj[iIndex].AddLife), 
; 2413 : 						 (WORD)(gObj[iIndex].MaxMana+gObj[iIndex].AddMana), 
; 2414 : 						 gObj[iIndex].MaxBP+gObj[iIndex].AddBP,
; 2415 : 						 AddPoint, MaxAddPoint);
; 2416 : #endif // ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 2417 : 
; 2418 : 		gObjCalcMaxLifePower(gObj[iIndex].m_Index);	//    

  005b0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  005b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005bd	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  005c0	52		 push	 edx
  005c1	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  005c6	83 c4 04	 add	 esp, 4

; 2419 : 		
; 2420 : 		LogAddTD(lMsg.Get(520), gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].Level);

  005c9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  005d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005d6	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  005de	52		 push	 edx
  005df	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  005e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ec	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  005f0	52		 push	 edx
  005f1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  005f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005fe	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00602	52		 push	 edx
  00603	68 08 02 00 00	 push	 520			; 00000208H
  00608	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0060d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00613	50		 push	 eax
  00614	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0061a	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@LevelUp:

; 2421 : 		
; 2422 : #ifdef ADD_LOG_400LEVELUP_PARTY_20070628	// 400      
; 2423 : 		if(gObj[iIndex].Level == 400 && gObj[iIndex].PartyNumber >=0)
; 2424 : 		{
; 2425 : 			int partynum = gObj[iIndex].PartyNumber;
; 2426 : 			char partyLog[256];
; 2427 : 			int number;
; 2428 : 			sprintf(partyLog, "400 LevelUp (%s)(%s) Party ", gObj[iIndex].AccountID, gObj[iIndex].Name);
; 2429 : 			
; 2430 : 			for( int n=0; n<MAX_PARTYUSER; n++)
; 2431 : 			{
; 2432 : 				number = gParty.m_PartyS[partynum].Number[n];
; 2433 : 				if( number >= 0 )
; 2434 : 				{
; 2435 : 					int noffSet = strlen(partyLog);
; 2436 : 					sprintf(partyLog + noffSet, ",(%s)(%s) ",gObj[number].AccountID, gObj[number].Name);								
; 2437 : 				}
; 2438 : 			}
; 2439 : 			
; 2440 : 			LogAddTD(partyLog);
; 2441 : 		}
; 2442 : #endif
; 2443 : 	}
; 2444 : 
; 2445 : 	//   .
; 2446 : 	GJSetCharacterInfo(&gObj[iIndex], gObj[iIndex].m_Index);

  0061d	6a 00		 push	 0
  0061f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00626	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0062c	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0062f	52		 push	 edx
  00630	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00637	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0063d	50		 push	 eax
  0063e	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  00643	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2447 : 	//LogAdd("   ");
; 2448 : 
; 2449 : 	return iLEFT_EXP;

  00646	8b 45 f8	 mov	 eax, DWORD PTR _iLEFT_EXP$[ebp]
$LN1@LevelUp:

; 2450 : }

  00649	5f		 pop	 edi
  0064a	5e		 pop	 esi
  0064b	5b		 pop	 ebx
  0064c	8b e5		 mov	 esp, ebp
  0064e	5d		 pop	 ebp
  0064f	c2 0c 00	 ret	 12			; 0000000cH
?LevelUp@CBloodCastle@@QAEHHHH@Z ENDP			; CBloodCastle::LevelUp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?EnterUserBridge@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
_i$1 = -12						; size = 4
_iRET_VAL$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?EnterUserBridge@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::EnterUserBridge, COMDAT
; _this$ = ecx

; 2281 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2282 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN12@EnterUserB
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN13@EnterUserB
$LN12@EnterUserB:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN10@EnterUserB
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN11@EnterUserB
$LN10@EnterUserB:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN11@EnterUserB:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN13@EnterUserB:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 08		 jne	 SHORT $LN5@EnterUserB

; 2283 : 		return -1;

  0003d	83 c8 ff	 or	 eax, -1
  00040	e9 35 01 00 00	 jmp	 $LN1@EnterUserB
$LN5@EnterUserB:

; 2284 : 
; 2285 : #ifdef BLOODCASTLE_SENDPOINT_BUGFIX_20040604
; 2286 : 	if (!gObjIsConnected(iUserIndex))
; 2287 : 		return -1;
; 2288 : #endif
; 2289 : 
; 2290 : 	INT iRET_VAL = -1;

  00045	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1

; 2291 : 
; 2292 : 	EnterCriticalSection(& m_BridgeData[iBridgeIndex].m_critUserData);

  0004c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0005a	52		 push	 edx
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 2293 : 	
; 2294 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00061	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00068	eb 09		 jmp	 SHORT $LN4@EnterUserB
$LN2@EnterUserB:
  0006a	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  0006d	83 c0 01	 add	 eax, 1
  00070	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@EnterUserB:
  00073	83 7d f4 0a	 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  00077	0f 8d e5 00 00
	00		 jge	 $LN3@EnterUserB

; 2295 : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) {

  0007d	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0008b	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0008f	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  00094	74 26		 je	 SHORT $LN6@EnterUserB

; 2296 : 			//    .
; 2297 : 			if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iUserIndex) {

  00096	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000a4	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000a8	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  000ac	3b 4d 0c	 cmp	 ecx, DWORD PTR _iUserIndex$[ebp]
  000af	75 0b		 jne	 SHORT $LN6@EnterUserB

; 2298 : 				iRET_VAL = i;

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  000b4	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 2299 : 				break;

  000b7	e9 a6 00 00 00	 jmp	 $LN3@EnterUserB
$LN6@EnterUserB:

; 2300 : 			}
; 2301 : 		}
; 2302 : 
; 2303 : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1) {

  000bc	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000ca	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000ce	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  000d3	0f 85 84 00 00
	00		 jne	 $LN8@EnterUserB

; 2304 : 			iRET_VAL = i;

  000d9	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  000dc	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 2305 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = iUserIndex;

  000df	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000ed	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000f1	8b 4d 0c	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  000f4	89 4c 02 18	 mov	 DWORD PTR [edx+eax+24], ecx

; 2306 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  000f8	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00106	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0010a	c7 44 02 1c 00
	00 00 00	 mov	 DWORD PTR [edx+eax+28], 0

; 2307 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  00112	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00119	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00120	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00124	c7 44 02 20 00
	00 00 00	 mov	 DWORD PTR [edx+eax+32], 0

; 2308 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_ALIVE;

  0012c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00133	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0013a	6b 45 f4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0013e	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0

; 2309 : #ifdef BLOODCASTLE_SENDPOINT_BUGFIX_20040604
; 2310 : 			memcpy (m_BridgeData[iBridgeIndex].m_UserData[i].m_szAccountID, gObj[iUserIndex].AccountID, MAX_IDSTRING);
; 2311 : 			memcpy (m_BridgeData[iBridgeIndex].m_UserData[i].m_szCharName, gObj[iUserIndex].Name, MAX_IDSTRING);
; 2312 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_szAccountID[MAX_IDSTRING] = 0;
; 2313 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_szCharName[MAX_IDSTRING] = 0;
; 2314 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_iCharClass = gObj[iUserIndex].Class;
; 2315 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_iBloodCastleIndex = iBridgeIndex;
; 2316 : 			m_BridgeData[iBridgeIndex].m_UserData[i].m_iBloodCastleSubIndex = i;
; 2317 : #endif
; 2318 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 2319 : 			gObj[iUserIndex].m_bBloodCastleComplete = false;

  00146	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserIndex$[ebp], 7072
  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00153	c6 84 01 d8 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3288], 0

; 2320 : #endif
; 2321 : 			break;

  0015b	eb 05		 jmp	 SHORT $LN3@EnterUserB
$LN8@EnterUserB:

; 2322 : 		}
; 2323 : 	}

  0015d	e9 08 ff ff ff	 jmp	 $LN2@EnterUserB
$LN3@EnterUserB:

; 2324 : 
; 2325 : 	LeaveCriticalSection(& m_BridgeData[iBridgeIndex].m_critUserData);

  00162	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00169	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00170	52		 push	 edx
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 2326 : 	
; 2327 : 	return iRET_VAL;

  00177	8b 45 f8	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
$LN1@EnterUserB:

; 2328 : }

  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5b		 pop	 ebx
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 08 00	 ret	 8
?EnterUserBridge@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::EnterUserBridge
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z
_TEXT	SEGMENT
tv71 = -80						; size = 4
tv66 = -80						; size = 4
tv72 = -76						; size = 4
tv67 = -76						; size = 4
_iRET_VAL$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iBridgeSubIndex$ = 12					; size = 4
_iUserIndex$ = 16					; size = 4
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z PROC		; CBloodCastle::LeaveUserBridge, COMDAT
; _this$ = ecx

; 2255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2256 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN8@LeaveUserB
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN9@LeaveUserB
$LN8@LeaveUserB:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN6@LeaveUserB
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN7@LeaveUserB
$LN6@LeaveUserB:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN7@LeaveUserB:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN9@LeaveUserB:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 08		 jne	 SHORT $LN2@LeaveUserB

; 2257 : 		return -1;

  0003d	83 c8 ff	 or	 eax, -1
  00040	e9 f6 00 00 00	 jmp	 $LN1@LeaveUserB
$LN2@LeaveUserB:

; 2258 : 
; 2259 : 	if (!CHECK_LIMIT(iBridgeSubIndex, MAX_BLOODCASTLE_USER_COUNT))

  00045	83 7d 0c 00	 cmp	 DWORD PTR _iBridgeSubIndex$[ebp], 0
  00049	7d 09		 jge	 SHORT $LN12@LeaveUserB
  0004b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  00052	eb 1c		 jmp	 SHORT $LN13@LeaveUserB
$LN12@LeaveUserB:
  00054	83 7d 0c 09	 cmp	 DWORD PTR _iBridgeSubIndex$[ebp], 9
  00058	7e 09		 jle	 SHORT $LN10@LeaveUserB
  0005a	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00061	eb 07		 jmp	 SHORT $LN11@LeaveUserB
$LN10@LeaveUserB:
  00063	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN11@LeaveUserB:
  0006a	8b 45 b0	 mov	 eax, DWORD PTR tv71[ebp]
  0006d	89 45 b4	 mov	 DWORD PTR tv72[ebp], eax
$LN13@LeaveUserB:
  00070	83 7d b4 00	 cmp	 DWORD PTR tv72[ebp], 0
  00074	75 08		 jne	 SHORT $LN3@LeaveUserB

; 2260 : 		return -1;

  00076	83 c8 ff	 or	 eax, -1
  00079	e9 bd 00 00 00	 jmp	 $LN1@LeaveUserB
$LN3@LeaveUserB:

; 2261 : 
; 2262 : 	INT iRET_VAL = -1;

  0007e	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iRET_VAL$[ebp], -1

; 2263 : 
; 2264 : 	EnterCriticalSection(& m_BridgeData[iBridgeIndex].m_critUserData);

  00085	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00093	52		 push	 edx
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 2265 : 
; 2266 : 	if (m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex == iUserIndex) {

  0009a	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000a8	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  000ac	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  000b0	3b 4d 10	 cmp	 ecx, DWORD PTR _iUserIndex$[ebp]
  000b3	75 6e		 jne	 SHORT $LN4@LeaveUserB

; 2267 : 		iRET_VAL = iUserIndex;

  000b5	8b 45 10	 mov	 eax, DWORD PTR _iUserIndex$[ebp]
  000b8	89 45 f8	 mov	 DWORD PTR _iRET_VAL$[ebp], eax

; 2268 : 		m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex = -1;

  000bb	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000c9	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  000cd	c7 44 02 18 ff
	ff ff ff	 mov	 DWORD PTR [edx+eax+24], -1

; 2269 : 		m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iEXP = 0;

  000d5	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000e3	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  000e7	c7 44 02 1c 00
	00 00 00	 mov	 DWORD PTR [edx+eax+28], 0

; 2270 : 		m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iScore = 0;

  000ef	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000fd	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  00101	c7 44 02 20 00
	00 00 00	 mov	 DWORD PTR [edx+eax+32], 0

; 2271 : 		m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = BC_USER_ALIVE;

  00109	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00110	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00117	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  0011b	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0
$LN4@LeaveUserB:

; 2272 : 	}
; 2273 : 
; 2274 : 	LeaveCriticalSection(& m_BridgeData[iBridgeIndex].m_critUserData);

  00123	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00131	52		 push	 edx
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 2275 : 
; 2276 : 	return iRET_VAL;

  00138	8b 45 f8	 mov	 eax, DWORD PTR _iRET_VAL$[ebp]
$LN1@LeaveUserB:

; 2277 : }

  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 0c 00	 ret	 12			; 0000000cH
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z ENDP		; CBloodCastle::LeaveUserBridge
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetSaintStatue@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv89 = -88						; size = 4
tv66 = -88						; size = 4
tv90 = -84						; size = 4
tv67 = -84						; size = 4
_result$1 = -16						; size = 4
_btBloodCastleIndex$ = -11				; size = 1
_btMapNumber$ = -10					; size = 1
_btMonsterType$ = -9					; size = 1
_nSaintStatuePosNum$ = -8				; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetSaintStatue, COMDAT
; _this$ = ecx

; 2184 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2185 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {		//   

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN10@SetSaintSt
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN11@SetSaintSt
$LN10@SetSaintSt:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN8@SetSaintSt
  00021	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN9@SetSaintSt
$LN8@SetSaintSt:
  0002a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@SetSaintSt:
  00031	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN11@SetSaintSt:
  00037	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN2@SetSaintSt

; 2186 : 		return;

  0003d	e9 23 02 00 00	 jmp	 $LN1@SetSaintSt
$LN2@SetSaintSt:

; 2187 : 	}
; 2188 : 
; 2189 : 	// * .   .
; 2190 : 	int nSaintStatuePosNum = m_BridgeData[iBridgeIndex].m_nSaintStatuePosNum;

  00042	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	8b 94 01 34 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+308]
  00053	89 55 f8	 mov	 DWORD PTR _nSaintStatuePosNum$[ebp], edx

; 2191 : 
; 2192 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//   			
; 2193 : 	WORD btMonsterType = gMSetBase.m_Mp[nSaintStatuePosNum].m_Type;
; 2194 : #else
; 2195 : 	BYTE btMonsterType = gMSetBase.m_Mp[nSaintStatuePosNum].m_Type;

  00056	6b 45 f8 0c	 imul	 eax, DWORD PTR _nSaintStatuePosNum$[ebp], 12
  0005a	8a 88 06 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  00060	88 4d f7	 mov	 BYTE PTR _btMonsterType$[ebp], cl

; 2196 : #endif
; 2197 : 	BYTE btMapNumber = gMSetBase.m_Mp[nSaintStatuePosNum].m_MapNumber;

  00063	6b 45 f8 0c	 imul	 eax, DWORD PTR _nSaintStatuePosNum$[ebp], 12
  00067	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  0006d	88 4d f6	 mov	 BYTE PTR _btMapNumber$[ebp], cl

; 2198 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2199 : 	BYTE btBloodCastleIndex = GetBridgeIndexByMapNum( btMapNumber );
; 2200 : #else
; 2201 : 	BYTE btBloodCastleIndex = btMapNumber - MAP_INDEX_BLOODCASTLE1;

  00070	0f b6 45 f6	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  00074	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00077	88 45 f5	 mov	 BYTE PTR _btBloodCastleIndex$[ebp], al

; 2202 : #endif
; 2203 : 
; 2204 : 	if (nSaintStatuePosNum != -1) {

  0007a	83 7d f8 ff	 cmp	 DWORD PTR _nSaintStatuePosNum$[ebp], -1
  0007e	0f 84 e1 01 00
	00		 je	 $LN5@SetSaintSt

; 2205 : 		if (CHECK_LIMIT(btMonsterType-BC_SAINT_STATUE_1, 3)) {			//     

  00084	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMonsterType$[ebp]
  00088	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  0008d	79 09		 jns	 SHORT $LN14@SetSaintSt
  0008f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
  00096	eb 25		 jmp	 SHORT $LN15@SetSaintSt
$LN14@SetSaintSt:
  00098	0f b6 4d f7	 movzx	 ecx, BYTE PTR _btMonsterType$[ebp]
  0009c	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  000a2	83 f9 02	 cmp	 ecx, 2
  000a5	7e 09		 jle	 SHORT $LN12@SetSaintSt
  000a7	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  000ae	eb 07		 jmp	 SHORT $LN13@SetSaintSt
$LN12@SetSaintSt:
  000b0	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
$LN13@SetSaintSt:
  000b7	8b 55 a8	 mov	 edx, DWORD PTR tv89[ebp]
  000ba	89 55 ac	 mov	 DWORD PTR tv90[ebp], edx
$LN15@SetSaintSt:
  000bd	83 7d ac 00	 cmp	 DWORD PTR tv90[ebp], 0
  000c1	0f 84 70 01 00
	00		 je	 $LN4@SetSaintSt

; 2206 : #ifdef MAP_SERVER_ADD_MONSTER_20041216		//   , NPC  (     .)
; 2207 : 			int result = gObjAddMonster(btMapNumber);

  000c7	0f b6 45 f6	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  000d1	83 c4 04	 add	 esp, 4
  000d4	0f bf c8	 movsx	 ecx, ax
  000d7	89 4d f0	 mov	 DWORD PTR _result$1[ebp], ecx

; 2208 : #else
; 2209 : 			int result = gObjAdd();
; 2210 : #endif
; 2211 : 			if( result >= 0 )

  000da	83 7d f0 00	 cmp	 DWORD PTR _result$1[ebp], 0
  000de	0f 8c 51 01 00
	00		 jl	 $LN6@SetSaintSt

; 2212 : 			{
; 2213 : 				gObjSetPosMonster(result, nSaintStatuePosNum);

  000e4	8b 45 f8	 mov	 eax, DWORD PTR _nSaintStatuePosNum$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d f0	 mov	 ecx, DWORD PTR _result$1[ebp]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  000f1	83 c4 08	 add	 esp, 8

; 2214 : 				gObjSetMonster(result, btMonsterType);

  000f4	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMonsterType$[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d f0	 mov	 ecx, DWORD PTR _result$1[ebp]
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  00102	83 c4 08	 add	 esp, 8

; 2215 : 				
; 2216 : 				gObj[result].Class = BC_SAINT_STATUE_1 + rand()%3;

  00105	e8 00 00 00 00	 call	 _rand
  0010a	99		 cdq
  0010b	b9 03 00 00 00	 mov	 ecx, 3
  00110	f7 f9		 idiv	 ecx
  00112	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  00118	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  0011f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00125	66 89 94 01 9c
	00 00 00	 mov	 WORD PTR [ecx+eax+156], dx

; 2217 : 				gObj[result].m_cBloodCastleIndex	= btBloodCastleIndex;

  0012d	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013a	8a 55 f5	 mov	 dl, BYTE PTR _btBloodCastleIndex$[ebp]
  0013d	88 94 01 d2 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3282], dl

; 2218 : 				gObj[result].m_ItemRate		= m_iBC_NORMAL_ITEM_DROP;

  00144	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  0014b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00151	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00154	66 8b 92 30 0e
	00 00		 mov	 dx, WORD PTR [edx+3632]
  0015b	66 89 94 01 00
	03 00 00	 mov	 WORD PTR [ecx+eax+768], dx

; 2219 : 				gObj[result].Dir			= 1;

  00163	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  0016a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00170	c6 84 01 08 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+264], 1

; 2220 : 				gObj[result].m_PosNum		= -1;

  00178	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  0017f	83 c9 ff	 or	 ecx, -1
  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00188	66 89 8c 02 0c
	02 00 00	 mov	 WORD PTR [edx+eax+524], cx

; 2221 : 				gObj[result].Live			= 1;

  00190	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  00197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019d	c6 44 01 66 01	 mov	 BYTE PTR [ecx+eax+102], 1

; 2222 : 				gObj[result].DieRegen		= 0;

  001a2	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001af	c6 84 01 fe 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+510], 0

; 2223 : 				gObj[result].m_State		= OBJST_CREATE;

  001b7	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  001be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c4	c7 84 01 b8 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+440], 1

; 2224 : 				gObj[result].MaxRegenTime	= 0;

  001cf	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001dc	c7 84 01 08 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+520], 0

; 2225 : 				gObj[result].MaxLife		= m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  001e7	0f b6 45 f5	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  001eb	69 c8 04 02 00
	00		 imul	 ecx, eax, 516
  001f1	69 55 f0 a0 1b
	00 00		 imul	 edx, DWORD PTR _result$1[ebp], 7072
  001f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001fd	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00200	8b 8c 0e 6c 01
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+364]
  00207	89 8c 10 c0 00
	00 00		 mov	 DWORD PTR [eax+edx+192], ecx

; 2226 : 				gObj[result].Life			= m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  0020e	0f b6 45 f5	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  00212	69 c8 04 02 00
	00		 imul	 ecx, eax, 516
  00218	69 55 f0 a0 1b
	00 00		 imul	 edx, DWORD PTR _result$1[ebp], 7072
  0021f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00224	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00227	8b 8c 0e 6c 01
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+364]
  0022e	89 8c 10 bc 00
	00 00		 mov	 DWORD PTR [eax+edx+188], ecx
$LN6@SetSaintSt:

; 2227 : 
; 2228 : #ifdef EXTEND_LOG_SYSTEM_05_20060823
; 2229 : 				LogAddTD("[Blood Castle] (%d) Saint Status be created.", iBridgeIndex+1 );
; 2230 : #endif // EXTEND_LOG_SYSTEM_05_20060823
; 2231 : 			}
; 2232 : 		}

  00235	eb 2e		 jmp	 SHORT $LN5@SetSaintSt
$LN4@SetSaintSt:

; 2233 : 		else {
; 2234 : 			//   . ( )
; 2235 : #ifdef ADD_LOG_CHECK_CAHOSCASTLE_BLOODCASTLE_EVENT_20060314
; 2236 : 			LogAddTD( "[Blood Castle][Bug Tracer] (%d) It's not Saint Statue( Map:%d, BloodCastleIndex:%d, Type:%d )"

  00237	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMonsterType$[ebp]
  0023b	50		 push	 eax
  0023c	6b 4d f8 0c	 imul	 ecx, DWORD PTR _nSaintStatuePosNum$[ebp], 12
  00240	0f b6 91 08 00
	00 00		 movzx	 edx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[ecx+8]
  00247	83 ea 0b	 sub	 edx, 11			; 0000000bH
  0024a	52		 push	 edx
  0024b	0f b6 45 f6	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  0024f	50		 push	 eax
  00250	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00253	83 c1 01	 add	 ecx, 1
  00256	51		 push	 ecx
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00262	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@SetSaintSt:
$LN1@SetSaintSt:

; 2237 : 				, iBridgeIndex + 1
; 2238 : 				, btMapNumber
; 2239 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2240 : 				, GetBridgeIndexByMapNum( btMapNumber )
; 2241 : #else
; 2242 : 				, gMSetBase.m_Mp[nSaintStatuePosNum].m_MapNumber - MAP_INDEX_BLOODCASTLE1
; 2243 : #endif
; 2244 : 				, btMonsterType 
; 2245 : 				);
; 2246 : #endif			
; 2247 : 		}
; 2248 : 	}
; 2249 : }

  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	5b		 pop	 ebx
  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c2 04 00	 ret	 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetSaintStatue
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetBossMonster@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -92						; size = 4
tv67 = -88						; size = 4
_btBloodCastleIndex$1 = -19				; size = 1
_btMapNumber$2 = -18					; size = 1
_btMonsterType$3 = -17					; size = 1
_iBossPosNum$4 = -16					; size = 4
_x$5 = -12						; size = 4
_result$ = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetBossMonster@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetBossMonster, COMDAT
; _this$ = ecx

; 2122 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2123 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {		//   

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN14@SetBossMon
  00012	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN15@SetBossMon
$LN14@SetBossMon:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN12@SetBossMon
  00021	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN13@SetBossMon
$LN12@SetBossMon:
  0002a	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN13@SetBossMon:
  00031	8b 45 a4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN15@SetBossMon:
  00037	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@SetBossMon

; 2124 : 		return;

  0003d	e9 87 01 00 00	 jmp	 $LN1@SetBossMon
$LN5@SetBossMon:

; 2125 : 	}
; 2126 : 
; 2127 : 	// * .  .
; 2128 : 	int result;
; 2129 : 	for (int x = 0 ; x < MAX_BLOODCASTLE_BOSS_COUNT ; x++) {

  00042	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _x$5[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN4@SetBossMon
$LN2@SetBossMon:
  0004b	8b 45 f4	 mov	 eax, DWORD PTR _x$5[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 f4	 mov	 DWORD PTR _x$5[ebp], eax
$LN4@SetBossMon:
  00054	83 7d f4 14	 cmp	 DWORD PTR _x$5[ebp], 20	; 00000014H
  00058	0f 8d 6b 01 00
	00		 jge	 $LN1@SetBossMon

; 2130 : 		if (m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x] != -1) {

  0005e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0006c	8b 45 f4	 mov	 eax, DWORD PTR _x$5[ebp]
  0006f	83 bc 82 e0 00
	00 00 ff	 cmp	 DWORD PTR [edx+eax*4+224], -1
  00077	0f 84 47 01 00
	00		 je	 $LN6@SetBossMon

; 2131 : 			INT iBossPosNum = m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x];

  0007d	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0008b	8b 45 f4	 mov	 eax, DWORD PTR _x$5[ebp]
  0008e	8b 8c 82 e0 00
	00 00		 mov	 ecx, DWORD PTR [edx+eax*4+224]
  00095	89 4d f0	 mov	 DWORD PTR _iBossPosNum$4[ebp], ecx

; 2132 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//   			
; 2133 : 			WORD btMonsterType = gMSetBase.m_Mp[iBossPosNum].m_Type;
; 2134 : #else
; 2135 : 			BYTE btMonsterType = gMSetBase.m_Mp[iBossPosNum].m_Type;

  00098	6b 45 f0 0c	 imul	 eax, DWORD PTR _iBossPosNum$4[ebp], 12
  0009c	8a 88 06 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  000a2	88 4d ef	 mov	 BYTE PTR _btMonsterType$3[ebp], cl

; 2136 : #endif
; 2137 : 			BYTE btMapNumber = gMSetBase.m_Mp[iBossPosNum].m_MapNumber;

  000a5	6b 45 f0 0c	 imul	 eax, DWORD PTR _iBossPosNum$4[ebp], 12
  000a9	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  000af	88 4d ee	 mov	 BYTE PTR _btMapNumber$2[ebp], cl

; 2138 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2139 : 			BYTE btBloodCastleIndex = GetBridgeIndexByMapNum( btMapNumber );
; 2140 : #else
; 2141 : 			BYTE btBloodCastleIndex = btMapNumber - MAP_INDEX_BLOODCASTLE1;

  000b2	0f b6 45 ee	 movzx	 eax, BYTE PTR _btMapNumber$2[ebp]
  000b6	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000b9	88 45 ed	 mov	 BYTE PTR _btBloodCastleIndex$1[ebp], al

; 2142 : #endif
; 2143 : 
; 2144 : 			if (btBloodCastleIndex != iBridgeIndex)				//     					

  000bc	0f b6 45 ed	 movzx	 eax, BYTE PTR _btBloodCastleIndex$1[ebp]
  000c0	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000c3	74 02		 je	 SHORT $LN7@SetBossMon

; 2145 : 				continue;

  000c5	eb 84		 jmp	 SHORT $LN2@SetBossMon
$LN7@SetBossMon:

; 2146 : 
; 2147 : 			//    
; 2148 : 			if ((btMonsterType == 89) ||							// 1						
; 2149 : 				(btMonsterType == 95) ||							// 2
; 2150 : 				(btMonsterType == 112) ||							// 3
; 2151 : 				(btMonsterType == 118) ||							// 4
; 2152 : 				(btMonsterType == 124) ||							// 5
; 2153 : 				(btMonsterType == 130)								// 6
; 2154 : #ifdef BLOODCASTLE_EXTEND_20040314
; 2155 : 				|| (btMonsterType == 143)							// 7

  000c7	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  000cb	83 f8 59	 cmp	 eax, 89			; 00000059H
  000ce	74 3e		 je	 SHORT $LN9@SetBossMon
  000d0	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  000d4	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  000d7	74 35		 je	 SHORT $LN9@SetBossMon
  000d9	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  000dd	83 f8 70	 cmp	 eax, 112		; 00000070H
  000e0	74 2c		 je	 SHORT $LN9@SetBossMon
  000e2	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  000e6	83 f8 76	 cmp	 eax, 118		; 00000076H
  000e9	74 23		 je	 SHORT $LN9@SetBossMon
  000eb	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  000ef	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  000f2	74 1a		 je	 SHORT $LN9@SetBossMon
  000f4	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  000f8	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  000fd	74 0f		 je	 SHORT $LN9@SetBossMon
  000ff	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  00103	3d 8f 00 00 00	 cmp	 eax, 143		; 0000008fH
  00108	0f 85 b6 00 00
	00		 jne	 $LN6@SetBossMon
$LN9@SetBossMon:

; 2156 : #endif	
; 2157 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		// 8  
; 2158 : 				|| (btMonsterType == 433)							// 8
; 2159 : #endif				
; 2160 : 				)
; 2161 : 			{
; 2162 : #ifdef MAP_SERVER_ADD_MONSTER_20041216		//   , NPC  (     .)
; 2163 : 				result = gObjAddMonster(btMapNumber);

  0010e	0f b6 45 ee	 movzx	 eax, BYTE PTR _btMapNumber$2[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00118	83 c4 04	 add	 esp, 4
  0011b	0f bf c8	 movsx	 ecx, ax
  0011e	89 4d f8	 mov	 DWORD PTR _result$[ebp], ecx

; 2164 : #else
; 2165 : 				result = gObjAdd();
; 2166 : #endif
; 2167 : 				if( result >= 0 )

  00121	83 7d f8 00	 cmp	 DWORD PTR _result$[ebp], 0
  00125	0f 8c 99 00 00
	00		 jl	 $LN6@SetBossMon

; 2168 : 				{
; 2169 : 					gObjSetPosMonster(result, iBossPosNum);

  0012b	8b 45 f0	 mov	 eax, DWORD PTR _iBossPosNum$4[ebp]
  0012e	50		 push	 eax
  0012f	8b 4d f8	 mov	 ecx, DWORD PTR _result$[ebp]
  00132	51		 push	 ecx
  00133	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  00138	83 c4 08	 add	 esp, 8

; 2170 : 					gObjSetMonster(result, btMonsterType);

  0013b	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  0013f	50		 push	 eax
  00140	8b 4d f8	 mov	 ecx, DWORD PTR _result$[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  00149	83 c4 08	 add	 esp, 8

; 2171 : 
; 2172 : 					gObj[result].MaxRegenTime = m_iBC_MONSTER_REGEN;

  0014c	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00159	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0015c	8b 92 38 0e 00
	00		 mov	 edx, DWORD PTR [edx+3640]
  00162	89 94 01 08 02
	00 00		 mov	 DWORD PTR [ecx+eax+520], edx

; 2173 : 					gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;

  00169	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00176	8a 55 ed	 mov	 dl, BYTE PTR _btBloodCastleIndex$1[ebp]
  00179	88 94 01 d2 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3282], dl

; 2174 : 					gObj[result].m_ItemRate = m_iBC_NORMAL_ITEM_DROP;

  00180	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00187	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00190	66 8b 92 30 0e
	00 00		 mov	 dx, WORD PTR [edx+3632]
  00197	66 89 94 01 00
	03 00 00	 mov	 WORD PTR [ecx+eax+768], dx

; 2175 : 					gObj[result].Dir = rand()%8;				//  Dir      .

  0019f	e8 00 00 00 00	 call	 _rand
  001a4	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  001a9	79 05		 jns	 SHORT $LN16@SetBossMon
  001ab	48		 dec	 eax
  001ac	83 c8 f8	 or	 eax, -8			; fffffff8H
  001af	40		 inc	 eax
$LN16@SetBossMon:
  001b0	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  001b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bd	88 84 0a 08 01
	00 00		 mov	 BYTE PTR [edx+ecx+264], al
$LN6@SetBossMon:

; 2176 : 				}
; 2177 : 			}
; 2178 : 		}
; 2179 : 	}

  001c4	e9 82 fe ff ff	 jmp	 $LN2@SetBossMon
$LN1@SetBossMon:

; 2180 : }

  001c9	5f		 pop	 edi
  001ca	5e		 pop	 esi
  001cb	5b		 pop	 ebx
  001cc	8b e5		 mov	 esp, ebp
  001ce	5d		 pop	 ebp
  001cf	c2 04 00	 ret	 4
?SetBossMonster@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetBossMonster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetMonster@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv220 = -100						; size = 4
tv182 = -100						; size = 4
tv66 = -100						; size = 4
tv221 = -96						; size = 4
tv183 = -96						; size = 4
tv67 = -96						; size = 4
_btBloodCastleIndex$1 = -27				; size = 1
_btMapNumber$2 = -26					; size = 1
_btMonsterType$3 = -25					; size = 1
_n$4 = -24						; size = 4
_result$ = -20						; size = 4
_result$5 = -16						; size = 4
_btBloodCastleIndex$ = -11				; size = 1
_btMapNumber$ = -10					; size = 1
_btMonsterType$ = -9					; size = 1
_nCastleDoorPosNum$ = -8				; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetMonster@CBloodCastle@@QAEXH@Z PROC			; CBloodCastle::SetMonster, COMDAT
; _this$ = ecx

; 1950 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1951 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)) {			//   

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN21@SetMonster
  00012	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN22@SetMonster
$LN21@SetMonster:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN19@SetMonster
  00021	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN20@SetMonster
$LN19@SetMonster:
  0002a	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN20@SetMonster:
  00031	8b 45 9c	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN22@SetMonster:
  00037	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@SetMonster

; 1952 : 		return;

  0003d	e9 0b 05 00 00	 jmp	 $LN1@SetMonster
$LN5@SetMonster:

; 1953 : 	}
; 1954 : 
; 1955 : 	// 1 .        
; 1956 : 	SetMonsterKillCount(iBridgeIndex);

  00042	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonsterKillCount

; 1957 : 
; 1958 : 	// !!> 
; 1959 : //	m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = 3;
; 1960 : 	
; 1961 : 
; 1962 : 	// 2 .  .
; 1963 : 	int nCastleDoorPosNum = m_BridgeData[iBridgeIndex].m_nCastleDoorPosNum;

  0004e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 94 01 38 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+312]
  0005f	89 55 f8	 mov	 DWORD PTR _nCastleDoorPosNum$[ebp], edx

; 1964 : 
; 1965 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//   			
; 1966 : 	WORD btMonsterType = gMSetBase.m_Mp[nCastleDoorPosNum].m_Type;
; 1967 : #else
; 1968 : 	BYTE btMonsterType = gMSetBase.m_Mp[nCastleDoorPosNum].m_Type;

  00062	6b 45 f8 0c	 imul	 eax, DWORD PTR _nCastleDoorPosNum$[ebp], 12
  00066	8a 88 06 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  0006c	88 4d f7	 mov	 BYTE PTR _btMonsterType$[ebp], cl

; 1969 : #endif
; 1970 : 	BYTE btMapNumber = gMSetBase.m_Mp[nCastleDoorPosNum].m_MapNumber;

  0006f	6b 45 f8 0c	 imul	 eax, DWORD PTR _nCastleDoorPosNum$[ebp], 12
  00073	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  00079	88 4d f6	 mov	 BYTE PTR _btMapNumber$[ebp], cl

; 1971 : 
; 1972 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 1973 : 	BYTE btBloodCastleIndex = GetBridgeIndexByMapNum( btMapNumber );
; 1974 : #else
; 1975 : 	BYTE btBloodCastleIndex = btMapNumber - MAP_INDEX_BLOODCASTLE1;

  0007c	0f b6 45 f6	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  00080	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00083	88 45 f5	 mov	 BYTE PTR _btBloodCastleIndex$[ebp], al

; 1976 : #endif
; 1977 : 
; 1978 : 	if (nCastleDoorPosNum != -1) {

  00086	83 7d f8 ff	 cmp	 DWORD PTR _nCastleDoorPosNum$[ebp], -1
  0008a	0f 84 55 01 00
	00		 je	 $LN7@SetMonster

; 1979 : 		if (btMonsterType == 131) {											//    

  00090	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMonsterType$[ebp]
  00094	3d 83 00 00 00	 cmp	 eax, 131		; 00000083H
  00099	0f 85 46 01 00
	00		 jne	 $LN7@SetMonster

; 1980 : #ifdef MAP_SERVER_ADD_MONSTER_20041216		//   , NPC  (     .)
; 1981 : 			int result = gObjAddMonster(btMapNumber);

  0009f	0f b6 45 f6	 movzx	 eax, BYTE PTR _btMapNumber$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  000a9	83 c4 04	 add	 esp, 4
  000ac	0f bf c8	 movsx	 ecx, ax
  000af	89 4d f0	 mov	 DWORD PTR _result$5[ebp], ecx

; 1982 : #else
; 1983 : 			int result = gObjAdd();
; 1984 : #endif
; 1985 : 			if( result >= 0 )

  000b2	83 7d f0 00	 cmp	 DWORD PTR _result$5[ebp], 0
  000b6	0f 8c 29 01 00
	00		 jl	 $LN9@SetMonster

; 1986 : 			{
; 1987 : 				gObjSetPosMonster(result, nCastleDoorPosNum);

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _nCastleDoorPosNum$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR _result$5[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  000c9	83 c4 08	 add	 esp, 8

; 1988 : 				gObjSetMonster(result, btMonsterType);

  000cc	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMonsterType$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d f0	 mov	 ecx, DWORD PTR _result$5[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  000da	83 c4 08	 add	 esp, 8

; 1989 : 				
; 1990 : 				gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;

  000dd	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$5[ebp], 7072
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ea	8a 55 f5	 mov	 dl, BYTE PTR _btBloodCastleIndex$[ebp]
  000ed	88 94 01 d2 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3282], dl

; 1991 : 				gObj[result].m_ItemRate = m_iBC_NORMAL_ITEM_DROP;

  000f4	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$5[ebp], 7072
  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00101	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00104	66 8b 92 30 0e
	00 00		 mov	 dx, WORD PTR [edx+3632]
  0010b	66 89 94 01 00
	03 00 00	 mov	 WORD PTR [ecx+eax+768], dx

; 1992 : 				gObj[result].Dir = 1;

  00113	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$5[ebp], 7072
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00120	c6 84 01 08 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+264], 1

; 1993 : 				gObj[result].m_PosNum = -1;

  00128	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$5[ebp], 7072
  0012f	83 c9 ff	 or	 ecx, -1
  00132	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00138	66 89 8c 02 0c
	02 00 00	 mov	 WORD PTR [edx+eax+524], cx

; 1994 : 				gObj[result].Live	= 1;

  00140	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$5[ebp], 7072
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014d	c6 44 01 66 01	 mov	 BYTE PTR [ecx+eax+102], 1

; 1995 : 				gObj[result].DieRegen = 0;

  00152	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$5[ebp], 7072
  00159	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015f	c6 84 01 fe 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+510], 0

; 1996 : 				gObj[result].m_State	= OBJST_CREATE;

  00167	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$5[ebp], 7072
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00174	c7 84 01 b8 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+440], 1

; 1997 : 				gObj[result].MaxRegenTime = 0;

  0017f	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$5[ebp], 7072
  00186	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018c	c7 84 01 08 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+520], 0

; 1998 : 				gObj[result].MaxLife	= m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  00197	0f b6 45 f5	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  0019b	69 c8 04 02 00
	00		 imul	 ecx, eax, 516
  001a1	69 55 f0 a0 1b
	00 00		 imul	 edx, DWORD PTR _result$5[ebp], 7072
  001a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ad	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  001b0	8b 8c 0e 6c 01
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+364]
  001b7	89 8c 10 c0 00
	00 00		 mov	 DWORD PTR [eax+edx+192], ecx

; 1999 : 				gObj[result].Life		= m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  001be	0f b6 45 f5	 movzx	 eax, BYTE PTR _btBloodCastleIndex$[ebp]
  001c2	69 c8 04 02 00
	00		 imul	 ecx, eax, 516
  001c8	69 55 f0 a0 1b
	00 00		 imul	 edx, DWORD PTR _result$5[ebp], 7072
  001cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d4	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  001d7	8b 8c 0e 6c 01
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+364]
  001de	89 8c 10 bc 00
	00 00		 mov	 DWORD PTR [eax+edx+188], ecx
$LN9@SetMonster:
$LN7@SetMonster:

; 2000 : #ifdef ADD_LOG_BLOODCASTLE_DOOR_20070321
; 2001 : 				m_BridgeData[btBloodCastleIndex].m_iDoorIndex	=	result;
; 2002 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2003 : 				LogAddTD("[Blood Castle] (%d) Create Door Successfuly : Index(%d)", btBloodCastleIndex + 1, result);
; 2004 : #else
; 2005 : 				LogAddTD("[Blood Castle] (%d) Create Door Successfuly : Index(%d)", btMapNumber - MAP_INDEX_BLOODCASTLE1+1, result);
; 2006 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 2007 : #endif
; 2008 : 			}
; 2009 : #ifdef ADD_LOG_BLOODCASTLE_DOOR_20070321
; 2010 : 			else
; 2011 : 			{
; 2012 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2013 : 				LogAddTD("[Blood Castle] (%d) Create Door Fail", btBloodCastleIndex + 1);
; 2014 : #else
; 2015 : 				LogAddTD("[Blood Castle] (%d) Create Door Fail", btMapNumber - MAP_INDEX_BLOODCASTLE1+1);
; 2016 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 2017 : 			}
; 2018 : #endif
; 2019 : 		}
; 2020 : 		else {
; 2021 : 			//  . ( )
; 2022 : #ifdef ADD_LOG_BLOODCASTLE_DOOR_20070321
; 2023 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2024 : 			LogAddTD("[Blood Castle] (%d) Door monster type Error", btBloodCastleIndex + 1);
; 2025 : #else
; 2026 : 			LogAddTD("[Blood Castle] (%d) Door monster type Error", btMapNumber - MAP_INDEX_BLOODCASTLE1+1);
; 2027 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 2028 : #endif	
; 2029 : 		}
; 2030 : 	}
; 2031 : 
; 2032 : 
; 2033 : 	// 3 .   .
; 2034 : 	int result;	
; 2035 : 	for( int n=0; n<gMSetBase.m_Count; n++)

  001e5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$4[ebp], 0
  001ec	eb 09		 jmp	 SHORT $LN4@SetMonster
$LN2@SetMonster:
  001ee	8b 45 e8	 mov	 eax, DWORD PTR _n$4[ebp]
  001f1	83 c0 01	 add	 eax, 1
  001f4	89 45 e8	 mov	 DWORD PTR _n$4[ebp], eax
$LN4@SetMonster:
  001f7	8b 45 e8	 mov	 eax, DWORD PTR _n$4[ebp]
  001fa	3b 05 e4 0f 01
	00		 cmp	 eax, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A+69604
  00200	0f 8d 47 03 00
	00		 jge	 $LN3@SetMonster

; 2036 : 	{
; 2037 : 		if( CHECK_BLOODCASTLE(gMSetBase.m_Mp[n].m_MapNumber) )		//    

  00206	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$4[ebp], 12
  0020a	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  00211	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00214	7d 09		 jge	 SHORT $LN25@SetMonster
  00216	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv183[ebp], 0
  0021d	eb 26		 jmp	 SHORT $LN26@SetMonster
$LN25@SetMonster:
  0021f	6b 55 e8 0c	 imul	 edx, DWORD PTR _n$4[ebp], 12
  00223	0f b6 82 08 00
	00 00		 movzx	 eax, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[edx+8]
  0022a	83 f8 11	 cmp	 eax, 17			; 00000011H
  0022d	7e 09		 jle	 SHORT $LN23@SetMonster
  0022f	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv182[ebp], 0
  00236	eb 07		 jmp	 SHORT $LN24@SetMonster
$LN23@SetMonster:
  00238	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv182[ebp], 1
$LN24@SetMonster:
  0023f	8b 4d 9c	 mov	 ecx, DWORD PTR tv182[ebp]
  00242	89 4d a0	 mov	 DWORD PTR tv183[ebp], ecx
$LN26@SetMonster:
  00245	83 7d a0 00	 cmp	 DWORD PTR tv183[ebp], 0
  00249	0f 84 f9 02 00
	00		 je	 $LN17@SetMonster

; 2038 : 		{
; 2039 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//   			
; 2040 : 			WORD btMonsterType = gMSetBase.m_Mp[n].m_Type;
; 2041 : #else
; 2042 : 			BYTE btMonsterType = gMSetBase.m_Mp[n].m_Type;

  0024f	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$4[ebp], 12
  00253	8a 88 06 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+6]
  00259	88 4d e7	 mov	 BYTE PTR _btMonsterType$3[ebp], cl

; 2043 : #endif
; 2044 : 			BYTE btMapNumber = gMSetBase.m_Mp[n].m_MapNumber;

  0025c	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$4[ebp], 12
  00260	8a 88 08 00 00
	00		 mov	 cl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  00266	88 4d e6	 mov	 BYTE PTR _btMapNumber$2[ebp], cl

; 2045 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2046 : 			BYTE btBloodCastleIndex = GetBridgeIndexByMapNum( btMapNumber );
; 2047 : #else
; 2048 : 			BYTE btBloodCastleIndex = btMapNumber - MAP_INDEX_BLOODCASTLE1;

  00269	0f b6 45 e6	 movzx	 eax, BYTE PTR _btMapNumber$2[ebp]
  0026d	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00270	88 45 e5	 mov	 BYTE PTR _btBloodCastleIndex$1[ebp], al

; 2049 : #endif
; 2050 : 
; 2051 : 			if (btBloodCastleIndex != iBridgeIndex)					//     					

  00273	0f b6 45 e5	 movzx	 eax, BYTE PTR _btBloodCastleIndex$1[ebp]
  00277	3b 45 08	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0027a	74 05		 je	 SHORT $LN11@SetMonster

; 2052 : 				continue;

  0027c	e9 6d ff ff ff	 jmp	 $LN2@SetMonster
$LN11@SetMonster:

; 2053 : 
; 2054 : 			if (btMonsterType == NPC_ANGELKING)						//       .

  00281	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  00285	3d e8 00 00 00	 cmp	 eax, 232		; 000000e8H
  0028a	75 05		 jne	 SHORT $LN12@SetMonster

; 2055 : 				continue;

  0028c	e9 5d ff ff ff	 jmp	 $LN2@SetMonster
$LN12@SetMonster:

; 2056 : 
; 2057 : 			if (btMonsterType == 131)								//       .

  00291	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  00295	3d 83 00 00 00	 cmp	 eax, 131		; 00000083H
  0029a	75 05		 jne	 SHORT $LN13@SetMonster

; 2058 : 				continue;

  0029c	e9 4d ff ff ff	 jmp	 $LN2@SetMonster
$LN13@SetMonster:

; 2059 : 
; 2060 : 			//      .
; 2061 : 			if ((btMonsterType == 89) ||							// 1							
; 2062 : 				(btMonsterType == 95) ||							// 2
; 2063 : 				(btMonsterType == 112) ||							// 3
; 2064 : 				(btMonsterType == 118) ||							// 4
; 2065 : 				(btMonsterType == 124) ||							// 5
; 2066 : 				(btMonsterType == 130)								// 6
; 2067 : #ifdef BLOODCASTLE_EXTEND_20040314
; 2068 : 				|| (btMonsterType == 143)							// 7

  002a1	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  002a5	83 f8 59	 cmp	 eax, 89			; 00000059H
  002a8	74 3a		 je	 SHORT $LN15@SetMonster
  002aa	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  002ae	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002b1	74 31		 je	 SHORT $LN15@SetMonster
  002b3	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  002b7	83 f8 70	 cmp	 eax, 112		; 00000070H
  002ba	74 28		 je	 SHORT $LN15@SetMonster
  002bc	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  002c0	83 f8 76	 cmp	 eax, 118		; 00000076H
  002c3	74 1f		 je	 SHORT $LN15@SetMonster
  002c5	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  002c9	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  002cc	74 16		 je	 SHORT $LN15@SetMonster
  002ce	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  002d2	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  002d7	74 0b		 je	 SHORT $LN15@SetMonster
  002d9	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  002dd	3d 8f 00 00 00	 cmp	 eax, 143		; 0000008fH
  002e2	75 05		 jne	 SHORT $LN14@SetMonster
$LN15@SetMonster:

; 2069 : #endif	
; 2070 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		// 8   
; 2071 : 				|| (btMonsterType == 433)							// 8
; 2072 : #endif				
; 2073 : 				)
; 2074 : 				continue;

  002e4	e9 05 ff ff ff	 jmp	 $LN2@SetMonster
$LN14@SetMonster:

; 2075 : 
; 2076 : 			if (CHECK_LIMIT(btMonsterType-BC_SAINT_STATUE_1, 3))	//          .

  002e9	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  002ed	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  002f2	79 09		 jns	 SHORT $LN29@SetMonster
  002f4	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv221[ebp], 0
  002fb	eb 25		 jmp	 SHORT $LN30@SetMonster
$LN29@SetMonster:
  002fd	0f b6 4d e7	 movzx	 ecx, BYTE PTR _btMonsterType$3[ebp]
  00301	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  00307	83 f9 02	 cmp	 ecx, 2
  0030a	7e 09		 jle	 SHORT $LN27@SetMonster
  0030c	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv220[ebp], 0
  00313	eb 07		 jmp	 SHORT $LN28@SetMonster
$LN27@SetMonster:
  00315	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv220[ebp], 1
$LN28@SetMonster:
  0031c	8b 55 9c	 mov	 edx, DWORD PTR tv220[ebp]
  0031f	89 55 a0	 mov	 DWORD PTR tv221[ebp], edx
$LN30@SetMonster:
  00322	83 7d a0 00	 cmp	 DWORD PTR tv221[ebp], 0
  00326	74 05		 je	 SHORT $LN16@SetMonster

; 2077 : 				continue;

  00328	e9 c1 fe ff ff	 jmp	 $LN2@SetMonster
$LN16@SetMonster:

; 2078 : 
; 2079 : //			if (MAP_ATTR_NONE != MapC[gObj[result].MapNumber].GetAttr(gObj[result].X, gObj[result].Y))
; 2080 : //				continue;
; 2081 : 
; 2082 : #ifdef MAP_SERVER_ADD_MONSTER_20041216		//   , NPC  (     .)
; 2083 : 			result = gObjAddMonster(gMSetBase.m_Mp[n].m_MapNumber);

  0032d	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$4[ebp], 12
  00331	0f b6 88 08 00
	00 00		 movzx	 ecx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  00338	51		 push	 ecx
  00339	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0033e	83 c4 04	 add	 esp, 4
  00341	0f bf d0	 movsx	 edx, ax
  00344	89 55 ec	 mov	 DWORD PTR _result$[ebp], edx

; 2084 : #else
; 2085 : 			result = gObjAdd();
; 2086 : #endif
; 2087 : 			if( result >= 0 )

  00347	83 7d ec 00	 cmp	 DWORD PTR _result$[ebp], 0
  0034b	0f 8c f7 01 00
	00		 jl	 $LN17@SetMonster

; 2088 : 			{
; 2089 : 				gObj[result].m_PosNum   = n;

  00351	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00358	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0035e	66 8b 55 e8	 mov	 dx, WORD PTR _n$4[ebp]
  00362	66 89 94 01 0c
	02 00 00	 mov	 WORD PTR [ecx+eax+524], dx

; 2090 : 				gObj[result].X			= gMSetBase.m_Mp[n].m_X;

  0036a	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$4[ebp], 12
  0036e	66 0f b6 88 0a
	00 00 00	 movzx	 cx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10]
  00376	69 55 ec a0 1b
	00 00		 imul	 edx, DWORD PTR _result$[ebp], 7072
  0037d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00382	66 89 8c 10 04
	01 00 00	 mov	 WORD PTR [eax+edx+260], cx

; 2091 : 				gObj[result].Y			= gMSetBase.m_Mp[n].m_Y;

  0038a	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$4[ebp], 12
  0038e	66 0f b6 88 0b
	00 00 00	 movzx	 cx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+11]
  00396	69 55 ec a0 1b
	00 00		 imul	 edx, DWORD PTR _result$[ebp], 7072
  0039d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a2	66 89 8c 10 06
	01 00 00	 mov	 WORD PTR [eax+edx+262], cx

; 2092 : 				gObj[result].MapNumber	= gMSetBase.m_Mp[n].m_MapNumber;

  003aa	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$4[ebp], 12
  003ae	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  003b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003bb	8a 80 08 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  003c1	88 84 0a 09 01
	00 00		 mov	 BYTE PTR [edx+ecx+265], al

; 2093 : 				gObj[result].TX			= gObj[result].X;

  003c8	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  003cf	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  003d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003dc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003e2	66 8b 84 06 04
	01 00 00	 mov	 ax, WORD PTR [esi+eax+260]
  003ea	66 89 84 0a 20
	01 00 00	 mov	 WORD PTR [edx+ecx+288], ax

; 2094 : 				gObj[result].TY			= gObj[result].Y;

  003f2	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  003f9	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  00400	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00406	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0040c	66 8b 84 06 06
	01 00 00	 mov	 ax, WORD PTR [esi+eax+262]
  00414	66 89 84 0a 22
	01 00 00	 mov	 WORD PTR [edx+ecx+290], ax

; 2095 : 				gObj[result].m_OldX		= gObj[result].X;

  0041c	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00423	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  0042a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00430	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00436	66 8b 84 06 04
	01 00 00	 mov	 ax, WORD PTR [esi+eax+260]
  0043e	66 89 84 0a 1c
	01 00 00	 mov	 WORD PTR [edx+ecx+284], ax

; 2096 : 				gObj[result].m_OldY		= gObj[result].Y;

  00446	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  0044d	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  00454	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0045a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00460	66 8b 84 06 06
	01 00 00	 mov	 ax, WORD PTR [esi+eax+262]
  00468	66 89 84 0a 1e
	01 00 00	 mov	 WORD PTR [edx+ecx+286], ax

; 2097 : 				gObj[result].Dir		= gMSetBase.m_Mp[n].m_Dir;

  00470	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$4[ebp], 12
  00474	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  0047b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00481	8a 80 0c 00 00
	00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+12]
  00487	88 84 0a 08 01
	00 00		 mov	 BYTE PTR [edx+ecx+264], al

; 2098 : 				gObj[result].StartX     = (BYTE)gObj[result].X;

  0048e	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00495	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  0049c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004a2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004a8	8a 84 06 04 01
	00 00		 mov	 al, BYTE PTR [esi+eax+260]
  004af	88 84 0a 1a 01
	00 00		 mov	 BYTE PTR [edx+ecx+282], al

; 2099 : 				gObj[result].StartY     = (BYTE)gObj[result].Y;

  004b6	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  004bd	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  004c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ca	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004d0	8a 84 06 06 01
	00 00		 mov	 al, BYTE PTR [esi+eax+262]
  004d7	88 84 0a 1b 01
	00 00		 mov	 BYTE PTR [edx+ecx+283], al

; 2100 : /*
; 2101 : 				LogAddTD ("[BTEST] Pos:%d, X:%d, Y:%d, Type:%d, MapAttr:%d",
; 2102 : 					n,
; 2103 : 					gObj[result].X,
; 2104 : 					gObj[result].Y,
; 2105 : 					gObj[result].Class,
; 2106 : 					MapC[gObj[result].MapNumber].GetAttr(gObj[result].X, gObj[result].Y)
; 2107 : 					);
; 2108 : */
; 2109 : 				gObjSetMonster(result, btMonsterType);

  004de	0f b6 45 e7	 movzx	 eax, BYTE PTR _btMonsterType$3[ebp]
  004e2	50		 push	 eax
  004e3	8b 4d ec	 mov	 ecx, DWORD PTR _result$[ebp]
  004e6	51		 push	 ecx
  004e7	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  004ec	83 c4 08	 add	 esp, 8

; 2110 : 
; 2111 : 				gObj[result].MaxRegenTime = m_iBC_MONSTER_REGEN;

  004ef	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  004f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004fc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  004ff	8b 92 38 0e 00
	00		 mov	 edx, DWORD PTR [edx+3640]
  00505	89 94 01 08 02
	00 00		 mov	 DWORD PTR [ecx+eax+520], edx

; 2112 : 				gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;

  0050c	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00513	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00519	8a 55 e5	 mov	 dl, BYTE PTR _btBloodCastleIndex$1[ebp]
  0051c	88 94 01 d2 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3282], dl

; 2113 : //				gObj[result].m_ItemRate = m_iBC_NORMAL_ITEM_DROP;
; 2114 : 				gObj[result].Dir = rand()%8;					//  Dir      .

  00523	e8 00 00 00 00	 call	 _rand
  00528	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0052d	79 05		 jns	 SHORT $LN31@SetMonster
  0052f	48		 dec	 eax
  00530	83 c8 f8	 or	 eax, -8			; fffffff8H
  00533	40		 inc	 eax
$LN31@SetMonster:
  00534	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  0053b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00541	88 84 0a 08 01
	00 00		 mov	 BYTE PTR [edx+ecx+264], al
$LN17@SetMonster:

; 2115 : 			}
; 2116 : 		}
; 2117 : 	}

  00548	e9 a1 fc ff ff	 jmp	 $LN2@SetMonster
$LN3@SetMonster:
$LN1@SetMonster:

; 2118 : }

  0054d	5f		 pop	 edi
  0054e	5e		 pop	 esi
  0054f	5b		 pop	 ebx
  00550	8b e5		 mov	 esp, ebp
  00552	5d		 pop	 ebp
  00553	c2 04 00	 ret	 4
?SetMonster@CBloodCastle@@QAEXH@Z ENDP			; CBloodCastle::SetMonster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ClearMonster@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
tv66 = -80						; size = 4
tv67 = -76						; size = 4
_n$1 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_bClearCastleDoor$ = 12					; size = 1
?ClearMonster@CBloodCastle@@QAEXH_N@Z PROC		; CBloodCastle::ClearMonster, COMDAT
; _this$ = ecx

; 1926 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1927 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN12@ClearMonst
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN13@ClearMonst
$LN12@ClearMonst:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN10@ClearMonst
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN11@ClearMonst
$LN10@ClearMonst:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN11@ClearMonst:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN13@ClearMonst:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@ClearMonst

; 1928 : 		return;

  0003d	e9 91 00 00 00	 jmp	 $LN1@ClearMonst
$LN5@ClearMonst:

; 1929 : 	
; 1930 : 	for( int n=0; n<MAX_MONSTER; n++)

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN4@ClearMonst
$LN2@ClearMonst:
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@ClearMonst:
  00054	81 7d f8 a8 16
	00 00		 cmp	 DWORD PTR _n$1[ebp], 5800 ; 000016a8H
  0005b	7d 76		 jge	 SHORT $LN1@ClearMonst

; 1931 : 	{
; 1932 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 1933 : 		if (gObj[n].MapNumber == GetMapNumByBCBridge( iBridgeIndex ) ) {	//          
; 1934 : #else
; 1935 : 		if (gObj[n].MapNumber == (MAP_INDEX_BLOODCASTLE1 + iBridgeIndex)) {	//          

  0005d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006a	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00072	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00075	83 c0 0b	 add	 eax, 11			; 0000000bH
  00078	3b d0		 cmp	 edx, eax
  0007a	75 52		 jne	 SHORT $LN6@ClearMonst

; 1936 : #endif
; 1937 : 
; 1938 : 			if (!bClearCastleDoor && (gObj[n].Class == 131))				//      .

  0007c	0f b6 45 0c	 movzx	 eax, BYTE PTR _bClearCastleDoor$[ebp]
  00080	85 c0		 test	 eax, eax
  00082	75 1f		 jne	 SHORT $LN7@ClearMonst
  00084	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00091	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00099	81 fa 83 00 00
	00		 cmp	 edx, 131		; 00000083H
  0009f	75 02		 jne	 SHORT $LN7@ClearMonst

; 1939 : 				continue;

  000a1	eb a8		 jmp	 SHORT $LN2@ClearMonst
$LN7@ClearMonst:

; 1940 : 			if (gObj[n].Class == NPC_ANGELKING)										//   

  000a3	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b0	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  000b8	81 fa e8 00 00
	00		 cmp	 edx, 232		; 000000e8H
  000be	75 02		 jne	 SHORT $LN8@ClearMonst

; 1941 : 				continue;

  000c0	eb 89		 jmp	 SHORT $LN2@ClearMonst
$LN8@ClearMonst:

; 1942 : 
; 1943 : 			gObjDel(n);

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  000cb	83 c4 04	 add	 esp, 4
$LN6@ClearMonst:

; 1944 : 		}
; 1945 : 	}

  000ce	e9 78 ff ff ff	 jmp	 $LN2@ClearMonst
$LN1@ClearMonst:

; 1946 : }

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8
?ClearMonster@CBloodCastle@@QAEXH_N@Z ENDP		; CBloodCastle::ClearMonster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
tv68 = -208						; size = 4
tv69 = -204						; size = 4
_pChange$1 = -136					; size = 10
_aAntiLootIndex$ = -124					; size = 4
_szItemName$ = -120					; size = 50
_item_number$ = -68					; size = 4
_SOption$ = -61						; size = 1
_PetExp$ = -60						; size = 4
_PetLevel$ = -56					; size = 4
_NewOption$ = -52					; size = 8
_s_num$ = -44						; size = 4
_NOption$ = -40						; size = 1
_Option3$ = -39						; size = 1
_Option2$ = -38						; size = 1
_Option1$ = -37						; size = 1
_ret$ = -36						; size = 4
_dur$ = -32						; size = 4
_level$ = -28						; size = 4
_type$ = -24						; size = 4
_map_num$ = -20						; size = 4
_pResult$ = -16						; size = 5
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_iItemType$ = 16					; size = 4
_iItemPos$ = 20						; size = 4
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z PROC		; CBloodCastle::DropItemDirectly, COMDAT
; _this$ = ecx

; 4567 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4568 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 4569 : 	if (!CHECK_BLOODCASTLE( GetMapNumByBCBridge( iBridgeIndex ) )) {
; 4570 : #else
; 4571 : 	if (!CHECK_BLOODCASTLE(MAP_INDEX_BLOODCASTLE1 + iBridgeIndex)) {

  00019	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0001c	83 c0 0b	 add	 eax, 11			; 0000000bH
  0001f	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00022	7d 0c		 jge	 SHORT $LN12@DropItemDi
  00024	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
  0002e	eb 2d		 jmp	 SHORT $LN13@DropItemDi
$LN12@DropItemDi:
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00033	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00036	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00039	7e 0c		 jle	 SHORT $LN10@DropItemDi
  0003b	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00045	eb 0a		 jmp	 SHORT $LN11@DropItemDi
$LN10@DropItemDi:
  00047	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
$LN11@DropItemDi:
  00051	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv68[ebp]
  00057	89 95 34 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], edx
$LN13@DropItemDi:
  0005d	83 bd 34 ff ff
	ff 00		 cmp	 DWORD PTR tv69[ebp], 0
  00064	75 3d		 jne	 SHORT $LN2@DropItemDi

; 4572 : #endif
; 4573 : 		LogAddTD("[Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeIndex wrong - %d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iBridgeIndex);

  00066	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00069	50		 push	 eax
  0006a	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00071	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00077	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0007b	50		 push	 eax
  0007c	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00083	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00089	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropIte@
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00099	83 c4 10	 add	 esp, 16			; 00000010H

; 4574 : 		return false;

  0009c	33 c0		 xor	 eax, eax
  0009e	e9 39 05 00 00	 jmp	 $LN1@DropItemDi
$LN2@DropItemDi:

; 4575 : 	}
; 4576 : 
; 4577 : 	PMSG_ITEMTHROW_RESULT pResult;
; 4578 : 
; 4579 : 	PHeadSetB((LPBYTE)&pResult, 0x23, sizeof( pResult ));

  000a3	6a 05		 push	 5
  000a5	6a 23		 push	 35			; 00000023H
  000a7	8d 45 f0	 lea	 eax, DWORD PTR _pResult$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4580 : 	pResult.Result		= 0x01;

  000b3	c6 45 f3 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 4581 : 	pResult.Ipos		= iItemPos;		

  000b7	8a 45 14	 mov	 al, BYTE PTR _iItemPos$[ebp]
  000ba	88 45 f4	 mov	 BYTE PTR _pResult$[ebp+4], al

; 4582 : 
; 4583 : 	int map_num = gObj[iIndex].MapNumber;	

  000bd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ca	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000d2	89 55 ec	 mov	 DWORD PTR _map_num$[ebp], edx

; 4584 : 	int type    = gObj[iIndex].pInventory[iItemPos].m_Type;

  000d5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000dc	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  000e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e9	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  000f0	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  000f5	89 4d e8	 mov	 DWORD PTR _type$[ebp], ecx

; 4585 : 	int level   = gObj[iIndex].pInventory[iItemPos].m_Level;

  000f8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000ff	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  00106	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010c	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00113	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  00118	89 4d e4	 mov	 DWORD PTR _level$[ebp], ecx

; 4586 : 	float dur   = gObj[iIndex].pInventory[iItemPos].m_Durability;

  0011b	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00122	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  00129	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012f	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00136	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  0013c	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4587 : 	int ret     = gObj[iIndex].pInventory[iItemPos].IsItem();

  00141	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00148	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  0014f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00155	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0015c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00161	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 4588 : 	BYTE Option1= gObj[iIndex].pInventory[iItemPos].m_Option1;

  00164	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0016b	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  00172	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00178	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  0017f	8a 4c 08 78	 mov	 cl, BYTE PTR [eax+ecx+120]
  00183	88 4d db	 mov	 BYTE PTR _Option1$[ebp], cl

; 4589 : 	BYTE Option2= gObj[iIndex].pInventory[iItemPos].m_Option2;

  00186	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0018d	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  00194	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019a	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  001a1	8a 4c 08 79	 mov	 cl, BYTE PTR [eax+ecx+121]
  001a5	88 4d da	 mov	 BYTE PTR _Option2$[ebp], cl

; 4590 : 	BYTE Option3= gObj[iIndex].pInventory[iItemPos].m_Option3;

  001a8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001af	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  001b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bc	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  001c3	8a 4c 08 7a	 mov	 cl, BYTE PTR [eax+ecx+122]
  001c7	88 4d d9	 mov	 BYTE PTR _Option3$[ebp], cl

; 4591 : 	BYTE NOption= gObj[iIndex].pInventory[iItemPos].m_NewOption;

  001ca	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001d1	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  001d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001de	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  001e5	8a 4c 08 7b	 mov	 cl, BYTE PTR [eax+ecx+123]
  001e9	88 4d d8	 mov	 BYTE PTR _NOption$[ebp], cl

; 4592 : 	DWORD s_num = gObj[iIndex].pInventory[iItemPos].m_Number;

  001ec	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001f3	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  001fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00200	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00207	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0020a	89 4d d4	 mov	 DWORD PTR _s_num$[ebp], ecx

; 4593 : 	
; 4594 : #ifdef EXTEND_LOG_SYSTEM_03_20060816
; 4595 : 	#ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 4596 : 		BYTE ItemExOption	= g_kJewelOfHarmonySystem.GetItemStrengthenOption( &gObj[iIndex].pInventory[iItemPos] );
; 4597 : 		BYTE ItemExLevel	= g_kJewelOfHarmonySystem.GetItemOptionLevel( &gObj[iIndex].pInventory[iItemPos] );
; 4598 : 	#endif
; 4599 : #endif // EXTEND_LOG_SYSTEM_03_20060816
; 4600 : 	
; 4601 : 	BYTE NewOption[8];
; 4602 : 	ItemIsBufExOption(NewOption, &gObj[iIndex].pInventory[iItemPos]);

  0020d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00214	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  0021b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00221	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00228	51		 push	 ecx
  00229	8d 45 cc	 lea	 eax, DWORD PTR _NewOption$[ebp]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  00232	83 c4 08	 add	 esp, 8

; 4603 : 
; 4604 : #ifdef DARKLORD_WORK
; 4605 : 	int	 PetLevel = gObj[iIndex].pInventory[iItemPos].m_PetItem_Level;

  00235	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0023c	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  00243	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00249	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00250	8b 8c 08 a0 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+160]
  00257	89 4d c8	 mov	 DWORD PTR _PetLevel$[ebp], ecx

; 4606 : 	int	 PetExp = 	gObj[iIndex].pInventory[iItemPos].m_PetItem_Exp;

  0025a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00261	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  00268	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0026e	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00275	8b 8c 08 a4 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+164]
  0027c	89 4d c4	 mov	 DWORD PTR _PetExp$[ebp], ecx

; 4607 : #endif
; 4608 : 
; 4609 : 	BYTE SOption= gObj[iIndex].pInventory[iItemPos].m_SetOption;

  0027f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00286	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  0028d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00293	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  0029a	8a 8c 08 92 00
	00 00		 mov	 cl, BYTE PTR [eax+ecx+146]
  002a1	88 4d c3	 mov	 BYTE PTR _SOption$[ebp], cl

; 4610 : 	
; 4611 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 4612 : 	#ifdef MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 4613 : 		BYTE ItemEffectEx = gObj[iIndex].pInventory[iItemPos].m_ItemOptionEx;
; 4614 : 	#else
; 4615 : 		BYTE ItemEffectEx = gObj[iIndex].pInventory[iItemPos].m_ItemOptionEx >> 7;
; 4616 : 	#endif // MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 4617 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 4618 : 
; 4619 : 	DWORD item_number = gObj[iIndex].pInventory[iItemPos].m_Number;

  002a4	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002ab	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  002b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b8	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  002bf	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  002c2	89 4d bc	 mov	 DWORD PTR _item_number$[ebp], ecx

; 4620 : 	char szItemName[50]="Item";

  002c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04BGCMBJDA@Item@
  002ca	89 45 88	 mov	 DWORD PTR _szItemName$[ebp], eax
  002cd	8a 0d 04 00 00
	00		 mov	 cl, BYTE PTR ??_C@_04BGCMBJDA@Item@+4
  002d3	88 4d 8c	 mov	 BYTE PTR _szItemName$[ebp+4], cl
  002d6	6a 2d		 push	 45			; 0000002dH
  002d8	6a 00		 push	 0
  002da	8d 45 8d	 lea	 eax, DWORD PTR _szItemName$[ebp+5]
  002dd	50		 push	 eax
  002de	e8 00 00 00 00	 call	 _memset
  002e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4621 : 	
; 4622 : 	int aAntiLootIndex = -1;					//      .

  002e6	c7 45 84 ff ff
	ff ff		 mov	 DWORD PTR _aAntiLootIndex$[ebp], -1

; 4623 : 	
; 4624 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4625 : 	BYTE SocketOption[MAX_SOCKET_SLOT] = { SOCKETSLOT_NONE, SOCKETSLOT_NONE, SOCKETSLOT_NONE, SOCKETSLOT_NONE, SOCKETSLOT_NONE };
; 4626 : 	BYTE SocketBonusOption = 0;
; 4627 : 
; 4628 : 	g_SocketOptionSystem.GetSocketOption( &gObj[iIndex].pInventory[iItemPos], SocketOption, SocketBonusOption );
; 4629 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4630 : 
; 4631 : #ifdef DARKLORD_WORK
; 4632 : 
; 4633 : 	#ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4634 : 		if( MapC[map_num].ItemDrop(type, level, dur, gObj[iIndex].X, gObj[iIndex].Y, Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp, ItemEffectEx, SocketOption, SocketBonusOption ) == TRUE )
; 4635 : 	#else
; 4636 : 		#ifdef ADD_380ITEM_NEWOPTION_20060711
; 4637 : 			if( MapC[map_num].ItemDrop(type, level, dur, gObj[iIndex].X, gObj[iIndex].Y, Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp, ItemEffectEx) == TRUE )
; 4638 : 		#else
; 4639 : 			if( MapC[map_num].ItemDrop(type, level, dur, gObj[iIndex].X, gObj[iIndex].Y, Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp) == TRUE )

  002ed	8b 45 c4	 mov	 eax, DWORD PTR _PetExp$[ebp]
  002f0	50		 push	 eax
  002f1	8b 4d c8	 mov	 ecx, DWORD PTR _PetLevel$[ebp]
  002f4	51		 push	 ecx
  002f5	8b 55 84	 mov	 edx, DWORD PTR _aAntiLootIndex$[ebp]
  002f8	52		 push	 edx
  002f9	8b 45 bc	 mov	 eax, DWORD PTR _item_number$[ebp]
  002fc	50		 push	 eax
  002fd	0f b6 4d c3	 movzx	 ecx, BYTE PTR _SOption$[ebp]
  00301	51		 push	 ecx
  00302	0f b6 55 d8	 movzx	 edx, BYTE PTR _NOption$[ebp]
  00306	52		 push	 edx
  00307	0f b6 45 d9	 movzx	 eax, BYTE PTR _Option3$[ebp]
  0030b	50		 push	 eax
  0030c	0f b6 4d da	 movzx	 ecx, BYTE PTR _Option2$[ebp]
  00310	51		 push	 ecx
  00311	0f b6 55 db	 movzx	 edx, BYTE PTR _Option1$[ebp]
  00315	52		 push	 edx
  00316	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0031d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00323	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  0032b	52		 push	 edx
  0032c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00333	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00339	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00341	52		 push	 edx
  00342	51		 push	 ecx
  00343	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _dur$[ebp]
  00348	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0034d	8b 45 e4	 mov	 eax, DWORD PTR _level$[ebp]
  00350	50		 push	 eax
  00351	8b 4d e8	 mov	 ecx, DWORD PTR _type$[ebp]
  00354	51		 push	 ecx
  00355	69 4d ec 8c 04
	05 00		 imul	 ecx, DWORD PTR _map_num$[ebp], 328844
  0035c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00362	e8 00 00 00 00	 call	 ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z ; MapClass::ItemDrop
  00367	83 f8 01	 cmp	 eax, 1
  0036a	0f 85 16 01 00
	00		 jne	 $LN3@DropItemDi

; 4640 : 		#endif // ADD_380ITEM_NEWOPTION_20060711
; 4641 : 	#endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4642 : 
; 4643 : #else	// #ifdef DARKLORD_WORK
; 4644 : 
; 4645 : 
; 4646 : 		if( MapC[map_num].ItemDrop(type, level, dur, gObj[iIndex].X, gObj[iIndex].Y, Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex) == TRUE )
; 4647 : 
; 4648 : #endif	// #ifdef DARKLORD_WORK
; 4649 : 	{   //   ..
; 4650 : 		gObjInventoryDeleteItem(iIndex, iItemPos);	

  00370	8b 45 14	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  00373	50		 push	 eax
  00374	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00377	51		 push	 ecx
  00378	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0037d	83 c4 08	 add	 esp, 8

; 4651 : 		pResult.Result = 0x01;

  00380	c6 45 f3 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 4652 : 
; 4653 : #ifdef EXTEND_LOG_SYSTEM_03_20060816
; 4654 : 	#ifdef ADD_380ITEM_NEWOPTION_20060711
; 4655 : 		#ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 4656 : 		LogAddTD(lMsg.Get(479),
; 4657 : 			gObj[iIndex].AccountID, 
; 4658 : 			gObj[iIndex].Name,
; 4659 : 			gObj[iIndex].MapNumber, 
; 4660 : 			gObj[iIndex].X, 
; 4661 : 			gObj[iIndex].Y, 
; 4662 : 			s_num, 
; 4663 : 			szItemName, 
; 4664 : 			type, 
; 4665 : 			level, 
; 4666 : 			Option1, 
; 4667 : 			Option2, 
; 4668 : 			Option3,
; 4669 : 			(int)dur,
; 4670 : 			NewOption[0],
; 4671 : 			NewOption[1],
; 4672 : 			NewOption[2],
; 4673 : 			NewOption[3],
; 4674 : 			NewOption[4],
; 4675 : 			NewOption[5],
; 4676 : 			NewOption[6],
; 4677 : 			SOption,
; 4678 : 		#ifdef MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 4679 : 			ItemEffectEx>>7,
; 4680 : 		#else
; 4681 : 			ItemEffectEx,
; 4682 : 		#endif// MODIFY_380_ITEM_OPTION_DELETE_AT_DROP_20060919
; 4683 : 			ItemExOption,
; 4684 : 			ItemExLevel
; 4685 : 			);
; 4686 : 		#endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 4687 : 	#endif // ADD_380ITEM_NEWOPTION_20060711
; 4688 : #else // EXTEND_LOG_SYSTEM_03_20060816
; 4689 : 		LogAddTD(lMsg.Get(479),

  00384	0f b6 45 c3	 movzx	 eax, BYTE PTR _SOption$[ebp]
  00388	50		 push	 eax
  00389	b9 01 00 00 00	 mov	 ecx, 1
  0038e	6b d1 06	 imul	 edx, ecx, 6
  00391	0f b6 44 15 cc	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  00396	50		 push	 eax
  00397	b9 01 00 00 00	 mov	 ecx, 1
  0039c	6b d1 05	 imul	 edx, ecx, 5
  0039f	0f b6 44 15 cc	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  003a4	50		 push	 eax
  003a5	b9 01 00 00 00	 mov	 ecx, 1
  003aa	c1 e1 02	 shl	 ecx, 2
  003ad	0f b6 54 0d cc	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  003b2	52		 push	 edx
  003b3	b8 01 00 00 00	 mov	 eax, 1
  003b8	6b c8 03	 imul	 ecx, eax, 3
  003bb	0f b6 54 0d cc	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  003c0	52		 push	 edx
  003c1	b8 01 00 00 00	 mov	 eax, 1
  003c6	d1 e0		 shl	 eax, 1
  003c8	0f b6 4c 05 cc	 movzx	 ecx, BYTE PTR _NewOption$[ebp+eax]
  003cd	51		 push	 ecx
  003ce	ba 01 00 00 00	 mov	 edx, 1
  003d3	c1 e2 00	 shl	 edx, 0
  003d6	0f b6 44 15 cc	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  003db	50		 push	 eax
  003dc	b9 01 00 00 00	 mov	 ecx, 1
  003e1	6b d1 00	 imul	 edx, ecx, 0
  003e4	0f b6 44 15 cc	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  003e9	50		 push	 eax
  003ea	0f b6 4d d9	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  003ee	51		 push	 ecx
  003ef	0f b6 55 da	 movzx	 edx, BYTE PTR _Option2$[ebp]
  003f3	52		 push	 edx
  003f4	0f b6 45 db	 movzx	 eax, BYTE PTR _Option1$[ebp]
  003f8	50		 push	 eax
  003f9	8b 4d e4	 mov	 ecx, DWORD PTR _level$[ebp]
  003fc	51		 push	 ecx
  003fd	8b 55 e8	 mov	 edx, DWORD PTR _type$[ebp]
  00400	52		 push	 edx
  00401	8d 45 88	 lea	 eax, DWORD PTR _szItemName$[ebp]
  00404	50		 push	 eax
  00405	8b 4d d4	 mov	 ecx, DWORD PTR _s_num$[ebp]
  00408	51		 push	 ecx
  00409	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00410	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00415	0f bf 8c 10 06
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+262]
  0041d	51		 push	 ecx
  0041e	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00425	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0042a	0f bf 8c 10 04
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+260]
  00432	51		 push	 ecx
  00433	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  0043a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0043f	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  00447	51		 push	 ecx
  00448	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  0044f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00454	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00458	51		 push	 ecx
  00459	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00460	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00465	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00469	51		 push	 ecx
  0046a	68 df 01 00 00	 push	 479			; 000001dfH
  0046f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00474	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0047a	50		 push	 eax
  0047b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00481	83 c4 54	 add	 esp, 84			; 00000054H

; 4690 : 			gObj[iIndex].AccountID, 
; 4691 : 			gObj[iIndex].Name,
; 4692 : 			gObj[iIndex].MapNumber, 
; 4693 : 			gObj[iIndex].X, 
; 4694 : 			gObj[iIndex].Y, 
; 4695 : 			s_num, 
; 4696 : 			szItemName, 
; 4697 : 			type, 
; 4698 : 			level, 
; 4699 : 			Option1, 
; 4700 : 			Option2, 
; 4701 : 			Option3,
; 4702 : 			NewOption[0],
; 4703 : 			NewOption[1],
; 4704 : 			NewOption[2],
; 4705 : 			NewOption[3],
; 4706 : 			NewOption[4],
; 4707 : 			NewOption[5],
; 4708 : 			NewOption[6],
; 4709 : 			SOption
; 4710 : 			);
; 4711 : #endif // EXTEND_LOG_SYSTEM_03_20060816
; 4712 : 
; 4713 : 	}

  00484	eb 04		 jmp	 SHORT $LN4@DropItemDi
$LN3@DropItemDi:

; 4714 : 	else
; 4715 : 	{
; 4716 : 		//  .
; 4717 : 		pResult.Result = 0x00;

  00486	c6 45 f3 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN4@DropItemDi:

; 4718 : 	}
; 4719 : 		
; 4720 : 	DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0048a	0f b6 45 f1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0048e	50		 push	 eax
  0048f	8d 4d f0	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00492	51		 push	 ecx
  00493	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00496	52		 push	 edx
  00497	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0049c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4721 : 
; 4722 : 	if( pResult.Result == 0x01 )

  0049f	0f b6 45 f3	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  004a3	83 f8 01	 cmp	 eax, 1
  004a6	0f 85 2c 01 00
	00		 jne	 $LN6@DropItemDi

; 4723 : 	{
; 4724 : 		//    
; 4725 : 		if( iItemPos < MAX_EQUIPMENT ) 

  004ac	83 7d 14 0c	 cmp	 DWORD PTR _iItemPos$[ebp], 12 ; 0000000cH
  004b0	0f 8d 22 01 00
	00		 jge	 $LN6@DropItemDi

; 4726 : 		{
; 4727 : 			if( iItemPos == EQUIPMENT_RING_RIGHT || iItemPos == EQUIPMENT_RING_LEFT)

  004b6	83 7d 14 0a	 cmp	 DWORD PTR _iItemPos$[ebp], 10 ; 0000000aH
  004ba	74 06		 je	 SHORT $LN8@DropItemDi
  004bc	83 7d 14 0b	 cmp	 DWORD PTR _iItemPos$[ebp], 11 ; 0000000bH
  004c0	75 0e		 jne	 SHORT $LN7@DropItemDi
$LN8@DropItemDi:

; 4728 : 			{
; 4729 : 				gObjUseSkill.SkillChangeUse(iIndex);				

  004c2	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004c5	50		 push	 eax
  004c6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  004cb	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN7@DropItemDi:

; 4730 : 			}
; 4731 : 			gObjMakePreviewCharSet(iIndex);

  004d0	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004d3	50		 push	 eax
  004d4	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  004d9	83 c4 04	 add	 esp, 4

; 4732 : 			
; 4733 : 			PMSG_USEREQUIPMENTCHANGED	pChange;
; 4734 : 			
; 4735 : 			PHeadSetB((LPBYTE)&pChange, 0x25, sizeof( pChange ));

  004dc	6a 0a		 push	 10			; 0000000aH
  004de	6a 25		 push	 37			; 00000025H
  004e0	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _pChange$1[ebp]
  004e6	50		 push	 eax
  004e7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  004ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4736 : 
; 4737 : 			pChange.NumberH    = HIBYTE( iIndex );

  004ef	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  004f2	c1 e8 08	 shr	 eax, 8
  004f5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004fa	88 85 7b ff ff
	ff		 mov	 BYTE PTR _pChange$1[ebp+3], al

; 4738 : 			pChange.NumberL	   = LOBYTE( iIndex );

  00500	8b 45 0c	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00503	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00508	88 85 7c ff ff
	ff		 mov	 BYTE PTR _pChange$1[ebp+4], al

; 4739 : 						
; 4740 : 			//pChange.ItemInfo[0] = (BYTE)gObj[iIndex].pInventory[iItemPos].m_Type;
; 4741 : 			ItemByteConvert(pChange.ItemInfo, gObj[iIndex].pInventory[iItemPos]);

  0050e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00515	69 4d 14 a8 00
	00 00		 imul	 ecx, DWORD PTR _iItemPos$[ebp], 168
  0051c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00522	8b b4 02 5c 0c
	00 00		 mov	 esi, DWORD PTR [edx+eax+3164]
  00529	03 f1		 add	 esi, ecx
  0052b	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00531	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00536	8b fc		 mov	 edi, esp
  00538	f3 a5		 rep movsd
  0053a	8d 85 7d ff ff
	ff		 lea	 eax, DWORD PTR _pChange$1[ebp+5]
  00540	50		 push	 eax
  00541	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00546	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 4742 : 			pChange.ItemInfo[1] = iItemPos<<4;

  0054c	8b 45 14	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  0054f	c1 e0 04	 shl	 eax, 4
  00552	b9 01 00 00 00	 mov	 ecx, 1
  00557	c1 e1 00	 shl	 ecx, 0
  0055a	88 84 0d 7d ff
	ff ff		 mov	 BYTE PTR _pChange$1[ebp+ecx+5], al

; 4743 : 			pChange.ItemInfo[1]|= LevelSmallConvert(iIndex, iItemPos)&0x0F;

  00561	be 01 00 00 00	 mov	 esi, 1
  00566	c1 e6 00	 shl	 esi, 0
  00569	8b 45 14	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  0056c	50		 push	 eax
  0056d	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00570	51		 push	 ecx
  00571	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  00576	83 c4 08	 add	 esp, 8
  00579	0f b6 d0	 movzx	 edx, al
  0057c	83 e2 0f	 and	 edx, 15			; 0000000fH
  0057f	0f b6 84 35 7d
	ff ff ff	 movzx	 eax, BYTE PTR _pChange$1[ebp+esi+5]
  00587	0b c2		 or	 eax, edx
  00589	b9 01 00 00 00	 mov	 ecx, 1
  0058e	c1 e1 00	 shl	 ecx, 0
  00591	88 84 0d 7d ff
	ff ff		 mov	 BYTE PTR _pChange$1[ebp+ecx+5], al

; 4744 : 
; 4745 : 			
; 4746 : 			DataSend(iIndex, (LPBYTE)&pChange, pChange.h.size);

  00598	0f b6 85 79 ff
	ff ff		 movzx	 eax, BYTE PTR _pChange$1[ebp+1]
  0059f	50		 push	 eax
  005a0	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _pChange$1[ebp]
  005a6	51		 push	 ecx
  005a7	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  005aa	52		 push	 edx
  005ab	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4747 : 			MsgSendV2(&gObj[iIndex], (LPBYTE)&pChange, pChange.h.size);

  005b3	0f b6 85 79 ff
	ff ff		 movzx	 eax, BYTE PTR _pChange$1[ebp+1]
  005ba	50		 push	 eax
  005bb	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _pChange$1[ebp]
  005c1	51		 push	 ecx
  005c2	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  005c9	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005cf	52		 push	 edx
  005d0	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  005d5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@DropItemDi:

; 4748 : 		}
; 4749 : 	}
; 4750 : 	return pResult.Result;

  005d8	0f b6 45 f3	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
$LN1@DropItemDi:

; 4751 : }

  005dc	5f		 pop	 edi
  005dd	5e		 pop	 esi
  005de	5b		 pop	 ebx
  005df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e2	33 cd		 xor	 ecx, ebp
  005e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e9	8b e5		 mov	 esp, ebp
  005eb	5d		 pop	 ebp
  005ec	c2 10 00	 ret	 16			; 00000010H
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ENDP		; CBloodCastle::DropItemDirectly
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv93 = -88						; size = 4
tv80 = -88						; size = 4
tv66 = -88						; size = 4
tv94 = -84						; size = 4
tv81 = -84						; size = 4
tv67 = -84						; size = 4
_iIndex$1 = -16						; size = 4
_i$2 = -12						; size = 4
_iRetLiveUserCount$ = -8				; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetCurrentLiveUserCount, COMDAT
; _this$ = ecx

; 4522 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4523 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN13@GetCurrent
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN14@GetCurrent
$LN13@GetCurrent:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN11@GetCurrent
  00021	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN12@GetCurrent
$LN11@GetCurrent:
  0002a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN12@GetCurrent:
  00031	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN14@GetCurrent:
  00037	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 08		 jne	 SHORT $LN5@GetCurrent

; 4524 : 		return -1;

  0003d	83 c8 ff	 or	 eax, -1
  00040	e9 11 01 00 00	 jmp	 $LN1@GetCurrent
$LN5@GetCurrent:

; 4525 : 
; 4526 : 	int iRetLiveUserCount = 0;

  00045	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRetLiveUserCount$[ebp], 0

; 4527 : 
; 4528 : 
; 4529 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  0004c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00053	eb 09		 jmp	 SHORT $LN4@GetCurrent
$LN2@GetCurrent:
  00055	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@GetCurrent:
  0005e	83 7d f4 0a	 cmp	 DWORD PTR _i$2[ebp], 10	; 0000000aH
  00062	0f 8d eb 00 00
	00		 jge	 $LN3@GetCurrent

; 4530 : 		int iIndex = m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00068	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00076	6b 45 f4 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0007a	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0007e	89 4d f0	 mov	 DWORD PTR _iIndex$1[ebp], ecx

; 4531 : 
; 4532 : 		if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  00081	83 7d f0 00	 cmp	 DWORD PTR _iIndex$1[ebp], 0
  00085	7d 09		 jge	 SHORT $LN17@GetCurrent
  00087	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
  0008e	eb 1f		 jmp	 SHORT $LN18@GetCurrent
$LN17@GetCurrent:
  00090	81 7d f0 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$1[ebp], 7399 ; 00001ce7H
  00097	7e 09		 jle	 SHORT $LN15@GetCurrent
  00099	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  000a0	eb 07		 jmp	 SHORT $LN16@GetCurrent
$LN15@GetCurrent:
  000a2	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
$LN16@GetCurrent:
  000a9	8b 45 a8	 mov	 eax, DWORD PTR tv80[ebp]
  000ac	89 45 ac	 mov	 DWORD PTR tv81[ebp], eax
$LN18@GetCurrent:
  000af	83 7d ac 00	 cmp	 DWORD PTR tv81[ebp], 0
  000b3	75 02		 jne	 SHORT $LN6@GetCurrent

; 4533 : 			continue;

  000b5	eb 9e		 jmp	 SHORT $LN2@GetCurrent
$LN6@GetCurrent:

; 4534 : 
; 4535 : 		if (!CHECK_BLOODCASTLE(gObj[iIndex].MapNumber))

  000b7	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$1[ebp], 7072
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c4	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000cc	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  000cf	7d 09		 jge	 SHORT $LN21@GetCurrent
  000d1	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  000d8	eb 30		 jmp	 SHORT $LN22@GetCurrent
$LN21@GetCurrent:
  000da	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$1[ebp], 7072
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e7	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000ef	83 fa 11	 cmp	 edx, 17			; 00000011H
  000f2	7e 09		 jle	 SHORT $LN19@GetCurrent
  000f4	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
  000fb	eb 07		 jmp	 SHORT $LN20@GetCurrent
$LN19@GetCurrent:
  000fd	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv93[ebp], 1
$LN20@GetCurrent:
  00104	8b 45 a8	 mov	 eax, DWORD PTR tv93[ebp]
  00107	89 45 ac	 mov	 DWORD PTR tv94[ebp], eax
$LN22@GetCurrent:
  0010a	83 7d ac 00	 cmp	 DWORD PTR tv94[ebp], 0
  0010e	75 05		 jne	 SHORT $LN7@GetCurrent

; 4536 : 			continue;

  00110	e9 40 ff ff ff	 jmp	 $LN2@GetCurrent
$LN7@GetCurrent:

; 4537 : 
; 4538 : 		if (gObj[iIndex].Type != OBJTYPE_CHARACTER)

  00115	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$1[ebp], 7072
  0011c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00122	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00127	83 fa 01	 cmp	 edx, 1
  0012a	74 05		 je	 SHORT $LN8@GetCurrent

; 4539 : 			continue;

  0012c	e9 24 ff ff ff	 jmp	 $LN2@GetCurrent
$LN8@GetCurrent:

; 4540 : 
; 4541 : #ifdef FOR_ONAIR
; 4542 : 		if( gObj[iIndex].Authority&AUTHORITY_ADMIN )
; 4543 : 		{
; 4544 : 			continue;
; 4545 : 		}
; 4546 : #endif
; 4547 : 		if (gObj[iIndex].Connected > 2) {

  00131	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$1[ebp], 7072
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013e	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00143	7e 09		 jle	 SHORT $LN9@GetCurrent

; 4548 : 			iRetLiveUserCount++;

  00145	8b 45 f8	 mov	 eax, DWORD PTR _iRetLiveUserCount$[ebp]
  00148	83 c0 01	 add	 eax, 1
  0014b	89 45 f8	 mov	 DWORD PTR _iRetLiveUserCount$[ebp], eax
$LN9@GetCurrent:

; 4549 : 		}
; 4550 : 	}

  0014e	e9 02 ff ff ff	 jmp	 $LN2@GetCurrent
$LN3@GetCurrent:

; 4551 : 
; 4552 : 	return iRetLiveUserCount;

  00153	8b 45 f8	 mov	 eax, DWORD PTR _iRetLiveUserCount$[ebp]
$LN1@GetCurrent:

; 4553 : }

  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 04 00	 ret	 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetCurrentLiveUserCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv167 = -96						; size = 4
tv134 = -96						; size = 4
tv80 = -96						; size = 4
tv66 = -96						; size = 4
tv168 = -92						; size = 4
tv135 = -92						; size = 4
tv81 = -92						; size = 4
tv67 = -92						; size = 4
_iITEM_LEVEL$1 = -24					; size = 4
_x$2 = -20						; size = 4
_iIndex$3 = -16						; size = 4
_i$4 = -12						; size = 4
_iBridgeUserIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWhoGotUltimateWeapon, COMDAT
; _this$ = ecx

; 4473 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4474 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN21@GetWhoGotU
  00012	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN22@GetWhoGotU
$LN21@GetWhoGotU:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN19@GetWhoGotU
  00021	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN20@GetWhoGotU
$LN19@GetWhoGotU:
  0002a	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN20@GetWhoGotU:
  00031	8b 45 a0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN22@GetWhoGotU:
  00037	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 08		 jne	 SHORT $LN8@GetWhoGotU

; 4475 : 		return -1;

  0003d	83 c8 ff	 or	 eax, -1
  00040	e9 27 02 00 00	 jmp	 $LN1@GetWhoGotU
$LN8@GetWhoGotU:

; 4476 : 
; 4477 : 	int iBridgeUserIndex = -1;

  00045	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _iBridgeUserIndex$[ebp], -1

; 4478 : 
; 4479 : 
; 4480 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  0004c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  00053	eb 09		 jmp	 SHORT $LN4@GetWhoGotU
$LN2@GetWhoGotU:
  00055	8b 45 f4	 mov	 eax, DWORD PTR _i$4[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 f4	 mov	 DWORD PTR _i$4[ebp], eax
$LN4@GetWhoGotU:
  0005e	83 7d f4 0a	 cmp	 DWORD PTR _i$4[ebp], 10	; 0000000aH
  00062	0f 8d 01 02 00
	00		 jge	 $LN3@GetWhoGotU

; 4481 : 		int iIndex = m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00068	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00076	6b 45 f4 14	 imul	 eax, DWORD PTR _i$4[ebp], 20
  0007a	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0007e	89 4d f0	 mov	 DWORD PTR _iIndex$3[ebp], ecx

; 4482 : 
; 4483 : 		if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  00081	83 7d f0 00	 cmp	 DWORD PTR _iIndex$3[ebp], 0
  00085	7d 09		 jge	 SHORT $LN25@GetWhoGotU
  00087	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
  0008e	eb 1f		 jmp	 SHORT $LN26@GetWhoGotU
$LN25@GetWhoGotU:
  00090	81 7d f0 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$3[ebp], 7399 ; 00001ce7H
  00097	7e 09		 jle	 SHORT $LN23@GetWhoGotU
  00099	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  000a0	eb 07		 jmp	 SHORT $LN24@GetWhoGotU
$LN23@GetWhoGotU:
  000a2	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
$LN24@GetWhoGotU:
  000a9	8b 45 a0	 mov	 eax, DWORD PTR tv80[ebp]
  000ac	89 45 a4	 mov	 DWORD PTR tv81[ebp], eax
$LN26@GetWhoGotU:
  000af	83 7d a4 00	 cmp	 DWORD PTR tv81[ebp], 0
  000b3	75 02		 jne	 SHORT $LN9@GetWhoGotU

; 4484 : 			continue;

  000b5	eb 9e		 jmp	 SHORT $LN2@GetWhoGotU
$LN9@GetWhoGotU:

; 4485 : 
; 4486 : 		if ((gObj[iIndex].Type != OBJTYPE_CHARACTER) || (gObj[iIndex].Connected <= 2))

  000b7	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$3[ebp], 7072
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c4	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000c9	83 fa 01	 cmp	 edx, 1
  000cc	75 14		 jne	 SHORT $LN11@GetWhoGotU
  000ce	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$3[ebp], 7072
  000d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000db	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  000e0	7f 05		 jg	 SHORT $LN10@GetWhoGotU
$LN11@GetWhoGotU:

; 4487 : 			continue;

  000e2	e9 6e ff ff ff	 jmp	 $LN2@GetWhoGotU
$LN10@GetWhoGotU:

; 4488 : 
; 4489 : 		if (!CHECK_BLOODCASTLE(gObj[iIndex].MapNumber))

  000e7	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$3[ebp], 7072
  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f4	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000fc	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  000ff	7d 09		 jge	 SHORT $LN29@GetWhoGotU
  00101	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
  00108	eb 30		 jmp	 SHORT $LN30@GetWhoGotU
$LN29@GetWhoGotU:
  0010a	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$3[ebp], 7072
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00117	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0011f	83 fa 11	 cmp	 edx, 17			; 00000011H
  00122	7e 09		 jle	 SHORT $LN27@GetWhoGotU
  00124	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv134[ebp], 0
  0012b	eb 07		 jmp	 SHORT $LN28@GetWhoGotU
$LN27@GetWhoGotU:
  0012d	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
$LN28@GetWhoGotU:
  00134	8b 45 a0	 mov	 eax, DWORD PTR tv134[ebp]
  00137	89 45 a4	 mov	 DWORD PTR tv135[ebp], eax
$LN30@GetWhoGotU:
  0013a	83 7d a4 00	 cmp	 DWORD PTR tv135[ebp], 0
  0013e	75 05		 jne	 SHORT $LN12@GetWhoGotU

; 4490 : 			continue;

  00140	e9 10 ff ff ff	 jmp	 $LN2@GetWhoGotU
$LN12@GetWhoGotU:

; 4491 : 
; 4492 : #ifdef PERSONAL_SHOP_20040113	//          
; 4493 : 		for(int x=0; x<MAX_INVENTORY_EXTEND; x++)

  00145	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _x$2[ebp], 0
  0014c	eb 09		 jmp	 SHORT $LN7@GetWhoGotU
$LN5@GetWhoGotU:
  0014e	8b 45 ec	 mov	 eax, DWORD PTR _x$2[ebp]
  00151	83 c0 01	 add	 eax, 1
  00154	89 45 ec	 mov	 DWORD PTR _x$2[ebp], eax
$LN7@GetWhoGotU:
  00157	83 7d ec 6c	 cmp	 DWORD PTR _x$2[ebp], 108 ; 0000006cH
  0015b	0f 8d 03 01 00
	00		 jge	 $LN6@GetWhoGotU

; 4494 : #else
; 4495 : 		for(int x=0; x<MAX_INVENTORY; x++)
; 4496 : #endif
; 4497 : 		{
; 4498 : 			if( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00161	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$3[ebp], 7072
  00168	69 4d ec a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  0016f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00175	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0017c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00181	83 f8 01	 cmp	 eax, 1
  00184	0f 85 d5 00 00
	00		 jne	 $LN13@GetWhoGotU

; 4499 : 			{
; 4500 : 				if( gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(13, 19) )		//   

  0018a	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$3[ebp], 7072
  00191	69 4d ec a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  00198	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019e	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  001a5	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  001aa	6a 13		 push	 19			; 00000013H
  001ac	6a 0d		 push	 13			; 0000000dH
  001ae	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001b3	83 c4 08	 add	 esp, 8
  001b6	3b f0		 cmp	 esi, eax
  001b8	0f 85 a1 00 00
	00		 jne	 $LN13@GetWhoGotU

; 4501 : 				{
; 4502 : 					INT iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;			//   .

  001be	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$3[ebp], 7072
  001c5	69 4d ec a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  001cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d2	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  001d9	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  001de	89 4d e8	 mov	 DWORD PTR _iITEM_LEVEL$1[ebp], ecx

; 4503 : 					if (CHECK_LIMIT(iITEM_LEVEL, 3)) {

  001e1	83 7d e8 00	 cmp	 DWORD PTR _iITEM_LEVEL$1[ebp], 0
  001e5	7d 09		 jge	 SHORT $LN33@GetWhoGotU
  001e7	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv168[ebp], 0
  001ee	eb 1c		 jmp	 SHORT $LN34@GetWhoGotU
$LN33@GetWhoGotU:
  001f0	83 7d e8 02	 cmp	 DWORD PTR _iITEM_LEVEL$1[ebp], 2
  001f4	7e 09		 jle	 SHORT $LN31@GetWhoGotU
  001f6	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv167[ebp], 0
  001fd	eb 07		 jmp	 SHORT $LN32@GetWhoGotU
$LN31@GetWhoGotU:
  001ff	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
$LN32@GetWhoGotU:
  00206	8b 45 a0	 mov	 eax, DWORD PTR tv167[ebp]
  00209	89 45 a4	 mov	 DWORD PTR tv168[ebp], eax
$LN34@GetWhoGotU:
  0020c	83 7d a4 00	 cmp	 DWORD PTR tv168[ebp], 0
  00210	74 4d		 je	 SHORT $LN13@GetWhoGotU

; 4504 : 						if (m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL != -1) {

  00212	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00219	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021c	83 bc 01 90 01
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+400], -1
  00224	74 39		 je	 SHORT $LN13@GetWhoGotU

; 4505 : 							if (m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number) {

  00226	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0022d	69 4d f0 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$3[ebp], 7072
  00234	69 55 ec a8 00
	00 00		 imul	 edx, DWORD PTR _x$2[ebp], 168
  0023b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00241	8b 8c 0e 5c 0c
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+3164]
  00248	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0024b	8b 84 06 90 01
	00 00		 mov	 eax, DWORD PTR [esi+eax+400]
  00252	3b 04 11	 cmp	 eax, DWORD PTR [ecx+edx]
  00255	75 08		 jne	 SHORT $LN13@GetWhoGotU

; 4506 : 								//  . ->       
; 4507 : 								iBridgeUserIndex = iIndex;

  00257	8b 45 f0	 mov	 eax, DWORD PTR _iIndex$3[ebp]
  0025a	89 45 f8	 mov	 DWORD PTR _iBridgeUserIndex$[ebp], eax

; 4508 : 								break;

  0025d	eb 05		 jmp	 SHORT $LN6@GetWhoGotU
$LN13@GetWhoGotU:

; 4509 : 							}
; 4510 : 						}
; 4511 : 					}
; 4512 : 				}
; 4513 : 			}
; 4514 : 		}

  0025f	e9 ea fe ff ff	 jmp	 $LN5@GetWhoGotU
$LN6@GetWhoGotU:

; 4515 : 	}

  00264	e9 ec fd ff ff	 jmp	 $LN2@GetWhoGotU
$LN3@GetWhoGotU:

; 4516 : 
; 4517 : 	return iBridgeUserIndex;

  00269	8b 45 f8	 mov	 eax, DWORD PTR _iBridgeUserIndex$[ebp]
$LN1@GetWhoGotU:

; 4518 : }

  0026c	5f		 pop	 edi
  0026d	5e		 pop	 esi
  0026e	5b		 pop	 ebx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c2 04 00	 ret	 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWhoGotUltimateWeapon
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -88						; size = 4
tv67 = -84						; size = 4
_result$1 = -16						; size = 4
_i$2 = -12						; size = 4
_bRET_VAL$ = -5						; size = 1
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckAngelKingExist, COMDAT
; _this$ = ecx

; 4410 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4411 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN16@CheckAngel
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN17@CheckAngel
$LN16@CheckAngel:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN14@CheckAngel
  00021	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN15@CheckAngel
$LN14@CheckAngel:
  0002a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN15@CheckAngel:
  00031	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN17@CheckAngel:
  00037	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 07		 jne	 SHORT $LN5@CheckAngel

; 4412 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	e9 69 01 00 00	 jmp	 $LN1@CheckAngel
$LN5@CheckAngel:

; 4413 : 
; 4414 : 	bool bRET_VAL = false;

  00044	c6 45 fb 00	 mov	 BYTE PTR _bRET_VAL$[ebp], 0

; 4415 : 
; 4416 : 	if (m_BridgeData[iBridgeIndex].m_iAngelKingPosNum == -1) {

  00048	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	83 bc 01 9c 01
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+412], -1
  0005a	75 1c		 jne	 SHORT $LN6@CheckAngel

; 4417 : 		//     . ->  
; 4418 : 		LogAddTD("[Blood Castle] (%d) Angel King's Monster Position Doesn't Exist", iBridgeIndex+1);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0005f	83 c0 01	 add	 eax, 1
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8@
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0006e	83 c4 08	 add	 esp, 8

; 4419 : 		return false;

  00071	32 c0		 xor	 al, al
  00073	e9 35 01 00 00	 jmp	 $LN1@CheckAngel
$LN6@CheckAngel:

; 4420 : 	}
; 4421 : 
; 4422 : 	for( int i=0 ; i<ALLOC_USEROBJECTSTART ; i++) {

  00078	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0007f	eb 09		 jmp	 SHORT $LN4@CheckAngel
$LN2@CheckAngel:
  00081	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@CheckAngel:
  0008a	81 7d f4 00 19
	00 00		 cmp	 DWORD PTR _i$2[ebp], 6400 ; 00001900H
  00091	7d 72		 jge	 SHORT $LN3@CheckAngel

; 4423 : 		if( gObj[i].Connected == 3 && (gObj[i].Type == OBJTYPE_NPC) ) {

  00093	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 7072
  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a0	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  000a5	75 59		 jne	 SHORT $LN7@CheckAngel
  000a7	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 7072
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b4	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000b9	83 fa 03	 cmp	 edx, 3
  000bc	75 42		 jne	 SHORT $LN7@CheckAngel

; 4424 : 			if (gObj[i].Class == NPC_ANGELKING) {

  000be	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 7072
  000c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cb	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  000d3	81 fa e8 00 00
	00		 cmp	 edx, 232		; 000000e8H
  000d9	75 25		 jne	 SHORT $LN7@CheckAngel

; 4425 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    				
; 4426 : 				if (gObj[i].MapNumber == GetMapNumByBCBridge( iBridgeIndex ) ) {
; 4427 : #else
; 4428 : 				if (gObj[i].MapNumber == MAP_INDEX_BLOODCASTLE1 + iBridgeIndex) {

  000db	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$2[ebp], 7072
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e8	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000f0	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000f3	83 c0 0b	 add	 eax, 11			; 0000000bH
  000f6	3b d0		 cmp	 edx, eax
  000f8	75 06		 jne	 SHORT $LN7@CheckAngel

; 4429 : #endif
; 4430 : 					//   ->  .
; 4431 : 					bRET_VAL = true;

  000fa	c6 45 fb 01	 mov	 BYTE PTR _bRET_VAL$[ebp], 1

; 4432 : 					break;

  000fe	eb 05		 jmp	 SHORT $LN3@CheckAngel
$LN7@CheckAngel:

; 4433 : 				}
; 4434 : 			}
; 4435 : 		}
; 4436 : 	}

  00100	e9 7c ff ff ff	 jmp	 $LN2@CheckAngel
$LN3@CheckAngel:

; 4437 : 
; 4438 : 	if (!bRET_VAL) {

  00105	0f b6 45 fb	 movzx	 eax, BYTE PTR _bRET_VAL$[ebp]
  00109	85 c0		 test	 eax, eax
  0010b	0f 85 99 00 00
	00		 jne	 $LN10@CheckAngel

; 4439 : 		//  !! -> 
; 4440 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 4441 : 		int result = gObjAddMonster( GetMapNumByBCBridge( iBridgeIndex ) );
; 4442 : #else
; 4443 : #ifdef MAP_SERVER_ADD_MONSTER_20041216		//   , NPC  (     .)
; 4444 : 		int result = gObjAddMonster(MAP_INDEX_BLOODCASTLE1 + iBridgeIndex);

  00111	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00114	83 c0 0b	 add	 eax, 11			; 0000000bH
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0011d	83 c4 04	 add	 esp, 4
  00120	0f bf c8	 movsx	 ecx, ax
  00123	89 4d f0	 mov	 DWORD PTR _result$1[ebp], ecx

; 4445 : #else
; 4446 : 		int result = gObjAdd();
; 4447 : #endif
; 4448 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 4449 : 		if( result >= 0 )

  00126	83 7d f0 00	 cmp	 DWORD PTR _result$1[ebp], 0
  0012a	7c 61		 jl	 SHORT $LN11@CheckAngel

; 4450 : 		{
; 4451 : 			gObjSetPosMonster(result, m_BridgeData[iBridgeIndex].m_iAngelKingPosNum);

  0012c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00133	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	8b 94 01 9c 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+412]
  0013d	52		 push	 edx
  0013e	8b 45 f0	 mov	 eax, DWORD PTR _result$1[ebp]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster
  00147	83 c4 08	 add	 esp, 8

; 4452 : 			gObjSetMonster(result, NPC_ANGELKING);

  0014a	68 e8 00 00 00	 push	 232			; 000000e8H
  0014f	8b 45 f0	 mov	 eax, DWORD PTR _result$1[ebp]
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  00158	83 c4 08	 add	 esp, 8

; 4453 : 
; 4454 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 4455 : 			gObj[result].m_cBloodCastleIndex = GetBridgeIndexByMapNum( gObj[result].MapNumber );
; 4456 : #else
; 4457 : 			gObj[result].m_cBloodCastleIndex = gObj[result].MapNumber - MAP_INDEX_BLOODCASTLE1;

  0015b	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  00162	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00168	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00170	83 ea 0b	 sub	 edx, 11			; 0000000bH
  00173	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _result$1[ebp], 7072
  0017a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00180	88 94 01 d2 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3282], dl

; 4458 : #endif
; 4459 : 
; 4460 : 			bRET_VAL = true;

  00187	c6 45 fb 01	 mov	 BYTE PTR _bRET_VAL$[ebp], 1

; 4461 : 		}

  0018b	eb 1d		 jmp	 SHORT $LN10@CheckAngel
$LN11@CheckAngel:

; 4462 : 		else {
; 4463 : 			LogAddTD("[Blood Castle] (%d) Angel King - gObjAdd() failed (no space to add monster, result:%d)", iBridgeIndex+1, result);

  0018d	8b 45 f0	 mov	 eax, DWORD PTR _result$1[ebp]
  00190	50		 push	 eax
  00191	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00194	83 c1 01	 add	 ecx, 1
  00197	51		 push	 ecx
  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5@
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4464 : 			return false;

  001a6	32 c0		 xor	 al, al
  001a8	eb 03		 jmp	 SHORT $LN1@CheckAngel
$LN10@CheckAngel:

; 4465 : 		}
; 4466 : 	}
; 4467 : 
; 4468 : 	return bRET_VAL;

  001aa	8a 45 fb	 mov	 al, BYTE PTR _bRET_VAL$[ebp]
$LN1@CheckAngel:

; 4469 : }

  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	5b		 pop	 ebx
  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c2 04 00	 ret	 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckAngelKingExist
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv95 = -104						; size = 4
tv66 = -104						; size = 4
tv128 = -100						; size = 4
tv67 = -100						; size = 4
_pMsg$1 = -32						; size = 14
_i$2 = -16						; size = 4
_bRET_VAL$ = -9						; size = 1
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckEveryUserDie, COMDAT
; _this$ = ecx

; 4358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4359 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00016	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $LN16@CheckEvery
  0001c	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00023	eb 1c		 jmp	 SHORT $LN17@CheckEvery
$LN16@CheckEvery:
  00025	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  00029	7e 09		 jle	 SHORT $LN14@CheckEvery
  0002b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN15@CheckEvery
$LN14@CheckEvery:
  00034	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN15@CheckEvery:
  0003b	8b 45 98	 mov	 eax, DWORD PTR tv66[ebp]
  0003e	89 45 9c	 mov	 DWORD PTR tv67[ebp], eax
$LN17@CheckEvery:
  00041	83 7d 9c 00	 cmp	 DWORD PTR tv67[ebp], 0
  00045	75 07		 jne	 SHORT $LN5@CheckEvery

; 4360 : 		return false;

  00047	32 c0		 xor	 al, al
  00049	e9 f5 01 00 00	 jmp	 $LN1@CheckEvery
$LN5@CheckEvery:

; 4361 : 
; 4362 : 	bool bRET_VAL = true;

  0004e	c6 45 f7 01	 mov	 BYTE PTR _bRET_VAL$[ebp], 1

; 4363 : 
; 4364 : 	for (INT i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00052	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00059	eb 09		 jmp	 SHORT $LN4@CheckEvery
$LN2@CheckEvery:
  0005b	8b 45 f0	 mov	 eax, DWORD PTR _i$2[ebp]
  0005e	83 c0 01	 add	 eax, 1
  00061	89 45 f0	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@CheckEvery:
  00064	83 7d f0 0a	 cmp	 DWORD PTR _i$2[ebp], 10	; 0000000aH
  00068	0f 8d d2 01 00
	00		 jge	 $LN3@CheckEvery

; 4365 : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) {

  0006e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0007c	6b 45 f0 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  00080	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  00085	0f 84 b0 01 00
	00		 je	 $LN6@CheckEvery

; 4366 : 			if (!CHECK_LIMIT(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, MAX_OBJECT)) {

  0008b	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00092	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00099	6b 45 f0 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0009d	83 7c 02 18 00	 cmp	 DWORD PTR [edx+eax+24], 0
  000a2	7d 09		 jge	 SHORT $LN20@CheckEvery
  000a4	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], 0
  000ab	eb 32		 jmp	 SHORT $LN21@CheckEvery
$LN20@CheckEvery:
  000ad	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  000b4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000b7	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  000bb	6b 4d f0 14	 imul	 ecx, DWORD PTR _i$2[ebp], 20
  000bf	81 7c 08 18 e7
	1c 00 00	 cmp	 DWORD PTR [eax+ecx+24], 7399 ; 00001ce7H
  000c7	7e 09		 jle	 SHORT $LN18@CheckEvery
  000c9	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  000d0	eb 07		 jmp	 SHORT $LN19@CheckEvery
$LN18@CheckEvery:
  000d2	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
$LN19@CheckEvery:
  000d9	8b 55 98	 mov	 edx, DWORD PTR tv95[ebp]
  000dc	89 55 9c	 mov	 DWORD PTR tv128[ebp], edx
$LN21@CheckEvery:
  000df	83 7d 9c 00	 cmp	 DWORD PTR tv128[ebp], 0
  000e3	75 35		 jne	 SHORT $LN7@CheckEvery

; 4367 : 				LogAddTD("error-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d, SubIndex:%d", iBridgeIndex+1, m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);

  000e5	8b 45 f0	 mov	 eax, DWORD PTR _i$2[ebp]
  000e8	50		 push	 eax
  000e9	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  000f0	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000f3	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  000f7	6b 4d f0 14	 imul	 ecx, DWORD PTR _i$2[ebp], 20
  000fb	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  000ff	52		 push	 edx
  00100	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00103	83 c0 01	 add	 eax, 1
  00106	50		 push	 eax
  00107	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5@
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00112	83 c4 10	 add	 esp, 16			; 00000010H

; 4368 : 				continue;

  00115	e9 41 ff ff ff	 jmp	 $LN2@CheckEvery
$LN7@CheckEvery:

; 4369 : 			}
; 4370 : 
; 4371 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 4372 : 			if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber == GetMapNumByBCBridge( iBridgeIndex ) ) {
; 4373 : #else
; 4374 : 			if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber == MAP_INDEX_BLOODCASTLE1 + iBridgeIndex) {

  0011a	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00121	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00128	6b 45 f0 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0012c	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00134	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013a	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  00142	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00145	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00148	3b c1		 cmp	 eax, ecx
  0014a	75 62		 jne	 SHORT $LN8@CheckEvery

; 4375 : #endif
; 4376 : 				if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > 2) {

  0014c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00153	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0015a	6b 45 f0 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  0015e	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00166	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016c	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  00171	7e 06		 jle	 SHORT $LN10@CheckEvery

; 4377 : 					//          .
; 4378 : 					bRET_VAL = false;

  00173	c6 45 f7 00	 mov	 BYTE PTR _bRET_VAL$[ebp], 0

; 4379 : 				}

  00177	eb 30		 jmp	 SHORT $LN11@CheckEvery
$LN10@CheckEvery:

; 4380 : 				else
; 4381 : 				{
; 4382 : 					LogAddTD("error-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d, SubIndex:%d", iBridgeIndex+1, m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);

  00179	8b 45 f0	 mov	 eax, DWORD PTR _i$2[ebp]
  0017c	50		 push	 eax
  0017d	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00184	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00187	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0018b	6b 4d f0 14	 imul	 ecx, DWORD PTR _i$2[ebp], 20
  0018f	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00193	52		 push	 edx
  00194	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00197	83 c0 01	 add	 eax, 1
  0019a	50		 push	 eax
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5@
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001a6	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@CheckEvery:

; 4383 : 				}
; 4384 : 			}

  001a9	e9 8d 00 00 00	 jmp	 $LN6@CheckEvery
$LN8@CheckEvery:

; 4385 : 			else {
; 4386 : 				if (!m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg) {

  001ae	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  001bc	6b 45 f0 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  001c0	0f b6 4c 02 28	 movzx	 ecx, BYTE PTR [edx+eax+40]
  001c5	85 c9		 test	 ecx, ecx
  001c7	75 72		 jne	 SHORT $LN6@CheckEvery

; 4387 : 					//        .
; 4388 : 					m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = true;

  001c9	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  001d7	6b 45 f0 14	 imul	 eax, DWORD PTR _i$2[ebp], 20
  001db	c6 44 02 28 01	 mov	 BYTE PTR [edx+eax+40], 1

; 4389 : 
; 4390 : 					PMSG_STATEBLOODCASTLE pMsg;
; 4391 : 					PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(pMsg));

  001e0	6a 0e		 push	 14			; 0000000eH
  001e2	68 9b 00 00 00	 push	 155			; 0000009bH
  001e7	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  001ea	50		 push	 eax
  001eb	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  001f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4392 : 					pMsg.btPlayState		= BC_STATE_END;

  001f3	c6 45 e3 02	 mov	 BYTE PTR _pMsg$1[ebp+3], 2

; 4393 : 					pMsg.wRemainSec			= 0;

  001f7	33 c0		 xor	 eax, eax
  001f9	66 89 45 e4	 mov	 WORD PTR _pMsg$1[ebp+4], ax

; 4394 : 					pMsg.wMaxKillMonster	= 0;

  001fd	33 c0		 xor	 eax, eax
  001ff	66 89 45 e6	 mov	 WORD PTR _pMsg$1[ebp+6], ax

; 4395 : 					pMsg.wCurKillMonster	= 0;

  00203	33 c0		 xor	 eax, eax
  00205	66 89 45 e8	 mov	 WORD PTR _pMsg$1[ebp+8], ax

; 4396 : 					pMsg.wUserHaveWeapon	= 0;

  00209	33 c0		 xor	 eax, eax
  0020b	66 89 45 ea	 mov	 WORD PTR _pMsg$1[ebp+10], ax

; 4397 : 					pMsg.btWeaponNum		= -1;

  0020f	c6 45 ec ff	 mov	 BYTE PTR _pMsg$1[ebp+12], 255 ; 000000ffH

; 4398 : 
; 4399 : 					DataSend(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00213	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00217	50		 push	 eax
  00218	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  0021b	51		 push	 ecx
  0021c	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00223	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00226	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0022a	6b 55 f0 14	 imul	 edx, DWORD PTR _i$2[ebp], 20
  0022e	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00238	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CheckEvery:

; 4400 : 				}
; 4401 : 			}
; 4402 : 		}
; 4403 : 	}

  0023b	e9 1b fe ff ff	 jmp	 $LN2@CheckEvery
$LN3@CheckEvery:

; 4404 : 
; 4405 : 	return bRET_VAL;

  00240	8a 45 f7	 mov	 al, BYTE PTR _bRET_VAL$[ebp]
$LN1@CheckEvery:

; 4406 : }

  00243	5f		 pop	 edi
  00244	5e		 pop	 esi
  00245	5b		 pop	 ebx
  00246	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00249	33 cd		 xor	 ecx, ebp
  0024b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00250	8b e5		 mov	 esp, ebp
  00252	5d		 pop	 ebp
  00253	c2 04 00	 ret	 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckEveryUserDie
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckBossKillSuccess, COMDAT
; _this$ = ecx

; 4349 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4350 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN6@CheckBossK
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN7@CheckBossK
$LN6@CheckBossK:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN4@CheckBossK
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN5@CheckBossK
$LN4@CheckBossK:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN5@CheckBossK:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@CheckBossK:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@CheckBossK

; 4351 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 11		 jmp	 SHORT $LN1@CheckBossK
$LN2@CheckBossK:

; 4352 : 
; 4353 : 	return m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE;

  00041	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8a 84 01 61 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+353]
$LN1@CheckBossK:

; 4354 : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckBossKillSuccess
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckBossKillCount@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckBossKillCount, COMDAT
; _this$ = ecx

; 4324 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4325 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN7@CheckBossK
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN8@CheckBossK
$LN7@CheckBossK:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN5@CheckBossK
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN6@CheckBossK
$LN5@CheckBossK:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN6@CheckBossK:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN8@CheckBossK:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@CheckBossK

; 4326 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 63		 jmp	 SHORT $LN1@CheckBossK
$LN2@CheckBossK:

; 4327 : 
; 4328 : #ifdef ADD_LOG_CHECK_CAHOSCASTLE_BLOODCASTLE_EVENT_20060314
; 4329 : 	if( m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT >= m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT )

  00041	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00048	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00055	8b 84 02 88 01
	00 00		 mov	 eax, DWORD PTR [edx+eax+392]
  0005c	3b 84 0e 84 01
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+388]
  00063	7c 3d		 jl	 SHORT $LN3@CheckBossK

; 4330 : 	{
; 4331 : 		LogAddTD( "[Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success(Max Boss Kill Count:%d / Boss Kill Count:%d)"

  00065	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8b 94 01 88 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+392]
  00076	52		 push	 edx
  00077	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	8b 94 01 84 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+388]
  00088	52		 push	 edx
  00089	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0008c	83 c0 01	 add	 eax, 1
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0009b	83 c4 10	 add	 esp, 16			; 00000010H

; 4332 : 			, iBridgeIndex + 1
; 4333 : 			, m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT
; 4334 : 			, m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT 
; 4335 : 			);
; 4336 : 
; 4337 : 		return true;

  0009e	b0 01		 mov	 al, 1
  000a0	eb 02		 jmp	 SHORT $LN1@CheckBossK
$LN3@CheckBossK:

; 4338 : 	}
; 4339 : #else
; 4340 : 	if (m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT >= m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT)
; 4341 : 		return true;
; 4342 : #endif
; 4343 : 
; 4344 : 	return false;

  000a2	32 c0		 xor	 al, al
$LN1@CheckBossK:

; 4345 : }

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckBossKillCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillSuccess, COMDAT
; _this$ = ecx

; 4315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4316 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN6@CheckMonst
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN7@CheckMonst
$LN6@CheckMonst:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN4@CheckMonst
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN5@CheckMonst
$LN4@CheckMonst:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN5@CheckMonst:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@CheckMonst:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@CheckMonst

; 4317 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 11		 jmp	 SHORT $LN1@CheckMonst
$LN2@CheckMonst:

; 4318 : 
; 4319 : 	return m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE;

  00041	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8a 84 01 60 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+352]
$LN1@CheckMonst:

; 4320 : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillSuccess
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillCount, COMDAT
; _this$ = ecx

; 4290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4291 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN7@CheckMonst
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN8@CheckMonst
$LN7@CheckMonst:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN5@CheckMonst
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN6@CheckMonst
$LN5@CheckMonst:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN6@CheckMonst:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN8@CheckMonst:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@CheckMonst

; 4292 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 63		 jmp	 SHORT $LN1@CheckMonst
$LN2@CheckMonst:

; 4293 : 
; 4294 : #ifdef ADD_LOG_CHECK_CAHOSCASTLE_BLOODCASTLE_EVENT_20060314
; 4295 : 		if (m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT >= m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT)

  00041	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00048	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00055	8b 84 02 78 01
	00 00		 mov	 eax, DWORD PTR [edx+eax+376]
  0005c	3b 84 0e 74 01
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+372]
  00063	7c 3d		 jl	 SHORT $LN3@CheckMonst

; 4296 : 		{
; 4297 : 			LogAddTD( "[Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max Kill Count:%d / Kill Count:%d)"

  00065	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8b 94 01 78 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+376]
  00076	52		 push	 edx
  00077	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	8b 94 01 74 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+372]
  00088	52		 push	 edx
  00089	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0008c	83 c0 01	 add	 eax, 1
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ@
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0009b	83 c4 10	 add	 esp, 16			; 00000010H

; 4298 : 			, iBridgeIndex + 1
; 4299 : 			, m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT
; 4300 : 			, m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT 
; 4301 : 			);
; 4302 : 
; 4303 : 			return true;

  0009e	b0 01		 mov	 al, 1
  000a0	eb 02		 jmp	 SHORT $LN1@CheckMonst
$LN3@CheckMonst:

; 4304 : 		}
; 4305 : #else
; 4306 : 	if (m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT >= m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT)
; 4307 : 		return true;
; 4308 : #endif
; 4309 : 
; 4310 : 	return false;

  000a2	32 c0		 xor	 al, al
$LN1@CheckMonst:

; 4311 : }

  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetMonsterKillCount@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv138 = -92						; size = 4
tv66 = -92						; size = 4
tv139 = -88						; size = 4
tv67 = -88						; size = 4
_i$1 = -20						; size = 4
_iKILL_USER_COUNT$ = -16				; size = 4
_iLIVE_USER_COUNT$ = -12				; size = 4
_iTOT_USER_COUNT$ = -8					; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetMonsterKillCount, COMDAT
; _this$ = ecx

; 4233 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4234 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN14@SetMonster
  00012	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN15@SetMonster
$LN14@SetMonster:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN12@SetMonster
  00021	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN13@SetMonster
$LN12@SetMonster:
  0002a	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN13@SetMonster:
  00031	8b 45 a4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 a8	 mov	 DWORD PTR tv67[ebp], eax
$LN15@SetMonster:
  00037	83 7d a8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@SetMonster

; 4235 : 		return;

  0003d	e9 8f 01 00 00	 jmp	 $LN1@SetMonster
$LN5@SetMonster:

; 4236 : 
; 4237 : 	INT iTOT_USER_COUNT		= 0;

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iTOT_USER_COUNT$[ebp], 0

; 4238 : 	INT iLIVE_USER_COUNT	= 0;

  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iLIVE_USER_COUNT$[ebp], 0

; 4239 : 	INT iKILL_USER_COUNT	= 0;

  00050	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iKILL_USER_COUNT$[ebp], 0

; 4240 : 
; 4241 : 	for (INT i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00057	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0005e	eb 09		 jmp	 SHORT $LN4@SetMonster
$LN2@SetMonster:
  00060	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SetMonster:
  00069	83 7d ec 0a	 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  0006d	0f 8d ef 00 00
	00		 jge	 $LN3@SetMonster

; 4242 : 		
; 4243 : #ifdef FOR_ONAIR
; 4244 : #ifdef MODIFY_BLOODCASTLE_USERINDEX_BUGFIX_20080709
; 4245 : 		if( m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 ) continue;
; 4246 : #endif	// MODIFY_BLOODCASTLE_USERINDEX_BUGFIX_20080709
; 4247 : 		
; 4248 : 		if( CheckAuthority(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex], AUTHORITY_ADMIN) == true)
; 4249 : //			gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Authority&AUTHORITY_ADMIN )
; 4250 : 		{
; 4251 : 			continue;
; 4252 : 		}
; 4253 : #endif
; 4254 : 		
; 4255 : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) {

  00073	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00081	6b 45 ec 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00085	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  0008a	0f 84 cd 00 00
	00		 je	 $LN6@SetMonster

; 4256 : 			iTOT_USER_COUNT++;

  00090	8b 45 f8	 mov	 eax, DWORD PTR _iTOT_USER_COUNT$[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 45 f8	 mov	 DWORD PTR _iTOT_USER_COUNT$[ebp], eax

; 4257 : 
; 4258 : 			if (CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber)) {

  00099	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000a7	6b 45 ec 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000ab	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b9	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  000c1	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  000c4	7d 09		 jge	 SHORT $LN18@SetMonster
  000c6	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv139[ebp], 0
  000cd	eb 42		 jmp	 SHORT $LN19@SetMonster
$LN18@SetMonster:
  000cf	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  000d6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d9	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  000dd	6b 4d ec 14	 imul	 ecx, DWORD PTR _i$1[ebp], 20
  000e1	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ee	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  000f6	83 f9 11	 cmp	 ecx, 17			; 00000011H
  000f9	7e 09		 jle	 SHORT $LN16@SetMonster
  000fb	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
  00102	eb 07		 jmp	 SHORT $LN17@SetMonster
$LN16@SetMonster:
  00104	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv138[ebp], 1
$LN17@SetMonster:
  0010b	8b 55 a4	 mov	 edx, DWORD PTR tv138[ebp]
  0010e	89 55 a8	 mov	 DWORD PTR tv139[ebp], edx
$LN19@SetMonster:
  00111	83 7d a8 00	 cmp	 DWORD PTR tv139[ebp], 0
  00115	74 3d		 je	 SHORT $LN7@SetMonster

; 4259 : 				if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > 2) {

  00117	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0011e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00125	6b 45 ec 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00129	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00131	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00137	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  0013c	7e 0b		 jle	 SHORT $LN9@SetMonster

; 4260 : 					iLIVE_USER_COUNT++;

  0013e	8b 45 f4	 mov	 eax, DWORD PTR _iLIVE_USER_COUNT$[ebp]
  00141	83 c0 01	 add	 eax, 1
  00144	89 45 f4	 mov	 DWORD PTR _iLIVE_USER_COUNT$[ebp], eax

; 4261 : 				}

  00147	eb 09		 jmp	 SHORT $LN10@SetMonster
$LN9@SetMonster:

; 4262 : 				else {
; 4263 : 					iKILL_USER_COUNT++;

  00149	8b 45 f0	 mov	 eax, DWORD PTR _iKILL_USER_COUNT$[ebp]
  0014c	83 c0 01	 add	 eax, 1
  0014f	89 45 f0	 mov	 DWORD PTR _iKILL_USER_COUNT$[ebp], eax
$LN10@SetMonster:

; 4264 : 				
; 4265 : 				}
; 4266 : 			}

  00152	eb 09		 jmp	 SHORT $LN6@SetMonster
$LN7@SetMonster:

; 4267 : 			else {
; 4268 : 				iKILL_USER_COUNT++;

  00154	8b 45 f0	 mov	 eax, DWORD PTR _iKILL_USER_COUNT$[ebp]
  00157	83 c0 01	 add	 eax, 1
  0015a	89 45 f0	 mov	 DWORD PTR _iKILL_USER_COUNT$[ebp], eax
$LN6@SetMonster:

; 4269 : 			}
; 4270 : 		}
; 4271 : 	}

  0015d	e9 fe fe ff ff	 jmp	 $LN2@SetMonster
$LN3@SetMonster:

; 4272 : 	
; 4273 : //	m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = (iTOT_USER_COUNT * BC_PERUSER_MONSTER_KILL) - (iKILL_USER_COUNT * BC_PERUSER_MONSTER_KILL * 8 /10);
; 4274 : 
; 4275 : 	m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = iLIVE_USER_COUNT * BC_PERUSER_MONSTER_KILL;

  00162	6b 45 f4 28	 imul	 eax, DWORD PTR _iLIVE_USER_COUNT$[ebp], 40
  00166	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0016d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00170	89 84 0a 74 01
	00 00		 mov	 DWORD PTR [edx+ecx+372], eax

; 4276 : 	m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT = 0;

  00177	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0017e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	c7 84 01 78 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+376], 0

; 4277 : 
; 4278 : 	LogAddTD("[Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Current Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d",

  0018c	8b 45 f0	 mov	 eax, DWORD PTR _iKILL_USER_COUNT$[ebp]
  0018f	50		 push	 eax
  00190	8b 4d f4	 mov	 ecx, DWORD PTR _iLIVE_USER_COUNT$[ebp]
  00193	51		 push	 ecx
  00194	8b 55 f8	 mov	 edx, DWORD PTR _iTOT_USER_COUNT$[ebp]
  00197	52		 push	 edx
  00198	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0019f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	8b 94 01 78 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+376]
  001a9	52		 push	 edx
  001aa	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	8b 94 01 74 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+372]
  001bb	52		 push	 edx
  001bc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  001bf	83 c0 01	 add	 eax, 1
  001c2	50		 push	 eax
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kil@
  001c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001ce	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@SetMonster:

; 4279 : 		iBridgeIndex+1,
; 4280 : 		m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT,
; 4281 : 		m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT,
; 4282 : 		iTOT_USER_COUNT,
; 4283 : 		iLIVE_USER_COUNT,
; 4284 : 		iKILL_USER_COUNT
; 4285 : 		);
; 4286 : }

  001d1	5f		 pop	 edi
  001d2	5e		 pop	 esi
  001d3	5b		 pop	 ebx
  001d4	8b e5		 mov	 esp, ebp
  001d6	5d		 pop	 ebp
  001d7	c2 04 00	 ret	 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetMonsterKillCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -88						; size = 4
tv67 = -84						; size = 4
_j$1 = -16						; size = 4
_i$2 = -12						; size = 4
_x$3 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleDoor, COMDAT
; _this$ = ecx

; 2609 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2610 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN15@ReleaseCas
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN16@ReleaseCas
$LN15@ReleaseCas:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN13@ReleaseCas
  00021	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN14@ReleaseCas
$LN13@ReleaseCas:
  0002a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN14@ReleaseCas:
  00031	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN16@ReleaseCas:
  00037	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN11@ReleaseCas

; 2611 : 		return;

  0003d	e9 00 01 00 00	 jmp	 $LN1@ReleaseCas
$LN11@ReleaseCas:

; 2612 : 
; 2613 : 	for (INT x = 0 ; x < 3 ; x++) {

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$3[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN4@ReleaseCas
$LN2@ReleaseCas:
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _x$3[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 f8	 mov	 DWORD PTR _x$3[ebp], eax
$LN4@ReleaseCas:
  00054	83 7d f8 03	 cmp	 DWORD PTR _x$3[ebp], 3
  00058	0f 8d e4 00 00
	00		 jge	 $LN1@ReleaseCas

; 2614 : 		for (INT i = g_btCastleDoorMapXY[iBridgeIndex][x][0] ; i <= g_btCastleDoorMapXY[iBridgeIndex][x][2] ; i++) {

  0005e	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _x$3[ebp]
  00065	8d 94 88 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx*4]
  0006c	b8 01 00 00 00	 mov	 eax, 1
  00071	6b c8 00	 imul	 ecx, eax, 0
  00074	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00078	89 55 f4	 mov	 DWORD PTR _i$2[ebp], edx
  0007b	eb 09		 jmp	 SHORT $LN7@ReleaseCas
$LN5@ReleaseCas:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
$LN7@ReleaseCas:
  00086	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _x$3[ebp]
  0008d	8d 94 88 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx*4]
  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	d1 e0		 shl	 eax, 1
  0009b	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0009f	39 4d f4	 cmp	 DWORD PTR _i$2[ebp], ecx
  000a2	0f 8f 95 00 00
	00		 jg	 $LN6@ReleaseCas

; 2615 : 			for (INT j = g_btCastleDoorMapXY[iBridgeIndex][x][1] ; j <= g_btCastleDoorMapXY[iBridgeIndex][x][3] ; j++) {

  000a8	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _x$3[ebp]
  000af	8d 94 88 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx*4]
  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	c1 e0 00	 shl	 eax, 0
  000be	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  000c2	89 4d f0	 mov	 DWORD PTR _j$1[ebp], ecx
  000c5	eb 09		 jmp	 SHORT $LN10@ReleaseCas
$LN8@ReleaseCas:
  000c7	8b 45 f0	 mov	 eax, DWORD PTR _j$1[ebp]
  000ca	83 c0 01	 add	 eax, 1
  000cd	89 45 f0	 mov	 DWORD PTR _j$1[ebp], eax
$LN10@ReleaseCas:
  000d0	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _x$3[ebp]
  000d7	8d 94 88 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx*4]
  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	6b c8 03	 imul	 ecx, eax, 3
  000e6	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  000ea	39 55 f0	 cmp	 DWORD PTR _j$1[ebp], edx
  000ed	7f 49		 jg	 SHORT $LN9@ReleaseCas

; 2616 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2617 : 				int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 2618 : 				MapC[iMapNum].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] &= ~((BYTE) MAP_ATTR_BLOCK);
; 2619 : #else
; 2620 : 				MapC[MAP_INDEX_BLOODCASTLE1 + iBridgeIndex].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] &= ~((BYTE) MAP_ATTR_BLOCK);

  000ef	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000f2	83 c0 0b	 add	 eax, 11			; 0000000bH
  000f5	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000fb	8b 55 f0	 mov	 edx, DWORD PTR _j$1[ebp]
  000fe	c1 e2 08	 shl	 edx, 8
  00101	03 55 f4	 add	 edx, DWORD PTR _i$2[ebp]
  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00109	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  0010d	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00111	83 e2 fb	 and	 edx, -5			; fffffffbH
  00114	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00117	83 c0 0b	 add	 eax, 11			; 0000000bH
  0011a	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00120	8b 45 f0	 mov	 eax, DWORD PTR _j$1[ebp]
  00123	c1 e0 08	 shl	 eax, 8
  00126	03 45 f4	 add	 eax, DWORD PTR _i$2[ebp]
  00129	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0012f	8b 4c 0e 10	 mov	 ecx, DWORD PTR [esi+ecx+16]
  00133	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2621 : #endif
; 2622 : 			}

  00136	eb 8f		 jmp	 SHORT $LN8@ReleaseCas
$LN9@ReleaseCas:

; 2623 : 		}

  00138	e9 40 ff ff ff	 jmp	 $LN5@ReleaseCas
$LN6@ReleaseCas:

; 2624 : 	}

  0013d	e9 09 ff ff ff	 jmp	 $LN2@ReleaseCas
$LN1@ReleaseCas:

; 2625 : }

  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 04 00	 ret	 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleDoor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?BlockCastleDoor@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -88						; size = 4
tv67 = -84						; size = 4
_j$1 = -16						; size = 4
_i$2 = -12						; size = 4
_x$3 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleDoor, COMDAT
; _this$ = ecx

; 2589 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2590 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN15@BlockCastl
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN16@BlockCastl
$LN15@BlockCastl:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN13@BlockCastl
  00021	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN14@BlockCastl
$LN13@BlockCastl:
  0002a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN14@BlockCastl:
  00031	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN16@BlockCastl:
  00037	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN11@BlockCastl

; 2591 : 		return;

  0003d	e9 00 01 00 00	 jmp	 $LN1@BlockCastl
$LN11@BlockCastl:

; 2592 : 
; 2593 : 	for (INT x = 0 ; x < 3 ; x++) {

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$3[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN4@BlockCastl
$LN2@BlockCastl:
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _x$3[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 f8	 mov	 DWORD PTR _x$3[ebp], eax
$LN4@BlockCastl:
  00054	83 7d f8 03	 cmp	 DWORD PTR _x$3[ebp], 3
  00058	0f 8d e4 00 00
	00		 jge	 $LN1@BlockCastl

; 2594 : 		for (INT i = g_btCastleDoorMapXY[iBridgeIndex][x][0] ; i <= g_btCastleDoorMapXY[iBridgeIndex][x][2] ; i++) {

  0005e	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _x$3[ebp]
  00065	8d 94 88 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx*4]
  0006c	b8 01 00 00 00	 mov	 eax, 1
  00071	6b c8 00	 imul	 ecx, eax, 0
  00074	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  00078	89 55 f4	 mov	 DWORD PTR _i$2[ebp], edx
  0007b	eb 09		 jmp	 SHORT $LN7@BlockCastl
$LN5@BlockCastl:
  0007d	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
$LN7@BlockCastl:
  00086	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _x$3[ebp]
  0008d	8d 94 88 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx*4]
  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	d1 e0		 shl	 eax, 1
  0009b	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0009f	39 4d f4	 cmp	 DWORD PTR _i$2[ebp], ecx
  000a2	0f 8f 95 00 00
	00		 jg	 $LN6@BlockCastl

; 2595 : 			for (INT j = g_btCastleDoorMapXY[iBridgeIndex][x][1] ; j <= g_btCastleDoorMapXY[iBridgeIndex][x][3] ; j++) {

  000a8	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  000ac	8b 4d f8	 mov	 ecx, DWORD PTR _x$3[ebp]
  000af	8d 94 88 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx*4]
  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	c1 e0 00	 shl	 eax, 0
  000be	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  000c2	89 4d f0	 mov	 DWORD PTR _j$1[ebp], ecx
  000c5	eb 09		 jmp	 SHORT $LN10@BlockCastl
$LN8@BlockCastl:
  000c7	8b 45 f0	 mov	 eax, DWORD PTR _j$1[ebp]
  000ca	83 c0 01	 add	 eax, 1
  000cd	89 45 f0	 mov	 DWORD PTR _j$1[ebp], eax
$LN10@BlockCastl:
  000d0	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _x$3[ebp]
  000d7	8d 94 88 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx*4]
  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	6b c8 03	 imul	 ecx, eax, 3
  000e6	0f b6 14 0a	 movzx	 edx, BYTE PTR [edx+ecx]
  000ea	39 55 f0	 cmp	 DWORD PTR _j$1[ebp], edx
  000ed	7f 49		 jg	 SHORT $LN9@BlockCastl

; 2596 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2597 : 				int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 2598 : 				MapC[iMapNum].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] |= (BYTE) MAP_ATTR_BLOCK;
; 2599 : #else
; 2600 : 				MapC[MAP_INDEX_BLOODCASTLE1 + iBridgeIndex].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] |= (BYTE) MAP_ATTR_BLOCK;

  000ef	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000f2	83 c0 0b	 add	 eax, 11			; 0000000bH
  000f5	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000fb	8b 55 f0	 mov	 edx, DWORD PTR _j$1[ebp]
  000fe	c1 e2 08	 shl	 edx, 8
  00101	03 55 f4	 add	 edx, DWORD PTR _i$2[ebp]
  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00109	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  0010d	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00111	83 ca 04	 or	 edx, 4
  00114	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00117	83 c0 0b	 add	 eax, 11			; 0000000bH
  0011a	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00120	8b 45 f0	 mov	 eax, DWORD PTR _j$1[ebp]
  00123	c1 e0 08	 shl	 eax, 8
  00126	03 45 f4	 add	 eax, DWORD PTR _i$2[ebp]
  00129	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0012f	8b 4c 0e 10	 mov	 ecx, DWORD PTR [esi+ecx+16]
  00133	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2601 : #endif
; 2602 : 			}

  00136	eb 8f		 jmp	 SHORT $LN8@BlockCastl
$LN9@BlockCastl:

; 2603 : 		}

  00138	e9 40 ff ff ff	 jmp	 $LN5@BlockCastl
$LN6@BlockCastl:

; 2604 : 	}

  0013d	e9 09 ff ff ff	 jmp	 $LN2@BlockCastl
$LN1@BlockCastl:

; 2605 : }

  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 04 00	 ret	 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleDoor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
_j$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleBridge, COMDAT
; _this$ = ecx

; 2561 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2562 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN12@ReleaseCas
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN13@ReleaseCas
$LN12@ReleaseCas:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN10@ReleaseCas
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN11@ReleaseCas
$LN10@ReleaseCas:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN11@ReleaseCas:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN13@ReleaseCas:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN8@ReleaseCas

; 2563 : 		return;

  0003d	e9 d8 00 00 00	 jmp	 $LN1@ReleaseCas
$LN8@ReleaseCas:

; 2564 : 
; 2565 : 	for (INT i = g_btCastleBridgeMapXY[iBridgeIndex][0] ; i <= g_btCastleBridgeMapXY[iBridgeIndex][2] ; i++) 

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	6b c8 00	 imul	 ecx, eax, 0
  0004a	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0004d	0f b6 84 91 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[ecx+edx*4]
  00055	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
  00058	eb 09		 jmp	 SHORT $LN4@ReleaseCas
$LN2@ReleaseCas:
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0005d	83 c0 01	 add	 eax, 1
  00060	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@ReleaseCas:
  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	d1 e0		 shl	 eax, 1
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0006d	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[eax+ecx*4]
  00075	39 55 f8	 cmp	 DWORD PTR _i$2[ebp], edx
  00078	0f 8f 9c 00 00
	00		 jg	 $LN1@ReleaseCas

; 2566 : 	{
; 2567 : 		for (INT j = g_btCastleBridgeMapXY[iBridgeIndex][1] ; j <= g_btCastleBridgeMapXY[iBridgeIndex][3] ; j++) 

  0007e	b8 01 00 00 00	 mov	 eax, 1
  00083	c1 e0 00	 shl	 eax, 0
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00089	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[eax+ecx*4]
  00091	89 55 f4	 mov	 DWORD PTR _j$1[ebp], edx
  00094	eb 09		 jmp	 SHORT $LN7@ReleaseCas
$LN5@ReleaseCas:
  00096	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 45 f4	 mov	 DWORD PTR _j$1[ebp], eax
$LN7@ReleaseCas:
  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	6b c8 03	 imul	 ecx, eax, 3
  000a7	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  000aa	0f b6 84 91 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[ecx+edx*4]
  000b2	39 45 f4	 cmp	 DWORD PTR _j$1[ebp], eax
  000b5	7f 5e		 jg	 SHORT $LN6@ReleaseCas

; 2568 : 		{
; 2569 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2570 : 			int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 2571 : 			MapC[iMapNum].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] &= ~((BYTE) MAP_ATTR_HOLLOW);
; 2572 : #else
; 2573 : 			MapC[MAP_INDEX_BLOODCASTLE1 + iBridgeIndex].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] &= ~((BYTE) MAP_ATTR_HOLLOW);

  000b7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000ba	83 c0 0b	 add	 eax, 11			; 0000000bH
  000bd	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000c3	8b 55 f4	 mov	 edx, DWORD PTR _j$1[ebp]
  000c6	c1 e2 08	 shl	 edx, 8
  000c9	03 55 f8	 add	 edx, DWORD PTR _i$2[ebp]
  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000d1	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  000d5	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  000d9	83 e2 f7	 and	 edx, -9			; fffffff7H
  000dc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000df	83 c0 0b	 add	 eax, 11			; 0000000bH
  000e2	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000e8	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  000eb	c1 e0 08	 shl	 eax, 8
  000ee	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  000f1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000f7	8b 4c 0e 10	 mov	 ecx, DWORD PTR [esi+ecx+16]
  000fb	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2574 : #endif
; 2575 : 
; 2576 : #ifdef EXTEND_LOG_SYSTEM_05_20060823
; 2577 : 			LogAddTD("[Blood Castle] (%d) Castle Door Subsist", iBridgeIndex+1);
; 2578 : #endif // EXTEND_LOG_SYSTEM_05_20060823
; 2579 : 
; 2580 : #ifdef ADD_LOG_FOR_CASTLE_BUG_20060911
; 2581 : 			LogAddTD( "[Blood Castle][Bug Tracer] ReleaseCastleBridge-> %d", iBridgeIndex+1 );

  000fe	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00101	83 c0 01	 add	 eax, 1
  00104	50		 push	 eax
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Rele@
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00110	83 c4 08	 add	 esp, 8

; 2582 : #endif
; 2583 : 		}

  00113	eb 81		 jmp	 SHORT $LN5@ReleaseCas
$LN6@ReleaseCas:

; 2584 : 	}

  00115	e9 40 ff ff ff	 jmp	 $LN2@ReleaseCas
$LN1@ReleaseCas:

; 2585 : }

  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 04 00	 ret	 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleBridge
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?BlockCastleBridge@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
_j$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleBridge, COMDAT
; _this$ = ecx

; 2543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2544 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN12@BlockCastl
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN13@BlockCastl
$LN12@BlockCastl:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN10@BlockCastl
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN11@BlockCastl
$LN10@BlockCastl:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN11@BlockCastl:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN13@BlockCastl:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN8@BlockCastl

; 2545 : 		return;

  0003d	e9 c3 00 00 00	 jmp	 $LN1@BlockCastl
$LN8@BlockCastl:

; 2546 : 
; 2547 : 	for (INT i = g_btCastleBridgeMapXY[iBridgeIndex][0] ; i <= g_btCastleBridgeMapXY[iBridgeIndex][2] ; i++) {

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	6b c8 00	 imul	 ecx, eax, 0
  0004a	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0004d	0f b6 84 91 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[ecx+edx*4]
  00055	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
  00058	eb 09		 jmp	 SHORT $LN4@BlockCastl
$LN2@BlockCastl:
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0005d	83 c0 01	 add	 eax, 1
  00060	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@BlockCastl:
  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	d1 e0		 shl	 eax, 1
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0006d	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[eax+ecx*4]
  00075	39 55 f8	 cmp	 DWORD PTR _i$2[ebp], edx
  00078	0f 8f 87 00 00
	00		 jg	 $LN1@BlockCastl

; 2548 : 		for (INT j = g_btCastleBridgeMapXY[iBridgeIndex][1] ; j <= g_btCastleBridgeMapXY[iBridgeIndex][3] ; j++) {

  0007e	b8 01 00 00 00	 mov	 eax, 1
  00083	c1 e0 00	 shl	 eax, 0
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00089	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[eax+ecx*4]
  00091	89 55 f4	 mov	 DWORD PTR _j$1[ebp], edx
  00094	eb 09		 jmp	 SHORT $LN7@BlockCastl
$LN5@BlockCastl:
  00096	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 45 f4	 mov	 DWORD PTR _j$1[ebp], eax
$LN7@BlockCastl:
  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	6b c8 03	 imul	 ecx, eax, 3
  000a7	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  000aa	0f b6 84 91 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[ecx+edx*4]
  000b2	39 45 f4	 cmp	 DWORD PTR _j$1[ebp], eax
  000b5	7f 49		 jg	 SHORT $LN6@BlockCastl

; 2549 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2550 : 			int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 2551 : 			MapC[iMapNum].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] |= (BYTE) MAP_ATTR_HOLLOW;
; 2552 : #else
; 2553 : 			MapC[MAP_INDEX_BLOODCASTLE1 + iBridgeIndex].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] |= (BYTE) MAP_ATTR_HOLLOW;

  000b7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000ba	83 c0 0b	 add	 eax, 11			; 0000000bH
  000bd	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000c3	8b 55 f4	 mov	 edx, DWORD PTR _j$1[ebp]
  000c6	c1 e2 08	 shl	 edx, 8
  000c9	03 55 f8	 add	 edx, DWORD PTR _i$2[ebp]
  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000d1	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  000d5	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  000d9	83 ca 08	 or	 edx, 8
  000dc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000df	83 c0 0b	 add	 eax, 11			; 0000000bH
  000e2	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000e8	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  000eb	c1 e0 08	 shl	 eax, 8
  000ee	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  000f1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000f7	8b 4c 0e 10	 mov	 ecx, DWORD PTR [esi+ecx+16]
  000fb	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2554 : #endif
; 2555 : 		}

  000fe	eb 96		 jmp	 SHORT $LN5@BlockCastl
$LN6@BlockCastl:

; 2556 : 	}

  00100	e9 55 ff ff ff	 jmp	 $LN2@BlockCastl
$LN1@BlockCastl:

; 2557 : }

  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 04 00	 ret	 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleBridge
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
_j$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::ReleaseCastleEntrance, COMDAT
; _this$ = ecx

; 2525 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2526 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN12@ReleaseCas
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN13@ReleaseCas
$LN12@ReleaseCas:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN10@ReleaseCas
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN11@ReleaseCas
$LN10@ReleaseCas:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN11@ReleaseCas:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN13@ReleaseCas:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN8@ReleaseCas

; 2527 : 		return;

  0003d	e9 c3 00 00 00	 jmp	 $LN1@ReleaseCas
$LN8@ReleaseCas:

; 2528 : 
; 2529 : 	for (INT i = g_btCastleEntranceMapXY[iBridgeIndex][0] ; i <= g_btCastleEntranceMapXY[iBridgeIndex][2] ; i++) {

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	6b c8 00	 imul	 ecx, eax, 0
  0004a	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0004d	0f b6 84 91 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[ecx+edx*4]
  00055	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
  00058	eb 09		 jmp	 SHORT $LN4@ReleaseCas
$LN2@ReleaseCas:
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0005d	83 c0 01	 add	 eax, 1
  00060	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@ReleaseCas:
  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	d1 e0		 shl	 eax, 1
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0006d	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[eax+ecx*4]
  00075	39 55 f8	 cmp	 DWORD PTR _i$2[ebp], edx
  00078	0f 8f 87 00 00
	00		 jg	 $LN1@ReleaseCas

; 2530 : 		for (INT j = g_btCastleEntranceMapXY[iBridgeIndex][1] ; j <= g_btCastleEntranceMapXY[iBridgeIndex][3] ; j++) {

  0007e	b8 01 00 00 00	 mov	 eax, 1
  00083	c1 e0 00	 shl	 eax, 0
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00089	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[eax+ecx*4]
  00091	89 55 f4	 mov	 DWORD PTR _j$1[ebp], edx
  00094	eb 09		 jmp	 SHORT $LN7@ReleaseCas
$LN5@ReleaseCas:
  00096	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 45 f4	 mov	 DWORD PTR _j$1[ebp], eax
$LN7@ReleaseCas:
  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	6b c8 03	 imul	 ecx, eax, 3
  000a7	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  000aa	0f b6 84 91 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[ecx+edx*4]
  000b2	39 45 f4	 cmp	 DWORD PTR _j$1[ebp], eax
  000b5	7f 49		 jg	 SHORT $LN6@ReleaseCas

; 2531 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2532 : 			int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 2533 : 			MapC[iMapNum].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] &= ~((BYTE) MAP_ATTR_BLOCK);
; 2534 : #else
; 2535 : 			MapC[MAP_INDEX_BLOODCASTLE1 + iBridgeIndex].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] &= ~((BYTE) MAP_ATTR_BLOCK);

  000b7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000ba	83 c0 0b	 add	 eax, 11			; 0000000bH
  000bd	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000c3	8b 55 f4	 mov	 edx, DWORD PTR _j$1[ebp]
  000c6	c1 e2 08	 shl	 edx, 8
  000c9	03 55 f8	 add	 edx, DWORD PTR _i$2[ebp]
  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000d1	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  000d5	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  000d9	83 e2 fb	 and	 edx, -5			; fffffffbH
  000dc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000df	83 c0 0b	 add	 eax, 11			; 0000000bH
  000e2	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000e8	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  000eb	c1 e0 08	 shl	 eax, 8
  000ee	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  000f1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000f7	8b 4c 0e 10	 mov	 ecx, DWORD PTR [esi+ecx+16]
  000fb	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2536 : #endif
; 2537 : 		}

  000fe	eb 96		 jmp	 SHORT $LN5@ReleaseCas
$LN6@ReleaseCas:

; 2538 : 	}

  00100	e9 55 ff ff ff	 jmp	 $LN2@ReleaseCas
$LN1@ReleaseCas:

; 2539 : }

  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 04 00	 ret	 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::ReleaseCastleEntrance
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?BlockCastleEntrance@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
_j$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleEntrance, COMDAT
; _this$ = ecx

; 2507 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2508 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN12@BlockCastl
  00012	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN13@BlockCastl
$LN12@BlockCastl:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN10@BlockCastl
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN11@BlockCastl
$LN10@BlockCastl:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN11@BlockCastl:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN13@BlockCastl:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN8@BlockCastl

; 2509 : 		return;

  0003d	e9 c3 00 00 00	 jmp	 $LN1@BlockCastl
$LN8@BlockCastl:

; 2510 : 
; 2511 : 	for (INT i = g_btCastleEntranceMapXY[iBridgeIndex][0] ; i <= g_btCastleEntranceMapXY[iBridgeIndex][2] ; i++) {

  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	6b c8 00	 imul	 ecx, eax, 0
  0004a	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0004d	0f b6 84 91 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[ecx+edx*4]
  00055	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
  00058	eb 09		 jmp	 SHORT $LN4@BlockCastl
$LN2@BlockCastl:
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0005d	83 c0 01	 add	 eax, 1
  00060	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@BlockCastl:
  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	d1 e0		 shl	 eax, 1
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0006d	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[eax+ecx*4]
  00075	39 55 f8	 cmp	 DWORD PTR _i$2[ebp], edx
  00078	0f 8f 87 00 00
	00		 jg	 $LN1@BlockCastl

; 2512 : 		for (INT j = g_btCastleEntranceMapXY[iBridgeIndex][1] ; j <= g_btCastleEntranceMapXY[iBridgeIndex][3] ; j++) {

  0007e	b8 01 00 00 00	 mov	 eax, 1
  00083	c1 e0 00	 shl	 eax, 0
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00089	0f b6 94 88 00
	00 00 00	 movzx	 edx, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[eax+ecx*4]
  00091	89 55 f4	 mov	 DWORD PTR _j$1[ebp], edx
  00094	eb 09		 jmp	 SHORT $LN7@BlockCastl
$LN5@BlockCastl:
  00096	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 45 f4	 mov	 DWORD PTR _j$1[ebp], eax
$LN7@BlockCastl:
  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	6b c8 03	 imul	 ecx, eax, 3
  000a7	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  000aa	0f b6 84 91 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[ecx+edx*4]
  000b2	39 45 f4	 cmp	 DWORD PTR _j$1[ebp], eax
  000b5	7f 49		 jg	 SHORT $LN6@BlockCastl

; 2513 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2514 : 			int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 2515 : 			MapC[iMapNum].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] |= (BYTE) MAP_ATTR_BLOCK;
; 2516 : #else
; 2517 : 			MapC[MAP_INDEX_BLOODCASTLE1 + iBridgeIndex].m_attrbuf[(j*MAX_TERRAIN_SIZE)+i] |= (BYTE) MAP_ATTR_BLOCK;

  000b7	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000ba	83 c0 0b	 add	 eax, 11			; 0000000bH
  000bd	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000c3	8b 55 f4	 mov	 edx, DWORD PTR _j$1[ebp]
  000c6	c1 e2 08	 shl	 edx, 8
  000c9	03 55 f8	 add	 edx, DWORD PTR _i$2[ebp]
  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000d1	8b 4c 08 10	 mov	 ecx, DWORD PTR [eax+ecx+16]
  000d5	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  000d9	83 ca 04	 or	 edx, 4
  000dc	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  000df	83 c0 0b	 add	 eax, 11			; 0000000bH
  000e2	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000e8	8b 45 f4	 mov	 eax, DWORD PTR _j$1[ebp]
  000eb	c1 e0 08	 shl	 eax, 8
  000ee	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  000f1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000f7	8b 4c 0e 10	 mov	 ecx, DWORD PTR [esi+ecx+16]
  000fb	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2518 : #endif
; 2519 : 		}

  000fe	eb 96		 jmp	 SHORT $LN5@BlockCastl
$LN6@BlockCastl:

; 2520 : 	}

  00100	e9 55 ff ff ff	 jmp	 $LN2@BlockCastl
$LN1@BlockCastl:

; 2521 : }

  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c2 04 00	 ret	 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleEntrance
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
tv71 = -80						; size = 4
tv66 = -80						; size = 4
tv72 = -76						; size = 4
tv67 = -76						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserBridgeMember, COMDAT
; _this$ = ecx

; 2866 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2867 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN11@CheckUserB
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN12@CheckUserB
$LN11@CheckUserB:
  0001b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN9@CheckUserB
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN10@CheckUserB
$LN9@CheckUserB:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN10@CheckUserB:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN12@CheckUserB:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN5@CheckUserB

; 2868 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 73		 jmp	 SHORT $LN1@CheckUserB
$LN5@CheckUserB:

; 2869 : 
; 2870 : 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  00041	83 7d 0c 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00045	7d 09		 jge	 SHORT $LN15@CheckUserB
  00047	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  0004e	eb 1f		 jmp	 SHORT $LN16@CheckUserB
$LN15@CheckUserB:
  00050	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00057	7e 09		 jle	 SHORT $LN13@CheckUserB
  00059	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00060	eb 07		 jmp	 SHORT $LN14@CheckUserB
$LN13@CheckUserB:
  00062	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN14@CheckUserB:
  00069	8b 45 b0	 mov	 eax, DWORD PTR tv71[ebp]
  0006c	89 45 b4	 mov	 DWORD PTR tv72[ebp], eax
$LN16@CheckUserB:
  0006f	83 7d b4 00	 cmp	 DWORD PTR tv72[ebp], 0
  00073	75 04		 jne	 SHORT $LN6@CheckUserB

; 2871 : 		return false;

  00075	32 c0		 xor	 al, al
  00077	eb 3b		 jmp	 SHORT $LN1@CheckUserB
$LN6@CheckUserB:

; 2872 : 
; 2873 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00079	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00080	eb 09		 jmp	 SHORT $LN4@CheckUserB
$LN2@CheckUserB:
  00082	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@CheckUserB:
  0008b	83 7d f8 0a	 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  0008f	7d 21		 jge	 SHORT $LN3@CheckUserB

; 2874 : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iIndex) {

  00091	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0009f	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000a3	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  000a7	3b 4d 0c	 cmp	 ecx, DWORD PTR _iIndex$[ebp]
  000aa	75 04		 jne	 SHORT $LN7@CheckUserB

; 2875 : 			return true;

  000ac	b0 01		 mov	 al, 1
  000ae	eb 04		 jmp	 SHORT $LN1@CheckUserB
$LN7@CheckUserB:

; 2876 : 		}
; 2877 : 	}

  000b0	eb d0		 jmp	 SHORT $LN2@CheckUserB
$LN3@CheckUserB:

; 2878 : 
; 2879 : 	return false;

  000b2	32 c0		 xor	 al, al
$LN1@CheckUserB:

; 2880 : }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 08 00	 ret	 8
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserBridgeMember
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SendNoticeState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv66 = -100						; size = 4
tv67 = -96						; size = 4
_i$1 = -28						; size = 4
_pMsg$ = -24						; size = 14
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iPlayState$ = 12					; size = 4
?SendNoticeState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SendNoticeState, COMDAT
; _this$ = ecx

; 2834 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2835 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00016	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $LN13@SendNotice
  0001c	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00023	eb 1c		 jmp	 SHORT $LN14@SendNotice
$LN13@SendNotice:
  00025	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  00029	7e 09		 jle	 SHORT $LN11@SendNotice
  0002b	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN12@SendNotice
$LN11@SendNotice:
  00034	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN12@SendNotice:
  0003b	8b 45 9c	 mov	 eax, DWORD PTR tv66[ebp]
  0003e	89 45 a0	 mov	 DWORD PTR tv67[ebp], eax
$LN14@SendNotice:
  00041	83 7d a0 00	 cmp	 DWORD PTR tv67[ebp], 0
  00045	75 05		 jne	 SHORT $LN5@SendNotice

; 2836 : 		return;

  00047	e9 af 01 00 00	 jmp	 $LN1@SendNotice
$LN5@SendNotice:

; 2837 : 
; 2838 : //	return;
; 2839 : 	PMSG_STATEBLOODCASTLE pMsg;
; 2840 : 	PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(pMsg));

  0004c	6a 0e		 push	 14			; 0000000eH
  0004e	68 9b 00 00 00	 push	 155			; 0000009bH
  00053	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2841 : 	pMsg.btPlayState		= iPlayState;

  0005f	8a 45 0c	 mov	 al, BYTE PTR _iPlayState$[ebp]
  00062	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2842 : 	pMsg.wRemainSec			= m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  00065	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00076	99		 cdq
  00077	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0007c	f7 f9		 idiv	 ecx
  0007e	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 2843 : 
; 2844 : 	if (iPlayState == BC_STATE_PLAY_BOSS) {

  00082	83 7d 0c 04	 cmp	 DWORD PTR _iPlayState$[ebp], 4
  00086	75 2e		 jne	 SHORT $LN6@SendNotice

; 2845 : 		pMsg.wMaxKillMonster	= m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT;

  00088	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	66 8b 94 01 84
	01 00 00	 mov	 dx, WORD PTR [ecx+eax+388]
  0009a	66 89 55 ee	 mov	 WORD PTR _pMsg$[ebp+6], dx

; 2846 : 		pMsg.wCurKillMonster	= m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT;

  0009e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	66 8b 94 01 88
	01 00 00	 mov	 dx, WORD PTR [ecx+eax+392]
  000b0	66 89 55 f0	 mov	 WORD PTR _pMsg$[ebp+8], dx

; 2847 : 	}

  000b4	eb 2c		 jmp	 SHORT $LN7@SendNotice
$LN6@SendNotice:

; 2848 : 	else {
; 2849 : 		pMsg.wMaxKillMonster	= m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT;

  000b6	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	66 8b 94 01 74
	01 00 00	 mov	 dx, WORD PTR [ecx+eax+372]
  000c8	66 89 55 ee	 mov	 WORD PTR _pMsg$[ebp+6], dx

; 2850 : 		pMsg.wCurKillMonster	= m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT;

  000cc	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	66 8b 94 01 78
	01 00 00	 mov	 dx, WORD PTR [ecx+eax+376]
  000de	66 89 55 f0	 mov	 WORD PTR _pMsg$[ebp+8], dx
$LN7@SendNotice:

; 2851 : 	}
; 2852 : 
; 2853 : 	pMsg.wUserHaveWeapon	= m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX;

  000e2	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	66 8b 94 01 94
	01 00 00	 mov	 dx, WORD PTR [ecx+eax+404]
  000f4	66 89 55 f2	 mov	 WORD PTR _pMsg$[ebp+10], dx

; 2854 : 	pMsg.btWeaponNum		= m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER + 1;	//     .

  000f8	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	0f b6 94 01 98
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+408]
  0010a	83 c2 01	 add	 edx, 1
  0010d	88 55 f4	 mov	 BYTE PTR _pMsg$[ebp+12], dl

; 2855 : 
; 2856 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00110	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00117	eb 09		 jmp	 SHORT $LN4@SendNotice
$LN2@SendNotice:
  00119	8b 45 e4	 mov	 eax, DWORD PTR _i$1[ebp]
  0011c	83 c0 01	 add	 eax, 1
  0011f	89 45 e4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SendNotice:
  00122	83 7d e4 0a	 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  00126	0f 8d cf 00 00
	00		 jge	 $LN1@SendNotice

; 2857 : 		if ((m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) && (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > 2)) {

  0012c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00133	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0013a	6b 45 e4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0013e	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  00143	0f 84 ad 00 00
	00		 je	 $LN8@SendNotice
  00149	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00150	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00157	6b 45 e4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0015b	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00163	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00169	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  0016e	0f 8e 82 00 00
	00		 jle	 $LN8@SendNotice

; 2858 : 			if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1) && (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1))

  00174	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0017b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00182	6b 45 e4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00186	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0018e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00194	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  0019c	83 f8 ff	 cmp	 eax, -1
  0019f	74 55		 je	 SHORT $LN8@SendNotice
  001a1	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  001af	6b 45 e4 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  001b3	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  001bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c1	0f be 84 0a d3
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3283]
  001c9	83 f8 ff	 cmp	 eax, -1
  001cc	74 28		 je	 SHORT $LN8@SendNotice

; 2859 : 				DataSend(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  001ce	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001d2	50		 push	 eax
  001d3	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001d6	51		 push	 ecx
  001d7	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  001de	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001e1	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  001e5	6b 55 e4 14	 imul	 edx, DWORD PTR _i$1[ebp], 20
  001e9	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@SendNotice:

; 2860 : 		}
; 2861 : 	}

  001f6	e9 1e ff ff ff	 jmp	 $LN2@SendNotice
$LN1@SendNotice:

; 2862 : }

  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00201	33 cd		 xor	 ecx, ebp
  00203	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 08 00	 ret	 8
?SendNoticeState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SendNoticeState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SendNoticeScore@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -356						; size = 4
tv67 = -352						; size = 4
_i$1 = -284						; size = 4
_pNotice$ = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SendNoticeScore, COMDAT
; _this$ = ecx

; 2808 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2809 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00019	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0001d	7d 0c		 jge	 SHORT $LN11@SendNotice
  0001f	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00029	eb 28		 jmp	 SHORT $LN12@SendNotice
$LN11@SendNotice:
  0002b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0002f	7e 0c		 jle	 SHORT $LN9@SendNotice
  00031	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN10@SendNotice
$LN9@SendNotice:
  0003d	c7 85 9c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN10@SendNotice:
  00047	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN12@SendNotice:
  00053	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 05		 jne	 SHORT $LN5@SendNotice

; 2810 : 		return;

  0005c	e9 5a 01 00 00	 jmp	 $LN1@SendNotice
$LN5@SendNotice:

; 2811 : 
; 2812 : 	PMSG_NOTICE	pNotice;
; 2813 : 		
; 2814 : 	pNotice.type = 0;

  00061	c6 85 eb fe ff
	ff 00		 mov	 BYTE PTR _pNotice$[ebp+3], 0

; 2815 : 
; 2816 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00068	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  00072	eb 0f		 jmp	 SHORT $LN4@SendNotice
$LN2@SendNotice:
  00074	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  0007a	83 c0 01	 add	 eax, 1
  0007d	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SendNotice:
  00083	83 bd e4 fe ff
	ff 0a		 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  0008a	0f 8d 2b 01 00
	00		 jge	 $LN1@SendNotice

; 2817 : 		if ((m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) && (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > 2)) {

  00090	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0009e	6b 85 e4 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$1[ebp], 20
  000a5	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  000aa	0f 84 06 01 00
	00		 je	 $LN6@SendNotice
  000b0	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000be	6b 85 e4 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$1[ebp], 20
  000c5	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d3	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  000d8	0f 8e d8 00 00
	00		 jle	 $LN6@SendNotice

; 2818 : 			if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1) && (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1)) {

  000de	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000e5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000ec	6b 85 e4 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$1[ebp], 20
  000f3	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00101	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  00109	83 f8 ff	 cmp	 eax, -1
  0010c	0f 84 a4 00 00
	00		 je	 $LN6@SendNotice
  00112	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00119	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00120	6b 85 e4 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$1[ebp], 20
  00127	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0012f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00135	0f be 84 0a d3
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3283]
  0013d	83 f8 ff	 cmp	 eax, -1
  00140	74 74		 je	 SHORT $LN6@SendNotice

; 2819 : 
; 2820 : #ifdef MODIFY_NOTICE_20040325
; 2821 : 				TNotice::MakeNoticeMsgEx( &pNotice, 0, lMsg.Get(1164), iBridgeIndex+1, m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP);

  00142	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00149	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00150	6b 85 e4 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$1[ebp], 20
  00157	8b 4c 02 1c	 mov	 ecx, DWORD PTR [edx+eax+28]
  0015b	51		 push	 ecx
  0015c	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0015f	83 c2 01	 add	 edx, 1
  00162	52		 push	 edx
  00163	68 8c 04 00 00	 push	 1164			; 0000048cH
  00168	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00173	50		 push	 eax
  00174	6a 00		 push	 0
  00176	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  00182	83 c4 14	 add	 esp, 20			; 00000014H

; 2822 : #else
; 2823 : 				wsprintf(pNotice.Notice, lMsg.Get(1164), iBridgeIndex+1, m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP);	// " %d       %d ."
; 2824 : 				PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 2825 : #endif
; 2826 : 				DataSend(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00185	0f b6 85 e9 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  0018c	50		 push	 eax
  0018d	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  00193	51		 push	 ecx
  00194	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  0019b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019e	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  001a2	6b 95 e4 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$1[ebp], 20
  001a9	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  001ad	50		 push	 eax
  001ae	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SendNotice:

; 2827 : 			}
; 2828 : 		}
; 2829 : 	}

  001b6	e9 b9 fe ff ff	 jmp	 $LN2@SendNotice
$LN1@SendNotice:

; 2830 : }

  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx
  001be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c1	33 cd		 xor	 ecx, ebp
  001c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c2 04 00	 ret	 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SendNoticeScore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z
_TEXT	SEGMENT
tv66 = -356						; size = 4
tv67 = -352						; size = 4
_i$1 = -284						; size = 4
_pNotice$ = -280					; size = 272
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_lpszMSG$ = 12						; size = 4
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z PROC	; CBloodCastle::SendNoticeMessage, COMDAT
; _this$ = ecx

; 2784 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2785 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00019	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0001d	7d 0c		 jge	 SHORT $LN11@SendNotice
  0001f	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00029	eb 28		 jmp	 SHORT $LN12@SendNotice
$LN11@SendNotice:
  0002b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0002f	7e 0c		 jle	 SHORT $LN9@SendNotice
  00031	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN10@SendNotice
$LN9@SendNotice:
  0003d	c7 85 9c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN10@SendNotice:
  00047	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN12@SendNotice:
  00053	83 bd a0 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 05		 jne	 SHORT $LN5@SendNotice

; 2786 : 		return;

  0005c	e9 21 01 00 00	 jmp	 $LN1@SendNotice
$LN5@SendNotice:

; 2787 : 
; 2788 : 	PMSG_NOTICE	pNotice;
; 2789 : 
; 2790 : #ifdef MODIFY_NOTICE_20040325
; 2791 : 	TNotice::MakeNoticeMsg( &pNotice, 0, lpszMSG );

  00061	8b 45 0c	 mov	 eax, DWORD PTR _lpszMSG$[ebp]
  00064	50		 push	 eax
  00065	6a 00		 push	 0
  00067	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2792 : #else
; 2793 : 	pNotice.type = 0;
; 2794 : 	strcpy(pNotice.Notice, lpszMSG);
; 2795 : 	PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 2796 : #endif
; 2797 : 
; 2798 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00076	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  00080	eb 0f		 jmp	 SHORT $LN4@SendNotice
$LN2@SendNotice:
  00082	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00088	83 c0 01	 add	 eax, 1
  0008b	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SendNotice:
  00091	83 bd e4 fe ff
	ff 0a		 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  00098	0f 8d e4 00 00
	00		 jge	 $LN1@SendNotice

; 2799 : 		if ((m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) && (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > 2)) {

  0009e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000ac	6b 85 e4 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$1[ebp], 20
  000b3	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  000b8	0f 84 bf 00 00
	00		 je	 $LN6@SendNotice
  000be	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000cc	6b 85 e4 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$1[ebp], 20
  000d3	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e1	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  000e6	0f 8e 91 00 00
	00		 jle	 $LN6@SendNotice

; 2800 : 			if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1) && (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1))

  000ec	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000fa	6b 85 e4 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$1[ebp], 20
  00101	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00109	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010f	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  00117	83 f8 ff	 cmp	 eax, -1
  0011a	74 61		 je	 SHORT $LN6@SendNotice
  0011c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00123	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0012a	6b 85 e4 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$1[ebp], 20
  00131	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00139	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013f	0f be 84 0a d3
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3283]
  00147	83 f8 ff	 cmp	 eax, -1
  0014a	74 31		 je	 SHORT $LN6@SendNotice

; 2801 : 				DataSend(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  0014c	0f b6 85 e9 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  00153	50		 push	 eax
  00154	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$[ebp]
  0015a	51		 push	 ecx
  0015b	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00162	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00165	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00169	6b 95 e4 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$1[ebp], 20
  00170	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SendNotice:

; 2802 : 		}
; 2803 : 	}

  0017d	e9 00 ff ff ff	 jmp	 $LN2@SendNotice
$LN1@SendNotice:

; 2804 : }

  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5b		 pop	 ebx
  00185	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00188	33 cd		 xor	 ecx, ebp
  0018a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 08 00	 ret	 8
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ENDP	; CBloodCastle::SendNoticeMessage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z
_TEXT	SEGMENT
tv66 = -80						; size = 4
tv67 = -76						; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
_iBridgeIndex$ = 16					; size = 4
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z PROC	; CBloodCastle::SendBridgeAnyMsg, COMDAT
; _this$ = ecx

; 4203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4204 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  0000c	83 7d 10 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN12@SendBridge
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1c		 jmp	 SHORT $LN13@SendBridge
$LN12@SendBridge:
  0001b	83 7d 10 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0001f	7e 09		 jle	 SHORT $LN10@SendBridge
  00021	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN11@SendBridge
$LN10@SendBridge:
  0002a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN11@SendBridge:
  00031	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN13@SendBridge:
  00037	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 05		 jne	 SHORT $LN5@SendBridge

; 4205 : 		return;

  0003d	e9 ea 00 00 00	 jmp	 $LN1@SendBridge
$LN5@SendBridge:

; 4206 : 
; 4207 : 	for (INT i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN4@SendBridge
$LN2@SendBridge:
  0004b	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0004e	83 c0 01	 add	 eax, 1
  00051	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SendBridge:
  00054	83 7d f8 0a	 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  00058	0f 8d ce 00 00
	00		 jge	 $LN1@SendBridge

; 4208 : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1) {

  0005e	69 45 10 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0006c	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00070	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  00075	0f 84 ac 00 00
	00		 je	 $LN6@SendBridge

; 4209 : 			if(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected == 3)

  0007b	69 45 10 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00089	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0008d	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009b	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  000a0	0f 85 81 00 00
	00		 jne	 $LN6@SendBridge

; 4210 : 			{
; 4211 : 				//           .
; 4212 : 				if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1) && (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1))

  000a6	69 45 10 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000b4	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000b8	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c6	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  000ce	83 f8 ff	 cmp	 eax, -1
  000d1	74 54		 je	 SHORT $LN6@SendBridge
  000d3	69 45 10 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  000e1	6b 45 f8 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  000e5	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  000ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f3	0f be 84 0a d3
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3283]
  000fb	83 f8 ff	 cmp	 eax, -1
  000fe	74 27		 je	 SHORT $LN6@SendBridge

; 4213 : 					DataSend(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)lpMsg, iSize);

  00100	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  00103	50		 push	 eax
  00104	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00107	51		 push	 ecx
  00108	69 55 10 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  0010f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00112	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00116	6b 55 f8 14	 imul	 edx, DWORD PTR _i$1[ebp], 20
  0011a	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SendBridge:

; 4214 : 			}
; 4215 : 		}
; 4216 : 	}

  00127	e9 1f ff ff ff	 jmp	 $LN2@SendBridge
$LN1@SendBridge:

; 4217 : }

  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 0c 00	 ret	 12			; 0000000cH
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ENDP	; CBloodCastle::SendBridgeAnyMsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z PROC	; CBloodCastle::SendAllUserAnyMsg, COMDAT
; _this$ = ecx

; 4221 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4222 : 	for( int i=ALLOC_USEROBJECTSTART ; i<MAX_OBJECT; i++)

  0000c	c7 45 f8 00 19
	00 00		 mov	 DWORD PTR _i$1[ebp], 6400 ; 00001900H
  00013	eb 09		 jmp	 SHORT $LN4@SendAllUse
$LN2@SendAllUse:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SendAllUse:
  0001e	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _i$1[ebp], 7400 ; 00001ce8H
  00025	7d 41		 jge	 SHORT $LN1@SendAllUse

; 4223 : 	{
; 4224 : 		if( (gObj[i].Connected == 3) && (gObj[i].Type == OBJTYPE_CHARACTER))

  00027	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 7072
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00039	75 2b		 jne	 SHORT $LN5@SendAllUse
  0003b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 7072
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00048	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0004d	83 fa 01	 cmp	 edx, 1
  00050	75 14		 jne	 SHORT $LN5@SendAllUse

; 4225 : 		{
; 4226 : 			DataSend(i, (LPBYTE)lpMsg, iSize);

  00052	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  00055	50		 push	 eax
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00059	51		 push	 ecx
  0005a	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@SendAllUse:

; 4227 : 		}
; 4228 : 	}

  00066	eb ad		 jmp	 SHORT $LN2@SendAllUse
$LN1@SendAllUse:

; 4229 : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ENDP	; CBloodCastle::SendAllUserAnyMsg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
tv66 = -348						; size = 4
tv67 = -344						; size = 4
tv80 = -341						; size = 1
_i$1 = -276						; size = 4
_lpMsgBody$ = -272					; size = 4
_lpMsg$ = -268						; size = 4
_cTEMP_BUF$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleDoorBlockInfo, COMDAT
; _this$ = ecx

; 2742 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2743 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00019	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0001d	7d 0c		 jge	 SHORT $LN10@SendCastle
  0001f	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00029	eb 28		 jmp	 SHORT $LN11@SendCastle
$LN10@SendCastle:
  0002b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0002f	7e 0c		 jle	 SHORT $LN8@SendCastle
  00031	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN9@SendCastle
$LN8@SendCastle:
  0003d	c7 85 a4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN9@SendCastle:
  00047	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN11@SendCastle:
  00053	83 bd a8 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 05		 jne	 SHORT $LN5@SendCastle

; 2744 : 		return;

  0005c	e9 29 03 00 00	 jmp	 $LN1@SendCastle
$LN5@SendCastle:

; 2745 : 
; 2746 : 	char cTEMP_BUF [256];
; 2747 : 	LPPMSG_SETMAPATTR_COUNT lpMsg = (LPPMSG_SETMAPATTR_COUNT) cTEMP_BUF;

  00061	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00067	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2748 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT) + sizeof(PMSG_SETMAPATTR) * 2 * 3);

  0006d	6a 13		 push	 19			; 00000013H
  0006f	6a 46		 push	 70			; 00000046H
  00071	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2749 : 
; 2750 : 	LPPMSG_SETMAPATTR lpMsgBody = (LPPMSG_SETMAPATTR) (cTEMP_BUF + sizeof(PMSG_SETMAPATTR_COUNT));

  00080	8d 85 ff fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp+7]
  00086	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 2751 : 
; 2752 : 	lpMsg->btType = 0;

  0008c	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00092	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 2753 : 	lpMsg->btCount = 3;

  00096	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0009c	c6 40 06 03	 mov	 BYTE PTR [eax+6], 3

; 2754 : 	lpMsg->btMapAttr = MAP_ATTR_BLOCK;

  000a0	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a6	c6 40 04 04	 mov	 BYTE PTR [eax+4], 4

; 2755 : 	(bLive) ? lpMsg->btMapSetType = 0 : lpMsg->btMapSetType = 1;

  000aa	0f b6 45 0c	 movzx	 eax, BYTE PTR _bLive$[ebp]
  000ae	85 c0		 test	 eax, eax
  000b0	74 13		 je	 SHORT $LN12@SendCastle
  000b2	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000b8	c6 41 05 00	 mov	 BYTE PTR [ecx+5], 0
  000bc	c6 85 ab fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
  000c3	eb 11		 jmp	 SHORT $LN13@SendCastle
$LN12@SendCastle:
  000c5	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000cb	c6 42 05 01	 mov	 BYTE PTR [edx+5], 1
  000cf	c6 85 ab fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
$LN13@SendCastle:

; 2756 : 
; 2757 : 	lpMsgBody[0].btX = g_btCastleDoorMapXY[iBridgeIndex][0][0];

  000d6	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  000da	b9 04 00 00 00	 mov	 ecx, 4
  000df	6b d1 00	 imul	 edx, ecx, 0
  000e2	8d 84 10 00 00
	00 00		 lea	 eax, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+edx]
  000e9	b9 01 00 00 00	 mov	 ecx, 1
  000ee	6b d1 00	 imul	 edx, ecx, 0
  000f1	b9 02 00 00 00	 mov	 ecx, 2
  000f6	6b c9 00	 imul	 ecx, ecx, 0
  000f9	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  000ff	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  00102	88 14 0e	 mov	 BYTE PTR [esi+ecx], dl

; 2758 : 	lpMsgBody[0].btY = g_btCastleDoorMapXY[iBridgeIndex][0][1];

  00105	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  00109	b9 04 00 00 00	 mov	 ecx, 4
  0010e	6b d1 00	 imul	 edx, ecx, 0
  00111	8d 84 10 00 00
	00 00		 lea	 eax, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+edx]
  00118	b9 01 00 00 00	 mov	 ecx, 1
  0011d	c1 e1 00	 shl	 ecx, 0
  00120	ba 02 00 00 00	 mov	 edx, 2
  00125	6b d2 00	 imul	 edx, edx, 0
  00128	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  0012e	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00131	88 44 16 01	 mov	 BYTE PTR [esi+edx+1], al

; 2759 : 	lpMsgBody[1].btX = g_btCastleDoorMapXY[iBridgeIndex][0][2];

  00135	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  00139	b9 04 00 00 00	 mov	 ecx, 4
  0013e	6b d1 00	 imul	 edx, ecx, 0
  00141	8d 84 10 00 00
	00 00		 lea	 eax, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+edx]
  00148	b9 01 00 00 00	 mov	 ecx, 1
  0014d	d1 e1		 shl	 ecx, 1
  0014f	ba 02 00 00 00	 mov	 edx, 2
  00154	c1 e2 00	 shl	 edx, 0
  00157	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  0015d	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00160	88 04 16	 mov	 BYTE PTR [esi+edx], al

; 2760 : 	lpMsgBody[1].btY = g_btCastleDoorMapXY[iBridgeIndex][0][3];

  00163	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  00167	b9 04 00 00 00	 mov	 ecx, 4
  0016c	6b d1 00	 imul	 edx, ecx, 0
  0016f	8d 84 10 00 00
	00 00		 lea	 eax, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+edx]
  00176	b9 01 00 00 00	 mov	 ecx, 1
  0017b	6b d1 03	 imul	 edx, ecx, 3
  0017e	b9 02 00 00 00	 mov	 ecx, 2
  00183	c1 e1 00	 shl	 ecx, 0
  00186	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  0018c	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  0018f	88 54 0e 01	 mov	 BYTE PTR [esi+ecx+1], dl

; 2761 : 	lpMsgBody[2].btX = g_btCastleDoorMapXY[iBridgeIndex][1][0];

  00193	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  00197	b9 04 00 00 00	 mov	 ecx, 4
  0019c	c1 e1 00	 shl	 ecx, 0
  0019f	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx]
  001a6	b8 01 00 00 00	 mov	 eax, 1
  001ab	6b c8 00	 imul	 ecx, eax, 0
  001ae	b8 02 00 00 00	 mov	 eax, 2
  001b3	d1 e0		 shl	 eax, 1
  001b5	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  001bb	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  001be	88 0c 06	 mov	 BYTE PTR [esi+eax], cl

; 2762 : 	lpMsgBody[2].btY = g_btCastleDoorMapXY[iBridgeIndex][1][1];

  001c1	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  001c5	b9 04 00 00 00	 mov	 ecx, 4
  001ca	c1 e1 00	 shl	 ecx, 0
  001cd	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx]
  001d4	b8 01 00 00 00	 mov	 eax, 1
  001d9	c1 e0 00	 shl	 eax, 0
  001dc	b9 02 00 00 00	 mov	 ecx, 2
  001e1	d1 e1		 shl	 ecx, 1
  001e3	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  001e9	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  001ec	88 54 0e 01	 mov	 BYTE PTR [esi+ecx+1], dl

; 2763 : 	lpMsgBody[3].btX = g_btCastleDoorMapXY[iBridgeIndex][1][2];

  001f0	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  001f4	b9 04 00 00 00	 mov	 ecx, 4
  001f9	c1 e1 00	 shl	 ecx, 0
  001fc	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx]
  00203	b8 01 00 00 00	 mov	 eax, 1
  00208	d1 e0		 shl	 eax, 1
  0020a	b9 02 00 00 00	 mov	 ecx, 2
  0020f	6b c9 03	 imul	 ecx, ecx, 3
  00212	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  00218	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  0021b	88 14 0e	 mov	 BYTE PTR [esi+ecx], dl

; 2764 : 	lpMsgBody[3].btY = g_btCastleDoorMapXY[iBridgeIndex][1][3];

  0021e	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  00222	b9 04 00 00 00	 mov	 ecx, 4
  00227	c1 e1 00	 shl	 ecx, 0
  0022a	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx]
  00231	b8 01 00 00 00	 mov	 eax, 1
  00236	6b c8 03	 imul	 ecx, eax, 3
  00239	b8 02 00 00 00	 mov	 eax, 2
  0023e	6b c0 03	 imul	 eax, eax, 3
  00241	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  00247	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  0024a	88 4c 06 01	 mov	 BYTE PTR [esi+eax+1], cl

; 2765 : 	lpMsgBody[4].btX = g_btCastleDoorMapXY[iBridgeIndex][2][0];

  0024e	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  00252	b9 04 00 00 00	 mov	 ecx, 4
  00257	d1 e1		 shl	 ecx, 1
  00259	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx]
  00260	b8 01 00 00 00	 mov	 eax, 1
  00265	6b c8 00	 imul	 ecx, eax, 0
  00268	b8 02 00 00 00	 mov	 eax, 2
  0026d	c1 e0 02	 shl	 eax, 2
  00270	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  00276	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00279	88 0c 06	 mov	 BYTE PTR [esi+eax], cl

; 2766 : 	lpMsgBody[4].btY = g_btCastleDoorMapXY[iBridgeIndex][2][1];

  0027c	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  00280	b9 04 00 00 00	 mov	 ecx, 4
  00285	d1 e1		 shl	 ecx, 1
  00287	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx]
  0028e	b8 01 00 00 00	 mov	 eax, 1
  00293	c1 e0 00	 shl	 eax, 0
  00296	b9 02 00 00 00	 mov	 ecx, 2
  0029b	c1 e1 02	 shl	 ecx, 2
  0029e	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  002a4	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  002a7	88 54 0e 01	 mov	 BYTE PTR [esi+ecx+1], dl

; 2767 : 	lpMsgBody[5].btX = g_btCastleDoorMapXY[iBridgeIndex][2][2];

  002ab	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  002af	b9 04 00 00 00	 mov	 ecx, 4
  002b4	d1 e1		 shl	 ecx, 1
  002b6	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx]
  002bd	b8 01 00 00 00	 mov	 eax, 1
  002c2	d1 e0		 shl	 eax, 1
  002c4	b9 02 00 00 00	 mov	 ecx, 2
  002c9	6b c9 05	 imul	 ecx, ecx, 5
  002cc	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  002d2	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  002d5	88 14 0e	 mov	 BYTE PTR [esi+ecx], dl

; 2768 : 	lpMsgBody[5].btY = g_btCastleDoorMapXY[iBridgeIndex][2][3];

  002d8	6b 45 08 0c	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 12
  002dc	b9 04 00 00 00	 mov	 ecx, 4
  002e1	d1 e1		 shl	 ecx, 1
  002e3	8d 94 08 00 00
	00 00		 lea	 edx, DWORD PTR ?g_btCastleDoorMapXY@@3QAY123$$CBEA[eax+ecx]
  002ea	b8 01 00 00 00	 mov	 eax, 1
  002ef	6b c8 03	 imul	 ecx, eax, 3
  002f2	b8 02 00 00 00	 mov	 eax, 2
  002f7	6b c0 05	 imul	 eax, eax, 5
  002fa	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsgBody$[ebp]
  00300	8a 0c 0a	 mov	 cl, BYTE PTR [edx+ecx]
  00303	88 4c 06 01	 mov	 BYTE PTR [esi+eax+1], cl

; 2769 : 
; 2770 : 	for (int i = MAX_MONSTER ; i < MAX_OBJECT ; i++) {

  00307	c7 85 ec fe ff
	ff a8 16 00 00	 mov	 DWORD PTR _i$1[ebp], 5800 ; 000016a8H
  00311	eb 0f		 jmp	 SHORT $LN4@SendCastle
$LN2@SendCastle:
  00313	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00319	83 c0 01	 add	 eax, 1
  0031c	89 85 ec fe ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SendCastle:
  00322	81 bd ec fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _i$1[ebp], 7400 ; 00001ce8H
  0032c	7d 5c		 jge	 SHORT $LN1@SendCastle

; 2771 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2772 : 		int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 2773 : 		if ((gObj[i].MapNumber == iMapNum) && (gObj[i].Connected > 2)) {
; 2774 : #else
; 2775 : 		if ((gObj[i].MapNumber == MAP_INDEX_BLOODCASTLE1 + iBridgeIndex) && (gObj[i].Connected > 2)) {

  0032e	69 85 ec fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _i$1[ebp], 7072
  00338	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0033e	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00346	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00349	83 c0 0b	 add	 eax, 11			; 0000000bH
  0034c	3b d0		 cmp	 edx, eax
  0034e	75 38		 jne	 SHORT $LN6@SendCastle
  00350	69 85 ec fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _i$1[ebp], 7072
  0035a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00360	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00365	7e 21		 jle	 SHORT $LN6@SendCastle

; 2776 : #endif
; 2777 : 			DataSend (i, (unsigned char*) lpMsg, lpMsg->h.size);

  00367	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0036d	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00371	51		 push	 ecx
  00372	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00378	52		 push	 edx
  00379	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  0037f	50		 push	 eax
  00380	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00385	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SendCastle:

; 2778 : 		}
; 2779 : 	}

  00388	eb 89		 jmp	 SHORT $LN2@SendCastle
$LN1@SendCastle:

; 2780 : }

  0038a	5f		 pop	 edi
  0038b	5e		 pop	 esi
  0038c	5b		 pop	 ebx
  0038d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00390	33 cd		 xor	 ecx, ebp
  00392	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00397	8b e5		 mov	 esp, ebp
  00399	5d		 pop	 ebp
  0039a	c2 08 00	 ret	 8
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleDoorBlockInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
tv66 = -348						; size = 4
tv67 = -344						; size = 4
tv80 = -341						; size = 1
_i$1 = -276						; size = 4
_lpMsgBody$ = -272					; size = 4
_lpMsg$ = -268						; size = 4
_cTEMP_BUF$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleBridgeBlockInfo, COMDAT
; _this$ = ecx

; 2701 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2702 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00019	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0001d	7d 0c		 jge	 SHORT $LN10@SendCastle
  0001f	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00029	eb 28		 jmp	 SHORT $LN11@SendCastle
$LN10@SendCastle:
  0002b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0002f	7e 0c		 jle	 SHORT $LN8@SendCastle
  00031	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN9@SendCastle
$LN8@SendCastle:
  0003d	c7 85 a4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN9@SendCastle:
  00047	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN11@SendCastle:
  00053	83 bd a8 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 05		 jne	 SHORT $LN5@SendCastle

; 2703 : 		return;

  0005c	e9 fc 01 00 00	 jmp	 $LN1@SendCastle
$LN5@SendCastle:

; 2704 : 
; 2705 : 	char cTEMP_BUF [256];
; 2706 : 	LPPMSG_SETMAPATTR_COUNT lpMsg = (LPPMSG_SETMAPATTR_COUNT) cTEMP_BUF;

  00061	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00067	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2707 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT) + sizeof(PMSG_SETMAPATTR) * 2 * 3);

  0006d	6a 13		 push	 19			; 00000013H
  0006f	6a 46		 push	 70			; 00000046H
  00071	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2708 : 
; 2709 : 	LPPMSG_SETMAPATTR lpMsgBody = (LPPMSG_SETMAPATTR) (cTEMP_BUF + sizeof(PMSG_SETMAPATTR_COUNT));

  00080	8d 85 ff fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp+7]
  00086	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 2710 : 
; 2711 : 	lpMsg->btType = 0;

  0008c	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00092	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 2712 : 	lpMsg->btCount = 1;

  00096	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0009c	c6 40 06 01	 mov	 BYTE PTR [eax+6], 1

; 2713 : 	lpMsg->btMapAttr = MAP_ATTR_HOLLOW;

  000a0	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a6	c6 40 04 08	 mov	 BYTE PTR [eax+4], 8

; 2714 : 	(bLive) ? lpMsg->btMapSetType = 0 : lpMsg->btMapSetType = 1;

  000aa	0f b6 45 0c	 movzx	 eax, BYTE PTR _bLive$[ebp]
  000ae	85 c0		 test	 eax, eax
  000b0	74 13		 je	 SHORT $LN12@SendCastle
  000b2	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000b8	c6 41 05 00	 mov	 BYTE PTR [ecx+5], 0
  000bc	c6 85 ab fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
  000c3	eb 11		 jmp	 SHORT $LN13@SendCastle
$LN12@SendCastle:
  000c5	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000cb	c6 42 05 01	 mov	 BYTE PTR [edx+5], 1
  000cf	c6 85 ab fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
$LN13@SendCastle:

; 2715 : 
; 2716 : 	lpMsgBody[0].btX = g_btCastleBridgeMapXY[iBridgeIndex][0];

  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	6b c8 00	 imul	 ecx, eax, 0
  000de	ba 02 00 00 00	 mov	 edx, 2
  000e3	6b c2 00	 imul	 eax, edx, 0
  000e6	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  000ec	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  000ef	8a 8c b1 00 00
	00 00		 mov	 cl, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[ecx+esi*4]
  000f6	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2717 : 	lpMsgBody[0].btY = g_btCastleBridgeMapXY[iBridgeIndex][1];

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	c1 e0 00	 shl	 eax, 0
  00101	b9 02 00 00 00	 mov	 ecx, 2
  00106	6b d1 00	 imul	 edx, ecx, 0
  00109	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  0010f	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00112	8a 84 b0 00 00
	00 00		 mov	 al, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[eax+esi*4]
  00119	88 44 11 01	 mov	 BYTE PTR [ecx+edx+1], al

; 2718 : 	lpMsgBody[1].btX = g_btCastleBridgeMapXY[iBridgeIndex][2];

  0011d	b8 01 00 00 00	 mov	 eax, 1
  00122	d1 e0		 shl	 eax, 1
  00124	b9 02 00 00 00	 mov	 ecx, 2
  00129	c1 e1 00	 shl	 ecx, 0
  0012c	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  00132	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00135	8a 84 b0 00 00
	00 00		 mov	 al, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[eax+esi*4]
  0013c	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2719 : 	lpMsgBody[1].btY = g_btCastleBridgeMapXY[iBridgeIndex][3];

  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	6b c8 03	 imul	 ecx, eax, 3
  00147	ba 02 00 00 00	 mov	 edx, 2
  0014c	c1 e2 00	 shl	 edx, 0
  0014f	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  00155	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00158	8a 8c b1 00 00
	00 00		 mov	 cl, BYTE PTR ?g_btCastleBridgeMapXY@@3QAY03$$CBEA[ecx+esi*4]
  0015f	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 2720 : 
; 2721 : 	for (int i = MAX_MONSTER ; i < MAX_OBJECT ; i++) 

  00163	c7 85 ec fe ff
	ff a8 16 00 00	 mov	 DWORD PTR _i$1[ebp], 5800 ; 000016a8H
  0016d	eb 0f		 jmp	 SHORT $LN4@SendCastle
$LN2@SendCastle:
  0016f	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00175	83 c0 01	 add	 eax, 1
  00178	89 85 ec fe ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SendCastle:
  0017e	81 bd ec fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _i$1[ebp], 7400 ; 00001ce8H
  00188	0f 8d cf 00 00
	00		 jge	 $LN1@SendCastle

; 2722 : 	{
; 2723 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2724 : 		int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 2725 : 		if ((gObj[i].MapNumber == iMapNum) && (gObj[i].Connected > 2)) 
; 2726 : #else
; 2727 : 		if ((gObj[i].MapNumber == MAP_INDEX_BLOODCASTLE1 + iBridgeIndex) && (gObj[i].Connected > 2)) 

  0018e	69 85 ec fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _i$1[ebp], 7072
  00198	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019e	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001a6	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  001a9	83 c0 0b	 add	 eax, 11			; 0000000bH
  001ac	3b d0		 cmp	 edx, eax
  001ae	0f 85 a4 00 00
	00		 jne	 $LN6@SendCastle
  001b4	69 85 ec fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _i$1[ebp], 7072
  001be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c4	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  001c9	0f 8e 89 00 00
	00		 jle	 $LN6@SendCastle

; 2728 : #endif
; 2729 : 		{
; 2730 : 			DataSend (i, (unsigned char*) lpMsg, lpMsg->h.size);

  001cf	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001d5	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001d9	51		 push	 ecx
  001da	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  001e0	52		 push	 edx
  001e1	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2731 : 
; 2732 : #ifdef ADD_LOG_FOR_CASTLE_BUG_20060911
; 2733 : 			LogAddTD( "[Blood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:%d/Live:%d, (%d,%d,%d,%d)", 

  001f0	b8 02 00 00 00	 mov	 eax, 2
  001f5	c1 e0 00	 shl	 eax, 0
  001f8	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  001fe	0f b6 54 01 01	 movzx	 edx, BYTE PTR [ecx+eax+1]
  00203	52		 push	 edx
  00204	b8 02 00 00 00	 mov	 eax, 2
  00209	c1 e0 00	 shl	 eax, 0
  0020c	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  00212	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00216	52		 push	 edx
  00217	b8 02 00 00 00	 mov	 eax, 2
  0021c	6b c8 00	 imul	 ecx, eax, 0
  0021f	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  00225	0f b6 44 0a 01	 movzx	 eax, BYTE PTR [edx+ecx+1]
  0022a	50		 push	 eax
  0022b	b9 02 00 00 00	 mov	 ecx, 2
  00230	6b d1 00	 imul	 edx, ecx, 0
  00233	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  00239	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0023d	51		 push	 ecx
  0023e	0f b6 55 0c	 movzx	 edx, BYTE PTR _bLive$[ebp]
  00242	52		 push	 edx
  00243	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00246	83 c0 01	 add	 eax, 1
  00249	50		 push	 eax
  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Send@
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00255	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN6@SendCastle:

; 2734 : 				iBridgeIndex+1, bLive, lpMsgBody[0].btX, lpMsgBody[0].btY, lpMsgBody[1].btX, lpMsgBody[1].btY );
; 2735 : #endif
; 2736 : 		}
; 2737 : 	}

  00258	e9 12 ff ff ff	 jmp	 $LN2@SendCastle
$LN1@SendCastle:

; 2738 : }

  0025d	5f		 pop	 edi
  0025e	5e		 pop	 esi
  0025f	5b		 pop	 ebx
  00260	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00263	33 cd		 xor	 ecx, ebp
  00265	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026a	8b e5		 mov	 esp, ebp
  0026c	5d		 pop	 ebp
  0026d	c2 08 00	 ret	 8
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleBridgeBlockInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
tv66 = -348						; size = 4
tv67 = -344						; size = 4
tv80 = -341						; size = 1
_i$1 = -276						; size = 4
_lpMsgBody$ = -272					; size = 4
_lpMsg$ = -268						; size = 4
_cTEMP_BUF$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z PROC ; CBloodCastle::SendCastleEntranceBlockInfo, COMDAT
; _this$ = ecx

; 2667 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2668 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00019	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  0001d	7d 0c		 jge	 SHORT $LN10@SendCastle
  0001f	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00029	eb 28		 jmp	 SHORT $LN11@SendCastle
$LN10@SendCastle:
  0002b	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0002f	7e 0c		 jle	 SHORT $LN8@SendCastle
  00031	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN9@SendCastle
$LN8@SendCastle:
  0003d	c7 85 a4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN9@SendCastle:
  00047	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN11@SendCastle:
  00053	83 bd a8 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 05		 jne	 SHORT $LN5@SendCastle

; 2669 : 		return;

  0005c	e9 85 01 00 00	 jmp	 $LN1@SendCastle
$LN5@SendCastle:

; 2670 : 
; 2671 : 	char cTEMP_BUF [256];
; 2672 : 	LPPMSG_SETMAPATTR_COUNT lpMsg = (LPPMSG_SETMAPATTR_COUNT) cTEMP_BUF;

  00061	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00067	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2673 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT) + sizeof(PMSG_SETMAPATTR) * 2 * 3);

  0006d	6a 13		 push	 19			; 00000013H
  0006f	6a 46		 push	 70			; 00000046H
  00071	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2674 : 
; 2675 : 	LPPMSG_SETMAPATTR lpMsgBody = (LPPMSG_SETMAPATTR) (cTEMP_BUF + sizeof(PMSG_SETMAPATTR_COUNT));

  00080	8d 85 ff fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp+7]
  00086	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 2676 : 
; 2677 : 	lpMsg->btType = 0;

  0008c	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00092	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 2678 : 	lpMsg->btCount = 1;

  00096	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0009c	c6 40 06 01	 mov	 BYTE PTR [eax+6], 1

; 2679 : 	lpMsg->btMapAttr = MAP_ATTR_BLOCK;

  000a0	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a6	c6 40 04 04	 mov	 BYTE PTR [eax+4], 4

; 2680 : 	(bLive) ? lpMsg->btMapSetType = 0 : lpMsg->btMapSetType = 1;

  000aa	0f b6 45 0c	 movzx	 eax, BYTE PTR _bLive$[ebp]
  000ae	85 c0		 test	 eax, eax
  000b0	74 13		 je	 SHORT $LN12@SendCastle
  000b2	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000b8	c6 41 05 00	 mov	 BYTE PTR [ecx+5], 0
  000bc	c6 85 ab fe ff
	ff 00		 mov	 BYTE PTR tv80[ebp], 0
  000c3	eb 11		 jmp	 SHORT $LN13@SendCastle
$LN12@SendCastle:
  000c5	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000cb	c6 42 05 01	 mov	 BYTE PTR [edx+5], 1
  000cf	c6 85 ab fe ff
	ff 01		 mov	 BYTE PTR tv80[ebp], 1
$LN13@SendCastle:

; 2681 : 
; 2682 : 	lpMsgBody[0].btX = g_btCastleEntranceMapXY[iBridgeIndex][0];

  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	6b c8 00	 imul	 ecx, eax, 0
  000de	ba 02 00 00 00	 mov	 edx, 2
  000e3	6b c2 00	 imul	 eax, edx, 0
  000e6	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  000ec	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  000ef	8a 8c b1 00 00
	00 00		 mov	 cl, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[ecx+esi*4]
  000f6	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2683 : 	lpMsgBody[0].btY = g_btCastleEntranceMapXY[iBridgeIndex][1];

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	c1 e0 00	 shl	 eax, 0
  00101	b9 02 00 00 00	 mov	 ecx, 2
  00106	6b d1 00	 imul	 edx, ecx, 0
  00109	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  0010f	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00112	8a 84 b0 00 00
	00 00		 mov	 al, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[eax+esi*4]
  00119	88 44 11 01	 mov	 BYTE PTR [ecx+edx+1], al

; 2684 : 	lpMsgBody[1].btX = g_btCastleEntranceMapXY[iBridgeIndex][2];

  0011d	b8 01 00 00 00	 mov	 eax, 1
  00122	d1 e0		 shl	 eax, 1
  00124	b9 02 00 00 00	 mov	 ecx, 2
  00129	c1 e1 00	 shl	 ecx, 0
  0012c	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsgBody$[ebp]
  00132	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00135	8a 84 b0 00 00
	00 00		 mov	 al, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[eax+esi*4]
  0013c	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 2685 : 	lpMsgBody[1].btY = g_btCastleEntranceMapXY[iBridgeIndex][3];

  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	6b c8 03	 imul	 ecx, eax, 3
  00147	ba 02 00 00 00	 mov	 edx, 2
  0014c	c1 e2 00	 shl	 edx, 0
  0014f	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsgBody$[ebp]
  00155	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00158	8a 8c b1 00 00
	00 00		 mov	 cl, BYTE PTR ?g_btCastleEntranceMapXY@@3QAY03$$CBEA[ecx+esi*4]
  0015f	88 4c 10 01	 mov	 BYTE PTR [eax+edx+1], cl

; 2686 : 
; 2687 : 	for (int i = MAX_MONSTER ; i < MAX_OBJECT ; i++) {

  00163	c7 85 ec fe ff
	ff a8 16 00 00	 mov	 DWORD PTR _i$1[ebp], 5800 ; 000016a8H
  0016d	eb 0f		 jmp	 SHORT $LN4@SendCastle
$LN2@SendCastle:
  0016f	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00175	83 c0 01	 add	 eax, 1
  00178	89 85 ec fe ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SendCastle:
  0017e	81 bd ec fe ff
	ff e8 1c 00 00	 cmp	 DWORD PTR _i$1[ebp], 7400 ; 00001ce8H
  00188	7d 5c		 jge	 SHORT $LN1@SendCastle

; 2688 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2689 : 		int iMapNum = GetMapNumByBCBridge( iBridgeIndex );
; 2690 : 		if ((gObj[i].MapNumber == iMapNum) && (gObj[i].Connected > 2)) {
; 2691 : #else
; 2692 : 		if ((gObj[i].MapNumber == MAP_INDEX_BLOODCASTLE1 + iBridgeIndex) && (gObj[i].Connected > 2)) {

  0018a	69 85 ec fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _i$1[ebp], 7072
  00194	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019a	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001a2	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  001a5	83 c0 0b	 add	 eax, 11			; 0000000bH
  001a8	3b d0		 cmp	 edx, eax
  001aa	75 38		 jne	 SHORT $LN6@SendCastle
  001ac	69 85 ec fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _i$1[ebp], 7072
  001b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bc	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  001c1	7e 21		 jle	 SHORT $LN6@SendCastle

; 2693 : #endif
; 2694 : 			DataSend (i, (unsigned char*) lpMsg, lpMsg->h.size);

  001c3	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001c9	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  001cd	51		 push	 ecx
  001ce	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  001d4	52		 push	 edx
  001d5	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  001db	50		 push	 eax
  001dc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001e1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SendCastle:

; 2695 : 		}
; 2696 : 	}

  001e4	eb 89		 jmp	 SHORT $LN2@SendCastle
$LN1@SendCastle:

; 2697 : }

  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c2 08 00	 ret	 8
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP ; CBloodCastle::SendCastleEntranceBlockInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SetUserState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv182 = -88						; size = 4
tv84 = -88						; size = 4
tv79 = -88						; size = 4
tv66 = -88						; size = 4
tv183 = -84						; size = 4
tv87 = -84						; size = 4
tv85 = -84						; size = 4
tv80 = -84						; size = 4
tv67 = -84						; size = 4
_i$1 = -16						; size = 4
_iBridgeSubIndex$ = -12					; size = 4
_iBridgeIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iState$ = 12						; size = 4
?SetUserState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SetUserState, COMDAT
; _this$ = ecx

; 3024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3025 : 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN24@SetUserSta
  00012	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN25@SetUserSta
$LN24@SetUserSta:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN22@SetUserSta
  00024	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN23@SetUserSta
$LN22@SetUserSta:
  0002d	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN23@SetUserSta:
  00034	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN25@SetUserSta:
  0003a	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 05		 jne	 SHORT $LN7@SetUserSta

; 3026 : 		return;

  00040	e9 9a 02 00 00	 jmp	 $LN1@SetUserSta
$LN7@SetUserSta:

; 3027 : 
; 3028 : 	int iBridgeIndex = gObj[iIndex].m_cBloodCastleIndex;

  00045	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00052	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  0005a	89 55 f8	 mov	 DWORD PTR _iBridgeIndex$[ebp], edx

; 3029 : 	int iBridgeSubIndex = gObj[iIndex].m_cBloodCastleSubIndex;

  0005d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006a	0f be 94 01 d3
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3283]
  00072	89 55 f4	 mov	 DWORD PTR _iBridgeSubIndex$[ebp], edx

; 3030 : 
; 3031 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00075	83 7d f8 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00079	7d 09		 jge	 SHORT $LN28@SetUserSta
  0007b	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00082	eb 1c		 jmp	 SHORT $LN29@SetUserSta
$LN28@SetUserSta:
  00084	83 7d f8 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  00088	7e 09		 jle	 SHORT $LN26@SetUserSta
  0008a	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00091	eb 07		 jmp	 SHORT $LN27@SetUserSta
$LN26@SetUserSta:
  00093	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN27@SetUserSta:
  0009a	8b 45 a8	 mov	 eax, DWORD PTR tv79[ebp]
  0009d	89 45 ac	 mov	 DWORD PTR tv80[ebp], eax
$LN29@SetUserSta:
  000a0	83 7d ac 00	 cmp	 DWORD PTR tv80[ebp], 0
  000a4	75 05		 jne	 SHORT $LN8@SetUserSta

; 3032 : 		return;

  000a6	e9 34 02 00 00	 jmp	 $LN1@SetUserSta
$LN8@SetUserSta:

; 3033 : 
; 3034 : 	if (!CHECK_LIMIT(iBridgeSubIndex, MAX_BLOODCASTLE_USER_COUNT))

  000ab	83 7d f4 00	 cmp	 DWORD PTR _iBridgeSubIndex$[ebp], 0
  000af	7d 09		 jge	 SHORT $LN32@SetUserSta
  000b1	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  000b8	eb 1c		 jmp	 SHORT $LN33@SetUserSta
$LN32@SetUserSta:
  000ba	83 7d f4 09	 cmp	 DWORD PTR _iBridgeSubIndex$[ebp], 9
  000be	7e 09		 jle	 SHORT $LN30@SetUserSta
  000c0	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
  000c7	eb 07		 jmp	 SHORT $LN31@SetUserSta
$LN30@SetUserSta:
  000c9	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
$LN31@SetUserSta:
  000d0	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  000d3	89 45 ac	 mov	 DWORD PTR tv85[ebp], eax
$LN33@SetUserSta:
  000d6	83 7d ac 00	 cmp	 DWORD PTR tv85[ebp], 0
  000da	75 05		 jne	 SHORT $LN9@SetUserSta

; 3035 : 		return;

  000dc	e9 fe 01 00 00	 jmp	 $LN1@SetUserSta
$LN9@SetUserSta:

; 3036 : 
; 3037 : /*	if( (!CHECK_BLOODCASTLE(gObj[iIndex].MapNumber)) || (gObj[iIndex].Connected <= 2))
; 3038 : 	{
; 3039 : 		m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = BC_USER_DEAD;
; 3040 : 		return;
; 3041 : 	}
; 3042 : */
; 3043 : 
; 3044 : 	switch (iState) {

  000e1	8b 45 0c	 mov	 eax, DWORD PTR _iState$[ebp]
  000e4	89 45 ac	 mov	 DWORD PTR tv87[ebp], eax
  000e7	83 7d ac 04	 cmp	 DWORD PTR tv87[ebp], 4
  000eb	0f 87 ee 01 00
	00		 ja	 $LN1@SetUserSta
  000f1	8b 4d ac	 mov	 ecx, DWORD PTR tv87[ebp]
  000f4	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN38@SetUserSta[ecx*4]
$LN10@SetUserSta:

; 3045 : 	case BC_USER_ALIVE :			//    .
; 3046 : 		{
; 3047 : 			m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = BC_USER_ALIVE;

  000fb	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00109	6b 45 f4 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  0010d	c7 44 02 24 00
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 0

; 3048 : 		}
; 3049 : 		break;

  00115	e9 c5 01 00 00	 jmp	 $LN1@SetUserSta
$LN11@SetUserSta:

; 3050 : 	case BC_USER_DEAD :				//    -> gObjUserDie() 
; 3051 : 		{
; 3052 : 			m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = BC_USER_DEAD;

  0011a	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00121	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00128	6b 45 f4 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  0012c	c7 44 02 24 01
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 1

; 3053 : 		}
; 3054 : 		break;

  00134	e9 a6 01 00 00	 jmp	 $LN1@SetUserSta
$LN12@SetUserSta:

; 3055 : 	case BC_USER_WINNER :			//    BC_USER_WINNER_PARTY  .
; 3056 : 		{
; 3057 : 			if( gObj[iIndex].PartyNumber >= 0 )

  00139	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00146	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  0014e	0f 8c 25 01 00
	00		 jl	 $LN13@SetUserSta

; 3058 : 			{
; 3059 : //				int iPartyCount = gParty.m_PartyS[gObj[iIndex].PartyNumber].Count;
; 3060 : 
; 3061 : 				for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00154	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0015b	eb 09		 jmp	 SHORT $LN6@SetUserSta
$LN4@SetUserSta:
  0015d	8b 45 f0	 mov	 eax, DWORD PTR _i$1[ebp]
  00160	83 c0 01	 add	 eax, 1
  00163	89 45 f0	 mov	 DWORD PTR _i$1[ebp], eax
$LN6@SetUserSta:
  00166	83 7d f0 0a	 cmp	 DWORD PTR _i$1[ebp], 10	; 0000000aH
  0016a	0f 8d 09 01 00
	00		 jge	 $LN13@SetUserSta

; 3062 : 					if (i == iBridgeSubIndex) {

  00170	8b 45 f0	 mov	 eax, DWORD PTR _i$1[ebp]
  00173	3b 45 f4	 cmp	 eax, DWORD PTR _iBridgeSubIndex$[ebp]
  00176	75 07		 jne	 SHORT $LN14@SetUserSta

; 3063 : 						//  .
; 3064 : 						continue;

  00178	eb e3		 jmp	 SHORT $LN4@SetUserSta

; 3065 : 					}

  0017a	e9 f5 00 00 00	 jmp	 $LN15@SetUserSta
$LN14@SetUserSta:

; 3066 : 					else {
; 3067 : #ifdef MODIFY_BLOODCASTLE_USERINDEX_BUGFIX_20080709
; 3068 : 						if( m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 ) continue;							
; 3069 : #endif	// MODIFY_BLOODCASTLE_USERINDEX_BUGFIX_20080709
; 3070 : 						
; 3071 : 						if (gObj[iIndex].PartyNumber == gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber) {

  0017f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00186	69 4d f8 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0018d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00190	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  00194	6b 55 f0 14	 imul	 edx, DWORD PTR _i$1[ebp], 20
  00198	69 4c 11 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [ecx+edx+24], 7072
  001a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ac	8b 84 02 88 02
	00 00		 mov	 eax, DWORD PTR [edx+eax+648]
  001b3	3b 84 0e 88 02
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+648]
  001ba	0f 85 b4 00 00
	00		 jne	 $LN15@SetUserSta

; 3072 : 							//    BC_USER_WINNER_PARTY  .
; 3073 : 							if (CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber))

  001c0	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ca	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  001ce	6b 45 f0 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  001d2	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  001da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e0	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  001e8	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  001eb	7d 09		 jge	 SHORT $LN36@SetUserSta
  001ed	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv183[ebp], 0
  001f4	eb 42		 jmp	 SHORT $LN37@SetUserSta
$LN36@SetUserSta:
  001f6	69 4d f8 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  001fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00200	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00204	6b 4d f0 14	 imul	 ecx, DWORD PTR _i$1[ebp], 20
  00208	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  00210	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00215	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  0021d	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00220	7e 09		 jle	 SHORT $LN34@SetUserSta
  00222	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv182[ebp], 0
  00229	eb 07		 jmp	 SHORT $LN35@SetUserSta
$LN34@SetUserSta:
  0022b	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv182[ebp], 1
$LN35@SetUserSta:
  00232	8b 55 a8	 mov	 edx, DWORD PTR tv182[ebp]
  00235	89 55 ac	 mov	 DWORD PTR tv183[ebp], edx
$LN37@SetUserSta:
  00238	83 7d ac 00	 cmp	 DWORD PTR tv183[ebp], 0
  0023c	74 1c		 je	 SHORT $LN17@SetUserSta

; 3074 : 								m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_WINNER_PARTY_ALIVE;

  0023e	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00245	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00248	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0024c	6b 45 f0 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  00250	c7 44 02 24 03
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 3
  00258	eb 1a		 jmp	 SHORT $LN15@SetUserSta
$LN17@SetUserSta:

; 3075 : 							else
; 3076 : 								m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = BC_USER_WINNER_PARTY_DEAD;

  0025a	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00261	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00264	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00268	6b 45 f0 14	 imul	 eax, DWORD PTR _i$1[ebp], 20
  0026c	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN15@SetUserSta:

; 3077 : 						}
; 3078 : 					}
; 3079 : 				}

  00274	e9 e4 fe ff ff	 jmp	 $LN4@SetUserSta
$LN13@SetUserSta:

; 3080 : 			}
; 3081 : 
; 3082 : 			m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = BC_USER_WINNER;

  00279	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00280	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00283	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00287	6b 45 f4 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  0028b	c7 44 02 24 02
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 2

; 3083 : 			m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS = iBridgeSubIndex;

  00293	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0029a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029d	8b 55 f4	 mov	 edx, DWORD PTR _iBridgeSubIndex$[ebp]
  002a0	89 94 01 48 01
	00 00		 mov	 DWORD PTR [ecx+eax+328], edx

; 3084 : 		}
; 3085 : 		break;

  002a7	eb 36		 jmp	 SHORT $LN1@SetUserSta
$LN19@SetUserSta:

; 3086 : 	case BC_USER_WINNER_PARTY_ALIVE :		//    .
; 3087 : 		{
; 3088 : 			m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = BC_USER_WINNER_PARTY_ALIVE;

  002a9	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  002b7	6b 45 f4 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  002bb	c7 44 02 24 03
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 3

; 3089 : 		}
; 3090 : 		break;

  002c3	eb 1a		 jmp	 SHORT $LN1@SetUserSta
$LN20@SetUserSta:

; 3091 : 	case BC_USER_WINNER_PARTY_DEAD :		//    .
; 3092 : 		{
; 3093 : 			m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = BC_USER_WINNER_PARTY_DEAD;

  002c5	69 45 f8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002cc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002cf	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  002d3	6b 45 f4 14	 imul	 eax, DWORD PTR _iBridgeSubIndex$[ebp], 20
  002d7	c7 44 02 24 04
	00 00 00	 mov	 DWORD PTR [edx+eax+36], 4
$LN1@SetUserSta:

; 3094 : 		}
; 3095 : 		break;
; 3096 : 	}
; 3097 : }

  002df	5f		 pop	 edi
  002e0	5e		 pop	 esi
  002e1	5b		 pop	 ebx
  002e2	8b e5		 mov	 esp, ebp
  002e4	5d		 pop	 ebp
  002e5	c2 08 00	 ret	 8
$LN38@SetUserSta:
  002e8	00 00 00 00	 DD	 $LN10@SetUserSta
  002ec	00 00 00 00	 DD	 $LN11@SetUserSta
  002f0	00 00 00 00	 DD	 $LN12@SetUserSta
  002f4	00 00 00 00	 DD	 $LN19@SetUserSta
  002f8	00 00 00 00	 DD	 $LN20@SetUserSta
?SetUserState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SetUserState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv159 = -96						; size = 4
tv140 = -96						; size = 4
tv66 = -96						; size = 4
tv160 = -92						; size = 4
tv141 = -92						; size = 4
tv67 = -92						; size = 4
_iBridgeIndex$1 = -24					; size = 4
_pDropItem$2 = -20					; size = 6
_iITEM_LEVEL$3 = -12					; size = 4
_x$4 = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDropQuestItem, COMDAT
; _this$ = ecx

; 2943 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2944 : 	if(!CHECK_LIMIT( iIndex, MAX_OBJECT ) )

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN18@SearchUser
  00012	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN19@SearchUser
$LN18@SearchUser:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN16@SearchUser
  00024	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN17@SearchUser
$LN16@SearchUser:
  0002d	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN17@SearchUser:
  00034	8b 45 a0	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 a4	 mov	 DWORD PTR tv67[ebp], eax
$LN19@SearchUser:
  0003a	83 7d a4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 05		 jne	 SHORT $LN5@SearchUser

; 2945 : 		return;

  00040	e9 ca 02 00 00	 jmp	 $LN1@SearchUser
$LN5@SearchUser:

; 2946 : 
; 2947 : 	if ((gObj[iIndex].Type != OBJTYPE_CHARACTER) || (gObj[iIndex].Connected <= 2))

  00045	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00052	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00057	83 fa 01	 cmp	 edx, 1
  0005a	75 14		 jne	 SHORT $LN7@SearchUser
  0005c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00069	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0006e	7f 05		 jg	 SHORT $LN6@SearchUser
$LN7@SearchUser:

; 2948 : 		return;

  00070	e9 9a 02 00 00	 jmp	 $LN1@SearchUser
$LN6@SearchUser:

; 2949 : 
; 2950 : #ifdef PERSONAL_SHOP_20040113	//        .
; 2951 : 	for(int x=0; x<MAX_INVENTORY_EXTEND; x++)

  00075	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$4[ebp], 0
  0007c	eb 09		 jmp	 SHORT $LN4@SearchUser
$LN2@SearchUser:
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _x$4[ebp]
  00081	83 c0 01	 add	 eax, 1
  00084	89 45 f8	 mov	 DWORD PTR _x$4[ebp], eax
$LN4@SearchUser:
  00087	83 7d f8 6c	 cmp	 DWORD PTR _x$4[ebp], 108 ; 0000006cH
  0008b	0f 8d 7e 02 00
	00		 jge	 $LN1@SearchUser

; 2952 : #else
; 2953 : 	for(int x=0; x<MAX_INVENTORY; x++)
; 2954 : #endif
; 2955 : 	{
; 2956 : 		if( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00091	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00098	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$4[ebp], 168
  0009f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a5	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  000ac	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000b1	83 f8 01	 cmp	 eax, 1
  000b4	0f 85 50 02 00
	00		 jne	 $LN8@SearchUser

; 2957 : 		{
; 2958 : 			if( gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(13, 19) )		//   

  000ba	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000c1	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$4[ebp], 168
  000c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ce	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  000d5	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  000da	6a 13		 push	 19			; 00000013H
  000dc	6a 0d		 push	 13			; 0000000dH
  000de	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000e3	83 c4 08	 add	 esp, 8
  000e6	3b f0		 cmp	 esi, eax
  000e8	0f 85 1c 02 00
	00		 jne	 $LN8@SearchUser

; 2959 : 			{
; 2960 : 				INT iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;			//   .

  000ee	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000f5	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$4[ebp], 168
  000fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00102	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00109	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  0010e	89 4d f4	 mov	 DWORD PTR _iITEM_LEVEL$3[ebp], ecx

; 2961 : 
; 2962 : 				if (CHECK_LIMIT(iITEM_LEVEL, 3)) {

  00111	83 7d f4 00	 cmp	 DWORD PTR _iITEM_LEVEL$3[ebp], 0
  00115	7d 09		 jge	 SHORT $LN22@SearchUser
  00117	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
  0011e	eb 1c		 jmp	 SHORT $LN23@SearchUser
$LN22@SearchUser:
  00120	83 7d f4 02	 cmp	 DWORD PTR _iITEM_LEVEL$3[ebp], 2
  00124	7e 09		 jle	 SHORT $LN20@SearchUser
  00126	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
  0012d	eb 07		 jmp	 SHORT $LN21@SearchUser
$LN20@SearchUser:
  0012f	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv140[ebp], 1
$LN21@SearchUser:
  00136	8b 45 a0	 mov	 eax, DWORD PTR tv140[ebp]
  00139	89 45 a4	 mov	 DWORD PTR tv141[ebp], eax
$LN23@SearchUser:
  0013c	83 7d a4 00	 cmp	 DWORD PTR tv141[ebp], 0
  00140	0f 84 c4 01 00
	00		 je	 $LN8@SearchUser

; 2963 : 					//    .
; 2964 : 					PMSG_ITEMTHROW	pDropItem;
; 2965 : 					pDropItem.Ipos  = x;

  00146	8a 45 f8	 mov	 al, BYTE PTR _x$4[ebp]
  00149	88 45 f1	 mov	 BYTE PTR _pDropItem$2[ebp+5], al

; 2966 : 					pDropItem.px    = (BYTE)gObj[iIndex].X;

  0014c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00159	8a 94 01 04 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+260]
  00160	88 55 ef	 mov	 BYTE PTR _pDropItem$2[ebp+3], dl

; 2967 : 					pDropItem.py	= (BYTE)gObj[iIndex].Y;

  00163	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0016a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00170	8a 94 01 06 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+262]
  00177	88 55 f0	 mov	 BYTE PTR _pDropItem$2[ebp+4], dl

; 2968 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2969 : 					int iBridgeIndex = GetBridgeIndexByMapNum( gObj[iIndex].MapNumber );
; 2970 : 					DropItemDirectly( iBridgeIndex, gObj[iIndex].m_Index, MAKE_ITEMNUM(13, 19), x );
; 2971 : #ifdef BLOODCASTLE_ITEMDROP_DIRECTLY_20040728
; 2972 : 					DropItemDirectly(gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1, gObj[iIndex].m_Index, MAKE_ITEMNUM(13, 19), x);
; 2973 : #else
; 2974 : 					CGItemDropRequest((LPPMSG_ITEMTHROW)&pDropItem, gObj[iIndex].m_Index, 1);		//     .
; 2975 : #endif
; 2976 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 2977 : 
; 2978 : 					//        .
; 2979 : 					if (CHECK_BLOODCASTLE(gObj[iIndex].MapNumber)) {

  0017a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00181	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00187	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0018f	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00192	7d 09		 jge	 SHORT $LN26@SearchUser
  00194	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
  0019b	eb 30		 jmp	 SHORT $LN27@SearchUser
$LN26@SearchUser:
  0019d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001aa	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001b2	83 fa 11	 cmp	 edx, 17			; 00000011H
  001b5	7e 09		 jle	 SHORT $LN24@SearchUser
  001b7	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
  001be	eb 07		 jmp	 SHORT $LN25@SearchUser
$LN24@SearchUser:
  001c0	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv159[ebp], 1
$LN25@SearchUser:
  001c7	8b 45 a0	 mov	 eax, DWORD PTR tv159[ebp]
  001ca	89 45 a4	 mov	 DWORD PTR tv160[ebp], eax
$LN27@SearchUser:
  001cd	83 7d a4 00	 cmp	 DWORD PTR tv160[ebp], 0
  001d1	0f 84 de 00 00
	00		 je	 $LN11@SearchUser

; 2980 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 2981 : 						INT iBridgeIndex = GetBridgeIndexByMapNum( gObj[iIndex].MapNumber );
; 2982 : #else
; 2983 : 						INT iBridgeIndex = gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1;

  001d7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e4	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  001ec	83 ea 0b	 sub	 edx, 11			; 0000000bH
  001ef	89 55 e8	 mov	 DWORD PTR _iBridgeIndex$1[ebp], edx

; 2984 : #endif
; 2985 : 
; 2986 : 						if (m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL != -1) {

  001f2	69 45 e8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$1[ebp], 516
  001f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001fc	83 bc 01 90 01
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+400], -1
  00204	74 46		 je	 SHORT $LN13@SearchUser

; 2987 : 							if (m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number) {

  00206	69 45 e8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$1[ebp], 516
  0020d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00214	69 55 f8 a8 00
	00 00		 imul	 edx, DWORD PTR _x$4[ebp], 168
  0021b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00221	8b 8c 0e 5c 0c
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+3164]
  00228	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0022b	8b 84 06 90 01
	00 00		 mov	 eax, DWORD PTR [esi+eax+400]
  00232	3b 04 11	 cmp	 eax, DWORD PTR [ecx+edx]
  00235	75 15		 jne	 SHORT $LN13@SearchUser

; 2988 : 								m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX = -1; 

  00237	69 45 e8 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$1[ebp], 516
  0023e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	c7 84 01 94 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+404], -1
$LN13@SearchUser:

; 2989 : 							}
; 2990 : 						}
; 2991 : 
; 2992 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 2993 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%u-%u]",
; 2994 : #else
; 2995 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%d-%d]",

  0024c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00253	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$4[ebp], 168
  0025a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00260	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00267	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0026a	51		 push	 ecx
  0026b	69 55 e8 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$1[ebp], 516
  00272	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00275	8b 8c 10 90 01
	00 00		 mov	 ecx, DWORD PTR [eax+edx+400]
  0027c	51		 push	 ecx
  0027d	8b 55 f4	 mov	 edx, DWORD PTR _iITEM_LEVEL$3[ebp]
  00280	52		 push	 edx
  00281	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00288	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0028e	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00292	52		 push	 edx
  00293	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0029a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a0	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  002a4	52		 push	 edx
  002a5	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@
  002aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002b0	83 c4 18	 add	 esp, 24			; 00000018H

; 2996 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 2997 : 							gObj[iIndex].AccountID,
; 2998 : 							gObj[iIndex].Name,
; 2999 : 							iITEM_LEVEL,
; 3000 : 							m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL,
; 3001 : 							gObj[iIndex].pInventory[x].m_Number
; 3002 : 							);
; 3003 : 					}

  002b3	eb 55		 jmp	 SHORT $LN8@SearchUser
$LN11@SearchUser:

; 3004 : 					else {
; 3005 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3006 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%u]",
; 3007 : #else
; 3008 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%d]",

  002b5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002bc	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$4[ebp], 168
  002c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c9	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  002d0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  002d3	51		 push	 ecx
  002d4	8b 55 f4	 mov	 edx, DWORD PTR _iITEM_LEVEL$3[ebp]
  002d7	52		 push	 edx
  002d8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e5	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  002e9	52		 push	 edx
  002ea	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f7	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  002fb	52		 push	 edx
  002fc	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@
  00301	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00307	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@SearchUser:

; 3009 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3010 : 							gObj[iIndex].AccountID,
; 3011 : 							gObj[iIndex].Name,
; 3012 : 							iITEM_LEVEL,
; 3013 : 							gObj[iIndex].pInventory[x].m_Number
; 3014 : 							);
; 3015 : 					}
; 3016 : 				}
; 3017 : 			}
; 3018 : 		}
; 3019 : 	}

  0030a	e9 6f fd ff ff	 jmp	 $LN2@SearchUser
$LN1@SearchUser:

; 3020 : }

  0030f	5f		 pop	 edi
  00310	5e		 pop	 esi
  00311	5b		 pop	 ebx
  00312	8b e5		 mov	 esp, ebp
  00314	5d		 pop	 ebp
  00315	c2 04 00	 ret	 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDropQuestItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv129 = -84						; size = 4
tv130 = -80						; size = 4
_iITEM_LEVEL$1 = -12					; size = 4
_x$2 = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDeleteQuestItem, COMDAT
; _this$ = ecx

; 2903 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2904 : 	if (!gObjIsConnected (iIndex))

  0000c	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00015	83 c4 04	 add	 esp, 4
  00018	85 c0		 test	 eax, eax
  0001a	75 05		 jne	 SHORT $LN5@SearchUser

; 2905 : 		return;

  0001c	e9 63 01 00 00	 jmp	 $LN1@SearchUser
$LN5@SearchUser:

; 2906 : 
; 2907 : #ifdef PERSONAL_SHOP_20040113	//        .
; 2908 : 	for(int x=0; x<MAX_INVENTORY_EXTEND; x++)

  00021	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$2[ebp], 0
  00028	eb 09		 jmp	 SHORT $LN4@SearchUser
$LN2@SearchUser:
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _x$2[ebp]
  0002d	83 c0 01	 add	 eax, 1
  00030	89 45 f8	 mov	 DWORD PTR _x$2[ebp], eax
$LN4@SearchUser:
  00033	83 7d f8 6c	 cmp	 DWORD PTR _x$2[ebp], 108 ; 0000006cH
  00037	0f 8d 47 01 00
	00		 jge	 $LN1@SearchUser

; 2909 : #else
; 2910 : 	for(int x=0; x<MAX_INVENTORY; x++)
; 2911 : #endif
; 2912 : 	{
; 2913 : 		if( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  0003d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00044	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  0004b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00051	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00058	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005d	83 f8 01	 cmp	 eax, 1
  00060	0f 85 19 01 00
	00		 jne	 $LN6@SearchUser

; 2914 : 		{
; 2915 : 			if( gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(13, 19) )		//   

  00066	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0006d	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  00074	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007a	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00081	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00086	6a 13		 push	 19			; 00000013H
  00088	6a 0d		 push	 13			; 0000000dH
  0008a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0008f	83 c4 08	 add	 esp, 8
  00092	3b f0		 cmp	 esi, eax
  00094	0f 85 e5 00 00
	00		 jne	 $LN6@SearchUser

; 2916 : 			{
; 2917 : 				INT iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;			//   .

  0009a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000a1	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  000a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ae	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  000b5	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  000ba	89 4d f4	 mov	 DWORD PTR _iITEM_LEVEL$1[ebp], ecx

; 2918 : 
; 2919 : 				if (CHECK_LIMIT(iITEM_LEVEL, 3)) {

  000bd	83 7d f4 00	 cmp	 DWORD PTR _iITEM_LEVEL$1[ebp], 0
  000c1	7d 09		 jge	 SHORT $LN12@SearchUser
  000c3	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
  000ca	eb 1c		 jmp	 SHORT $LN13@SearchUser
$LN12@SearchUser:
  000cc	83 7d f4 02	 cmp	 DWORD PTR _iITEM_LEVEL$1[ebp], 2
  000d0	7e 09		 jle	 SHORT $LN10@SearchUser
  000d2	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
  000d9	eb 07		 jmp	 SHORT $LN11@SearchUser
$LN10@SearchUser:
  000db	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv129[ebp], 1
$LN11@SearchUser:
  000e2	8b 45 ac	 mov	 eax, DWORD PTR tv129[ebp]
  000e5	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
$LN13@SearchUser:
  000e8	83 7d b0 00	 cmp	 DWORD PTR tv130[ebp], 0
  000ec	0f 84 8d 00 00
	00		 je	 $LN6@SearchUser

; 2920 : 					//    .
; 2921 : 					gObjInventoryItemSet(iIndex, x, 0xFF);

  000f2	68 ff 00 00 00	 push	 255			; 000000ffH
  000f7	8b 45 f8	 mov	 eax, DWORD PTR _x$2[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2922 : 					gObjInventoryDeleteItem(iIndex, x);

  00107	8b 45 f8	 mov	 eax, DWORD PTR _x$2[ebp]
  0010a	50		 push	 eax
  0010b	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00114	83 c4 08	 add	 esp, 8

; 2923 : 					GCInventoryItemDeleteSend(iIndex, x, 1);

  00117	6a 01		 push	 1
  00119	0f b6 45 f8	 movzx	 eax, BYTE PTR _x$2[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00121	51		 push	 ecx
  00122	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2924 : 
; 2925 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 2926 : 					LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Delete Angel King's Weapon (%d) [Serial:%u]",
; 2927 : #else
; 2928 : 					LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Delete Angel King's Weapon (%d) [Serial:%d]",

  0012a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00131	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  00138	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013e	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00145	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00148	51		 push	 ecx
  00149	8b 55 f4	 mov	 edx, DWORD PTR _iITEM_LEVEL$1[ebp]
  0014c	52		 push	 edx
  0014d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00154	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015a	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0015e	52		 push	 edx
  0015f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016c	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00170	52		 push	 edx
  00171	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CF@
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0017c	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@SearchUser:

; 2929 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 2930 : 						gObj[iIndex].AccountID,
; 2931 : 						gObj[iIndex].Name,
; 2932 : 						iITEM_LEVEL,
; 2933 : 						gObj[iIndex].pInventory[x].m_Number
; 2934 : 						);
; 2935 : 				}
; 2936 : 			}
; 2937 : 		}
; 2938 : 	}

  0017f	e9 a6 fe ff ff	 jmp	 $LN2@SearchUser
$LN1@SearchUser:

; 2939 : }

  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c2 04 00	 ret	 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDeleteQuestItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GiveReward_Fail@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv77 = -364						; size = 4
tv68 = -364						; size = 4
tv78 = -360						; size = 4
tv69 = -360						; size = 4
_pMsg$1 = -292						; size = 269
_iEXTRA_EXP$2 = -20					; size = 4
_i$3 = -16						; size = 4
_iUserWhoGotUltimateWeapon$ = -12			; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::GiveReward_Fail, COMDAT
; _this$ = ecx

; 3581 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3582 : #ifdef BLOODCASTLE_EVENT_5TH_20050531		//      .
; 3583 : 	FixUsersPlayStateFail(iBridgeIndex);

  00019	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateFail

; 3584 : #endif
; 3585 : 
; 3586 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00025	83 7d 08 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  00029	7d 0c		 jge	 SHORT $LN25@GiveReward
  0002b	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
  00035	eb 28		 jmp	 SHORT $LN26@GiveReward
$LN25@GiveReward:
  00037	83 7d 08 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0003b	7e 0c		 jle	 SHORT $LN23@GiveReward
  0003d	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00047	eb 0a		 jmp	 SHORT $LN24@GiveReward
$LN23@GiveReward:
  00049	c7 85 94 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
$LN24@GiveReward:
  00053	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]
  00059	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN26@GiveReward:
  0005f	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv69[ebp], 0
  00066	75 05		 jne	 SHORT $LN5@GiveReward

; 3587 : 		return;

  00068	e9 c1 05 00 00	 jmp	 $LN1@GiveReward
$LN5@GiveReward:

; 3588 : 
; 3589 : 	INT iUserWhoGotUltimateWeapon = -1;

  0006d	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], -1

; 3590 : 	if ( (iUserWhoGotUltimateWeapon = GetWhoGotUltimateWeapon(iBridgeIndex)) != -1 ) {

  00074	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWhoGotUltimateWeapon
  00080	89 45 f4	 mov	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], eax
  00083	83 7d f4 ff	 cmp	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], -1
  00087	0f 84 92 00 00
	00		 je	 $LN6@GiveReward

; 3591 : 		if (CHECK_LIMIT(iUserWhoGotUltimateWeapon, MAX_OBJECT)) {

  0008d	83 7d f4 00	 cmp	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], 0
  00091	7d 0c		 jge	 SHORT $LN29@GiveReward
  00093	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv78[ebp], 0
  0009d	eb 2b		 jmp	 SHORT $LN30@GiveReward
$LN29@GiveReward:
  0009f	81 7d f4 e7 1c
	00 00		 cmp	 DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], 7399 ; 00001ce7H
  000a6	7e 0c		 jle	 SHORT $LN27@GiveReward
  000a8	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
  000b2	eb 0a		 jmp	 SHORT $LN28@GiveReward
$LN27@GiveReward:
  000b4	c7 85 94 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv77[ebp], 1
$LN28@GiveReward:
  000be	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv77[ebp]
  000c4	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
$LN30@GiveReward:
  000ca	83 bd 98 fe ff
	ff 00		 cmp	 DWORD PTR tv78[ebp], 0
  000d1	74 4c		 je	 SHORT $LN6@GiveReward

; 3592 : 			LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon (%d) but Failed - Time Out", 

  000d3	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	0f b6 94 01 98
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+408]
  000e5	52		 push	 edx
  000e6	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], 7072
  000ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f3	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000f7	52		 push	 edx
  000f8	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iUserWhoGotUltimateWeapon$[ebp], 7072
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00105	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00109	52		 push	 edx
  0010a	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0010d	83 c0 01	 add	 eax, 1
  00110	50		 push	 eax
  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0011c	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@GiveReward:

; 3593 : 				iBridgeIndex+1,
; 3594 : 				gObj[iUserWhoGotUltimateWeapon].AccountID,
; 3595 : 				gObj[iUserWhoGotUltimateWeapon].Name,
; 3596 : 				m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER				
; 3597 : 				);
; 3598 : 		}
; 3599 : 	}
; 3600 : 
; 3601 : 	for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  0011f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00126	eb 09		 jmp	 SHORT $LN4@GiveReward
$LN2@GiveReward:
  00128	8b 45 f0	 mov	 eax, DWORD PTR _i$3[ebp]
  0012b	83 c0 01	 add	 eax, 1
  0012e	89 45 f0	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@GiveReward:
  00131	83 7d f0 0a	 cmp	 DWORD PTR _i$3[ebp], 10	; 0000000aH
  00135	0f 8d f3 04 00
	00		 jge	 $LN1@GiveReward

; 3602 : 		if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1)

  0013b	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00142	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00145	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00149	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0014d	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  00152	75 02		 jne	 SHORT $LN8@GiveReward

; 3603 : 			continue;

  00154	eb d2		 jmp	 SHORT $LN2@GiveReward
$LN8@GiveReward:

; 3604 : 
; 3605 : 		//     .
; 3606 : 		if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < 3) {

  00156	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0015d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00160	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00164	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  00168	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00170	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00176	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  0017b	7d 02		 jge	 SHORT $LN9@GiveReward

; 3607 : #ifdef BLOODCASTLE_SENDPOINT_BUGFIX_20040604
; 3608 : 			SendRewardScore (&m_BridgeData[iBridgeIndex].m_UserData[i], g_iBC_EventScore_Fail[iBridgeIndex], 0);
; 3609 : #endif
; 3610 : 			continue;

  0017d	eb a9		 jmp	 SHORT $LN2@GiveReward
$LN9@GiveReward:

; 3611 : 		}
; 3612 : 
; 3613 : 		if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1) || (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1))

  0017f	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00186	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00189	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0018d	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  00191	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00199	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019f	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  001a7	83 f8 ff	 cmp	 eax, -1
  001aa	74 2d		 je	 SHORT $LN11@GiveReward
  001ac	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001b3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b6	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  001ba	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  001be	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  001c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cc	0f be 84 0a d3
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3283]
  001d4	83 f8 ff	 cmp	 eax, -1
  001d7	75 05		 jne	 SHORT $LN10@GiveReward
$LN11@GiveReward:

; 3614 : 			continue;

  001d9	e9 4a ff ff ff	 jmp	 $LN2@GiveReward
$LN10@GiveReward:

; 3615 : 
; 3616 : 		//  ,      .
; 3617 : 		// 1 . 
; 3618 : 		INT iEXTRA_EXP = 0;

  001de	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], 0

; 3619 : 		if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1) &&
; 3620 : 			(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party)
; 3621 : 			||

  001e5	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  001f3	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  001f7	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  001ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00205	83 bc 0a 88 02
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+648], -1
  0020d	74 39		 je	 SHORT $LN15@GiveReward
  0020f	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00216	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00219	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0021d	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  00221	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00229	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00230	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00235	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00238	8b 8c 08 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+648]
  0023f	3b 8c 16 a0 01
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+416]
  00246	74 29		 je	 SHORT $LN14@GiveReward
$LN15@GiveReward:
  00248	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0024f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00252	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00256	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0025a	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00261	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00264	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  00268	3b 94 0e a4 01
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+420]
  0026f	75 1d		 jne	 SHORT $LN12@GiveReward
$LN14@GiveReward:

; 3622 : 			(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)
; 3623 : 			)
; 3624 : 		{
; 3625 : 			iEXTRA_EXP += g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_DOOR];

  00271	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00274	c1 e0 04	 shl	 eax, 4
  00277	b9 04 00 00 00	 mov	 ecx, 4
  0027c	6b d1 00	 imul	 edx, ecx, 0
  0027f	8b 4d ec	 mov	 ecx, DWORD PTR _iEXTRA_EXP$2[ebp]
  00282	03 8c 10 00 00
	00 00		 add	 ecx, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[eax+edx]
  00289	89 4d ec	 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], ecx

; 3626 : #if TESTSERVER == 1
; 3627 : 			LogAddTD("[ - ] [%s][%s]  : %d",
; 3628 : 				gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3629 : 				gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3630 : 				g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_DOOR]
; 3631 : 				);
; 3632 : #endif
; 3633 : 		}

  0028c	eb 65		 jmp	 SHORT $LN13@GiveReward
$LN12@GiveReward:

; 3634 : #ifdef FOR_BLOODCASTLE3
; 3635 : 		else if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1) {

  0028e	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00295	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00298	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0029c	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  002a0	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  002a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ae	83 bc 0a 88 02
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+648], -1
  002b6	74 3b		 je	 SHORT $LN13@GiveReward

; 3636 : 			//         50% .
; 3637 : 			if (m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak)

  002b8	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002bf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c2	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  002c6	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  002ca	0f b6 4c 02 29	 movzx	 ecx, BYTE PTR [edx+eax+41]
  002cf	85 c9		 test	 ecx, ecx
  002d1	74 20		 je	 SHORT $LN13@GiveReward

; 3638 : 				iEXTRA_EXP += g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_DOOR] / 2;

  002d3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  002d6	c1 e0 04	 shl	 eax, 4
  002d9	b9 04 00 00 00	 mov	 ecx, 4
  002de	6b d1 00	 imul	 edx, ecx, 0
  002e1	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[eax+edx]
  002e8	99		 cdq
  002e9	2b c2		 sub	 eax, edx
  002eb	d1 f8		 sar	 eax, 1
  002ed	03 45 ec	 add	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  002f0	89 45 ec	 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], eax
$LN13@GiveReward:

; 3639 : 		}
; 3640 : #endif
; 3641 : 
; 3642 : 		// 2 . 
; 3643 : 		if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1) &&
; 3644 : 			(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party)
; 3645 : 			||

  002f3	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002fd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00301	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  00305	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0030d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00313	83 bc 0a 88 02
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+648], -1
  0031b	74 39		 je	 SHORT $LN20@GiveReward
  0031d	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00324	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00327	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0032b	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0032f	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00337	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  0033e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00343	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00346	8b 8c 08 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+648]
  0034d	3b 8c 16 c0 01
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+448]
  00354	74 29		 je	 SHORT $LN19@GiveReward
$LN20@GiveReward:
  00356	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0035d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00360	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00364	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  00368	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0036f	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00372	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  00376	3b 94 0e c4 01
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+452]
  0037d	75 1b		 jne	 SHORT $LN18@GiveReward
$LN19@GiveReward:

; 3646 : 			(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)
; 3647 : 			)
; 3648 : 		{
; 3649 : 			iEXTRA_EXP += g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_STATUE];

  0037f	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00382	c1 e0 04	 shl	 eax, 4
  00385	b9 04 00 00 00	 mov	 ecx, 4
  0038a	c1 e1 00	 shl	 ecx, 0
  0038d	8b 55 ec	 mov	 edx, DWORD PTR _iEXTRA_EXP$2[ebp]
  00390	03 94 08 00 00
	00 00		 add	 edx, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[eax+ecx]
  00397	89 55 ec	 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], edx
$LN18@GiveReward:

; 3650 : #if TESTSERVER == 1 
; 3651 : 			LogAddTD("[ - ] [%s][%s]  : %d",
; 3652 : 				gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3653 : 				gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3654 : 				g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_STATUE]
; 3655 : 				);
; 3656 : #endif
; 3657 : 		}
; 3658 : 		
; 3659 : 		//  
; 3660 : 		CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iEXTRA_EXP);

  0039a	8b 45 ec	 mov	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  0039d	50		 push	 eax
  0039e	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  003a5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  003a8	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  003ac	6b 4d f0 14	 imul	 ecx, DWORD PTR _i$3[ebp], 20
  003b0	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  003b4	52		 push	 edx
  003b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003b8	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 3661 : 
; 3662 : 		//    
; 3663 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3664 : 		SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, g_iBC_EventScore_Fail[iBridgeIndex], 0, 0);

  003bd	6a 00		 push	 0
  003bf	6a 00		 push	 0
  003c1	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  003c4	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_iBC_EventScore_Fail@@3QBHB[eax*4]
  003cb	51		 push	 ecx
  003cc	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  003d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003d6	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  003da	6b 55 f0 14	 imul	 edx, DWORD PTR _i$3[ebp], 20
  003de	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  003e2	50		 push	 eax
  003e3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003e6	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3665 : #else
; 3666 : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 3667 : 		SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, g_iBC_EventScore_Fail[iBridgeIndex], 0);
; 3668 : #else
; 3669 : 		SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, g_iBC_EventScore_Fail[iBridgeIndex]);
; 3670 : #endif	// BLOODCASTLE_EVENT_3RD_20040401
; 3671 : #endif	// BLOODCASTLE_EVENT_5TH_20050531
; 3672 : 
; 3673 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3674 : 		LogAddTD("[Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, Score:%d, ExtEXP:%d, LeftTime:%d)", 

  003eb	6a 00		 push	 0
  003ed	8b 45 ec	 mov	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  003f0	50		 push	 eax
  003f1	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  003f4	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?g_iBC_EventScore_Fail@@3QBHB[ecx*4]
  003fb	52		 push	 edx
  003fc	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00403	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00406	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0040a	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0040e	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00416	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0041c	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00420	50		 push	 eax
  00421	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00428	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0042b	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0042f	6b 4d f0 14	 imul	 ecx, DWORD PTR _i$3[ebp], 20
  00433	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  0043b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00440	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00444	51		 push	 ecx
  00445	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00448	83 c2 01	 add	 edx, 1
  0044b	52		 push	 edx
  0044c	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5@
  00451	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00457	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3675 : #else
; 3676 : 		LogAddTD("[Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, Score:%d, ExtEXP:%d)",
; 3677 : #endif
; 3678 : 			iBridgeIndex+1,
; 3679 : 			gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3680 : 			gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3681 : 			g_iBC_EventScore_Fail[iBridgeIndex],
; 3682 : 			iEXTRA_EXP
; 3683 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3684 : 			,0
; 3685 : #endif
; 3686 : 			);
; 3687 : 
; 3688 : 
; 3689 : 		//    .
; 3690 : 		PMSG_DEVILSQUARERESULT pMsg;
; 3691 : 		pMsg.MyRank = 0;	// 

  0045a	c6 85 df fe ff
	ff 00		 mov	 BYTE PTR _pMsg$1[ebp+3], 0

; 3692 : 		pMsg.Count = 255;

  00461	c6 85 e0 fe ff
	ff ff		 mov	 BYTE PTR _pMsg$1[ebp+4], 255 ; 000000ffH

; 3693 : 		memcpy(pMsg.Score[0].Name, gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, sizeof(pMsg.Score[0].Name));

  00468	6a 0a		 push	 10			; 0000000aH
  0046a	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00471	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00474	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00478	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0047c	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00484	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0048a	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0048e	50		 push	 eax
  0048f	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00494	6b d1 00	 imul	 edx, ecx, 0
  00497	8d 84 15 e1 fe
	ff ff		 lea	 eax, DWORD PTR _pMsg$1[ebp+edx+5]
  0049e	50		 push	 eax
  0049f	e8 00 00 00 00	 call	 _memcpy
  004a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3694 : 		pMsg.Score[0].BonusExp		= iEXTRA_EXP;

  004a7	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  004ac	6b c8 00	 imul	 ecx, eax, 0
  004af	8b 55 ec	 mov	 edx, DWORD PTR _iEXTRA_EXP$2[ebp]
  004b2	89 94 0d f1 fe
	ff ff		 mov	 DWORD PTR _pMsg$1[ebp+ecx+21], edx

; 3695 : 		pMsg.Score[0].BonusZen		= 0;

  004b9	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  004be	6b c8 00	 imul	 ecx, eax, 0
  004c1	c7 84 0d f5 fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _pMsg$1[ebp+ecx+25], 0

; 3696 : 		pMsg.Score[0].TotalScore	= g_iBC_EventScore_Fail[iBridgeIndex];

  004cc	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  004d1	6b c8 00	 imul	 ecx, eax, 0
  004d4	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  004d7	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_EventScore_Fail@@3QBHB[edx*4]
  004de	89 84 0d ed fe
	ff ff		 mov	 DWORD PTR _pMsg$1[ebp+ecx+17], eax

; 3697 : 		PHeadSetB((LPBYTE)&pMsg, 0x93, sizeof(PBMSG_HEAD) + 2 + sizeof(DevilSquareScoreInfo) * 2);

  004e5	6a 35		 push	 53			; 00000035H
  004e7	68 93 00 00 00	 push	 147			; 00000093H
  004ec	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  004f2	50		 push	 eax
  004f3	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  004f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3698 : 
; 3699 : 		//           .
; 3700 : 		if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1) && (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1)) {

  004fb	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00502	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00505	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00509	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0050d	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00515	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0051b	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  00523	83 f8 ff	 cmp	 eax, -1
  00526	0f 84 fd 00 00
	00		 je	 $LN21@GiveReward
  0052c	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00533	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00536	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0053a	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0053e	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00546	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0054c	0f be 84 0a d3
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3283]
  00554	83 f8 ff	 cmp	 eax, -1
  00557	0f 84 cc 00 00
	00		 je	 $LN21@GiveReward

; 3701 : 			//       
; 3702 : 			DataSend(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0055d	0f b6 85 dd fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00564	50		 push	 eax
  00565	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  0056b	51		 push	 ecx
  0056c	69 55 08 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00573	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00576	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0057a	6b 55 f0 14	 imul	 edx, DWORD PTR _i$3[ebp], 20
  0057e	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  00582	50		 push	 eax
  00583	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00588	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3703 : 			LogAddTD("[Blood Castle] (%d) Send User Quest Fail Message (Account:%s, Name:%s [State:%d], MapNumber:%d)",

  0058b	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00592	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00595	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00599	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0059d	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  005a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ab	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  005b3	50		 push	 eax
  005b4	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  005bb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005be	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  005c2	6b 4d f0 14	 imul	 ecx, DWORD PTR _i$3[ebp], 20
  005c6	8b 54 08 24	 mov	 edx, DWORD PTR [eax+ecx+36]
  005ca	52		 push	 edx
  005cb	69 45 08 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  005d2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005d5	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  005d9	6b 45 f0 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  005dd	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  005e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005eb	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  005ef	50		 push	 eax
  005f0	69 4d 08 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  005f7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  005fa	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  005fe	6b 4d f0 14	 imul	 ecx, DWORD PTR _i$3[ebp], 20
  00602	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  0060a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0060f	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00613	51		 push	 ecx
  00614	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00617	83 c2 01	 add	 edx, 1
  0061a	52		 push	 edx
  0061b	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Q@
  00620	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00626	83 c4 18	 add	 esp, 24			; 00000018H
$LN21@GiveReward:

; 3704 : 				iBridgeIndex+1,
; 3705 : 				gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3706 : 				gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3707 : 				m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState,
; 3708 : 				gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber
; 3709 : 				);
; 3710 : 		}
; 3711 : 
; 3712 : //		SendBridgeAnyMsg((LPBYTE)&pMsg, pMsg.h.size, iBridgeIndex);
; 3713 : 	}	

  00629	e9 fa fa ff ff	 jmp	 $LN2@GiveReward
$LN1@GiveReward:

; 3714 : }

  0062e	5f		 pop	 edi
  0062f	5e		 pop	 esi
  00630	5b		 pop	 ebx
  00631	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00634	33 cd		 xor	 ecx, ebp
  00636	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0063b	8b e5		 mov	 esp, ebp
  0063d	5d		 pop	 ebp
  0063e	c2 04 00	 ret	 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::GiveReward_Fail
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?GiveReward_Win@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv857 = -980						; size = 4
tv707 = -980						; size = 4
tv89 = -980						; size = 4
tv84 = -980						; size = 4
tv858 = -976						; size = 4
tv708 = -976						; size = 4
tv418 = -976						; size = 4
tv90 = -976						; size = 4
tv85 = -976						; size = 4
_pMsg$1 = -844						; size = 269
_iEXTRA_EXP$2 = -572					; size = 4
_pNotice$3 = -568					; size = 272
_i$4 = -296						; size = 4
_iALIVE_USER_TOTAL_EXP$5 = -292				; size = 4
_iADD_PARTYPOINT$ = -288				; size = 4
_iALIVE_PARTYCOUNT$ = -284				; size = 4
_iLEFT_TIME$ = -280					; size = 4
_iREWARD_SCR$ = -276					; size = 4
_iREWARD_ZEN$ = -272					; size = 4
_iREWARD_EXP$ = -268					; size = 4
_szNOTIFY_MSG$ = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iBridgeIndex$ = 12					; size = 4
?GiveReward_Win@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::GiveReward_Win, COMDAT
; _this$ = ecx

; 3101 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 03 00
	00		 sub	 esp, 980		; 000003d4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3102 : #ifdef BLOODCASTLE_EVENT_5TH_20050531		//      .
; 3103 : 	FixUsersPlayStateWin(iBridgeIndex);

  00019	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateWin

; 3104 : #endif
; 3105 : 
; 3106 : 	CHAR szNOTIFY_MSG [256];
; 3107 : 	INT iREWARD_EXP = 0;

  00025	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iREWARD_EXP$[ebp], 0

; 3108 : 	INT iREWARD_ZEN = 0;

  0002f	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iREWARD_ZEN$[ebp], 0

; 3109 : 	INT iREWARD_SCR = 0;

  00039	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iREWARD_SCR$[ebp], 0

; 3110 : 
; 3111 : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 3112 : 	INT iLEFT_TIME = m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  00043	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00054	99		 cdq
  00055	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0005a	f7 f9		 idiv	 ecx
  0005c	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iLEFT_TIME$[ebp], eax

; 3113 : #endif
; 3114 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3115 : 	INT iALIVE_PARTYCOUNT = GetWinnerPartyCompleteCount(iBridgeIndex);

  00062	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00065	50		 push	 eax
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
  0006e	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _iALIVE_PARTYCOUNT$[ebp], eax

; 3116 : 	INT iADD_PARTYPOINT = GetWinnerPartyCompletePoint(iBridgeIndex);

  00074	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
  00080	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _iADD_PARTYPOINT$[ebp], eax

; 3117 : 
; 3118 : 	LogAddTD("[Blood Castle] (%d) Winner Party Point - Alive Party Member : %d, Alive Party Point : %d", 

  00086	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _iADD_PARTYPOINT$[ebp]
  0008c	50		 push	 eax
  0008d	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  00093	51		 push	 ecx
  00094	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00097	83 c2 01	 add	 edx, 1
  0009a	52		 push	 edx
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Part@
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a6	83 c4 10	 add	 esp, 16			; 00000010H

; 3119 : 		iBridgeIndex + 1,
; 3120 : 		iALIVE_PARTYCOUNT,
; 3121 : 		iADD_PARTYPOINT
; 3122 : 		);
; 3123 : #endif
; 3124 : 
; 3125 : 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  000a9	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  000ad	7d 0c		 jge	 SHORT $LN39@GiveReward
  000af	c7 85 30 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv85[ebp], 0
  000b9	eb 2b		 jmp	 SHORT $LN40@GiveReward
$LN39@GiveReward:
  000bb	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  000c2	7e 0c		 jle	 SHORT $LN37@GiveReward
  000c4	c7 85 2c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv84[ebp], 0
  000ce	eb 0a		 jmp	 SHORT $LN38@GiveReward
$LN37@GiveReward:
  000d0	c7 85 2c fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv84[ebp], 1
$LN38@GiveReward:
  000da	8b 85 2c fc ff
	ff		 mov	 eax, DWORD PTR tv84[ebp]
  000e0	89 85 30 fc ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
$LN40@GiveReward:
  000e6	83 bd 30 fc ff
	ff 00		 cmp	 DWORD PTR tv85[ebp], 0
  000ed	75 05		 jne	 SHORT $LN7@GiveReward

; 3126 : 		return;

  000ef	e9 18 11 00 00	 jmp	 $LN1@GiveReward
$LN7@GiveReward:

; 3127 : 	
; 3128 : 	if (!CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  000f4	83 7d 0c 00	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 0
  000f8	7d 0c		 jge	 SHORT $LN43@GiveReward
  000fa	c7 85 30 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
  00104	eb 28		 jmp	 SHORT $LN44@GiveReward
$LN43@GiveReward:
  00106	83 7d 0c 06	 cmp	 DWORD PTR _iBridgeIndex$[ebp], 6
  0010a	7e 0c		 jle	 SHORT $LN41@GiveReward
  0010c	c7 85 2c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv89[ebp], 0
  00116	eb 0a		 jmp	 SHORT $LN42@GiveReward
$LN41@GiveReward:
  00118	c7 85 2c fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv89[ebp], 1
$LN42@GiveReward:
  00122	8b 85 2c fc ff
	ff		 mov	 eax, DWORD PTR tv89[ebp]
  00128	89 85 30 fc ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
$LN44@GiveReward:
  0012e	83 bd 30 fc ff
	ff 00		 cmp	 DWORD PTR tv90[ebp], 0
  00135	75 05		 jne	 SHORT $LN8@GiveReward

; 3129 : 		return;

  00137	e9 d0 10 00 00	 jmp	 $LN1@GiveReward
$LN8@GiveReward:

; 3130 : 
; 3131 : 	if (m_BridgeData[iBridgeIndex].m_bBC_REWARDED)

  0013c	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00143	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	0f b6 94 01 66
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+358]
  0014e	85 d2		 test	 edx, edx
  00150	74 05		 je	 SHORT $LN9@GiveReward

; 3132 : 		return;

  00152	e9 b5 10 00 00	 jmp	 $LN1@GiveReward
$LN9@GiveReward:

; 3133 : 
; 3134 : 	if (gObj[iIndex].Connected > 2) {

  00157	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00164	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00169	7e 4f		 jle	 SHORT $LN10@GiveReward

; 3135 : 		gObj[iIndex].Name[10] = '\0';

  0016b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00172	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00178	b9 01 00 00 00	 mov	 ecx, 1
  0017d	6b d1 0a	 imul	 edx, ecx, 10
  00180	c6 44 10 73 00	 mov	 BYTE PTR [eax+edx+115], 0

; 3136 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(1165), gObj[iIndex].Name);		// "%s     ."

  00185	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0018c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00192	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00196	52		 push	 edx
  00197	68 8d 04 00 00	 push	 1165			; 0000048dH
  0019c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001a7	50		 push	 eax
  001a8	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  001ae	50		 push	 eax
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3137 : 	}

  001b8	eb 21		 jmp	 SHORT $LN11@GiveReward
$LN10@GiveReward:

; 3138 : 	else {
; 3139 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(1166));							// "  ."

  001ba	68 8e 04 00 00	 push	 1166			; 0000048eH
  001bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001ca	50		 push	 eax
  001cb	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  001d1	50		 push	 eax
  001d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001d8	83 c4 08	 add	 esp, 8
$LN11@GiveReward:

; 3140 : 	}
; 3141 : 
; 3142 : 	if (m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1) {			//  

  001db	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  001e2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e5	83 bc 01 48 01
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+328], -1
  001ed	0f 84 19 10 00
	00		 je	 $LN1@GiveReward

; 3143 : 		//      .
; 3144 : 		INT iALIVE_USER_TOTAL_EXP = GetAliveUserTotalEXP(iBridgeIndex);

  001f3	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  001f6	50		 push	 eax
  001f7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fa	e8 00 00 00 00	 call	 ?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ; CBloodCastle::GetAliveUserTotalEXP
  001ff	89 85 dc fe ff
	ff		 mov	 DWORD PTR _iALIVE_USER_TOTAL_EXP$5[ebp], eax

; 3145 : 		LogAddTD("[Blood Castle] (%d) Quest Complete - All Alive User's Total EXP:%d",

  00205	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _iALIVE_USER_TOTAL_EXP$5[ebp]
  0020b	50		 push	 eax
  0020c	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0020f	83 c1 01	 add	 ecx, 1
  00212	51		 push	 ecx
  00213	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0021e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3146 : 			iBridgeIndex+1,
; 3147 : 			iALIVE_USER_TOTAL_EXP
; 3148 : 			);
; 3149 : 
; 3150 : 
; 3151 : 		for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  00221	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$4[ebp], 0
  0022b	eb 0f		 jmp	 SHORT $LN4@GiveReward
$LN2@GiveReward:
  0022d	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _i$4[ebp]
  00233	83 c0 01	 add	 eax, 1
  00236	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _i$4[ebp], eax
$LN4@GiveReward:
  0023c	83 bd d8 fe ff
	ff 0a		 cmp	 DWORD PTR _i$4[ebp], 10	; 0000000aH
  00243	0f 8d b1 0f 00
	00		 jge	 $LN3@GiveReward

; 3152 : 			if (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1)

  00249	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00250	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00253	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00257	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  0025e	83 7c 02 18 ff	 cmp	 DWORD PTR [edx+eax+24], -1
  00263	75 02		 jne	 SHORT $LN13@GiveReward

; 3153 : 				continue;

  00265	eb c6		 jmp	 SHORT $LN2@GiveReward
$LN13@GiveReward:

; 3154 : 			
; 3155 : 			//     .
; 3156 : 			if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < 3) {

  00267	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0026e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00271	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00275	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  0027c	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00284	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0028a	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  0028f	7d 02		 jge	 SHORT $LN14@GiveReward

; 3157 : #ifdef BLOODCASTLE_SENDPOINT_BUGFIX_20040604
; 3158 : 				SendRewardScore (&m_BridgeData[iBridgeIndex].m_UserData[i], g_iBC_EventScore_Fail[iBridgeIndex], 0);
; 3159 : #endif
; 3160 : 				continue;

  00291	eb 9a		 jmp	 SHORT $LN2@GiveReward
$LN14@GiveReward:

; 3161 : 			}
; 3162 : 
; 3163 : 			if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1) || 
; 3164 : 				(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1) ||

  00293	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0029a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0029d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  002a1	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  002a8	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  002b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b6	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  002be	83 f8 ff	 cmp	 eax, -1
  002c1	74 60		 je	 SHORT $LN16@GiveReward
  002c3	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002ca	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  002d1	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  002d8	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  002e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e6	0f be 84 0a d3
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3283]
  002ee	83 f8 ff	 cmp	 eax, -1
  002f1	74 30		 je	 SHORT $LN16@GiveReward
  002f3	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  002fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002fd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00301	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00308	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00310	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00316	0f be 84 0a d2
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3282]
  0031e	3b 45 0c	 cmp	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00321	74 05		 je	 SHORT $LN15@GiveReward
$LN16@GiveReward:

; 3165 : 				(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex)
; 3166 : 				) 
; 3167 : 			{
; 3168 : 				//    
; 3169 : 				continue;

  00323	e9 05 ff ff ff	 jmp	 $LN2@GiveReward
$LN15@GiveReward:

; 3170 : 			}
; 3171 : 
; 3172 : 			//   
; 3173 : 			
; 3174 : #ifdef MODIFY_NOTICE_20040325
; 3175 : 			PMSG_NOTICE	pNotice;
; 3176 : 			TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNOTIFY_MSG );

  00328	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  0032e	50		 push	 eax
  0032f	6a 0a		 push	 10			; 0000000aH
  00331	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR _pNotice$3[ebp]
  00337	51		 push	 ecx
  00338	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  0033d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3177 : 			TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_BLUE);

  00340	6a 14		 push	 20			; 00000014H
  00342	6a 00		 push	 0
  00344	6a 01		 push	 1
  00346	68 c4 00 00 00	 push	 196			; 000000c4H
  0034b	68 95 00 00 00	 push	 149			; 00000095H
  00350	68 80 00 00 00	 push	 128			; 00000080H
  00355	68 ff 00 00 00	 push	 255			; 000000ffH
  0035a	e8 00 00 00 00	 call	 ?_ARGB@@YAKEEEE@Z	; _ARGB
  0035f	83 c4 10	 add	 esp, 16			; 00000010H
  00362	50		 push	 eax
  00363	6a 0a		 push	 10			; 0000000aH
  00365	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  0036b	50		 push	 eax
  0036c	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty
  00371	83 c4 18	 add	 esp, 24			; 00000018H

; 3178 : 			TNotice::SendNoticeToUser( m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, &pNotice );

  00374	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  0037a	50		 push	 eax
  0037b	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00382	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00385	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00389	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00390	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00394	52		 push	 edx
  00395	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser
  0039a	83 c4 08	 add	 esp, 8

; 3179 : #else
; 3180 : 			GCServerMsgStringSend(szNOTIFY_MSG, m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, 0);
; 3181 : #endif
; 3182 : 
; 3183 : 			//  , ,       .
; 3184 : 			// 1 . 
; 3185 : 			INT iEXTRA_EXP = 0;

  0039d	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], 0

; 3186 : 			if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1) &&
; 3187 : 				(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party) 
; 3188 : 				||

  003a7	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  003ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003b1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  003b5	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  003bc	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  003c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ca	83 bc 0a 88 02
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+648], -1
  003d2	74 3c		 je	 SHORT $LN20@GiveReward
  003d4	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  003db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003de	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  003e2	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  003e9	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  003f1	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  003f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003fd	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00400	8b 8c 08 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+648]
  00407	3b 8c 16 a0 01
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+416]
  0040e	74 2c		 je	 SHORT $LN19@GiveReward
$LN20@GiveReward:
  00410	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00417	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0041a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0041e	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00425	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0042c	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0042f	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  00433	3b 94 0e a4 01
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+420]
  0043a	75 23		 jne	 SHORT $LN17@GiveReward
$LN19@GiveReward:

; 3189 : 				(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)
; 3190 : 				)
; 3191 : 			{
; 3192 : 				iEXTRA_EXP += g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_DOOR];

  0043c	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0043f	c1 e0 04	 shl	 eax, 4
  00442	b9 04 00 00 00	 mov	 ecx, 4
  00447	6b d1 00	 imul	 edx, ecx, 0
  0044a	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _iEXTRA_EXP$2[ebp]
  00450	03 8c 10 00 00
	00 00		 add	 ecx, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[eax+edx]
  00457	89 8d c4 fd ff
	ff		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], ecx

; 3193 : #if TESTSERVER == 1 
; 3194 : 				LogAddTD("[ - ] [%s][%s]  : %d",
; 3195 : 					gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3196 : 					gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3197 : 					g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_DOOR]
; 3198 : 					);
; 3199 : #endif
; 3200 : 			}

  0045d	eb 71		 jmp	 SHORT $LN18@GiveReward
$LN17@GiveReward:

; 3201 : #ifdef FOR_BLOODCASTLE3
; 3202 : 			else if (gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1) {

  0045f	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00466	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00469	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0046d	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00474	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0047c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00482	83 bc 0a 88 02
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+648], -1
  0048a	74 44		 je	 SHORT $LN18@GiveReward

; 3203 : 				//         50% .
; 3204 : 				if (m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak)

  0048c	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00493	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00496	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0049a	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  004a1	0f b6 4c 02 29	 movzx	 ecx, BYTE PTR [edx+eax+41]
  004a6	85 c9		 test	 ecx, ecx
  004a8	74 26		 je	 SHORT $LN18@GiveReward

; 3205 : 					iEXTRA_EXP += g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_DOOR] / 2;

  004aa	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  004ad	c1 e0 04	 shl	 eax, 4
  004b0	b9 04 00 00 00	 mov	 ecx, 4
  004b5	6b d1 00	 imul	 edx, ecx, 0
  004b8	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[eax+edx]
  004bf	99		 cdq
  004c0	2b c2		 sub	 eax, edx
  004c2	d1 f8		 sar	 eax, 1
  004c4	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  004ca	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], eax
$LN18@GiveReward:

; 3206 : 			}
; 3207 : #endif
; 3208 : 			// 2 . 
; 3209 : 			if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1) &&
; 3210 : 				(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party)
; 3211 : 				||

  004d0	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  004d7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004da	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  004de	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  004e5	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  004ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004f3	83 bc 0a 88 02
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+648], -1
  004fb	74 3c		 je	 SHORT $LN25@GiveReward
  004fd	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00504	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00507	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0050b	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00512	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0051a	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00521	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00526	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00529	8b 8c 08 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+648]
  00530	3b 8c 16 c0 01
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+448]
  00537	74 2c		 je	 SHORT $LN24@GiveReward
$LN25@GiveReward:
  00539	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00540	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00543	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00547	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  0054e	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00555	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00558	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  0055c	3b 94 0e c4 01
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+452]
  00563	75 21		 jne	 SHORT $LN23@GiveReward
$LN24@GiveReward:

; 3212 : 				(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)
; 3213 : 				)
; 3214 : 			{
; 3215 : 				iEXTRA_EXP += g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_STATUE];

  00565	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00568	c1 e0 04	 shl	 eax, 4
  0056b	b9 04 00 00 00	 mov	 ecx, 4
  00570	c1 e1 00	 shl	 ecx, 0
  00573	8b 95 c4 fd ff
	ff		 mov	 edx, DWORD PTR _iEXTRA_EXP$2[ebp]
  00579	03 94 08 00 00
	00 00		 add	 edx, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[eax+ecx]
  00580	89 95 c4 fd ff
	ff		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], edx
$LN23@GiveReward:

; 3216 : #if TESTSERVER == 1 
; 3217 : 				LogAddTD("[ - ] [%s][%s]  : %d",
; 3218 : 					gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3219 : 					gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3220 : 					g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_KILL_STATUE]
; 3221 : 					);
; 3222 : #endif
; 3223 : 			}
; 3224 : 			// 3 . 
; 3225 : 			if ((gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1) &&
; 3226 : 				(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party)
; 3227 : 				||

  00586	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0058d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00590	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00594	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  0059b	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  005a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a9	83 bc 0a 88 02
	00 00 ff	 cmp	 DWORD PTR [edx+ecx+648], -1
  005b1	74 3c		 je	 SHORT $LN28@GiveReward
  005b3	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  005ba	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005bd	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  005c1	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  005c8	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  005d0	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  005d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005dc	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  005df	8b 8c 08 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+648]
  005e6	3b 8c 16 e0 01
	00 00		 cmp	 ecx, DWORD PTR [esi+edx+480]
  005ed	74 2c		 je	 SHORT $LN27@GiveReward
$LN28@GiveReward:
  005ef	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  005f6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005f9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  005fd	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00604	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0060b	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0060e	8b 54 02 18	 mov	 edx, DWORD PTR [edx+eax+24]
  00612	3b 94 0e e4 01
	00 00		 cmp	 edx, DWORD PTR [esi+ecx+484]
  00619	75 20		 jne	 SHORT $LN26@GiveReward
$LN27@GiveReward:

; 3228 : 				(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index)
; 3229 : 				)
; 3230 : 			{
; 3231 : 				iEXTRA_EXP += g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_WIN_QUEST];

  0061b	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0061e	c1 e0 04	 shl	 eax, 4
  00621	b9 04 00 00 00	 mov	 ecx, 4
  00626	d1 e1		 shl	 ecx, 1
  00628	8b 95 c4 fd ff
	ff		 mov	 edx, DWORD PTR _iEXTRA_EXP$2[ebp]
  0062e	03 94 08 00 00
	00 00		 add	 edx, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[eax+ecx]
  00635	89 95 c4 fd ff
	ff		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], edx
$LN26@GiveReward:

; 3232 : #if TESTSERVER == 1 
; 3233 : 				LogAddTD("[ - ] [%s][%s]  : %d",
; 3234 : 					gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3235 : 					gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3236 : 					g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_WIN_QUEST]
; 3237 : 					);
; 3238 : #endif
; 3239 : 			}
; 3240 : 
; 3241 : 
; 3242 : 			//           .
; 3243 : 			switch (m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState) {

  0063b	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00642	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00645	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00649	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00650	8b 4c 02 24	 mov	 ecx, DWORD PTR [edx+eax+36]
  00654	89 8d 30 fc ff
	ff		 mov	 DWORD PTR tv418[ebp], ecx
  0065a	83 bd 30 fc ff
	ff 04		 cmp	 DWORD PTR tv418[ebp], 4
  00661	0f 87 b8 0a 00
	00		 ja	 $LN5@GiveReward
  00667	8b 95 30 fc ff
	ff		 mov	 edx, DWORD PTR tv418[ebp]
  0066d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN53@GiveReward[edx*4]
$LN29@GiveReward:

; 3244 : 			case BC_USER_ALIVE :		
; 3245 : 				{
; 3246 : #ifdef FOR_BLOODCASTLE2	
; 3247 : 					//    
; 3248 : 	#if TESTSERVER == 1 
; 3249 : 					LogAddTD("[]  () : %d", iREWARD_EXP);
; 3250 : 	#endif
; 3251 : 					iEXTRA_EXP += (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000) * g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_PER_SEC];

  00674	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0067b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0067e	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00685	99		 cdq
  00686	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0068b	f7 f9		 idiv	 ecx
  0068d	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00690	c1 e2 04	 shl	 edx, 4
  00693	b9 04 00 00 00	 mov	 ecx, 4
  00698	6b c9 03	 imul	 ecx, ecx, 3
  0069b	0f af 84 0a 00
	00 00 00	 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[edx+ecx]
  006a3	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  006a9	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], eax

; 3252 : 	#if TESTSERVER == 1 
; 3253 : 					LogAddTD("[]  () : Exp:(%d) RemainSec:(%d)", iREWARD_EXP, m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000);
; 3254 : 	#endif
; 3255 : #endif
; 3256 : 					//  
; 3257 : //					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iALIVE_USER_TOTAL_EXP * g_iQuestWinExpendEXP[iBridgeIndex][BC_REWARD_ALIVE] / 100 + iEXTRA_EXP);
; 3258 : 					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iEXTRA_EXP);

  006af	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  006b5	50		 push	 eax
  006b6	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  006bd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  006c0	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  006c4	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  006cb	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  006cf	52		 push	 edx
  006d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006d3	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  006d8	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 3259 : 					//  
; 3260 : 					iREWARD_ZEN = CalcSendRewardZEN (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, g_iQuestWinExpendZEN[iBridgeIndex][BC_REWARD_LOSER]);

  006de	b8 04 00 00 00	 mov	 eax, 4
  006e3	c1 e0 00	 shl	 eax, 0
  006e6	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  006e9	8b 94 c8 00 00
	00 00		 mov	 edx, DWORD PTR ?g_iQuestWinExpendZEN@@3QAY01$$CBHA[eax+ecx*8]
  006f0	52		 push	 edx
  006f1	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  006f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006fb	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  006ff	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00706	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0070a	51		 push	 ecx
  0070b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0070e	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  00713	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 3261 : 					//  
; 3262 : 					iREWARD_SCR = g_iBC_EventScore[iBridgeIndex][BC_USER_ALIVE];

  00719	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 20
  0071d	b9 04 00 00 00	 mov	 ecx, 4
  00722	6b d1 00	 imul	 edx, ecx, 0
  00725	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_EventScore@@3QAY04$$CBHA[eax+edx]
  0072c	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], eax

; 3263 : 
; 3264 : /*					wsprintf(szNOTIFY_MSG2, lMsg.Get(1167),	// " %d  %d , %d   ."
; 3265 : 						iREWARD_EXP, 
; 3266 : 						iREWARD_ZEN,
; 3267 : 						iREWARD_SCR
; 3268 : 						);
; 3269 : */
; 3270 : 					//    
; 3271 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3272 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  00732	6a 00		 push	 0
  00734	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iLEFT_TIME$[ebp]
  0073a	50		 push	 eax
  0073b	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_SCR$[ebp]
  00741	51		 push	 ecx
  00742	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00749	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0074c	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00750	6b 95 d8 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$4[ebp], 20
  00757	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  0075b	50		 push	 eax
  0075c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0075f	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3273 : #else
; 3274 : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 3275 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME);
; 3276 : #else
; 3277 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR);
; 3278 : #endif	// BLOODCASTLE_EVENT_3RD_20040401
; 3279 : #endif	// BLOODCASTLE_EVENT_5TH_20050531
; 3280 : 
; 3281 : 
; 3282 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3283 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", 

  00764	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0076b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0076e	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00772	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00779	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00781	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00787	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  0078f	50		 push	 eax
  00790	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  00796	51		 push	 ecx
  00797	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  0079d	52		 push	 edx
  0079e	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  007a4	50		 push	 eax
  007a5	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  007ab	51		 push	 ecx
  007ac	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  007b3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007b6	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  007ba	6b 95 d8 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$4[ebp], 20
  007c1	69 44 11 18 a0
	1b 00 00	 imul	 eax, DWORD PTR [ecx+edx+24], 7072
  007c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007cf	8b 94 01 d4 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3284]
  007d6	52		 push	 edx
  007d7	6a 00		 push	 0
  007d9	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  007e0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007e3	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  007e7	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  007ee	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  007f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007fc	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00800	50		 push	 eax
  00801	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00808	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0080b	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  0080f	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00816	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  0081e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00823	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00827	51		 push	 ecx
  00828	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0082b	83 c2 01	 add	 edx, 1
  0082e	52		 push	 edx
  0082f	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@
  00834	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0083a	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3284 : #else
; 3285 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d)", 
; 3286 : #endif
; 3287 : 						iBridgeIndex+1,
; 3288 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3289 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3290 : 						BC_USER_ALIVE,
; 3291 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3292 : 						iREWARD_EXP,
; 3293 : 						iREWARD_ZEN,
; 3294 : 						iREWARD_SCR
; 3295 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3296 : 						,iLEFT_TIME
; 3297 : 						,gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber
; 3298 : #endif
; 3299 : 						);
; 3300 : 				}
; 3301 : 				break;

  0083d	e9 dd 08 00 00	 jmp	 $LN5@GiveReward
$LN30@GiveReward:

; 3302 : 			case BC_USER_DEAD :				
; 3303 : 				{
; 3304 : #ifdef FOR_BLOODCASTLE2	
; 3305 : 					//    
; 3306 : 	#if TESTSERVER == 1 
; 3307 : 					LogAddTD("[]  () : %d", iREWARD_EXP);
; 3308 : 	#endif
; 3309 : 					iEXTRA_EXP += (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000) * g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_PER_SEC];

  00842	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00849	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0084c	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00853	99		 cdq
  00854	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00859	f7 f9		 idiv	 ecx
  0085b	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0085e	c1 e2 04	 shl	 edx, 4
  00861	b9 04 00 00 00	 mov	 ecx, 4
  00866	6b c9 03	 imul	 ecx, ecx, 3
  00869	0f af 84 0a 00
	00 00 00	 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[edx+ecx]
  00871	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  00877	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], eax

; 3310 : 	#if TESTSERVER == 1 
; 3311 : 					LogAddTD("[]  () : Exp:(%d) RemainSec:(%d)", iREWARD_EXP, m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000);
; 3312 : 	#endif
; 3313 : #endif
; 3314 : 					//  
; 3315 : //					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iALIVE_USER_TOTAL_EXP * g_iQuestWinExpendEXP[iBridgeIndex][BC_REWARD_LOSER] / 100 + iEXTRA_EXP);
; 3316 : 					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iEXTRA_EXP);

  0087d	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  00883	50		 push	 eax
  00884	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  0088b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0088e	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00892	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00899	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  0089d	52		 push	 edx
  0089e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008a1	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  008a6	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 3317 : 					//  
; 3318 : 					iREWARD_ZEN = CalcSendRewardZEN (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, g_iQuestWinExpendZEN[iBridgeIndex][BC_REWARD_LOSER]);

  008ac	b8 04 00 00 00	 mov	 eax, 4
  008b1	c1 e0 00	 shl	 eax, 0
  008b4	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  008b7	8b 94 c8 00 00
	00 00		 mov	 edx, DWORD PTR ?g_iQuestWinExpendZEN@@3QAY01$$CBHA[eax+ecx*8]
  008be	52		 push	 edx
  008bf	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  008c6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008c9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  008cd	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  008d4	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  008d8	51		 push	 ecx
  008d9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008dc	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  008e1	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 3319 : 					//  
; 3320 : 					iREWARD_SCR = g_iBC_EventScore[iBridgeIndex][BC_USER_DEAD];

  008e7	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 20
  008eb	b9 04 00 00 00	 mov	 ecx, 4
  008f0	c1 e1 00	 shl	 ecx, 0
  008f3	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?g_iBC_EventScore@@3QAY04$$CBHA[eax+ecx]
  008fa	89 95 ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], edx

; 3321 : 
; 3322 : /*					wsprintf(szNOTIFY_MSG2, lMsg.Get(1167),	// " %d  %d , %d   ."
; 3323 : 						iREWARD_EXP,
; 3324 : 						iREWARD_ZEN,
; 3325 : 						iREWARD_SCR
; 3326 : 						);
; 3327 : */
; 3328 : 					//    
; 3329 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3330 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  00900	6a 00		 push	 0
  00902	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iLEFT_TIME$[ebp]
  00908	50		 push	 eax
  00909	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_SCR$[ebp]
  0090f	51		 push	 ecx
  00910	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00917	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0091a	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0091e	6b 95 d8 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$4[ebp], 20
  00925	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  00929	50		 push	 eax
  0092a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0092d	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3331 : #else
; 3332 : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 3333 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME);
; 3334 : #else
; 3335 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR);
; 3336 : #endif	// BLOODCASTLE_EVENT_3RD_20040401
; 3337 : #endif	// BLOODCASTLE_EVENT_5TH_20050531
; 3338 : 
; 3339 : 
; 3340 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3341 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", 

  00932	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00939	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0093c	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00940	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00947	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0094f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00955	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  0095d	50		 push	 eax
  0095e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  00964	51		 push	 ecx
  00965	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  0096b	52		 push	 edx
  0096c	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  00972	50		 push	 eax
  00973	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  00979	51		 push	 ecx
  0097a	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00981	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00984	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00988	6b 95 d8 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$4[ebp], 20
  0098f	69 44 11 18 a0
	1b 00 00	 imul	 eax, DWORD PTR [ecx+edx+24], 7072
  00997	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0099d	8b 94 01 d4 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3284]
  009a4	52		 push	 edx
  009a5	6a 01		 push	 1
  009a7	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  009ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009b1	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  009b5	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  009bc	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  009c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009ca	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  009ce	50		 push	 eax
  009cf	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  009d6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  009d9	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  009dd	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  009e4	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  009ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009f1	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  009f5	51		 push	 ecx
  009f6	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  009f9	83 c2 01	 add	 edx, 1
  009fc	52		 push	 edx
  009fd	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@
  00a02	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a08	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3342 : #else
; 3343 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d)", 
; 3344 : #endif
; 3345 : 						iBridgeIndex+1,
; 3346 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3347 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3348 : 						BC_USER_DEAD,
; 3349 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3350 : 						iREWARD_EXP,
; 3351 : 						iREWARD_ZEN,
; 3352 : 						iREWARD_SCR
; 3353 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3354 : 						,iLEFT_TIME
; 3355 : 						,gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber
; 3356 : #endif
; 3357 : 						);
; 3358 : 				}
; 3359 : 				break;

  00a0b	e9 0f 07 00 00	 jmp	 $LN5@GiveReward
$LN31@GiveReward:

; 3360 : 			case BC_USER_WINNER :			
; 3361 : 				{
; 3362 : #ifdef FOR_BLOODCASTLE2	
; 3363 : 					//    
; 3364 : 	#if TESTSERVER == 1 
; 3365 : 					LogAddTD("[]  () : %d", iREWARD_EXP);
; 3366 : 	#endif
; 3367 : 					iEXTRA_EXP += (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000) * g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_PER_SEC];

  00a10	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00a17	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a1a	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00a21	99		 cdq
  00a22	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00a27	f7 f9		 idiv	 ecx
  00a29	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00a2c	c1 e2 04	 shl	 edx, 4
  00a2f	b9 04 00 00 00	 mov	 ecx, 4
  00a34	6b c9 03	 imul	 ecx, ecx, 3
  00a37	0f af 84 0a 00
	00 00 00	 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[edx+ecx]
  00a3f	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  00a45	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], eax

; 3368 : 	#if TESTSERVER == 1 
; 3369 : 					LogAddTD("[]  () : Exp:(%d) RemainSec:(%d)", iREWARD_EXP, m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000);
; 3370 : 	#endif
; 3371 : #endif
; 3372 : 					//  
; 3373 : //					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iALIVE_USER_TOTAL_EXP * g_iQuestWinExpendEXP[iBridgeIndex][BC_REWARD_WINNER] / 100 + iEXTRA_EXP);
; 3374 : 					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iEXTRA_EXP);

  00a4b	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  00a51	50		 push	 eax
  00a52	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00a59	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a5c	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00a60	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00a67	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00a6b	52		 push	 edx
  00a6c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a6f	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  00a74	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 3375 : 					//  
; 3376 : 					iREWARD_ZEN = CalcSendRewardZEN (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, g_iQuestWinExpendZEN[iBridgeIndex][BC_REWARD_WINNER]);

  00a7a	b8 04 00 00 00	 mov	 eax, 4
  00a7f	6b c8 00	 imul	 ecx, eax, 0
  00a82	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00a85	8b 84 d1 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iQuestWinExpendZEN@@3QAY01$$CBHA[ecx+edx*8]
  00a8c	50		 push	 eax
  00a8d	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00a94	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00a97	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00a9b	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00aa2	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00aa6	52		 push	 edx
  00aa7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00aaa	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  00aaf	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 3377 : 					//  
; 3378 : 					iREWARD_SCR = g_iBC_EventScore[iBridgeIndex][BC_USER_WINNER];

  00ab5	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 20
  00ab9	b9 04 00 00 00	 mov	 ecx, 4
  00abe	d1 e1		 shl	 ecx, 1
  00ac0	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?g_iBC_EventScore@@3QAY04$$CBHA[eax+ecx]
  00ac7	89 95 ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], edx

; 3379 : 
; 3380 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3381 : 					iREWARD_SCR += iADD_PARTYPOINT;

  00acd	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_SCR$[ebp]
  00ad3	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _iADD_PARTYPOINT$[ebp]
  00ad9	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], eax

; 3382 : #endif
; 3383 : 
; 3384 : /*					wsprintf(szNOTIFY_MSG2, lMsg.Get(1167),	// " %d  %d , %d   ."
; 3385 : 						iREWARD_EXP, 
; 3386 : 						iREWARD_ZEN,
; 3387 : 						iREWARD_SCR
; 3388 : 						);
; 3389 : */					
; 3390 : 					//   (iLootTime = 5 * 60 * 1000)
; 3391 : 					if (CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber)) {

  00adf	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00ae6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae9	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00aed	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00af4	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00afc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b02	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  00b0a	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00b0d	7d 0c		 jge	 SHORT $LN47@GiveReward
  00b0f	c7 85 30 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv708[ebp], 0
  00b19	eb 51		 jmp	 SHORT $LN48@GiveReward
$LN47@GiveReward:
  00b1b	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00b22	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00b25	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00b29	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00b30	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  00b38	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b3d	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  00b45	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00b48	7e 0c		 jle	 SHORT $LN45@GiveReward
  00b4a	c7 85 2c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv707[ebp], 0
  00b54	eb 0a		 jmp	 SHORT $LN46@GiveReward
$LN45@GiveReward:
  00b56	c7 85 2c fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv707[ebp], 1
$LN46@GiveReward:
  00b60	8b 95 2c fc ff
	ff		 mov	 edx, DWORD PTR tv707[ebp]
  00b66	89 95 30 fc ff
	ff		 mov	 DWORD PTR tv708[ebp], edx
$LN48@GiveReward:
  00b6c	83 bd 30 fc ff
	ff 00		 cmp	 DWORD PTR tv708[ebp], 0
  00b73	74 26		 je	 SHORT $LN32@GiveReward

; 3392 : 						//    .
; 3393 : #ifdef FOR_CHINA		//    
; 3394 : 						DropChaosGem(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex,iBridgeIndex);
; 3395 : #endif						
; 3396 : 						DropChaosGem(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex,iBridgeIndex);

  00b75	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00b78	50		 push	 eax
  00b79	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00b80	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00b83	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00b87	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00b8e	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00b92	52		 push	 edx
  00b93	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b96	e8 00 00 00 00	 call	 ?DropChaosGem@CBloodCastle@@QAEXHH@Z ; CBloodCastle::DropChaosGem
$LN32@GiveReward:

; 3397 : 					}
; 3398 : 
; 3399 : 					//    
; 3400 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3401 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  00b9b	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  00ba1	50		 push	 eax
  00ba2	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  00ba8	51		 push	 ecx
  00ba9	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  00baf	52		 push	 edx
  00bb0	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00bb7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bba	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00bbe	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00bc5	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  00bc9	51		 push	 ecx
  00bca	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bcd	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3402 : #else
; 3403 : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 3404 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME);
; 3405 : #else
; 3406 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR);
; 3407 : #endif	// BLOODCASTLE_EVENT_3RD_20040401
; 3408 : #endif	// BLOODCASTLE_EVENT_5TH_20050531
; 3409 : 
; 3410 : 
; 3411 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3412 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", 

  00bd2	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00bd9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bdc	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00be0	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00be7	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00bef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bf5	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  00bfd	50		 push	 eax
  00bfe	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  00c04	51		 push	 ecx
  00c05	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  00c0b	52		 push	 edx
  00c0c	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  00c12	50		 push	 eax
  00c13	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  00c19	51		 push	 ecx
  00c1a	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00c21	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00c24	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00c28	6b 95 d8 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$4[ebp], 20
  00c2f	69 44 11 18 a0
	1b 00 00	 imul	 eax, DWORD PTR [ecx+edx+24], 7072
  00c37	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c3d	8b 94 01 d4 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3284]
  00c44	52		 push	 edx
  00c45	6a 02		 push	 2
  00c47	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00c4e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c51	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00c55	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00c5c	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00c64	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c6a	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00c6e	50		 push	 eax
  00c6f	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00c76	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00c79	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00c7d	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00c84	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  00c8c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c91	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00c95	51		 push	 ecx
  00c96	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00c99	83 c2 01	 add	 edx, 1
  00c9c	52		 push	 edx
  00c9d	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@
  00ca2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00ca8	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3413 : #else
; 3414 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d)", 
; 3415 : #endif
; 3416 : 						iBridgeIndex+1,
; 3417 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3418 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3419 : 						BC_USER_WINNER,
; 3420 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3421 : 						iREWARD_EXP,
; 3422 : 						iREWARD_ZEN,
; 3423 : 						iREWARD_SCR
; 3424 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3425 : 						,iLEFT_TIME
; 3426 : 						,gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber
; 3427 : #endif
; 3428 : 						);
; 3429 : 				}
; 3430 : 				break;

  00cab	e9 6f 04 00 00	 jmp	 $LN5@GiveReward
$LN33@GiveReward:

; 3431 : 			case BC_USER_WINNER_PARTY_ALIVE :
; 3432 : 				{
; 3433 : #ifdef FOR_BLOODCASTLE2	
; 3434 : 					//    
; 3435 : 	#if TESTSERVER == 1 
; 3436 : 					LogAddTD("[]  () : %d", iREWARD_EXP);
; 3437 : 	#endif
; 3438 : 					iEXTRA_EXP += (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000) * g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_PER_SEC];

  00cb0	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00cb7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00cba	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00cc1	99		 cdq
  00cc2	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00cc7	f7 f9		 idiv	 ecx
  00cc9	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00ccc	c1 e2 04	 shl	 edx, 4
  00ccf	b9 04 00 00 00	 mov	 ecx, 4
  00cd4	6b c9 03	 imul	 ecx, ecx, 3
  00cd7	0f af 84 0a 00
	00 00 00	 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[edx+ecx]
  00cdf	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  00ce5	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], eax

; 3439 : 	#if TESTSERVER == 1 
; 3440 : 					LogAddTD("[]  () : Exp:(%d) RemainSec:(%d)", iREWARD_EXP, m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000);
; 3441 : 	#endif
; 3442 : #endif
; 3443 : 					//  
; 3444 : //					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iALIVE_USER_TOTAL_EXP * g_iQuestWinExpendEXP[iBridgeIndex][BC_REWARD_WINNER] / 100 + iEXTRA_EXP);
; 3445 : 					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iEXTRA_EXP);

  00ceb	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  00cf1	50		 push	 eax
  00cf2	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00cf9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00cfc	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00d00	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00d07	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00d0b	52		 push	 edx
  00d0c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d0f	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  00d14	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 3446 : 					//  
; 3447 : 					iREWARD_ZEN = CalcSendRewardZEN (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, g_iQuestWinExpendZEN[iBridgeIndex][BC_REWARD_WINNER]);

  00d1a	b8 04 00 00 00	 mov	 eax, 4
  00d1f	6b c8 00	 imul	 ecx, eax, 0
  00d22	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00d25	8b 84 d1 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iQuestWinExpendZEN@@3QAY01$$CBHA[ecx+edx*8]
  00d2c	50		 push	 eax
  00d2d	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00d34	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00d37	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00d3b	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00d42	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00d46	52		 push	 edx
  00d47	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d4a	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  00d4f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 3448 : 					//  
; 3449 : 					iREWARD_SCR = g_iBC_EventScore[iBridgeIndex][BC_USER_WINNER_PARTY_ALIVE];

  00d55	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 20
  00d59	b9 04 00 00 00	 mov	 ecx, 4
  00d5e	6b d1 03	 imul	 edx, ecx, 3
  00d61	8b 84 10 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_EventScore@@3QAY04$$CBHA[eax+edx]
  00d68	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], eax

; 3450 : 
; 3451 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3452 : 					iREWARD_SCR += iADD_PARTYPOINT;

  00d6e	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_SCR$[ebp]
  00d74	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _iADD_PARTYPOINT$[ebp]
  00d7a	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], eax

; 3453 : #endif
; 3454 : 
; 3455 : /*					wsprintf(szNOTIFY_MSG2, lMsg.Get(1167),	// " %d  %d , %d   ."
; 3456 : 						iREWARD_EXP, 
; 3457 : 						iREWARD_ZEN,
; 3458 : 						iREWARD_SCR
; 3459 : 						);
; 3460 : */					
; 3461 : 					//   (iLootTime = 5 * 60 * 1000)
; 3462 : 					if (CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber))

  00d80	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00d87	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00d8a	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00d8e	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00d95	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00d9d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00da3	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  00dab	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00dae	7d 0c		 jge	 SHORT $LN51@GiveReward
  00db0	c7 85 30 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv858[ebp], 0
  00dba	eb 51		 jmp	 SHORT $LN52@GiveReward
$LN51@GiveReward:
  00dbc	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00dc3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00dc6	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00dca	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00dd1	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  00dd9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00dde	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  00de6	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00de9	7e 0c		 jle	 SHORT $LN49@GiveReward
  00deb	c7 85 2c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR tv857[ebp], 0
  00df5	eb 0a		 jmp	 SHORT $LN50@GiveReward
$LN49@GiveReward:
  00df7	c7 85 2c fc ff
	ff 01 00 00 00	 mov	 DWORD PTR tv857[ebp], 1
$LN50@GiveReward:
  00e01	8b 95 2c fc ff
	ff		 mov	 edx, DWORD PTR tv857[ebp]
  00e07	89 95 30 fc ff
	ff		 mov	 DWORD PTR tv858[ebp], edx
$LN52@GiveReward:
  00e0d	83 bd 30 fc ff
	ff 00		 cmp	 DWORD PTR tv858[ebp], 0
  00e14	74 26		 je	 SHORT $LN34@GiveReward

; 3463 : 						DropChaosGem(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex,iBridgeIndex);

  00e16	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00e19	50		 push	 eax
  00e1a	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00e21	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00e24	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00e28	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00e2f	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00e33	52		 push	 edx
  00e34	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e37	e8 00 00 00 00	 call	 ?DropChaosGem@CBloodCastle@@QAEXHH@Z ; CBloodCastle::DropChaosGem
$LN34@GiveReward:

; 3464 : 
; 3465 : 					//    
; 3466 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3467 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  00e3c	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  00e42	50		 push	 eax
  00e43	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  00e49	51		 push	 ecx
  00e4a	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  00e50	52		 push	 edx
  00e51	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00e58	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e5b	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00e5f	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00e66	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  00e6a	51		 push	 ecx
  00e6b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e6e	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3468 : #else
; 3469 : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 3470 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME);
; 3471 : #else
; 3472 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR);
; 3473 : #endif	// BLOODCASTLE_EVENT_3RD_20040401
; 3474 : #endif	// BLOODCASTLE_EVENT_5TH_20050531
; 3475 : 
; 3476 : 
; 3477 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3478 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", 

  00e73	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00e7a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00e7d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00e81	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00e88	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00e90	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e96	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  00e9e	50		 push	 eax
  00e9f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  00ea5	51		 push	 ecx
  00ea6	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  00eac	52		 push	 edx
  00ead	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  00eb3	50		 push	 eax
  00eb4	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  00eba	51		 push	 ecx
  00ebb	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  00ec2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00ec5	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00ec9	6b 95 d8 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$4[ebp], 20
  00ed0	69 44 11 18 a0
	1b 00 00	 imul	 eax, DWORD PTR [ecx+edx+24], 7072
  00ed8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ede	8b 94 01 d4 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3284]
  00ee5	52		 push	 edx
  00ee6	6a 03		 push	 3
  00ee8	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00eef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ef2	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00ef6	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  00efd	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  00f05	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f0b	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00f0f	50		 push	 eax
  00f10	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00f17	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00f1a	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00f1e	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00f25	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  00f2d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f32	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00f36	51		 push	 ecx
  00f37	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00f3a	83 c2 01	 add	 edx, 1
  00f3d	52		 push	 edx
  00f3e	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@
  00f43	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00f49	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3479 : #else
; 3480 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d)", 
; 3481 : #endif
; 3482 : 						iBridgeIndex+1,
; 3483 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3484 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3485 : 						BC_USER_WINNER_PARTY_ALIVE,
; 3486 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3487 : 						iREWARD_EXP,
; 3488 : 						iREWARD_ZEN,
; 3489 : 						iREWARD_SCR
; 3490 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3491 : 						,iLEFT_TIME
; 3492 : 						,gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber
; 3493 : #endif
; 3494 : 						);
; 3495 : 				}
; 3496 : 				break;

  00f4c	e9 ce 01 00 00	 jmp	 $LN5@GiveReward
$LN35@GiveReward:

; 3497 : 			case BC_USER_WINNER_PARTY_DEAD :		
; 3498 : 				{
; 3499 : #ifdef FOR_BLOODCASTLE2	
; 3500 : 					//    
; 3501 : 	#if TESTSERVER == 1 
; 3502 : 					LogAddTD("[]  () : %d", iREWARD_EXP);
; 3503 : 	#endif
; 3504 : 					iEXTRA_EXP += (m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000) * g_iBC_Add_Exp[iBridgeIndex][ADD_EXP_PER_SEC];

  00f51	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  00f58	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00f5b	8b 84 01 54 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax+340]
  00f62	99		 cdq
  00f63	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00f68	f7 f9		 idiv	 ecx
  00f6a	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00f6d	c1 e2 04	 shl	 edx, 4
  00f70	b9 04 00 00 00	 mov	 ecx, 4
  00f75	6b c9 03	 imul	 ecx, ecx, 3
  00f78	0f af 84 0a 00
	00 00 00	 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QAY03$$CBHA[edx+ecx]
  00f80	03 85 c4 fd ff
	ff		 add	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  00f86	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _iEXTRA_EXP$2[ebp], eax

; 3505 : 	#if TESTSERVER == 1 
; 3506 : 					LogAddTD("[]  () : Exp:(%d) RemainSec:(%d)", iREWARD_EXP, m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000);
; 3507 : 	#endif
; 3508 : #endif
; 3509 : 					//  
; 3510 : //					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iALIVE_USER_TOTAL_EXP * g_iQuestWinExpendEXP[iBridgeIndex][BC_REWARD_WINNER] / 100 + iEXTRA_EXP);
; 3511 : 					iREWARD_EXP = CalcSendRewardEXP (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iEXTRA_EXP);

  00f8c	8b 85 c4 fd ff
	ff		 mov	 eax, DWORD PTR _iEXTRA_EXP$2[ebp]
  00f92	50		 push	 eax
  00f93	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00f9a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00f9d	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00fa1	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00fa8	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00fac	52		 push	 edx
  00fad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00fb0	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP
  00fb5	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$[ebp], eax

; 3512 : 					//  
; 3513 : 					iREWARD_ZEN = CalcSendRewardZEN (m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, g_iQuestWinExpendZEN[iBridgeIndex][BC_REWARD_WINNER]);

  00fbb	b8 04 00 00 00	 mov	 eax, 4
  00fc0	6b c8 00	 imul	 ecx, eax, 0
  00fc3	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00fc6	8b 84 d1 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iQuestWinExpendZEN@@3QAY01$$CBHA[ecx+edx*8]
  00fcd	50		 push	 eax
  00fce	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  00fd5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00fd8	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  00fdc	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  00fe3	8b 54 08 18	 mov	 edx, DWORD PTR [eax+ecx+24]
  00fe7	52		 push	 edx
  00fe8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00feb	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN
  00ff0	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$[ebp], eax

; 3514 : 					//  
; 3515 : 					iREWARD_SCR = g_iBC_EventScore[iBridgeIndex][BC_USER_WINNER_PARTY_DEAD];

  00ff6	6b 45 0c 14	 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 20
  00ffa	b9 04 00 00 00	 mov	 ecx, 4
  00fff	c1 e1 02	 shl	 ecx, 2
  01002	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?g_iBC_EventScore@@3QAY04$$CBHA[eax+ecx]
  01009	89 95 ec fe ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$[ebp], edx

; 3516 : 
; 3517 : /*					wsprintf(szNOTIFY_MSG2, lMsg.Get(1167),	// " %d  %d , %d   ."
; 3518 : 						iREWARD_EXP, 
; 3519 : 						iREWARD_ZEN,
; 3520 : 						iREWARD_SCR
; 3521 : 						);
; 3522 : */					
; 3523 : 					//    
; 3524 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3525 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  0100f	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iALIVE_PARTYCOUNT$[ebp]
  01015	50		 push	 eax
  01016	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  0101c	51		 push	 ecx
  0101d	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  01023	52		 push	 edx
  01024	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0102b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0102e	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  01032	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  01039	8b 4c 02 18	 mov	 ecx, DWORD PTR [edx+eax+24]
  0103d	51		 push	 ecx
  0103e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01041	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3526 : #else
; 3527 : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 3528 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME);
; 3529 : #else
; 3530 : 					SendRewardScore(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR);
; 3531 : #endif	// BLOODCASTLE_EVENT_3RD_20040401
; 3532 : #endif	// BLOODCASTLE_EVENT_5TH_20050531
; 3533 : 
; 3534 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3535 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)", 

  01046	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  0104d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01050	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  01054	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  0105b	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  01063	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01069	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  01071	50		 push	 eax
  01072	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iLEFT_TIME$[ebp]
  01078	51		 push	 ecx
  01079	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  0107f	52		 push	 edx
  01080	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$[ebp]
  01086	50		 push	 eax
  01087	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _iREWARD_EXP$[ebp]
  0108d	51		 push	 ecx
  0108e	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  01095	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  01098	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  0109c	6b 95 d8 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$4[ebp], 20
  010a3	69 44 11 18 a0
	1b 00 00	 imul	 eax, DWORD PTR [ecx+edx+24], 7072
  010ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  010b1	8b 94 01 d4 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3284]
  010b8	52		 push	 edx
  010b9	6a 04		 push	 4
  010bb	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  010c2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  010c5	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  010c9	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  010d0	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  010d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  010de	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  010e2	50		 push	 eax
  010e3	69 4d 0c 04 02
	00 00		 imul	 ecx, DWORD PTR _iBridgeIndex$[ebp], 516
  010ea	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  010ed	8d 44 0a 04	 lea	 eax, DWORD PTR [edx+ecx+4]
  010f1	6b 8d d8 fe ff
	ff 14		 imul	 ecx, DWORD PTR _i$4[ebp], 20
  010f8	69 54 08 18 a0
	1b 00 00	 imul	 edx, DWORD PTR [eax+ecx+24], 7072
  01100	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01105	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  01109	51		 push	 ecx
  0110a	8b 55 0c	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  0110d	83 c2 01	 add	 edx, 1
  01110	52		 push	 edx
  01111	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Compl@
  01116	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0111c	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN5@GiveReward:

; 3536 : #else
; 3537 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d)", 
; 3538 : #endif
; 3539 : 						iBridgeIndex+1,
; 3540 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3541 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3542 : 						BC_USER_WINNER_PARTY_DEAD,
; 3543 : 						gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3544 : 						iREWARD_EXP,
; 3545 : 						iREWARD_ZEN,
; 3546 : 						iREWARD_SCR
; 3547 : #ifdef BLOODCASTLE_EVENT_4TH_20040531		//   
; 3548 : 						,iLEFT_TIME
; 3549 : 						,gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber
; 3550 : #endif
; 3551 : 						);
; 3552 : 				}
; 3553 : 				break;
; 3554 : 			}
; 3555 : 
; 3556 : 			//    .
; 3557 : 			PMSG_DEVILSQUARERESULT pMsg;
; 3558 : 			pMsg.MyRank = 1;	// 

  0111f	c6 85 b7 fc ff
	ff 01		 mov	 BYTE PTR _pMsg$1[ebp+3], 1

; 3559 : 			pMsg.Count = 255;

  01126	c6 85 b8 fc ff
	ff ff		 mov	 BYTE PTR _pMsg$1[ebp+4], 255 ; 000000ffH

; 3560 : 			memcpy(pMsg.Score[0].Name, gObj[m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, sizeof(pMsg.Score[0].Name));

  0112d	6a 0a		 push	 10			; 0000000aH
  0112f	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  01136	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01139	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  0113d	6b 85 d8 fe ff
	ff 14		 imul	 eax, DWORD PTR _i$4[ebp], 20
  01144	69 4c 02 18 a0
	1b 00 00	 imul	 ecx, DWORD PTR [edx+eax+24], 7072
  0114c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01152	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  01156	50		 push	 eax
  01157	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  0115c	6b d1 00	 imul	 edx, ecx, 0
  0115f	8d 84 15 b9 fc
	ff ff		 lea	 eax, DWORD PTR _pMsg$1[ebp+edx+5]
  01166	50		 push	 eax
  01167	e8 00 00 00 00	 call	 _memcpy
  0116c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3561 : 
; 3562 : 
; 3563 : 			pMsg.Score[0].BonusExp		= iREWARD_EXP;

  0116f	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01174	6b c8 00	 imul	 ecx, eax, 0
  01177	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_EXP$[ebp]
  0117d	89 94 0d c9 fc
	ff ff		 mov	 DWORD PTR _pMsg$1[ebp+ecx+21], edx

; 3564 : 
; 3565 : 
; 3566 : 			pMsg.Score[0].BonusZen		= iREWARD_ZEN;

  01184	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  01189	6b c8 00	 imul	 ecx, eax, 0
  0118c	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_ZEN$[ebp]
  01192	89 94 0d cd fc
	ff ff		 mov	 DWORD PTR _pMsg$1[ebp+ecx+25], edx

; 3567 : 			pMsg.Score[0].TotalScore	= iREWARD_SCR;

  01199	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  0119e	6b c8 00	 imul	 ecx, eax, 0
  011a1	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _iREWARD_SCR$[ebp]
  011a7	89 94 0d c5 fc
	ff ff		 mov	 DWORD PTR _pMsg$1[ebp+ecx+17], edx

; 3568 : 			PHeadSetB((LPBYTE)&pMsg, 0x93, sizeof(PBMSG_HEAD) + 2 + sizeof(DevilSquareScoreInfo) * 2);

  011ae	6a 35		 push	 53			; 00000035H
  011b0	68 93 00 00 00	 push	 147			; 00000093H
  011b5	8d 85 b4 fc ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  011bb	50		 push	 eax
  011bc	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  011c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3569 : 
; 3570 : 			DataSend(m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  011c4	0f b6 85 b5 fc
	ff ff		 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  011cb	50		 push	 eax
  011cc	8d 8d b4 fc ff
	ff		 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  011d2	51		 push	 ecx
  011d3	69 55 0c 04 02
	00 00		 imul	 edx, DWORD PTR _iBridgeIndex$[ebp], 516
  011da	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  011dd	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  011e1	6b 95 d8 fe ff
	ff 14		 imul	 edx, DWORD PTR _i$4[ebp], 20
  011e8	8b 44 11 18	 mov	 eax, DWORD PTR [ecx+edx+24]
  011ec	50		 push	 eax
  011ed	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  011f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3571 : //			SendBridgeAnyMsg((LPBYTE)&pMsg, pMsg.h.size, iBridgeIndex);
; 3572 : 		}

  011f5	e9 33 f0 ff ff	 jmp	 $LN2@GiveReward
$LN3@GiveReward:

; 3573 : 
; 3574 : 		//    .
; 3575 : 		m_BridgeData[iBridgeIndex].m_bBC_REWARDED = true;

  011fa	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 516
  01201	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  01204	c6 84 01 66 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+358], 1
$LN1@GiveReward:

; 3576 : 	}
; 3577 : }

  0120c	5f		 pop	 edi
  0120d	5e		 pop	 esi
  0120e	5b		 pop	 ebx
  0120f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01212	33 cd		 xor	 ecx, ebp
  01214	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01219	8b e5		 mov	 esp, ebp
  0121b	5d		 pop	 ebp
  0121c	c2 08 00	 ret	 8
  0121f	90		 npad	 1
$LN53@GiveReward:
  01220	00 00 00 00	 DD	 $LN29@GiveReward
  01224	00 00 00 00	 DD	 $LN30@GiveReward
  01228	00 00 00 00	 DD	 $LN31@GiveReward
  0122c	00 00 00 00	 DD	 $LN33@GiveReward
  01230	00 00 00 00	 DD	 $LN35@GiveReward
?GiveReward_Win@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::GiveReward_Win
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z
_TEXT	SEGMENT
tv66 = -128						; size = 4
tv67 = -124						; size = 4
_pMsg$ = -56						; size = 48
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iSCORE$ = 12						; size = 4
_iLeftTime$ = 16					; size = 4
_iAlivePartyCount$ = 20					; size = 4
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z PROC		; CBloodCastle::SendRewardScore, COMDAT
; _this$ = ecx

; 4046 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4047 : 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  00019	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  0001d	7d 09		 jge	 SHORT $LN9@SendReward
  0001f	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00026	eb 1f		 jmp	 SHORT $LN10@SendReward
$LN9@SendReward:
  00028	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  0002f	7e 09		 jle	 SHORT $LN7@SendReward
  00031	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00038	eb 07		 jmp	 SHORT $LN8@SendReward
$LN7@SendReward:
  0003a	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN8@SendReward:
  00041	8b 45 80	 mov	 eax, DWORD PTR tv66[ebp]
  00044	89 45 84	 mov	 DWORD PTR tv67[ebp], eax
$LN10@SendReward:
  00047	83 7d 84 00	 cmp	 DWORD PTR tv67[ebp], 0
  0004b	75 05		 jne	 SHORT $LN2@SendReward

; 4048 : 		return;

  0004d	e9 23 01 00 00	 jmp	 $LN1@SendReward
$LN2@SendReward:

; 4049 : 
; 4050 : #ifdef BLOODCASTLE_EVENT_3RD_20040401
; 4051 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 4052 : 	PMSG_ANS_BLOODCASTLESCORE_5TH pMsg;	
; 4053 : #else
; 4054 : 	PMSG_ANS_BLOODCASTLESCORE_3RD pMsg;
; 4055 : #endif
; 4056 : 	
; 4057 : 	pMsg.h.c		= PMHC_BYTE;

  00052	c6 45 c8 c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 4058 : 
; 4059 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 4060 : 	pMsg.h.headcode	= 0x0D;

  00056	c6 45 ca 0d	 mov	 BYTE PTR _pMsg$[ebp+2], 13 ; 0000000dH

; 4061 : #else	
; 4062 : #ifdef BLOODCASTLE_EVENT_4TH_20040531
; 4063 : 	pMsg.h.headcode	= 0x0C;
; 4064 : #else
; 4065 : 	pMsg.h.headcode	= 0x0A;
; 4066 : #endif	// BLOODCASTLE_EVENT_4TH_20040531
; 4067 : #endif	// BLOODCASTLE_EVENT_5TH_20050531
; 4068 : 	
; 4069 : 	pMsg.h.size		= sizeof( pMsg );

  0005a	c6 45 c9 30	 mov	 BYTE PTR _pMsg$[ebp+1], 48 ; 00000030H

; 4070 : 
; 4071 : 	pMsg.Score	= iSCORE;

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _iSCORE$[ebp]
  00061	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+28], eax

; 4072 : 	pMsg.BridgeNum = gObj[iIndex].m_cBloodCastleIndex;

  00064	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00071	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  00079	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+36], edx

; 4073 : 	pMsg.Class = gObj[iIndex].Class;

  0007c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00089	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00091	89 55 e8	 mov	 DWORD PTR _pMsg$[ebp+32], edx

; 4074 : 
; 4075 : 	pMsg.ServerCode=gGameServerCode;

  00094	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0009b	89 45 e0	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 4076 : 	pMsg.iLeftTime = iLeftTime;

  0009e	8b 45 10	 mov	 eax, DWORD PTR _iLeftTime$[ebp]
  000a1	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+40], eax

; 4077 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, MAX_IDSTRING);

  000a4	6a 0a		 push	 10			; 0000000aH
  000a6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b3	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000b7	52		 push	 edx
  000b8	8d 45 cb	 lea	 eax, DWORD PTR _pMsg$[ebp+3]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4078 : 	memcpy(pMsg.GameID,    gObj[iIndex].Name, MAX_IDSTRING);

  000c4	6a 0a		 push	 10			; 0000000aH
  000c6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d3	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000d7	52		 push	 edx
  000d8	8d 45 d5	 lea	 eax, DWORD PTR _pMsg$[ebp+13]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _memcpy
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4079 : 
; 4080 : #ifndef BLOODCASTLE_EVENT_5TH_20050531
; 4081 : #ifdef FOR_BLOODCASLTE_PCEVENT
; 4082 : 	pMsg.iPCRoomGUID = gObj[iIndex].PcBangGuid;
; 4083 : #endif	// FOR_BLOODCASLTE_PCEVENT
; 4084 : #endif	// BLOODCASTLE_EVENT_5TH_20050531
; 4085 : 
; 4086 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 4087 : 	pMsg.iAlivePartyCount = iAlivePartyCount;

  000e4	8b 45 14	 mov	 eax, DWORD PTR _iAlivePartyCount$[ebp]
  000e7	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+44], eax

; 4088 : #endif
; 4089 : 
; 4090 : #else
; 4091 : 	PMSG_ANS_BLOODCASTLESCORE pMsg;	
; 4092 : 	
; 4093 : 	pMsg.h.c		= PMHC_BYTE;
; 4094 : 	pMsg.h.headcode	= 0x07;
; 4095 : 	pMsg.h.size		= sizeof( pMsg );
; 4096 : 
; 4097 : 	pMsg.Score	= iSCORE;
; 4098 : 	pMsg.BridgeNum = gObj[iIndex].m_cBloodCastleIndex;
; 4099 : 	pMsg.Class = gObj[iIndex].Class;
; 4100 : 
; 4101 : 	pMsg.ServerCode=gGameServerCode;
; 4102 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, MAX_IDSTRING);
; 4103 : 	memcpy(pMsg.GameID,    gObj[iIndex].Name, MAX_IDSTRING);
; 4104 : #ifdef FOR_BLOODCASLTE_PCEVENT
; 4105 : 	pMsg.iPCRoomGUID = gObj[iIndex].PcBangGuid;
; 4106 : #endif
; 4107 : #endif 
; 4108 : 
; 4109 : 	
; 4110 : 	//    
; 4111 : 	if( !IsDevilSquareEventConnected && !DevilSquareEventConnect )

  000ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  000f1	75 5d		 jne	 SHORT $LN3@SendReward
  000f3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  000fa	75 54		 jne	 SHORT $LN3@SendReward

; 4112 : 	{
; 4113 : 		wsRServerCli.Close();

  000fc	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  00101	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 4114 : 		wsRServerCli.CreateSocket(ghWnd);

  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0010b	50		 push	 eax
  0010c	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  00111	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 4115 : 		if( GMRankingServerConnect(gDevilSquareEventServerIp, WM_ASS_RANKINGCLIMSG) == FALSE )

  00116	68 0c 04 00 00	 push	 1036			; 0000040cH
  0011b	68 00 00 00 00	 push	 OFFSET ?gDevilSquareEventServerIp@@3PADA ; gDevilSquareEventServerIp
  00120	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  00125	83 c4 08	 add	 esp, 8
  00128	85 c0		 test	 eax, eax
  0012a	75 1a		 jne	 SHORT $LN4@SendReward

; 4116 : 		{
; 4117 : 			IsDevilSquareEventConnected = 0;

  0012c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected

; 4118 : 			LogAddTD("Can not connect Ranking Server");

  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EMDINEAJ@Can?5not?5connect?5Ranking?5Server@
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00141	83 c4 04	 add	 esp, 4

; 4119 : 			return;

  00144	eb 2f		 jmp	 SHORT $LN1@SendReward
$LN4@SendReward:

; 4120 : 		}
; 4121 : 		IsDevilSquareEventConnected = 1;

  00146	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN3@SendReward:

; 4122 : 	}
; 4123 : 
; 4124 : 	if( !DevilSquareEventConnect && IsDevilSquareEventConnected )

  00150	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  00157	75 1c		 jne	 SHORT $LN1@SendReward
  00159	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00160	74 13		 je	 SHORT $LN1@SendReward

; 4125 : 		wsRServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  00162	0f b6 45 c9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00166	50		 push	 eax
  00167	8d 4d c8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0016a	51		 push	 ecx
  0016b	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  00170	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN1@SendReward:

; 4126 : }

  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx
  00178	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017b	33 cd		 xor	 ecx, ebp
  0017d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c2 10 00	 ret	 16			; 00000010H
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ENDP		; CBloodCastle::SendRewardScore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?DropChaosGem@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv66 = -104						; size = 4
tv67 = -100						; size = 4
$T1 = -96						; size = 4
_reward$2 = -28						; size = 4
_it$ = -24						; size = 4
_count$ = -20						; size = 4
_used_count$ = -16					; size = 4
_drop_count$ = -12					; size = 4
_iMaxHitUser$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iBridgeNum$ = 12					; size = 4
?DropChaosGem@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::DropChaosGem, COMDAT
; _this$ = ecx

; 3975 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3976 : 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN10@DropChaosG
  00012	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN11@DropChaosG
$LN10@DropChaosG:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN8@DropChaosG
  00024	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN9@DropChaosG
$LN8@DropChaosG:
  0002d	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@DropChaosG:
  00034	8b 45 98	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 9c	 mov	 DWORD PTR tv67[ebp], eax
$LN11@DropChaosG:
  0003a	83 7d 9c 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 05		 jne	 SHORT $LN5@DropChaosG

; 3977 : 		return;

  00040	e9 91 01 00 00	 jmp	 $LN1@DropChaosG
$LN5@DropChaosG:

; 3978 : 
; 3979 : 	int iMaxHitUser = iIndex;

  00045	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00048	89 45 f8	 mov	 DWORD PTR _iMaxHitUser$[ebp], eax

; 3980 : 
; 3981 : 	int drop_count = 0, used_count = 0;

  0004b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _drop_count$[ebp], 0
  00052	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _used_count$[ebp], 0

; 3982 : 
; 3983 : 	int count = m_LST_BLOODCASTLE_REWARD[iBridgeNum].size();

  00059	8b 45 0c	 mov	 eax, DWORD PTR _iBridgeNum$[ebp]
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	8d 8c c1 3c 0e
	00 00		 lea	 ecx, DWORD PTR [ecx+eax*8+3644]
  00066	e8 00 00 00 00	 call	 ?size@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QBEIXZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::size
  0006b	89 45 ec	 mov	 DWORD PTR _count$[ebp], eax

; 3984 : 
; 3985 : 	tdBCRewardList::iterator it = m_LST_BLOODCASTLE_REWARD[iBridgeNum].begin();

  0006e	8d 45 e8	 lea	 eax, DWORD PTR _it$[ebp]
  00071	50		 push	 eax
  00072	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeNum$[ebp]
  00075	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00078	8d 8c ca 3c 0e
	00 00		 lea	 ecx, DWORD PTR [edx+ecx*8+3644]
  0007f	e8 00 00 00 00	 call	 ?begin@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::begin

; 3986 : 
; 3987 : 	for(std::advance(it, rand()%count);used_count < count && drop_count < m_BridgeData[iBridgeNum].m_iDropItemCount;advance(it = m_LST_BLOODCASTLE_REWARD[iBridgeNum].begin(),rand()%count),++used_count)

  00084	e8 00 00 00 00	 call	 _rand
  00089	99		 cdq
  0008a	f7 7d ec	 idiv	 DWORD PTR _count$[ebp]
  0008d	52		 push	 edx
  0008e	8d 45 e8	 lea	 eax, DWORD PTR _it$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ??$advance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z ; std::advance<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,int>
  00097	83 c4 08	 add	 esp, 8
  0009a	eb 3a		 jmp	 SHORT $LN4@DropChaosG
$LN2@DropChaosG:
  0009c	8d 45 a0	 lea	 eax, DWORD PTR $T1[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR _iBridgeNum$[ebp]
  000a3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	8d 8c ca 3c 0e
	00 00		 lea	 ecx, DWORD PTR [edx+ecx*8+3644]
  000ad	e8 00 00 00 00	 call	 ?begin@?$list@UBLOODCASTLE_REWARD@@V?$allocator@UBLOODCASTLE_REWARD@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@2@XZ ; std::list<BLOODCASTLE_REWARD,std::allocator<BLOODCASTLE_REWARD> >::begin
  000b2	8b 00		 mov	 eax, DWORD PTR [eax]
  000b4	89 45 e8	 mov	 DWORD PTR _it$[ebp], eax
  000b7	e8 00 00 00 00	 call	 _rand
  000bc	99		 cdq
  000bd	f7 7d ec	 idiv	 DWORD PTR _count$[ebp]
  000c0	52		 push	 edx
  000c1	8d 4d e8	 lea	 ecx, DWORD PTR _it$[ebp]
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 ??$advance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@H@std@@YAXAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@0@H@Z ; std::advance<std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >,int>
  000ca	83 c4 08	 add	 esp, 8
  000cd	8b 55 f0	 mov	 edx, DWORD PTR _used_count$[ebp]
  000d0	83 c2 01	 add	 edx, 1
  000d3	89 55 f0	 mov	 DWORD PTR _used_count$[ebp], edx
$LN4@DropChaosG:
  000d6	8b 45 f0	 mov	 eax, DWORD PTR _used_count$[ebp]
  000d9	3b 45 ec	 cmp	 eax, DWORD PTR _count$[ebp]
  000dc	0f 8d f4 00 00
	00		 jge	 $LN1@DropChaosG
  000e2	69 45 0c 04 02
	00 00		 imul	 eax, DWORD PTR _iBridgeNum$[ebp], 516
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	8b 55 f4	 mov	 edx, DWORD PTR _drop_count$[ebp]
  000ef	3b 94 01 04 02
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+516]
  000f6	0f 8d da 00 00
	00		 jge	 $LN1@DropChaosG

; 3988 : 	{
; 3989 : 		BLOODCASTLE_REWARD &reward = (*it);

  000fc	8d 4d e8	 lea	 ecx, DWORD PTR _it$[ebp]
  000ff	e8 00 00 00 00	 call	 ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UBLOODCASTLE_REWARD@@@std@@@std@@@std@@QBEAAUBLOODCASTLE_REWARD@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<BLOODCASTLE_REWARD> > >::operator*
  00104	89 45 e4	 mov	 DWORD PTR _reward$2[ebp], eax

; 3990 : 
; 3991 : 		if((rand()%1000) < reward.max_drop_rate)

  00107	e8 00 00 00 00	 call	 _rand
  0010c	99		 cdq
  0010d	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00112	f7 f9		 idiv	 ecx
  00114	8b 45 e4	 mov	 eax, DWORD PTR _reward$2[ebp]
  00117	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  0011b	3b d1		 cmp	 edx, ecx
  0011d	0f 8d ae 00 00
	00		 jge	 $LN6@DropChaosG

; 3992 : 		{
; 3993 : 			drop_count++;

  00123	8b 45 f4	 mov	 eax, DWORD PTR _drop_count$[ebp]
  00126	83 c0 01	 add	 eax, 1
  00129	89 45 f4	 mov	 DWORD PTR _drop_count$[ebp], eax

; 3994 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// BC_MAPNUMBER_BASE_CHAOSGEM 
; 3995 : 			int iChaosGemMapNum = -1;
; 3996 : 			switch( gObj[iIndex].MapNumber )
; 3997 : 			{
; 3998 : 			case MAP_INDEX_BLOODCASTLE1: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM1; break;
; 3999 : 			case MAP_INDEX_BLOODCASTLE2: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM2; break;
; 4000 : 			case MAP_INDEX_BLOODCASTLE3: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM3; break;
; 4001 : 			case MAP_INDEX_BLOODCASTLE4: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM4; break;
; 4002 : 			case MAP_INDEX_BLOODCASTLE5: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM5; break;
; 4003 : 			case MAP_INDEX_BLOODCASTLE6: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM6; break;
; 4004 : 			case MAP_INDEX_BLOODCASTLE7: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM7; break;
; 4005 : 			case MAP_INDEX_BLOODCASTLE8: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM8; break;
; 4006 : 			}
; 4007 : 
; 4008 : 			ItemSerialCreateSend(gObj[iIndex].m_Index, iChaosGemMapNum, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, reward.item_type, reward.item_level, (BYTE)ItemAttribute[reward.item_type].Durability, reward.is_skill, reward.is_luck, reward.option, iMaxHitUser, reward.exc_option);
; 4009 : #else
; 4010 : 			ItemSerialCreateSend(gObj[iIndex].m_Index, BC_MAPNUMBER_BASE_CHAOSGEM + gObj[iIndex].MapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, reward.item_type, reward.item_level, (BYTE)ItemAttribute[reward.item_type].Durability, reward.is_skill, reward.is_luck, reward.option, iMaxHitUser, reward.exc_option);

  0012c	6a 00		 push	 0
  0012e	6a 00		 push	 0
  00130	8b 45 e4	 mov	 eax, DWORD PTR _reward$2[ebp]
  00133	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00137	51		 push	 ecx
  00138	8b 55 f8	 mov	 edx, DWORD PTR _iMaxHitUser$[ebp]
  0013b	52		 push	 edx
  0013c	8b 45 e4	 mov	 eax, DWORD PTR _reward$2[ebp]
  0013f	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00143	51		 push	 ecx
  00144	8b 55 e4	 mov	 edx, DWORD PTR _reward$2[ebp]
  00147	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0014b	50		 push	 eax
  0014c	8b 4d e4	 mov	 ecx, DWORD PTR _reward$2[ebp]
  0014f	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00153	52		 push	 edx
  00154	8b 45 e4	 mov	 eax, DWORD PTR _reward$2[ebp]
  00157	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0015a	6b d1 6c	 imul	 edx, ecx, 108
  0015d	0f b6 82 30 00
	00 00		 movzx	 eax, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[edx+48]
  00164	50		 push	 eax
  00165	8b 4d e4	 mov	 ecx, DWORD PTR _reward$2[ebp]
  00168	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  0016c	52		 push	 edx
  0016d	8b 45 e4	 mov	 eax, DWORD PTR _reward$2[ebp]
  00170	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00173	51		 push	 ecx
  00174	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  0017b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00180	0f b6 8c 10 06
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+262]
  00188	51		 push	 ecx
  00189	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00190	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00195	0f b6 8c 10 04
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+260]
  0019d	51		 push	 ecx
  0019e	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  001a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001aa	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  001b2	81 c1 e3 00 00
	00		 add	 ecx, 227		; 000000e3H
  001b8	51		 push	 ecx
  001b9	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  001c0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c5	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  001c8	51		 push	 ecx
  001c9	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  001ce	83 c4 38	 add	 esp, 56			; 00000038H
$LN6@DropChaosG:

; 4011 : #endif
; 4012 : 		}
; 4013 : 	}

  001d1	e9 c6 fe ff ff	 jmp	 $LN2@DropChaosG
$LN1@DropChaosG:

; 4014 : /*
; 4015 : 	int iType = ItemGetNumberMake(12, 15);
; 4016 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// BC_MAPNUMBER_BASE_CHAOSGEM 
; 4017 : 	int iChaosGemMapNum = -1;
; 4018 : 	switch( gObj[iIndex].MapNumber )
; 4019 : 	{
; 4020 : 	case MAP_INDEX_BLOODCASTLE1: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM1; break;
; 4021 : 	case MAP_INDEX_BLOODCASTLE2: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM2; break;
; 4022 : 	case MAP_INDEX_BLOODCASTLE3: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM3; break;
; 4023 : 	case MAP_INDEX_BLOODCASTLE4: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM4; break;
; 4024 : 	case MAP_INDEX_BLOODCASTLE5: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM5; break;
; 4025 : 	case MAP_INDEX_BLOODCASTLE6: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM6; break;
; 4026 : 	case MAP_INDEX_BLOODCASTLE7: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM7; break;
; 4027 : 	case MAP_INDEX_BLOODCASTLE8: iChaosGemMapNum = BC_MAPNUMBER_CHAOSGEM8; break;
; 4028 : 	}
; 4029 : 	
; 4030 : 	ItemSerialCreateSend(gObj[iIndex].m_Index, iChaosGemMapNum, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 0, (BYTE)0, 0, 0, 0, iMaxHitUser);
; 4031 : #else
; 4032 : 	ItemSerialCreateSend(gObj[iIndex].m_Index, BC_MAPNUMBER_BASE_CHAOSGEM + gObj[iIndex].MapNumber, (BYTE)gObj[iIndex].X, (BYTE)gObj[iIndex].Y, iType, 0, (BYTE)0, 0, 0, 0, iMaxHitUser);
; 4033 : #endif
; 4034 : */
; 4035 : }

  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	5b		 pop	 ebx
  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c2 08 00	 ret	 8
?DropChaosGem@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::DropChaosGem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
tv67 = -80						; size = 4
tv68 = -76						; size = 4
_iRET_ZEN$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iZEN$ = 12						; size = 4
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardZEN, COMDAT
; _this$ = ecx

; 3935 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3936 : 	if (iZEN <= 0)

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _iZEN$[ebp], 0
  00010	7f 07		 jg	 SHORT $LN2@CalcSendRe

; 3937 : 		return 0;

  00012	33 c0		 xor	 eax, eax
  00014	e9 14 01 00 00	 jmp	 $LN1@CalcSendRe
$LN2@CalcSendRe:

; 3938 : 
; 3939 : 	INT iRET_ZEN = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRET_ZEN$[ebp], 0

; 3940 : 
; 3941 : 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  00020	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00024	7d 09		 jge	 SHORT $LN10@CalcSendRe
  00026	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  0002d	eb 1f		 jmp	 SHORT $LN11@CalcSendRe
$LN10@CalcSendRe:
  0002f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00036	7e 09		 jle	 SHORT $LN8@CalcSendRe
  00038	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  0003f	eb 07		 jmp	 SHORT $LN9@CalcSendRe
$LN8@CalcSendRe:
  00041	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
$LN9@CalcSendRe:
  00048	8b 45 b0	 mov	 eax, DWORD PTR tv67[ebp]
  0004b	89 45 b4	 mov	 DWORD PTR tv68[ebp], eax
$LN11@CalcSendRe:
  0004e	83 7d b4 00	 cmp	 DWORD PTR tv68[ebp], 0
  00052	75 07		 jne	 SHORT $LN3@CalcSendRe

; 3942 : 		return 0;

  00054	33 c0		 xor	 eax, eax
  00056	e9 d2 00 00 00	 jmp	 $LN1@CalcSendRe
$LN3@CalcSendRe:

; 3943 : 
; 3944 : 	if (gObj[iIndex].Connected < 3)

  0005b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00068	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0006d	7d 07		 jge	 SHORT $LN4@CalcSendRe

; 3945 : 		return 0;

  0006f	33 c0		 xor	 eax, eax
  00071	e9 b7 00 00 00	 jmp	 $LN1@CalcSendRe
$LN4@CalcSendRe:

; 3946 : 
; 3947 : #ifdef MODIFY_ZEN_MAX_20040414
; 3948 : 	if( !gObjCheckMaxZen( iIndex, iZEN ) )

  00076	8b 45 0c	 mov	 eax, DWORD PTR _iZEN$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  00083	83 c4 08	 add	 esp, 8
  00086	85 c0		 test	 eax, eax
  00088	75 4e		 jne	 SHORT $LN5@CalcSendRe

; 3949 : 	{
; 3950 : 		iRET_ZEN = MAX_ZEN - gObj[iIndex].Money;

  0008a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00097	ba 00 94 35 77	 mov	 edx, 2000000000		; 77359400H
  0009c	2b 94 01 b0 00
	00 00		 sub	 edx, DWORD PTR [ecx+eax+176]
  000a3	89 55 f8	 mov	 DWORD PTR _iRET_ZEN$[ebp], edx

; 3951 : 		gObj[iIndex].Money += iRET_ZEN;

  000a6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b3	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  000ba	03 55 f8	 add	 edx, DWORD PTR _iRET_ZEN$[ebp]
  000bd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ca	89 94 01 b0 00
	00 00		 mov	 DWORD PTR [ecx+eax+176], edx

; 3952 : 		return iRET_ZEN;

  000d1	8b 45 f8	 mov	 eax, DWORD PTR _iRET_ZEN$[ebp]
  000d4	eb 57		 jmp	 SHORT $LN1@CalcSendRe

; 3953 : 	}

  000d6	eb 2b		 jmp	 SHORT $LN6@CalcSendRe
$LN5@CalcSendRe:

; 3954 : 	else
; 3955 : #endif
; 3956 : 	gObj[iIndex].Money += iZEN;

  000d8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e5	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  000ec	03 55 0c	 add	 edx, DWORD PTR _iZEN$[ebp]
  000ef	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fc	89 94 01 b0 00
	00 00		 mov	 DWORD PTR [ecx+eax+176], edx
$LN6@CalcSendRe:

; 3957 : 
; 3958 : 	iRET_ZEN = iZEN;

  00103	8b 45 0c	 mov	 eax, DWORD PTR _iZEN$[ebp]
  00106	89 45 f8	 mov	 DWORD PTR _iRET_ZEN$[ebp], eax

; 3959 : 
; 3960 : #if TESTSERVER == 1 
; 3961 : 	LogAddTD("[Blood Castle] [%s][%s] CBloodCastle::CalcSendRewardZEN() - ZEN : %d", 
; 3962 : 		gObj[iIndex].AccountID,
; 3963 : 		gObj[iIndex].Name,
; 3964 : 		iZEN
; 3965 : 		);
; 3966 : #endif
; 3967 : 
; 3968 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  00109	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00110	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00116	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  0011d	52		 push	 edx
  0011e	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00127	83 c4 08	 add	 esp, 8

; 3969 : 
; 3970 : 	return iRET_ZEN;

  0012a	8b 45 f8	 mov	 eax, DWORD PTR _iRET_ZEN$[ebp]
$LN1@CalcSendRe:

; 3971 : }

  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	5b		 pop	 ebx
  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c2 08 00	 ret	 8
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardZEN
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
tv82 = -100						; size = 4
tv83 = -96						; size = 4
_pkillMsg$1 = -28					; size = 12
_iCAL_EXP$ = -16					; size = 4
_iRET_EXP$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iEXP$ = 12						; size = 4
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardEXP, COMDAT
; _this$ = ecx

; 3718 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3719 : 	if (iEXP <= 0)

  00016	83 7d 0c 00	 cmp	 DWORD PTR _iEXP$[ebp], 0
  0001a	7f 07		 jg	 SHORT $LN4@CalcSendRe

; 3720 : 		return 0;

  0001c	33 c0		 xor	 eax, eax
  0001e	e9 92 01 00 00	 jmp	 $LN1@CalcSendRe
$LN4@CalcSendRe:

; 3721 : 
; 3722 : #ifdef BUGFIX_GAIN_EXP_20071210
; 3723 : 	INT64 iRET_EXP = 0;
; 3724 : 	INT64 iCAL_EXP = iEXP;
; 3725 : #else
; 3726 : 	INT iRET_EXP = 0;

  00023	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iRET_EXP$[ebp], 0

; 3727 : 	INT iCAL_EXP = iEXP;

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _iEXP$[ebp]
  0002d	89 45 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax

; 3728 : #endif
; 3729 : 
; 3730 : #ifdef MU_CRYWOLF_PENALTY_20051215
; 3731 : 	// MVP  :    
; 3732 : 	if( g_CrywolfSync.GetOccupationState() == CRYWOLF_OCCUPATION_STATE_OCCUPIED 
; 3733 : 		&& g_iCrywolfApplyMvpPenalty	
; 3734 : 	  )
; 3735 : 	{
; 3736 : 		iCAL_EXP = iCAL_EXP * g_CrywolfSync.GetGettingExpPenaltyRate() / 100;
; 3737 : 	}
; 3738 : #endif
; 3739 : 	
; 3740 : #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004				// !! NOT
; 3741 : 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 3742 : 		#ifdef MODIFY_MARKITEM_EFFECT_REMOVE_IN_EVENTMAP_20070328
; 3743 : 	if( gObj[iIndex].m_wExprienceRate == 0 )
; 3744 : 	{
; 3745 : 		iEXP = 0;
; 3746 : 		iCAL_EXP = 0;
; 3747 : 	}
; 3748 : 		#else
; 3749 : 	if( gObj[iIndex].m_wExprienceRate > 0 )

  00030	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003d	0f b7 94 01 2c
	1a 00 00	 movzx	 edx, WORD PTR [ecx+eax+6700]
  00045	85 d2		 test	 edx, edx
  00047	7e 31		 jle	 SHORT $LN5@CalcSendRe

; 3750 : 	{
; 3751 : 		iEXP = (int)(iEXP * ((float)gObj[iIndex].m_wExprienceRate / 100 ));

  00049	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _iEXP$[ebp]
  0004e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005b	0f b7 94 01 2c
	1a 00 00	 movzx	 edx, WORD PTR [ecx+eax+6700]
  00063	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00067	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@42c80000
  0006f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00073	f3 0f 2c c0	 cvttss2si eax, xmm0
  00077	89 45 0c	 mov	 DWORD PTR _iEXP$[ebp], eax
$LN5@CalcSendRe:

; 3752 : 	}
; 3753 : 		#endif // MODIFY_MARKITEM_EFFECT_REMOVE_IN_EVENTMAP_20070328
; 3754 : 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 3755 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 3756 : 
; 3757 : 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  0007a	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  0007e	7d 09		 jge	 SHORT $LN15@CalcSendRe
  00080	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  00087	eb 1f		 jmp	 SHORT $LN16@CalcSendRe
$LN15@CalcSendRe:
  00089	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00090	7e 09		 jle	 SHORT $LN13@CalcSendRe
  00092	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
  00099	eb 07		 jmp	 SHORT $LN14@CalcSendRe
$LN13@CalcSendRe:
  0009b	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
$LN14@CalcSendRe:
  000a2	8b 45 9c	 mov	 eax, DWORD PTR tv82[ebp]
  000a5	89 45 a0	 mov	 DWORD PTR tv83[ebp], eax
$LN16@CalcSendRe:
  000a8	83 7d a0 00	 cmp	 DWORD PTR tv83[ebp], 0
  000ac	75 07		 jne	 SHORT $LN6@CalcSendRe

; 3758 : 		return 0;

  000ae	33 c0		 xor	 eax, eax
  000b0	e9 00 01 00 00	 jmp	 $LN1@CalcSendRe
$LN6@CalcSendRe:

; 3759 : 
; 3760 : 	if (gObj[iIndex].Connected < 3)

  000b5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c2	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  000c7	7d 07		 jge	 SHORT $LN7@CalcSendRe

; 3761 : 		return 0;

  000c9	33 c0		 xor	 eax, eax
  000cb	e9 e5 00 00 00	 jmp	 $LN1@CalcSendRe
$LN7@CalcSendRe:

; 3762 : 
; 3763 : 	iRET_EXP = iCAL_EXP;

  000d0	8b 45 f0	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  000d3	89 45 f4	 mov	 DWORD PTR _iRET_EXP$[ebp], eax

; 3764 : 
; 3765 : 	if( gObj[iIndex].Type == OBJTYPE_CHARACTER ) {

  000d6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e3	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000e8	83 fa 01	 cmp	 edx, 1
  000eb	0f 85 c1 00 00
	00		 jne	 $LN8@CalcSendRe
$LN2@CalcSendRe:

; 3766 : 		while (iCAL_EXP > 0) {

  000f1	83 7d f0 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp], 0
  000f5	7e 68		 jle	 SHORT $LN3@CalcSendRe

; 3767 : 			if (iCAL_EXP > 0) {

  000f7	83 7d f0 00	 cmp	 DWORD PTR _iCAL_EXP$[ebp], 0
  000fb	7e 60		 jle	 SHORT $LN11@CalcSendRe

; 3768 : #ifdef CHN_PLAYTIME_LIMIT_SYSTEM_20050818	// > .      .
; 3769 : 				if (g_bChnPlayTimeLimitOn)
; 3770 : 				{
; 3771 : 	#ifdef MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 3772 : 					if( gObj[iIndex].m_iVerifyType != PLAYTIME_LIMIT_VERIFY_ADULT )
; 3773 : 					{
; 3774 : 						if (gObj[iIndex].m_iPlayTimeLimit >= 5*60*60) {
; 3775 : 						iCAL_EXP = iCAL_EXP * g_iChnPlayTimeLimitLevel2Exp / 100;
; 3776 : 						}
; 3777 : 						else if (gObj[iIndex].m_iPlayTimeLimit >= 3*60*60) {
; 3778 : 							iCAL_EXP = iCAL_EXP * g_iChnPlayTimeLimitLevel1Exp / 100;
; 3779 : 						}
; 3780 : 					}
; 3781 : 	#else
; 3782 : 					if (gObj[iIndex].m_iPlayTimeLimit >= 5*60*60) {
; 3783 : 						iCAL_EXP = iCAL_EXP * g_iChnPlayTimeLimitLevel2Exp / 100;
; 3784 : 					}
; 3785 : 					else if (gObj[iIndex].m_iPlayTimeLimit >= 3*60*60) {
; 3786 : 						iCAL_EXP = iCAL_EXP * g_iChnPlayTimeLimitLevel1Exp / 100;
; 3787 : 					}
; 3788 : 	#endif // MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 3789 : 				}
; 3790 : #endif
; 3791 : 				
; 3792 : #ifdef VTM_PLAYTIME_LIMIT_SYSTEM_20060626 //  :    
; 3793 : 				if (g_bVtmPlayTimeLimitOn) 
; 3794 : 				{
; 3795 : 					if (gObj[iIndex].m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel2Time * 60 ) 
; 3796 : 					{
; 3797 : 						iCAL_EXP = iCAL_EXP * g_iVtmPlayTimeLimitLevel2Exp / 100;
; 3798 : 					}
; 3799 : 					else if (gObj[iIndex].m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel1Time * 60) 
; 3800 : 					{
; 3801 : 						iCAL_EXP = iCAL_EXP * g_iVtmPlayTimeLimitLevel1Exp / 100;
; 3802 : 					}
; 3803 : 				}
; 3804 : #endif
; 3805 : 
; 3806 : #ifdef MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 3807 : 				CheckItemOptForGetExpEx(&gObj[iIndex], iCAL_EXP, TRUE);
; 3808 : 				
; 3809 : 				//       
; 3810 : #ifdef UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 3811 : 				iCAL_EXP = (int)iCAL_EXP * m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_fRewardExpRate;
; 3812 : #endif //UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 3813 : 				
; 3814 : 				iRET_EXP = (int)iCAL_EXP;
; 3815 : #else // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 3816 : //--> MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC     
; 3817 : #ifdef MODIFY_EVENTMAP_REWARD_BUGFIX_20080404	//    
; 3818 : 				if( gObjCheckUsedBuffEffect( &gObj[iIndex], BUFFTYPE_PCBANG_POINT_MARK3 ))
; 3819 : 				{
; 3820 : 					iCAL_EXP = 0;
; 3821 : 				}
; 3822 : 				
; 3823 : 		#ifdef UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 3824 : 				iCAL_EXP = (int)iCAL_EXP * m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_fRewardExpRate;
; 3825 : 		#endif //UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 3826 : 				
; 3827 : 				iRET_EXP = iCAL_EXP;
; 3828 : #else	// MODIFY_EVENTMAP_REWARD_BUGFIX_20080404				
; 3829 : #ifdef PCBANG_POINT_SYSTEM_20070206	//  -  
; 3830 : 				g_PCBangPointSystem.CheckItemOptForGetExp( &gObj[iIndex], (int)iCAL_EXP );
; 3831 : #endif
; 3832 : #endif // MODIFY_EVENTMAP_REWARD_BUGFIX_20080404
; 3833 : 
; 3834 : 		//       
; 3835 : 		#ifdef UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 3836 : 				iCAL_EXP = (int)iCAL_EXP * m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_fRewardExpRate;
; 3837 : 		#endif //UPDATE_ADD_EVENT_MAP_EXP_RATE_20080320
; 3838 : 
; 3839 : #ifdef MODIFY_MARKITEM_20080506
; 3840 : 	#ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 3841 : 				CheckItemOptForGetExp(&gObj[iIndex], iCAL_EXP, TRUE);
; 3842 : 	#endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 3843 : #endif // MODIFY_MARKITEM_20080506
; 3844 : 				
; 3845 : 		#ifdef BUGFIX_GAIN_EXP_20071210				
; 3846 : 				iRET_EXP = iCAL_EXP;
; 3847 : 		#else
; 3848 : 				iRET_EXP = (int)iCAL_EXP;

  000fd	8b 45 f0	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  00100	89 45 f4	 mov	 DWORD PTR _iRET_EXP$[ebp], eax

; 3849 : 		#endif
; 3850 : //<--
; 3851 : #endif // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 3852 : 
; 3853 : #ifndef MODIFY_MARKITEM_20080506
; 3854 : 	//    riverstyx
; 3855 : 	#ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 3856 : 				CheckItemOptForGetExp(&gObj[iIndex], iCAL_EXP, TRUE);
; 3857 : 	#endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 3858 : #endif // MODIFY_MARKITEM_20080506
; 3859 : 
; 3860 : 	#ifdef MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 3861 : 				iCAL_EXP = LevelUp( iIndex, iCAL_EXP, EVENT_TYPE_BLOODCASTLE );

  00103	6a 04		 push	 4
  00105	8b 45 f0	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  00108	50		 push	 eax
  00109	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0010c	51		 push	 ecx
  0010d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	e8 00 00 00 00	 call	 ?LevelUp@CBloodCastle@@QAEHHHH@Z ; CBloodCastle::LevelUp
  00115	89 45 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax

; 3862 : 	#else
; 3863 : 				iCAL_EXP = LevelUp( iIndex, iCAL_EXP );
; 3864 : 	#endif // MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 3865 : 
; 3866 : #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004				// !!NOT
; 3867 : 	#ifdef MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 3868 : 		#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 3869 : 				if( gObj[iIndex].m_wExprienceRate > 0 )

  00118	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0011f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00125	0f b7 94 01 2c
	1a 00 00	 movzx	 edx, WORD PTR [ecx+eax+6700]
  0012d	85 d2		 test	 edx, edx
  0012f	7e 17		 jle	 SHORT $LN10@CalcSendRe

; 3870 : 				{
; 3871 : 					iCAL_EXP = LevelUp(iIndex, iCAL_EXP, EVENT_TYPE_BLOODCASTLE );

  00131	6a 04		 push	 4
  00133	8b 45 f0	 mov	 eax, DWORD PTR _iCAL_EXP$[ebp]
  00136	50		 push	 eax
  00137	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0013a	51		 push	 ecx
  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0013e	e8 00 00 00 00	 call	 ?LevelUp@CBloodCastle@@QAEHHHH@Z ; CBloodCastle::LevelUp
  00143	89 45 f0	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax

; 3872 : 				}

  00146	eb 15		 jmp	 SHORT $LN11@CalcSendRe
$LN10@CalcSendRe:

; 3873 : 				else
; 3874 : 				{
; 3875 : 					iEXP = 0;

  00148	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _iEXP$[ebp], 0

; 3876 : 					iCAL_EXP = 0;

  0014f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _iCAL_EXP$[ebp], 0

; 3877 : 					iRET_EXP = 0;

  00156	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iRET_EXP$[ebp], 0
$LN11@CalcSendRe:

; 3878 : 				}
; 3879 : 		#else
; 3880 : 				iCAL_EXP = LevelUp(iIndex, iCAL_EXP, EVENT_TYPE_BLOODCASTLE );
; 3881 : 		#endif // ADD_PCS_MARK_OF_EXP_20070205
; 3882 : 	#endif // MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 3883 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 3884 : 			}
; 3885 : 		}

  0015d	eb 92		 jmp	 SHORT $LN2@CalcSendRe
$LN3@CalcSendRe:

; 3886 : 
; 3887 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912
; 3888 : 	#if TESTSERVER == 1 
; 3889 : 			LogAddTD("[Blood Castle] [%s][%s] CBloodCastle::CalcSendRewardEXP() - EXP : %d", 
; 3890 : 				gObj[iIndex].AccountID,
; 3891 : 				gObj[iIndex].Name,
; 3892 : 				iRET_EXP
; 3893 : 				);
; 3894 : 	#endif
; 3895 : 		
; 3896 : 		//   .
; 3897 : 		// *    .
; 3898 : 		if( !g_MasterLevelSystem.IsMasterLevelUser( &gObj[iIndex] ) )
; 3899 : 		{
; 3900 : 	#ifdef BUGFIX_GAIN_EXP_20071210
; 3901 : 			GCSendExp_INT64( iIndex, 0xFFFF, iRET_EXP, 0, 0 );
; 3902 : 	#endif
; 3903 : 		}
; 3904 : #else
; 3905 : 		PMSG_KILLPLAYER_EXT	pkillMsg;
; 3906 : 
; 3907 : 		PHeadSetBE((LPBYTE)&pkillMsg, 0x9C, sizeof( pkillMsg));		//  0x16  INT   0x9C .

  0015f	6a 0c		 push	 12			; 0000000cH
  00161	68 9c 00 00 00	 push	 156			; 0000009cH
  00166	8d 45 e4	 lea	 eax, DWORD PTR _pkillMsg$1[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3908 : 
; 3909 : 		pkillMsg.NumberH	= HIBYTE( 0xFFFF );

  00172	c6 45 e7 ff	 mov	 BYTE PTR _pkillMsg$1[ebp+3], 255 ; 000000ffH

; 3910 : 		pkillMsg.NumberL	= LOBYTE( 0xFFFF );

  00176	c6 45 e8 ff	 mov	 BYTE PTR _pkillMsg$1[ebp+4], 255 ; 000000ffH

; 3911 : 		pkillMsg.ExpH		= HIWORD( iRET_EXP ) ;

  0017a	8b 45 f4	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
  0017d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00180	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00185	66 89 45 ea	 mov	 WORD PTR _pkillMsg$1[ebp+6], ax

; 3912 : 		pkillMsg.ExpL		= LOWORD( iRET_EXP ) ;

  00189	8b 45 f4	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
  0018c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00191	66 89 45 ec	 mov	 WORD PTR _pkillMsg$1[ebp+8], ax

; 3913 : 		pkillMsg.DamageH    = HIBYTE( 0 );

  00195	c6 45 ee 00	 mov	 BYTE PTR _pkillMsg$1[ebp+10], 0

; 3914 : 		pkillMsg.DamageL    = LOBYTE( 0 );

  00199	c6 45 ef 00	 mov	 BYTE PTR _pkillMsg$1[ebp+11], 0

; 3915 : 
; 3916 : #if TESTSERVER == 1 
; 3917 : 		LogAddTD("[Blood Castle] [%s][%s] CBloodCastle::CalcSendRewardEXP() - EXP : %d", 
; 3918 : 			gObj[iIndex].AccountID,
; 3919 : 			gObj[iIndex].Name,
; 3920 : 			iRET_EXP
; 3921 : 			);
; 3922 : #endif
; 3923 : 
; 3924 : 		//   .
; 3925 : 		DataSend(iIndex, (LPBYTE)&pkillMsg, pkillMsg.h.size);

  0019d	0f b6 45 e5	 movzx	 eax, BYTE PTR _pkillMsg$1[ebp+1]
  001a1	50		 push	 eax
  001a2	8d 4d e4	 lea	 ecx, DWORD PTR _pkillMsg$1[ebp]
  001a5	51		 push	 ecx
  001a6	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  001a9	52		 push	 edx
  001aa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CalcSendRe:

; 3926 : #endif
; 3927 : 	}
; 3928 : 
; 3929 : 	
; 3930 : 	return iRET_EXP;

  001b2	8b 45 f4	 mov	 eax, DWORD PTR _iRET_EXP$[ebp]
$LN1@CalcSendRe:

; 3931 : }

  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx
  001b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bb	33 cd		 xor	 ecx, ebp
  001bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c2 08 00	 ret	 8
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardEXP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?AddExperience@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
tv92 = -76						; size = 4
tv79 = -76						; size = 4
tv66 = -76						; size = 4
tv93 = -72						; size = 4
tv80 = -72						; size = 4
tv67 = -72						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iEXP$ = 12						; size = 4
?AddExperience@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::AddExperience, COMDAT
; _this$ = ecx

; 2487 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2488 : 	if(!CHECK_LIMIT( iIndex, MAX_OBJECT ) )

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN9@AddExperie
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN10@AddExperie
$LN9@AddExperie:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN7@AddExperie
  00024	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN8@AddExperie
$LN7@AddExperie:
  0002d	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN8@AddExperie:
  00034	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN10@AddExperie:
  0003a	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 07		 jne	 SHORT $LN2@AddExperie

; 2489 : 		return false;

  00040	32 c0		 xor	 al, al
  00042	e9 74 01 00 00	 jmp	 $LN1@AddExperie
$LN2@AddExperie:

; 2490 : 
; 2491 : 	if (!CHECK_LIMIT(gObj[iIndex].m_cBloodCastleIndex, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00047	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00054	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  0005c	85 d2		 test	 edx, edx
  0005e	7d 09		 jge	 SHORT $LN13@AddExperie
  00060	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00067	eb 30		 jmp	 SHORT $LN14@AddExperie
$LN13@AddExperie:
  00069	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00076	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  0007e	83 fa 06	 cmp	 edx, 6
  00081	7e 09		 jle	 SHORT $LN11@AddExperie
  00083	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  0008a	eb 07		 jmp	 SHORT $LN12@AddExperie
$LN11@AddExperie:
  0008c	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN12@AddExperie:
  00093	8b 45 b4	 mov	 eax, DWORD PTR tv79[ebp]
  00096	89 45 b8	 mov	 DWORD PTR tv80[ebp], eax
$LN14@AddExperie:
  00099	83 7d b8 00	 cmp	 DWORD PTR tv80[ebp], 0
  0009d	75 07		 jne	 SHORT $LN3@AddExperie

; 2492 : 		return false;

  0009f	32 c0		 xor	 al, al
  000a1	e9 15 01 00 00	 jmp	 $LN1@AddExperie
$LN3@AddExperie:

; 2493 : 
; 2494 : 	if (!CHECK_LIMIT(gObj[iIndex].m_cBloodCastleSubIndex, MAX_BLOODCASTLE_USER_COUNT))

  000a6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b3	0f be 94 01 d3
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3283]
  000bb	85 d2		 test	 edx, edx
  000bd	7d 09		 jge	 SHORT $LN17@AddExperie
  000bf	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
  000c6	eb 30		 jmp	 SHORT $LN18@AddExperie
$LN17@AddExperie:
  000c8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d5	0f be 94 01 d3
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3283]
  000dd	83 fa 09	 cmp	 edx, 9
  000e0	7e 09		 jle	 SHORT $LN15@AddExperie
  000e2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
  000e9	eb 07		 jmp	 SHORT $LN16@AddExperie
$LN15@AddExperie:
  000eb	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
$LN16@AddExperie:
  000f2	8b 45 b4	 mov	 eax, DWORD PTR tv92[ebp]
  000f5	89 45 b8	 mov	 DWORD PTR tv93[ebp], eax
$LN18@AddExperie:
  000f8	83 7d b8 00	 cmp	 DWORD PTR tv93[ebp], 0
  000fc	75 07		 jne	 SHORT $LN4@AddExperie

; 2495 : 		return false;

  000fe	32 c0		 xor	 al, al
  00100	e9 b6 00 00 00	 jmp	 $LN1@AddExperie
$LN4@AddExperie:

; 2496 : 
; 2497 : 	if (iEXP > 0) {		//      .

  00105	83 7d 0c 00	 cmp	 DWORD PTR _iEXP$[ebp], 0
  00109	0f 8e aa 00 00
	00		 jle	 $LN5@AddExperie

; 2498 : 		m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_UserData[gObj[iIndex].m_cBloodCastleSubIndex].m_iEXP += iEXP;

  0010f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011c	0f be 94 01 d2
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3282]
  00124	69 c2 04 02 00
	00		 imul	 eax, edx, 516
  0012a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00131	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013e	0f be 84 01 d3
	0c 00 00	 movsx	 eax, BYTE PTR [ecx+eax+3283]
  00146	6b c8 14	 imul	 ecx, eax, 20
  00149	8b 54 0a 1c	 mov	 edx, DWORD PTR [edx+ecx+28]
  0014d	03 55 0c	 add	 edx, DWORD PTR _iEXP$[ebp]
  00150	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00157	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015d	0f be 84 01 d3
	0c 00 00	 movsx	 eax, BYTE PTR [ecx+eax+3283]
  00165	6b c8 14	 imul	 ecx, eax, 20
  00168	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0016f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00175	0f be 84 06 d2
	0c 00 00	 movsx	 eax, BYTE PTR [esi+eax+3282]
  0017d	69 c0 04 02 00
	00		 imul	 eax, eax, 516
  00183	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00186	8d 44 06 04	 lea	 eax, DWORD PTR [esi+eax+4]
  0018a	89 54 08 1c	 mov	 DWORD PTR [eax+ecx+28], edx

; 2499 : 		gObj[iIndex].m_iBloodCastleEXP += iEXP;

  0018e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00195	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019b	8b 94 01 d4 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3284]
  001a2	03 55 0c	 add	 edx, DWORD PTR _iEXP$[ebp]
  001a5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b2	89 94 01 d4 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3284], edx
$LN5@AddExperie:

; 2500 : 	}
; 2501 : 
; 2502 : 	return true;

  001b9	b0 01		 mov	 al, 1
$LN1@AddExperie:

; 2503 : }

  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx
  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c2 08 00	 ret	 8
?AddExperience@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::AddExperience
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
tv75 = -108						; size = 4
tv66 = -108						; size = 4
tv76 = -104						; size = 4
tv67 = -104						; size = 4
_iItemType$1 = -36					; size = 4
_iMIX_NEED_MONEY$ = -32					; size = 4
_iMIX_SUCCESS_RATE$ = -28				; size = 4
_pMsg$ = -24						; size = 9
_bMIX_RESULT$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iLEVEL$ = 12						; size = 4
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::BloodCastleChaosMix, COMDAT
; _this$ = ecx

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1296 : 	if(!CHECK_LIMIT( iIndex, MAX_OBJECT ) )

  00016	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  0001a	7d 09		 jge	 SHORT $LN13@BloodCastl
  0001c	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00023	eb 1f		 jmp	 SHORT $LN14@BloodCastl
$LN13@BloodCastl:
  00025	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  0002c	7e 09		 jle	 SHORT $LN11@BloodCastl
  0002e	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00035	eb 07		 jmp	 SHORT $LN12@BloodCastl
$LN11@BloodCastl:
  00037	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN12@BloodCastl:
  0003e	8b 45 94	 mov	 eax, DWORD PTR tv66[ebp]
  00041	89 45 98	 mov	 DWORD PTR tv67[ebp], eax
$LN14@BloodCastl:
  00044	83 7d 98 00	 cmp	 DWORD PTR tv67[ebp], 0
  00048	75 07		 jne	 SHORT $LN2@BloodCastl

; 1297 : 		return false;

  0004a	32 c0		 xor	 al, al
  0004c	e9 a2 03 00 00	 jmp	 $LN1@BloodCastl
$LN2@BloodCastl:

; 1298 : 	
; 1299 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 1300 : 	int iMapNum = GetMapNumByBCBridge( iLEVEL - 1 );
; 1301 : 
; 1302 : 	if( !CHECK_BLOODCASTLE( iMapNum ) )
; 1303 : 		return false;
; 1304 : #else	
; 1305 : 	if(!CHECK_BLOODCASTLE( iLEVEL - 1 + MAP_INDEX_BLOODCASTLE1 ) )

  00051	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  00054	83 c0 0a	 add	 eax, 10			; 0000000aH
  00057	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0005a	7d 09		 jge	 SHORT $LN17@BloodCastl
  0005c	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  00063	eb 21		 jmp	 SHORT $LN18@BloodCastl
$LN17@BloodCastl:
  00065	8b 4d 0c	 mov	 ecx, DWORD PTR _iLEVEL$[ebp]
  00068	83 c1 0a	 add	 ecx, 10			; 0000000aH
  0006b	83 f9 11	 cmp	 ecx, 17			; 00000011H
  0006e	7e 09		 jle	 SHORT $LN15@BloodCastl
  00070	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  00077	eb 07		 jmp	 SHORT $LN16@BloodCastl
$LN15@BloodCastl:
  00079	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
$LN16@BloodCastl:
  00080	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  00083	89 55 98	 mov	 DWORD PTR tv76[ebp], edx
$LN18@BloodCastl:
  00086	83 7d 98 00	 cmp	 DWORD PTR tv76[ebp], 0
  0008a	75 07		 jne	 SHORT $LN3@BloodCastl

; 1306 : 		return false;

  0008c	32 c0		 xor	 al, al
  0008e	e9 60 03 00 00	 jmp	 $LN1@BloodCastl
$LN3@BloodCastl:

; 1307 : #endif
; 1308 : 	
; 1309 : 	BOOL bMIX_RESULT=FALSE;		//     ?

  00093	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bMIX_RESULT$[ebp], 0

; 1310 : 	
; 1311 : 	PMSG_CHAOSMIXRESULT	pMsg;
; 1312 : 	PHeadSetB((LPBYTE)&pMsg, 0x86, sizeof( pMsg ));

  0009a	6a 09		 push	 9
  0009c	68 86 00 00 00	 push	 134			; 00000086H
  000a1	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1313 : 	pMsg.Result		= 0x00;

  000ad	c6 45 eb 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 1314 : 	
; 1315 : 	gObj[iIndex].ChaosLock = TRUE;

  000b1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000be	c7 84 01 bc 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+3260], 1

; 1316 : 	LogAddTD("[Blood Castle]  Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)", 

  000c9	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  000cc	50		 push	 eax
  000cd	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  000d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000da	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  000de	50		 push	 eax
  000df	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  000e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ec	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  000f0	50		 push	 eax
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000fc	83 c4 10	 add	 esp, 16			; 00000010H

; 1317 : 		gObj[iIndex].AccountID, 
; 1318 : 		gObj[iIndex].Name, 
; 1319 : 		iLEVEL);
; 1320 : 
; 1321 : #ifdef EXTEND_LOG_SYSTEM_05_20060823
; 1322 : 	char chChaosLogText[20];
; 1323 : 
; 1324 : 	wsprintf( chChaosLogText, " Mix,%d", iLEVEL );
; 1325 : 	g_MixSystem.LogChaosItem(&gObj[iIndex], chChaosLogText );
; 1326 : #elif defined(MODIFY_MIX_SYSTEM_20070518)
; 1327 : 	g_MixSystem.LogChaosItem(&gObj[iIndex], " Mix");

  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FFCGFOPA@?E?u?$LI?m?$LI?A?E?d?5Mix@
  00104	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0010b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00111	50		 push	 eax
  00112	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00117	e8 00 00 00 00	 call	 ?LogChaosItem@CMixSystem@@QAEXPAVOBJECTSTRUCT@@PAD@Z ; CMixSystem::LogChaosItem

; 1328 : #endif // EXTEND_LOG_SYSTEM_05_20060823
; 1329 : 	
; 1330 : 	INT iMIX_SUCCESS_RATE = g_iBC_ChoasMixSuccessRate[iLEVEL-1];

  0011c	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  0011f	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR ?g_iBC_ChoasMixSuccessRate@@3QBHB[eax*4-4]
  00126	89 4d e4	 mov	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], ecx

; 1331 : 	if ( (iMIX_SUCCESS_RATE < 0) || (iMIX_SUCCESS_RATE > 100) ) {

  00129	83 7d e4 00	 cmp	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], 0
  0012d	7c 06		 jl	 SHORT $LN5@BloodCastl
  0012f	83 7d e4 64	 cmp	 DWORD PTR _iMIX_SUCCESS_RATE$[ebp], 100 ; 00000064H
  00133	7e 52		 jle	 SHORT $LN4@BloodCastl
$LN5@BloodCastl:

; 1332 : 		//   ( ->     .)
; 1333 : 		DataSend( iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00135	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00139	50		 push	 eax
  0013a	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0013d	51		 push	 ecx
  0013e	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1334 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Name:%s, Level:%d)",

  0014a	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  0014d	50		 push	 eax
  0014e	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00155	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015b	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0015f	50		 push	 eax
  00160	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00167	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016d	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00171	50		 push	 eax
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0017d	83 c4 10	 add	 esp, 16			; 00000010H

; 1335 : 			gObj[iIndex].AccountID, 
; 1336 : 			gObj[iIndex].Name, 
; 1337 : 			iLEVEL
; 1338 : 			);
; 1339 : 		return FALSE;

  00180	32 c0		 xor	 al, al
  00182	e9 6c 02 00 00	 jmp	 $LN1@BloodCastl
$LN4@BloodCastl:

; 1340 : 	}
; 1341 : 	
; 1342 : #ifdef MU_CRYWOLF_BENEFIT_20051215
; 1343 : 	// MVP  :     (  )
; 1344 : 	if( g_CrywolfSync.GetOccupationState() == CRYWOLF_OCCUPATION_STATE_PEACE 
; 1345 : 		&& g_iCrywolfApplyMvpBenefit	
; 1346 : 	  )
; 1347 : 	{
; 1348 : 		iMIX_SUCCESS_RATE += g_CrywolfSync.GetPlusChaosRate();
; 1349 : 	}
; 1350 : #endif
; 1351 : 
; 1352 : #ifdef MODIFY_CHAOSMIX_RATE_FIX_20070304
; 1353 : 	if( iMIX_SUCCESS_RATE > 80 )
; 1354 : 	{
; 1355 : 		iMIX_SUCCESS_RATE = 80;
; 1356 : 	}
; 1357 : #endif // MODIFY_CHAOSMIX_RATE_FIX_20070304
; 1358 : 
; 1359 : #ifdef ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1360 : 	if( gObj[iIndex].ChaosSuccessRate > 10 )
; 1361 : 	{
; 1362 : 		pMsg.Result	= 0xF0;
; 1363 : 		gObj[iIndex].ChaosLock = FALSE;
; 1364 : 		DataSend( iIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 1365 : 	}
; 1366 : 	iMIX_SUCCESS_RATE += gObj[iIndex].ChaosSuccessRate;
; 1367 : #endif // ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1368 : 	
; 1369 : 	INT iMIX_NEED_MONEY = g_iBC_ChoasMixMoney[iLEVEL-1];

  00187	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  0018a	8b 0c 85 fc ff
	ff ff		 mov	 ecx, DWORD PTR ?g_iBC_ChoasMixMoney@@3QBHB[eax*4-4]
  00191	89 4d e0	 mov	 DWORD PTR _iMIX_NEED_MONEY$[ebp], ecx

; 1370 : 	
; 1371 : #ifdef MU_CASTLESIEGE_TAX_SYSTEM_20041219	//    -   
; 1372 : 	INT iChaosTaxMoney		= (INT)((INT64)iMIX_NEED_MONEY * (INT64)g_CastleSiegeSync.GetTaxRateChaos(iIndex) / (INT64)100);
; 1373 : 	if (iChaosTaxMoney < 0)
; 1374 : 		iChaosTaxMoney	= 0;
; 1375 : 
; 1376 : 	iMIX_NEED_MONEY			= iMIX_NEED_MONEY + iChaosTaxMoney;
; 1377 : #endif
; 1378 : 
; 1379 : 	if ( iMIX_NEED_MONEY < 0 ) {

  00194	83 7d e0 00	 cmp	 DWORD PTR _iMIX_NEED_MONEY$[ebp], 0
  00198	7d 52		 jge	 SHORT $LN6@BloodCastl

; 1380 : 		//   ( ->     .)
; 1381 : 		DataSend( iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0019a	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0019e	50		 push	 eax
  0019f	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  001a2	51		 push	 ecx
  001a3	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1382 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Level:%d)", 

  001af	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  001b2	50		 push	 eax
  001b3	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  001ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c0	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  001c4	50		 push	 eax
  001c5	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  001cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d2	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  001d6	50		 push	 eax
  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@
  001dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001e2	83 c4 10	 add	 esp, 16			; 00000010H

; 1383 : 			gObj[iIndex].AccountID, 
; 1384 : 			gObj[iIndex].Name, 
; 1385 : 			iLEVEL
; 1386 : 			);
; 1387 : 		return FALSE;

  001e5	32 c0		 xor	 al, al
  001e7	e9 07 02 00 00	 jmp	 $LN1@BloodCastl
$LN6@BloodCastl:

; 1388 : 	}
; 1389 : 	
; 1390 : 	if( (gObj[iIndex].Money - iMIX_NEED_MONEY) < 0 )

  001ec	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f9	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  00200	2b 55 e0	 sub	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  00203	79 56		 jns	 SHORT $LN7@BloodCastl

; 1391 : 	{
; 1392 : 		//  . (0x86, Result: 0x0B  )
; 1393 : 		pMsg.Result	= 0x0B;

  00205	c6 45 eb 0b	 mov	 BYTE PTR _pMsg$[ebp+3], 11 ; 0000000bH

; 1394 : 		DataSend( iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00209	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0020d	50		 push	 eax
  0020e	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00211	51		 push	 ecx
  00212	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00215	52		 push	 edx
  00216	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0021b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1395 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s, Level:%d)", 

  0021e	8b 45 0c	 mov	 eax, DWORD PTR _iLEVEL$[ebp]
  00221	50		 push	 eax
  00222	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00229	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0022f	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00233	50		 push	 eax
  00234	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  0023b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00241	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00245	50		 push	 eax
  00246	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Cha@
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00251	83 c4 10	 add	 esp, 16			; 00000010H

; 1396 : 			gObj[iIndex].AccountID, 
; 1397 : 			gObj[iIndex].Name, 
; 1398 : 			iLEVEL
; 1399 : 			);
; 1400 : 		return FALSE;

  00254	32 c0		 xor	 al, al
  00256	e9 98 01 00 00	 jmp	 $LN1@BloodCastl
$LN7@BloodCastl:

; 1401 : 	}
; 1402 : 	
; 1403 : 	gObj[iIndex].Money -= iMIX_NEED_MONEY;

  0025b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00262	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00268	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  0026f	2b 55 e0	 sub	 edx, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  00272	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00279	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027f	89 94 01 b0 00
	00 00		 mov	 DWORD PTR [ecx+eax+176], edx

; 1404 : #ifdef MU_CASTLESIEGE_SERVER_SYNC_20041130		//     -   
; 1405 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);
; 1406 : #endif
; 1407 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  00286	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0028d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00293	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  0029a	52		 push	 edx
  0029b	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  002a4	83 c4 08	 add	 esp, 8

; 1408 : 	
; 1409 : 	if (rand()%100 < iMIX_SUCCESS_RATE) {

  002a7	e8 00 00 00 00	 call	 _rand
  002ac	99		 cdq
  002ad	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  002b2	f7 f9		 idiv	 ecx
  002b4	3b 55 e4	 cmp	 edx, DWORD PTR _iMIX_SUCCESS_RATE$[ebp]
  002b7	0f 8d 92 00 00
	00		 jge	 $LN8@BloodCastl

; 1410 : 		//    . =>  .
; 1411 : 		int iItemType  = MAKE_ITEMNUM(13, 18);

  002bd	6a 12		 push	 18			; 00000012H
  002bf	6a 0d		 push	 13			; 0000000dH
  002c1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002c6	83 c4 08	 add	 esp, 8
  002c9	89 45 dc	 mov	 DWORD PTR _iItemType$1[ebp], eax

; 1412 : #ifdef FOR_BLOODCASTLE_TEST
; 1413 : 		ItemSerialCreateSend(iIndex, 255, 0, 0, iItemType, iLEVEL, 0, 0, 0, 0);
; 1414 : #else
; 1415 : 		ItemSerialCreateSend(iIndex, 255, 0, 0, iItemType, iLEVEL, 255, 0, 0, 0);

  002cc	6a 00		 push	 0
  002ce	6a 00		 push	 0
  002d0	6a 00		 push	 0
  002d2	6a ff		 push	 -1
  002d4	6a 00		 push	 0
  002d6	6a 00		 push	 0
  002d8	6a 00		 push	 0
  002da	68 ff 00 00 00	 push	 255			; 000000ffH
  002df	0f b6 45 0c	 movzx	 eax, BYTE PTR _iLEVEL$[ebp]
  002e3	50		 push	 eax
  002e4	8b 4d dc	 mov	 ecx, DWORD PTR _iItemType$1[ebp]
  002e7	51		 push	 ecx
  002e8	6a 00		 push	 0
  002ea	6a 00		 push	 0
  002ec	68 ff 00 00 00	 push	 255			; 000000ffH
  002f1	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  002f4	52		 push	 edx
  002f5	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  002fa	83 c4 38	 add	 esp, 56			; 00000038H

; 1416 : #endif
; 1417 : 
; 1418 : 		LogAddTD("[ Mix] [%s][%s] CBMix Success %d Money : %d-%d", 

  002fd	8b 45 e0	 mov	 eax, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  00300	50		 push	 eax
  00301	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00308	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0030e	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  00315	50		 push	 eax
  00316	8b 4d e4	 mov	 ecx, DWORD PTR _iMIX_SUCCESS_RATE$[ebp]
  00319	51		 push	 ecx
  0031a	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00321	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00326	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  0032a	51		 push	 ecx
  0032b	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00332	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00337	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  0033b	51		 push	 ecx
  0033c	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@PODHMCM@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5S@
  00341	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00347	83 c4 18	 add	 esp, 24			; 00000018H

; 1419 : 			   gObj[iIndex].AccountID, gObj[iIndex].Name, 
; 1420 : 			   iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);
; 1421 : 	}

  0034a	e9 96 00 00 00	 jmp	 $LN9@BloodCastl
$LN8@BloodCastl:

; 1422 : 	else {
; 1423 : 		//  .
; 1424 : #ifdef MODIFY_MIX_SYSTEM_20070518
; 1425 : 		g_MixSystem.ChaosBoxInit(&gObj[iIndex]);

  0034f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00356	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0035c	50		 push	 eax
  0035d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00362	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit

; 1426 : #endif
; 1427 : 		GCUserChaosBoxSend(&gObj[iIndex]);

  00367	6a 00		 push	 0
  00369	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00370	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00376	50		 push	 eax
  00377	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAVOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend
  0037c	83 c4 08	 add	 esp, 8

; 1428 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0037f	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00383	50		 push	 eax
  00384	8d 4d e8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00387	51		 push	 ecx
  00388	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0038b	52		 push	 edx
  0038c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00391	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1429 : 		LogAddTD("[ Mix] [%s][%s] CBMix Fail %d Money : %d-%d",  

  00394	8b 45 e0	 mov	 eax, DWORD PTR _iMIX_NEED_MONEY$[ebp]
  00397	50		 push	 eax
  00398	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  0039f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a5	8b 84 0a b0 00
	00 00		 mov	 eax, DWORD PTR [edx+ecx+176]
  003ac	50		 push	 eax
  003ad	8b 4d e4	 mov	 ecx, DWORD PTR _iMIX_SUCCESS_RATE$[ebp]
  003b0	51		 push	 ecx
  003b1	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  003b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003bd	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  003c1	51		 push	 ecx
  003c2	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  003c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ce	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  003d2	51		 push	 ecx
  003d3	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KMNEMIOE@?$FL?E?u?$LI?m?$LI?A?E?d?5Mix?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5F@
  003d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003de	83 c4 18	 add	 esp, 24			; 00000018H

; 1430 : 			   gObj[iIndex].AccountID, gObj[iIndex].Name, 
; 1431 : 			   iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);
; 1432 : 		
; 1433 : #ifdef 	CHAOS_MIX_UPGRADE
; 1434 : 		return FALSE;

  003e1	32 c0		 xor	 al, al
  003e3	eb 0e		 jmp	 SHORT $LN1@BloodCastl
$LN9@BloodCastl:

; 1435 : #endif
; 1436 : 	}
; 1437 : 	
; 1438 : 	gObjInventoryCommit(iIndex);

  003e5	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  003e8	50		 push	 eax
  003e9	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  003ee	83 c4 04	 add	 esp, 4

; 1439 : 	
; 1440 : 	return TRUE;

  003f1	b0 01		 mov	 al, 1
$LN1@BloodCastl:

; 1441 : }

  003f3	5f		 pop	 edi
  003f4	5e		 pop	 esi
  003f5	5b		 pop	 ebx
  003f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f9	33 cd		 xor	 ecx, ebp
  003fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00400	8b e5		 mov	 esp, ebp
  00402	5d		 pop	 ebp
  00403	c2 08 00	 ret	 8
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::BloodCastleChaosMix
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?CheckChoasMixItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv178 = -120						; size = 4
tv171 = -120						; size = 4
tv66 = -120						; size = 4
tv179 = -116						; size = 4
tv172 = -116						; size = 4
tv67 = -116						; size = 4
_iITEM_LEVEL$1 = -48					; size = 4
_iITEM_LEVEL$2 = -44					; size = 4
_i$3 = -40						; size = 4
_iBloodBoneLevel$ = -36					; size = 4
_iAngelKingPaperLevel$ = -32				; size = 4
_iEventItemCount$ = -28					; size = 4
_bIsOtherItemExist$ = -24				; size = 4
_bIsBloodBoneExist$ = -20				; size = 4
_bIsAngelKingPaperExist$ = -16				; size = 4
_bIsChaosGemExist$ = -12				; size = 4
_iCHAOS_MIX_LEVEL$ = -8					; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckChoasMixItem, COMDAT
; _this$ = ecx

; 1445 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1446 : 	if(!CHECK_LIMIT( iIndex, MAX_OBJECT ) )

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN33@CheckChoas
  00012	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN34@CheckChoas
$LN33@CheckChoas:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN31@CheckChoas
  00024	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN32@CheckChoas
$LN31@CheckChoas:
  0002d	c7 45 88 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN32@CheckChoas:
  00034	8b 45 88	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 8c	 mov	 DWORD PTR tv67[ebp], eax
$LN34@CheckChoas:
  0003a	83 7d 8c 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 07		 jne	 SHORT $LN5@CheckChoas

; 1447 : 		return 0;

  00040	33 c0		 xor	 eax, eax
  00042	e9 38 03 00 00	 jmp	 $LN1@CheckChoas
$LN5@CheckChoas:

; 1448 : 
; 1449 : 	INT iCHAOS_MIX_LEVEL = 0;					//      ?

  00047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iCHAOS_MIX_LEVEL$[ebp], 0

; 1450 : 
; 1451 : 	BOOL bIsChaosGemExist = FALSE;				//    ?

  0004e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bIsChaosGemExist$[ebp], 0

; 1452 : 	BOOL bIsAngelKingPaperExist = FALSE;		//   ?

  00055	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0

; 1453 : 	BOOL bIsBloodBoneExist = FALSE;				//   ?

  0005c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bIsBloodBoneExist$[ebp], 0

; 1454 : 	BOOL bIsOtherItemExist = FALSE;				//    ?

  00063	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bIsOtherItemExist$[ebp], 0

; 1455 : 
; 1456 : 	INT iEventItemCount = 0;

  0006a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iEventItemCount$[ebp], 0

; 1457 : 
; 1458 : 	INT iAngelKingPaperLevel = 0;

  00071	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iAngelKingPaperLevel$[ebp], 0

; 1459 : 	INT iBloodBoneLevel = 0;

  00078	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _iBloodBoneLevel$[ebp], 0

; 1460 : 
; 1461 : #ifdef ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1462 : 	int iCharmOfLuckCount = 0;
; 1463 : #endif // ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1464 : 
; 1465 : 	for( int i=0; i<MAX_CHAOSBOXITEMS; i++)

  0007f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00086	eb 09		 jmp	 SHORT $LN4@CheckChoas
$LN2@CheckChoas:
  00088	8b 45 d8	 mov	 eax, DWORD PTR _i$3[ebp]
  0008b	83 c0 01	 add	 eax, 1
  0008e	89 45 d8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@CheckChoas:
  00091	83 7d d8 20	 cmp	 DWORD PTR _i$3[ebp], 32	; 00000020H
  00095	0f 8d 47 01 00
	00		 jge	 $LN3@CheckChoas

; 1466 : 	{
; 1467 : 		if( gObj[iIndex].pChaosBox[i].IsItem() == TRUE )

  0009b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000a2	69 4d d8 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$3[ebp], 168
  000a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	03 8c 02 ac 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3244]
  000b6	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000bb	83 f8 01	 cmp	 eax, 1
  000be	0f 85 19 01 00
	00		 jne	 $LN6@CheckChoas

; 1468 : 		{
; 1469 : 			if( gObj[iIndex].pChaosBox[i].m_Type == MAKE_ITEMNUM(12, 15) )

  000c4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000cb	69 4d d8 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$3[ebp], 168
  000d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d8	8b 84 02 ac 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3244]
  000df	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  000e4	6a 0f		 push	 15			; 0000000fH
  000e6	6a 0c		 push	 12			; 0000000cH
  000e8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ed	83 c4 08	 add	 esp, 8
  000f0	3b f0		 cmp	 esi, eax
  000f2	75 0c		 jne	 SHORT $LN7@CheckChoas

; 1470 : 			{	//  
; 1471 : 				bIsChaosGemExist = TRUE;

  000f4	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bIsChaosGemExist$[ebp], 1

; 1472 : 			}

  000fb	e9 dd 00 00 00	 jmp	 $LN6@CheckChoas
$LN7@CheckChoas:

; 1473 : 			else if( gObj[iIndex].pChaosBox[i].m_Type == MAKE_ITEMNUM(13, 16) )

  00100	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00107	69 4d d8 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$3[ebp], 168
  0010e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00114	8b 84 02 ac 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3244]
  0011b	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00120	6a 10		 push	 16			; 00000010H
  00122	6a 0d		 push	 13			; 0000000dH
  00124	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00129	83 c4 08	 add	 esp, 8
  0012c	3b f0		 cmp	 esi, eax
  0012e	75 3b		 jne	 SHORT $LN9@CheckChoas

; 1474 : 			{	//  
; 1475 : 				INT iITEM_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;

  00130	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00137	69 4d d8 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$3[ebp], 168
  0013e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00144	8b 84 02 ac 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3244]
  0014b	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  00150	89 4d d4	 mov	 DWORD PTR _iITEM_LEVEL$2[ebp], ecx

; 1476 : 
; 1477 : 				iEventItemCount++;

  00153	8b 45 e4	 mov	 eax, DWORD PTR _iEventItemCount$[ebp]
  00156	83 c0 01	 add	 eax, 1
  00159	89 45 e4	 mov	 DWORD PTR _iEventItemCount$[ebp], eax

; 1478 : 				bIsAngelKingPaperExist = TRUE;

  0015c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 1

; 1479 : 
; 1480 : 				iAngelKingPaperLevel = iITEM_LEVEL;

  00163	8b 45 d4	 mov	 eax, DWORD PTR _iITEM_LEVEL$2[ebp]
  00166	89 45 e0	 mov	 DWORD PTR _iAngelKingPaperLevel$[ebp], eax

; 1481 : 			}

  00169	eb 72		 jmp	 SHORT $LN6@CheckChoas
$LN9@CheckChoas:

; 1482 : 			else if( gObj[iIndex].pChaosBox[i].m_Type == MAKE_ITEMNUM(13, 17) )

  0016b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00172	69 4d d8 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$3[ebp], 168
  00179	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017f	8b 84 02 ac 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3244]
  00186	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0018b	6a 11		 push	 17			; 00000011H
  0018d	6a 0d		 push	 13			; 0000000dH
  0018f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00194	83 c4 08	 add	 esp, 8
  00197	3b f0		 cmp	 esi, eax
  00199	75 3b		 jne	 SHORT $LN11@CheckChoas

; 1483 : 			{	//  
; 1484 : 				INT iITEM_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;

  0019b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001a2	69 4d d8 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$3[ebp], 168
  001a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001af	8b 84 02 ac 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3244]
  001b6	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  001bb	89 4d d0	 mov	 DWORD PTR _iITEM_LEVEL$1[ebp], ecx

; 1485 : 
; 1486 : 				iEventItemCount++;

  001be	8b 45 e4	 mov	 eax, DWORD PTR _iEventItemCount$[ebp]
  001c1	83 c0 01	 add	 eax, 1
  001c4	89 45 e4	 mov	 DWORD PTR _iEventItemCount$[ebp], eax

; 1487 : 				bIsBloodBoneExist = TRUE;

  001c7	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bIsBloodBoneExist$[ebp], 1

; 1488 : 
; 1489 : 				iBloodBoneLevel = iITEM_LEVEL;

  001ce	8b 45 d0	 mov	 eax, DWORD PTR _iITEM_LEVEL$1[ebp]
  001d1	89 45 dc	 mov	 DWORD PTR _iBloodBoneLevel$[ebp], eax

; 1490 : 			}

  001d4	eb 07		 jmp	 SHORT $LN6@CheckChoas
$LN11@CheckChoas:

; 1491 : #ifdef ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1492 : 			else if( gObj[iIndex].pChaosBox[i].m_Type == MAKE_ITEMNUM( 14, 53 ) )
; 1493 : 			{
; 1494 : 				iCharmOfLuckCount += gObj[iIndex].pChaosBox[i].m_Durability;
; 1495 : 			}
; 1496 : #endif // ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1497 : 			else
; 1498 : 			{	//    
; 1499 : 				bIsOtherItemExist = TRUE;

  001d6	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bIsOtherItemExist$[ebp], 1
$LN6@CheckChoas:

; 1500 : 			}
; 1501 : 		}		
; 1502 : 	}

  001dd	e9 a6 fe ff ff	 jmp	 $LN2@CheckChoas
$LN3@CheckChoas:

; 1503 : 
; 1504 : #ifdef ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1505 : 	gObj[iIndex].ChaosSuccessRate = iCharmOfLuckCount;
; 1506 : #endif // ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1507 : 
; 1508 : 	if (bIsOtherItemExist) {

  001e2	83 7d e8 00	 cmp	 DWORD PTR _bIsOtherItemExist$[ebp], 0
  001e6	74 0a		 je	 SHORT $LN13@CheckChoas

; 1509 : 		return 8;		//    ->    .

  001e8	b8 08 00 00 00	 mov	 eax, 8
  001ed	e9 8d 01 00 00	 jmp	 $LN1@CheckChoas
$LN13@CheckChoas:

; 1510 : 	}
; 1511 : 
; 1512 : 	if ((!bIsAngelKingPaperExist) && (!bIsBloodBoneExist)) {

  001f2	83 7d f0 00	 cmp	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0
  001f6	75 0f		 jne	 SHORT $LN14@CheckChoas
  001f8	83 7d ec 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  001fc	75 09		 jne	 SHORT $LN14@CheckChoas

; 1513 : 		return 0;		//       .

  001fe	33 c0		 xor	 eax, eax
  00200	e9 7a 01 00 00	 jmp	 $LN1@CheckChoas

; 1514 : 	}

  00205	eb 16		 jmp	 SHORT $LN15@CheckChoas
$LN14@CheckChoas:

; 1515 : 
; 1516 : 	else if ((!bIsAngelKingPaperExist) || (!bIsBloodBoneExist)) {

  00207	83 7d f0 00	 cmp	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0
  0020b	74 06		 je	 SHORT $LN17@CheckChoas
  0020d	83 7d ec 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  00211	75 0a		 jne	 SHORT $LN15@CheckChoas
$LN17@CheckChoas:

; 1517 : 		return 11;		// ,    

  00213	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00218	e9 62 01 00 00	 jmp	 $LN1@CheckChoas
$LN15@CheckChoas:

; 1518 : 	}
; 1519 : 
; 1520 : 	if (iEventItemCount > 2) {

  0021d	83 7d e4 02	 cmp	 DWORD PTR _iEventItemCount$[ebp], 2
  00221	7e 0a		 jle	 SHORT $LN18@CheckChoas

; 1521 : 		return 12;		//    .

  00223	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00228	e9 52 01 00 00	 jmp	 $LN1@CheckChoas
$LN18@CheckChoas:

; 1522 : 	}
; 1523 : 
; 1524 : #ifdef ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1525 : 	if( iCharmOfLuckCount > 10 )
; 1526 : 	{
; 1527 : 		return 15;
; 1528 : 	}
; 1529 : #endif // ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 1530 : 
; 1531 : 	if (iAngelKingPaperLevel != iBloodBoneLevel) {

  0022d	8b 45 e0	 mov	 eax, DWORD PTR _iAngelKingPaperLevel$[ebp]
  00230	3b 45 dc	 cmp	 eax, DWORD PTR _iBloodBoneLevel$[ebp]
  00233	74 0f		 je	 SHORT $LN19@CheckChoas

; 1532 : 		return 9;		//    

  00235	b8 09 00 00 00	 mov	 eax, 9
  0023a	e9 40 01 00 00	 jmp	 $LN1@CheckChoas

; 1533 : 	}

  0023f	e9 84 00 00 00	 jmp	 $LN20@CheckChoas
$LN19@CheckChoas:

; 1534 : 	else {
; 1535 : 		if (!CHECK_LIMIT(iAngelKingPaperLevel-1, MAX_BLOODCASTLE_BRIDGE_COUNT)) 

  00244	8b 45 e0	 mov	 eax, DWORD PTR _iAngelKingPaperLevel$[ebp]
  00247	83 e8 01	 sub	 eax, 1
  0024a	79 09		 jns	 SHORT $LN37@CheckChoas
  0024c	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv172[ebp], 0
  00253	eb 21		 jmp	 SHORT $LN38@CheckChoas
$LN37@CheckChoas:
  00255	8b 4d e0	 mov	 ecx, DWORD PTR _iAngelKingPaperLevel$[ebp]
  00258	83 e9 01	 sub	 ecx, 1
  0025b	83 f9 06	 cmp	 ecx, 6
  0025e	7e 09		 jle	 SHORT $LN35@CheckChoas
  00260	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv171[ebp], 0
  00267	eb 07		 jmp	 SHORT $LN36@CheckChoas
$LN35@CheckChoas:
  00269	c7 45 88 01 00
	00 00		 mov	 DWORD PTR tv171[ebp], 1
$LN36@CheckChoas:
  00270	8b 55 88	 mov	 edx, DWORD PTR tv171[ebp]
  00273	89 55 8c	 mov	 DWORD PTR tv172[ebp], edx
$LN38@CheckChoas:
  00276	83 7d 8c 00	 cmp	 DWORD PTR tv172[ebp], 0
  0027a	75 0a		 jne	 SHORT $LN21@CheckChoas

; 1536 : 			return 9;

  0027c	b8 09 00 00 00	 mov	 eax, 9
  00281	e9 f9 00 00 00	 jmp	 $LN1@CheckChoas
$LN21@CheckChoas:

; 1537 : 
; 1538 : 		if (!CHECK_LIMIT(iBloodBoneLevel-1, MAX_BLOODCASTLE_BRIDGE_COUNT))

  00286	8b 45 dc	 mov	 eax, DWORD PTR _iBloodBoneLevel$[ebp]
  00289	83 e8 01	 sub	 eax, 1
  0028c	79 09		 jns	 SHORT $LN41@CheckChoas
  0028e	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
  00295	eb 21		 jmp	 SHORT $LN42@CheckChoas
$LN41@CheckChoas:
  00297	8b 4d dc	 mov	 ecx, DWORD PTR _iBloodBoneLevel$[ebp]
  0029a	83 e9 01	 sub	 ecx, 1
  0029d	83 f9 06	 cmp	 ecx, 6
  002a0	7e 09		 jle	 SHORT $LN39@CheckChoas
  002a2	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv178[ebp], 0
  002a9	eb 07		 jmp	 SHORT $LN40@CheckChoas
$LN39@CheckChoas:
  002ab	c7 45 88 01 00
	00 00		 mov	 DWORD PTR tv178[ebp], 1
$LN40@CheckChoas:
  002b2	8b 55 88	 mov	 edx, DWORD PTR tv178[ebp]
  002b5	89 55 8c	 mov	 DWORD PTR tv179[ebp], edx
$LN42@CheckChoas:
  002b8	83 7d 8c 00	 cmp	 DWORD PTR tv179[ebp], 0
  002bc	75 0a		 jne	 SHORT $LN20@CheckChoas

; 1539 : 			return 9;

  002be	b8 09 00 00 00	 mov	 eax, 9
  002c3	e9 b7 00 00 00	 jmp	 $LN1@CheckChoas
$LN20@CheckChoas:

; 1540 : 	}
; 1541 : 
; 1542 : #ifdef	FOR_BLOODCASTLE3
; 1543 : 	// 2003.10.21    
; 1544 : /*	if ( (iAngelKingPaperLevel == 1) && (iBloodBoneLevel == 1) ) {
; 1545 : 		//  1    
; 1546 : 		bIsChaosGemExist = TRUE;
; 1547 : 	}
; 1548 : */
; 1549 : #endif
; 1550 : 
; 1551 : 	if (!bIsChaosGemExist) {

  002c8	83 7d f4 00	 cmp	 DWORD PTR _bIsChaosGemExist$[ebp], 0
  002cc	75 0a		 jne	 SHORT $LN23@CheckChoas

; 1552 : 		return 10;		//  

  002ce	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  002d3	e9 a7 00 00 00	 jmp	 $LN1@CheckChoas
$LN23@CheckChoas:

; 1553 : 	}
; 1554 : 
; 1555 : 	//        
; 1556 : #ifdef DARKLORD_WORK
; 1557 : 	if (gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA) {

  002d8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e5	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  002ed	83 fa 04	 cmp	 edx, 4
  002f0	74 1a		 je	 SHORT $LN26@CheckChoas
  002f2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ff	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00307	83 fa 03	 cmp	 edx, 3
  0030a	75 2e		 jne	 SHORT $LN24@CheckChoas
$LN26@CheckChoas:

; 1558 : #else
; 1559 : 	if (gObj[iIndex].Class == CLASS_MAGUMSA) {
; 1560 : #endif
; 1561 : 		if (gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND_MAGUMSA) {

  0030c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00313	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00319	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00321	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00326	6b c8 00	 imul	 ecx, eax, 0
  00329	3b 91 08 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[ecx+8]
  0032f	7d 07		 jge	 SHORT $LN27@CheckChoas

; 1562 : 			return 14;

  00331	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00336	eb 47		 jmp	 SHORT $LN1@CheckChoas
$LN27@CheckChoas:

; 1563 : 		}
; 1564 : 	}

  00338	eb 2c		 jmp	 SHORT $LN25@CheckChoas
$LN24@CheckChoas:

; 1565 : 	else {
; 1566 : 		if (gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND) {

  0033a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00341	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00347	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  0034f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00354	6b c8 00	 imul	 ecx, eax, 0
  00357	3b 91 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[ecx]
  0035d	7d 07		 jge	 SHORT $LN25@CheckChoas

; 1567 : 			return 14;

  0035f	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00364	eb 19		 jmp	 SHORT $LN1@CheckChoas
$LN25@CheckChoas:

; 1568 : 		}
; 1569 : 	}
; 1570 : 
; 1571 : 	if (bIsChaosGemExist && bIsAngelKingPaperExist && bIsBloodBoneExist) {

  00366	83 7d f4 00	 cmp	 DWORD PTR _bIsChaosGemExist$[ebp], 0
  0036a	74 11		 je	 SHORT $LN29@CheckChoas
  0036c	83 7d f0 00	 cmp	 DWORD PTR _bIsAngelKingPaperExist$[ebp], 0
  00370	74 0b		 je	 SHORT $LN29@CheckChoas
  00372	83 7d ec 00	 cmp	 DWORD PTR _bIsBloodBoneExist$[ebp], 0
  00376	74 05		 je	 SHORT $LN29@CheckChoas

; 1572 : 		//       (  )
; 1573 : 		return iAngelKingPaperLevel;	

  00378	8b 45 e0	 mov	 eax, DWORD PTR _iAngelKingPaperLevel$[ebp]
  0037b	eb 02		 jmp	 SHORT $LN1@CheckChoas
$LN29@CheckChoas:

; 1574 : 	}
; 1575 : 
; 1576 : 	return 0;			//     

  0037d	33 c0		 xor	 eax, eax
$LN1@CheckChoas:

; 1577 : }

  0037f	5f		 pop	 edi
  00380	5e		 pop	 esi
  00381	5b		 pop	 ebx
  00382	8b e5		 mov	 esp, ebp
  00384	5d		 pop	 ebp
  00385	c2 04 00	 ret	 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckChoasMixItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	83 c0 23	 add	 eax, 35			; 00000023H
  0000f	89 45 fc	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  00012	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00015	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00018	77 05		 ja	 SHORT $LN8@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  0001a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001f	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002e	83 7d f8 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00032	74 02		 je	 SHORT $LN7@Allocate_m
  00034	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00036	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0003b	33 c0		 xor	 eax, eax
  0003d	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  0003f	33 c0		 xor	 eax, eax
  00041	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00046	83 c0 23	 add	 eax, 35			; 00000023H
  00049	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0004c	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	6b c8 ff	 imul	 ecx, eax, -1
  00057	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00060	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00009	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00010	72 0e		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00012	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0001b	83 c4 04	 add	 esp, 4
  0001e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00020	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00024	74 0e		 je	 SHORT $LN3@Allocate

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002f	83 c4 04	 add	 esp, 4
  00032	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00034	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00028	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0002f	72 10		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00031	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  00034	50		 push	 eax
  00035	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0003e	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8

; 222  : }

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
$T1 = -68						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 67   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 68   :     // return smaller of _Left and _Right
; 69   :     return _Right < _Left ? _Right : _Left;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	73 08		 jae	 SHORT $LN3@min
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00018	89 45 b8	 mov	 DWORD PTR tv65[ebp], eax
  0001b	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00020	89 4d b8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00023	8b 55 b8	 mov	 edx, DWORD PTR tv65[ebp]
  00026	89 55 bc	 mov	 DWORD PTR $T1[ebp], edx
  00029	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]

; 70   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TNotice.h
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 8    : inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b) { return (a << 24) + (b << 16) + (g << 8) + (r); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  0000d	c1 e0 18	 shl	 eax, 24			; 00000018H
  00010	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  00014	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00017	03 c1		 add	 eax, ecx
  00019	0f b6 55 10	 movzx	 edx, BYTE PTR _g$[ebp]
  0001d	c1 e2 08	 shl	 edx, 8
  00020	03 c2		 add	 eax, edx
  00022	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  00026	03 c1		 add	 eax, ecx
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$ = ecx

; 1259 :     void _Release() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1256 :     _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 1073 :     const _Container_base0* _Getcont() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1074 :         return nullptr;

  0000c	33 c0		 xor	 eax, eax

; 1075 :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 1072 :     void _Adopt(const void*) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1065 :     void _Orphan_all() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -16					; size = 4
__Min_back_shift$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 c1 23	 add	 ecx, 35			; 00000023H
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00014	89 0a		 mov	 DWORD PTR [edx], ecx

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00016	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 4d fc	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001e	b8 04 00 00 00	 mov	 eax, 4
  00023	6b c8 ff	 imul	 ecx, eax, -1
  00026	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00029	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002c	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002f	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00036	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  0003e	89 4d f0	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00041	83 7d f0 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00045	72 08		 jb	 SHORT $LN7@Adjust_man
  00047	83 7d f0 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  0004b	77 02		 ja	 SHORT $LN7@Adjust_man
  0004d	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00054	33 c0		 xor	 eax, eax
  00056	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00058	33 c0		 xor	 eax, eax
  0005a	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  00062	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 76   :     __declspec(allocator) static void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 77   :         return ::operator new(_Bytes);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00012	83 c4 04	 add	 esp, 4

; 78   :     }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 554  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 555  :         return INT_MAX;

  00009	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 556  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -76						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 321  :     _THROW(bad_array_new_length{});

  00009	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  00011	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00016	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :         : bad_alloc("bad array new length")

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :         : exception(_Message, 1)

  0000c	6a 01		 push	 1
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	74 0b		 je	 SHORT $LN3@what
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 b8	 mov	 DWORD PTR tv69[ebp], edx
  0001e	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  00020	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00027	8b 45 b8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ___std_exception_destroy
  00021	83 c4 04	 add	 esp, 4

; 91   :     }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c0 04	 add	 eax, 4
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0002c	83 c1 04	 add	 ecx, 4
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ___std_exception_copy
  00035	83 c4 08	 add	 esp, 8

; 74   :     }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00028	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 68   :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 535  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 536  :             return _time64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __time64
  00012	83 c4 04	 add	 esp, 4

; 537  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 509  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 510  :             #pragma warning(push)
; 511  :             #pragma warning(disable: 4996)
; 512  :             return _localtime64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __localtime64
  00012	83 c4 04	 add	 esp, 4

; 513  :             #pragma warning(pop)
; 514  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 168  :         (void)_Size;
; 169  :         return _Where;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\BloodCastle.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
