; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ghWnd@@3PAUHWND__@@A				; ghWnd
PUBLIC	?gCurPaintMapNumber@@3HA			; gCurPaintMapNumber
PUBLIC	?gCurPaintType@@3HA				; gCurPaintType
PUBLIC	?gServerReady@@3HA				; gServerReady
PUBLIC	?hInst@@3PAUHINSTANCE__@@A			; hInst
PUBLIC	?szTitle@@3PADA					; szTitle
PUBLIC	?szWindowClass@@3PADA				; szWindowClass
PUBLIC	?gCurPaintPlayer@@3HA				; gCurPaintPlayer
PUBLIC	?gCloseMsgTime@@3HA				; gCloseMsgTime
PUBLIC	?gCloseMsg@@3HA					; gCloseMsg
PUBLIC	?JoinServerIp@@3PADA				; JoinServerIp
PUBLIC	?DataServerIp@@3PADA				; DataServerIp
PUBLIC	?DataServerIp2@@3PADA				; DataServerIp2
PUBLIC	?ExDbIp@@3PADA					; ExDbIp
_BSS	SEGMENT
?ghWnd@@3PAUHWND__@@A DD 01H DUP (?)			; ghWnd
?gCurPaintMapNumber@@3HA DD 01H DUP (?)			; gCurPaintMapNumber
?gCurPaintType@@3HA DD 01H DUP (?)			; gCurPaintType
?gServerReady@@3HA DD 01H DUP (?)			; gServerReady
?hInst@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; hInst
?szTitle@@3PADA DB 064H DUP (?)				; szTitle
?szWindowClass@@3PADA DB 064H DUP (?)			; szWindowClass
?gCurPaintPlayer@@3HA DD 01H DUP (?)			; gCurPaintPlayer
?gCloseMsgTime@@3HA DD 01H DUP (?)			; gCloseMsgTime
?gCloseMsg@@3HA DD 01H DUP (?)				; gCloseMsg
?JoinServerIp@@3PADA DB 0100H DUP (?)			; JoinServerIp
?DataServerIp@@3PADA DB 0100H DUP (?)			; DataServerIp
?DataServerIp2@@3PADA DB 0100H DUP (?)			; DataServerIp2
?ExDbIp@@3PADA DB 0100H DUP (?)				; ExDbIp
_BSS	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	_WinMain@16
PUBLIC	___local_stdio_scanf_options
PUBLIC	__vsscanf_l
PUBLIC	_sscanf
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?Size@CTerrainManager@@QAE?BHXZ			; CTerrainManager::Size
PUBLIC	??0_CDBCon@@QAE@XZ				; _CDBCon::_CDBCon
PUBLIC	??0CSettings@@QAE@XZ				; CSettings::CSettings
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	?GetState@CDragonEvent@@QAEEXZ			; CDragonEvent::GetState
PUBLIC	?MyRegisterClass@@YAGPAUHINSTANCE__@@@Z		; MyRegisterClass
PUBLIC	?InitInstance@@YAHPAUHINSTANCE__@@H@Z		; InitInstance
PUBLIC	?WndProc@@YGJPAUHWND__@@IIJ@Z			; WndProc
PUBLIC	?About@@YGJPAUHWND__@@IIJ@Z			; About
PUBLIC	?GameServerStart@@YAHXZ				; GameServerStart
PUBLIC	?AllServerStart@@YAHXZ				; AllServerStart
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	?g_MonsterHerdTest@@3VCRingMonsterHerd@@A	; g_MonsterHerdTest
PUBLIC	?g_RingAttackEvent@@3VCRingAttackEvent@@A	; g_RingAttackEvent
PUBLIC	?gWhatsUpDummyServer@@3VCWhatsUpDummyServer@@A	; gWhatsUpDummyServer
PUBLIC	??_C@_0BL@IOPIBMID@?$CFs?5?$CFd?5?$CFs?5?$CFd?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_0BL@IBBPGHEK@Ranking?5Server?$LP?$KB?5?A?$KC?$LM?S?5?$LO?H?$LF?J@ ; `string'
PUBLIC	??_C@_0BO@IPBDMNKJ@Event?5Chip?5Server?$LP?$KB?5?A?$KC?$LM?S?5?$LO?H?$LF?J@ ; `string'
PUBLIC	??_C@_0BA@LAAHBEDI@closeplayer?4txt@		; `string'
PUBLIC	??_C@_0L@DPAHEMHE@Iplist?4dat@			; `string'
PUBLIC	??_C@_0BK@PPGGKBGC@?4?4?2data?2BalanceSystem?4ini@ ; `string'
PUBLIC	??_C@_0BG@PNKLNBEB@?4?4?2data?2DropTable?4cfg@	; `string'
PUBLIC	??_C@_05LGELBCGM@Close@				; `string'
PUBLIC	??_C@_0BC@EBEJPBOM@GameServer?5close?$DP@	; `string'
PUBLIC	??_C@_06MMLDKFPE@?E?W?$LN?$LK?F?$KO@		; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	_atexit:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__LoadStringA@16:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassExA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__DialogBoxParamA@20:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__SetTimer@16:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__LoadAcceleratorsA@8:PROC
EXTRN	__imp__TranslateAcceleratorA@12:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__FillRect@12:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__InitCommonControls@0:PROC
EXTRN	___stdio_common_vsscanf:PROC
EXTRN	_srand:PROC
EXTRN	__time64:PROC
EXTRN	?LogDateChange@@YAHXZ:PROC			; LogDateChange
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?GiocpInit@@YAXXZ:PROC				; GiocpInit
EXTRN	?GiocpDelete@@YAXXZ:PROC			; GiocpDelete
EXTRN	?CreateGIocp@@YAHH@Z:PROC			; CreateGIocp
EXTRN	?Run@CEngagePVP@@QAEXXZ:PROC			; CEngagePVP::Run
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjViewportListCreate@@YAXF@Z:PROC		; gObjViewportListCreate
EXTRN	?gObjViewportListDestroy@@YAXF@Z:PROC		; gObjViewportListDestroy
EXTRN	?gObjViewportListProtocol@@YAXF@Z:PROC		; gObjViewportListProtocol
EXTRN	?gObjSetState@@YAXXZ:PROC			; gObjSetState
EXTRN	?gObjSecondProc@@YAXXZ:PROC			; gObjSecondProc
EXTRN	?PShop_ViewportListRegenarate@@YAXF@Z:PROC	; PShop_ViewportListRegenarate
EXTRN	?gObjStateSetCreate@@YAXH@Z:PROC		; gObjStateSetCreate
EXTRN	?gObjViewportPaint@@YAXPAUHWND__@@F@Z:PROC	; gObjViewportPaint
EXTRN	?MonsterAndMsgProc@@YAXXZ:PROC			; MonsterAndMsgProc
EXTRN	?MoveMonsterProc@@YAXXZ:PROC			; MoveMonsterProc
EXTRN	?gObjAllDisconnect@@YAXXZ:PROC			; gObjAllDisconnect
EXTRN	?gObjAllLogOut@@YAXXZ:PROC			; gObjAllLogOut
EXTRN	?gObjCheckAllUserDuelStop@@YAXXZ:PROC		; gObjCheckAllUserDuelStop
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?LoadConfig@cDropSystem@@QAEXPBD@Z:PROC		; cDropSystem::LoadConfig
EXTRN	?Load@cBalanceSystem@@QAEXPAD@Z:PROC		; cBalanceSystem::Load
EXTRN	?_loading@CDynamicExperience@@QAEXXZ:PROC	; CDynamicExperience::_loading
EXTRN	?Loading@CSettings@@QAE_NXZ:PROC		; CSettings::Loading
EXTRN	?WeatherVariationProcess@MapClass@@QAEXXZ:PROC	; MapClass::WeatherVariationProcess
EXTRN	?ShopDataLoad@@YAHXZ:PROC			; ShopDataLoad
EXTRN	?GameMainInit@@YAXPAUHWND__@@@Z:PROC		; GameMainInit
EXTRN	?GameMainFree@@YAXXZ:PROC			; GameMainFree
EXTRN	?GameMainServerCreate@@YAHKK@Z:PROC		; GameMainServerCreate
EXTRN	?GMJoinServerConnect@@YAHPADK@Z:PROC		; GMJoinServerConnect
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?GMEventChipServerConnect@@YAHPADK@Z:PROC	; GMEventChipServerConnect
EXTRN	?GMServerMsgProc@@YAXIJ@Z:PROC			; GMServerMsgProc
EXTRN	?GMClientMsgProc@@YAXIJ@Z:PROC			; GMClientMsgProc
EXTRN	?GMJoinClientMsgProc@@YAXIJ@Z:PROC		; GMJoinClientMsgProc
EXTRN	?ExDataClientMsgProc@@YAXIJ@Z:PROC		; ExDataClientMsgProc
EXTRN	?GMRankingClientMsgProc@@YAXIJ@Z:PROC		; GMRankingClientMsgProc
EXTRN	?GMEventChipClientMsgProc@@YAXIJ@Z:PROC		; GMEventChipClientMsgProc
EXTRN	?GameMonsterAllCloseAndReLoad@@YAXXZ:PROC	; GameMonsterAllCloseAndReLoad
EXTRN	?GameServerInfoSend@@YAXXZ:PROC			; GameServerInfoSend
EXTRN	?ReadCommonServerInfo@@YAXXZ:PROC		; ReadCommonServerInfo
EXTRN	?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z:PROC	; ReadGameEtcInfo
EXTRN	?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z:PROC	; ReadEventInfo
EXTRN	?gSetDate@@YAXXZ:PROC				; gSetDate
EXTRN	??0Ccloseplayer@@QAE@XZ:PROC			; Ccloseplayer::Ccloseplayer
EXTRN	??1Ccloseplayer@@UAE@XZ:PROC			; Ccloseplayer::~Ccloseplayer
EXTRN	?Load@Ccloseplayer@@QAEXPAD@Z:PROC		; Ccloseplayer::Load
EXTRN	?TimeCheckCashDelete@CWhisperCash@@QAEXXZ:PROC	; CWhisperCash::TimeCheckCashDelete
EXTRN	?Load@CAcceptIp@@QAEXPAD@Z:PROC			; CAcceptIp::Load
EXTRN	?Start@CDragonEvent@@QAEXXZ:PROC		; CDragonEvent::Start
EXTRN	?End@CDragonEvent@@QAEXXZ:PROC			; CDragonEvent::End
EXTRN	?Run@CDragonEvent@@QAEXXZ:PROC			; CDragonEvent::Run
EXTRN	?Load@CBalancer@@QAE_NXZ:PROC			; CBalancer::Load
EXTRN	?MainFunction@cOffExp@@QAEXXZ:PROC		; cOffExp::MainFunction
EXTRN	?ReadyLicense@@YAXXZ:PROC			; ReadyLicense
EXTRN	?Run@CBloodCastle@@QAEXXZ:PROC			; CBloodCastle::Run
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?Run@CChaosCastle@@QAEXXZ:PROC			; CChaosCastle::Run
EXTRN	??0CWhatsUpDummyServer@@QAE@XZ:PROC		; CWhatsUpDummyServer::CWhatsUpDummyServer
EXTRN	??1CWhatsUpDummyServer@@QAE@XZ:PROC		; CWhatsUpDummyServer::~CWhatsUpDummyServer
EXTRN	?Start@CWhatsUpDummyServer@@QAEHPAUHWND__@@G@Z:PROC ; CWhatsUpDummyServer::Start
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?Connect@DBSockMng@@QAEXXZ:PROC			; DBSockMng::Connect
EXTRN	?MsgProc@DBSockMng@@QAEHHIJ@Z:PROC		; DBSockMng::MsgProc
EXTRN	?Run@CAttackEvent@@QAEXXZ:PROC			; CAttackEvent::Run
EXTRN	?DGGuildListRequest@@YAXXZ:PROC			; DGGuildListRequest
EXTRN	??0CRingMonsterHerd@@QAE@XZ:PROC		; CRingMonsterHerd::CRingMonsterHerd
EXTRN	??1CRingMonsterHerd@@UAE@XZ:PROC		; CRingMonsterHerd::~CRingMonsterHerd
EXTRN	??0CRingAttackEvent@@QAE@XZ:PROC		; CRingAttackEvent::CRingAttackEvent
EXTRN	??1CRingAttackEvent@@UAE@XZ:PROC		; CRingAttackEvent::~CRingAttackEvent
EXTRN	?Run@CRingAttackEvent@@QAEXXZ:PROC		; CRingAttackEvent::Run
EXTRN	?Run@CEledoradoEvent@@QAEXXZ:PROC		; CEledoradoEvent::Run
EXTRN	?Run@CEventManagement@@QAEXXZ:PROC		; CEventManagement::Run
EXTRN	?Run@TServerInfoDisplayer@@QAEXPAUHWND__@@@Z:PROC ; TServerInfoDisplayer::Run
EXTRN	?Begin@CMiniDump@@SAHXZ:PROC			; CMiniDump::Begin
EXTRN	?End@CMiniDump@@SAHXZ:PROC			; CMiniDump::End
EXTRN	?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z:PROC ; CGPCharacterMapJoinRequest
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogTextPaint@@3P6AXPAUHWND__@@@ZA:DWORD	; LogTextPaint
EXTRN	?g_PvpEvent@@3VCEngagePVP@@A:BYTE		; g_PvpEvent
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gServerMaxUser@@3HA:DWORD			; gServerMaxUser
EXTRN	?cexDrop@@3VcDropSystem@@A:BYTE			; cexDrop
EXTRN	?g_TerrainManager@@3VCTerrainManager@@A:BYTE	; g_TerrainManager
EXTRN	?gBalanceSystem@@3VcBalanceSystem@@A:BYTE	; gBalanceSystem
EXTRN	?_dynamic_experience@@3VCDynamicExperience@@A:BYTE ; _dynamic_experience
EXTRN	?gSettings@@3PAVCSettings@@A:DWORD		; gSettings
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?JoinServerPort@@3HA:DWORD			; JoinServerPort
EXTRN	?GameServerPort@@3HA:DWORD			; GameServerPort
EXTRN	?DataServerPort@@3HA:DWORD			; DataServerPort
EXTRN	?JoinServerConnected@@3HA:DWORD			; JoinServerConnected
EXTRN	?DataServerPort2@@3HA:DWORD			; DataServerPort2
EXTRN	?ExDbPort@@3HA:DWORD				; ExDbPort
EXTRN	?DevilSquareEventConnect@@3HA:DWORD		; DevilSquareEventConnect
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
EXTRN	?EventChipServerConnect@@3HA:DWORD		; EventChipServerConnect
EXTRN	?IsEventChipServerConnected@@3HA:DWORD		; IsEventChipServerConnected
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?gLanguage@@3HA:DWORD				; gLanguage
EXTRN	?gXMasEvent@@3HA:DWORD				; gXMasEvent
EXTRN	?gFireCrackerEvent@@3HA:DWORD			; gFireCrackerEvent
EXTRN	?gDevilSquareEventServerIp@@3PADA:BYTE		; gDevilSquareEventServerIp
EXTRN	?gEventChipServerIp@@3PADA:BYTE			; gEventChipServerIp
EXTRN	?gDoPShopOpen@@3HA:DWORD			; gDoPShopOpen
EXTRN	?acceptIP@@3VCAcceptIp@@A:BYTE			; acceptIP
EXTRN	?Balancer@@3VCBalancer@@A:BYTE			; Balancer
EXTRN	?OffExp@@3VcOffExp@@A:BYTE			; OffExp
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?gEledoradoEvent@@3VCEledoradoEvent@@A:BYTE	; gEledoradoEvent
EXTRN	?g_EventManager@@3VCEventManagement@@A:BYTE	; g_EventManager
EXTRN	?g_ServerInfoDisplayer@@3VTServerInfoDisplayer@@A:BYTE ; g_ServerInfoDisplayer
EXTRN	?WhisperCash@@3VCWhisperCash@@A:BYTE		; WhisperCash
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?wsGServer@@3VCwsGameServer@@A:BYTE		; wsGServer
EXTRN	?DragonEvent@@3PAVCDragonEvent@@A:DWORD		; DragonEvent
EXTRN	?AttackEvent@@3PAVCAttackEvent@@A:DWORD		; AttackEvent
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
?g_MonsterHerdTest@@3VCRingMonsterHerd@@A DB 044H DUP (?) ; g_MonsterHerdTest
?g_RingAttackEvent@@3VCRingAttackEvent@@A DB 0138H DUP (?) ; g_RingAttackEvent
?gWhatsUpDummyServer@@3VCWhatsUpDummyServer@@A DB 0cH DUP (?) ; gWhatsUpDummyServer
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT ??_C@_06MMLDKFPE@?E?W?$LN?$LK?F?$KO@
CONST	SEGMENT
??_C@_06MMLDKFPE@?E?W?$LN?$LK?F?$KO@ DB 0c5H, 0d7H, 0bdH, 0baH, 0c6H, 0aeH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EBEJPBOM@GameServer?5close?$DP@
CONST	SEGMENT
??_C@_0BC@EBEJPBOM@GameServer?5close?$DP@ DB 'GameServer close?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LGELBCGM@Close@
CONST	SEGMENT
??_C@_05LGELBCGM@Close@ DB 'Close', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PNKLNBEB@?4?4?2data?2DropTable?4cfg@
CONST	SEGMENT
??_C@_0BG@PNKLNBEB@?4?4?2data?2DropTable?4cfg@ DB '..\data\DropTable.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PPGGKBGC@?4?4?2data?2BalanceSystem?4ini@
CONST	SEGMENT
??_C@_0BK@PPGGKBGC@?4?4?2data?2BalanceSystem?4ini@ DB '..\data\BalanceSys'
	DB	'tem.ini', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPAHEMHE@Iplist?4dat@
CONST	SEGMENT
??_C@_0L@DPAHEMHE@Iplist?4dat@ DB 'Iplist.dat', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LAAHBEDI@closeplayer?4txt@
CONST	SEGMENT
??_C@_0BA@LAAHBEDI@closeplayer?4txt@ DB 'closeplayer.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IPBDMNKJ@Event?5Chip?5Server?$LP?$KB?5?A?$KC?$LM?S?5?$LO?H?$LF?J@
CONST	SEGMENT
??_C@_0BO@IPBDMNKJ@Event?5Chip?5Server?$LP?$KB?5?A?$KC?$LM?S?5?$LO?H?$LF?J@ DB 'E'
	DB	'vent Chip Server', 0bfH, 0a1H, ' ', 0c1H, 0a2H, 0bcH, 0d3H, ' '
	DB	0beH, 0c8H, 0b5H, 0caH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IBBPGHEK@Ranking?5Server?$LP?$KB?5?A?$KC?$LM?S?5?$LO?H?$LF?J@
CONST	SEGMENT
??_C@_0BL@IBBPGHEK@Ranking?5Server?$LP?$KB?5?A?$KC?$LM?S?5?$LO?H?$LF?J@ DB 'R'
	DB	'anking Server', 0bfH, 0a1H, ' ', 0c1H, 0a2H, 0bcH, 0d3H, ' ', 0beH
	DB	0c8H, 0b5H, 0caH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IOPIBMID@?$CFs?5?$CFd?5?$CFs?5?$CFd?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BL@IOPIBMID@?$CFs?5?$CFd?5?$CFs?5?$CFd?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd@ DB '%'
	DB	's %d %s %d %d %s %d %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?WndProc@@YGJPAUHWND__@@IIJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WndProc@@YGJPAUHWND__@@IIJ@Z$0
__ehfuncinfo$?WndProc@@YGJPAUHWND__@@IIJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?WndProc@@YGJPAUHWND__@@IIJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_MonsterHerdTest$initializer$@@3P6AXXZA DD FLAT:??__Eg_MonsterHerdTest@@YAXXZ ; g_MonsterHerdTest$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?g_RingAttackEvent$initializer$@@3P6AXXZA DD FLAT:??__Eg_RingAttackEvent@@YAXXZ ; g_RingAttackEvent$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gWhatsUpDummyServer$initializer$@@3P6AXXZA DD FLAT:??__EgWhatsUpDummyServer@@YAXXZ ; gWhatsUpDummyServer$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ?AllServerStart@@YAHXZ
_TEXT	SEGMENT
?AllServerStart@@YAHXZ PROC				; AllServerStart, COMDAT

; 474  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 475  : 	if( !JoinServerConnected )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?JoinServerConnected@@3HA, 0 ; JoinServerConnected
  00010	75 36		 jne	 SHORT $LN2@AllServerS

; 476  : 	{
; 477  : 		if( GMJoinServerConnect(JoinServerIp, WM_ASS_JOINCLIMSG) == FALSE )

  00012	68 03 04 00 00	 push	 1027			; 00000403H
  00017	68 00 00 00 00	 push	 OFFSET ?JoinServerIp@@3PADA ; JoinServerIp
  0001c	e8 00 00 00 00	 call	 ?GMJoinServerConnect@@YAHPADK@Z ; GMJoinServerConnect
  00021	83 c4 08	 add	 esp, 8
  00024	85 c0		 test	 eax, eax
  00026	75 20		 jne	 SHORT $LN2@AllServerS

; 478  : 		{
; 479  : 			MsgBox(lMsg.Get(400));

  00028	68 90 01 00 00	 push	 400			; 00000190H
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0003e	83 c4 04	 add	 esp, 4

; 480  : 			return FALSE;

  00041	33 c0		 xor	 eax, eax
  00043	e9 95 00 00 00	 jmp	 $LN1@AllServerS
$LN2@AllServerS:

; 481  : 		}
; 482  : 	}
; 483  : 
; 484  : 	if( !DevilSquareEventConnect && !IsDevilSquareEventConnected )

  00048	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DevilSquareEventConnect@@3HA, 0 ; DevilSquareEventConnect
  0004f	75 3a		 jne	 SHORT $LN4@AllServerS
  00051	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00058	75 31		 jne	 SHORT $LN4@AllServerS

; 485  : 	{	// 랭킹서버 연결
; 486  : 		if( GMRankingServerConnect(gDevilSquareEventServerIp, WM_ASS_RANKINGCLIMSG) == FALSE )

  0005a	68 0c 04 00 00	 push	 1036			; 0000040cH
  0005f	68 00 00 00 00	 push	 OFFSET ?gDevilSquareEventServerIp@@3PADA ; gDevilSquareEventServerIp
  00064	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  00069	83 c4 08	 add	 esp, 8
  0006c	85 c0		 test	 eax, eax
  0006e	75 11		 jne	 SHORT $LN5@AllServerS

; 487  : 		{
; 488  : 			MsgBox("Ranking Server에 접속 안됨");

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IBBPGHEK@Ranking?5Server?$LP?$KB?5?A?$KC?$LM?S?5?$LO?H?$LF?J@
  00075	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0007a	83 c4 04	 add	 esp, 4

; 489  : 			return FALSE;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 5c		 jmp	 SHORT $LN1@AllServerS
$LN5@AllServerS:

; 490  : 		}		
; 491  : 		IsDevilSquareEventConnected = 1;

  00081	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN4@AllServerS:

; 492  : 	}
; 493  : 	
; 494  : 	if( EventChipServerConnect && !IsEventChipServerConnected )

  0008b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?EventChipServerConnect@@3HA, 0 ; EventChipServerConnect
  00092	74 3a		 je	 SHORT $LN6@AllServerS
  00094	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsEventChipServerConnected@@3HA, 0 ; IsEventChipServerConnected
  0009b	75 31		 jne	 SHORT $LN6@AllServerS

; 495  : 	{	// 레나 스톤 이벤트서버 연결
; 496  : 		if( GMEventChipServerConnect(gEventChipServerIp, WM_ASS_EVENTCHIPCLIMSG) == FALSE )

  0009d	68 0d 04 00 00	 push	 1037			; 0000040dH
  000a2	68 00 00 00 00	 push	 OFFSET ?gEventChipServerIp@@3PADA ; gEventChipServerIp
  000a7	e8 00 00 00 00	 call	 ?GMEventChipServerConnect@@YAHPADK@Z ; GMEventChipServerConnect
  000ac	83 c4 08	 add	 esp, 8
  000af	85 c0		 test	 eax, eax
  000b1	75 11		 jne	 SHORT $LN7@AllServerS

; 497  : 		{
; 498  : 			MsgBox("Event Chip Server에 접속 안됨");

  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IPBDMNKJ@Event?5Chip?5Server?$LP?$KB?5?A?$KC?$LM?S?5?$LO?H?$LF?J@
  000b8	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000bd	83 c4 04	 add	 esp, 4

; 499  : 			return FALSE;

  000c0	33 c0		 xor	 eax, eax
  000c2	eb 19		 jmp	 SHORT $LN1@AllServerS
$LN7@AllServerS:

; 500  : 		}		
; 501  : 		IsEventChipServerConnected = 1;

  000c4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsEventChipServerConnected@@3HA, 1 ; IsEventChipServerConnected
$LN6@AllServerS:

; 502  : 	}
; 503  : 
; 504  : 	/*if( !DataServerConnected )
; 505  : 	{
; 506  : 		if( GMDataServerConnect(DataServerIp, WM_ASS_DATACLIMSG)== FALSE )
; 507  : 		{
; 508  : 			MsgBox(lMsg.Get(399));
; 509  : 			return FALSE;
; 510  : 		}
; 511  : 
; 512  : 		
; 513  : 	}
; 514  : 	*/
; 515  : 	cDBSMng.Connect();

  000ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000d3	e8 00 00 00 00	 call	 ?Connect@DBSockMng@@QAEXXZ ; DBSockMng::Connect

; 516  : 
; 517  : #ifdef GAMESERVER_INFO_TCP_20031203
; 518  : /*	if( !IsConnectServerConnected )
; 519  : 	{	// 접속서버에 연결
; 520  : 		if( ConnectServerConnect(connectserverip, WM_ASS_CSERVERMSG) == FALSE )
; 521  : 		{
; 522  : 			MsgBox("Connect Server에 접속 안됨");
; 523  : 			return FALSE;
; 524  : 		}		
; 525  : 		IsConnectServerConnected = 1;
; 526  : 	}
; 527  : */
; 528  : #endif
; 529  : 
; 530  : 	return TRUE;

  000d8	b8 01 00 00 00	 mov	 eax, 1
$LN1@AllServerS:

; 531  : }

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
?AllServerStart@@YAHXZ ENDP				; AllServerStart
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ?GameServerStart@@YAHXZ
_TEXT	SEGMENT
?GameServerStart@@YAHXZ PROC				; GameServerStart, COMDAT

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 536  : 	if( GameMainServerCreate(WM_ASS_SERVERMSG, WM_ASS_CLIENTMSG) == FALSE )

  00009	68 02 04 00 00	 push	 1026			; 00000402H
  0000e	68 01 04 00 00	 push	 1025			; 00000401H
  00013	e8 00 00 00 00	 call	 ?GameMainServerCreate@@YAHKK@Z ; GameMainServerCreate
  00018	83 c4 08	 add	 esp, 8
  0001b	85 c0		 test	 eax, eax
  0001d	75 20		 jne	 SHORT $LN2@GameServer

; 537  : 	{
; 538  : 		MsgBox(lMsg.Get(398));

  0001f	68 8e 01 00 00	 push	 398			; 0000018eH
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00035	83 c4 04	 add	 esp, 4

; 539  : 		return FALSE;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 17 01 00 00	 jmp	 $LN1@GameServer
$LN2@GameServer:

; 540  : 	}
; 541  : 
; 542  : 	CreateGIocp(GameServerPort);

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GameServerPort@@3HA ; GameServerPort
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?CreateGIocp@@YAHH@Z	; CreateGIocp
  0004a	83 c4 04	 add	 esp, 4

; 543  : 
; 544  : 	#if LICENCIA == 1
; 545  : 	ReadyLicense();

  0004d	e8 00 00 00 00	 call	 ?ReadyLicense@@YAXXZ	; ReadyLicense

; 546  :     #endif
; 547  : 
; 548  : 	SetTimer(ghWnd, 100, 2000, NULL);

  00052	6a 00		 push	 0
  00054	68 d0 07 00 00	 push	 2000			; 000007d0H
  00059	6a 64		 push	 100			; 00000064H
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00060	50		 push	 eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 549  : 	SetTimer(ghWnd, 101, 1000, NULL);

  00067	6a 00		 push	 0
  00069	68 e8 03 00 00	 push	 1000			; 000003e8H
  0006e	6a 65		 push	 101			; 00000065H
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 550  : 	//SetTimer(ghWnd, 100, 500, NULL);
; 551  : 	SetTimer(ghWnd, MTIME_HOUR, 1000*60, NULL);

  0007c	6a 00		 push	 0
  0007e	68 60 ea 00 00	 push	 60000			; 0000ea60H
  00083	68 e9 03 00 00	 push	 1001			; 000003e9H
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0008d	50		 push	 eax
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 552  : 	SetTimer(ghWnd, MTIME_DAY, (1000*60), NULL);

  00094	6a 00		 push	 0
  00096	68 60 ea 00 00	 push	 60000			; 0000ea60H
  0009b	68 eb 03 00 00	 push	 1003			; 000003ebH
  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000a5	50		 push	 eax
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 553  : 	SetTimer(ghWnd, MTIME_MIN, 1000*10, NULL);

  000ac	6a 00		 push	 0
  000ae	68 10 27 00 00	 push	 10000			; 00002710H
  000b3	68 ef 03 00 00	 push	 1007			; 000003efH
  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000bd	50		 push	 eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 554  : 	//SetTimer(ghWnd, MTIME_DAY, 1000, NULL);
; 555  : 	//SetTimer(ghWnd, 1000, 1000, NULL);
; 556  : 	SetTimer(ghWnd, 1000, 1000, NULL);

  000c4	6a 00		 push	 0
  000c6	68 e8 03 00 00	 push	 1000			; 000003e8H
  000cb	68 e8 03 00 00	 push	 1000			; 000003e8H
  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000d5	50		 push	 eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 557  : 	SetTimer(ghWnd, MTIME_SECOND, 1000, NULL);

  000dc	6a 00		 push	 0
  000de	68 e8 03 00 00	 push	 1000			; 000003e8H
  000e3	68 ea 03 00 00	 push	 1002			; 000003eaH
  000e8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000ed	50		 push	 eax
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 558  : 	SetTimer(ghWnd, MTIME_500, 500 , NULL);

  000f4	6a 00		 push	 0
  000f6	68 f4 01 00 00	 push	 500			; 000001f4H
  000fb	68 ee 03 00 00	 push	 1006			; 000003eeH
  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00105	50		 push	 eax
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 559  : 
; 560  : #ifdef FOR_BLOODCASTLE
; 561  : 	SetTimer(ghWnd, MTIME_300, 300 , NULL);

  0010c	6a 00		 push	 0
  0010e	68 2c 01 00 00	 push	 300			; 0000012cH
  00113	68 ed 03 00 00	 push	 1005			; 000003edH
  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0011d	50		 push	 eax
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 562  : 	SetTimer(ghWnd, MTIME_100, 100 , NULL);

  00124	6a 00		 push	 0
  00126	6a 64		 push	 100			; 00000064H
  00128	68 ec 03 00 00	 push	 1004			; 000003ecH
  0012d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00132	50		 push	 eax
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 563  : #else	
; 564  : 	SetTimer(ghWnd, MTIME_100, 300 , NULL);
; 565  : #endif
; 566  : 
; 567  : #ifdef ADD_NEW_MONSTER_SYSTEM_02_20050725
; 568  : 	SetTimer(ghWnd, TIMER_MONSTER_MOVE, TIMER_MONSTER_MOVE_CYCLE,	NULL);
; 569  : 	SetTimer(ghWnd, TIMER_MONSTER_AI,	TIMER_MONSTER_AI_CYCLE,		NULL);
; 570  : #endif
; 571  : 
; 572  : #if (DBGUILDLOAD==1)
; 573  : 	SetTimer(ghWnd, MTIME_DBSGUILDLISTREQUEST, 1000, NULL);

  00139	6a 00		 push	 0
  0013b	68 e8 03 00 00	 push	 1000			; 000003e8H
  00140	68 f0 03 00 00	 push	 1008			; 000003f0H
  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0014a	50		 push	 eax
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16

; 574  : #else
; 575  : 	MsgBox("Guild List not load");
; 576  : 	GameServerInfoSendStart();
; 577  : #endif
; 578  : 	return TRUE;

  00151	b8 01 00 00 00	 mov	 eax, 1
$LN1@GameServer:

; 579  : }

  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
?GameServerStart@@YAHXZ ENDP				; GameServerStart
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ?About@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv64 = -68						; size = 4
_hDlg$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?About@@YGJPAUHWND__@@IIJ@Z PROC			; About, COMDAT

; 1683 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1684 : 	switch (message)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  0000c	89 45 bc	 mov	 DWORD PTR tv64[ebp], eax
  0000f	81 7d bc 10 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 272 ; 00000110H
  00016	74 0b		 je	 SHORT $LN4@About
  00018	81 7d bc 11 01
	00 00		 cmp	 DWORD PTR tv64[ebp], 273 ; 00000111H
  0001f	74 09		 je	 SHORT $LN5@About
  00021	eb 44		 jmp	 SHORT $LN2@About
$LN4@About:

; 1685 : 	{
; 1686 : 		case WM_INITDIALOG:
; 1687 : 				return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	eb 3f		 jmp	 SHORT $LN1@About
$LN5@About:

; 1688 : 
; 1689 : 		case WM_COMMAND:
; 1690 : 			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 

  0002a	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0002d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00032	0f b7 c8	 movzx	 ecx, ax
  00035	83 f9 01	 cmp	 ecx, 1
  00038	74 10		 je	 SHORT $LN7@About
  0003a	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0003d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00042	0f b7 c8	 movzx	 ecx, ax
  00045	83 f9 02	 cmp	 ecx, 2
  00048	75 1d		 jne	 SHORT $LN2@About
$LN7@About:

; 1691 : 			{
; 1692 : 				EndDialog(hDlg, LOWORD(wParam));

  0004a	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0004d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00052	0f b7 c8	 movzx	 ecx, ax
  00055	51		 push	 ecx
  00056	8b 55 08	 mov	 edx, DWORD PTR _hDlg$[ebp]
  00059	52		 push	 edx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 1693 : 				return TRUE;

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	eb 02		 jmp	 SHORT $LN1@About
$LN2@About:

; 1694 : 			}
; 1695 : 			break;
; 1696 : 	}
; 1697 :     return FALSE;

  00067	33 c0		 xor	 eax, eax
$LN1@About:

; 1698 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 10 00	 ret	 16			; 00000010H
?About@@YGJPAUHWND__@@IIJ@Z ENDP			; About
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ?WndProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv362 = -408						; size = 4
tv221 = -408						; size = 4
tv145 = -408						; size = 4
tv72 = -408						; size = 4
tv64 = -408						; size = 4
$T2 = -404						; size = 4
_Msg$3 = -336						; size = 14
_szTemp$4 = -320					; size = 256
_n$5 = -64						; size = 4
_n$6 = -60						; size = 4
_hdc$7 = -56						; size = 4
_rect$8 = -52						; size = 16
_lp$9 = -36						; size = 4
_wp$10 = -32						; size = 4
_cp$11 = -28						; size = 4
_wmEvent$ = -24						; size = 4
_wmId$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WndProc@@YGJPAUHWND__@@IIJ@Z PROC			; WndProc, COMDAT

; 682  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?WndProc@@YGJPAUHWND__@@IIJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 683  : 	int wmId, wmEvent;
; 684  : 	//PAINTSTRUCT ps;
; 685  : 	//HDC hdc;
; 686  : 	//TCHAR szHello[MAX_LOADSTRING];
; 687  : 	//LoadString(hInst, IDS_HELLO, szHello, MAX_LOADSTRING);
; 688  : 
; 689  : 	switch (message) 

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00031	89 85 68 fe ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00037	81 bd 68 fe ff
	ff 01 04 00 00	 cmp	 DWORD PTR tv64[ebp], 1025 ; 00000401H
  00041	77 75		 ja	 SHORT $LN143@WndProc
  00043	81 bd 68 fe ff
	ff 01 04 00 00	 cmp	 DWORD PTR tv64[ebp], 1025 ; 00000401H
  0004d	0f 84 5e 05 00
	00		 je	 $LN87@WndProc
  00053	81 bd 68 fe ff
	ff 00 01 00 00	 cmp	 DWORD PTR tv64[ebp], 256 ; 00000100H
  0005d	77 38		 ja	 SHORT $LN144@WndProc
  0005f	81 bd 68 fe ff
	ff 00 01 00 00	 cmp	 DWORD PTR tv64[ebp], 256 ; 00000100H
  00069	0f 84 96 0a 00
	00		 je	 $LN124@WndProc
  0006f	83 bd 68 fe ff
	ff 01		 cmp	 DWORD PTR tv64[ebp], 1
  00076	74 6c		 je	 SHORT $LN31@WndProc
  00078	83 bd 68 fe ff
	ff 02		 cmp	 DWORD PTR tv64[ebp], 2
  0007f	0f 84 65 0b 00
	00		 je	 $LN136@WndProc
  00085	83 bd 68 fe ff
	ff 10		 cmp	 DWORD PTR tv64[ebp], 16	; 00000010H
  0008c	0f 84 32 0a 00
	00		 je	 $LN120@WndProc
  00092	e9 67 0b 00 00	 jmp	 $LN137@WndProc
$LN144@WndProc:
  00097	81 bd 68 fe ff
	ff 11 01 00 00	 cmp	 DWORD PTR tv64[ebp], 273 ; 00000111H
  000a1	74 48		 je	 SHORT $LN32@WndProc
  000a3	81 bd 68 fe ff
	ff 13 01 00 00	 cmp	 DWORD PTR tv64[ebp], 275 ; 00000113H
  000ad	0f 84 cd 05 00
	00		 je	 $LN97@WndProc
  000b3	e9 46 0b 00 00	 jmp	 $LN137@WndProc
$LN143@WndProc:
  000b8	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  000be	81 e9 02 04 00
	00		 sub	 ecx, 1026		; 00000402H
  000c4	89 8d 68 fe ff
	ff		 mov	 DWORD PTR tv64[ebp], ecx
  000ca	83 bd 68 fe ff
	ff 0c		 cmp	 DWORD PTR tv64[ebp], 12	; 0000000cH
  000d1	0f 87 27 0b 00
	00		 ja	 $LN137@WndProc
  000d7	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  000dd	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN146@WndProc[edx*4]
$LN31@WndProc:

; 690  : 	{
; 691  : 		case WM_CREATE :
; 692  : #ifdef MU_CASTLESIEGE_LOG_20050107
; 693  : 			g_hCsLogDlgProc = CreateDialog(hInst, MAKEINTRESOURCE(IDD_CS_LOG_DLG), hWnd, CsLogDlgProc);
; 694  : #endif			
; 695  : 			return 0;

  000e4	33 c0		 xor	 eax, eax
  000e6	e9 2d 0b 00 00	 jmp	 $LN1@WndProc
$LN32@WndProc:

; 696  : 		
; 697  : 		case WM_COMMAND:
; 698  : 			wmId    = LOWORD(wParam); 

  000eb	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  000ee	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000f3	0f b7 c8	 movzx	 ecx, ax
  000f6	89 4d ec	 mov	 DWORD PTR _wmId$[ebp], ecx

; 699  : 			wmEvent = HIWORD(wParam); 

  000f9	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  000fc	c1 e8 10	 shr	 eax, 16			; 00000010H
  000ff	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00104	0f b7 c8	 movzx	 ecx, ax
  00107	89 4d e8	 mov	 DWORD PTR _wmEvent$[ebp], ecx

; 700  : 			// Parse the menu selections:
; 701  : 			switch (wmId)

  0010a	8b 45 ec	 mov	 eax, DWORD PTR _wmId$[ebp]
  0010d	89 85 68 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00113	81 bd 68 fe ff
	ff 04 80 00 00	 cmp	 DWORD PTR tv72[ebp], 32772 ; 00008004H
  0011d	7f 27		 jg	 SHORT $LN141@WndProc
  0011f	81 bd 68 fe ff
	ff 04 80 00 00	 cmp	 DWORD PTR tv72[ebp], 32772 ; 00008004H
  00129	0f 84 bb 00 00
	00		 je	 $LN38@WndProc
  0012f	83 bd 68 fe ff
	ff 68		 cmp	 DWORD PTR tv72[ebp], 104 ; 00000068H
  00136	74 3a		 je	 SHORT $LN33@WndProc
  00138	83 bd 68 fe ff
	ff 69		 cmp	 DWORD PTR tv72[ebp], 105 ; 00000069H
  0013f	74 50		 je	 SHORT $LN34@WndProc
  00141	e9 4b 04 00 00	 jmp	 $LN86@WndProc
$LN141@WndProc:
  00146	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  0014c	81 e9 05 80 00
	00		 sub	 ecx, 32773		; 00008005H
  00152	89 8d 68 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00158	83 bd 68 fe ff
	ff 38		 cmp	 DWORD PTR tv72[ebp], 56	; 00000038H
  0015f	0f 87 2c 04 00
	00		 ja	 $LN86@WndProc
  00165	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  0016b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN147@WndProc[edx*4]
$LN33@WndProc:

; 702  : 			{
; 703  : 
; 704  : #ifdef ADD_SERVER_ALERT_USING_WHATSUP_01_20050628
; 705  : 				case IDM_ALERT_ALL_CLEAR:
; 706  : 					{
; 707  : 						g_ServerAlertManager.ClearAllAlert();
; 708  : 					}
; 709  : 					break;
; 710  : #endif
; 711  : 
; 712  : 				case IDM_ABOUT:
; 713  : 				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);

  00172	6a 00		 push	 0
  00174	68 00 00 00 00	 push	 OFFSET ?About@@YGJPAUHWND__@@IIJ@Z ; About
  00179	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0017c	50		 push	 eax
  0017d	6a 67		 push	 103			; 00000067H
  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hInst@@3PAUHINSTANCE__@@A ; hInst
  00185	51		 push	 ecx
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamA@20

; 714  : 				   break;

  0018c	e9 1b 04 00 00	 jmp	 $LN4@WndProc
$LN34@WndProc:

; 715  : 				case IDM_EXIT:				   
; 716  : 				   SendMessage(hWnd, WM_CLOSE, 0,0);

  00191	6a 00		 push	 0
  00193	6a 00		 push	 0
  00195	6a 10		 push	 16			; 00000010H
  00197	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0019a	50		 push	 eax
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 717  : 				   break;

  001a1	e9 06 04 00 00	 jmp	 $LN4@WndProc
$LN35@WndProc:

; 718  : 				case ID_MENU_DISPLAYER :
; 719  : 					{
; 720  : 					Ccloseplayer	cp;

  001a6	8d 4d e4	 lea	 ecx, DWORD PTR _cp$11[ebp]
  001a9	e8 00 00 00 00	 call	 ??0Ccloseplayer@@QAE@XZ	; Ccloseplayer::Ccloseplayer
  001ae	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 721  : 					cp.Load("closeplayer.txt");

  001b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LAAHBEDI@closeplayer?4txt@
  001ba	8d 4d e4	 lea	 ecx, DWORD PTR _cp$11[ebp]
  001bd	e8 00 00 00 00	 call	 ?Load@Ccloseplayer@@QAEXPAD@Z ; Ccloseplayer::Load

; 722  : 					}

  001c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001c9	8d 4d e4	 lea	 ecx, DWORD PTR _cp$11[ebp]
  001cc	e8 00 00 00 00	 call	 ??1Ccloseplayer@@UAE@XZ	; Ccloseplayer::~Ccloseplayer

; 723  : 					break;

  001d1	e9 d6 03 00 00	 jmp	 $LN4@WndProc
$LN36@WndProc:

; 724  : 				case ID_MENU_DISCONNECT :
; 725  : 					gObjAllDisconnect();

  001d6	e8 00 00 00 00	 call	 ?gObjAllDisconnect@@YAXXZ ; gObjAllDisconnect

; 726  : 					break;

  001db	e9 cc 03 00 00	 jmp	 $LN4@WndProc
$LN37@WndProc:

; 727  : 				case ID_MENU_USERLOGOUT :
; 728  : 					gObjAllLogOut();

  001e0	e8 00 00 00 00	 call	 ?gObjAllLogOut@@YAXXZ	; gObjAllLogOut

; 729  : 					break;				

  001e5	e9 c2 03 00 00	 jmp	 $LN4@WndProc
$LN38@WndProc:

; 730  : 				case ID_LOAD_MONSTERPOS :
; 731  : 					GameMonsterAllCloseAndReLoad();

  001ea	e8 00 00 00 00	 call	 ?GameMonsterAllCloseAndReLoad@@YAXXZ ; GameMonsterAllCloseAndReLoad

; 732  : 					break;

  001ef	e9 b8 03 00 00	 jmp	 $LN4@WndProc
$LN39@WndProc:

; 733  : 				case ID_LOAD_SHOP :
; 734  : 					ShopDataLoad();

  001f4	e8 00 00 00 00	 call	 ?ShopDataLoad@@YAHXZ	; ShopDataLoad

; 735  : 					break;

  001f9	e9 ae 03 00 00	 jmp	 $LN4@WndProc
$LN40@WndProc:

; 736  : #ifdef MAP_SERVER_WORK_20041030
; 737  : 				case ID_LOAD_MAPSVRINFO :
; 738  : 					g_MapServerManager.LoadData(gDirPath.GetNewPath("MapServerInfo.dat"));
; 739  : 					break;
; 740  : #ifdef CASTLE_MAIN_SCHEDULER_20041111				// 공성서버 만 공성정보를 읽음
; 741  : 				case ID_LOAD_CASTLESIEGE :
; 742  : 					if (g_CastleSiege.Ready(g_MapServerManager.GetMapSvrGroup()) == TRUE) {
; 743  : 						if (g_CastleSiege.LoadData(gDirPath.GetNewPath("MuCastleData.dat"))) {
; 744  : 							g_CastleSiege.LoadPreFixData(gDirPath.GetNewPath("commonserver.cfg"));
; 745  : 							g_CastleSiege.SetDataLoadState(CASTLESIEGE_DATALOAD_2);		// DB 데이터를 읽을 준비를 한다.
; 746  : 						}
; 747  : 					}
; 748  : 					break;
; 749  : #endif
; 750  : #endif
; 751  : 				case ID_LOAD_ACCEPTIPLOAD :
; 752  : 					acceptIP.Load(gDirPath.GetNewPath("Iplist.dat"));

  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DPAHEMHE@Iplist?4dat@
  00203	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00208	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0020d	50		 push	 eax
  0020e	b9 00 00 00 00	 mov	 ecx, OFFSET ?acceptIP@@3VCAcceptIp@@A ; acceptIP
  00213	e8 00 00 00 00	 call	 ?Load@CAcceptIp@@QAEXPAD@Z ; CAcceptIp::Load

; 753  : 					break;

  00218	e9 8f 03 00 00	 jmp	 $LN4@WndProc
$LN41@WndProc:

; 754  : 				case ID_MENUGAMESERVEROPTIONLOAD :	// 게임서버 정보 옵션 읽기
; 755  : 					ReadCommonServerInfo();

  0021d	e8 00 00 00 00	 call	 ?ReadCommonServerInfo@@YAXXZ ; ReadCommonServerInfo

; 756  : 					break;

  00222	e9 85 03 00 00	 jmp	 $LN4@WndProc
$LN42@WndProc:

; 757  : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 758  : 				case ID_MENUSHOPLISTRELOAD:
; 759  : 					g_CashShop.CashShopOptioNReload();
; 760  : 					break;
; 761  : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 762  : 				case ID_VIEW_LOG :
; 763  : 					gCurPaintType = 0;

  00227	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gCurPaintType@@3HA, 0 ; gCurPaintType

; 764  : 					break;

  00231	e9 76 03 00 00	 jmp	 $LN4@WndProc
$LN43@WndProc:

; 765  : #ifdef MU_CASTLESIEGE_LOG_20050107
; 766  : 				case ID_VIEW_LOG_CS :
; 767  : 					SendMessage(GetDlgItem(g_hCsLogDlgProc, IDC_MAIN_LIST), LB_ADDSTRING, 0, rand()%2?(LPARAM)"HELLO WORLD":(LPARAM)"옴냐");
; 768  : 					ShowWindow(g_hCsLogDlgProc, TRUE);
; 769  : 					break;
; 770  : #endif					
; 771  : 				case ID_MAP_1 :
; 772  : 					gCurPaintMapNumber = 0; 

  00236	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gCurPaintMapNumber@@3HA, 0 ; gCurPaintMapNumber

; 773  : 					gCurPaintType = 1;

  00240	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gCurPaintType@@3HA, 1 ; gCurPaintType

; 774  : 					break;

  0024a	e9 5d 03 00 00	 jmp	 $LN4@WndProc
$LN44@WndProc:

; 775  : 				case ID_MAP_2 :
; 776  : 					gCurPaintType = 1;

  0024f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gCurPaintType@@3HA, 1 ; gCurPaintType

; 777  : 					gCurPaintMapNumber = 1; 

  00259	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gCurPaintMapNumber@@3HA, 1 ; gCurPaintMapNumber

; 778  : 					break;

  00263	e9 44 03 00 00	 jmp	 $LN4@WndProc
$LN45@WndProc:

; 779  : 				case ID_MAP_3 : 
; 780  : 					gCurPaintType = 1;

  00268	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gCurPaintType@@3HA, 1 ; gCurPaintType

; 781  : 					gCurPaintMapNumber = 2; 

  00272	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?gCurPaintMapNumber@@3HA, 2 ; gCurPaintMapNumber

; 782  : 					break;

  0027c	e9 2b 03 00 00	 jmp	 $LN4@WndProc
$LN46@WndProc:

; 783  : 				case ID_MAP_4 :
; 784  : 					gCurPaintType = 1;

  00281	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gCurPaintType@@3HA, 1 ; gCurPaintType

; 785  : 					gCurPaintMapNumber = 3; 

  0028b	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?gCurPaintMapNumber@@3HA, 3 ; gCurPaintMapNumber

; 786  : 					break;

  00295	e9 12 03 00 00	 jmp	 $LN4@WndProc
$LN47@WndProc:

; 787  : #ifdef ADD_NEW_MAP_CRYWOLF_FIRSTZONE_20050414
; 788  : 				case ID_MAP_CRYWOLF :
; 789  : 					gCurPaintType = 1;
; 790  : 					gCurPaintMapNumber = MAP_INDEX_CRYWOLF_FIRSTZONE; 
; 791  : 					break;
; 792  : #endif
; 793  : 				case ID_MENUITEM_EVENT :
; 794  : 					if( DragonEvent->GetState() )

  0029a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  002a0	e8 00 00 00 00	 call	 ?GetState@CDragonEvent@@QAEEXZ ; CDragonEvent::GetState
  002a5	0f b6 c0	 movzx	 eax, al
  002a8	85 c0		 test	 eax, eax
  002aa	74 0d		 je	 SHORT $LN48@WndProc

; 795  : 					{
; 796  : 						DragonEvent->End();

  002ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  002b2	e8 00 00 00 00	 call	 ?End@CDragonEvent@@QAEXXZ ; CDragonEvent::End

; 797  : 					}

  002b7	eb 0b		 jmp	 SHORT $LN49@WndProc
$LN48@WndProc:

; 798  : 					else DragonEvent->Start();

  002b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  002bf	e8 00 00 00 00	 call	 ?Start@CDragonEvent@@QAEXXZ ; CDragonEvent::Start
$LN49@WndProc:

; 799  : 					break;

  002c4	e9 e3 02 00 00	 jmp	 $LN4@WndProc
$LN50@WndProc:

; 800  : 
; 801  : 				case ID_MENUITEM_STAROFXMAS_EVENT :
; 802  : 					if( gXMasEvent )

  002c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gXMasEvent@@3HA, 0 ; gXMasEvent
  002d0	74 0c		 je	 SHORT $LN51@WndProc

; 803  : 					{
; 804  : 						gXMasEvent = 0;

  002d2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gXMasEvent@@3HA, 0 ; gXMasEvent

; 805  : 					}

  002dc	eb 0a		 jmp	 SHORT $LN52@WndProc
$LN51@WndProc:

; 806  : 					else gXMasEvent = 1;

  002de	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gXMasEvent@@3HA, 1 ; gXMasEvent
$LN52@WndProc:

; 807  : 					break;				

  002e8	e9 bf 02 00 00	 jmp	 $LN4@WndProc
$LN53@WndProc:

; 808  : 				
; 809  : 					// 폭죽 이벤트 활성화메뉴
; 810  : 				case ID_MENUITEM_FIRECRACKER_EVENT :
; 811  : 					if( gFireCrackerEvent )

  002ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gFireCrackerEvent@@3HA, 0 ; gFireCrackerEvent
  002f4	74 0c		 je	 SHORT $LN54@WndProc

; 812  : 					{
; 813  : 						gFireCrackerEvent = 0;

  002f6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gFireCrackerEvent@@3HA, 0 ; gFireCrackerEvent

; 814  : 					}

  00300	eb 0a		 jmp	 SHORT $LN55@WndProc
$LN54@WndProc:

; 815  : 					else gFireCrackerEvent = 1;

  00302	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gFireCrackerEvent@@3HA, 1 ; gFireCrackerEvent
$LN55@WndProc:

; 816  : 					break;		

  0030c	e9 9b 02 00 00	 jmp	 $LN4@WndProc
$LN56@WndProc:

; 817  : 
; 818  : 				case ID_LOAD_CUSTOM:
; 819  : 					
; 820  : 					gBalanceSystem.Load(gDirPath.GetNewPath(BALANCESYSTEM_DIR));

  00311	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PPGGKBGC@?4?4?2data?2BalanceSystem?4ini@
  00316	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0031b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00320	50		 push	 eax
  00321	b9 00 00 00 00	 mov	 ecx, OFFSET ?gBalanceSystem@@3VcBalanceSystem@@A ; gBalanceSystem
  00326	e8 00 00 00 00	 call	 ?Load@cBalanceSystem@@QAEXPAD@Z ; cBalanceSystem::Load

; 821  : 					gSettings = new CSettings; gSettings->Loading(); _dynamic_experience._loading(); 

  0032b	68 94 00 00 00	 push	 148			; 00000094H
  00330	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00335	83 c4 04	 add	 esp, 4
  00338	89 85 6c fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  0033e	83 bd 6c fe ff
	ff 00		 cmp	 DWORD PTR $T2[ebp], 0
  00345	74 13		 je	 SHORT $LN139@WndProc
  00347	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0034d	e8 00 00 00 00	 call	 ??0CSettings@@QAE@XZ
  00352	89 85 68 fe ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
  00358	eb 0a		 jmp	 SHORT $LN140@WndProc
$LN139@WndProc:
  0035a	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv145[ebp], 0
$LN140@WndProc:
  00364	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv145[ebp]
  0036a	a3 00 00 00 00	 mov	 DWORD PTR ?gSettings@@3PAVCSettings@@A, eax ; gSettings
  0036f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gSettings@@3PAVCSettings@@A ; gSettings
  00375	e8 00 00 00 00	 call	 ?Loading@CSettings@@QAE_NXZ ; CSettings::Loading
  0037a	b9 00 00 00 00	 mov	 ecx, OFFSET ?_dynamic_experience@@3VCDynamicExperience@@A ; _dynamic_experience
  0037f	e8 00 00 00 00	 call	 ?_loading@CDynamicExperience@@QAEXXZ ; CDynamicExperience::_loading

; 822  : 					Balancer.Load();

  00384	b9 00 00 00 00	 mov	 ecx, OFFSET ?Balancer@@3VCBalancer@@A ; Balancer
  00389	e8 00 00 00 00	 call	 ?Load@CBalancer@@QAE_NXZ ; CBalancer::Load

; 823  : 					cexDrop.LoadConfig("..\\data\\DropTable.cfg");

  0038e	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PNKLNBEB@?4?4?2data?2DropTable?4cfg@
  00393	b9 00 00 00 00	 mov	 ecx, OFFSET ?cexDrop@@3VcDropSystem@@A ; cexDrop
  00398	e8 00 00 00 00	 call	 ?LoadConfig@cDropSystem@@QAEXPBD@Z ; cDropSystem::LoadConfig

; 824  : 		           // s_PickUp.LoadFile(gDirPath.GetNewPath("..\\data\\PickupSystem.txt"));
; 825  : 					//_beginthread(SORTEO_CUSTOM::Sorteo,0,NULL);// Sorteo custom
; 826  : 					break;

  0039d	e9 0a 02 00 00	 jmp	 $LN4@WndProc
$LN57@WndProc:

; 827  : 
; 828  : #ifdef NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 829  : 				case ID_GAMEGUARD_MODULE_UPDATE:
; 830  : 					char chGGModuleInfo[256];
; 831  : 					ReadGameGuardUpdateInfo();
; 832  : 					if( strlen( gGGModuleName ) )
; 833  : 					{
; 834  : 						AddAuthProtocol25( gGGModuleName );
; 835  : 						ModuleInfo25( chGGModuleInfo, 256);
; 836  : 						LogAddTD("[GameGuard][Add New Auth Protocol] - %s", gGGModuleName);
; 837  : 						LogAddTD("[GameGuard][Current Module Info] - %s", chGGModuleInfo);
; 838  : 					}
; 839  : 					break;
; 840  : #endif
; 841  : 
; 842  : 				case ID_MENU_FIVECLOSE :
; 843  : 					if( gCloseMsg == 0 )

  003a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCloseMsg@@3HA, 0 ; gCloseMsg
  003a9	75 2d		 jne	 SHORT $LN58@WndProc

; 844  : 					{
; 845  : 						gCloseMsgTime=300;

  003ab	c7 05 00 00 00
	00 2c 01 00 00	 mov	 DWORD PTR ?gCloseMsgTime@@3HA, 300 ; gCloseMsgTime, 0000012cH

; 846  : 						gCloseMsg=1;

  003b5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gCloseMsg@@3HA, 1 ; gCloseMsg

; 847  : 						AllSendServerMsg(lMsg.Get(1128));

  003bf	68 68 04 00 00	 push	 1128			; 00000468H
  003c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003cf	50		 push	 eax
  003d0	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  003d5	83 c4 04	 add	 esp, 4
$LN58@WndProc:

; 848  : 					}
; 849  : 					break;

  003d8	e9 cf 01 00 00	 jmp	 $LN4@WndProc
$LN59@WndProc:

; 850  : 				case ID_MENU_THREECLOSE :
; 851  : 					if( gCloseMsg == 0 )

  003dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCloseMsg@@3HA, 0 ; gCloseMsg
  003e4	75 2d		 jne	 SHORT $LN60@WndProc

; 852  : 					{
; 853  : 						gCloseMsgTime=180;

  003e6	c7 05 00 00 00
	00 b4 00 00 00	 mov	 DWORD PTR ?gCloseMsgTime@@3HA, 180 ; gCloseMsgTime, 000000b4H

; 854  : 						gCloseMsg=2;

  003f0	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?gCloseMsg@@3HA, 2 ; gCloseMsg

; 855  : 						AllSendServerMsg(lMsg.Get(1129));	// "3분후 서버가 자동 종료 됩니다."

  003fa	68 69 04 00 00	 push	 1129			; 00000469H
  003ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00404	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0040a	50		 push	 eax
  0040b	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00410	83 c4 04	 add	 esp, 4
$LN60@WndProc:

; 856  : 					}
; 857  : 					break;

  00413	e9 94 01 00 00	 jmp	 $LN4@WndProc
$LN61@WndProc:

; 858  : 				case ID_MENU_ONECLOSE :
; 859  : 					if( gCloseMsg == 0 )

  00418	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCloseMsg@@3HA, 0 ; gCloseMsg
  0041f	75 2d		 jne	 SHORT $LN62@WndProc

; 860  : 					{
; 861  : 						gCloseMsgTime=60;

  00421	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?gCloseMsgTime@@3HA, 60 ; gCloseMsgTime, 0000003cH

; 862  : 						gCloseMsg=3;

  0042b	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?gCloseMsg@@3HA, 3 ; gCloseMsg

; 863  : 						AllSendServerMsg(lMsg.Get(1130));//1분후 서버가 자동 종료 됩니다

  00435	68 6a 04 00 00	 push	 1130			; 0000046aH
  0043a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0043f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00445	50		 push	 eax
  00446	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  0044b	83 c4 04	 add	 esp, 4
$LN62@WndProc:

; 864  : 					}
; 865  : 					break;

  0044e	e9 59 01 00 00	 jmp	 $LN4@WndProc
$LN63@WndProc:

; 866  : #ifdef EVENT_OPTION_RELOAD_20040305						// 이벤트 관련 옵션만 리로드 한다.
; 867  : 				case ID_EVENTLOAD_ALL :					// 모든 옵션 리로드
; 868  : 					ReadEventInfo (MU_EVENT_ALL);

  00453	6a 00		 push	 0
  00455	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  0045a	83 c4 04	 add	 esp, 4

; 869  : 					break;

  0045d	e9 4a 01 00 00	 jmp	 $LN4@WndProc
$LN64@WndProc:

; 870  : 				case ID_EVENTLOAD_DEVILSQUARE :			// 데빌스퀘어
; 871  : 					ReadEventInfo (MU_EVENT_DEVILSQUARE);

  00462	6a 01		 push	 1
  00464	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  00469	83 c4 04	 add	 esp, 4

; 872  : 					break;

  0046c	e9 3b 01 00 00	 jmp	 $LN4@WndProc
$LN65@WndProc:

; 873  : 				case ID_EVENTLOAD_BLOODCASTLE :			// 블러드캐슬
; 874  : 					ReadEventInfo (MU_EVENT_BLOODCASTLE);

  00471	6a 02		 push	 2
  00473	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  00478	83 c4 04	 add	 esp, 4

; 875  : 					break;

  0047b	e9 2c 01 00 00	 jmp	 $LN4@WndProc
$LN66@WndProc:

; 876  : 				case ID_EVENTLOAD_UNDERTROOPATTACK :	// 지하군단
; 877  : 					ReadEventInfo (MU_EVENT_ATTACKEVENTTROOP);

  00480	6a 03		 push	 3
  00482	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  00487	83 c4 04	 add	 esp, 4

; 878  : 					break;

  0048a	e9 1d 01 00 00	 jmp	 $LN4@WndProc
$LN67@WndProc:

; 879  : 				case ID_EVENTLOAD_GOLDENTROOPATTACK :	// 황금군단
; 880  : 					ReadEventInfo (MU_EVENT_GOLDENTROOP);

  0048f	6a 04		 push	 4
  00491	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  00496	83 c4 04	 add	 esp, 4

; 881  : 					break;

  00499	e9 0e 01 00 00	 jmp	 $LN4@WndProc
$LN68@WndProc:

; 882  : 				case ID_EVENTLOAD_WHITEMAGEATTACK :		// 백색마법사군단
; 883  : 					ReadEventInfo (MU_EVENT_WHITEMAGETROOP);

  0049e	6a 05		 push	 5
  004a0	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  004a5	83 c4 04	 add	 esp, 4

; 884  : 					break;

  004a8	e9 ff 00 00 00	 jmp	 $LN4@WndProc
$LN69@WndProc:

; 885  : 				case ID_EVENTLOAD_LOVEPANGPANG :		// 러브러브팡팡
; 886  : 					ReadEventInfo (MU_EVENT_LOVEPANGPANG);

  004ad	6a 06		 push	 6
  004af	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  004b4	83 c4 04	 add	 esp, 4

; 887  : 					break;

  004b7	e9 f0 00 00 00	 jmp	 $LN4@WndProc
$LN70@WndProc:

; 888  : 				case ID_EVENTLOAD_FIRECRACKER :			// 폭툭
; 889  : 					ReadEventInfo (MU_EVENT_FIRECRACKER);

  004bc	6a 07		 push	 7
  004be	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  004c3	83 c4 04	 add	 esp, 4

; 890  : 					break;

  004c6	e9 e1 00 00 00	 jmp	 $LN4@WndProc
$LN71@WndProc:

; 891  : 				case ID_EVENTLOAD_XMASSTAR :			// 성탄의별
; 892  : 					ReadEventInfo (MU_EVENT_XMASSTAR);

  004cb	6a 09		 push	 9
  004cd	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  004d2	83 c4 04	 add	 esp, 4

; 893  : 					break;

  004d5	e9 d2 00 00 00	 jmp	 $LN4@WndProc
$LN72@WndProc:

; 894  : 				case ID_EVENTLOAD_HEARTOFLOVE :			// 사랑의하트
; 895  : 					ReadEventInfo (MU_EVENT_HEARTOFLOVE);

  004da	6a 0a		 push	 10			; 0000000aH
  004dc	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  004e1	83 c4 04	 add	 esp, 4

; 896  : 					break;

  004e4	e9 c3 00 00 00	 jmp	 $LN4@WndProc
$LN73@WndProc:

; 897  : 				case ID_EVENTLOAD_SAY_HAPPYNEWYEAR :	// NPC 새해인사
; 898  : 					ReadEventInfo (MU_EVENT_SAY_HAPPYNEWYEAR);

  004e9	6a 0b		 push	 11			; 0000000bH
  004eb	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  004f0	83 c4 04	 add	 esp, 4

; 899  : 					break;

  004f3	e9 b4 00 00 00	 jmp	 $LN4@WndProc
$LN74@WndProc:

; 900  : 				case ID_EVENTLOAD_SAY_MERRYXMAS :		// NPC 크리스마스인사
; 901  : 					ReadEventInfo (MU_EVENT_SAY_MERRYXMAS);

  004f8	6a 0c		 push	 12			; 0000000cH
  004fa	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  004ff	83 c4 04	 add	 esp, 4

; 902  : 					break;

  00502	e9 a5 00 00 00	 jmp	 $LN4@WndProc
$LN75@WndProc:

; 903  : 					
; 904  : #ifdef CHAOSCASTLE_SYSTEM_20040408 
; 905  : 				case ID_EVENTLOAD_CHAOSCASTLE :			// 카오스 캐슬
; 906  : 					ReadEventInfo (MU_EVENT_CHAOSCASTLE);

  00507	6a 0d		 push	 13			; 0000000dH
  00509	e8 00 00 00 00	 call	 ?ReadEventInfo@@YAXW4MU_EVENT_TYPE@@@Z ; ReadEventInfo
  0050e	83 c4 04	 add	 esp, 4

; 907  : 					break;

  00511	e9 96 00 00 00	 jmp	 $LN4@WndProc
$LN76@WndProc:

; 908  : #endif
; 909  : 
; 910  : #ifdef CHRISTMAS_RIBBONBOX_EVENT_20051212
; 911  : 				case ID_EVENTLOAD_RIBBONBOX:		// 크리스마스 리본상자 이벤트
; 912  : 					ReadEventInfo( MU_EVENT_CHRISTMAS_RIBBONBOX );
; 913  : 					break;
; 914  : #endif // #ifdef CHRISTMAS_RIBBONBOX_EVENT_20051212
; 915  : 
; 916  : #ifdef VALENTINES_DAY_BOX_EVENT_20060124
; 917  : 				case ID_EVENTLOAD_CHOCOLATEBOX:		// 발렌타인데이 초콜릿상자 이벤트
; 918  : 					ReadEventInfo( MU_EVENT_VALENTINESDAY_CHOCOLATEBOX );
; 919  : 					break;
; 920  : #endif // #ifdef VALENTINES_DAY_BOX_EVENT_20060124
; 921  : 
; 922  : #ifdef WHITEDAY_CANDY_BOX_EVENT_20060222
; 923  : 				case ID_EVENTLOAD_CANDYBOX:			// 화이트데이 사탕상자 이벤트
; 924  : 					ReadEventInfo( MU_EVENT_WHITEDAY_CANDYBOX );
; 925  : 					break;
; 926  : #endif	// #ifdef WHITEDAY_CANDY_BOX_EVENT_20060222	
; 927  : 
; 928  : #endif
; 929  : #ifdef ETC_OPTION_RELOAD_20040308				// 뮤의 옵션 중 이벤트 외의 것들만 리로드
; 930  : 				case ID_ETCLOAD_ALL :
; 931  : 					ReadGameEtcInfo (MU_ETC_ALL);

  00516	6a 00		 push	 0
  00518	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  0051d	83 c4 04	 add	 esp, 4

; 932  : 					break;

  00520	e9 87 00 00 00	 jmp	 $LN4@WndProc
$LN77@WndProc:

; 933  : 				case ID_ETCLOAD_CREATECHAR :
; 934  : 					ReadGameEtcInfo (MU_ETC_CREATECHARACTER);

  00525	6a 01		 push	 1
  00527	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  0052c	83 c4 04	 add	 esp, 4

; 935  : 					break;

  0052f	eb 7b		 jmp	 SHORT $LN4@WndProc
$LN78@WndProc:

; 936  : 				case ID_ETCLOAD_GUILD :
; 937  : 					ReadGameEtcInfo (MU_ETC_GUILD);

  00531	6a 02		 push	 2
  00533	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  00538	83 c4 04	 add	 esp, 4

; 938  : 					break;

  0053b	eb 6f		 jmp	 SHORT $LN4@WndProc
$LN79@WndProc:

; 939  : 				case ID_ETCLOAD_TRADE :
; 940  : 					ReadGameEtcInfo (MU_ETC_TRADE);

  0053d	6a 03		 push	 3
  0053f	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  00544	83 c4 04	 add	 esp, 4

; 941  : 					break;

  00547	eb 63		 jmp	 SHORT $LN4@WndProc
$LN80@WndProc:

; 942  : 				case ID_ETCLOAD_CHAOSBOX :
; 943  : 					ReadGameEtcInfo (MU_ETC_USECHAOSBOX);

  00549	6a 04		 push	 4
  0054b	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  00550	83 c4 04	 add	 esp, 4

; 944  : 					break;

  00553	eb 57		 jmp	 SHORT $LN4@WndProc
$LN81@WndProc:

; 945  : 				case ID_ETCLOAD_PSHOP :
; 946  : 					ReadGameEtcInfo (MU_ETC_PERSONALSHOP);

  00555	6a 05		 push	 5
  00557	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  0055c	83 c4 04	 add	 esp, 4

; 947  : 					break;

  0055f	eb 4b		 jmp	 SHORT $LN4@WndProc
$LN82@WndProc:

; 948  : 				case ID_ETCLOAD_PKITEMDROP :
; 949  : 					ReadGameEtcInfo (MU_ETC_PKITEMDROP);

  00561	6a 06		 push	 6
  00563	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  00568	83 c4 04	 add	 esp, 4

; 950  : 					break;

  0056b	eb 3f		 jmp	 SHORT $LN4@WndProc
$LN83@WndProc:

; 951  : 				case ID_ETCLOAD_ITEMDROPRATE :
; 952  : 					ReadGameEtcInfo (MU_ETC_ITEMDROPRATE);

  0056d	6a 07		 push	 7
  0056f	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  00574	83 c4 04	 add	 esp, 4

; 953  : 					break;

  00577	eb 33		 jmp	 SHORT $LN4@WndProc
$LN84@WndProc:

; 954  : 				case ID_ETCLOAD_SPEEDHACK :
; 955  : 					ReadGameEtcInfo (MU_ETC_SPEEDHACK);

  00579	6a 08		 push	 8
  0057b	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  00580	83 c4 04	 add	 esp, 4

; 956  : 					break;

  00583	eb 27		 jmp	 SHORT $LN4@WndProc
$LN85@WndProc:

; 957  : 				case ID_ETCLOAD_GAMEGUARD :
; 958  : 					ReadGameEtcInfo (MU_ETC_GAMEGUARD);

  00585	6a 09		 push	 9
  00587	e8 00 00 00 00	 call	 ?ReadGameEtcInfo@@YAXW4MU_ETC_TYPE@@@Z ; ReadGameEtcInfo
  0058c	83 c4 04	 add	 esp, 4

; 959  : 					break;

  0058f	eb 1b		 jmp	 SHORT $LN4@WndProc
$LN86@WndProc:

; 960  : #endif
; 961  : 				default:
; 962  : 				   return DefWindowProc(hWnd, message, wParam, lParam);

  00591	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00594	50		 push	 eax
  00595	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00598	51		 push	 ecx
  00599	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  0059c	52		 push	 edx
  0059d	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  005a0	50		 push	 eax
  005a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  005a7	e9 6c 06 00 00	 jmp	 $LN1@WndProc
$LN4@WndProc:

; 963  : 			}
; 964  : 			break;

  005ac	e9 65 06 00 00	 jmp	 $LN2@WndProc
$LN87@WndProc:

; 965  : 		/*case WM_PAINT:
; 966  : 			hdc = BeginPaint(hWnd, &ps);
; 967  : 			// TODO: Add any drawing code here...
; 968  : 			RECT rt;
; 969  : 			GetClientRect(hWnd, &rt);
; 970  : 			DrawText(hdc, szHello, strlen(szHello), &rt, DT_CENTER);
; 971  : 			EndPaint(hWnd, &ps);
; 972  : 			break;*/
; 973  : 		case WM_ASS_SERVERMSG :
; 974  : 			GMServerMsgProc(wParam, lParam);

  005b1	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  005b4	50		 push	 eax
  005b5	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  005b8	51		 push	 ecx
  005b9	e8 00 00 00 00	 call	 ?GMServerMsgProc@@YAXIJ@Z ; GMServerMsgProc
  005be	83 c4 08	 add	 esp, 8

; 975  : 			break;

  005c1	e9 50 06 00 00	 jmp	 $LN2@WndProc
$LN88@WndProc:

; 976  : 		case WM_ASS_CLIENTMSG :
; 977  : 			{
; 978  : 			int wp=wParam;

  005c6	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  005c9	89 45 e0	 mov	 DWORD PTR _wp$10[ebp], eax

; 979  : 			int lp=lParam;

  005cc	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  005cf	89 45 dc	 mov	 DWORD PTR _lp$9[ebp], eax

; 980  : 			GMClientMsgProc(wParam, lParam);

  005d2	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  005d5	50		 push	 eax
  005d6	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  005d9	51		 push	 ecx
  005da	e8 00 00 00 00	 call	 ?GMClientMsgProc@@YAXIJ@Z ; GMClientMsgProc
  005df	83 c4 08	 add	 esp, 8

; 981  : 			//GMClientMsgProc(wp, lp);
; 982  : 			}
; 983  : 			break;

  005e2	e9 2f 06 00 00	 jmp	 $LN2@WndProc
$LN89@WndProc:

; 984  : 		case WM_ASS_JOINCLIMSG :
; 985  : 			GMJoinClientMsgProc(wParam, lParam);

  005e7	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  005ea	50		 push	 eax
  005eb	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  005ee	51		 push	 ecx
  005ef	e8 00 00 00 00	 call	 ?GMJoinClientMsgProc@@YAXIJ@Z ; GMJoinClientMsgProc
  005f4	83 c4 08	 add	 esp, 8

; 986  : 			break;

  005f7	e9 1a 06 00 00	 jmp	 $LN2@WndProc
$LN90@WndProc:

; 987  : 
; 988  : 		case WM_ASS_RANKINGCLIMSG :
; 989  : 			GMRankingClientMsgProc(wParam, lParam);

  005fc	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  005ff	50		 push	 eax
  00600	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00603	51		 push	 ecx
  00604	e8 00 00 00 00	 call	 ?GMRankingClientMsgProc@@YAXIJ@Z ; GMRankingClientMsgProc
  00609	83 c4 08	 add	 esp, 8

; 990  : 			break;

  0060c	e9 05 06 00 00	 jmp	 $LN2@WndProc
$LN91@WndProc:

; 991  : 
; 992  : 		case WM_ASS_EVENTCHIPCLIMSG :
; 993  : 			GMEventChipClientMsgProc(wParam, lParam);

  00611	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00614	50		 push	 eax
  00615	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00618	51		 push	 ecx
  00619	e8 00 00 00 00	 call	 ?GMEventChipClientMsgProc@@YAXIJ@Z ; GMEventChipClientMsgProc
  0061e	83 c4 08	 add	 esp, 8

; 994  : 			break;

  00621	e9 f0 05 00 00	 jmp	 $LN2@WndProc
$LN92@WndProc:

; 995  : 			
; 996  : #ifdef GAMESERVER_INFO_TCP_20031203
; 997  : 		case WM_ASS_CSERVERMSG :
; 998  : 			GMConnectServerClientMsgProc(wParam, lParam);
; 999  : 			break;
; 1000 : #endif
; 1001 : 
; 1002 : 		case WM_ASS_DATACLIMSG :
; 1003 : 			//GMDataClientMsgProc(wParam, lParam);
; 1004 : 			cDBSMng.MsgProc(0, wParam, lParam);

  00626	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00629	50		 push	 eax
  0062a	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0062d	51		 push	 ecx
  0062e	6a 00		 push	 0
  00630	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00635	e8 00 00 00 00	 call	 ?MsgProc@DBSockMng@@QAEHHIJ@Z ; DBSockMng::MsgProc

; 1005 : 			break;

  0063a	e9 d7 05 00 00	 jmp	 $LN2@WndProc
$LN93@WndProc:

; 1006 : 		case WM_ASS_DATACLIMSG+1 :
; 1007 : 			cDBSMng.MsgProc(1, wParam, lParam);

  0063f	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00642	50		 push	 eax
  00643	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00646	51		 push	 ecx
  00647	6a 01		 push	 1
  00649	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0064e	e8 00 00 00 00	 call	 ?MsgProc@DBSockMng@@QAEHHIJ@Z ; DBSockMng::MsgProc

; 1008 : 			//GMDataClientMsgProc(wParam, lParam);
; 1009 : 			break;

  00653	e9 be 05 00 00	 jmp	 $LN2@WndProc
$LN94@WndProc:

; 1010 : #ifdef _NEW_EXDB_
; 1011 : //##EXDB##
; 1012 : 		case WM_ASS_EXDATACLIMSG :
; 1013 : 			ExDataClientMsgProc(wParam, lParam);

  00658	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0065b	50		 push	 eax
  0065c	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0065f	51		 push	 ecx
  00660	e8 00 00 00 00	 call	 ?ExDataClientMsgProc@@YAXIJ@Z ; ExDataClientMsgProc
  00665	83 c4 08	 add	 esp, 8

; 1014 : 			break;

  00668	e9 a9 05 00 00	 jmp	 $LN2@WndProc
$LN95@WndProc:

; 1015 : //##EXDB##
; 1016 : #endif
; 1017 : 
; 1018 : 		case WM_ASS_CREATEGAMESERVER :	// 게임서버를 만들어도 되는가?
; 1019 : 			if( gServerReady == 2 )

  0066d	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?gServerReady@@3HA, 2 ; gServerReady
  00674	75 05		 jne	 SHORT $LN96@WndProc

; 1020 : 			{
; 1021 : 				GameServerStart();

  00676	e8 00 00 00 00	 call	 ?GameServerStart@@YAHXZ	; GameServerStart
$LN96@WndProc:

; 1022 : 			}
; 1023 : 			break;

  0067b	e9 96 05 00 00	 jmp	 $LN2@WndProc
$LN97@WndProc:

; 1024 : 		case WM_TIMER :
; 1025 : 			switch( wParam )

  00680	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00683	89 85 68 fe ff
	ff		 mov	 DWORD PTR tv221[ebp], eax
  00689	81 bd 68 fe ff
	ff e8 03 00 00	 cmp	 DWORD PTR tv221[ebp], 1000 ; 000003e8H
  00693	77 2b		 ja	 SHORT $LN142@WndProc
  00695	81 bd 68 fe ff
	ff e8 03 00 00	 cmp	 DWORD PTR tv221[ebp], 1000 ; 000003e8H
  0069f	0f 84 5e 02 00
	00		 je	 $LN108@WndProc
  006a5	83 bd 68 fe ff
	ff 64		 cmp	 DWORD PTR tv221[ebp], 100 ; 00000064H
  006ac	74 59		 je	 SHORT $LN99@WndProc
  006ae	83 bd 68 fe ff
	ff 65		 cmp	 DWORD PTR tv221[ebp], 101 ; 00000065H
  006b5	0f 84 1d 01 00
	00		 je	 $LN105@WndProc
  006bb	e9 ff 03 00 00	 jmp	 $LN6@WndProc
$LN142@WndProc:
  006c0	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv221[ebp]
  006c6	81 e9 e9 03 00
	00		 sub	 ecx, 1001		; 000003e9H
  006cc	89 8d 68 fe ff
	ff		 mov	 DWORD PTR tv221[ebp], ecx
  006d2	83 bd 68 fe ff
	ff 07		 cmp	 DWORD PTR tv221[ebp], 7
  006d9	0f 87 e0 03 00
	00		 ja	 $LN6@WndProc
  006df	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv221[ebp]
  006e5	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN148@WndProc[edx*4]
$LN98@WndProc:

; 1026 : 			{
; 1027 : 			case MTIME_DBSGUILDLISTREQUEST :
; 1028 : #ifdef _NEW_EXDB_
; 1029 : 				DGGuildListRequest();

  006ec	e8 00 00 00 00	 call	 ?DGGuildListRequest@@YAXXZ ; DGGuildListRequest

; 1030 : #endif
; 1031 : 				KillTimer(ghWnd, MTIME_DBSGUILDLISTREQUEST);	// 최초 한번만 요청하고 타이머 죽임

  006f1	68 f0 03 00 00	 push	 1008			; 000003f0H
  006f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  006fb	50		 push	 eax
  006fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 1032 : 				break;

  00702	e9 b8 03 00 00	 jmp	 $LN6@WndProc
$LN99@WndProc:

; 1033 : 			case 100 :
; 1034 : 				{
; 1035 : 				RECT rect;
; 1036 : 				HDC hdc = GetDC(hWnd);

  00707	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0070a	50		 push	 eax
  0070b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00711	89 45 c8	 mov	 DWORD PTR _hdc$7[ebp], eax

; 1037 : 
; 1038 : 				GetClientRect(hWnd, &rect);

  00714	8d 45 cc	 lea	 eax, DWORD PTR _rect$8[ebp]
  00717	50		 push	 eax
  00718	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  0071b	51		 push	 ecx
  0071c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 1039 : 				FillRect(hdc, &rect, (HBRUSH)GetStockObject(WHITE_BRUSH));	

  00722	6a 00		 push	 0
  00724	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStockObject@4
  0072a	50		 push	 eax
  0072b	8d 45 cc	 lea	 eax, DWORD PTR _rect$8[ebp]
  0072e	50		 push	 eax
  0072f	8b 4d c8	 mov	 ecx, DWORD PTR _hdc$7[ebp]
  00732	51		 push	 ecx
  00733	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12

; 1040 : 				ReleaseDC(hWnd, hdc);

  00739	8b 45 c8	 mov	 eax, DWORD PTR _hdc$7[ebp]
  0073c	50		 push	 eax
  0073d	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00740	51		 push	 ecx
  00741	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 1041 : 	
; 1042 : 				if( gCurPaintType == 0 ) {

  00747	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCurPaintType@@3HA, 0 ; gCurPaintType
  0074e	75 16		 jne	 SHORT $LN100@WndProc

; 1043 : 					if( LogTextPaint != NULL ) LogTextPaint(hWnd);

  00750	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?LogTextPaint@@3P6AXPAUHWND__@@@ZA, 0 ; LogTextPaint
  00757	74 0d		 je	 SHORT $LN100@WndProc
  00759	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0075c	50		 push	 eax
  0075d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogTextPaint@@3P6AXPAUHWND__@@@ZA ; LogTextPaint
  00763	83 c4 04	 add	 esp, 4
$LN100@WndProc:

; 1044 : 				}
; 1045 : 				gObjViewportPaint(hWnd, gCurPaintPlayer);

  00766	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?gCurPaintPlayer@@3HA
  0076d	50		 push	 eax
  0076e	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00771	51		 push	 ecx
  00772	e8 00 00 00 00	 call	 ?gObjViewportPaint@@YAXPAUHWND__@@F@Z ; gObjViewportPaint
  00777	83 c4 08	 add	 esp, 8

; 1046 : 
; 1047 : #ifdef ADD_SERVER_ALERT_USING_WHATSUP_01_20050628
; 1048 : 				g_ServerAlertManager.Run( hWnd );
; 1049 : #endif
; 1050 : 				
; 1051 : #ifdef ADD_SERVER_INFO_DISPLAY_EXTEND_01_20060313
; 1052 : 				g_ServerInfoDisplayer.Run( hWnd );

  0077a	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0077d	50		 push	 eax
  0077e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ServerInfoDisplayer@@3VTServerInfoDisplayer@@A ; g_ServerInfoDisplayer
  00783	e8 00 00 00 00	 call	 ?Run@TServerInfoDisplayer@@QAEXPAUHWND__@@@Z ; TServerInfoDisplayer::Run

; 1053 : #endif
; 1054 : 				}
; 1055 : 				//GraphPaint(hWnd);
; 1056 : #ifdef MAP_SERVER_WORK_20041030
; 1057 : 				GJNotifyMaxUserCount();
; 1058 : #endif
; 1059 : 				break;

  00788	e9 32 03 00 00	 jmp	 $LN6@WndProc
$LN102@WndProc:

; 1060 : 			case MTIME_500 :
; 1061 : 				MonsterAndMsgProc();

  0078d	e8 00 00 00 00	 call	 ?MonsterAndMsgProc@@YAXXZ ; MonsterAndMsgProc

; 1062 : #ifdef ADD_NEWPVP_PKFIELD
; 1063 : 				g_NewPVP.Run();
; 1064 : #endif // ADD_NEWPVP_PKFIELD
; 1065 : 				break;

  00792	e9 28 03 00 00	 jmp	 $LN6@WndProc
$LN103@WndProc:

; 1066 : #ifdef FOR_BLOODCASTLE
; 1067 : 			case MTIME_300 :
; 1068 : 				MoveMonsterProc();

  00797	e8 00 00 00 00	 call	 ?MoveMonsterProc@@YAXXZ	; MoveMonsterProc

; 1069 : #ifdef ADD_KANTURU_20060627
; 1070 : 				// 20060818 RKFKA - For Test
; 1071 : 				g_Kanturu.UserMonsterCountCheck();
; 1072 : #endif
; 1073 : 				break;

  0079c	e9 1e 03 00 00	 jmp	 $LN6@WndProc
$LN104@WndProc:

; 1074 : 			case MTIME_100 :
; 1075 : 				g_BloodCastle.Run();

  007a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  007a6	e8 00 00 00 00	 call	 ?Run@CBloodCastle@@QAEXXZ ; CBloodCastle::Run

; 1076 : 	#ifdef MONSTER_HERD_SYSTEM_20031120
; 1077 : 				g_RingAttackEvent.Run();

  007ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_RingAttackEvent@@3VCRingAttackEvent@@A ; g_RingAttackEvent
  007b0	e8 00 00 00 00	 call	 ?Run@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::Run

; 1078 : 	#endif	// #ifdef MONSTER_HERD_SYSTEM_20031120
; 1079 : 
; 1080 : 	#ifdef CHAOSCASTLE_SYSTEM_20040408
; 1081 : 				g_ChaosCastle.Run();

  007b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  007ba	e8 00 00 00 00	 call	 ?Run@CChaosCastle@@QAEXXZ ; CChaosCastle::Run

; 1082 : 	#endif	// #ifdef CHAOSCASTLE_SYSTEM_20040408
; 1083 : 
; 1084 : 	#ifdef CASTLE_MAIN_SCHEDULER_20041111
; 1085 : 				g_CastleSiege.Run();
; 1086 : 	#endif	// #ifdef CASTLE_MAIN_SCHEDULER_20041111
; 1087 : 
; 1088 : 	#ifdef CASTLEDEEP_EVENT_20050413
; 1089 : 				g_CastleDeepEvent.Run();
; 1090 : 	#endif	// #ifdef CASTLEDEEP_EVENT_20050413
; 1091 : 				
; 1092 : 	#ifdef ADD_NEW_WEAPON_FOR_CASTLE_01_20041116
; 1093 : 				g_CsNPC_Weapon.WeaponAttackProc();
; 1094 : 	#endif  // ADD_NEW_WEAPON_FOR_CASTLE_01_20041116
; 1095 : 
; 1096 : 
; 1097 : 	#ifdef CRYWOLF_MAIN_SCHEDULER_20050505
; 1098 : 				g_Crywolf.Run();
; 1099 : 	#endif	// CRYWOLF_MAIN_SCHEDULER_20050505
; 1100 : 
; 1101 : 	#ifdef ADD_KANTURU_20060627
; 1102 : 				g_Kanturu.Run();
; 1103 : 	#endif // ADD_KANTURU_20060627
; 1104 : 
; 1105 : 	#ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 1106 : 				g_CashShop.CheckShopServerConnectState();
; 1107 : 	#endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 1108 : 
; 1109 : 	#ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	// 타이머
; 1110 : 				g_IllusionTempleEvent.IllusionTempleRun();
; 1111 : 	#endif
; 1112 : 	
; 1113 : 	#ifdef ADD_RAKLION_20080408
; 1114 : 				g_Raklion.Run();
; 1115 : 	#endif // ADD_RAKLION_20080408
; 1116 : 
; 1117 : 	#ifdef ADD_ITEM_ATTACK_XMASEVENT_20081014
; 1118 : 				g_XMasAttackEvent.Run();
; 1119 : 	#endif // ADD_ITEM_ATTACK_XMASEVENT_20081014
; 1120 : 
; 1121 : 				g_PvpEvent.Run();

  007bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PvpEvent@@3VCEngagePVP@@A ; g_PvpEvent
  007c4	e8 00 00 00 00	 call	 ?Run@CEngagePVP@@QAEXXZ	; CEngagePVP::Run

; 1122 : 				//DevGamesX 01/05/2018 - OffExp
; 1123 : 				OffExp.MainFunction();

  007c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?OffExp@@3VcOffExp@@A ; OffExp
  007ce	e8 00 00 00 00	 call	 ?MainFunction@cOffExp@@QAEXXZ ; cOffExp::MainFunction

; 1124 : 
; 1125 : 				break;

  007d3	e9 e7 02 00 00	 jmp	 $LN6@WndProc
$LN105@WndProc:

; 1126 : #else	// #ifdef FOR_BLOODCASTLE
; 1127 : 			case MTIME_100 :
; 1128 : 				MoveMonsterProc();
; 1129 : 				break;
; 1130 : #endif	// #ifdef FOR_BLOODCASTLE
; 1131 : 
; 1132 : #ifdef ADD_NEW_MONSTER_SYSTEM_02_20050725
; 1133 : 			case TIMER_MONSTER_MOVE :
; 1134 : 				TMonsterAI::MonsterMoveProc();
; 1135 : 				break;
; 1136 : 			case TIMER_MONSTER_AI :
; 1137 : 				TMonsterAI::MonsterAIProc();
; 1138 : 				break;
; 1139 : #endif
; 1140 : 
; 1141 : 			case 101 :
; 1142 : 				{
; 1143 : 				int n;
; 1144 : 				for( n=0; n<MAX_OBJECT; n++)

  007d8	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _n$6[ebp], 0
  007df	eb 09		 jmp	 SHORT $LN10@WndProc
$LN8@WndProc:
  007e1	8b 45 c4	 mov	 eax, DWORD PTR _n$6[ebp]
  007e4	83 c0 01	 add	 eax, 1
  007e7	89 45 c4	 mov	 DWORD PTR _n$6[ebp], eax
$LN10@WndProc:
  007ea	81 7d c4 e8 1c
	00 00		 cmp	 DWORD PTR _n$6[ebp], 7400 ; 00001ce8H
  007f1	7d 0e		 jge	 SHORT $LN9@WndProc

; 1145 : 					gObjStateSetCreate(n);

  007f3	8b 45 c4	 mov	 eax, DWORD PTR _n$6[ebp]
  007f6	50		 push	 eax
  007f7	e8 00 00 00 00	 call	 ?gObjStateSetCreate@@YAXH@Z ; gObjStateSetCreate
  007fc	83 c4 04	 add	 esp, 4
  007ff	eb e0		 jmp	 SHORT $LN8@WndProc
$LN9@WndProc:

; 1146 : 				
; 1147 : 				for( n=0; n<MAX_OBJECT; n++)

  00801	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _n$6[ebp], 0
  00808	eb 09		 jmp	 SHORT $LN13@WndProc
$LN11@WndProc:
  0080a	8b 45 c4	 mov	 eax, DWORD PTR _n$6[ebp]
  0080d	83 c0 01	 add	 eax, 1
  00810	89 45 c4	 mov	 DWORD PTR _n$6[ebp], eax
$LN13@WndProc:
  00813	81 7d c4 e8 1c
	00 00		 cmp	 DWORD PTR _n$6[ebp], 7400 ; 00001ce8H
  0081a	7d 0f		 jge	 SHORT $LN12@WndProc

; 1148 : 					gObjViewportListDestroy(n);

  0081c	0f b7 45 c4	 movzx	 eax, WORD PTR _n$6[ebp]
  00820	50		 push	 eax
  00821	e8 00 00 00 00	 call	 ?gObjViewportListDestroy@@YAXF@Z ; gObjViewportListDestroy
  00826	83 c4 04	 add	 esp, 4
  00829	eb df		 jmp	 SHORT $LN11@WndProc
$LN12@WndProc:

; 1149 : 								
; 1150 : 				for( n=0; n<MAX_OBJECT; n++)

  0082b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _n$6[ebp], 0
  00832	eb 09		 jmp	 SHORT $LN16@WndProc
$LN14@WndProc:
  00834	8b 45 c4	 mov	 eax, DWORD PTR _n$6[ebp]
  00837	83 c0 01	 add	 eax, 1
  0083a	89 45 c4	 mov	 DWORD PTR _n$6[ebp], eax
$LN16@WndProc:
  0083d	81 7d c4 e8 1c
	00 00		 cmp	 DWORD PTR _n$6[ebp], 7400 ; 00001ce8H
  00844	7d 0f		 jge	 SHORT $LN15@WndProc

; 1151 : 				{
; 1152 : 					gObjViewportListCreate(n);

  00846	0f b7 45 c4	 movzx	 eax, WORD PTR _n$6[ebp]
  0084a	50		 push	 eax
  0084b	e8 00 00 00 00	 call	 ?gObjViewportListCreate@@YAXF@Z ; gObjViewportListCreate
  00850	83 c4 04	 add	 esp, 4

; 1153 : 					
; 1154 : 				}

  00853	eb df		 jmp	 SHORT $LN14@WndProc
$LN15@WndProc:

; 1155 : 				
; 1156 : 				for( n=0; n<MAX_OBJECT; n++)

  00855	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _n$6[ebp], 0
  0085c	eb 09		 jmp	 SHORT $LN19@WndProc
$LN17@WndProc:
  0085e	8b 45 c4	 mov	 eax, DWORD PTR _n$6[ebp]
  00861	83 c0 01	 add	 eax, 1
  00864	89 45 c4	 mov	 DWORD PTR _n$6[ebp], eax
$LN19@WndProc:
  00867	81 7d c4 e8 1c
	00 00		 cmp	 DWORD PTR _n$6[ebp], 7400 ; 00001ce8H
  0086e	7d 0f		 jge	 SHORT $LN18@WndProc

; 1157 : 					gObjViewportListProtocol(n);

  00870	0f b7 45 c4	 movzx	 eax, WORD PTR _n$6[ebp]
  00874	50		 push	 eax
  00875	e8 00 00 00 00	 call	 ?gObjViewportListProtocol@@YAXF@Z ; gObjViewportListProtocol
  0087a	83 c4 04	 add	 esp, 4
  0087d	eb df		 jmp	 SHORT $LN17@WndProc
$LN18@WndProc:

; 1158 : 
; 1159 : #ifdef PERSONAL_SHOP_20040113	// 개인상점 뷰포트 재구축 및 추가된 상점 리스트 보냄 (삭제는 위에서 하므로 여기서는 않해도 됨)
; 1160 : 				if (gDoPShopOpen) {

  0087f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  00886	74 6c		 je	 SHORT $LN106@WndProc

; 1161 : 					for( n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++) {

  00888	c7 45 c4 00 19
	00 00		 mov	 DWORD PTR _n$6[ebp], 6400 ; 00001900H
  0088f	eb 09		 jmp	 SHORT $LN22@WndProc
$LN20@WndProc:
  00891	8b 45 c4	 mov	 eax, DWORD PTR _n$6[ebp]
  00894	83 c0 01	 add	 eax, 1
  00897	89 45 c4	 mov	 DWORD PTR _n$6[ebp], eax
$LN22@WndProc:
  0089a	81 7d c4 e8 1c
	00 00		 cmp	 DWORD PTR _n$6[ebp], 7400 ; 00001ce8H
  008a1	7d 0f		 jge	 SHORT $LN21@WndProc

; 1162 : 						PShop_ViewportListRegenarate(n);

  008a3	0f b7 45 c4	 movzx	 eax, WORD PTR _n$6[ebp]
  008a7	50		 push	 eax
  008a8	e8 00 00 00 00	 call	 ?PShop_ViewportListRegenarate@@YAXF@Z ; PShop_ViewportListRegenarate
  008ad	83 c4 04	 add	 esp, 4

; 1163 : 					}

  008b0	eb df		 jmp	 SHORT $LN20@WndProc
$LN21@WndProc:

; 1164 : 					for( n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++) {

  008b2	c7 45 c4 00 19
	00 00		 mov	 DWORD PTR _n$6[ebp], 6400 ; 00001900H
  008b9	eb 09		 jmp	 SHORT $LN25@WndProc
$LN23@WndProc:
  008bb	8b 45 c4	 mov	 eax, DWORD PTR _n$6[ebp]
  008be	83 c0 01	 add	 eax, 1
  008c1	89 45 c4	 mov	 DWORD PTR _n$6[ebp], eax
$LN25@WndProc:
  008c4	81 7d c4 e8 1c
	00 00		 cmp	 DWORD PTR _n$6[ebp], 7400 ; 00001ce8H
  008cb	7d 27		 jge	 SHORT $LN106@WndProc

; 1165 : 						if (gObjIsConnected(n)) {

  008cd	8b 45 c4	 mov	 eax, DWORD PTR _n$6[ebp]
  008d0	50		 push	 eax
  008d1	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  008d6	83 c4 04	 add	 esp, 4
  008d9	85 c0		 test	 eax, eax
  008db	74 15		 je	 SHORT $LN107@WndProc

; 1166 : 							gObj[n].m_bPShopItemChange = false;

  008dd	69 45 c4 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$6[ebp], 7072
  008e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008ea	c6 84 01 fa 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3322], 0
$LN107@WndProc:

; 1167 : 						}
; 1168 : 					}

  008f2	eb c7		 jmp	 SHORT $LN23@WndProc
$LN106@WndProc:

; 1169 : 				}
; 1170 : #endif
; 1171 : 
; 1172 : #ifdef ADD_NEW_UNION_01_20041006 // 연합 정보 TimeStamp Check 및 처리!
; 1173 : 				for( n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++) 
; 1174 : 				{
; 1175 : 					gObjUnionUpdateProc(n);
; 1176 : 				}	
; 1177 : #endif
; 1178 : 
; 1179 : #ifdef CHN_PLAYTIME_LIMIT_SYSTEM_20050818	// 중국변경> . 시간마다 사용자에게 남은 시간에 대한 공지를 한다.
; 1180 : 	#ifdef MODIFY_PLAYTIME_LIMIT_MESSAGE_ONOFF_20060427
; 1181 : 				if( g_bChnPlayTimeLimitOn == TRUE )
; 1182 : 	#endif
; 1183 : 				{
; 1184 : 					INT iTickGap;
; 1185 : 					INT iCheckTick;
; 1186 : 					for( n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++) 
; 1187 : 					{
; 1188 : 						if (gObjIsConnected(n))
; 1189 : 						{
; 1190 : 	#ifdef MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 1191 : 								// 성인 인증을 받은 사용자는 다른 공지가 필요 없다.
; 1192 : 								if( gObj[n].m_iVerifyType != PLAYTIME_LIMIT_VERIFY_ADULT )
; 1193 : 								{
; 1194 : 									PMSG_NOTICE	pNotice;
; 1195 : 									CHAR szNotice[256] = {0,};
; 1196 : 
; 1197 : 		#ifdef MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_02_20080218
; 1198 : 									gObj[n].m_iPlayTimeLimit++;
; 1199 : 									gObj[n].m_dwPlayTick = GetTickCount();
; 1200 : 
; 1201 : 									if( gObj[n].m_iPlayTimeLimit == ( 60 * 60 ) )			// 한시간 지남
; 1202 : 									{
; 1203 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1204 : 										wsprintf(szNotice, lMsg.Get(1260)		// "누적 접속 시간이 이미 1시간이 되었습니다"
; 1205 : 											);
; 1206 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1207 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1208 : 									}
; 1209 : 									else if( gObj[n].m_iPlayTimeLimit == ( 3 * 60 * 60 ) )	// 3시간 지남
; 1210 : 									{
; 1211 : 										// 3시간 경과
; 1212 : 										gObj[n].m_iPlayNoticeTick = GetTickCount();
; 1213 : 
; 1214 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1215 : 										wsprintf(szNotice, lMsg.Get(1261)		// "누적 접속 시간이 이미 3시간이 되었습니다....(생략)"
; 1216 : 											);
; 1217 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1218 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1219 : 									}
; 1220 : 									else if( gObj[n].m_iPlayTimeLimit == ( 5 * 60 * 60 ) )	// 5시간 지남
; 1221 : 									{
; 1222 : 										gObj[n].m_iPlayNoticeTick = GetTickCount();
; 1223 : 
; 1224 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1225 : 										wsprintf(szNotice, lMsg.Get(1262)		// "당신의 게임 시간이 이미 건전하지 못한 수준이 되었습니다....(생략)"
; 1226 : 											);
; 1227 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1228 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1229 : 									}
; 1230 : 
; 1231 : 									if( GetTickCount() - gObj[n].m_iPlayNoticeTick >= ( 15 * 60 * 1000 ) )
; 1232 : 									{
; 1233 : 										gObj[n].m_iPlayNoticeTick = GetTickCount();
; 1234 : 
; 1235 : 										PMSG_NOTICE	pNotice;
; 1236 : 										CHAR szNotice[256] = {0,};
; 1237 : 
; 1238 : 										if( gObj[n].m_iPlayTimeLimit >= 5*60*60)
; 1239 : 										{
; 1240 : 											// 5시간 경과
; 1241 : 											TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1242 : 											wsprintf(szNotice, lMsg.Get(1262)		// "당신의 게임 시간이 이미 건전하지 못한 수준이 되었습니다....(생략)"
; 1243 : 												);
; 1244 : 											TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1245 : 											TNotice::SendNoticeToUser( n, &pNotice );
; 1246 : 										}
; 1247 : 										else if( gObj[n].m_iPlayTimeLimit >= 3*60*60)
; 1248 : 										{
; 1249 : 											// 3시간 경과
; 1250 : 											TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1251 : 											wsprintf(szNotice, lMsg.Get(1261)		// "누적 접속 시간이 이미 3시간이 되었습니다....(생략)"
; 1252 : 												);
; 1253 : 											TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1254 : 											TNotice::SendNoticeToUser( n, &pNotice );
; 1255 : 										}
; 1256 : 									}
; 1257 : 		#else
; 1258 : 									gObj[n].m_iPlayTimeLimit += iTickGap;
; 1259 : 									gObj[n].m_dwPlayTick = GetTickCount();
; 1260 : 
; 1261 : 									if( gObj[n].m_iPlayTimeLimit >= 5*60*60)		// 5시간 지남
; 1262 : 									{
; 1263 : 										iCheckTick = 15*60*1000;					// 15분 마다 메시지 전송
; 1264 : 									}
; 1265 : 									else if( gObj[n].m_iPlayTimeLimit >= 3*60*60)	// 3시간 지남
; 1266 : 									{
; 1267 : 										iCheckTick = 30*60*1000;					// 30분 마다 메시지 전송
; 1268 : 									}
; 1269 : 
; 1270 : 									if( gObj[n].m_iPlayTimeLimit == ( 60 * 60 ) )			// 한시간 지남
; 1271 : 									{
; 1272 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1273 : 										wsprintf(szNotice, lMsg.Get(1260)		// "누적 접속 시간이 이미 1시간이 되었습니다"
; 1274 : 											);
; 1275 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1276 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1277 : 									}
; 1278 : 									else if( gObj[n].m_iPlayTimeLimit == ( 3 * 60 * 60 ) )	// 3시간 지남
; 1279 : 									{
; 1280 : 										// 3시간 경과
; 1281 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1282 : 										wsprintf(szNotice, lMsg.Get(1261)		// "누적 접속 시간이 이미 3시간이 되었습니다....(생략)"
; 1283 : 											);
; 1284 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1285 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1286 : 									}
; 1287 : 									else if( gObj[n].m_iPlayTimeLimit == ( 5 * 60 * 60 ) )	// 5시간 지남
; 1288 : 									{
; 1289 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1290 : 										wsprintf(szNotice, lMsg.Get(1262)		// "당신의 게임 시간이 이미 건전하지 못한 수준이 되었습니다....(생략)"
; 1291 : 											);
; 1292 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1293 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1294 : 									}
; 1295 : 
; 1296 : 									// 중국추가> . 시간마다 사용자에게 남은 시간에 대한 공지를 한다.
; 1297 : 									if (GetTickCount() - gObj[n].m_iPlayNoticeTick >= iCheckTick)
; 1298 : 									{
; 1299 : 										gObj[n].m_iPlayNoticeTick = GetTickCount();
; 1300 : 
; 1301 : 										PMSG_NOTICE	pNotice;
; 1302 : 										CHAR szNotice[256] = {0,};
; 1303 : 										if( gObj[n].m_iPlayTimeLimit >= 5*60*60)
; 1304 : 										{
; 1305 : 											// 5시간 경과
; 1306 : 											TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1307 : 											wsprintf(szNotice, lMsg.Get(1262)		// "당신의 게임 시간이 이미 건전하지 못한 수준이 되었습니다....(생략)"
; 1308 : 												);
; 1309 : 											TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1310 : 											TNotice::SendNoticeToUser( n, &pNotice );
; 1311 : 										}
; 1312 : 										else if( gObj[n].m_iPlayTimeLimit >= 3*60*60)
; 1313 : 										{
; 1314 : 											// 3시간 경과
; 1315 : 											TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1316 : 											wsprintf(szNotice, lMsg.Get(1261)		// "누적 접속 시간이 이미 3시간이 되었습니다....(생략)"
; 1317 : 												);
; 1318 : 											TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1319 : 											TNotice::SendNoticeToUser( n, &pNotice );
; 1320 : 										}
; 1321 : 										/*else if( gObj[n].m_iPlayTimeLimit >= 60*60 )
; 1322 : 										{
; 1323 : 											// 1시간 경과
; 1324 : 											TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1325 : 											wsprintf(szNotice, lMsg.Get(1260)		// "누적 접속 시간이 이미 1시간이 되었습니다"
; 1326 : 												);
; 1327 : 											TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1328 : 											TNotice::SendNoticeToUser( n, &pNotice );
; 1329 : 										}*/
; 1330 : 									}
; 1331 : 		#endif // MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_02_20080218
; 1332 : 								}
; 1333 : 	#else
; 1334 : 								gObj[n].m_iPlayTimeLimit += iTickGap;
; 1335 : 								gObj[n].m_dwPlayTick = GetTickCount();
; 1336 : 
; 1337 : 								if (gObj[n].m_iPlayTimeLimit >= 5*60*60) {
; 1338 : 									iCheckTick = 15*60*1000;
; 1339 : 								}
; 1340 : 								else if (gObj[n].m_iPlayTimeLimit >= 3*60*60) {
; 1341 : 									iCheckTick = 30*60*1000;
; 1342 : 								}
; 1343 : 								else {
; 1344 : 									iCheckTick = 60*60*1000;
; 1345 : 								}
; 1346 : 
; 1347 : 								// 중국추가> . 시간마다 사용자에게 남은 시간에 대한 공지를 한다.
; 1348 : 								if (GetTickCount() - gObj[n].m_iPlayNoticeTick >= iCheckTick)
; 1349 : 								{
; 1350 : 									gObj[n].m_iPlayNoticeTick = GetTickCount();
; 1351 : 
; 1352 : 									PMSG_NOTICE	pNotice;
; 1353 : 									CHAR szNotice[256] = {0,};
; 1354 : 									if (gObj[n].m_iPlayTimeLimit >= 5*60*60) {
; 1355 : 										// 유해시간
; 1356 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1357 : 										wsprintf(szNotice, lMsg.Get(1258),		// "유해시간입니다. 게임내 수익 0%%. 잔여 플레이시간:%02d시%02d분"
; 1358 : 											0,
; 1359 : 											0
; 1360 : 	//										((5*60*60)-gObj[n].m_iPlayTimeLimit)/(60*60),
; 1361 : 	//										(((5*60*60)-gObj[n].m_iPlayTimeLimit)%(60*60))/60
; 1362 : 											);
; 1363 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1364 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1365 : 									}
; 1366 : 									else if (gObj[n].m_iPlayTimeLimit >= 3*60*60) {
; 1367 : 										// 피로시간
; 1368 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1369 : 										wsprintf(szNotice, lMsg.Get(1257),		// "피로시간입니다. 게임내 수익 50%%. 잔여 플레이시간:%02d시%02d분"
; 1370 : 											((5*60*60)-gObj[n].m_iPlayTimeLimit)/(60*60),
; 1371 : 											(((5*60*60)-gObj[n].m_iPlayTimeLimit)%(60*60))/60
; 1372 : 											);
; 1373 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1374 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1375 : 									}
; 1376 : 									else {
; 1377 : 										// 정상시간
; 1378 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1379 : 										wsprintf(szNotice, lMsg.Get(1256),		// "플레이시간:%02d시%02d분, 잔여 플레이시간:%02d시%02d분"
; 1380 : 											gObj[n].m_iPlayTimeLimit/(60*60),
; 1381 : 											(gObj[n].m_iPlayTimeLimit%(60*60))/60,
; 1382 : 											((5*60*60)-gObj[n].m_iPlayTimeLimit)/(60*60),
; 1383 : 											(((5*60*60)-gObj[n].m_iPlayTimeLimit)%(60*60))/60
; 1384 : 											);
; 1385 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, szNotice);
; 1386 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1387 : 									}
; 1388 : 								}
; 1389 : 	#endif // MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 1390 : #if 0 //중국 디파인으로 빌드 안됨 "}" 하나더 추가된것 같아서 제거함
; 1391 : 							}
; 1392 : #endif
; 1393 : 						}
; 1394 : 					}
; 1395 : 				}
; 1396 : #endif
; 1397 : 				
; 1398 : #ifdef VTM_PLAYTIME_LIMIT_SYSTEM_20060626 // 베트남 : 피로도 공지
; 1399 : 				
; 1400 : 				if( g_bVtmPlayTimeLimitOn == TRUE )
; 1401 : 				{
; 1402 : 					INT iTickGap;	// (sec)
; 1403 : 					INT iCheckTick;	// (ms)
; 1404 : 					for( n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++) 
; 1405 : 					{
; 1406 : 						if (gObjIsConnected(n)) 
; 1407 : 						{
; 1408 : 							iTickGap = (GetTickCount() - gObj[n].m_dwPlayTick)/1000;
; 1409 : 							
; 1410 : 							if (iTickGap >= 1) 
; 1411 : 							{
; 1412 : 								gObj[n].m_iPlayTimeLimit += iTickGap;
; 1413 : 								gObj[n].m_dwPlayTick = GetTickCount();
; 1414 : 
; 1415 : 								// 5 시간 이상 (sec)
; 1416 : 								if (gObj[n].m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel2Time*60) 
; 1417 : 								{
; 1418 : 									// 15분 마다 공지 (ms)
; 1419 : 									iCheckTick = g_iVtmPlayTimeLimitLevel2NoticeTime*60*1000;	
; 1420 : 								}
; 1421 : 								// 3 시간 이상 (sec)
; 1422 : 								else if (gObj[n].m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel1Time*60) 
; 1423 : 								{
; 1424 : 									// 30분 마다 공지 (ms)
; 1425 : 									iCheckTick = g_iVtmPlayTimeLimitLevel1NoticeTime*60*1000;
; 1426 : 								}
; 1427 : 								else 
; 1428 : 								{
; 1429 : 									// 60분 마다 공지 (ms)
; 1430 : 									iCheckTick = g_iVtmPlayTimeLimitNoticeTime*60*1000;
; 1431 : 								}
; 1432 : 
; 1433 : 								// (ms) 시간마다 사용자에게 남은 시간에 대한 공지를 한다.
; 1434 : 								if (GetTickCount() - gObj[n].m_iPlayNoticeTick >= iCheckTick) 
; 1435 : 								{
; 1436 : 									gObj[n].m_iPlayNoticeTick = GetTickCount();
; 1437 : 
; 1438 : 									PMSG_NOTICE	pNotice;
; 1439 : 	
; 1440 : 									// (sec)
; 1441 : 									if (gObj[n].m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel2Time*60 ) 
; 1442 : 									{
; 1443 : 										// 유해시간 공지 "이제부터는 경험치 및 아이템을 습득할 수 없습니다."
; 1444 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1445 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, lMsg.Get(1273));
; 1446 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1447 : 									}
; 1448 : 									else if (gObj[n].m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel1Time*60) 
; 1449 : 									{
; 1450 : 										// 피로시간 공지 "이제부터는 경험치 및 아이템 드롭이 50%로 적용됩니다."
; 1451 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1452 : 										TNotice::MakeNoticeMsg( &pNotice, TNOTICE_PRIORITY_LV1, lMsg.Get(1271));
; 1453 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1454 : 									}
; 1455 : 									else 
; 1456 : 									{
; 1457 : 										// 정상시간 공지 
; 1458 : 										INT iCalcRestTime = (g_iVtmPlayTimeLimitLevel2Time*60)-gObj[n].m_iPlayRestTime;
; 1459 : 										TNotice::SetNoticeProperty(&pNotice, TNOTICE_PRIORITY_LV1, TNOTICE_COLOR_RED);
; 1460 : 										// "현재 플레이 시간은 %d시 %d분이며, 초기화까지 %d시 %d분의 휴식이 필요합니다."
; 1461 : 										TNotice::MakeNoticeMsgEx( &pNotice, TNOTICE_PRIORITY_LV1, lMsg.Get(1270), 
; 1462 : 											gObj[n].m_iPlayTimeLimit/(60*60), (gObj[n].m_iPlayTimeLimit%(60*60))/60,
; 1463 : 											iCalcRestTime/(60*60), (iCalcRestTime%(60*60))/60 );
; 1464 : 										TNotice::SendNoticeToUser( n, &pNotice );
; 1465 : 									}
; 1466 : 								}
; 1467 : 
; 1468 : 							}
; 1469 : 						}
; 1470 : 					}
; 1471 : 				}
; 1472 : #endif // VTM_PLAYTIME_LIMIT_SYSTEM_20060626
; 1473 : 				
; 1474 : 				gObjSetState();

  008f4	e8 00 00 00 00	 call	 ?gObjSetState@@YAXXZ	; gObjSetState

; 1475 : 				
; 1476 : 				GameServerInfoSend();

  008f9	e8 00 00 00 00	 call	 ?GameServerInfoSend@@YAXXZ ; GameServerInfoSend

; 1477 : 				//LogAdd("Server info send");
; 1478 : 
; 1479 : #ifdef GAMESERVER_INFO_EXTENDED_20040625	
; 1480 : 				GameServerExtInfoSend();	// 접속서버에 게임서버 추가적인 정보 보냄
; 1481 : #endif
; 1482 : 								
; 1483 : 				}
; 1484 : 				break;

  008fe	e9 bc 01 00 00	 jmp	 $LN6@WndProc
$LN108@WndProc:

; 1485 : 			case 1000 :
; 1486 : 
; 1487 : 				{
; 1488 : 				for( int n=0; n<g_TerrainManager.Size(); n++)

  00903	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _n$5[ebp], 0
  0090a	eb 09		 jmp	 SHORT $LN28@WndProc
$LN26@WndProc:
  0090c	8b 45 c0	 mov	 eax, DWORD PTR _n$5[ebp]
  0090f	83 c0 01	 add	 eax, 1
  00912	89 45 c0	 mov	 DWORD PTR _n$5[ebp], eax
$LN28@WndProc:
  00915	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  0091a	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  0091f	39 45 c0	 cmp	 DWORD PTR _n$5[ebp], eax
  00922	7d 14		 jge	 SHORT $LN27@WndProc

; 1489 : 				{
; 1490 : 					MapC[n].WeatherVariationProcess();

  00924	69 4d c0 8c 04
	05 00		 imul	 ecx, DWORD PTR _n$5[ebp], 328844
  0092b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00931	e8 00 00 00 00	 call	 ?WeatherVariationProcess@MapClass@@QAEXXZ ; MapClass::WeatherVariationProcess

; 1491 : 				}

  00936	eb d4		 jmp	 SHORT $LN26@WndProc
$LN27@WndProc:

; 1492 : 				wsGServer.m_SendSec = wsGServer.m_SendSecTmp;

  00938	a1 20 00 00 00	 mov	 eax, DWORD PTR ?wsGServer@@3VCwsGameServer@@A+32
  0093d	a3 1c 00 00 00	 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+28, eax

; 1493 : 				wsGServer.m_RecvSec = wsGServer.m_RecvSecTmp;

  00942	a1 28 00 00 00	 mov	 eax, DWORD PTR ?wsGServer@@3VCwsGameServer@@A+40
  00947	a3 24 00 00 00	 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+36, eax

; 1494 : 				wsGServer.m_SendSecTmp = 0;

  0094c	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+32, 0

; 1495 : 				wsGServer.m_RecvSecTmp = 0;	

  00956	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+40, 0

; 1496 : 				DragonEvent->Run();

  00960	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00966	e8 00 00 00 00	 call	 ?Run@CDragonEvent@@QAEXXZ ; CDragonEvent::Run

; 1497 : 				AttackEvent->Run();

  0096b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AttackEvent@@3PAVCAttackEvent@@A ; AttackEvent
  00971	e8 00 00 00 00	 call	 ?Run@CAttackEvent@@QAEXXZ ; CAttackEvent::Run

; 1498 : #ifdef ELEGORADO_EVENT
; 1499 : 				gEledoradoEvent.Run();

  00976	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  0097b	e8 00 00 00 00	 call	 ?Run@CEledoradoEvent@@QAEXXZ ; CEledoradoEvent::Run

; 1500 : #endif
; 1501 : 
; 1502 : #ifdef EVENT_MANAGEMENT_20040711
; 1503 : 				g_EventManager.Run();

  00980	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventManager@@3VCEventManagement@@A ; g_EventManager
  00985	e8 00 00 00 00	 call	 ?Run@CEventManagement@@QAEXXZ ; CEventManagement::Run

; 1504 : #endif
; 1505 : 
; 1506 : 				//g_VIPSystem.ProcessVIP();
; 1507 : 
; 1508 : #ifdef __HAPPYHOUR_H__
; 1509 : 				g_HappyHour.Process();
; 1510 : #endif
; 1511 : 				}
; 1512 : 				break;

  0098a	e9 30 01 00 00	 jmp	 $LN6@WndProc
$LN109@WndProc:

; 1513 : 			case MTIME_SECOND :
; 1514 : 				{				
; 1515 : 					srand(time(NULL));

  0098f	6a 00		 push	 0
  00991	e8 00 00 00 00	 call	 _time
  00996	83 c4 04	 add	 esp, 4
  00999	50		 push	 eax
  0099a	e8 00 00 00 00	 call	 _srand
  0099f	83 c4 04	 add	 esp, 4

; 1516 : 				if( gCloseMsg )

  009a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCloseMsg@@3HA, 0 ; gCloseMsg
  009a9	0f 84 e2 00 00
	00		 je	 $LN110@WndProc

; 1517 : 				{					
; 1518 : 					gCloseMsgTime--;

  009af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gCloseMsgTime@@3HA ; gCloseMsgTime
  009b4	83 e8 01	 sub	 eax, 1
  009b7	a3 00 00 00 00	 mov	 DWORD PTR ?gCloseMsgTime@@3HA, eax ; gCloseMsgTime

; 1519 : 					if( gCloseMsgTime <= 1 )

  009bc	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gCloseMsgTime@@3HA, 1 ; gCloseMsgTime
  009c3	7f 40		 jg	 SHORT $LN111@WndProc

; 1520 : 					{						
; 1521 : 						if( gCloseMsgTime == 1 )

  009c5	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gCloseMsgTime@@3HA, 1 ; gCloseMsgTime
  009cc	75 35		 jne	 SHORT $LN113@WndProc

; 1522 : 						{
; 1523 : 							AllSendServerMsg(lMsg.Get(449));

  009ce	68 c1 01 00 00	 push	 449			; 000001c1H
  009d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  009d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  009de	50		 push	 eax
  009df	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  009e4	83 c4 04	 add	 esp, 4

; 1524 : 							LogAddC(LOGC_RED, lMsg.Get(449));

  009e7	68 c1 01 00 00	 push	 449			; 000001c1H
  009ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  009f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  009f7	50		 push	 eax
  009f8	6a 02		 push	 2
  009fa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00a00	83 c4 08	 add	 esp, 8
$LN113@WndProc:

; 1525 : 						}
; 1526 : 					}

  00a03	eb 59		 jmp	 SHORT $LN112@WndProc
$LN111@WndProc:

; 1527 : 					else
; 1528 : 					{
; 1529 : 						if((gCloseMsgTime%10) == 0 )

  00a05	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gCloseMsgTime@@3HA ; gCloseMsgTime
  00a0a	99		 cdq
  00a0b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00a10	f7 f9		 idiv	 ecx
  00a12	85 d2		 test	 edx, edx
  00a14	75 48		 jne	 SHORT $LN112@WndProc

; 1530 : 						{
; 1531 : 							char szTemp[256];
; 1532 : 							wsprintf(szTemp,lMsg.Get(450), gCloseMsgTime);

  00a16	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gCloseMsgTime@@3HA ; gCloseMsgTime
  00a1b	50		 push	 eax
  00a1c	68 c2 01 00 00	 push	 450			; 000001c2H
  00a21	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00a26	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00a2c	50		 push	 eax
  00a2d	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$4[ebp]
  00a33	51		 push	 ecx
  00a34	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00a3a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1533 : 							AllSendServerMsg(szTemp);

  00a3d	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$4[ebp]
  00a43	50		 push	 eax
  00a44	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00a49	83 c4 04	 add	 esp, 4

; 1534 : 							LogAddC(LOGC_RED, szTemp);

  00a4c	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$4[ebp]
  00a52	50		 push	 eax
  00a53	6a 02		 push	 2
  00a55	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00a5b	83 c4 08	 add	 esp, 8
$LN112@WndProc:

; 1535 : 						}
; 1536 : 					}
; 1537 : 					if( gCloseMsgTime < 0 )

  00a5e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCloseMsgTime@@3HA, 0 ; gCloseMsgTime
  00a65	7d 2a		 jge	 SHORT $LN110@WndProc

; 1538 : 					{
; 1539 : 						KillTimer(ghWnd, MTIME_SECOND);

  00a67	68 ea 03 00 00	 push	 1002			; 000003eaH
  00a6c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00a71	50		 push	 eax
  00a72	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 1540 : 						gObjAllLogOut();

  00a78	e8 00 00 00 00	 call	 ?gObjAllLogOut@@YAXXZ	; gObjAllLogOut

; 1541 : 						gCloseMsgTime = 0;

  00a7d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gCloseMsgTime@@3HA, 0 ; gCloseMsgTime

; 1542 : 						gCloseMsg = 0;

  00a87	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gCloseMsg@@3HA, 0 ; gCloseMsg
$LN110@WndProc:

; 1543 : #ifdef MODIFY_AUTHSERVER_CLOSE_20041207
; 1544 : 						gbAuthServerClosed = FALSE;
; 1545 : #endif
; 1546 : 					}
; 1547 : 				}
; 1548 : 				}
; 1549 : 				gObjSecondProc();

  00a91	e8 00 00 00 00	 call	 ?gObjSecondProc@@YAXXZ	; gObjSecondProc

; 1550 : #ifdef CASTLE_MAIN_SCHEDULER_20041111
; 1551 : 				if (cDBSMng.GetActiveDS() > -1 && g_CastleSiege.GetDataLoadState() == CASTLESIEGE_DATALOAD_2) {
; 1552 : 					if (g_CastleSiege.DataRequest()) {
; 1553 : //						g_CastleSiege.SetDataLoadState(CASTLESIEGE_DATALOAD_3);
; 1554 : 					}
; 1555 : 				}
; 1556 : 				// 초당 한번씩 성의 상태를 동기화 한다.
; 1557 : 				g_CastleSiege.SendCastleStateSync();
; 1558 : #endif
; 1559 : #ifdef MU_CASTLESIEGE_SERVER_SYNC_20041130
; 1560 : 				g_CastleSiegeSync.AdjustTributeMoney();
; 1561 : #endif
; 1562 : 				
; 1563 : #ifdef CRYWOLF_MAIN_SCHEDULER_20050505
; 1564 : 				g_Crywolf.CrywolfSecondAct();
; 1565 : #endif				
; 1566 : 				break;

  00a96	eb 27		 jmp	 SHORT $LN6@WndProc
$LN116@WndProc:

; 1567 : 			case MTIME_HOUR :
; 1568 : 				gSetDate();							// 한시간에 한번씩 날짜 데이터를 갱신 (2003.01.02)

  00a98	e8 00 00 00 00	 call	 ?gSetDate@@YAXXZ	; gSetDate

; 1569 : 				WhisperCash.TimeCheckCashDelete();	// 사실상 쓸 일이 없다.

  00a9d	b9 00 00 00 00	 mov	 ecx, OFFSET ?WhisperCash@@3VCWhisperCash@@A ; WhisperCash
  00aa2	e8 00 00 00 00	 call	 ?TimeCheckCashDelete@CWhisperCash@@QAEXXZ ; CWhisperCash::TimeCheckCashDelete

; 1570 : 				break;

  00aa7	eb 16		 jmp	 SHORT $LN6@WndProc
$LN117@WndProc:

; 1571 : 			case MTIME_MIN :						// 10초에 한번씩 접속서버와의 연결 점검
; 1572 : 				cDBSMng.Connect();

  00aa9	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00aae	e8 00 00 00 00	 call	 ?Connect@DBSockMng@@QAEXXZ ; DBSockMng::Connect

; 1573 : #ifndef ADD_NEWPVP_PKFIELD
; 1574 : #ifdef DUEL_SYSTEM_FIX_20031224
; 1575 : 				gObjCheckAllUserDuelStop();

  00ab3	e8 00 00 00 00	 call	 ?gObjCheckAllUserDuelStop@@YAXXZ ; gObjCheckAllUserDuelStop

; 1576 : #endif
; 1577 : #endif // ADD_NEWPVP_PKFIELD
; 1578 : 				break;

  00ab8	eb 05		 jmp	 SHORT $LN6@WndProc
$LN118@WndProc:

; 1579 : 			case MTIME_DAY :
; 1580 : 				if( LogDateChange() == TRUE )

  00aba	e8 00 00 00 00	 call	 ?LogDateChange@@YAHXZ	; LogDateChange
$LN6@WndProc:

; 1581 : 				{
; 1582 : #ifdef CASTLE_SPECIAL_ITEMMIX_20050425				// 하루가 지나면 성주 조합의 횟수가 원상복구된다.
; 1583 : 					g_iCastleItemMixLimit = CASTLE_ITEM_MIX_MAXCOUNT;
; 1584 : #endif
; 1585 : 				}
; 1586 : 				break;
; 1587 : 			}
; 1588 : 			break;

  00abf	e9 52 01 00 00	 jmp	 $LN2@WndProc
$LN120@WndProc:

; 1589 : 		case WM_CLOSE :
; 1590 : 				if( gLanguage != 3 )

  00ac4	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?gLanguage@@3HA, 3 ; gLanguage
  00acb	74 29		 je	 SHORT $LN121@WndProc

; 1591 : 				{
; 1592 : 					if( MessageBox(ghWnd, "GameServer close?", "Close", MB_YESNO) == IDYES ) 

  00acd	6a 04		 push	 4
  00acf	68 00 00 00 00	 push	 OFFSET ??_C@_05LGELBCGM@Close@
  00ad4	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EBEJPBOM@GameServer?5close?$DP@
  00ad9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00ade	50		 push	 eax
  00adf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00ae5	83 f8 06	 cmp	 eax, 6
  00ae8	75 0a		 jne	 SHORT $LN123@WndProc

; 1593 : 					{
; 1594 : #ifdef MODIFY_AUTHSERVER_CLOSE_20041207
; 1595 : 						if (gbAuthServerClosed == TRUE) {
; 1596 : 							SendMessageA(ghWnd, WM_COMMAND, MAKELONG(ID_MENU_ONECLOSE, 0), 0);
; 1597 : 						} 
; 1598 : 						else {
; 1599 : #endif
; 1600 : 						DestroyWindow(hWnd);

  00aea	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00aed	50		 push	 eax
  00aee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$LN123@WndProc:

; 1601 : #ifdef MODIFY_AUTHSERVER_CLOSE_20041207
; 1602 : 						}
; 1603 : #endif
; 1604 : 					}
; 1605 : 				}

  00af4	eb 0a		 jmp	 SHORT $LN122@WndProc
$LN121@WndProc:

; 1606 : 				else
; 1607 : 				{
; 1608 : 					DestroyWindow(hWnd);

  00af6	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00af9	50		 push	 eax
  00afa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$LN122@WndProc:

; 1609 : 				}
; 1610 : 			break;

  00b00	e9 11 01 00 00	 jmp	 $LN2@WndProc
$LN124@WndProc:

; 1611 : 		case WM_KEYDOWN :
; 1612 : 			switch( wParam )

  00b05	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00b08	89 85 68 fe ff
	ff		 mov	 DWORD PTR tv362[ebp], eax
  00b0e	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv362[ebp]
  00b14	83 e9 70	 sub	 ecx, 112		; 00000070H
  00b17	89 8d 68 fe ff
	ff		 mov	 DWORD PTR tv362[ebp], ecx
  00b1d	83 bd 68 fe ff
	ff 06		 cmp	 DWORD PTR tv362[ebp], 6
  00b24	0f 87 be 00 00
	00		 ja	 $LN29@WndProc
  00b2a	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv362[ebp]
  00b30	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN149@WndProc[edx*4]
$LN125@WndProc:

; 1613 : 			{
; 1614 : 			case VK_F1 :
; 1615 : 				gCurPaintPlayer--;

  00b37	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gCurPaintPlayer@@3HA ; gCurPaintPlayer
  00b3c	83 e8 01	 sub	 eax, 1
  00b3f	a3 00 00 00 00	 mov	 DWORD PTR ?gCurPaintPlayer@@3HA, eax ; gCurPaintPlayer

; 1616 : 				if( gCurPaintPlayer < 0 ) gCurPaintPlayer = 0;

  00b44	79 0a		 jns	 SHORT $LN126@WndProc
  00b46	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gCurPaintPlayer@@3HA, 0 ; gCurPaintPlayer
$LN126@WndProc:

; 1617 : 				break;

  00b50	e9 93 00 00 00	 jmp	 $LN29@WndProc
$LN127@WndProc:

; 1618 : 			case VK_F2 :
; 1619 : 				gCurPaintPlayer++;

  00b55	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gCurPaintPlayer@@3HA ; gCurPaintPlayer
  00b5a	83 c0 01	 add	 eax, 1
  00b5d	a3 00 00 00 00	 mov	 DWORD PTR ?gCurPaintPlayer@@3HA, eax ; gCurPaintPlayer

; 1620 : 				if( gCurPaintPlayer > MAX_OBJECT-1 ) gCurPaintPlayer = MAX_OBJECT-1;

  00b62	81 3d 00 00 00
	00 e7 1c 00 00	 cmp	 DWORD PTR ?gCurPaintPlayer@@3HA, 7399 ; gCurPaintPlayer, 00001ce7H
  00b6c	7e 0a		 jle	 SHORT $LN128@WndProc
  00b6e	c7 05 00 00 00
	00 e7 1c 00 00	 mov	 DWORD PTR ?gCurPaintPlayer@@3HA, 7399 ; gCurPaintPlayer, 00001ce7H
$LN128@WndProc:

; 1621 : 				break;

  00b78	eb 6e		 jmp	 SHORT $LN29@WndProc

; 1622 : 			case VK_F4 :
; 1623 : 				//GameMainServerCreate(WM_ASS_SERVERMSG, WM_ASS_CLIENTMSG);
; 1624 : 				//TestDSSend();
; 1625 : 				{
; 1626 : 				/*PMSG_IDPASS Msg;
; 1627 : 				strcpy(Msg.Id,"saemsong");
; 1628 : 				strcpy(Msg.Pass,"ssman");	
; 1629 : 				Msg.CliVersion[0] = szClientVersion[0];
; 1630 : 				Msg.CliVersion[1] = szClientVersion[1];
; 1631 : 				Msg.CliVersion[2] = szClientVersion[2];
; 1632 : 				CSPJoinIdPassRequest(&Msg, 0);
; 1633 : 				*/
; 1634 : 				}
; 1635 : 				break;

  00b7a	eb 6c		 jmp	 SHORT $LN29@WndProc
$LN130@WndProc:

; 1636 : 			case VK_F5 : 
; 1637 : 				gServerMaxUser-=10;

  00b7c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gServerMaxUser@@3HA ; gServerMaxUser
  00b81	83 e8 0a	 sub	 eax, 10			; 0000000aH
  00b84	a3 00 00 00 00	 mov	 DWORD PTR ?gServerMaxUser@@3HA, eax ; gServerMaxUser

; 1638 : 				if( gServerMaxUser < 10 ) gServerMaxUser = 10;

  00b89	83 3d 00 00 00
	00 0a		 cmp	 DWORD PTR ?gServerMaxUser@@3HA, 10 ; gServerMaxUser, 0000000aH
  00b90	7d 0a		 jge	 SHORT $LN131@WndProc
  00b92	c7 05 00 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?gServerMaxUser@@3HA, 10 ; gServerMaxUser, 0000000aH
$LN131@WndProc:

; 1639 : 				break;

  00b9c	eb 4a		 jmp	 SHORT $LN29@WndProc
$LN132@WndProc:

; 1640 : 			case VK_F6 :
; 1641 : 				gServerMaxUser+=10;

  00b9e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gServerMaxUser@@3HA ; gServerMaxUser
  00ba3	83 c0 0a	 add	 eax, 10			; 0000000aH
  00ba6	a3 00 00 00 00	 mov	 DWORD PTR ?gServerMaxUser@@3HA, eax ; gServerMaxUser

; 1642 : 				if( gServerMaxUser > 1500 ) gServerMaxUser = 1500;

  00bab	81 3d 00 00 00
	00 dc 05 00 00	 cmp	 DWORD PTR ?gServerMaxUser@@3HA, 1500 ; gServerMaxUser, 000005dcH
  00bb5	7e 0a		 jle	 SHORT $LN133@WndProc
  00bb7	c7 05 00 00 00
	00 dc 05 00 00	 mov	 DWORD PTR ?gServerMaxUser@@3HA, 1500 ; gServerMaxUser, 000005dcH
$LN133@WndProc:

; 1643 : 				break;

  00bc1	eb 25		 jmp	 SHORT $LN29@WndProc
$LN134@WndProc:

; 1644 : 			case VK_F7 :
; 1645 : 				{
; 1646 : 					PMSG_CHARMAPJOIN Msg;
; 1647 : 					strcpy(Msg.Name,"테스트");				

  00bc3	68 00 00 00 00	 push	 OFFSET ??_C@_06MMLDKFPE@?E?W?$LN?$LK?F?$KO@
  00bc8	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _Msg$3[ebp+4]
  00bce	50		 push	 eax
  00bcf	e8 00 00 00 00	 call	 _strcpy
  00bd4	83 c4 08	 add	 esp, 8

; 1648 : 					CGPCharacterMapJoinRequest(&Msg, 0);

  00bd7	6a 00		 push	 0
  00bd9	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _Msg$3[ebp]
  00bdf	50		 push	 eax
  00be0	e8 00 00 00 00	 call	 ?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ; CGPCharacterMapJoinRequest
  00be5	83 c4 08	 add	 esp, 8
$LN29@WndProc:

; 1649 : 				}
; 1650 : 				break;
; 1651 : 			case VK_F9 :				
; 1652 : 				#if( TESTSERVER == 1 )
; 1653 : 				//{
; 1654 : 					TestDSSend();
; 1655 : 				/*PMSG_IDPASS pMsg;
; 1656 : 				for( int n=0; n<100; n++)
; 1657 : 				{
; 1658 : 					CSPJoinIdPassRequestTEST(&pMsg, 0);					
; 1659 : 				}
; 1660 : 				}*/
; 1661 : 				#endif
; 1662 : 				break;
; 1663 : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_2_20070724
; 1664 : 			case VK_F11 :
; 1665 : 				DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
; 1666 : 				break;
; 1667 : #endif				
; 1668 : 			}
; 1669 : 			break;

  00be8	eb 2c		 jmp	 SHORT $LN2@WndProc
$LN136@WndProc:

; 1670 : 		case WM_DESTROY:
; 1671 : 			GameMainFree();

  00bea	e8 00 00 00 00	 call	 ?GameMainFree@@YAXXZ	; GameMainFree

; 1672 : 			GiocpDelete();

  00bef	e8 00 00 00 00	 call	 ?GiocpDelete@@YAXXZ	; GiocpDelete

; 1673 : 			PostQuitMessage(0);

  00bf4	6a 00		 push	 0
  00bf6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 1674 : 			break;

  00bfc	eb 18		 jmp	 SHORT $LN2@WndProc
$LN137@WndProc:

; 1675 : 		default:
; 1676 : 			return DefWindowProc(hWnd, message, wParam, lParam);

  00bfe	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00c01	50		 push	 eax
  00c02	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00c05	51		 push	 ecx
  00c06	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  00c09	52		 push	 edx
  00c0a	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00c0d	50		 push	 eax
  00c0e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  00c14	eb 02		 jmp	 SHORT $LN1@WndProc
$LN2@WndProc:

; 1677 :    }
; 1678 :    return 0;

  00c16	33 c0		 xor	 eax, eax
$LN1@WndProc:

; 1679 : }

  00c18	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00c1b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00c22	59		 pop	 ecx
  00c23	5f		 pop	 edi
  00c24	5e		 pop	 esi
  00c25	5b		 pop	 ebx
  00c26	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c29	33 cd		 xor	 ecx, ebp
  00c2b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c30	8b e5		 mov	 esp, ebp
  00c32	5d		 pop	 ebp
  00c33	c2 10 00	 ret	 16			; 00000010H
  00c36	66 90		 npad	 2
$LN146@WndProc:
  00c38	00 00 00 00	 DD	 $LN88@WndProc
  00c3c	00 00 00 00	 DD	 $LN89@WndProc
  00c40	00 00 00 00	 DD	 $LN137@WndProc
  00c44	00 00 00 00	 DD	 $LN95@WndProc
  00c48	00 00 00 00	 DD	 $LN137@WndProc
  00c4c	00 00 00 00	 DD	 $LN137@WndProc
  00c50	00 00 00 00	 DD	 $LN137@WndProc
  00c54	00 00 00 00	 DD	 $LN137@WndProc
  00c58	00 00 00 00	 DD	 $LN92@WndProc
  00c5c	00 00 00 00	 DD	 $LN93@WndProc
  00c60	00 00 00 00	 DD	 $LN90@WndProc
  00c64	00 00 00 00	 DD	 $LN91@WndProc
  00c68	00 00 00 00	 DD	 $LN94@WndProc
$LN147@WndProc:
  00c6c	00 00 00 00	 DD	 $LN43@WndProc
  00c70	00 00 00 00	 DD	 $LN44@WndProc
  00c74	00 00 00 00	 DD	 $LN39@WndProc
  00c78	00 00 00 00	 DD	 $LN86@WndProc
  00c7c	00 00 00 00	 DD	 $LN86@WndProc
  00c80	00 00 00 00	 DD	 $LN45@WndProc
  00c84	00 00 00 00	 DD	 $LN86@WndProc
  00c88	00 00 00 00	 DD	 $LN42@WndProc
  00c8c	00 00 00 00	 DD	 $LN35@WndProc
  00c90	00 00 00 00	 DD	 $LN36@WndProc
  00c94	00 00 00 00	 DD	 $LN37@WndProc
  00c98	00 00 00 00	 DD	 $LN86@WndProc
  00c9c	00 00 00 00	 DD	 $LN57@WndProc
  00ca0	00 00 00 00	 DD	 $LN59@WndProc
  00ca4	00 00 00 00	 DD	 $LN61@WndProc
  00ca8	00 00 00 00	 DD	 $LN46@WndProc
  00cac	00 00 00 00	 DD	 $LN40@WndProc
  00cb0	00 00 00 00	 DD	 $LN41@WndProc
  00cb4	00 00 00 00	 DD	 $LN47@WndProc
  00cb8	00 00 00 00	 DD	 $LN53@WndProc
  00cbc	00 00 00 00	 DD	 $LN50@WndProc
  00cc0	00 00 00 00	 DD	 $LN63@WndProc
  00cc4	00 00 00 00	 DD	 $LN64@WndProc
  00cc8	00 00 00 00	 DD	 $LN65@WndProc
  00ccc	00 00 00 00	 DD	 $LN86@WndProc
  00cd0	00 00 00 00	 DD	 $LN66@WndProc
  00cd4	00 00 00 00	 DD	 $LN67@WndProc
  00cd8	00 00 00 00	 DD	 $LN68@WndProc
  00cdc	00 00 00 00	 DD	 $LN86@WndProc
  00ce0	00 00 00 00	 DD	 $LN69@WndProc
  00ce4	00 00 00 00	 DD	 $LN70@WndProc
  00ce8	00 00 00 00	 DD	 $LN71@WndProc
  00cec	00 00 00 00	 DD	 $LN72@WndProc
  00cf0	00 00 00 00	 DD	 $LN73@WndProc
  00cf4	00 00 00 00	 DD	 $LN74@WndProc
  00cf8	00 00 00 00	 DD	 $LN76@WndProc
  00cfc	00 00 00 00	 DD	 $LN77@WndProc
  00d00	00 00 00 00	 DD	 $LN78@WndProc
  00d04	00 00 00 00	 DD	 $LN79@WndProc
  00d08	00 00 00 00	 DD	 $LN81@WndProc
  00d0c	00 00 00 00	 DD	 $LN82@WndProc
  00d10	00 00 00 00	 DD	 $LN83@WndProc
  00d14	00 00 00 00	 DD	 $LN80@WndProc
  00d18	00 00 00 00	 DD	 $LN84@WndProc
  00d1c	00 00 00 00	 DD	 $LN85@WndProc
  00d20	00 00 00 00	 DD	 $LN75@WndProc
  00d24	00 00 00 00	 DD	 $LN86@WndProc
  00d28	00 00 00 00	 DD	 $LN86@WndProc
  00d2c	00 00 00 00	 DD	 $LN86@WndProc
  00d30	00 00 00 00	 DD	 $LN86@WndProc
  00d34	00 00 00 00	 DD	 $LN86@WndProc
  00d38	00 00 00 00	 DD	 $LN86@WndProc
  00d3c	00 00 00 00	 DD	 $LN86@WndProc
  00d40	00 00 00 00	 DD	 $LN86@WndProc
  00d44	00 00 00 00	 DD	 $LN86@WndProc
  00d48	00 00 00 00	 DD	 $LN86@WndProc
  00d4c	00 00 00 00	 DD	 $LN56@WndProc
$LN148@WndProc:
  00d50	00 00 00 00	 DD	 $LN116@WndProc
  00d54	00 00 00 00	 DD	 $LN109@WndProc
  00d58	00 00 00 00	 DD	 $LN118@WndProc
  00d5c	00 00 00 00	 DD	 $LN104@WndProc
  00d60	00 00 00 00	 DD	 $LN103@WndProc
  00d64	00 00 00 00	 DD	 $LN102@WndProc
  00d68	00 00 00 00	 DD	 $LN117@WndProc
  00d6c	00 00 00 00	 DD	 $LN98@WndProc
$LN149@WndProc:
  00d70	00 00 00 00	 DD	 $LN125@WndProc
  00d74	00 00 00 00	 DD	 $LN127@WndProc
  00d78	00 00 00 00	 DD	 $LN29@WndProc
  00d7c	00 00 00 00	 DD	 $LN29@WndProc
  00d80	00 00 00 00	 DD	 $LN130@WndProc
  00d84	00 00 00 00	 DD	 $LN132@WndProc
  00d88	00 00 00 00	 DD	 $LN134@WndProc
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WndProc@@YGJPAUHWND__@@IIJ@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _cp$11[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Ccloseplayer@@UAE@XZ	; Ccloseplayer::~Ccloseplayer
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?WndProc@@YGJPAUHWND__@@IIJ@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 64 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-412]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WndProc@@YGJPAUHWND__@@IIJ@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WndProc@@YGJPAUHWND__@@IIJ@Z ENDP			; WndProc
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ?InitInstance@@YAHPAUHINSTANCE__@@H@Z
_TEXT	SEGMENT
_hWnd$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
?InitInstance@@YAHPAUHINSTANCE__@@H@Z PROC		; InitInstance, COMDAT

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 627  :    HWND hWnd;
; 628  : 
; 629  :    hInst = hInstance; // Store instance handle in our global variable

  00009	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0000c	a3 00 00 00 00	 mov	 DWORD PTR ?hInst@@3PAUHINSTANCE__@@A, eax ; hInst

; 630  : 
; 631  :    hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,

  00011	6a 00		 push	 0
  00013	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00022	6a 00		 push	 0
  00024	68 00 00 00 80	 push	 -2147483648		; 80000000H
  00029	68 00 00 cf 00	 push	 13565952		; 00cf0000H
  0002e	68 00 00 00 00	 push	 OFFSET ?szTitle@@3PADA	; szTitle
  00033	68 00 00 00 00	 push	 OFFSET ?szWindowClass@@3PADA ; szWindowClass
  00038	6a 00		 push	 0
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  00040	89 45 fc	 mov	 DWORD PTR _hWnd$[ebp], eax

; 632  :       CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
; 633  : 
; 634  :    if (!hWnd)

  00043	83 7d fc 00	 cmp	 DWORD PTR _hWnd$[ebp], 0
  00047	75 04		 jne	 SHORT $LN2@InitInstan

; 635  :    {
; 636  :       return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 25		 jmp	 SHORT $LN1@InitInstan
$LN2@InitInstan:

; 637  :    }
; 638  : 
; 639  :    ShowWindow(hWnd, nCmdShow);

  0004d	8b 45 0c	 mov	 eax, DWORD PTR _nCmdShow$[ebp]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00054	51		 push	 ecx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 640  :    UpdateWindow(hWnd);

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0005e	50		 push	 eax
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UpdateWindow@4

; 641  : 
; 642  :    ghWnd = hWnd;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?ghWnd@@3PAUHWND__@@A, eax ; ghWnd

; 643  :    return TRUE;

  0006d	b8 01 00 00 00	 mov	 eax, 1
$LN1@InitInstan:

; 644  : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?InitInstance@@YAHPAUHINSTANCE__@@H@Z ENDP		; InitInstance
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ?MyRegisterClass@@YAGPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_wcex$ = -48						; size = 48
_hInstance$ = 8						; size = 4
?MyRegisterClass@@YAGPAUHINSTANCE__@@@Z PROC		; MyRegisterClass, COMDAT

; 595  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 596  : 	WNDCLASSEX wcex;
; 597  : 
; 598  : 	wcex.cbSize = sizeof(WNDCLASSEX); 

  00009	c7 45 d0 30 00
	00 00		 mov	 DWORD PTR _wcex$[ebp], 48 ; 00000030H

; 599  : 
; 600  : 	wcex.style			= CS_HREDRAW | CS_VREDRAW;

  00010	c7 45 d4 03 00
	00 00		 mov	 DWORD PTR _wcex$[ebp+4], 3

; 601  : 	wcex.lpfnWndProc	= (WNDPROC)WndProc;

  00017	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _wcex$[ebp+8], OFFSET ?WndProc@@YGJPAUHWND__@@IIJ@Z ; WndProc

; 602  : 	wcex.cbClsExtra		= 0;

  0001e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _wcex$[ebp+12], 0

; 603  : 	wcex.cbWndExtra		= 0;

  00025	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _wcex$[ebp+16], 0

; 604  : 	wcex.hInstance		= hInstance;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0002f	89 45 e4	 mov	 DWORD PTR _wcex$[ebp+20], eax

; 605  : 	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_GAMESERVER);

  00032	6a 6b		 push	 107			; 0000006bH
  00034	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8
  0003e	89 45 e8	 mov	 DWORD PTR _wcex$[ebp+24], eax

; 606  : 	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);

  00041	68 00 7f 00 00	 push	 32512			; 00007f00H
  00046	6a 00		 push	 0
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorA@8
  0004e	89 45 ec	 mov	 DWORD PTR _wcex$[ebp+28], eax

; 607  : 	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);

  00051	c7 45 f0 06 00
	00 00		 mov	 DWORD PTR _wcex$[ebp+32], 6

; 608  : 	wcex.lpszMenuName	= (LPCSTR)IDC_GAMESERVER;

  00058	c7 45 f4 6d 00
	00 00		 mov	 DWORD PTR _wcex$[ebp+36], 109 ; 0000006dH

; 609  : 	wcex.lpszClassName	= szWindowClass;

  0005f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _wcex$[ebp+40], OFFSET ?szWindowClass@@3PADA ; szWindowClass

; 610  : 	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

  00066	6a 6c		 push	 108			; 0000006cH
  00068	8b 45 e4	 mov	 eax, DWORD PTR _wcex$[ebp+20]
  0006b	50		 push	 eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconA@8
  00072	89 45 fc	 mov	 DWORD PTR _wcex$[ebp+44], eax

; 611  : 
; 612  : 	return RegisterClassEx(&wcex);

  00075	8d 45 d0	 lea	 eax, DWORD PTR _wcex$[ebp]
  00078	50		 push	 eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassExA@4

; 613  : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?MyRegisterClass@@YAGPAUHINSTANCE__@@@Z ENDP		; MyRegisterClass
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FgWhatsUpDummyServer@@YAXXZ
text$yd	SEGMENT
??__FgWhatsUpDummyServer@@YAXXZ PROC			; `dynamic atexit destructor for 'gWhatsUpDummyServer'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gWhatsUpDummyServer@@3VCWhatsUpDummyServer@@A ; gWhatsUpDummyServer
  0000e	e8 00 00 00 00	 call	 ??1CWhatsUpDummyServer@@QAE@XZ ; CWhatsUpDummyServer::~CWhatsUpDummyServer
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FgWhatsUpDummyServer@@YAXXZ ENDP			; `dynamic atexit destructor for 'gWhatsUpDummyServer''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ??__EgWhatsUpDummyServer@@YAXXZ
text$di	SEGMENT
??__EgWhatsUpDummyServer@@YAXXZ PROC			; `dynamic initializer for 'gWhatsUpDummyServer'', COMDAT

; 175  : CWhatsUpDummyServer gWhatsUpDummyServer;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gWhatsUpDummyServer@@3VCWhatsUpDummyServer@@A ; gWhatsUpDummyServer
  0000e	e8 00 00 00 00	 call	 ??0CWhatsUpDummyServer@@QAE@XZ ; CWhatsUpDummyServer::CWhatsUpDummyServer
  00013	68 00 00 00 00	 push	 OFFSET ??__FgWhatsUpDummyServer@@YAXXZ ; `dynamic atexit destructor for 'gWhatsUpDummyServer''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EgWhatsUpDummyServer@@YAXXZ ENDP			; `dynamic initializer for 'gWhatsUpDummyServer''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fg_RingAttackEvent@@YAXXZ
text$yd	SEGMENT
??__Fg_RingAttackEvent@@YAXXZ PROC			; `dynamic atexit destructor for 'g_RingAttackEvent'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_RingAttackEvent@@3VCRingAttackEvent@@A ; g_RingAttackEvent
  0000e	e8 00 00 00 00	 call	 ??1CRingAttackEvent@@UAE@XZ ; CRingAttackEvent::~CRingAttackEvent
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_RingAttackEvent@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_RingAttackEvent''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ??__Eg_RingAttackEvent@@YAXXZ
text$di	SEGMENT
??__Eg_RingAttackEvent@@YAXXZ PROC			; `dynamic initializer for 'g_RingAttackEvent'', COMDAT

; 82   : CRingAttackEvent		g_RingAttackEvent;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_RingAttackEvent@@3VCRingAttackEvent@@A ; g_RingAttackEvent
  0000e	e8 00 00 00 00	 call	 ??0CRingAttackEvent@@QAE@XZ ; CRingAttackEvent::CRingAttackEvent
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_RingAttackEvent@@YAXXZ ; `dynamic atexit destructor for 'g_RingAttackEvent''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_RingAttackEvent@@YAXXZ ENDP			; `dynamic initializer for 'g_RingAttackEvent''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fg_MonsterHerdTest@@YAXXZ
text$yd	SEGMENT
??__Fg_MonsterHerdTest@@YAXXZ PROC			; `dynamic atexit destructor for 'g_MonsterHerdTest'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterHerdTest@@3VCRingMonsterHerd@@A ; g_MonsterHerdTest
  0000e	e8 00 00 00 00	 call	 ??1CRingMonsterHerd@@UAE@XZ ; CRingMonsterHerd::~CRingMonsterHerd
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_MonsterHerdTest@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_MonsterHerdTest''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ??__Eg_MonsterHerdTest@@YAXXZ
text$di	SEGMENT
??__Eg_MonsterHerdTest@@YAXXZ PROC			; `dynamic initializer for 'g_MonsterHerdTest'', COMDAT

; 81   : CRingMonsterHerd		g_MonsterHerdTest;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterHerdTest@@3VCRingMonsterHerd@@A ; g_MonsterHerdTest
  0000e	e8 00 00 00 00	 call	 ??0CRingMonsterHerd@@QAE@XZ ; CRingMonsterHerd::CRingMonsterHerd
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_MonsterHerdTest@@YAXXZ ; `dynamic atexit destructor for 'g_MonsterHerdTest''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_MonsterHerdTest@@YAXXZ ENDP			; `dynamic initializer for 'g_MonsterHerdTest''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1번 캐슬 - 축석

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1번 캐슬 - 영석

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2번 캐슬 - 축석

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2번 캐슬 - 영석

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3번 캐슬 - 축석

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3번 캐슬 - 영석

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4번 캐슬 - 축석

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4번 캐슬 - 영석

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5번 캐슬 - 축석

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5번 캐슬 - 영석

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6번 캐슬 - 축석

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6번 캐슬 - 영석

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DragonEvent.h
;	COMDAT ?GetState@CDragonEvent@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetState@CDragonEvent@@QAEEXZ PROC			; CDragonEvent::GetState, COMDAT
; _this$ = ecx

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 31   : 		return EventState;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 32   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetState@CDragonEvent@@QAEEXZ ENDP			; CDragonEvent::GetState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0CSettings@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CSettings@@QAE@XZ PROC				; CSettings::CSettings, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 30	 add	 ecx, 48			; 00000030H
  00012	e8 00 00 00 00	 call	 ??0_CDBCon@@QAE@XZ
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CSettings@@QAE@XZ ENDP				; CSettings::CSettings
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0_CDBCon@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_CDBCon@@QAE@XZ PROC					; _CDBCon::_CDBCon, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 18	 add	 ecx, 24			; 00000018H
  0001a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 30	 add	 ecx, 48			; 00000030H
  00025	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 48	 add	 ecx, 72			; 00000048H
  00030	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0_CDBCon@@QAE@XZ ENDP					; _CDBCon::_CDBCon
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TerrainManager.h
;	COMDAT ?Size@CTerrainManager@@QAE?BHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Size@CTerrainManager@@QAE?BHXZ PROC			; CTerrainManager::Size, COMDAT
; _this$ = ecx

; 22   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 		return m_iSize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 24   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Size@CTerrainManager@@QAE?BHXZ ENDP			; CTerrainManager::Size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4292 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4293 :         _Mypair._Myval2._Mysize = 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4294 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4295 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4296 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00020	c6 45 bb 00	 mov	 BYTE PTR $T1[ebp], 0
  00024	8d 45 bb	 lea	 eax, DWORD PTR $T1[ebp]
  00027	50		 push	 eax
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	6b d1 00	 imul	 edx, ecx, 0
  00030	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00039	83 c4 08	 add	 esp, 8

; 4297 :     }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -82						; size = 1
$T3 = -81						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2287 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	0f b6 45 af	 movzx	 eax, BYTE PTR $T3[ebp]
  0002f	50		 push	 eax
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2288 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00038	8d 45 ae	 lea	 eax, DWORD PTR $T2[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2289 :         _Tidy_init();

  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2290 :     }

  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2178 :         _Bxty() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2124 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 372  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 373  :         _Left = _Right;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 10		 mov	 BYTE PTR [eax], dl

; 374  :     }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1067 :     void _Alloc_proxy(const _Fake_allocator&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 535  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 536  :             return _time64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __time64
  00012	83 c4 04	 add	 esp, 4

; 537  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsscanf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 2275 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 2276 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 2277 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2175 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2176 :         return __stdio_common_vsscanf(

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00020	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00023	51		 push	 ecx
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 ___stdio_common_vsscanf
  0002c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2177 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2178 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2179 :     }

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 96   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 97   :         static unsigned __int64 _OptionsStorage;
; 98   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 99   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_serverport$ = -36					; size = 4
_hAccelTable$ = -32					; size = 4
_msg$ = -28						; size = 28
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 315  :  	// TODO: Place code here.
; 316  : 
; 317  : #ifdef ADD_MINIDUMP_20081222
; 318  : 	CMiniDump::Begin();

  00009	e8 00 00 00 00	 call	 ?Begin@CMiniDump@@SAHXZ	; CMiniDump::Begin

; 319  : #endif
; 320  : 
; 321  : #ifdef	fCHECK_CRT_DBG
; 322  : 	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
; 323  : 	_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_DEBUG);
; 324  : #endif
; 325  : 
; 326  : 	MSG msg;
; 327  : 	HACCEL hAccelTable;
; 328  : 	#if LICENCIA == 1
; 329  : 	ReadyLicense();

  0000e	e8 00 00 00 00	 call	 ?ReadyLicense@@YAXXZ	; ReadyLicense

; 330  :     #endif
; 331  : 
; 332  : #ifndef MUTEX_REMOVE
; 333  : 
; 334  : #if TESTSERVER == 0
; 335  : 	#ifndef WORLD_TOURNAMENT_EVENT_SETTING
; 336  : 		HANDLE hMutex = CreateMutex(NULL, FALSE, "WZ_MU_GS_MUTEX");
; 337  : 		if (GetLastError() == ERROR_ALREADY_EXISTS) {
; 338  : 			CloseHandle(hMutex);
; 339  : 			MessageBox (NULL, "Webzen Mu Game Server is already Running.", "Error", MB_OK | MB_ICONERROR);
; 340  : 			return 0;
; 341  : 		}
; 342  : 	#endif
; 343  : #endif
; 344  : 
; 345  : #endif
; 346  : 	
; 347  : 	// Initialize global strings
; 348  : 	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);

  00013	6a 64		 push	 100			; 00000064H
  00015	68 00 00 00 00	 push	 OFFSET ?szTitle@@3PADA	; szTitle
  0001a	6a 67		 push	 103			; 00000067H
  0001c	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadStringA@16

; 349  : 	LoadString(hInstance, IDC_GAMESERVER, szWindowClass, MAX_LOADSTRING);

  00026	6a 64		 push	 100			; 00000064H
  00028	68 00 00 00 00	 push	 OFFSET ?szWindowClass@@3PADA ; szWindowClass
  0002d	6a 6d		 push	 109			; 0000006dH
  0002f	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadStringA@16

; 350  : 	MyRegisterClass(hInstance);

  00039	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?MyRegisterClass@@YAGPAUHINSTANCE__@@@Z ; MyRegisterClass
  00042	83 c4 04	 add	 esp, 4

; 351  : 
; 352  : 	InitCommonControls();

  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitCommonControls@0

; 353  : 
; 354  : 	// Perform application initialization:
; 355  : 	if (!InitInstance (hInstance, nCmdShow)) 

  0004b	8b 45 14	 mov	 eax, DWORD PTR _nCmdShow$[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?InitInstance@@YAHPAUHINSTANCE__@@H@Z ; InitInstance
  00058	83 c4 08	 add	 esp, 8
  0005b	85 c0		 test	 eax, eax
  0005d	75 07		 jne	 SHORT $LN4@WinMain

; 356  : 	{
; 357  : 		return FALSE;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 ea 01 00 00	 jmp	 $LN1@WinMain
$LN4@WinMain:

; 358  : 	}
; 359  : 
; 360  : 	ShowWindow(ghWnd, SW_NORMAL);

  00066	6a 01		 push	 1
  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 361  : 	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_GAMESERVER);

  00074	6a 6d		 push	 109			; 0000006dH
  00076	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00079	50		 push	 eax
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadAcceleratorsA@8
  00080	89 45 e0	 mov	 DWORD PTR _hAccelTable$[ebp], eax

; 362  : 	GiocpInit();			// 단지 암호화 패킷용 버퍼 생성

  00083	e8 00 00 00 00	 call	 ?GiocpInit@@YAXXZ	; GiocpInit

; 363  : 	GameMainInit(ghWnd);	// 대부분의 정보 초기화 & 로드

  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?GameMainInit@@YAXPAUHWND__@@@Z ; GameMainInit
  00093	83 c4 04	 add	 esp, 4

; 364  : 
; 365  : 	int serverport;
; 366  : 
; 367  : #ifdef ADD_GAMESERVER_PARAMETER_20050728
; 368  : 	memset(DataServerIp2, 0, sizeof(DataServerIp2));

  00096	68 00 01 00 00	 push	 256			; 00000100H
  0009b	6a 00		 push	 0
  0009d	68 00 00 00 00	 push	 OFFSET ?DataServerIp2@@3PADA ; DataServerIp2
  000a2	e8 00 00 00 00	 call	 _memset
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 369  : 	memset(ExDbIp, 0, sizeof(ExDbIp));

  000aa	68 00 01 00 00	 push	 256			; 00000100H
  000af	6a 00		 push	 0
  000b1	68 00 00 00 00	 push	 OFFSET ?ExDbIp@@3PADA	; ExDbIp
  000b6	e8 00 00 00 00	 call	 _memset
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 370  : 	DataServerPort2	= 0;

  000be	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?DataServerPort2@@3HA, 0 ; DataServerPort2

; 371  : 	ExDbPort		= 0;

  000c8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ExDbPort@@3HA, 0 ; ExDbPort

; 372  : 	
; 373  : 	if( strlen(lpCmdLine) > 1 ) 

  000d2	8b 45 10	 mov	 eax, DWORD PTR _lpCmdLine$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _strlen
  000db	83 c4 04	 add	 esp, 4
  000de	83 f8 01	 cmp	 eax, 1
  000e1	76 3f		 jbe	 SHORT $LN5@WinMain

; 374  : 		sscanf(lpCmdLine, "%s %d %s %d %d %s %d %s %d", 

  000e3	68 00 00 00 00	 push	 OFFSET ?ExDbPort@@3HA	; ExDbPort
  000e8	68 00 00 00 00	 push	 OFFSET ?ExDbIp@@3PADA	; ExDbIp
  000ed	68 00 00 00 00	 push	 OFFSET ?DataServerPort2@@3HA ; DataServerPort2
  000f2	68 00 00 00 00	 push	 OFFSET ?DataServerIp2@@3PADA ; DataServerIp2
  000f7	8d 45 dc	 lea	 eax, DWORD PTR _serverport$[ebp]
  000fa	50		 push	 eax
  000fb	68 00 00 00 00	 push	 OFFSET ?DataServerPort@@3HA ; DataServerPort
  00100	68 00 00 00 00	 push	 OFFSET ?DataServerIp@@3PADA ; DataServerIp
  00105	68 00 00 00 00	 push	 OFFSET ?JoinServerPort@@3HA ; JoinServerPort
  0010a	68 00 00 00 00	 push	 OFFSET ?JoinServerIp@@3PADA ; JoinServerIp
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IOPIBMID@?$CFs?5?$CFd?5?$CFs?5?$CFd?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd@
  00114	8b 4d 10	 mov	 ecx, DWORD PTR _lpCmdLine$[ebp]
  00117	51		 push	 ecx
  00118	e8 00 00 00 00	 call	 _sscanf
  0011d	83 c4 2c	 add	 esp, 44			; 0000002cH
  00120	eb 45		 jmp	 SHORT $LN6@WinMain
$LN5@WinMain:

; 375  : 		JoinServerIp, 
; 376  : 		&JoinServerPort, 
; 377  : 		DataServerIp, 
; 378  : 		&DataServerPort, 
; 379  : 		&serverport,
; 380  : 		DataServerIp2, 
; 381  : 		&DataServerPort2, 
; 382  : 		ExDbIp, 
; 383  : 		&ExDbPort
; 384  : 		);
; 385  : 	else {
; 386  : 		serverport		= DEFMAPSERVERPORT;

  00122	c7 45 dc 5c da
	00 00		 mov	 DWORD PTR _serverport$[ebp], 55900 ; 0000da5cH

; 387  : 		JoinServerPort	= DEFJOINSERVERPORT;

  00129	c7 05 00 00 00
	00 a2 da 00 00	 mov	 DWORD PTR ?JoinServerPort@@3HA, 55970 ; JoinServerPort, 0000daa2H

; 388  : 		DataServerPort	= DEFDATASERVERPORT;

  00133	c7 05 00 00 00
	00 98 da 00 00	 mov	 DWORD PTR ?DataServerPort@@3HA, 55960 ; DataServerPort, 0000da98H

; 389  : 		DataServerPort2	= DEFDATASERVERPORT+2;

  0013d	c7 05 00 00 00
	00 9a da 00 00	 mov	 DWORD PTR ?DataServerPort2@@3HA, 55962 ; DataServerPort2, 0000da9aH

; 390  : 		ExDbPort		= DEFEXDBSERVERPORT;

  00147	c7 05 00 00 00
	00 62 da 00 00	 mov	 DWORD PTR ?ExDbPort@@3HA, 55906 ; ExDbPort, 0000da62H

; 391  : 		MsgBox(lMsg.Get(114));

  00151	6a 72		 push	 114			; 00000072H
  00153	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00164	83 c4 04	 add	 esp, 4
$LN6@WinMain:

; 392  : 	}
; 393  : 
; 394  : 	if (DataServerIp2[0] == 0) {

  00167	b8 01 00 00 00	 mov	 eax, 1
  0016c	6b c8 00	 imul	 ecx, eax, 0
  0016f	0f be 91 00 00
	00 00		 movsx	 edx, BYTE PTR ?DataServerIp2@@3PADA[ecx]
  00176	85 d2		 test	 edx, edx
  00178	75 17		 jne	 SHORT $LN7@WinMain

; 395  : 		memcpy (DataServerIp2, DataServerIp, sizeof(DataServerIp));

  0017a	68 00 01 00 00	 push	 256			; 00000100H
  0017f	68 00 00 00 00	 push	 OFFSET ?DataServerIp@@3PADA ; DataServerIp
  00184	68 00 00 00 00	 push	 OFFSET ?DataServerIp2@@3PADA ; DataServerIp2
  00189	e8 00 00 00 00	 call	 _memcpy
  0018e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@WinMain:

; 396  : 	}
; 397  : 	if (DataServerPort2 == 0) {

  00191	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?DataServerPort2@@3HA, 0 ; DataServerPort2
  00198	75 0a		 jne	 SHORT $LN8@WinMain

; 398  : 		DataServerPort2	= DEFDATASERVERPORT+2;

  0019a	c7 05 00 00 00
	00 9a da 00 00	 mov	 DWORD PTR ?DataServerPort2@@3HA, 55962 ; DataServerPort2, 0000da9aH
$LN8@WinMain:

; 399  : 	}
; 400  : 	if (ExDbIp[0] == 0) {

  001a4	b8 01 00 00 00	 mov	 eax, 1
  001a9	6b c8 00	 imul	 ecx, eax, 0
  001ac	0f be 91 00 00
	00 00		 movsx	 edx, BYTE PTR ?ExDbIp@@3PADA[ecx]
  001b3	85 d2		 test	 edx, edx
  001b5	75 17		 jne	 SHORT $LN9@WinMain

; 401  : 		memcpy (ExDbIp, DataServerIp, sizeof(DataServerIp));

  001b7	68 00 01 00 00	 push	 256			; 00000100H
  001bc	68 00 00 00 00	 push	 OFFSET ?DataServerIp@@3PADA ; DataServerIp
  001c1	68 00 00 00 00	 push	 OFFSET ?ExDbIp@@3PADA	; ExDbIp
  001c6	e8 00 00 00 00	 call	 _memcpy
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@WinMain:

; 402  : 	}
; 403  : 	if (ExDbPort == 0) {

  001ce	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ExDbPort@@3HA, 0 ; ExDbPort
  001d5	75 0a		 jne	 SHORT $LN10@WinMain

; 404  : 		ExDbPort		= DEFEXDBSERVERPORT;

  001d7	c7 05 00 00 00
	00 62 da 00 00	 mov	 DWORD PTR ?ExDbPort@@3HA, 55906 ; ExDbPort, 0000da62H
$LN10@WinMain:

; 405  : 	}
; 406  : 
; 407  : #else
; 408  : 	if( strlen(lpCmdLine) > 1 ) sscanf(lpCmdLine, "%s %d %s %d %d", JoinServerIp, &JoinServerPort, DataServerIp, &DataServerPort, &serverport);
; 409  : 	else {
; 410  : 		serverport		= DEFMAPSERVERPORT;
; 411  : 		JoinServerPort	= DEFJOINSERVERPORT;
; 412  : 		DataServerPort	= DEFDATASERVERPORT;
; 413  : 		MsgBox(lMsg.Get(114));
; 414  : 	}
; 415  : #endif
; 416  : 	GameServerPort = serverport;

  001e1	8b 45 dc	 mov	 eax, DWORD PTR _serverport$[ebp]
  001e4	a3 00 00 00 00	 mov	 DWORD PTR ?GameServerPort@@3HA, eax ; GameServerPort

; 417  : 
; 418  : #ifdef WHATSUP_DUMMY_SERVER
; 419  : 	gWhatsUpDummyServer.Start(ghWnd, GameServerPort+1);

  001e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GameServerPort@@3HA ; GameServerPort
  001ee	83 c0 01	 add	 eax, 1
  001f1	50		 push	 eax
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  001f8	51		 push	 ecx
  001f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gWhatsUpDummyServer@@3VCWhatsUpDummyServer@@A ; gWhatsUpDummyServer
  001fe	e8 00 00 00 00	 call	 ?Start@CWhatsUpDummyServer@@QAEHPAUHWND__@@G@Z ; CWhatsUpDummyServer::Start

; 420  : #endif
; 421  : 		
; 422  : 	AllServerStart();	// 인증, DB, 랭킹, 이벤트 서버 시작

  00203	e8 00 00 00 00	 call	 ?AllServerStart@@YAHXZ	; AllServerStart
$LN2@WinMain:

; 423  : 
; 424  : #ifdef PRINT_MAGICBOOK_ITEMINSERT_LOG
; 425  : 	char szTemp[255];
; 426  : 	wsprintf(szTemp, "몬스터 레벨\t법서\t축석\t영석\t혼석\t생석\t창석\t그외\n");
; 427  : 	LogAdd("몬스터 레벨\t법서\t축석\t영석\t혼석\t생석\t창석\t그외");
; 428  : 	OutputDebugString(szTemp);
; 429  : 
; 430  : 	for (int i = 67 ; i < 109 ; i++) {
; 431  : 
; 432  : 		wsprintf(szTemp, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
; 433  : 				 i,
; 434  : 				 g_MONITEM[i].iMagicBook,
; 435  : 				 g_MONITEM[i].iHolyGem1,
; 436  : 				 g_MONITEM[i].iHolyGem2,
; 437  : 				 g_MONITEM[i].iHolyGem3,
; 438  : 				 g_MONITEM[i].iHolyGem4,
; 439  : 				 g_MONITEM[i].iHolyGem5,
; 440  : 				 g_MONITEM[i].iETC);
; 441  : 		OutputDebugString(szTemp);
; 442  : 
; 443  : 		LogAdd("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d",
; 444  : 			i,
; 445  : 			g_MONITEM[i].iMagicBook,
; 446  : 			g_MONITEM[i].iHolyGem1,
; 447  : 			g_MONITEM[i].iHolyGem2,
; 448  : 			g_MONITEM[i].iHolyGem3,
; 449  : 			g_MONITEM[i].iHolyGem4,
; 450  : 			g_MONITEM[i].iHolyGem5,
; 451  : 			g_MONITEM[i].iETC
; 452  : 			);
; 453  : 	}
; 454  : #endif
; 455  : 	
; 456  : 	while (GetMessage(&msg, NULL, 0, 0)) 

  00208	6a 00		 push	 0
  0020a	6a 00		 push	 0
  0020c	6a 00		 push	 0
  0020e	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00211	50		 push	 eax
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageA@16
  00218	85 c0		 test	 eax, eax
  0021a	74 2c		 je	 SHORT $LN3@WinMain

; 457  : 	{
; 458  : 		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 

  0021c	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0021f	50		 push	 eax
  00220	8b 4d e0	 mov	 ecx, DWORD PTR _hAccelTable$[ebp]
  00223	51		 push	 ecx
  00224	8b 55 e4	 mov	 edx, DWORD PTR _msg$[ebp]
  00227	52		 push	 edx
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateAcceleratorA@12
  0022e	85 c0		 test	 eax, eax
  00230	75 14		 jne	 SHORT $LN11@WinMain

; 459  : 		{
; 460  : 			TranslateMessage(&msg);

  00232	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00235	50		 push	 eax
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 461  : 			DispatchMessage(&msg);

  0023c	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  0023f	50		 push	 eax
  00240	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageA@4
$LN11@WinMain:

; 462  : 		}
; 463  : 	}

  00246	eb c0		 jmp	 SHORT $LN2@WinMain
$LN3@WinMain:

; 464  : 
; 465  : #ifdef ADD_MINIDUMP_20081222
; 466  : 	CMiniDump::End();

  00248	e8 00 00 00 00	 call	 ?End@CMiniDump@@SAHXZ	; CMiniDump::End

; 467  : #endif
; 468  : 
; 469  : 	return msg.wParam;

  0024d	8b 45 ec	 mov	 eax, DWORD PTR _msg$[ebp+8]
$LN1@WinMain:

; 470  : }

  00250	5f		 pop	 edi
  00251	5e		 pop	 esi
  00252	5b		 pop	 ebx
  00253	8b e5		 mov	 esp, ebp
  00255	5d		 pop	 ebp
  00256	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\GameServer.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
