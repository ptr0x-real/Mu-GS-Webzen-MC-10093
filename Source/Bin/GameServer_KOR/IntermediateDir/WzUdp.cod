; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0WzUdp@@QAE@XZ				; WzUdp::WzUdp
PUBLIC	??1WzUdp@@UAE@XZ				; WzUdp::~WzUdp
PUBLIC	?Init@WzUdp@@QAEHXZ				; WzUdp::Init
PUBLIC	?CreateSocket@WzUdp@@QAEHXZ			; WzUdp::CreateSocket
PUBLIC	?Run@WzUdp@@QAEHXZ				; WzUdp::Run
PUBLIC	?SendData@WzUdp@@QAEHPAEK@Z			; WzUdp::SendData
PUBLIC	?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z		; WzUdp::MuProtocolParse
PUBLIC	?Close@WzUdp@@QAEHXZ				; WzUdp::Close
PUBLIC	?SendSet@WzUdp@@QAEHPADH@Z			; WzUdp::SendSet
PUBLIC	?RecvSet@WzUdp@@QAEHH@Z				; WzUdp::RecvSet
PUBLIC	?RecvThread@WzUdp@@QAEHXZ			; WzUdp::RecvThread
PUBLIC	?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z	; WzUdp::SetProtocolCore
PUBLIC	??_GWzUdp@@UAEPAXI@Z				; WzUdp::`scalar deleting destructor'
PUBLIC	?WzUdpRecvThread@@YGKPAVWzUdp@@@Z		; WzUdpRecvThread
PUBLIC	??_7WzUdp@@6B@					; WzUdp::`vftable'
PUBLIC	??_R4WzUdp@@6B@					; WzUdp::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVWzUdp@@@8				; WzUdp `RTTI Type Descriptor'
PUBLIC	??_R3WzUdp@@8					; WzUdp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2WzUdp@@8					; WzUdp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@WzUdp@@8				; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__htonl@4:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__recvfrom@24:PROC
EXTRN	__imp__gethostbyname@4:PROC
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSASendTo@36:PROC
EXTRN	__imp__WSASocketA@24:PROC
EXTRN	??_EWzUdp@@UAEPAXI@Z:PROC			; WzUdp::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@WzUdp@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@WzUdp@@8 DD FLAT:??_R0?AVWzUdp@@@8	; WzUdp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R2WzUdp@@8
rdata$r	SEGMENT
??_R2WzUdp@@8 DD FLAT:??_R1A@?0A@EA@WzUdp@@8		; WzUdp::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3WzUdp@@8
rdata$r	SEGMENT
??_R3WzUdp@@8 DD 00H					; WzUdp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWzUdp@@@8
data$r	SEGMENT
??_R0?AVWzUdp@@@8 DD FLAT:??_7type_info@@6B@		; WzUdp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWzUdp@@', 00H
data$r	ENDS
;	COMDAT ??_R4WzUdp@@6B@
rdata$r	SEGMENT
??_R4WzUdp@@6B@ DD 00H					; WzUdp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWzUdp@@@8
	DD	FLAT:??_R3WzUdp@@8
rdata$r	ENDS
;	COMDAT ??_7WzUdp@@6B@
CONST	SEGMENT
??_7WzUdp@@6B@ DD FLAT:??_R4WzUdp@@6B@			; WzUdp::`vftable'
	DD	FLAT:??_EWzUdp@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1WzUdp@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?WzUdpRecvThread@@YGKPAVWzUdp@@@Z
_TEXT	SEGMENT
_lpWzUdp$ = 8						; size = 4
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z PROC			; WzUdpRecvThread, COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 245  :     lpWzUdp->RecvThread();

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _lpWzUdp$[ebp]
  0000c	e8 00 00 00 00	 call	 ?RecvThread@WzUdp@@QAEHXZ ; WzUdp::RecvThread

; 246  : 	return TRUE;

  00011	b8 01 00 00 00	 mov	 eax, 1

; 247  : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ENDP			; WzUdpRecvThread
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GWzUdp@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GWzUdp@@UAEPAXI@Z PROC				; WzUdp::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1WzUdp@@UAE@XZ	; WzUdp::~WzUdp
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 60 08 00 00	 push	 2144			; 00000860H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GWzUdp@@UAEPAXI@Z ENDP				; WzUdp::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pc$ = 8						; size = 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z PROC		; WzUdp::SetProtocolCore, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   : 	ProtocolCore = pc;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pc$[ebp]
  00012	89 88 5c 08 00
	00		 mov	 DWORD PTR [eax+2140], ecx

; 96   : 	return TRUE;

  00018	b8 01 00 00 00	 mov	 eax, 1

; 97   : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetProtocolCore@WzUdp@@QAEHP6AXEPAEH@Z@Z ENDP		; WzUdp::SetProtocolCore
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?RecvThread@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_sender$ = -32						; size = 16
_dwSenderSize$ = -16					; size = 4
_ret$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?RecvThread@WzUdp@@QAEHXZ PROC				; WzUdp::RecvThread, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 	int			ret;
; 218  :     DWORD		dwSenderSize;
; 219  :     SOCKADDR_IN	sender;	
; 220  : 	
; 221  : 	dwSenderSize = sizeof(sender);

  00016	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _dwSenderSize$[ebp], 16 ; 00000010H
$LN2@RecvThread:

; 222  : 	while(1)

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 73		 je	 SHORT $LN1@RecvThread

; 223  : 	{		
; 224  : 		ret = recvfrom(m_Socket, (char*)m_Recvbuf+m_dwRecvOfs,

  00026	8d 45 f0	 lea	 eax, DWORD PTR _dwSenderSize$[ebp]
  00029	50		 push	 eax
  0002a	8d 4d e0	 lea	 ecx, DWORD PTR _sender$[ebp]
  0002d	51		 push	 ecx
  0002e	6a 00		 push	 0
  00030	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00033	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00038	2b 42 20	 sub	 eax, DWORD PTR [edx+32]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	03 50 20	 add	 edx, DWORD PTR [eax+32]
  00048	52		 push	 edx
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004f	52		 push	 edx
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__recvfrom@24
  00056	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 225  : 			DEFAULT_BUFFER_LENGTH-m_dwRecvOfs, 0, (SOCKADDR *)&sender, (int*)&dwSenderSize);
; 226  : 
; 227  : 		if (ret == SOCKET_ERROR)

  00059	83 7d f4 ff	 cmp	 DWORD PTR _ret$[ebp], -1
  0005d	75 02		 jne	 SHORT $LN4@RecvThread

; 228  : 		{
; 229  : 			//printf("recvfrom() failed; %d\n", WSAGetLastError());
; 230  : 		}

  0005f	eb 36		 jmp	 SHORT $LN5@RecvThread
$LN4@RecvThread:

; 231  : 		else if (ret == 0)

  00061	83 7d f4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00065	75 02		 jne	 SHORT $LN6@RecvThread

; 232  : 		{
; 233  : 		}

  00067	eb 2e		 jmp	 SHORT $LN5@RecvThread
$LN6@RecvThread:

; 234  : 		else
; 235  : 		{
; 236  : 			m_dwLength  = ret;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR _ret$[ebp]
  0006f	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 237  : 			m_dwRecvOfs += ret;

  00072	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00078	03 4d f4	 add	 ecx, DWORD PTR _ret$[ebp]
  0007b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 238  : 			MuProtocolParse(m_Recvbuf, m_dwLength);

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	83 c0 1c	 add	 eax, 28			; 0000001cH
  00087	50		 push	 eax
  00088	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0008e	52		 push	 edx
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ; WzUdp::MuProtocolParse
$LN5@RecvThread:

; 239  : 		}
; 240  : 	}

  00097	eb 84		 jmp	 SHORT $LN2@RecvThread
$LN1@RecvThread:

; 241  : }

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	33 cd		 xor	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
?RecvThread@WzUdp@@QAEHXZ ENDP				; WzUdp::RecvThread
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?RecvSet@WzUdp@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_port$ = 8						; size = 4
?RecvSet@WzUdp@@QAEHH@Z PROC				; WzUdp::RecvSet, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  : 	m_Port						= port;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _port$[ebp]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 103  :     m_SockAddr.sin_port			= htons(port);

  00015	0f b7 45 08	 movzx	 eax, WORD PTR _port$[ebp]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	66 89 81 4e 08
	00 00		 mov	 WORD PTR [ecx+2126], ax

; 104  : 	m_SockAddr.sin_family		= AF_INET;

  0002a	b8 02 00 00 00	 mov	 eax, 2
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	66 89 81 4c 08
	00 00		 mov	 WORD PTR [ecx+2124], ax

; 105  :     m_SockAddr.sin_addr.s_addr	= htonl(INADDR_ANY);

  00039	6a 00		 push	 0
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	89 81 50 08 00
	00		 mov	 DWORD PTR [ecx+2128], eax

; 106  : 	
; 107  : 	if( bind(m_Socket, (SOCKADDR *)&m_SockAddr, sizeof(m_SockAddr)) == SOCKET_ERROR )

  0004a	6a 10		 push	 16			; 00000010H
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	05 4c 08 00 00	 add	 eax, 2124		; 0000084cH
  00054	50		 push	 eax
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0005b	52		 push	 edx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12
  00062	83 f8 ff	 cmp	 eax, -1
  00065	75 04		 jne	 SHORT $LN2@RecvSet

; 108  :     {		
; 109  : 		return FALSE;

  00067	33 c0		 xor	 eax, eax
  00069	eb 2e		 jmp	 SHORT $LN1@RecvSet
$LN2@RecvSet:

; 110  :     }
; 111  : 	
; 112  : 	m_Recvbuf = (LPBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwLength);

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00071	51		 push	 ecx
  00072	6a 08		 push	 8
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  00081	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00084	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 113  :     if (!m_Recvbuf)

  00087	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0008e	75 04		 jne	 SHORT $LN3@RecvSet

; 114  :     {        
; 115  :         return FALSE;

  00090	33 c0		 xor	 eax, eax
  00092	eb 05		 jmp	 SHORT $LN1@RecvSet
$LN3@RecvSet:

; 116  :     }
; 117  : 	return TRUE;

  00094	b8 01 00 00 00	 mov	 eax, 1
$LN1@RecvSet:

; 118  : }

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
?RecvSet@WzUdp@@QAEHH@Z ENDP				; WzUdp::RecvSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?SendSet@WzUdp@@QAEHPADH@Z
_TEXT	SEGMENT
tv75 = -76						; size = 4
_host$1 = -8						; size = 4
_this$ = -4						; size = 4
_ip$ = 8						; size = 4
_port$ = 12						; size = 4
?SendSet@WzUdp@@QAEHPADH@Z PROC				; WzUdp::SendSet, COMDAT
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 	m_Port					= port;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _port$[ebp]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 75   :     m_SockAddr.sin_family	= AF_INET;

  00015	b8 02 00 00 00	 mov	 eax, 2
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	66 89 81 4c 08
	00 00		 mov	 WORD PTR [ecx+2124], ax

; 76   :     m_SockAddr.sin_port		= htons(port);

  00024	0f b7 45 0c	 movzx	 eax, WORD PTR _port$[ebp]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	66 89 81 4e 08
	00 00		 mov	 WORD PTR [ecx+2126], ax

; 77   : 	if( (m_SockAddr.sin_addr.s_addr	= inet_addr(ip)) == INADDR_NONE )

  00039	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  00043	89 45 b4	 mov	 DWORD PTR tv75[ebp], eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 55 b4	 mov	 edx, DWORD PTR tv75[ebp]
  0004c	89 91 50 08 00
	00		 mov	 DWORD PTR [ecx+2128], edx
  00052	83 7d b4 ff	 cmp	 DWORD PTR tv75[ebp], -1
  00056	75 4c		 jne	 SHORT $LN2@SendSet

; 78   : 	{
; 79   : 		struct hostent *host=NULL;

  00058	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _host$1[ebp], 0

; 80   : 		host = gethostbyname(ip);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4
  00069	89 45 f8	 mov	 DWORD PTR _host$1[ebp], eax

; 81   : 		if( host )

  0006c	83 7d f8 00	 cmp	 DWORD PTR _host$1[ebp], 0
  00070	74 2e		 je	 SHORT $LN3@SendSet

; 82   : 		{
; 83   : 			CopyMemory(&m_SockAddr.sin_addr, host->h_addr_list[0], host->h_length);

  00072	8b 45 f8	 mov	 eax, DWORD PTR _host$1[ebp]
  00075	0f bf 48 0a	 movsx	 ecx, WORD PTR [eax+10]
  00079	51		 push	 ecx
  0007a	ba 04 00 00 00	 mov	 edx, 4
  0007f	6b c2 00	 imul	 eax, edx, 0
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _host$1[ebp]
  00085	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00088	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0008b	50		 push	 eax
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	81 c1 50 08 00
	00		 add	 ecx, 2128		; 00000850H
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _memcpy
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   : 		}

  0009e	eb 04		 jmp	 SHORT $LN2@SendSet
$LN3@SendSet:

; 85   : 		else
; 86   : 		{		
; 87   : 			return FALSE;

  000a0	33 c0		 xor	 eax, eax
  000a2	eb 05		 jmp	 SHORT $LN1@SendSet
$LN2@SendSet:

; 88   : 		}
; 89   : 	}
; 90   : 	return TRUE;

  000a4	b8 01 00 00 00	 mov	 eax, 1
$LN1@SendSet:

; 91   : }

  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?SendSet@WzUdp@@QAEHPADH@Z ENDP				; WzUdp::SendSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?Close@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Close@WzUdp@@QAEHXZ PROC				; WzUdp::Close, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	TerminateThread(m_ThreadHandle, 0);

  0000c	6a 00		 push	 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00014	51		 push	 ecx
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 46   : 	if( m_ThreadHandle != NULL )

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00022	74 26		 je	 SHORT $LN2@Close

; 47   : 	{
; 48   : 		WaitForSingleObject( m_ThreadHandle, INFINITE );

  00024	6a ff		 push	 -1
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002c	51		 push	 ecx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 49   : 		CloseHandle(m_ThreadHandle);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00039	51		 push	 ecx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 50   : 		m_ThreadHandle = NULL;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
$LN2@Close:

; 51   : 	}
; 52   : 	HeapFree(GetProcessHeap(), 0, m_Recvbuf);

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00050	51		 push	 ecx
  00051	6a 00		 push	 0
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00059	50		 push	 eax
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapFree@12

; 53   : 	return TRUE;

  00060	b8 01 00 00 00	 mov	 eax, 1

; 54   : }	

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?Close@WzUdp@@QAEHXZ ENDP				; WzUdp::Close
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z
_TEXT	SEGMENT
_headcode$ = -13					; size = 1
_size$ = -12						; size = 4
_lOfs$ = -8						; size = 4
_this$ = -4						; size = 4
_RecvData$ = 8						; size = 4
_nRecvDataLen$ = 12					; size = 4
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z PROC		; WzUdp::MuProtocolParse, COMDAT
; _this$ = ecx

; 148  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 149  : 	int		lOfs = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lOfs$[ebp], 0

; 150  : 	int		size = 0;

  00013	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _size$[ebp], 0

; 151  : 	BYTE	headcode;
; 152  : 
; 153  : 	if( ProtocolCore == NULL ) return FALSE;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 b8 5c 08 00
	00 00		 cmp	 DWORD PTR [eax+2140], 0
  00024	75 07		 jne	 SHORT $LN2@MuProtocol
  00026	33 c0		 xor	 eax, eax
  00028	e9 30 01 00 00	 jmp	 $LN1@MuProtocol
$LN2@MuProtocol:

; 154  : 
; 155  : 	while( TRUE )

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	85 c0		 test	 eax, eax
  00034	0f 84 1e 01 00
	00		 je	 $LN3@MuProtocol

; 156  : 	{
; 157  : 		if( RecvData[lOfs] == 0xC1 )

  0003a	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  0003d	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  00040	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00043	81 f9 c1 00 00
	00		 cmp	 ecx, 193		; 000000c1H
  00049	75 1b		 jne	 SHORT $LN5@MuProtocol

; 158  : 		{
; 159  : 			size		= *(RecvData+lOfs+1);

  0004b	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  0004e	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  00051	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00055	89 4d f4	 mov	 DWORD PTR _size$[ebp], ecx

; 160  : 			headcode	= *(RecvData+lOfs+2);

  00058	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  0005b	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  0005e	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00061	88 4d f3	 mov	 BYTE PTR _headcode$[ebp], cl

; 161  : 		}

  00064	eb 56		 jmp	 SHORT $LN6@MuProtocol
$LN5@MuProtocol:

; 162  : 		else if( RecvData[lOfs] == 0xC2 )

  00066	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  00069	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  0006c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0006f	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  00075	75 34		 jne	 SHORT $LN7@MuProtocol

; 163  : 		{
; 164  : 			size		 = (WORD)(*(RecvData+lOfs+1));

  00077	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  0007a	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  0007d	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00081	89 4d f4	 mov	 DWORD PTR _size$[ebp], ecx

; 165  : 			size	   <<= 8;

  00084	8b 45 f4	 mov	 eax, DWORD PTR _size$[ebp]
  00087	c1 e0 08	 shl	 eax, 8
  0008a	89 45 f4	 mov	 DWORD PTR _size$[ebp], eax

; 166  : 			size		|= (WORD)(*(RecvData+lOfs+2));

  0008d	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  00090	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  00093	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00097	0b 4d f4	 or	 ecx, DWORD PTR _size$[ebp]
  0009a	89 4d f4	 mov	 DWORD PTR _size$[ebp], ecx

; 167  : 			headcode	 = *(RecvData+lOfs+3);

  0009d	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  000a0	03 45 f8	 add	 eax, DWORD PTR _lOfs$[ebp]
  000a3	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  000a6	88 4d f3	 mov	 BYTE PTR _headcode$[ebp], cl

; 168  : 		}

  000a9	eb 11		 jmp	 SHORT $LN6@MuProtocol
$LN7@MuProtocol:

; 169  : 		else  // 헤더가 맞지 않다면..
; 170  : 		{
; 171  : 			m_dwRecvOfs = 0;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 172  : 			return FALSE;

  000b5	33 c0		 xor	 eax, eax
  000b7	e9 a1 00 00 00	 jmp	 $LN1@MuProtocol
$LN6@MuProtocol:

; 173  : 		}
; 174  : 		if( size <= 0 )	// size 가 0일때는 에러..

  000bc	83 7d f4 00	 cmp	 DWORD PTR _size$[ebp], 0
  000c0	7f 0c		 jg	 SHORT $LN9@MuProtocol

; 175  : 		{
; 176  : 			return FALSE;

  000c2	33 c0		 xor	 eax, eax
  000c4	e9 94 00 00 00	 jmp	 $LN1@MuProtocol

; 177  : 		}		

  000c9	e9 85 00 00 00	 jmp	 $LN10@MuProtocol
$LN9@MuProtocol:

; 178  : 		else if( size <= nRecvDataLen )	// 하나의 패킷이 완전하다면..

  000ce	8b 45 0c	 mov	 eax, DWORD PTR _nRecvDataLen$[ebp]
  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _size$[ebp]
  000d4	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d6	7f 43		 jg	 SHORT $LN11@MuProtocol

; 179  : 		{
; 180  : 			(*ProtocolCore)(headcode, RecvData+lOfs, size);

  000d8	8b 45 f4	 mov	 eax, DWORD PTR _size$[ebp]
  000db	50		 push	 eax
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _RecvData$[ebp]
  000df	03 4d f8	 add	 ecx, DWORD PTR _lOfs$[ebp]
  000e2	51		 push	 ecx
  000e3	0f b6 55 f3	 movzx	 edx, BYTE PTR _headcode$[ebp]
  000e7	52		 push	 edx
  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 88 5c 08 00
	00		 mov	 ecx, DWORD PTR [eax+2140]
  000f1	ff d1		 call	 ecx
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 181  : 			lOfs		 += size;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _lOfs$[ebp]
  000f9	03 45 f4	 add	 eax, DWORD PTR _size$[ebp]
  000fc	89 45 f8	 mov	 DWORD PTR _lOfs$[ebp], eax

; 182  : 			m_dwRecvOfs  -= size;

  000ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00102	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00105	2b 4d f4	 sub	 ecx, DWORD PTR _size$[ebp]
  00108	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0010b	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 183  : 			if( m_dwRecvOfs <= 0 ) break;

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00111	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00115	7f 02		 jg	 SHORT $LN13@MuProtocol
  00117	eb 3f		 jmp	 SHORT $LN3@MuProtocol
$LN13@MuProtocol:

; 184  : 		}		

  00119	eb 38		 jmp	 SHORT $LN10@MuProtocol
$LN11@MuProtocol:

; 185  : 		else												// 데이터가 더 남았다면
; 186  : 		{	
; 187  : 			if( lOfs > 0 )									// 하나이상 데이터를 처리한 후 라면..

  0011b	83 7d f8 00	 cmp	 DWORD PTR _lOfs$[ebp], 0
  0011f	7e 30		 jle	 SHORT $LN14@MuProtocol

; 188  : 			{
; 189  : 				if( m_dwRecvOfs < 1 )

  00121	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00124	83 78 20 01	 cmp	 DWORD PTR [eax+32], 1
  00128	7d 06		 jge	 SHORT $LN15@MuProtocol

; 190  : 				{
; 191  : 					return FALSE;

  0012a	33 c0		 xor	 eax, eax
  0012c	eb 2f		 jmp	 SHORT $LN1@MuProtocol

; 192  : 				}

  0012e	eb 21		 jmp	 SHORT $LN14@MuProtocol
$LN15@MuProtocol:

; 193  : 				else 
; 194  : 				{
; 195  : 					memcpy(RecvData, (RecvData+lOfs), m_dwRecvOfs); // 남은만큼 복사한다.

  00130	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00133	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00136	51		 push	 ecx
  00137	8b 55 08	 mov	 edx, DWORD PTR _RecvData$[ebp]
  0013a	03 55 f8	 add	 edx, DWORD PTR _lOfs$[ebp]
  0013d	52		 push	 edx
  0013e	8b 45 08	 mov	 eax, DWORD PTR _RecvData$[ebp]
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _memcpy
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH

; 196  : 					return TRUE;

  0014a	b8 01 00 00 00	 mov	 eax, 1
  0014f	eb 0c		 jmp	 SHORT $LN1@MuProtocol
$LN14@MuProtocol:

; 197  : 				}
; 198  : 			}
; 199  : 			break;

  00151	eb 05		 jmp	 SHORT $LN3@MuProtocol
$LN10@MuProtocol:

; 200  : 		}
; 201  : 	}

  00153	e9 d5 fe ff ff	 jmp	 $LN2@MuProtocol
$LN3@MuProtocol:

; 202  : 	return TRUE;

  00158	b8 01 00 00 00	 mov	 eax, 1
$LN1@MuProtocol:

; 203  : }

  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 08 00	 ret	 8
?MuProtocolParse@WzUdp@@QAEHPAEAAH@Z ENDP		; WzUdp::MuProtocolParse
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?SendData@WzUdp@@QAEHPAEK@Z
_TEXT	SEGMENT
_Ret$ = -8						; size = 4
_this$ = -4						; size = 4
_SendData$ = 8						; size = 4
_nSendDataLen$ = 12					; size = 4
?SendData@WzUdp@@QAEHPAEK@Z PROC			; WzUdp::SendData, COMDAT
; _this$ = ecx

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 	DWORD Ret;
; 125  : 
; 126  : 	ZeroMemory(&(m_PerIoSendData.Overlapped), sizeof(OVERLAPPED));

  0000c	6a 14		 push	 20			; 00000014H
  0000e	6a 00		 push	 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 28	 add	 eax, 40			; 00000028H
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _memset
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 127  : 	
; 128  : 	memcpy(m_PerIoSendData.Buffer, SendData, nSendDataLen);

  0001f	8b 45 0c	 mov	 eax, DWORD PTR _nSendDataLen$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _SendData$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	83 c2 44	 add	 edx, 68			; 00000044H
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 _memcpy
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 129  : 	
; 130  : 	m_PerIoSendData.lOfs		= nSendDataLen;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _nSendDataLen$[ebp]
  0003c	89 88 48 08 00
	00		 mov	 DWORD PTR [eax+2120], ecx

; 131  : 	m_PerIoSendData.DataBuf.buf = m_PerIoSendData.Buffer;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	83 c0 44	 add	 eax, 68			; 00000044H
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 132  : 	m_PerIoSendData.DataBuf.len = m_PerIoSendData.lOfs;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 91 48 08 00
	00		 mov	 edx, DWORD PTR [ecx+2120]
  0005a	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 133  : 		
; 134  : 	Ret = WSASendTo(m_Socket, &(m_PerIoSendData.DataBuf), 1, &nSendDataLen, 

  0005d	6a 00		 push	 0
  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	83 c0 28	 add	 eax, 40			; 00000028H
  00065	50		 push	 eax
  00066	6a 10		 push	 16			; 00000010H
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	81 c1 4c 08 00
	00		 add	 ecx, 2124		; 0000084cH
  00071	51		 push	 ecx
  00072	6a 00		 push	 0
  00074	8d 55 0c	 lea	 edx, DWORD PTR _nSendDataLen$[ebp]
  00077	52		 push	 edx
  00078	6a 01		 push	 1
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	83 c0 3c	 add	 eax, 60			; 0000003cH
  00080	50		 push	 eax
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00087	52		 push	 edx
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASendTo@36
  0008e	89 45 f8	 mov	 DWORD PTR _Ret$[ebp], eax

; 135  : 		0, (SOCKADDR*)&m_SockAddr, sizeof(m_SockAddr), &(m_PerIoSendData.Overlapped), NULL);
; 136  : 	if( Ret == SOCKET_ERROR )

  00091	83 7d f8 ff	 cmp	 DWORD PTR _Ret$[ebp], -1
  00095	75 12		 jne	 SHORT $LN2@SendData

; 137  : 	{
; 138  : 		if (WSAGetLastError() != ERROR_IO_PENDING)

  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0009d	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000a2	74 05		 je	 SHORT $LN2@SendData

; 139  : 		{
; 140  : 			//printf("WSASend() failed with error %d\n", WSAGetLastError());
; 141  : 			return -1;

  000a4	83 c8 ff	 or	 eax, -1
  000a7	eb 05		 jmp	 SHORT $LN1@SendData
$LN2@SendData:

; 142  : 		}
; 143  : 	}
; 144  : 	return TRUE;

  000a9	b8 01 00 00 00	 mov	 eax, 1
$LN1@SendData:

; 145  : }

  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 08 00	 ret	 8
?SendData@WzUdp@@QAEHPAEK@Z ENDP			; WzUdp::SendData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?Run@WzUdp@@QAEHXZ
_TEXT	SEGMENT
tv65 = -72						; size = 4
_this$ = -4						; size = 4
?Run@WzUdp@@QAEHXZ PROC					; WzUdp::Run, COMDAT
; _this$ = ecx

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 	if( (m_ThreadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)WzUdpRecvThread, (void*)this, 0, &m_ThreadID) ) == NULL)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	51		 push	 ecx
  00019	68 00 00 00 00	 push	 OFFSET ?WzUdpRecvThread@@YGKPAVWzUdp@@@Z ; WzUdpRecvThread
  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00028	89 45 b8	 mov	 DWORD PTR tv65[ebp], eax
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 45 b8	 mov	 eax, DWORD PTR tv65[ebp]
  00031	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00034	83 7d b8 00	 cmp	 DWORD PTR tv65[ebp], 0
  00038	75 04		 jne	 SHORT $LN2@Run

; 209  : 	{		
; 210  : 		return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 05		 jmp	 SHORT $LN1@Run
$LN2@Run:

; 211  : 	}
; 212  : 	return TRUE;

  0003e	b8 01 00 00 00	 mov	 eax, 1
$LN1@Run:

; 213  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?Run@WzUdp@@QAEHXZ ENDP					; WzUdp::Run
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?CreateSocket@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CreateSocket@WzUdp@@QAEHXZ PROC			; WzUdp::CreateSocket, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 	if (m_Socket != INVALID_SOCKET) {

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  00013	74 17		 je	 SHORT $LN2@CreateSock

; 59   : 		closesocket(m_Socket);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0001b	51		 push	 ecx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 60   : 		m_Socket = INVALID_SOCKET;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1
$LN2@CreateSock:

; 61   : 	}
; 62   : 
; 63   : 	m_Socket = WSASocket(AF_INET, SOCK_DGRAM, 0, NULL, 0, NULL);

  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 02		 push	 2
  00036	6a 02		 push	 2
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 64   :     
; 65   : 	if( m_Socket == INVALID_SOCKET )

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 78 10 ff	 cmp	 DWORD PTR [eax+16], -1
  0004b	75 04		 jne	 SHORT $LN3@CreateSock

; 66   :     {        
; 67   :         return FALSE;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 05		 jmp	 SHORT $LN1@CreateSock
$LN3@CreateSock:

; 68   :     }
; 69   : 	return TRUE;

  00051	b8 01 00 00 00	 mov	 eax, 1
$LN1@CreateSock:

; 70   : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?CreateSocket@WzUdp@@QAEHXZ ENDP			; WzUdp::CreateSocket
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?Init@WzUdp@@QAEHXZ
_TEXT	SEGMENT
_wsd$ = -408						; size = 400
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Init@WzUdp@@QAEHXZ PROC				; WzUdp::Init, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 01 00
	00		 sub	 esp, 472		; 000001d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	WSADATA			wsd;
; 30   : 
; 31   : 	if (WSAStartup(MAKEWORD(2,2), &wsd) != 0)

  00019	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _wsd$[ebp]
  0001f	50		 push	 eax
  00020	68 02 02 00 00	 push	 514			; 00000202H
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAStartup@8
  0002b	85 c0		 test	 eax, eax
  0002d	74 04		 je	 SHORT $LN2@Init

; 32   :     {        
; 33   :         return FALSE;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 3a		 jmp	 SHORT $LN1@Init
$LN2@Init:

; 34   :     }
; 35   : 	m_Socket	= INVALID_SOCKET;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1

; 36   : 	m_dwLength  = DEFAULT_BUFFER_LENGTH;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 40 1c 00 10
	00 00		 mov	 DWORD PTR [eax+28], 4096 ; 00001000H

; 37   : 	m_dwRecvOfs = 0;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 38   : 	m_ThreadHandle = NULL;

  00051	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00054	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 39   : 	ProtocolCore   = NULL;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 80 5c 08 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2140], 0

; 40   : 	return TRUE;

  00068	b8 01 00 00 00	 mov	 eax, 1
$LN1@Init:

; 41   : }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?Init@WzUdp@@QAEHXZ ENDP				; WzUdp::Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ??1WzUdp@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1WzUdp@@UAE@XZ PROC					; WzUdp::~WzUdp, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1WzUdp@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7WzUdp@@6B@

; 24   : 	Close();

  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?Close@WzUdp@@QAEHXZ	; WzUdp::Close

; 25   : }

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
  00052	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1WzUdp@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1WzUdp@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1WzUdp@@UAE@XZ ENDP					; WzUdp::~WzUdp
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ??0WzUdp@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WzUdp@@QAE@XZ PROC					; WzUdp::WzUdp, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7WzUdp@@6B@

; 19   : 	Init();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?Init@WzUdp@@QAEHXZ	; WzUdp::Init

; 20   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0WzUdp@@QAE@XZ ENDP					; WzUdp::WzUdp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\WzUdp.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
