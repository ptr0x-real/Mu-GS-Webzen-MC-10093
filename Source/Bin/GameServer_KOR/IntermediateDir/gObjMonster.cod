; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
PUBLIC	?gObjMonsterProcess@@YAXPAVOBJECTSTRUCT@@@Z	; gObjMonsterProcess
PUBLIC	?gObjMonsterStateProc@@YAXPAVOBJECTSTRUCT@@HH@Z	; gObjMonsterStateProc
PUBLIC	?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z	; gObjMonsterRegen
PUBLIC	?gObjMonsterSetHitDamage@@YAXPAVOBJECTSTRUCT@@HH@Z ; gObjMonsterSetHitDamage
PUBLIC	?gObjMonsterHitDamageInit@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit
PUBLIC	?gObjMonsterHitDamageUserDel@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageUserDel
PUBLIC	?gObjCallMonsterSetEnemy@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCallMonsterSetEnemy
PUBLIC	?gObjMonsterSearchEnemy@@YAHPAVOBJECTSTRUCT@@E@Z ; gObjMonsterSearchEnemy
PUBLIC	?gObjMonsterGetTargetPos@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterGetTargetPos
PUBLIC	?gObjMonsterMoveAction@@YAXPAVOBJECTSTRUCT@@@Z	; gObjMonsterMoveAction
PUBLIC	?PathFindMoveMsgSend@@YAHPAVOBJECTSTRUCT@@@Z	; PathFindMoveMsgSend
PUBLIC	?gObjMonsterLastHitDamageUser@@YAHPAVOBJECTSTRUCT@@AAH@Z ; gObjMonsterLastHitDamageUser
PUBLIC	?gObjSkylandBossSheildAttack@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSkylandBossSheildAttack
PUBLIC	?NewOptionRand@@YAEH@Z				; NewOptionRand
PUBLIC	?gObjMonsterDieGiveItem@@YAXPAVOBJECTSTRUCT@@0@Z ; gObjMonsterDieGiveItem
PUBLIC	?gObjMonsterDieRewardItems@@YAXPAVOBJECTSTRUCT@@0HHHHHHH@Z ; gObjMonsterDieRewardItems
PUBLIC	?gObjRefillMonsterHP@@YAXPAVOBJECTSTRUCT@@H@Z	; gObjRefillMonsterHP
PUBLIC	?gObjUseMonsterSpecialAbillity@@YAXPAVOBJECTSTRUCT@@@Z ; gObjUseMonsterSpecialAbillity
PUBLIC	??0CQeustNpcTeleport@@QAE@XZ			; CQeustNpcTeleport::CQeustNpcTeleport
PUBLIC	??1CQeustNpcTeleport@@QAE@XZ			; CQeustNpcTeleport::~CQeustNpcTeleport
PUBLIC	?Run@CQeustNpcTeleport@@QAEXH@Z			; CQeustNpcTeleport::Run
PUBLIC	?gObjMonsterBaseAct@@YAXPAVOBJECTSTRUCT@@@Z	; gObjMonsterBaseAct
PUBLIC	?gObjMonsterTrapAct@@YAXPAVOBJECTSTRUCT@@@Z	; gObjMonsterTrapAct
PUBLIC	?gObjMonsterAttack@@YAXPAVOBJECTSTRUCT@@0@Z	; gObjMonsterAttack
PUBLIC	?gObjMonsterMagicAttack@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjMonsterMagicAttack
PUBLIC	?gObjMonsterBeattackRecv@@YAXPAEH@Z		; gObjMonsterBeattackRecv
PUBLIC	?gEventMonsterItemDrop@@YAHPAVOBJECTSTRUCT@@0@Z	; gEventMonsterItemDrop
PUBLIC	?gObjMonsterMoveRegen@@YAXHHPAVOBJECTSTRUCT@@@Z	; gObjMonsterMoveRegen
PUBLIC	?gObjMonsterViewportIsCharacter@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterViewportIsCharacter
PUBLIC	?gObjMonsterMoveCheck@@YAHPAVOBJECTSTRUCT@@HH@Z	; gObjMonsterMoveCheck
PUBLIC	?gObjGetTargetPos@@YAHPAVOBJECTSTRUCT@@HHAAH1@Z	; gObjGetTargetPos
PUBLIC	?gObjGuardSearchEnemy@@YAHPAVOBJECTSTRUCT@@@Z	; gObjGuardSearchEnemy
PUBLIC	?gObjTrapAttackEnemySearchX@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchX
PUBLIC	?gObjTrapAttackEnemySearchY@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchY
PUBLIC	?gObjTrapAttackEnemySearch@@YAXPAVOBJECTSTRUCT@@@Z ; gObjTrapAttackEnemySearch
PUBLIC	?InventoryDropItem@@YAXPAVOBJECTSTRUCT@@H@Z	; InventoryDropItem
PUBLIC	?IsCanNotItemDtopInDevilSquare@@YAHH@Z		; IsCanNotItemDtopInDevilSquare
PUBLIC	?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A	; gQeustNpcTeleport
PUBLIC	?KUNDUN_EVENT_LOG@@3VCLogToFile@@A		; KUNDUN_EVENT_LOG
PUBLIC	??_C@_0BD@CIMLGFIE@?4?2KUNDUN_EVENT_LOG@	; `string'
PUBLIC	??_C@_0BB@BACGIKG@KUNDUN_EVENT_LOG@		; `string'
PUBLIC	??_C@_0CA@MINPGEPL@error?9L2?5?3?5Hit?5Damage?5Set?5error@ ; `string'
PUBLIC	??_C@_0DI@FKJGCAAF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5@ ; `string'
PUBLIC	??_C@_0DN@OMDKGOEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjMonsterBeattackRecv@@YAXPAEH@Z@4JA ; `gObjMonsterBeattackRecv'::`1'::__LINE__Var
PUBLIC	??_C@_0DO@IODFIFIN@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@	; `string'
PUBLIC	??_C@_0DJ@LBLCMLBJ@?$FLKUNDUN?$FN?5HP?5Log?5?9?$DO?5?$FL?$CFd?$FN?H?$LI?$LK?$LJ?5?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5@ ; `string'
PUBLIC	??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5@ ; `string'
PUBLIC	??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5@ ; `string'
PUBLIC	??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0O@PGINOIGE@NPC?5?$CFd?$LH?N?5?$MA?L?$LF?$LP@ ; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40a00000
PUBLIC	__real@41c80000
PUBLIC	__real@42c80000
PUBLIC	__real@43000000
PUBLIC	__real@437f0000
EXTRN	_atexit:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	_rand:PROC
EXTRN	_sqrt:PROC
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z:PROC ; gObjGetRandomItemDropLocation
EXTRN	?gObjMemFree@@YAFH@Z:PROC			; gObjMemFree
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjViewportClose@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; gObjViewportClose
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjViewportListCreate@@YAXF@Z:PROC		; gObjViewportListCreate
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z:PROC ; gObjAttack
EXTRN	?gObjMsgProc@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; gObjMsgProc
EXTRN	?gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z:PROC	; gObjBackSpring
EXTRN	?GetPathPacketDirPos@@YAEHH@Z:PROC		; GetPathPacketDirPos
EXTRN	?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjTeleportMagicUse@@YAXHEE@Z:PROC		; gObjTeleportMagicUse
EXTRN	?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagic
EXTRN	?gObjCheckTileArea@@YAHHHHH@Z:PROC		; gObjCheckTileArea
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
EXTRN	?gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z:PROC	; gObjBackSpring2
EXTRN	?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; gObjClearViewport
EXTRN	?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolDestroy
EXTRN	?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolCreate
EXTRN	?MakeRewardSetItem@@YAXHEEH@Z:PROC		; MakeRewardSetItem
EXTRN	?ChatSend@@YAXPAVOBJECTSTRUCT@@PAD@Z:PROC	; ChatSend
EXTRN	?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z:PROC		; PMoveProc
EXTRN	?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z:PROC		; CGAttack
EXTRN	?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z:PROC ; CGMagicAttack
EXTRN	?CGBeattackRecv@@YAXPAEHH@Z:PROC		; CGBeattackRecv
EXTRN	?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z:PROC ; CGDurationMagicRecv
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?DropItem@cDropSystem@@QAE_NPAVOBJECTSTRUCT@@0@Z:PROC ; cDropSystem::DropItem
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
EXTRN	?CheckWall@MapClass@@QAEHHHHH@Z:PROC		; MapClass::CheckWall
EXTRN	?CheckWall2@MapClass@@QAEEHHHH@Z:PROC		; MapClass::CheckWall2
EXTRN	?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z:PROC ; MapClass::MonsterItemDrop
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z:PROC ; MapClass::PathFinding2
EXTRN	?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z:PROC ; MapClass::PathFinding3
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?GetStandAttr@MapClass@@QAEHHH@Z:PROC		; MapClass::GetStandAttr
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z:PROC	; CMonsterSetBase::GetPosition
EXTRN	?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z:PROC ; CMonsterSetBase::GetBoxPosition
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z:PROC	; ItemSerialCreateSend
EXTRN	?AttackEvent55BagOpen@@YAHPAVOBJECTSTRUCT@@@Z:PROC ; AttackEvent55BagOpen
EXTRN	?KundunEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@EEE@Z:PROC ; KundunEventItemBoxOpen
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?GetPartyCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetPartyCount
EXTRN	?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z:PROC	; CMonsterItemMng::GetItem
EXTRN	?MonsterItemDrop@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CQuestInfo::MonsterItemDrop
EXTRN	?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z:PROC ; CBloodCastle::SendBridgeAnyMsg
EXTRN	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z:PROC ; CBloodCastle::SendNoticeMessage
EXTRN	?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z:PROC	; CBloodCastle::ReleaseCastleBridge
EXTRN	?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z:PROC ; CBloodCastle::CheckMonsterKillCount
EXTRN	?CheckBossKillCount@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckBossKillCount
EXTRN	?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z:PROC ; CBloodCastle::GetCurrentLiveUserCount
EXTRN	?SetSaintStatue@CBloodCastle@@QAEXH@Z:PROC	; CBloodCastle::SetSaintStatue
EXTRN	?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z:PROC ; CChaosCastle::SearchNDropMonsterItem
EXTRN	?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z:PROC ; CChaosCastle::CheckRegisterOfflineGift
EXTRN	?DropEventItem@CItemBagEx@@QAEHH@Z:PROC		; CItemBagEx::DropEventItem
EXTRN	?Output@CLogToFile@@QAAXPADZZ:PROC		; CLogToFile::Output
EXTRN	??0CLogToFile@@QAE@QAD0H@Z:PROC			; CLogToFile::CLogToFile
EXTRN	??1CLogToFile@@QAE@XZ:PROC			; CLogToFile::~CLogToFile
EXTRN	?KalimaGateAct@CKalimaGate@@QAEXH@Z:PROC	; CKalimaGate::KalimaGateAct
EXTRN	?gCheckGoal@@YAHHHAAH@Z:PROC			; gCheckGoal
EXTRN	?gBattleSoccerScoreUpdate@@YAHHH@Z:PROC		; gBattleSoccerScoreUpdate
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__except_handler4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_memset:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?RoadPathTable@@3PAFA:BYTE			; RoadPathTable
EXTRN	?g_GlobalConfig@@3VCGlobalConfig@@A:BYTE	; g_GlobalConfig
EXTRN	?cexDrop@@3VcDropSystem@@A:BYTE			; cexDrop
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gEvent1@@3HA:DWORD				; gEvent1
EXTRN	?gEvent1ItemDropTodayCount@@3HA:DWORD		; gEvent1ItemDropTodayCount
EXTRN	?gEvent1ItemDropTodayMax@@3HA:DWORD		; gEvent1ItemDropTodayMax
EXTRN	?gEvent1ItemDropTodayPercent@@3HA:DWORD		; gEvent1ItemDropTodayPercent
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?gItemDropPer@@3HA:DWORD			; gItemDropPer
EXTRN	?gLanguage@@3HA:DWORD				; gLanguage
EXTRN	?gAddZen@@3MA:DWORD				; gAddZen
EXTRN	?gXMasEvent@@3HA:DWORD				; gXMasEvent
EXTRN	?gFireCrackerEvent@@3HA:DWORD			; gFireCrackerEvent
EXTRN	?gFireCrackerDropRate@@3HA:DWORD		; gFireCrackerDropRate
EXTRN	?gHeartOfLoveEvent@@3HA:DWORD			; gHeartOfLoveEvent
EXTRN	?gHeartOfLoveDropRate@@3HA:DWORD		; gHeartOfLoveDropRate
EXTRN	?gMedalEvent@@3HA:DWORD				; gMedalEvent
EXTRN	?gGoldMedalDropRate@@3HA:DWORD			; gGoldMedalDropRate
EXTRN	?gSilverMedalDropRate@@3HA:DWORD		; gSilverMedalDropRate
EXTRN	?gEventChipEvent@@3HA:DWORD			; gEventChipEvent
EXTRN	?gBoxOfGoldDropRate@@3HA:DWORD			; gBoxOfGoldDropRate
EXTRN	?g_bBloodCastle@@3HA:DWORD			; g_bBloodCastle
EXTRN	?g_iAngelKingsPaperDropRate@@3HA:DWORD		; g_iAngelKingsPaperDropRate
EXTRN	?g_iBloodBoneDropRate@@3HA:DWORD		; g_iBloodBoneDropRate
EXTRN	?g_iKundunMarkDropRate@@3HA:DWORD		; g_iKundunMarkDropRate
EXTRN	?g_iDarkLordHeartDropRate@@3HA:DWORD		; g_iDarkLordHeartDropRate
EXTRN	?gQuestNPCTeleportTime@@3HA:DWORD		; gQuestNPCTeleportTime
EXTRN	?gIsItemDropRingOfTransform@@3HA:DWORD		; gIsItemDropRingOfTransform
EXTRN	?gItemDropRingOfTransform@@3HA:DWORD		; gItemDropRingOfTransform
EXTRN	?giKundunRefillHP@@3HA:DWORD			; giKundunRefillHP
EXTRN	?giKundunRefillHPTime@@3HA:DWORD		; giKundunRefillHPTime
EXTRN	?gIsDropDarkLordItem@@3HA:DWORD			; gIsDropDarkLordItem
EXTRN	?gSleeveOfLordDropRate@@3HA:DWORD		; gSleeveOfLordDropRate
EXTRN	?gSleeveOfLordDropLevel@@3HA:DWORD		; gSleeveOfLordDropLevel
EXTRN	?gSoulOfDarkHorseDropRate@@3HA:DWORD		; gSoulOfDarkHorseDropRate
EXTRN	?gSoulOfDarkHorseropLevel@@3HA:DWORD		; gSoulOfDarkHorseropLevel
EXTRN	?gSoulOfDarkSpiritDropRate@@3HA:DWORD		; gSoulOfDarkSpiritDropRate
EXTRN	?gSoulOfDarkSpiritDropLevel@@3HA:DWORD		; gSoulOfDarkSpiritDropLevel
EXTRN	?g_MonsterItemMng@@3VCMonsterItemMng@@A:BYTE	; g_MonsterItemMng
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?g_KalimaGate@@3VCKalimaGate@@A:BYTE		; g_KalimaGate
EXTRN	?StarOfXMasItemBag@@3PAVCItemBagEx@@A:DWORD	; StarOfXMasItemBag
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A DB 064H DUP (?) ; gQeustNpcTeleport
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
?KUNDUN_EVENT_LOG@@3VCLogToFile@@A DB 010228H DUP (?)	; KUNDUN_EVENT_LOG
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0O@PGINOIGE@NPC?5?$CFd?$LH?N?5?$MA?L?$LF?$LP@
CONST	SEGMENT
??_C@_0O@PGINOIGE@NPC?5?$CFd?$LH?N?5?$MA?L?$LF?$LP@ DB 'NPC %d', 0b7H, 0ceH
	DB	' ', 0c0H, 0ccH, 0b5H, 0bfH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN@ DB '['
	DB	0a1H, 0dbH, 'Kundun EVENT] Drop Item [%d][%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5@
CONST	SEGMENT
??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5@ DB '[', 0a1H
	DB	0dbH, 'Kundun EVENT] Drop SetItem ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5@
CONST	SEGMENT
??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5@ DB '['
	DB	0a1H, 0daH, 'Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser ['
	DB	'%d][%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5@
CONST	SEGMENT
??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5@ DB '['
	DB	0a1H, 0daH, 0a1H, 0daH, 'Kundun EVENT] Kundun die, Killer [%s]'
	DB	'[%s]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LBLCMLBJ@?$FLKUNDUN?$FN?5HP?5Log?5?9?$DO?5?$FL?$CFd?$FN?H?$LI?$LK?$LJ?5?5?$FL?$CF@
CONST	SEGMENT
??_C@_0DJ@LBLCMLBJ@?$FLKUNDUN?$FN?5HP?5Log?5?9?$DO?5?$FL?$CFd?$FN?H?$LI?$LK?$LJ?5?5?$FL?$CF@ DB '['
	DB	'KUNDUN] HP Log -> [%d]', 0c8H, 0b8H, 0baH, 0b9H, '  [%d]', 0c8H
	DB	0b8H, 0baH, 0b9H, 0bdH, 0c3H, 0b0H, 0a3H, '  [%7.0f]', 0c7H, 0f6H
	DB	0c0H, 0e7H, 'HP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@ DB 'error-L3 %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@IODFIFIN@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0DO@IODFIFIN@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onl'
	DB	'ine\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjMonsterBeattackRecv@@YAXPAEH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjMonsterBeattackRecv@@YAXPAEH@Z@4JA DD 07e0H ; `gObjMonsterBeattackRecv'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DN@OMDKGOEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5@
CONST	SEGMENT
??_C@_0DN@OMDKGOEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5@ DB '['
	DB	'Blood Castle] (%d) All of the Boss Monster Terminated -> %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FKJGCAAF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5@
CONST	SEGMENT
??_C@_0DI@FKJGCAAF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5@ DB '['
	DB	'Blood Castle] (%d) All of the Monster Terminated -> %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MINPGEPL@error?9L2?5?3?5Hit?5Damage?5Set?5error@
CONST	SEGMENT
??_C@_0CA@MINPGEPL@error?9L2?5?3?5Hit?5Damage?5Set?5error@ DB 'error-L2 :'
	DB	' Hit Damage Set error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BACGIKG@KUNDUN_EVENT_LOG@
CONST	SEGMENT
??_C@_0BB@BACGIKG@KUNDUN_EVENT_LOG@ DB 'KUNDUN_EVENT_LOG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CIMLGFIE@?4?2KUNDUN_EVENT_LOG@
CONST	SEGMENT
??_C@_0BD@CIMLGFIE@?4?2KUNDUN_EVENT_LOG@ DB '.\KUNDUN_EVENT_LOG', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?gObjMonsterMoveAction@@YAXPAVOBJECTSTRUCT@@@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff80H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN18@gObjMonste
	DD	FLAT:$LN14@gObjMonste
xdata$x	ENDS
CRT$XCU	SEGMENT
?KUNDUN_EVENT_LOG$initializer$@@3P6AXXZA DD FLAT:??__EKUNDUN_EVENT_LOG@@YAXXZ ; KUNDUN_EVENT_LOG$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gQeustNpcTeleport$initializer$@@3P6AXXZA DD FLAT:??__EgQeustNpcTeleport@@YAXXZ ; gQeustNpcTeleport$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?IsCanNotItemDtopInDevilSquare@@YAHH@Z
_TEXT	SEGMENT
_checkitemindex$ = -8					; size = 4
_checkitemtype$ = -4					; size = 4
_ItemType$ = 8						; size = 4
?IsCanNotItemDtopInDevilSquare@@YAHH@Z PROC		; IsCanNotItemDtopInDevilSquare, COMDAT

; 3205 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3206 : 	int checkitemtype = ItemType/MAX_ITEM_INDEX;

  00009	8b 45 08	 mov	 eax, DWORD PTR _ItemType$[ebp]
  0000c	99		 cdq
  0000d	83 e2 1f	 and	 edx, 31			; 0000001fH
  00010	03 c2		 add	 eax, edx
  00012	c1 f8 05	 sar	 eax, 5
  00015	89 45 fc	 mov	 DWORD PTR _checkitemtype$[ebp], eax

; 3207 : 	int	checkitemindex = ItemType%MAX_ITEM_INDEX;

  00018	8b 45 08	 mov	 eax, DWORD PTR _ItemType$[ebp]
  0001b	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00020	79 05		 jns	 SHORT $LN17@IsCanNotIt
  00022	48		 dec	 eax
  00023	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00026	40		 inc	 eax
$LN17@IsCanNotIt:
  00027	89 45 f8	 mov	 DWORD PTR _checkitemindex$[ebp], eax

; 3208 : 
; 3209 : 	if( checkitemtype >= 7 && checkitemtype <= 11 )

  0002a	83 7d fc 07	 cmp	 DWORD PTR _checkitemtype$[ebp], 7
  0002e	7c 1e		 jl	 SHORT $LN2@IsCanNotIt
  00030	83 7d fc 0b	 cmp	 DWORD PTR _checkitemtype$[ebp], 11 ; 0000000bH
  00034	7f 18		 jg	 SHORT $LN2@IsCanNotIt

; 3210 : 	{	// 다크피닉스, 그랜드소울, 홀리스프잇 세트
; 3211 : 		if( checkitemindex == 17 || checkitemindex == 18 || checkitemindex == 19 )

  00036	83 7d f8 11	 cmp	 DWORD PTR _checkitemindex$[ebp], 17 ; 00000011H
  0003a	74 0c		 je	 SHORT $LN5@IsCanNotIt
  0003c	83 7d f8 12	 cmp	 DWORD PTR _checkitemindex$[ebp], 18 ; 00000012H
  00040	74 06		 je	 SHORT $LN5@IsCanNotIt
  00042	83 7d f8 13	 cmp	 DWORD PTR _checkitemindex$[ebp], 19 ; 00000013H
  00046	75 04		 jne	 SHORT $LN4@IsCanNotIt
$LN5@IsCanNotIt:

; 3212 : 		{
; 3213 : 			return FALSE;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 7b		 jmp	 SHORT $LN1@IsCanNotIt
$LN4@IsCanNotIt:

; 3214 : 		}
; 3215 : 	}

  0004c	eb 74		 jmp	 SHORT $LN3@IsCanNotIt
$LN2@IsCanNotIt:

; 3216 : 	else if( checkitemtype == 0  )

  0004e	83 7d fc 00	 cmp	 DWORD PTR _checkitemtype$[ebp], 0
  00052	75 12		 jne	 SHORT $LN6@IsCanNotIt

; 3217 : 	{	// 다크브레이커, 선더블레이드
; 3218 : 		if( checkitemindex == 17 || checkitemindex == 18 )

  00054	83 7d f8 11	 cmp	 DWORD PTR _checkitemindex$[ebp], 17 ; 00000011H
  00058	74 06		 je	 SHORT $LN9@IsCanNotIt
  0005a	83 7d f8 12	 cmp	 DWORD PTR _checkitemindex$[ebp], 18 ; 00000012H
  0005e	75 04		 jne	 SHORT $LN8@IsCanNotIt
$LN9@IsCanNotIt:

; 3219 : 		{
; 3220 : 			return FALSE;

  00060	33 c0		 xor	 eax, eax
  00062	eb 63		 jmp	 SHORT $LN1@IsCanNotIt
$LN8@IsCanNotIt:

; 3221 : 		}
; 3222 : 	}

  00064	eb 5c		 jmp	 SHORT $LN3@IsCanNotIt
$LN6@IsCanNotIt:

; 3223 : 	else if( checkitemtype == 12  )

  00066	83 7d fc 0c	 cmp	 DWORD PTR _checkitemtype$[ebp], 12 ; 0000000cH
  0006a	75 30		 jne	 SHORT $LN10@IsCanNotIt

; 3224 : 	{	// 분노의일격,창찌르기, 스웰라이프, 블러드어택, 관통, 아이스애로우, 일렉스트라이크 구슬
; 3225 : 		if( checkitemindex == 12 || checkitemindex == 13 || checkitemindex == 14 || 
; 3226 : 			checkitemindex == 16 || checkitemindex == 17 || checkitemindex == 18 || 

  0006c	83 7d f8 0c	 cmp	 DWORD PTR _checkitemindex$[ebp], 12 ; 0000000cH
  00070	74 24		 je	 SHORT $LN13@IsCanNotIt
  00072	83 7d f8 0d	 cmp	 DWORD PTR _checkitemindex$[ebp], 13 ; 0000000dH
  00076	74 1e		 je	 SHORT $LN13@IsCanNotIt
  00078	83 7d f8 0e	 cmp	 DWORD PTR _checkitemindex$[ebp], 14 ; 0000000eH
  0007c	74 18		 je	 SHORT $LN13@IsCanNotIt
  0007e	83 7d f8 10	 cmp	 DWORD PTR _checkitemindex$[ebp], 16 ; 00000010H
  00082	74 12		 je	 SHORT $LN13@IsCanNotIt
  00084	83 7d f8 11	 cmp	 DWORD PTR _checkitemindex$[ebp], 17 ; 00000011H
  00088	74 0c		 je	 SHORT $LN13@IsCanNotIt
  0008a	83 7d f8 12	 cmp	 DWORD PTR _checkitemindex$[ebp], 18 ; 00000012H
  0008e	74 06		 je	 SHORT $LN13@IsCanNotIt
  00090	83 7d f8 13	 cmp	 DWORD PTR _checkitemindex$[ebp], 19 ; 00000013H
  00094	75 04		 jne	 SHORT $LN12@IsCanNotIt
$LN13@IsCanNotIt:

; 3227 : 			checkitemindex == 19 )
; 3228 : 		{
; 3229 : 			return FALSE;

  00096	33 c0		 xor	 eax, eax
  00098	eb 2d		 jmp	 SHORT $LN1@IsCanNotIt
$LN12@IsCanNotIt:

; 3230 : 		}
; 3231 : 	}	

  0009a	eb 26		 jmp	 SHORT $LN3@IsCanNotIt
$LN10@IsCanNotIt:

; 3232 : 	else if( (ItemType == MAKE_ITEMNUM(4,17)) || (ItemType == MAKE_ITEMNUM(5,9)) )

  0009c	6a 11		 push	 17			; 00000011H
  0009e	6a 04		 push	 4
  000a0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000a5	83 c4 08	 add	 esp, 8
  000a8	39 45 08	 cmp	 DWORD PTR _ItemType$[ebp], eax
  000ab	74 11		 je	 SHORT $LN15@IsCanNotIt
  000ad	6a 09		 push	 9
  000af	6a 05		 push	 5
  000b1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b6	83 c4 08	 add	 esp, 8
  000b9	39 45 08	 cmp	 DWORD PTR _ItemType$[ebp], eax
  000bc	75 04		 jne	 SHORT $LN3@IsCanNotIt
$LN15@IsCanNotIt:

; 3233 : 	{	// 홀리스프릿보우, 드래곤소울지팡이
; 3234 : 		return FALSE;

  000be	33 c0		 xor	 eax, eax
  000c0	eb 05		 jmp	 SHORT $LN1@IsCanNotIt
$LN3@IsCanNotIt:

; 3235 : 	}
; 3236 : 	return TRUE;

  000c2	b8 01 00 00 00	 mov	 eax, 1
$LN1@IsCanNotIt:

; 3237 : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?IsCanNotItemDtopInDevilSquare@@YAHH@Z ENDP		; IsCanNotItemDtopInDevilSquare
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?InventoryDropItem@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_DropItem$ = 12						; size = 4
?InventoryDropItem@@YAXPAVOBJECTSTRUCT@@H@Z PROC	; InventoryDropItem, COMDAT

; 3146 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3147 : 
; 3148 : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?InventoryDropItem@@YAXPAVOBJECTSTRUCT@@H@Z ENDP	; InventoryDropItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjTrapAttackEnemySearch@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_tObjNum$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjTrapAttackEnemySearch@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjTrapAttackEnemySearch, COMDAT

; 3026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3027 : 	int  tObjNum;
; 3028 : 	lpObj->TargetNumber = -1;

  00009	83 c8 ff	 or	 eax, -1
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0000f	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 3029 : 	for( int i=0; i<MAX_MONVIEWPORTOBJECT; i++)

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN4@gObjTrapAt
$LN2@gObjTrapAt:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@gObjTrapAt:
  00028	83 7d f8 14	 cmp	 DWORD PTR _i$1[ebp], 20	; 00000014H
  0002c	0f 8d bf 00 00
	00		 jge	 $LN1@gObjTrapAt

; 3030 : 	{
; 3031 : 		tObjNum = lpObj->VpPlayer2[i].number;

  00032	6b 45 f8 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00039	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  00041	89 55 fc	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 3032 : 		if( tObjNum >= 0 )

  00044	83 7d fc 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00048	0f 8c 9e 00 00
	00		 jl	 $LN5@gObjTrapAt

; 3033 : 		{
; 3034 : 			if( gObj[tObjNum].Type == OBJTYPE_CHARACTER && gObj[tObjNum].Live )

  0004e	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005b	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00060	83 fa 01	 cmp	 edx, 1
  00063	0f 85 83 00 00
	00		 jne	 $LN5@gObjTrapAt
  00069	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00076	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  0007b	85 d2		 test	 edx, edx
  0007d	74 6d		 je	 SHORT $LN5@gObjTrapAt

; 3035 : 			{
; 3036 : 				if( (lpObj->Y == gObj[tObjNum].Y) && (lpObj->X == gObj[tObjNum].X) )

  0007f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00082	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00089	69 55 fc a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00095	0f bf 94 10 06
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+262]
  0009d	3b ca		 cmp	 ecx, edx
  0009f	75 4b		 jne	 SHORT $LN5@gObjTrapAt
  000a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a4	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000ab	69 55 fc a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b7	0f bf 94 10 04
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+260]
  000bf	3b ca		 cmp	 ecx, edx
  000c1	75 29		 jne	 SHORT $LN5@gObjTrapAt

; 3037 : 				{
; 3038 : 					if( (gObj[tObjNum].Authority&AUTHORITY_ADMIN) != AUTHORITY_ADMIN ) 

  000c3	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d0	8b 94 01 a4 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+420]
  000d7	83 e2 02	 and	 edx, 2
  000da	75 10		 jne	 SHORT $LN5@gObjTrapAt

; 3039 : 					{
; 3040 : 						lpObj->TargetNumber = tObjNum;

  000dc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000df	66 8b 4d fc	 mov	 cx, WORD PTR _tObjNum$[ebp]
  000e3	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx

; 3041 : 						return;

  000ea	eb 05		 jmp	 SHORT $LN1@gObjTrapAt
$LN5@gObjTrapAt:

; 3042 : 					}
; 3043 : 				}
; 3044 : 			}
; 3045 : 		}
; 3046 : 	}	

  000ec	e9 2e ff ff ff	 jmp	 $LN2@gObjTrapAt
$LN1@gObjTrapAt:

; 3047 : }

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?gObjTrapAttackEnemySearch@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjTrapAttackEnemySearch
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjTrapAttackEnemySearchY@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_n$2 = -16						; size = 4
_x$ = -12						; size = 4
_pos$ = -8						; size = 4
_tObjNum$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_count$ = 12						; size = 4
?gObjTrapAttackEnemySearchY@@YAXPAVOBJECTSTRUCT@@H@Z PROC ; gObjTrapAttackEnemySearchY, COMDAT

; 2994 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2995 : 	int  tObjNum;
; 2996 : 
; 2997 : 	lpObj->TargetNumber = -1;

  00009	83 c8 ff	 or	 eax, -1
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0000f	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 2998 : 
; 2999 : 	int pos = lpObj->Y;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00020	89 4d f8	 mov	 DWORD PTR _pos$[ebp], ecx

; 3000 : 	int x   = lpObj->X;

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00026	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0002d	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 3001 : 	for( int n=0; n<count; n++)

  00030	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$2[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@gObjTrapAt
$LN2@gObjTrapAt:
  00039	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f0	 mov	 DWORD PTR _n$2[ebp], eax
$LN4@gObjTrapAt:
  00042	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  00045	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  00048	0f 8d d5 00 00
	00		 jge	 $LN1@gObjTrapAt

; 3002 : 	{
; 3003 : 		pos--;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _pos$[ebp]
  00051	83 e8 01	 sub	 eax, 1
  00054	89 45 f8	 mov	 DWORD PTR _pos$[ebp], eax

; 3004 : 		for( int i=0; i<MAX_MONVIEWPORTOBJECT; i++)

  00057	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0005e	eb 09		 jmp	 SHORT $LN7@gObjTrapAt
$LN5@gObjTrapAt:
  00060	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN7@gObjTrapAt:
  00069	83 7d ec 14	 cmp	 DWORD PTR _i$1[ebp], 20	; 00000014H
  0006d	0f 8d ab 00 00
	00		 jge	 $LN6@gObjTrapAt

; 3005 : 		{
; 3006 : 			tObjNum = lpObj->VpPlayer2[i].number;

  00073	6b 45 ec 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007a	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  00082	89 55 fc	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 3007 : 			if( tObjNum >= 0) 

  00085	83 7d fc 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00089	0f 8c 8a 00 00
	00		 jl	 $LN8@gObjTrapAt

; 3008 : 			{
; 3009 : 				if( gObj[tObjNum].Type == OBJTYPE_CHARACTER && gObj[tObjNum].Live )

  0008f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009c	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000a1	83 fa 01	 cmp	 edx, 1
  000a4	75 73		 jne	 SHORT $LN8@gObjTrapAt
  000a6	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b3	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  000b8	85 d2		 test	 edx, edx
  000ba	74 5d		 je	 SHORT $LN8@gObjTrapAt

; 3010 : 				{
; 3011 : 					if( (pos == gObj[tObjNum].Y) && (x == gObj[tObjNum].X) )

  000bc	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c9	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  000d1	39 55 f8	 cmp	 DWORD PTR _pos$[ebp], edx
  000d4	75 43		 jne	 SHORT $LN8@gObjTrapAt
  000d6	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e3	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  000eb	39 55 f4	 cmp	 DWORD PTR _x$[ebp], edx
  000ee	75 29		 jne	 SHORT $LN8@gObjTrapAt

; 3012 : 					{
; 3013 : 						if( (gObj[tObjNum].Authority&AUTHORITY_ADMIN) != AUTHORITY_ADMIN ) 

  000f0	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fd	8b 94 01 a4 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+420]
  00104	83 e2 02	 and	 edx, 2
  00107	75 10		 jne	 SHORT $LN8@gObjTrapAt

; 3014 : 						{
; 3015 : 							lpObj->TargetNumber = tObjNum;

  00109	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	66 8b 4d fc	 mov	 cx, WORD PTR _tObjNum$[ebp]
  00110	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx

; 3016 : 							return;

  00117	eb 0a		 jmp	 SHORT $LN1@gObjTrapAt
$LN8@gObjTrapAt:

; 3017 : 						}
; 3018 : 					}
; 3019 : 				}
; 3020 : 			}
; 3021 : 		}

  00119	e9 42 ff ff ff	 jmp	 $LN5@gObjTrapAt
$LN6@gObjTrapAt:

; 3022 : 	}

  0011e	e9 16 ff ff ff	 jmp	 $LN2@gObjTrapAt
$LN1@gObjTrapAt:

; 3023 : }

  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
?gObjTrapAttackEnemySearchY@@YAXPAVOBJECTSTRUCT@@H@Z ENDP ; gObjTrapAttackEnemySearchY
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjTrapAttackEnemySearchX@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_n$2 = -16						; size = 4
_y$ = -12						; size = 4
_pos$ = -8						; size = 4
_tObjNum$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_count$ = 12						; size = 4
?gObjTrapAttackEnemySearchX@@YAXPAVOBJECTSTRUCT@@H@Z PROC ; gObjTrapAttackEnemySearchX, COMDAT

; 2962 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2963 : 	int  tObjNum;
; 2964 : 
; 2965 : 	lpObj->TargetNumber = -1;

  00009	83 c8 ff	 or	 eax, -1
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0000f	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 2966 : 
; 2967 : 	int pos = lpObj->X;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00020	89 4d f8	 mov	 DWORD PTR _pos$[ebp], ecx

; 2968 : 	int y   = lpObj->Y;

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00026	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0002d	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx

; 2969 : 	for( int n=0; n<count; n++)

  00030	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$2[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@gObjTrapAt
$LN2@gObjTrapAt:
  00039	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f0	 mov	 DWORD PTR _n$2[ebp], eax
$LN4@gObjTrapAt:
  00042	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  00045	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  00048	0f 8d d5 00 00
	00		 jge	 $LN1@gObjTrapAt

; 2970 : 	{
; 2971 : 		pos++;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _pos$[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 45 f8	 mov	 DWORD PTR _pos$[ebp], eax

; 2972 : 		for( int i=0; i<MAX_MONVIEWPORTOBJECT; i++)

  00057	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0005e	eb 09		 jmp	 SHORT $LN7@gObjTrapAt
$LN5@gObjTrapAt:
  00060	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN7@gObjTrapAt:
  00069	83 7d ec 14	 cmp	 DWORD PTR _i$1[ebp], 20	; 00000014H
  0006d	0f 8d ab 00 00
	00		 jge	 $LN6@gObjTrapAt

; 2973 : 		{
; 2974 : 			tObjNum = lpObj->VpPlayer2[i].number;

  00073	6b 45 ec 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007a	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  00082	89 55 fc	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 2975 : 			if( tObjNum >= 0  )

  00085	83 7d fc 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00089	0f 8c 8a 00 00
	00		 jl	 $LN8@gObjTrapAt

; 2976 : 			{
; 2977 : 				if( gObj[tObjNum].Type == OBJTYPE_CHARACTER && gObj[tObjNum].Live )

  0008f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009c	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000a1	83 fa 01	 cmp	 edx, 1
  000a4	75 73		 jne	 SHORT $LN8@gObjTrapAt
  000a6	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b3	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  000b8	85 d2		 test	 edx, edx
  000ba	74 5d		 je	 SHORT $LN8@gObjTrapAt

; 2978 : 				{
; 2979 : 					if( (y == gObj[tObjNum].Y) && (pos == gObj[tObjNum].X) )

  000bc	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c9	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  000d1	39 55 f4	 cmp	 DWORD PTR _y$[ebp], edx
  000d4	75 43		 jne	 SHORT $LN8@gObjTrapAt
  000d6	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e3	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  000eb	39 55 f8	 cmp	 DWORD PTR _pos$[ebp], edx
  000ee	75 29		 jne	 SHORT $LN8@gObjTrapAt

; 2980 : 					{
; 2981 : 						if( (gObj[tObjNum].Authority&AUTHORITY_ADMIN) != AUTHORITY_ADMIN ) 

  000f0	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fd	8b 94 01 a4 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+420]
  00104	83 e2 02	 and	 edx, 2
  00107	75 10		 jne	 SHORT $LN8@gObjTrapAt

; 2982 : 						{
; 2983 : 							lpObj->TargetNumber = tObjNum;

  00109	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	66 8b 4d fc	 mov	 cx, WORD PTR _tObjNum$[ebp]
  00110	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx

; 2984 : 							return;

  00117	eb 0a		 jmp	 SHORT $LN1@gObjTrapAt
$LN8@gObjTrapAt:

; 2985 : 						}
; 2986 : 					}
; 2987 : 				}
; 2988 : 			}
; 2989 : 		}

  00119	e9 42 ff ff ff	 jmp	 $LN5@gObjTrapAt
$LN6@gObjTrapAt:

; 2990 : 	}

  0011e	e9 16 ff ff ff	 jmp	 $LN2@gObjTrapAt
$LN1@gObjTrapAt:

; 2991 : }

  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
?gObjTrapAttackEnemySearchX@@YAXPAVOBJECTSTRUCT@@H@Z ENDP ; gObjTrapAttackEnemySearchX
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjGuardSearchEnemy@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_attr$ = -29						; size = 1
_tObjNum$ = -28						; size = 4
_searchtarget$ = -24					; size = 4
_mindis$ = -20						; size = 4
_dis$ = -16						; size = 4
_ty$ = -12						; size = 4
_tx$ = -8						; size = 4
_n$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjGuardSearchEnemy@@YAHPAVOBJECTSTRUCT@@@Z PROC	; gObjGuardSearchEnemy, COMDAT

; 920  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 921  : 	int n;
; 922  : 	int tx, ty;
; 923  : 	int dis;
; 924  : 	int mindis=lpObj->m_ViewRange;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f bf 88 fc 02
	00 00		 movsx	 ecx, WORD PTR [eax+764]
  00013	89 4d ec	 mov	 DWORD PTR _mindis$[ebp], ecx

; 925  : 	int searchtarget=-1;

  00016	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _searchtarget$[ebp], -1

; 926  : 	int tObjNum;
; 927  : 	BYTE attr;
; 928  : 	
; 929  : 	for( n=0; n<MAX_MONVIEWPORTOBJECT; n++)

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN4@gObjGuardS
$LN2@gObjGuardS:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjGuardS:
  0002f	83 7d fc 14	 cmp	 DWORD PTR _n$[ebp], 20	; 00000014H
  00033	0f 8d 59 01 00
	00		 jge	 $LN3@gObjGuardS

; 930  : 	{
; 931  : 		tObjNum = lpObj->VpPlayer2[n].number;

  00039	6b 45 fc 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00040	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  00048	89 55 e4	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 932  : 		if( tObjNum >= 0 )

  0004b	83 7d e4 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  0004f	0f 8c 38 01 00
	00		 jl	 $LN8@gObjGuardS

; 933  : 		{
; 934  : 			//if( gObj[tObjNum].Type == objtype && gObj[tObjNum].Live)	// 유저가 할당되어 있다면..
; 935  : 			//if( gObj[tObjNum].Live)	// 유저가 할당되어 있다면..
; 936  : 
; 937  : #ifdef UPDATE_PK_SYSTEM_20070302		// 살인마와 파티를 했을경우 경비원에게 공격 당함
; 938  : 			BOOL	PKFlag = FALSE;
; 939  : 			if(gObj[tObjNum].PartyNumber >= 0)	// 파티에 속할경우
; 940  : 			{
; 941  : 				if( gParty.GetPKPartyPenalty(gObj[tObjNum].PartyNumber) > PK_LEVEL_DEFAULT+1)
; 942  : 				{
; 943  : 					PKFlag = TRUE;
; 944  : 				}
; 945  : 			}
; 946  : 			else
; 947  : 			{
; 948  : 				if(gObj[tObjNum].m_PK_Level > PK_LEVEL_DEFAULT+1)
; 949  : 				{
; 950  : 					PKFlag = TRUE;
; 951  : 				}
; 952  : 			}
; 953  : 
; 954  : 			if( gObj[tObjNum].Type == OBJTYPE_CHARACTER&& PKFlag == TRUE )
; 955  : #else
; 956  : 			if( (gObj[tObjNum].Type == OBJTYPE_CHARACTER&&

  00055	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00062	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00067	83 fa 01	 cmp	 edx, 1
  0006a	0f 85 1d 01 00
	00		 jne	 $LN8@gObjGuardS
  00070	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007d	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00085	83 fa 04	 cmp	 edx, 4
  00088	0f 8e ff 00 00
	00		 jle	 $LN8@gObjGuardS

; 957  : 				gObj[tObjNum].m_PK_Level > PK_LEVEL_DEFAULT+1) )
; 958  : #endif
; 959  : 			{
; 960  : 				attr= MapC[gObj[tObjNum].MapNumber].GetAttr(gObj[tObjNum].X, gObj[tObjNum].Y);

  0008e	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009b	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  000a3	52		 push	 edx
  000a4	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b1	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  000b9	52		 push	 edx
  000ba	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000cf	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  000d5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000db	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000e0	88 45 e3	 mov	 BYTE PTR _attr$[ebp], al

; 961  : 
; 962  : 				if( (attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE )

  000e3	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  000e7	83 e0 01	 and	 eax, 1
  000ea	0f 85 9d 00 00
	00		 jne	 $LN8@gObjGuardS

; 963  : 				{
; 964  : 					tx = lpObj->X-gObj[tObjNum].X;

  000f0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f3	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000fa	69 55 e4 a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  00101	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00106	0f bf 94 10 04
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+260]
  0010e	2b ca		 sub	 ecx, edx
  00110	89 4d f8	 mov	 DWORD PTR _tx$[ebp], ecx

; 965  : 					ty = lpObj->Y-gObj[tObjNum].Y;

  00113	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00116	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0011d	69 55 e4 a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  00124	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00129	0f bf 94 10 06
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+262]
  00131	2b ca		 sub	 ecx, edx
  00133	89 4d f4	 mov	 DWORD PTR _ty$[ebp], ecx

; 966  : 					
; 967  : 					dis = (int)sqrt((double)(tx*tx)+(ty*ty));

  00136	8b 45 f8	 mov	 eax, DWORD PTR _tx$[ebp]
  00139	0f af 45 f8	 imul	 eax, DWORD PTR _tx$[ebp]
  0013d	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00141	8b 4d f4	 mov	 ecx, DWORD PTR _ty$[ebp]
  00144	0f af 4d f4	 imul	 ecx, DWORD PTR _ty$[ebp]
  00148	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  0014c	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00150	83 ec 08	 sub	 esp, 8
  00153	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00158	e8 00 00 00 00	 call	 _sqrt
  0015d	83 c4 08	 add	 esp, 8
  00160	e8 00 00 00 00	 call	 __ftol2_sse
  00165	89 45 f0	 mov	 DWORD PTR _dis$[ebp], eax

; 968  : 					lpObj->VpPlayer2[n].dis = dis;

  00168	6b 45 fc 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0016f	8b 55 f0	 mov	 edx, DWORD PTR _dis$[ebp]
  00172	89 94 01 f0 06
	00 00		 mov	 DWORD PTR [ecx+eax+1776], edx

; 969  : 					//if( dis <= 3 )	// 최소 영역에 들어오고..
; 970  : 					{	// 다른 애들보다 가까이 있다면..
; 971  : 						if( dis < mindis ) {

  00179	8b 45 f0	 mov	 eax, DWORD PTR _dis$[ebp]
  0017c	3b 45 ec	 cmp	 eax, DWORD PTR _mindis$[ebp]
  0017f	7d 0c		 jge	 SHORT $LN8@gObjGuardS

; 972  : 							searchtarget = tObjNum;

  00181	8b 45 e4	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00184	89 45 e8	 mov	 DWORD PTR _searchtarget$[ebp], eax

; 973  : 							mindis = dis;

  00187	8b 45 f0	 mov	 eax, DWORD PTR _dis$[ebp]
  0018a	89 45 ec	 mov	 DWORD PTR _mindis$[ebp], eax
$LN8@gObjGuardS:

; 974  : 						}
; 975  : 					}
; 976  : 				}
; 977  : 			}
; 978  : 		}
; 979  : 	}

  0018d	e9 94 fe ff ff	 jmp	 $LN2@gObjGuardS
$LN3@gObjGuardS:

; 980  : 	return searchtarget;

  00192	8b 45 e8	 mov	 eax, DWORD PTR _searchtarget$[ebp]

; 981  : }

  00195	5f		 pop	 edi
  00196	5e		 pop	 esi
  00197	5b		 pop	 ebx
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
?gObjGuardSearchEnemy@@YAHPAVOBJECTSTRUCT@@@Z ENDP	; gObjGuardSearchEnemy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjGetTargetPos@@YAHPAVOBJECTSTRUCT@@HHAAH1@Z
_TEXT	SEGMENT
tv138 = -104						; size = 4
_dis$ = -36						; size = 4
_attr$ = -29						; size = 1
_searchcount$ = -28					; size = 4
_sn$ = -24						; size = 4
_searchp$ = -20						; size = 4
_mty$ = -16						; size = 4
_mtx$ = -12						; size = 4
_tpy$ = -8						; size = 4
_tpx$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_tx$ = 20						; size = 4
_ty$ = 24						; size = 4
?gObjGetTargetPos@@YAHPAVOBJECTSTRUCT@@HHAAH1@Z PROC	; gObjGetTargetPos, COMDAT

; 718  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 719  : 	int tpx, tpy, mtx, mty;
; 720  : 	int searchp=0, sn=0;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _searchp$[ebp], 0
  00010	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _sn$[ebp], 0

; 721  : 	int searchcount=7;

  00017	c7 45 e4 07 00
	00 00		 mov	 DWORD PTR _searchcount$[ebp], 7

; 722  : 	BYTE attr;
; 723  : 	//BOOL result;
; 724  : 	
; 725  : 	mtx = tpx = sx;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00021	89 45 fc	 mov	 DWORD PTR _tpx$[ebp], eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _tpx$[ebp]
  00027	89 4d f4	 mov	 DWORD PTR _mtx$[ebp], ecx

; 726  : 	mty = tpy = sy;

  0002a	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  0002d	89 45 f8	 mov	 DWORD PTR _tpy$[ebp], eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _tpy$[ebp]
  00033	89 4d f0	 mov	 DWORD PTR _mty$[ebp], ecx

; 727  : 	
; 728  : 	int dis;
; 729  : 
; 730  : 	// 공격 형태가 100을 넘으면.. 공격길이를 2배로..
; 731  : 	if( lpObj->m_AttackType >= 100 )

  00036	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00039	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  00040	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00043	7c 12		 jl	 SHORT $LN4@gObjGetTar

; 732  : 	{
; 733  : 		dis = lpObj->m_AttackRange+2;

  00045	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00048	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  0004f	83 c1 02	 add	 ecx, 2
  00052	89 4d dc	 mov	 DWORD PTR _dis$[ebp], ecx

; 734  : 	}

  00055	eb 0d		 jmp	 SHORT $LN5@gObjGetTar
$LN4@gObjGetTar:

; 735  : 	else dis = lpObj->m_AttackRange;

  00057	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005a	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  00061	89 4d dc	 mov	 DWORD PTR _dis$[ebp], ecx
$LN5@gObjGetTar:

; 736  : 	
; 737  : 	// 타겟 근처로 위치를 잡는다.
; 738  : 	if( lpObj->X < mtx ) tpx -= dis;

  00064	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00067	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0006e	3b 4d f4	 cmp	 ecx, DWORD PTR _mtx$[ebp]
  00071	7d 09		 jge	 SHORT $LN6@gObjGetTar
  00073	8b 45 fc	 mov	 eax, DWORD PTR _tpx$[ebp]
  00076	2b 45 dc	 sub	 eax, DWORD PTR _dis$[ebp]
  00079	89 45 fc	 mov	 DWORD PTR _tpx$[ebp], eax
$LN6@gObjGetTar:

; 739  : 	if( lpObj->X > mtx ) tpx += dis;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007f	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00086	3b 4d f4	 cmp	 ecx, DWORD PTR _mtx$[ebp]
  00089	7e 09		 jle	 SHORT $LN7@gObjGetTar
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _tpx$[ebp]
  0008e	03 45 dc	 add	 eax, DWORD PTR _dis$[ebp]
  00091	89 45 fc	 mov	 DWORD PTR _tpx$[ebp], eax
$LN7@gObjGetTar:

; 740  : 	if( lpObj->Y < mty ) tpy -= dis;

  00094	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00097	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0009e	3b 4d f0	 cmp	 ecx, DWORD PTR _mty$[ebp]
  000a1	7d 09		 jge	 SHORT $LN8@gObjGetTar
  000a3	8b 45 f8	 mov	 eax, DWORD PTR _tpy$[ebp]
  000a6	2b 45 dc	 sub	 eax, DWORD PTR _dis$[ebp]
  000a9	89 45 f8	 mov	 DWORD PTR _tpy$[ebp], eax
$LN8@gObjGetTar:

; 741  : 	if( lpObj->Y > mty ) tpy += dis;

  000ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000af	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000b6	3b 4d f0	 cmp	 ecx, DWORD PTR _mty$[ebp]
  000b9	7e 09		 jle	 SHORT $LN9@gObjGetTar
  000bb	8b 45 f8	 mov	 eax, DWORD PTR _tpy$[ebp]
  000be	03 45 dc	 add	 eax, DWORD PTR _dis$[ebp]
  000c1	89 45 f8	 mov	 DWORD PTR _tpy$[ebp], eax
$LN9@gObjGetTar:

; 742  : 
; 743  : 	searchp = GetPathPacketDirPos(sx-tpx, sy-tpy)*2;

  000c4	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  000c7	2b 45 f8	 sub	 eax, DWORD PTR _tpy$[ebp]
  000ca	50		 push	 eax
  000cb	8b 4d 0c	 mov	 ecx, DWORD PTR _sx$[ebp]
  000ce	2b 4d fc	 sub	 ecx, DWORD PTR _tpx$[ebp]
  000d1	51		 push	 ecx
  000d2	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  000d7	83 c4 08	 add	 esp, 8
  000da	0f b6 d0	 movzx	 edx, al
  000dd	d1 e2		 shl	 edx, 1
  000df	89 55 ec	 mov	 DWORD PTR _searchp$[ebp], edx

; 744  : 	if( MapC[lpObj->MapNumber].GetStandAttr( tpx, tpy) == FALSE )	// 갈수 없다면.

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _tpy$[ebp]
  000e5	50		 push	 eax
  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _tpx$[ebp]
  000e9	51		 push	 ecx
  000ea	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ed	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000f4	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  000fa	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00100	e8 00 00 00 00	 call	 ?GetStandAttr@MapClass@@QAEHHH@Z ; MapClass::GetStandAttr
  00105	85 c0		 test	 eax, eax
  00107	0f 85 c6 00 00
	00		 jne	 $LN10@gObjGetTar
$LN2@gObjGetTar:

; 745  : 	{
; 746  : 		while(searchcount--)

  0010d	8b 45 e4	 mov	 eax, DWORD PTR _searchcount$[ebp]
  00110	89 45 98	 mov	 DWORD PTR tv138[ebp], eax
  00113	8b 4d e4	 mov	 ecx, DWORD PTR _searchcount$[ebp]
  00116	83 e9 01	 sub	 ecx, 1
  00119	89 4d e4	 mov	 DWORD PTR _searchcount$[ebp], ecx
  0011c	83 7d 98 00	 cmp	 DWORD PTR tv138[ebp], 0
  00120	0f 84 a1 00 00
	00		 je	 $LN3@gObjGetTar

; 747  : 		{
; 748  : 			mtx = sx+RoadPathTable[searchp];

  00126	8b 45 ec	 mov	 eax, DWORD PTR _searchp$[ebp]
  00129	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[eax*2]
  00131	03 4d 0c	 add	 ecx, DWORD PTR _sx$[ebp]
  00134	89 4d f4	 mov	 DWORD PTR _mtx$[ebp], ecx

; 749  : 			mty = sy+RoadPathTable[searchp+1];

  00137	8b 45 ec	 mov	 eax, DWORD PTR _searchp$[ebp]
  0013a	0f bf 0c 45 02
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[eax*2+2]
  00142	03 4d 10	 add	 ecx, DWORD PTR _sy$[ebp]
  00145	89 4d f0	 mov	 DWORD PTR _mty$[ebp], ecx

; 750  : 			
; 751  : 			//  자리가 비어있으면..
; 752  : 			attr= MapC[lpObj->MapNumber].GetAttr(mtx, mty);

  00148	8b 45 f0	 mov	 eax, DWORD PTR _mty$[ebp]
  0014b	50		 push	 eax
  0014c	8b 4d f4	 mov	 ecx, DWORD PTR _mtx$[ebp]
  0014f	51		 push	 ecx
  00150	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00153	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0015a	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00160	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00166	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0016b	88 45 e3	 mov	 BYTE PTR _attr$[ebp], al

; 753  : 			//result = gObjMonsterMoveCheck(lpObj, mtx, mty);
; 754  : 
; 755  : 			/*if( lpObj->Class == 249 )
; 756  : 			{
; 757  : 				if( ((attr&0x02) != 0x02) && (result==TRUE) )
; 758  : 				{
; 759  : 					lpObj->MTX = mtx;
; 760  : 					lpObj->MTY = mty;
; 761  : 					return TRUE;
; 762  : 				}
; 763  : 			}
; 764  : 			else
; 765  : 			{*/
; 766  : 				if(    ((attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE) 
; 767  : 					&& ((attr&MAP_ATTR_STAND) != MAP_ATTR_STAND) 
; 768  : 					&& ((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) 
; 769  : 					&& ((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW)) 

  0016e	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00172	83 e0 01	 and	 eax, 1
  00175	75 35		 jne	 SHORT $LN12@gObjGetTar
  00177	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0017b	83 e0 02	 and	 eax, 2
  0017e	75 2c		 jne	 SHORT $LN12@gObjGetTar
  00180	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00184	83 e0 04	 and	 eax, 4
  00187	75 23		 jne	 SHORT $LN12@gObjGetTar
  00189	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0018d	83 e0 08	 and	 eax, 8
  00190	75 1a		 jne	 SHORT $LN12@gObjGetTar

; 770  : 					//&& (result==TRUE) )
; 771  : 				{
; 772  : 					tx = mtx;

  00192	8b 45 14	 mov	 eax, DWORD PTR _tx$[ebp]
  00195	8b 4d f4	 mov	 ecx, DWORD PTR _mtx$[ebp]
  00198	89 08		 mov	 DWORD PTR [eax], ecx

; 773  : 					ty = mty;

  0019a	8b 45 18	 mov	 eax, DWORD PTR _ty$[ebp]
  0019d	8b 4d f0	 mov	 ecx, DWORD PTR _mty$[ebp]
  001a0	89 08		 mov	 DWORD PTR [eax], ecx

; 774  : 					return TRUE;

  001a2	b8 01 00 00 00	 mov	 eax, 1
  001a7	e9 cd 00 00 00	 jmp	 $LN1@gObjGetTar
$LN12@gObjGetTar:

; 775  : 				}
; 776  : 			//}
; 777  : 			searchp += 2;

  001ac	8b 45 ec	 mov	 eax, DWORD PTR _searchp$[ebp]
  001af	83 c0 02	 add	 eax, 2
  001b2	89 45 ec	 mov	 DWORD PTR _searchp$[ebp], eax

; 778  : 
; 779  : 			if( searchp > 15 ) searchp = 0;

  001b5	83 7d ec 0f	 cmp	 DWORD PTR _searchp$[ebp], 15 ; 0000000fH
  001b9	7e 07		 jle	 SHORT $LN13@gObjGetTar
  001bb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _searchp$[ebp], 0
$LN13@gObjGetTar:

; 780  : 		}		

  001c2	e9 46 ff ff ff	 jmp	 $LN2@gObjGetTar
$LN3@gObjGetTar:

; 781  : 		return FALSE;

  001c7	33 c0		 xor	 eax, eax
  001c9	e9 ab 00 00 00	 jmp	 $LN1@gObjGetTar

; 782  : 	}

  001ce	e9 a4 00 00 00	 jmp	 $LN11@gObjGetTar
$LN10@gObjGetTar:

; 783  : 	else
; 784  : 	{
; 785  : 		attr= MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  001d3	8b 45 f8	 mov	 eax, DWORD PTR _tpy$[ebp]
  001d6	50		 push	 eax
  001d7	8b 4d fc	 mov	 ecx, DWORD PTR _tpx$[ebp]
  001da	51		 push	 ecx
  001db	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001de	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  001e5	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  001eb	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  001f1	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  001f6	88 45 e3	 mov	 BYTE PTR _attr$[ebp], al

; 786  : 		//result = gObjMonsterMoveCheck(lpObj, mtx, mty);
; 787  : 		/*if( lpObj->Class == 249 )
; 788  : 		{
; 789  : 			if( ((attr&0x02) != 0x02) && (result==TRUE) ) 
; 790  : 			{
; 791  : 				lpObj->MTX = tpx;
; 792  : 				lpObj->MTY = tpy;
; 793  : 				return TRUE;
; 794  : 			}
; 795  : 
; 796  : 		}
; 797  : 		else
; 798  : 		{*/
; 799  : 		if( lpObj->m_Attribute>= 100 )

  001f9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fc	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  00203	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00206	7c 34		 jl	 SHORT $LN14@gObjGetTar

; 800  : 		{
; 801  : 			if(	((attr&MAP_ATTR_STAND) != MAP_ATTR_STAND) &&
; 802  : 				((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) &&

  00208	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0020c	83 e0 02	 and	 eax, 2
  0020f	75 29		 jne	 SHORT $LN16@gObjGetTar
  00211	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00215	83 e0 04	 and	 eax, 4
  00218	75 20		 jne	 SHORT $LN16@gObjGetTar
  0021a	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0021e	83 e0 08	 and	 eax, 8
  00221	75 17		 jne	 SHORT $LN16@gObjGetTar

; 803  : 				((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW) )
; 804  : 				//(result==TRUE) ) // 안전지대와 못 가는길이면..
; 805  : 			{
; 806  : 				tx = tpx;

  00223	8b 45 14	 mov	 eax, DWORD PTR _tx$[ebp]
  00226	8b 4d fc	 mov	 ecx, DWORD PTR _tpx$[ebp]
  00229	89 08		 mov	 DWORD PTR [eax], ecx

; 807  : 				ty = tpy;

  0022b	8b 45 18	 mov	 eax, DWORD PTR _ty$[ebp]
  0022e	8b 4d f8	 mov	 ecx, DWORD PTR _tpy$[ebp]
  00231	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 				return TRUE;

  00233	b8 01 00 00 00	 mov	 eax, 1
  00238	eb 3f		 jmp	 SHORT $LN1@gObjGetTar
$LN16@gObjGetTar:

; 809  : 			}
; 810  : 		}

  0023a	eb 3b		 jmp	 SHORT $LN11@gObjGetTar
$LN14@gObjGetTar:

; 811  : 		else
; 812  : 		{
; 813  : 			if( ((attr&0x01) != 0x01) && 
; 814  : 				((attr&0x02) != 0x02) &&
; 815  : 				((attr&0x04) != 0x04) &&

  0023c	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00240	83 e0 01	 and	 eax, 1
  00243	75 32		 jne	 SHORT $LN11@gObjGetTar
  00245	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00249	83 e0 02	 and	 eax, 2
  0024c	75 29		 jne	 SHORT $LN11@gObjGetTar
  0024e	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00252	83 e0 04	 and	 eax, 4
  00255	75 20		 jne	 SHORT $LN11@gObjGetTar
  00257	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0025b	83 e0 08	 and	 eax, 8
  0025e	75 17		 jne	 SHORT $LN11@gObjGetTar

; 816  : 				((attr&0x08) != 0x08) )
; 817  : 				//(result==TRUE) ) // 안전지대와 못 가는길이면..
; 818  : 			{
; 819  : 				tx = tpx;

  00260	8b 45 14	 mov	 eax, DWORD PTR _tx$[ebp]
  00263	8b 4d fc	 mov	 ecx, DWORD PTR _tpx$[ebp]
  00266	89 08		 mov	 DWORD PTR [eax], ecx

; 820  : 				ty = tpy;

  00268	8b 45 18	 mov	 eax, DWORD PTR _ty$[ebp]
  0026b	8b 4d f8	 mov	 ecx, DWORD PTR _tpy$[ebp]
  0026e	89 08		 mov	 DWORD PTR [eax], ecx

; 821  : 				return TRUE;

  00270	b8 01 00 00 00	 mov	 eax, 1
  00275	eb 02		 jmp	 SHORT $LN1@gObjGetTar
$LN11@gObjGetTar:

; 822  : 			}
; 823  : 		}
; 824  : 	}
; 825  : 	return FALSE;

  00277	33 c0		 xor	 eax, eax
$LN1@gObjGetTar:

; 826  : }

  00279	5f		 pop	 edi
  0027a	5e		 pop	 esi
  0027b	5b		 pop	 ebx
  0027c	8b e5		 mov	 esp, ebp
  0027e	5d		 pop	 ebp
  0027f	c3		 ret	 0
?gObjGetTargetPos@@YAHPAVOBJECTSTRUCT@@HHAAH1@Z ENDP	; gObjGetTargetPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterMoveCheck@@YAHPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_dis$ = -8						; size = 4
_lpPos$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_tx$ = 12						; size = 4
_ty$ = 16						; size = 4
?gObjMonsterMoveCheck@@YAHPAVOBJECTSTRUCT@@HH@Z PROC	; gObjMonsterMoveCheck, COMDAT

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 526  : 	// 열받았을땐 이동해도 된다.
; 527  : 	if( lpObj->m_ActState.Emotion == 1 ) return TRUE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00012	c1 e9 04	 shr	 ecx, 4
  00015	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00018	83 f9 01	 cmp	 ecx, 1
  0001b	75 0a		 jne	 SHORT $LN2@gObjMonste
  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	e9 91 00 00 00	 jmp	 $LN1@gObjMonste
$LN2@gObjMonste:

; 528  : 
; 529  : #ifdef ADD_KANTURU_20060627
; 530  : 	if( lpObj->MapNumber == MAP_INDEX_KANTURU_BOSS && lpObj->m_PosNum < 0 )
; 531  : 	{
; 532  : 		tx -= lpObj->StartX;
; 533  : 		ty -= lpObj->StartY;
; 534  : 
; 535  : 		int dis = ( int )sqrt( (double)( tx * tx ) + ( ty * ty ) );
; 536  : 
; 537  : 		if( dis > 30 ) 
; 538  : 		{
; 539  : 			LogAddTD( "[ KANTURU ][ Debug - m_PosNum ] Fail %s(Index:%d) X%d-Y%d -> X%d-Y%d(%d)",
; 540  : 				lpObj->Name, lpObj->Class, lpObj->StartX, lpObj->StartY, tx, ty, dis );
; 541  : 			return FALSE;		
; 542  : 		}
; 543  : 	}
; 544  : 	else
; 545  : 	{
; 546  : 		LPMONSTER_POSITION lpPos = (LPMONSTER_POSITION)&gMSetBase.m_Mp[lpObj->m_PosNum];
; 547  : 
; 548  : 		if( lpPos->m_Dis < 1 ) return FALSE;
; 549  : 
; 550  : 		tx -= lpObj->StartX;
; 551  : 		ty -= lpObj->StartY;
; 552  : 
; 553  : 		int dis = (int)sqrt((double)(tx*tx)+(ty*ty));
; 554  : 
; 555  : 		if( dis > lpPos->m_Dis ) return FALSE;
; 556  : 	}
; 557  : #else
; 558  : 	LPMONSTER_POSITION lpPos = (LPMONSTER_POSITION)&gMSetBase.m_Mp[lpObj->m_PosNum];

  00027	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002a	0f bf 88 0c 02
	00 00		 movsx	 ecx, WORD PTR [eax+524]
  00031	6b d1 0c	 imul	 edx, ecx, 12
  00034	81 c2 04 00 00
	00		 add	 edx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+4
  0003a	89 55 fc	 mov	 DWORD PTR _lpPos$[ebp], edx

; 559  : 
; 560  : 	if( lpPos->m_Dis < 1 ) return FALSE;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _lpPos$[ebp]
  00040	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00044	83 f9 01	 cmp	 ecx, 1
  00047	7d 04		 jge	 SHORT $LN3@gObjMonste
  00049	33 c0		 xor	 eax, eax
  0004b	eb 6b		 jmp	 SHORT $LN1@gObjMonste
$LN3@gObjMonste:

; 561  : 
; 562  : 	tx -= lpObj->StartX;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00050	0f b6 88 1a 01
	00 00		 movzx	 ecx, BYTE PTR [eax+282]
  00057	8b 55 0c	 mov	 edx, DWORD PTR _tx$[ebp]
  0005a	2b d1		 sub	 edx, ecx
  0005c	89 55 0c	 mov	 DWORD PTR _tx$[ebp], edx

; 563  : 	ty -= lpObj->StartY;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00062	0f b6 88 1b 01
	00 00		 movzx	 ecx, BYTE PTR [eax+283]
  00069	8b 55 10	 mov	 edx, DWORD PTR _ty$[ebp]
  0006c	2b d1		 sub	 edx, ecx
  0006e	89 55 10	 mov	 DWORD PTR _ty$[ebp], edx

; 564  : 
; 565  : 	int dis = (int)sqrt((double)(tx*tx)+(ty*ty));

  00071	8b 45 0c	 mov	 eax, DWORD PTR _tx$[ebp]
  00074	0f af 45 0c	 imul	 eax, DWORD PTR _tx$[ebp]
  00078	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  0007c	8b 4d 10	 mov	 ecx, DWORD PTR _ty$[ebp]
  0007f	0f af 4d 10	 imul	 ecx, DWORD PTR _ty$[ebp]
  00083	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  00087	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0008b	83 ec 08	 sub	 esp, 8
  0008e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00093	e8 00 00 00 00	 call	 _sqrt
  00098	83 c4 08	 add	 esp, 8
  0009b	e8 00 00 00 00	 call	 __ftol2_sse
  000a0	89 45 f8	 mov	 DWORD PTR _dis$[ebp], eax

; 566  : 
; 567  : 	if( dis > lpPos->m_Dis ) return FALSE;

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _lpPos$[ebp]
  000a6	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  000aa	39 4d f8	 cmp	 DWORD PTR _dis$[ebp], ecx
  000ad	7e 04		 jle	 SHORT $LN4@gObjMonste
  000af	33 c0		 xor	 eax, eax
  000b1	eb 05		 jmp	 SHORT $LN1@gObjMonste
$LN4@gObjMonste:

; 568  : #endif
; 569  : 
; 570  : 	return TRUE;

  000b3	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjMonste:

; 571  : }

  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?gObjMonsterMoveCheck@@YAHPAVOBJECTSTRUCT@@HH@Z ENDP	; gObjMonsterMoveCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterViewportIsCharacter@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_tObjNum$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterViewportIsCharacter@@YAHPAVOBJECTSTRUCT@@@Z PROC ; gObjMonsterViewportIsCharacter, COMDAT

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 357  : 	int tObjNum;
; 358  : 
; 359  : 	for(int n=0; n<MAX_MONVIEWPORTOBJECT; n++)

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  00012	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjMonste:
  0001b	83 7d f8 14	 cmp	 DWORD PTR _n$1[ebp], 20	; 00000014H
  0001f	7d 3b		 jge	 SHORT $LN3@gObjMonste

; 360  : 	{
; 361  : 		if( lpObj->VpPlayer2[n].state )

  00021	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00028	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  00030	85 d2		 test	 edx, edx
  00032	74 26		 je	 SHORT $LN5@gObjMonste

; 362  : 		{
; 363  : 			tObjNum = lpObj->VpPlayer2[n].number;

  00034	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0003b	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  00043	89 55 fc	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 364  : 			if( tObjNum == lpObj->TargetNumber ) // 대상 유저와 같다면..

  00046	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00049	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00050	39 4d fc	 cmp	 DWORD PTR _tObjNum$[ebp], ecx
  00053	75 05		 jne	 SHORT $LN5@gObjMonste

; 365  : 				return n;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00058	eb 05		 jmp	 SHORT $LN1@gObjMonste
$LN5@gObjMonste:

; 366  : 		}
; 367  : 	}

  0005a	eb b6		 jmp	 SHORT $LN2@gObjMonste
$LN3@gObjMonste:

; 368  : 	return -1;

  0005c	83 c8 ff	 or	 eax, -1
$LN1@gObjMonste:

; 369  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?gObjMonsterViewportIsCharacter@@YAHPAVOBJECTSTRUCT@@@Z ENDP ; gObjMonsterViewportIsCharacter
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterMoveRegen@@YAXHHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_lpObj$ = 16						; size = 4
?gObjMonsterMoveRegen@@YAXHHPAVOBJECTSTRUCT@@@Z PROC	; gObjMonsterMoveRegen, COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 161  : 	gMSetBase.GetBoxPosition(lpObj->MapNumber, x-1, y-1, x+1, y+1, lpObj->X, lpObj->Y);

  00009	8b 45 10	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00011	50		 push	 eax
  00012	8b 4d 10	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00015	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  0001b	51		 push	 ecx
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0001f	83 c2 01	 add	 edx, 1
  00022	52		 push	 edx
  00023	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00026	83 c0 01	 add	 eax, 1
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0002d	83 e9 01	 sub	 ecx, 1
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00034	83 ea 01	 sub	 edx, 1
  00037	52		 push	 edx
  00038	8b 45 10	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00042	51		 push	 ecx
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  00048	e8 00 00 00 00	 call	 ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition

; 162  : 	lpObj->TX = lpObj->X;

  0004d	8b 45 10	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00050	8b 4d 10	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00053	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  0005a	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 163  : 	lpObj->TY = lpObj->Y;

  00061	8b 45 10	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00064	8b 4d 10	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00067	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  0006e	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 164  : 	lpObj->MTX = lpObj->X;

  00075	8b 45 10	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00078	8b 4d 10	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007b	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  00082	66 89 90 24 01
	00 00		 mov	 WORD PTR [eax+292], dx

; 165  : 	lpObj->MTY = lpObj->Y;

  00089	8b 45 10	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	8b 4d 10	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0008f	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  00096	66 89 90 26 01
	00 00		 mov	 WORD PTR [eax+294], dx

; 166  : 	lpObj->StartX = (BYTE)lpObj->X;

  0009d	8b 45 10	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a0	8b 4d 10	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a3	8a 91 04 01 00
	00		 mov	 dl, BYTE PTR [ecx+260]
  000a9	88 90 1a 01 00
	00		 mov	 BYTE PTR [eax+282], dl

; 167  : 	lpObj->StartY = (BYTE)lpObj->Y;

  000af	8b 45 10	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b2	8b 4d 10	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b5	8a 91 06 01 00
	00		 mov	 dl, BYTE PTR [ecx+262]
  000bb	88 90 1b 01 00
	00		 mov	 BYTE PTR [eax+283], dl

; 168  : 	//LogAdd("위치 이동 %d %d", x, y);
; 169  : }

  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
?gObjMonsterMoveRegen@@YAXHHPAVOBJECTSTRUCT@@@Z ENDP	; gObjMonsterMoveRegen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gEventMonsterItemDrop@@YAHPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv647 = -200						; size = 4
tv648 = -196						; size = 4
_MaxHitUser$1 = -128					; size = 4
_iDropRate$2 = -124					; size = 4
_MaxHitUser$3 = -120					; size = 4
_MaxHitUser$4 = -116					; size = 4
_MaxHitUser$5 = -112					; size = 4
_MaxHitUser$6 = -108					; size = 4
_MaxHitUser$7 = -104					; size = 4
_MaxHitUser$8 = -100					; size = 4
_MaxHitUser$9 = -96					; size = 4
_MaxHitUser$10 = -92					; size = 4
_MaxHitUser$11 = -88					; size = 4
_MaxHitUser$12 = -84					; size = 4
_lpattr$13 = -80					; size = 4
_MaxHitUser$14 = -76					; size = 4
_lpattr$15 = -72					; size = 4
_lpattr$16 = -68					; size = 4
_partycount$17 = -64					; size = 4
_MaxHitUser$18 = -60					; size = 4
_MaxHitUser$19 = -56					; size = 4
_lpattr$20 = -52					; size = 4
_MaxHitUser$21 = -48					; size = 4
_callbead_level$22 = -44				; size = 4
_level$23 = -40						; size = 4
_lpattr$24 = -36					; size = 4
_Option3$ = -32						; size = 4
_Option2$ = -28						; size = 4
_Option1$ = -24						; size = 4
_dur$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_level$ = -8						; size = 4
_type$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gEventMonsterItemDrop@@YAHPAVOBJECTSTRUCT@@0@Z PROC	; gEventMonsterItemDrop, COMDAT

; 4883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 4884 : 	
; 4885 : 	int type, level, x, y;
; 4886 : 	float dur=0;

  0000c	0f 57 c0	 xorps	 xmm0, xmm0
  0000f	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4887 : 	int Option1 = 0;

  00014	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 4888 : 	int Option2 = 0;

  0001b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 4889 : 	int Option3 = 0;

  00022	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 4890 : 
; 4891 : 
; 4892 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 4893 : 	// 펜릴 재료 아이템 드랍
; 4894 : 	if( g_bFenrirStuffItemDrop )
; 4895 : 	{
; 4896 : 		Option1 = 0;
; 4897 : 		Option2 = 0;
; 4898 : 		Option3 = 0;
; 4899 : 
; 4900 : 		BOOL bDropStuff = FALSE;
; 4901 : 
; 4902 : 		// 1. > 갑옷 파편 드랍
; 4903 : 		if( lpObj->Level >= g_iFenrirStuff_01_DropLv_Min 
; 4904 : 			&& lpObj->Level <= g_iFenrirStuff_01_DropLv_Max 
; 4905 : 			&& lpObj->MapNumber == g_iFenrirStuff_01_DropMap 
; 4906 : 			&& !bDropStuff )
; 4907 : 		{
; 4908 : 			if( (rand()%10000) < g_iFenrirStuff_01_DropRate )
; 4909 : 			{
; 4910 : 				bDropStuff	= TRUE;
; 4911 : 				type		= ItemGetNumberMake(13,32);
; 4912 : 				
; 4913 : 			}
; 4914 : 		}
; 4915 : 
; 4916 : 		// 2. > 여신의 가호 드랍
; 4917 : 		if( lpObj->Level >= g_iFenrirStuff_02_DropLv_Min 
; 4918 : 			&& lpObj->Level <= g_iFenrirStuff_02_DropLv_Max
; 4919 : 			&& lpObj->MapNumber == g_iFenrirStuff_02_DropMap
; 4920 : 			&& !bDropStuff )
; 4921 : 		{
; 4922 : 			if( (rand()%10000) < g_iFenrirStuff_02_DropRate )
; 4923 : 			{
; 4924 : 				bDropStuff	= TRUE;
; 4925 : 				type		= ItemGetNumberMake(13,33);
; 4926 : 			}
; 4927 : 		}
; 4928 : 
; 4929 : 		// 3. > 맹수의 발톱 드랍
; 4930 : 		if( lpObj->Level >= g_iFenrirStuff_03_DropLv_Min 
; 4931 : 			&& lpObj->Level <= g_iFenrirStuff_03_DropLv_Max
; 4932 : 			&& lpObj->MapNumber == g_iFenrirStuff_03_DropMap
; 4933 : 			&& !bDropStuff )
; 4934 : 		{
; 4935 : 			if( (rand()%10000) < g_iFenrirStuff_03_DropRate )
; 4936 : 			{
; 4937 : 				bDropStuff	= TRUE;
; 4938 : 				type		= ItemGetNumberMake(13,34);
; 4939 : 			}
; 4940 : 		}
; 4941 : 
; 4942 : 		if( bDropStuff )
; 4943 : 		{
; 4944 : 			level   = 0;
; 4945 : 			x		= lpObj->X;
; 4946 : 			y		= lpObj->Y;
; 4947 : 			dur		= 1;
; 4948 : 			
; 4949 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4950 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 4951 : 			return TRUE;
; 4952 : 		}
; 4953 : 		
; 4954 : 	}
; 4955 : #endif // ADD_ITEM_FENRIR_01_20051110
; 4956 : 	
; 4957 : #ifdef MODIFY_SET_SEED_SPHERE_DROP_RATE_20080903
; 4958 : 	int iSphereItemCode = 0;
; 4959 : 	iSphereItemCode = g_SocketOptionSystem.GetSphereDropInfo( lpObj->Level );
; 4960 : 
; 4961 : 	if( iSphereItemCode != -1 )
; 4962 : 	{
; 4963 : 		int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4964 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, iSphereItemCode, 0, 1, 0, 0, 0, iMaxHitUser);
; 4965 : 		return TRUE;
; 4966 : 	}
; 4967 : #endif // MODIFY_SET_SEED_SPHERE_DROP_RATE_20080903
; 4968 : 	
; 4969 : #ifdef ADD_SHIELD_POINT_01_20060403
; 4970 : 	if( g_CompoundPotionDropOn == TRUE )
; 4971 : 	{
; 4972 : 		BOOL bDropStuff = FALSE;
; 4973 : 		int iType		= 0;
; 4974 : 
; 4975 : 		if( lpObj->Level >= g_iCompoundPotionLv1DropLevel )
; 4976 : 		{
; 4977 : 			if( ( (rand()%10000) <= g_iCompoundPotionLv1DropRate )
; 4978 : 				&& ( bDropStuff == FALSE )
; 4979 : 				)
; 4980 : 			{
; 4981 : 				bDropStuff	= TRUE;
; 4982 : 				iType		=ItemGetNumberMake(14,38);		// 작은 복합 물약
; 4983 : 			}
; 4984 : 		}
; 4985 : 		
; 4986 : 		if ( bDropStuff == FALSE && lpObj->Level >= g_iCompoundPotionLv2DropLevel )
; 4987 : 		{
; 4988 : 			if( (rand()%10000) <= g_iCompoundPotionLv2DropRate )
; 4989 : 			{
; 4990 : 				bDropStuff = TRUE;
; 4991 : 				iType		=ItemGetNumberMake(14,39);		// 중간 복합 물약
; 4992 : 			}
; 4993 : 		}
; 4994 : 
; 4995 : 		if ( bDropStuff == FALSE && lpObj->Level >= g_iCompoundPotionLv3DropLevel )
; 4996 : 		{
; 4997 : 			if( (rand()%10000) <= g_iCompoundPotionLv3DropRate )
; 4998 : 			{
; 4999 : 				bDropStuff = TRUE;
; 5000 : 				iType		=ItemGetNumberMake(14,40);		// 큰 복합 물약
; 5001 : 			}
; 5002 : 		}
; 5003 : 
; 5004 : 		if( bDropStuff == TRUE )
; 5005 : 		{
; 5006 : 			int level		= 0;
; 5007 : 			int dur			= 1;
; 5008 : 			int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5009 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, iType, level, (BYTE)dur, 0, 0, 0, iMaxHitUser);
; 5010 : 			return TRUE;
; 5011 : 		}
; 5012 : 	}
; 5013 : #endif // ADD_SHIELD_POINT_01_20060403
; 5014 : 
; 5015 : #ifdef ITEMDROP_RINGOFTRANSFORM
; 5016 : 	if( gIsItemDropRingOfTransform )

  00029	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsItemDropRingOfTransform@@3HA, 0 ; gIsItemDropRingOfTransform
  00030	0f 84 36 01 00
	00		 je	 $LN4@gEventMons

; 5017 : 	{	
; 5018 : 		// 변신 반지 드롭
; 5019 : 		if( (rand()%10000) < gItemDropRingOfTransform )

  00036	e8 00 00 00 00	 call	 _rand
  0003b	99		 cdq
  0003c	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00041	f7 f9		 idiv	 ecx
  00043	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gItemDropRingOfTransform@@3HA ; gItemDropRingOfTransform
  00049	0f 8d 1d 01 00
	00		 jge	 $LN4@gEventMons

; 5020 : 		{
; 5021 : 			LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);

  0004f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00052	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00059	51		 push	 ecx
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  0005f	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  00064	89 45 dc	 mov	 DWORD PTR _lpattr$24[ebp], eax

; 5022 : 			if( lpattr )

  00067	83 7d dc 00	 cmp	 DWORD PTR _lpattr$24[ebp], 0
  0006b	0f 84 fb 00 00
	00		 je	 $LN4@gEventMons

; 5023 : 			{
; 5024 : 				int level = lpattr->m_Level;												

  00071	8b 45 dc	 mov	 eax, DWORD PTR _lpattr$24[ebp]
  00074	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00077	89 4d d8	 mov	 DWORD PTR _level$23[ebp], ecx

; 5025 : 				int callbead_level=0;

  0007a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _callbead_level$22[ebp], 0

; 5026 : 				if( level < 0 ) level = 0;

  00081	83 7d d8 00	 cmp	 DWORD PTR _level$23[ebp], 0
  00085	7d 07		 jge	 SHORT $LN5@gEventMons
  00087	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _level$23[ebp], 0
$LN5@gEventMons:

; 5027 : 				callbead_level = level/10;

  0008e	8b 45 d8	 mov	 eax, DWORD PTR _level$23[ebp]
  00091	99		 cdq
  00092	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00097	f7 f9		 idiv	 ecx
  00099	89 45 d4	 mov	 DWORD PTR _callbead_level$22[ebp], eax

; 5028 : 				if( callbead_level > 0 ) callbead_level -= 1;

  0009c	83 7d d4 00	 cmp	 DWORD PTR _callbead_level$22[ebp], 0
  000a0	7e 09		 jle	 SHORT $LN6@gEventMons
  000a2	8b 45 d4	 mov	 eax, DWORD PTR _callbead_level$22[ebp]
  000a5	83 e8 01	 sub	 eax, 1
  000a8	89 45 d4	 mov	 DWORD PTR _callbead_level$22[ebp], eax
$LN6@gEventMons:

; 5029 : 				if( callbead_level > 5 ) callbead_level = 5;				

  000ab	83 7d d4 05	 cmp	 DWORD PTR _callbead_level$22[ebp], 5
  000af	7e 07		 jle	 SHORT $LN7@gEventMons
  000b1	c7 45 d4 05 00
	00 00		 mov	 DWORD PTR _callbead_level$22[ebp], 5
$LN7@gEventMons:

; 5030 : 
; 5031 : 				dur  = (float)100+(rand()%100);	// 내구도 설정

  000b8	e8 00 00 00 00	 call	 _rand
  000bd	99		 cdq
  000be	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000c3	f7 f9		 idiv	 ecx
  000c5	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  000c9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@42c80000
  000d1	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5032 : 				x    = lpObj->X;

  000d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d9	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000e0	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5033 : 				y    = lpObj->Y;

  000e3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e6	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000ed	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5034 : 				level= callbead_level;			// 변신 반지 레벨

  000f0	8b 45 d4	 mov	 eax, DWORD PTR _callbead_level$22[ebp]
  000f3	89 45 d8	 mov	 DWORD PTR _level$23[ebp], eax

; 5035 : 				type = ItemGetNumberMake(13, 10);			

  000f6	6a 0a		 push	 10			; 0000000aH
  000f8	6a 0d		 push	 13			; 0000000dH
  000fa	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000ff	83 c4 08	 add	 esp, 8
  00102	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5036 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00105	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0010e	83 c4 04	 add	 esp, 4
  00111	89 45 d0	 mov	 DWORD PTR _MaxHitUser$21[ebp], eax

; 5037 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00114	6a 00		 push	 0
  00116	6a 00		 push	 0
  00118	6a 00		 push	 0
  0011a	8b 45 d0	 mov	 eax, DWORD PTR _MaxHitUser$21[ebp]
  0011d	50		 push	 eax
  0011e	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00122	51		 push	 ecx
  00123	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00127	52		 push	 edx
  00128	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  0012c	50		 push	 eax
  0012d	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00132	0f b6 d1	 movzx	 edx, cl
  00135	52		 push	 edx
  00136	0f b6 45 d8	 movzx	 eax, BYTE PTR _level$23[ebp]
  0013a	50		 push	 eax
  0013b	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  0013e	51		 push	 ecx
  0013f	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  00143	52		 push	 edx
  00144	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  00148	50		 push	 eax
  00149	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0014c	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00153	52		 push	 edx
  00154	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00157	8b 08		 mov	 ecx, DWORD PTR [eax]
  00159	51		 push	 ecx
  0015a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0015f	83 c4 38	 add	 esp, 56			; 00000038H

; 5038 : 				return TRUE;				

  00162	b8 01 00 00 00	 mov	 eax, 1
  00167	e9 57 0f 00 00	 jmp	 $LN1@gEventMons
$LN4@gEventMons:

; 5039 : 			}	
; 5040 : 		}
; 5041 : 	}
; 5042 : #endif
; 5043 : 
; 5044 : 
; 5045 : 	if( gFireCrackerEvent )

  0016c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gFireCrackerEvent@@3HA, 0 ; gFireCrackerEvent
  00173	0f 84 33 02 00
	00		 je	 $LN19@gEventMons

; 5046 : 	{	
; 5047 : 		// 폭죽 이벤트가 진행줄일때
; 5048 : 		if( gLanguage == 0 )

  00179	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLanguage@@3HA, 0 ; gLanguage
  00180	0f 85 04 01 00
	00		 jne	 $LN9@gEventMons

; 5049 : 		{	
; 5050 : 			// 한국일때는 다르게 처리 된다
; 5051 : 
; 5052 : 			if( lpObj->MapNumber < 7 )

  00186	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00189	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00190	83 f9 07	 cmp	 ecx, 7
  00193	0f 8d ec 00 00
	00		 jge	 $LN14@gEventMons

; 5053 : 			{	
; 5054 : 				// 아틀란스 이하에서만 나온다
; 5055 : 				LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);

  00199	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001a3	51		 push	 ecx
  001a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  001a9	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  001ae	89 45 cc	 mov	 DWORD PTR _lpattr$20[ebp], eax

; 5056 : 				if( lpattr )

  001b1	83 7d cc 00	 cmp	 DWORD PTR _lpattr$20[ebp], 0
  001b5	0f 84 ca 00 00
	00		 je	 $LN14@gEventMons

; 5057 : 				{
; 5058 : 					if( lpattr->m_Level >= 17 )

  001bb	8b 45 cc	 mov	 eax, DWORD PTR _lpattr$20[ebp]
  001be	83 78 1c 11	 cmp	 DWORD PTR [eax+28], 17	; 00000011H
  001c2	0f 8c bd 00 00
	00		 jl	 $LN14@gEventMons

; 5059 : 					{	
; 5060 : 						// 자이언트 이상일때만
; 5061 : 						if( (rand()%10000) < gFireCrackerDropRate )

  001c8	e8 00 00 00 00	 call	 _rand
  001cd	99		 cdq
  001ce	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  001d3	f7 f9		 idiv	 ecx
  001d5	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gFireCrackerDropRate@@3HA ; gFireCrackerDropRate
  001db	0f 8d a4 00 00
	00		 jge	 $LN14@gEventMons

; 5062 : 						{
; 5063 : 							dur  = 255;

  001e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  001e9	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5064 : 							x    = lpObj->X;

  001ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f1	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  001f8	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5065 : 							y    = lpObj->Y;

  001fb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fe	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00205	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5066 : 							level= 2;	// 폭죽

  00208	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _level$[ebp], 2

; 5067 : 							type = ItemGetNumberMake(14, 11);			

  0020f	6a 0b		 push	 11			; 0000000bH
  00211	6a 0e		 push	 14			; 0000000eH
  00213	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00218	83 c4 08	 add	 esp, 8
  0021b	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5068 : 							int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0021e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00227	83 c4 04	 add	 esp, 4
  0022a	89 45 c8	 mov	 DWORD PTR _MaxHitUser$19[ebp], eax

; 5069 : 							ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  0022d	6a 00		 push	 0
  0022f	6a 00		 push	 0
  00231	6a 00		 push	 0
  00233	8b 45 c8	 mov	 eax, DWORD PTR _MaxHitUser$19[ebp]
  00236	50		 push	 eax
  00237	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  0023b	51		 push	 ecx
  0023c	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00240	52		 push	 edx
  00241	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00245	50		 push	 eax
  00246	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  0024b	0f b6 d1	 movzx	 edx, cl
  0024e	52		 push	 edx
  0024f	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  00253	50		 push	 eax
  00254	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  00257	51		 push	 ecx
  00258	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  0025c	52		 push	 edx
  0025d	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  00261	50		 push	 eax
  00262	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00265	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0026c	52		 push	 edx
  0026d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00270	8b 08		 mov	 ecx, DWORD PTR [eax]
  00272	51		 push	 ecx
  00273	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00278	83 c4 38	 add	 esp, 56			; 00000038H

; 5070 : 							return TRUE;

  0027b	b8 01 00 00 00	 mov	 eax, 1
  00280	e9 3e 0e 00 00	 jmp	 $LN1@gEventMons
$LN14@gEventMons:

; 5071 : 						}
; 5072 : 					}
; 5073 : 				}
; 5074 : 			}
; 5075 : 		}

  00285	e9 22 01 00 00	 jmp	 $LN19@gEventMons
$LN9@gEventMons:

; 5076 : 		else
; 5077 : 		{
; 5078 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0028a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00293	83 c4 04	 add	 esp, 4
  00296	89 45 c4	 mov	 DWORD PTR _MaxHitUser$18[ebp], eax

; 5079 : 			if( MaxHitUser != -1 )

  00299	83 7d c4 ff	 cmp	 DWORD PTR _MaxHitUser$18[ebp], -1
  0029d	0f 84 09 01 00
	00		 je	 $LN19@gEventMons

; 5080 : 			{
; 5081 : 				int partycount = gParty.GetPartyCount(gObj[MaxHitUser].PartyNumber);

  002a3	69 45 c4 a0 1b
	00 00		 imul	 eax, DWORD PTR _MaxHitUser$18[ebp], 7072
  002aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b0	8b 94 01 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+648]
  002b7	52		 push	 edx
  002b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  002bd	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount
  002c2	89 45 c0	 mov	 DWORD PTR _partycount$17[ebp], eax

; 5082 : 
; 5083 : 				if( partycount > 0 )

  002c5	83 7d c0 00	 cmp	 DWORD PTR _partycount$17[ebp], 0
  002c9	0f 8e dd 00 00
	00		 jle	 $LN19@gEventMons

; 5084 : 				{	// 파티를 맺었을때만 
; 5085 : 					LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);	

  002cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  002d9	51		 push	 ecx
  002da	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  002df	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  002e4	89 45 bc	 mov	 DWORD PTR _lpattr$16[ebp], eax

; 5086 : 
; 5087 : 					if( lpattr )

  002e7	83 7d bc 00	 cmp	 DWORD PTR _lpattr$16[ebp], 0
  002eb	0f 84 bb 00 00
	00		 je	 $LN19@gEventMons

; 5088 : 					{
; 5089 : 						if( lpattr->m_Level >= 17 )

  002f1	8b 45 bc	 mov	 eax, DWORD PTR _lpattr$16[ebp]
  002f4	83 78 1c 11	 cmp	 DWORD PTR [eax+28], 17	; 00000011H
  002f8	0f 8c ae 00 00
	00		 jl	 $LN19@gEventMons

; 5090 : 						{	// 자이언트 이상일때만
; 5091 : 							if( (rand()%10000) < gFireCrackerDropRate )

  002fe	e8 00 00 00 00	 call	 _rand
  00303	99		 cdq
  00304	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00309	f7 f9		 idiv	 ecx
  0030b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gFireCrackerDropRate@@3HA ; gFireCrackerDropRate
  00311	0f 8d 95 00 00
	00		 jge	 $LN19@gEventMons

; 5092 : 							{
; 5093 : 								dur  = 255;

  00317	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  0031f	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5094 : 								x    = lpObj->X;

  00324	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00327	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0032e	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5095 : 								y    = lpObj->Y;

  00331	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00334	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0033b	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5096 : 								level= 2;	// 폭죽

  0033e	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _level$[ebp], 2

; 5097 : 								type = ItemGetNumberMake(14, 11);			

  00345	6a 0b		 push	 11			; 0000000bH
  00347	6a 0e		 push	 14			; 0000000eH
  00349	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0034e	83 c4 08	 add	 esp, 8
  00351	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5098 : 								ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00354	6a 00		 push	 0
  00356	6a 00		 push	 0
  00358	6a 00		 push	 0
  0035a	8b 45 c4	 mov	 eax, DWORD PTR _MaxHitUser$18[ebp]
  0035d	50		 push	 eax
  0035e	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00362	51		 push	 ecx
  00363	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00367	52		 push	 edx
  00368	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  0036c	50		 push	 eax
  0036d	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00372	0f b6 d1	 movzx	 edx, cl
  00375	52		 push	 edx
  00376	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  0037a	50		 push	 eax
  0037b	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  0037e	51		 push	 ecx
  0037f	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  00383	52		 push	 edx
  00384	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  00388	50		 push	 eax
  00389	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0038c	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00393	52		 push	 edx
  00394	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00397	8b 08		 mov	 ecx, DWORD PTR [eax]
  00399	51		 push	 ecx
  0039a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0039f	83 c4 38	 add	 esp, 56			; 00000038H

; 5099 : 								return TRUE;

  003a2	b8 01 00 00 00	 mov	 eax, 1
  003a7	e9 17 0d 00 00	 jmp	 $LN1@gEventMons
$LN19@gEventMons:

; 5100 : 							}
; 5101 : 						}
; 5102 : 					}
; 5103 : 				}
; 5104 : 			}
; 5105 : 		}		
; 5106 : 	}
; 5107 : 	
; 5108 : 	
; 5109 : 	if( gXMasEvent )

  003ac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gXMasEvent@@3HA, 0 ; gXMasEvent
  003b3	74 2f		 je	 SHORT $LN22@gEventMons

; 5110 : 	{	
; 5111 : 		// 크리스마스 이벤트 일때만
; 5112 : #ifdef EVENT_ITEMBAG_UPGRADE		
; 5113 : 		if( !StarOfXMasItemBag )

  003b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?StarOfXMasItemBag@@3PAVCItemBagEx@@A, 0 ; StarOfXMasItemBag
  003bc	75 07		 jne	 SHORT $LN21@gEventMons

; 5114 : 			return FALSE;

  003be	33 c0		 xor	 eax, eax
  003c0	e9 fe 0c 00 00	 jmp	 $LN1@gEventMons
$LN21@gEventMons:

; 5115 : 		
; 5116 : 		if( StarOfXMasItemBag->DropEventItem(lpObj->m_Index) )

  003c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ca	51		 push	 ecx
  003cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?StarOfXMasItemBag@@3PAVCItemBagEx@@A ; StarOfXMasItemBag
  003d1	e8 00 00 00 00	 call	 ?DropEventItem@CItemBagEx@@QAEHH@Z ; CItemBagEx::DropEventItem
  003d6	85 c0		 test	 eax, eax
  003d8	74 0a		 je	 SHORT $LN22@gEventMons

; 5117 : 		{
; 5118 : 			return TRUE;

  003da	b8 01 00 00 00	 mov	 eax, 1
  003df	e9 df 0c 00 00	 jmp	 $LN1@gEventMons
$LN22@gEventMons:

; 5119 : 		}
; 5120 : #else	
; 5121 : 	#ifdef XMAS_EVENT_CHANGE		
; 5122 : 			if( lpObj->MapNumber == MAP_INDEX_DEVIAS )
; 5123 : 			{	// 데비아스에서만
; 5124 : 				if( (rand()%10000) < g_XMasEvent_StarOfXMasDropRate )
; 5125 : 				{
; 5126 : 					dur  = 255;
; 5127 : 					x    = lpObj->X;
; 5128 : 					y    = lpObj->Y;
; 5129 : 					level= 1;
; 5130 : 					type = ItemGetNumberMake(14, 11);
; 5131 : 
; 5132 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5133 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5134 : 					return TRUE;
; 5135 : 				}
; 5136 : 			}
; 5137 : 	#else	
; 5138 : 			LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);	
; 5139 : 
; 5140 : 			if( lpattr )	
; 5141 : 			{
; 5142 : 				if( lpattr->m_Level >= 17 )
; 5143 : 				{	// 자이언트 이상일때만
; 5144 : 					if( (rand()%10000) < g_XMasEvent_StarOfXMasDropRate )
; 5145 : 					{
; 5146 : 						dur  = 255;
; 5147 : 						x    = lpObj->X;
; 5148 : 						y    = lpObj->Y;
; 5149 : 						level= 1;
; 5150 : 						type = ItemGetNumberMake(14, 11);
; 5151 : 
; 5152 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5153 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5154 : 						return TRUE;
; 5155 : 					}
; 5156 : 				}
; 5157 : 			}
; 5158 : 	#endif
; 5159 : #endif
; 5160 : 	}
; 5161 : 
; 5162 : 	if( gHeartOfLoveEvent )

  003e4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gHeartOfLoveEvent@@3HA, 0 ; gHeartOfLoveEvent
  003eb	0f 84 fd 01 00
	00		 je	 $LN32@gEventMons

; 5163 : 	{	
; 5164 : 		// 폭죽 이벤트가 진행줄일때		
; 5165 : 		if( gLanguage == 2 )

  003f1	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?gLanguage@@3HA, 2 ; gLanguage
  003f8	0f 85 f1 00 00
	00		 jne	 $LN24@gEventMons

; 5166 : 		{
; 5167 : 			LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);

  003fe	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00401	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00408	51		 push	 ecx
  00409	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  0040e	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  00413	89 45 b8	 mov	 DWORD PTR _lpattr$15[ebp], eax

; 5168 : 			if( lpattr )

  00416	83 7d b8 00	 cmp	 DWORD PTR _lpattr$15[ebp], 0
  0041a	0f 84 ca 00 00
	00		 je	 $LN28@gEventMons

; 5169 : 			{
; 5170 : 				if( lpattr->m_Level >= 15 )

  00420	8b 45 b8	 mov	 eax, DWORD PTR _lpattr$15[ebp]
  00423	83 78 1c 0f	 cmp	 DWORD PTR [eax+28], 15	; 0000000fH
  00427	0f 8c bd 00 00
	00		 jl	 $LN28@gEventMons

; 5171 : 				{	
; 5172 : 					// 
; 5173 : 					if( (rand()%10000) < gHeartOfLoveDropRate )

  0042d	e8 00 00 00 00	 call	 _rand
  00432	99		 cdq
  00433	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00438	f7 f9		 idiv	 ecx
  0043a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gHeartOfLoveDropRate@@3HA ; gHeartOfLoveDropRate
  00440	0f 8d a4 00 00
	00		 jge	 $LN28@gEventMons

; 5174 : 					{
; 5175 : 						dur  = 255;

  00446	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  0044e	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5176 : 						x    = lpObj->X;

  00453	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00456	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0045d	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5177 : 						y    = lpObj->Y;

  00460	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00463	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0046a	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5178 : 						level= 3;	// 사랑의 하트

  0046d	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _level$[ebp], 3

; 5179 : 						type = ItemGetNumberMake(14, 11);			

  00474	6a 0b		 push	 11			; 0000000bH
  00476	6a 0e		 push	 14			; 0000000eH
  00478	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0047d	83 c4 08	 add	 esp, 8
  00480	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5180 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00483	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0048c	83 c4 04	 add	 esp, 4
  0048f	89 45 b4	 mov	 DWORD PTR _MaxHitUser$14[ebp], eax

; 5181 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00492	6a 00		 push	 0
  00494	6a 00		 push	 0
  00496	6a 00		 push	 0
  00498	8b 45 b4	 mov	 eax, DWORD PTR _MaxHitUser$14[ebp]
  0049b	50		 push	 eax
  0049c	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  004a0	51		 push	 ecx
  004a1	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  004a5	52		 push	 edx
  004a6	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  004aa	50		 push	 eax
  004ab	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  004b0	0f b6 d1	 movzx	 edx, cl
  004b3	52		 push	 edx
  004b4	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  004b8	50		 push	 eax
  004b9	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  004bc	51		 push	 ecx
  004bd	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  004c1	52		 push	 edx
  004c2	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  004c6	50		 push	 eax
  004c7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004ca	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  004d1	52		 push	 edx
  004d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  004d7	51		 push	 ecx
  004d8	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  004dd	83 c4 38	 add	 esp, 56			; 00000038H

; 5182 : 						return TRUE;

  004e0	b8 01 00 00 00	 mov	 eax, 1
  004e5	e9 d9 0b 00 00	 jmp	 $LN1@gEventMons
$LN28@gEventMons:

; 5183 : 					}
; 5184 : 				}
; 5185 : 			}
; 5186 : 		}

  004ea	e9 ff 00 00 00	 jmp	 $LN32@gEventMons
$LN24@gEventMons:

; 5187 : 		else
; 5188 : 		{
; 5189 : 			if( lpObj->MapNumber < 7 )

  004ef	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f2	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  004f9	83 f9 07	 cmp	 ecx, 7
  004fc	0f 8d ec 00 00
	00		 jge	 $LN32@gEventMons

; 5190 : 			{	
; 5191 : 				// 아틀란스 이하에서만 나온다
; 5192 : 				LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);

  00502	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00505	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0050c	51		 push	 ecx
  0050d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00512	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  00517	89 45 b0	 mov	 DWORD PTR _lpattr$13[ebp], eax

; 5193 : 				if( lpattr )

  0051a	83 7d b0 00	 cmp	 DWORD PTR _lpattr$13[ebp], 0
  0051e	0f 84 ca 00 00
	00		 je	 $LN32@gEventMons

; 5194 : 				{
; 5195 : 					if( lpattr->m_Level >= 17 )

  00524	8b 45 b0	 mov	 eax, DWORD PTR _lpattr$13[ebp]
  00527	83 78 1c 11	 cmp	 DWORD PTR [eax+28], 17	; 00000011H
  0052b	0f 8c bd 00 00
	00		 jl	 $LN32@gEventMons

; 5196 : 					{	
; 5197 : 						// 자이언트 이상일때만
; 5198 : 						if( (rand()%10000) < gHeartOfLoveDropRate )

  00531	e8 00 00 00 00	 call	 _rand
  00536	99		 cdq
  00537	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0053c	f7 f9		 idiv	 ecx
  0053e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gHeartOfLoveDropRate@@3HA ; gHeartOfLoveDropRate
  00544	0f 8d a4 00 00
	00		 jge	 $LN32@gEventMons

; 5199 : 						{
; 5200 : 							dur  = 255;

  0054a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00552	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5201 : 							x    = lpObj->X;

  00557	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0055a	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00561	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5202 : 							y    = lpObj->Y;

  00564	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00567	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0056e	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5203 : 							level= 3;	// 사랑의 하트

  00571	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _level$[ebp], 3

; 5204 : 							type = ItemGetNumberMake(14, 11);			

  00578	6a 0b		 push	 11			; 0000000bH
  0057a	6a 0e		 push	 14			; 0000000eH
  0057c	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00581	83 c4 08	 add	 esp, 8
  00584	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5205 : 							int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00587	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0058a	50		 push	 eax
  0058b	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00590	83 c4 04	 add	 esp, 4
  00593	89 45 ac	 mov	 DWORD PTR _MaxHitUser$12[ebp], eax

; 5206 : 							ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00596	6a 00		 push	 0
  00598	6a 00		 push	 0
  0059a	6a 00		 push	 0
  0059c	8b 45 ac	 mov	 eax, DWORD PTR _MaxHitUser$12[ebp]
  0059f	50		 push	 eax
  005a0	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  005a4	51		 push	 ecx
  005a5	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  005a9	52		 push	 edx
  005aa	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  005ae	50		 push	 eax
  005af	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  005b4	0f b6 d1	 movzx	 edx, cl
  005b7	52		 push	 edx
  005b8	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  005bc	50		 push	 eax
  005bd	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  005c0	51		 push	 ecx
  005c1	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  005c5	52		 push	 edx
  005c6	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  005ca	50		 push	 eax
  005cb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005ce	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  005d5	52		 push	 edx
  005d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  005db	51		 push	 ecx
  005dc	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  005e1	83 c4 38	 add	 esp, 56			; 00000038H

; 5207 : 							return TRUE;

  005e4	b8 01 00 00 00	 mov	 eax, 1
  005e9	e9 d5 0a 00 00	 jmp	 $LN1@gEventMons
$LN32@gEventMons:

; 5208 : 						}
; 5209 : 					}
; 5210 : 				}
; 5211 : 			}
; 5212 : 		}		
; 5213 : 	}
; 5214 : 
; 5215 : 
; 5216 : 	if( gMedalEvent )

  005ee	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gMedalEvent@@3HA, 0 ; gMedalEvent
  005f5	0f 84 d2 01 00
	00		 je	 $LN40@gEventMons

; 5217 : 	{	
; 5218 : 		// 메달 이벤트가 진행중일때
; 5219 : 		if( lpObj->MapNumber == 1 || lpObj->MapNumber == 2 )

  005fb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005fe	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00605	83 f9 01	 cmp	 ecx, 1
  00608	74 13		 je	 SHORT $LN36@gEventMons
  0060a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0060d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00614	83 f9 02	 cmp	 ecx, 2
  00617	0f 85 c2 00 00
	00		 jne	 $LN34@gEventMons
$LN36@gEventMons:

; 5220 : 		{	// 데비아스 및 던전에서는 은메달이 나와야 된다			
; 5221 : 			if( (rand()%10000) < gSilverMedalDropRate )

  0061d	e8 00 00 00 00	 call	 _rand
  00622	99		 cdq
  00623	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00628	f7 f9		 idiv	 ecx
  0062a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSilverMedalDropRate@@3HA ; gSilverMedalDropRate
  00630	0f 8d a4 00 00
	00		 jge	 $LN37@gEventMons

; 5222 : 			{
; 5223 : 				dur  = 255;

  00636	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  0063e	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5224 : 				x    = lpObj->X;

  00643	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00646	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0064d	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5225 : 				y    = lpObj->Y;

  00650	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00653	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0065a	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5226 : 				level= 5;	// 은메달

  0065d	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _level$[ebp], 5

; 5227 : 				type = ItemGetNumberMake(14, 11);			

  00664	6a 0b		 push	 11			; 0000000bH
  00666	6a 0e		 push	 14			; 0000000eH
  00668	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0066d	83 c4 08	 add	 esp, 8
  00670	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5228 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00673	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00676	50		 push	 eax
  00677	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0067c	83 c4 04	 add	 esp, 4
  0067f	89 45 a8	 mov	 DWORD PTR _MaxHitUser$11[ebp], eax

; 5229 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00682	6a 00		 push	 0
  00684	6a 00		 push	 0
  00686	6a 00		 push	 0
  00688	8b 45 a8	 mov	 eax, DWORD PTR _MaxHitUser$11[ebp]
  0068b	50		 push	 eax
  0068c	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00690	51		 push	 ecx
  00691	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00695	52		 push	 edx
  00696	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  0069a	50		 push	 eax
  0069b	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  006a0	0f b6 d1	 movzx	 edx, cl
  006a3	52		 push	 edx
  006a4	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  006a8	50		 push	 eax
  006a9	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  006ac	51		 push	 ecx
  006ad	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  006b1	52		 push	 edx
  006b2	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  006b6	50		 push	 eax
  006b7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006ba	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  006c1	52		 push	 edx
  006c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  006c7	51		 push	 ecx
  006c8	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  006cd	83 c4 38	 add	 esp, 56			; 00000038H

; 5230 : 				return TRUE;

  006d0	b8 01 00 00 00	 mov	 eax, 1
  006d5	e9 e9 09 00 00	 jmp	 $LN1@gEventMons
$LN37@gEventMons:

; 5231 : 			}			
; 5232 : 		}

  006da	e9 ee 00 00 00	 jmp	 $LN40@gEventMons
$LN34@gEventMons:

; 5233 : 		else if( lpObj->MapNumber == 4 || lpObj->MapNumber == 7 || lpObj->MapNumber == 8 )

  006df	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006e2	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  006e9	83 f9 04	 cmp	 ecx, 4
  006ec	74 22		 je	 SHORT $LN39@gEventMons
  006ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006f1	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  006f8	83 f9 07	 cmp	 ecx, 7
  006fb	74 13		 je	 SHORT $LN39@gEventMons
  006fd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00700	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00707	83 f9 08	 cmp	 ecx, 8
  0070a	0f 85 bd 00 00
	00		 jne	 $LN40@gEventMons
$LN39@gEventMons:

; 5234 : 		{	// 로스트타워, 아틀란스, 타르칸에서는 금메달이 나와야 된다
; 5235 : 			if( (rand()%10000) < gGoldMedalDropRate )

  00710	e8 00 00 00 00	 call	 _rand
  00715	99		 cdq
  00716	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0071b	f7 f9		 idiv	 ecx
  0071d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gGoldMedalDropRate@@3HA ; gGoldMedalDropRate
  00723	0f 8d a4 00 00
	00		 jge	 $LN40@gEventMons

; 5236 : 			{
; 5237 : 				dur  = 255;

  00729	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00731	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5238 : 				x    = lpObj->X;

  00736	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00739	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00740	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5239 : 				y    = lpObj->Y;

  00743	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00746	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0074d	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5240 : 				level= 6;	// 금메달

  00750	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _level$[ebp], 6

; 5241 : 				type = ItemGetNumberMake(14, 11);			

  00757	6a 0b		 push	 11			; 0000000bH
  00759	6a 0e		 push	 14			; 0000000eH
  0075b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00760	83 c4 08	 add	 esp, 8
  00763	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5242 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00766	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00769	50		 push	 eax
  0076a	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0076f	83 c4 04	 add	 esp, 4
  00772	89 45 a4	 mov	 DWORD PTR _MaxHitUser$10[ebp], eax

; 5243 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00775	6a 00		 push	 0
  00777	6a 00		 push	 0
  00779	6a 00		 push	 0
  0077b	8b 45 a4	 mov	 eax, DWORD PTR _MaxHitUser$10[ebp]
  0077e	50		 push	 eax
  0077f	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00783	51		 push	 ecx
  00784	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00788	52		 push	 edx
  00789	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  0078d	50		 push	 eax
  0078e	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00793	0f b6 d1	 movzx	 edx, cl
  00796	52		 push	 edx
  00797	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  0079b	50		 push	 eax
  0079c	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  0079f	51		 push	 ecx
  007a0	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  007a4	52		 push	 edx
  007a5	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  007a9	50		 push	 eax
  007aa	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  007ad	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  007b4	52		 push	 edx
  007b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  007ba	51		 push	 ecx
  007bb	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  007c0	83 c4 38	 add	 esp, 56			; 00000038H

; 5244 : 				return TRUE;

  007c3	b8 01 00 00 00	 mov	 eax, 1
  007c8	e9 f6 08 00 00	 jmp	 $LN1@gEventMons
$LN40@gEventMons:

; 5245 : 			}			
; 5246 : 		}
; 5247 : 	}	
; 5248 : 
; 5249 : 	if( gEventChipEvent )

  007cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gEventChipEvent@@3HA, 0 ; gEventChipEvent
  007d4	0f 84 bd 00 00
	00		 je	 $LN42@gEventMons

; 5250 : 	{	// 이벤트칩 이벤트가 진행중일때				
; 5251 : 		if( (rand()%10000) < gBoxOfGoldDropRate )

  007da	e8 00 00 00 00	 call	 _rand
  007df	99		 cdq
  007e0	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  007e5	f7 f9		 idiv	 ecx
  007e7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gBoxOfGoldDropRate@@3HA ; gBoxOfGoldDropRate
  007ed	0f 8d a4 00 00
	00		 jge	 $LN42@gEventMons

; 5252 : 		{
; 5253 : 			dur  = 255;

  007f3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  007fb	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5254 : 			x    = lpObj->X;

  00800	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00803	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0080a	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5255 : 			y    = lpObj->Y;

  0080d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00810	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00817	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5256 : 			level= 7;	// 황금의 상자

  0081a	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR _level$[ebp], 7

; 5257 : 			type = ItemGetNumberMake(14, 11);			

  00821	6a 0b		 push	 11			; 0000000bH
  00823	6a 0e		 push	 14			; 0000000eH
  00825	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0082a	83 c4 08	 add	 esp, 8
  0082d	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5258 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00830	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00833	50		 push	 eax
  00834	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00839	83 c4 04	 add	 esp, 4
  0083c	89 45 a0	 mov	 DWORD PTR _MaxHitUser$9[ebp], eax

; 5259 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  0083f	6a 00		 push	 0
  00841	6a 00		 push	 0
  00843	6a 00		 push	 0
  00845	8b 45 a0	 mov	 eax, DWORD PTR _MaxHitUser$9[ebp]
  00848	50		 push	 eax
  00849	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  0084d	51		 push	 ecx
  0084e	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00852	52		 push	 edx
  00853	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00857	50		 push	 eax
  00858	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  0085d	0f b6 d1	 movzx	 edx, cl
  00860	52		 push	 edx
  00861	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  00865	50		 push	 eax
  00866	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  00869	51		 push	 ecx
  0086a	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  0086e	52		 push	 edx
  0086f	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  00873	50		 push	 eax
  00874	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00877	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0087e	52		 push	 edx
  0087f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00882	8b 08		 mov	 ecx, DWORD PTR [eax]
  00884	51		 push	 ecx
  00885	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0088a	83 c4 38	 add	 esp, 56			; 00000038H

; 5260 : 			return TRUE;

  0088d	b8 01 00 00 00	 mov	 eax, 1
  00892	e9 2c 08 00 00	 jmp	 $LN1@gEventMons
$LN42@gEventMons:

; 5261 : 		}		
; 5262 : 	}
; 5263 : 
; 5264 : #ifdef AUTH_GAMESERVER_CHECKKEY
; 5265 : 	if( szAuthKey[16] != AUTH_CHECK_16 )
; 5266 : 		DestroyGIocp();
; 5267 : #endif
; 5268 : 
; 5269 : #ifdef ADD_NEW_MAP_KALIMA_20040518	
; 5270 : 	// 쿤둔의 표식 드롭처리
; 5271 : 	if (rand()%10000 < g_iKundunMarkDropRate) 

  00897	e8 00 00 00 00	 call	 _rand
  0089c	99		 cdq
  0089d	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  008a2	f7 f9		 idiv	 ecx
  008a4	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iKundunMarkDropRate@@3HA ; g_iKundunMarkDropRate
  008aa	0f 8d 5d 01 00
	00		 jge	 $LN43@gEventMons

; 5272 : 	{
; 5273 : 		
; 5274 : #ifndef HIDDEN_KALIMA_20050706
; 5275 : 	// 쿤둔의 표식 드랍지역 제한 삭제 - hnine
; 5276 : 	#ifndef UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 5277 : 		if (CHECK_KALIMAMAP(lpObj->MapNumber)) 
; 5278 : 		{
; 5279 : 			// 칼리마 내부에서는 쿤둔의 표식이 떨어지지 않는다.
; 5280 : 			return FALSE;
; 5281 : 		}
; 5282 : 	#endif
; 5283 : #endif
; 5284 : 
; 5285 : 		Option1 = 0;

  008b0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 5286 : 		Option2 = 0;

  008b7	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 5287 : 		Option3 = 0;

  008be	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 5288 : 		dur		= 1;

  008c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  008cd	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5289 : 		x		= lpObj->X;

  008d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008d5	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  008dc	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5290 : 		y		= lpObj->Y;

  008df	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008e2	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  008e9	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5291 : 
; 5292 : 		// ### 20040906 (apple) 
; 5293 : 		level = 0;

  008ec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 5294 : 
; 5295 : #ifdef MODIFY_KALIMA_KUNDUNMARK_DROP_01_20040906
; 5296 : 		if( lpObj->Level < 25 )

  008f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008f6	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  008fd	83 f9 19	 cmp	 ecx, 25			; 00000019H
  00900	7d 09		 jge	 SHORT $LN44@gEventMons

; 5297 : 		{
; 5298 : 			level = 0;

  00902	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 5299 : 		}

  00909	eb 7f		 jmp	 SHORT $LN55@gEventMons
$LN44@gEventMons:

; 5300 : 		else if( lpObj->Level < 47)								// +1 (25~ 46)

  0090b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0090e	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00915	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00918	7d 09		 jge	 SHORT $LN46@gEventMons

; 5301 : 		{
; 5302 : 			level = 1;

  0091a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _level$[ebp], 1

; 5303 : 		}

  00921	eb 67		 jmp	 SHORT $LN55@gEventMons
$LN46@gEventMons:

; 5304 : 		else if( lpObj->Level < 66)								// +2 (47~ 65)

  00923	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00926	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0092d	83 f9 42	 cmp	 ecx, 66			; 00000042H
  00930	7d 09		 jge	 SHORT $LN48@gEventMons

; 5305 : 		{
; 5306 : 			level = 2;

  00932	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _level$[ebp], 2

; 5307 : 		}

  00939	eb 4f		 jmp	 SHORT $LN55@gEventMons
$LN48@gEventMons:

; 5308 : 		else if( lpObj->Level < 78)								// +3 (66~ 79)

  0093b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0093e	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00945	83 f9 4e	 cmp	 ecx, 78			; 0000004eH
  00948	7d 09		 jge	 SHORT $LN50@gEventMons

; 5309 : 		{
; 5310 : 			level = 3;

  0094a	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _level$[ebp], 3

; 5311 : 		}

  00951	eb 37		 jmp	 SHORT $LN55@gEventMons
$LN50@gEventMons:

; 5312 : 		else if( lpObj->Level < 84)								// +4 (80~ 85)

  00953	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00956	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0095d	83 f9 54	 cmp	 ecx, 84			; 00000054H
  00960	7d 09		 jge	 SHORT $LN52@gEventMons

; 5313 : 		{
; 5314 : 			level = 4;

  00962	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _level$[ebp], 4

; 5315 : 		}

  00969	eb 1f		 jmp	 SHORT $LN55@gEventMons
$LN52@gEventMons:

; 5316 : 		else if( lpObj->Level < 92)								// +5 (86~ 95)

  0096b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0096e	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00975	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  00978	7d 09		 jge	 SHORT $LN54@gEventMons

; 5317 : 		{
; 5318 : 			level = 5;

  0097a	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _level$[ebp], 5

; 5319 : 		}

  00981	eb 07		 jmp	 SHORT $LN55@gEventMons
$LN54@gEventMons:

; 5320 : #ifdef HIDDEN_KALIMA_20050706
; 5321 : 		else if( lpObj->Level < 114)							// +6 (92~ 114)
; 5322 : 		{
; 5323 : 			level = 6;
; 5324 : 		}
; 5325 : 	#ifdef UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 5326 : 		// 쿤둔의 표식 +7의 드랍 레벨과 지역을 수정 : 레벨 115이상, 전지역 - hnine
; 5327 : 		else if( lpObj->Level > 115 && lpObj->Level < g_GlobalConfig.m_iMaxLevel+1 )		// +7 (115~ )
; 5328 : 		{
; 5329 : 			level = 7;
; 5330 : 		}
; 5331 : 	#else
; 5332 : 		else													// +7 (115~ )
; 5333 : 		{
; 5334 : 			if (CHECK_KALIMAMAP(lpObj->MapNumber))
; 5335 : 				level = 7;
; 5336 : 			else
; 5337 : 				level = 0;
; 5338 : 		}
; 5339 : 	#endif
; 5340 : #else
; 5341 : 		else													// +6 (96~ )
; 5342 : 		{
; 5343 : 			level = 6;

  00983	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _level$[ebp], 6
$LN55@gEventMons:

; 5344 : 		}
; 5345 : #endif
; 5346 : 
; 5347 : #ifdef HIDDEN_KALIMA_20050706
; 5348 : 	#ifndef UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 5349 : 		if (level != 7 &&
; 5350 : 			CHECK_KALIMAMAP(lpObj->MapNumber)
; 5351 : 			) 
; 5352 : 		{
; 5353 : 			return FALSE;
; 5354 : 		}
; 5355 : 	#endif
; 5356 : #endif
; 5357 : 
; 5358 : 		if (level == 0)

  0098a	83 7d f8 00	 cmp	 DWORD PTR _level$[ebp], 0
  0098e	75 07		 jne	 SHORT $LN56@gEventMons

; 5359 : 			return FALSE;

  00990	33 c0		 xor	 eax, eax
  00992	e9 2c 07 00 00	 jmp	 $LN1@gEventMons
$LN56@gEventMons:

; 5360 : #endif
; 5361 : 		
; 5362 : 		type = ItemGetNumberMake(14, 29);						// 쿤둔의 표식

  00997	6a 1d		 push	 29			; 0000001dH
  00999	6a 0e		 push	 14			; 0000000eH
  0099b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  009a0	83 c4 08	 add	 esp, 8
  009a3	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5363 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  009a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009a9	50		 push	 eax
  009aa	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  009af	83 c4 04	 add	 esp, 4
  009b2	89 45 9c	 mov	 DWORD PTR _MaxHitUser$8[ebp], eax

; 5364 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  009b5	6a 00		 push	 0
  009b7	6a 00		 push	 0
  009b9	6a 00		 push	 0
  009bb	8b 45 9c	 mov	 eax, DWORD PTR _MaxHitUser$8[ebp]
  009be	50		 push	 eax
  009bf	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  009c3	51		 push	 ecx
  009c4	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  009c8	52		 push	 edx
  009c9	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  009cd	50		 push	 eax
  009ce	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  009d3	0f b6 d1	 movzx	 edx, cl
  009d6	52		 push	 edx
  009d7	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  009db	50		 push	 eax
  009dc	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  009df	51		 push	 ecx
  009e0	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  009e4	52		 push	 edx
  009e5	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  009e9	50		 push	 eax
  009ea	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009ed	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  009f4	52		 push	 edx
  009f5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  009fa	51		 push	 ecx
  009fb	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00a00	83 c4 38	 add	 esp, 56			; 00000038H

; 5365 : 		return TRUE;

  00a03	b8 01 00 00 00	 mov	 eax, 1
  00a08	e9 b6 06 00 00	 jmp	 $LN1@gEventMons
$LN43@gEventMons:

; 5366 : 	}
; 5367 : #endif
; 5368 : 	
; 5369 : 
; 5370 : #ifdef MU_CASTLESIEGE_CS_MARKS_20041214							// 성주의 표식 드롭처리
; 5371 : 	if (rand()%10000 < g_iMarkOfTheLord) {
; 5372 : 		Option1 = 0;
; 5373 : 		Option2 = 0;
; 5374 : 		Option3 = 0;
; 5375 : 		level	= 3;
; 5376 : 		dur		= 1;
; 5377 : 		x		= lpObj->X;
; 5378 : 		y		= lpObj->Y;
; 5379 : 
; 5380 : 		type = ItemGetNumberMake(14, 21);						// 성주의 표식 (레나 +3)
; 5381 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5382 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5383 : 		return TRUE;
; 5384 : 	}
; 5385 : #endif
; 5386 : 
; 5387 : 
; 5388 : #ifdef JAPAN_1ST_ANIVERSARY_BOX_20040531
; 5389 : 	if (rand()%10000 < g_iJapan1StAnivItemDropRate) {
; 5390 : 		
; 5391 : 		if( lpTargetObj->PartyNumber >= 0 )
; 5392 : 		{
; 5393 : 			dur  = 255;
; 5394 : 			x    = lpObj->X;
; 5395 : 			y    = lpObj->Y;
; 5396 : 			type = ItemGetNumberMake(14, 20);			
; 5397 : 
; 5398 : 			// 일본 1주년 기념 폭죽상자는 맵에 따라 다른 레벨이 떨어진다.
; 5399 : 			switch(lpObj->MapNumber) {
; 5400 : 			case 0 :		// 로랜시아		(+1)
; 5401 : 				{
; 5402 : 					level= 1;
; 5403 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5404 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5405 : 					return TRUE;
; 5406 : 				}
; 5407 : 				return TRUE;
; 5408 : 			case 1 :		// 던전			(+2)
; 5409 : 				{
; 5410 : 					level= 2;
; 5411 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5412 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5413 : 					return TRUE;
; 5414 : 				}
; 5415 : 				return TRUE;
; 5416 : 			case 2 :		// 데비아스		(+2)
; 5417 : 				{
; 5418 : 					level= 2;
; 5419 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5420 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5421 : 					return TRUE;
; 5422 : 				}
; 5423 : 				return TRUE;
; 5424 : 			case 3 :		// 노리아		(+1)
; 5425 : 				{
; 5426 : 					level= 1;
; 5427 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5428 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5429 : 					return TRUE;
; 5430 : 				}
; 5431 : 				return TRUE;
; 5432 : 			case 4 :		// 로스트타워	(+3)
; 5433 : 				{
; 5434 : 					level= 3;
; 5435 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5436 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5437 : 					return TRUE;
; 5438 : 				}
; 5439 : 				return TRUE;
; 5440 : 			case 7 :		// 아틀란스		(+4)
; 5441 : 				{
; 5442 : 					level= 4;
; 5443 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5444 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5445 : 					return TRUE;
; 5446 : 				}
; 5447 : 				return TRUE;
; 5448 : 			case 8 :		// 타르칸		(+5)
; 5449 : 				{
; 5450 : 					level= 5;
; 5451 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5452 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5453 : 					return TRUE;
; 5454 : 				}
; 5455 : 				return TRUE;
; 5456 : 			default:
; 5457 : 				break;
; 5458 : 			}
; 5459 : 		}
; 5460 : 	}
; 5461 : #endif
; 5462 : 
; 5463 : #ifdef DARKLORD_WORK
; 5464 : 	if( gIsDropDarkLordItem )

  00a0d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsDropDarkLordItem@@3HA, 0 ; gIsDropDarkLordItem
  00a14	0f 84 a6 02 00
	00		 je	 $LN65@gEventMons

; 5465 : 	{
; 5466 : 		// 군주의 소매 드롭 
; 5467 : 		if( lpObj->Level >= gSleeveOfLordDropLevel )

  00a1a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a1d	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00a24	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gSleeveOfLordDropLevel@@3HA ; gSleeveOfLordDropLevel
  00a2a	0f 8c cc 00 00
	00		 jl	 $LN59@gEventMons

; 5468 : 		{
; 5469 : 			if( rand()%10000 < gSleeveOfLordDropRate && (g_GlobalConfig.m_bMonarchOnlyIcarus == false || lpObj->MapNumber == MAP_INDEX_ICARUS) )

  00a30	e8 00 00 00 00	 call	 _rand
  00a35	99		 cdq
  00a36	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00a3b	f7 f9		 idiv	 ecx
  00a3d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSleeveOfLordDropRate@@3HA ; gSleeveOfLordDropRate
  00a43	0f 8d b3 00 00
	00		 jge	 $LN59@gEventMons
  00a49	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+20, 0
  00a50	74 13		 je	 SHORT $LN60@gEventMons
  00a52	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a55	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00a5c	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00a5f	0f 85 97 00 00
	00		 jne	 $LN59@gEventMons
$LN60@gEventMons:

; 5470 : 			{	
; 5471 : 				type = ItemGetNumberMake(13, 14);

  00a65	6a 0e		 push	 14			; 0000000eH
  00a67	6a 0d		 push	 13			; 0000000dH
  00a69	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00a6e	83 c4 08	 add	 esp, 8
  00a71	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5472 : 				level = 1;

  00a74	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _level$[ebp], 1

; 5473 : 				x    = lpObj->X;

  00a7b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a7e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00a85	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5474 : 				y    = lpObj->Y;

  00a88	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a8b	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00a92	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5475 : 
; 5476 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00a95	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a98	50		 push	 eax
  00a99	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00a9e	83 c4 04	 add	 esp, 4
  00aa1	89 45 98	 mov	 DWORD PTR _MaxHitUser$7[ebp], eax

; 5477 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00aa4	6a 00		 push	 0
  00aa6	6a 00		 push	 0
  00aa8	6a 00		 push	 0
  00aaa	8b 45 98	 mov	 eax, DWORD PTR _MaxHitUser$7[ebp]
  00aad	50		 push	 eax
  00aae	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00ab2	51		 push	 ecx
  00ab3	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00ab7	52		 push	 edx
  00ab8	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00abc	50		 push	 eax
  00abd	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00ac2	0f b6 d1	 movzx	 edx, cl
  00ac5	52		 push	 edx
  00ac6	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  00aca	50		 push	 eax
  00acb	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  00ace	51		 push	 ecx
  00acf	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  00ad3	52		 push	 edx
  00ad4	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  00ad8	50		 push	 eax
  00ad9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00adc	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00ae3	52		 push	 edx
  00ae4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ae7	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ae9	51		 push	 ecx
  00aea	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00aef	83 c4 38	 add	 esp, 56			; 00000038H

; 5478 : 				return TRUE;

  00af2	b8 01 00 00 00	 mov	 eax, 1
  00af7	e9 c7 05 00 00	 jmp	 $LN1@gEventMons
$LN59@gEventMons:

; 5479 : 			}
; 5480 : 		}
; 5481 : 
; 5482 : 		// 다크호스의 영혼 드롭
; 5483 : 		if( lpObj->Level >= gSoulOfDarkHorseropLevel )

  00afc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aff	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00b06	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gSoulOfDarkHorseropLevel@@3HA ; gSoulOfDarkHorseropLevel
  00b0c	0f 8c cc 00 00
	00		 jl	 $LN62@gEventMons

; 5484 : 		{
; 5485 : 			if( rand()%10000 < gSoulOfDarkHorseDropRate && (g_GlobalConfig.m_bHorsePotOnlyIcarus == false || lpObj->MapNumber == MAP_INDEX_ICARUS) )

  00b12	e8 00 00 00 00	 call	 _rand
  00b17	99		 cdq
  00b18	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00b1d	f7 f9		 idiv	 ecx
  00b1f	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSoulOfDarkHorseDropRate@@3HA ; gSoulOfDarkHorseDropRate
  00b25	0f 8d b3 00 00
	00		 jge	 $LN62@gEventMons
  00b2b	83 3d 1c 00 00
	00 00		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+28, 0
  00b32	74 13		 je	 SHORT $LN63@gEventMons
  00b34	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b37	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00b3e	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00b41	0f 85 97 00 00
	00		 jne	 $LN62@gEventMons
$LN63@gEventMons:

; 5486 : 			{	
; 5487 : 				type = ItemGetNumberMake(13, 31);

  00b47	6a 1f		 push	 31			; 0000001fH
  00b49	6a 0d		 push	 13			; 0000000dH
  00b4b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00b50	83 c4 08	 add	 esp, 8
  00b53	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5488 : 				level = 0;

  00b56	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 5489 : 				x    = lpObj->X;

  00b5d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b60	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00b67	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5490 : 				y    = lpObj->Y;

  00b6a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b6d	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00b74	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5491 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00b77	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b7a	50		 push	 eax
  00b7b	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00b80	83 c4 04	 add	 esp, 4
  00b83	89 45 94	 mov	 DWORD PTR _MaxHitUser$6[ebp], eax

; 5492 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00b86	6a 00		 push	 0
  00b88	6a 00		 push	 0
  00b8a	6a 00		 push	 0
  00b8c	8b 45 94	 mov	 eax, DWORD PTR _MaxHitUser$6[ebp]
  00b8f	50		 push	 eax
  00b90	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00b94	51		 push	 ecx
  00b95	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00b99	52		 push	 edx
  00b9a	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00b9e	50		 push	 eax
  00b9f	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00ba4	0f b6 d1	 movzx	 edx, cl
  00ba7	52		 push	 edx
  00ba8	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  00bac	50		 push	 eax
  00bad	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  00bb0	51		 push	 ecx
  00bb1	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  00bb5	52		 push	 edx
  00bb6	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  00bba	50		 push	 eax
  00bbb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bbe	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00bc5	52		 push	 edx
  00bc6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bc9	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bcb	51		 push	 ecx
  00bcc	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00bd1	83 c4 38	 add	 esp, 56			; 00000038H

; 5493 : 				return TRUE;

  00bd4	b8 01 00 00 00	 mov	 eax, 1
  00bd9	e9 e5 04 00 00	 jmp	 $LN1@gEventMons
$LN62@gEventMons:

; 5494 : 			}
; 5495 : 		}
; 5496 : 
; 5497 : 		// 다크스피릿의 영혼 드롭
; 5498 : 		if( lpObj->Level >= gSoulOfDarkSpiritDropLevel )

  00bde	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00be1	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00be8	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gSoulOfDarkSpiritDropLevel@@3HA ; gSoulOfDarkSpiritDropLevel
  00bee	0f 8c cc 00 00
	00		 jl	 $LN65@gEventMons

; 5499 : 		{
; 5500 : 			if( rand()%10000 < gSoulOfDarkSpiritDropRate && (g_GlobalConfig.m_bSpiritPotOnlyIcarus == false || lpObj->MapNumber == MAP_INDEX_ICARUS) )

  00bf4	e8 00 00 00 00	 call	 _rand
  00bf9	99		 cdq
  00bfa	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00bff	f7 f9		 idiv	 ecx
  00c01	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSoulOfDarkSpiritDropRate@@3HA ; gSoulOfDarkSpiritDropRate
  00c07	0f 8d b3 00 00
	00		 jge	 $LN65@gEventMons
  00c0d	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+24, 0
  00c14	74 13		 je	 SHORT $LN66@gEventMons
  00c16	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c19	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00c20	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00c23	0f 85 97 00 00
	00		 jne	 $LN65@gEventMons
$LN66@gEventMons:

; 5501 : 			{	
; 5502 : 				type = ItemGetNumberMake(13, 31);

  00c29	6a 1f		 push	 31			; 0000001fH
  00c2b	6a 0d		 push	 13			; 0000000dH
  00c2d	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00c32	83 c4 08	 add	 esp, 8
  00c35	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5503 : 				level = 1;

  00c38	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _level$[ebp], 1

; 5504 : 				x    = lpObj->X;

  00c3f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c42	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00c49	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5505 : 				y    = lpObj->Y;

  00c4c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c4f	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00c56	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5506 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00c59	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c5c	50		 push	 eax
  00c5d	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00c62	83 c4 04	 add	 esp, 4
  00c65	89 45 90	 mov	 DWORD PTR _MaxHitUser$5[ebp], eax

; 5507 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00c68	6a 00		 push	 0
  00c6a	6a 00		 push	 0
  00c6c	6a 00		 push	 0
  00c6e	8b 45 90	 mov	 eax, DWORD PTR _MaxHitUser$5[ebp]
  00c71	50		 push	 eax
  00c72	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00c76	51		 push	 ecx
  00c77	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00c7b	52		 push	 edx
  00c7c	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00c80	50		 push	 eax
  00c81	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00c86	0f b6 d1	 movzx	 edx, cl
  00c89	52		 push	 edx
  00c8a	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  00c8e	50		 push	 eax
  00c8f	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  00c92	51		 push	 ecx
  00c93	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  00c97	52		 push	 edx
  00c98	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  00c9c	50		 push	 eax
  00c9d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ca0	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00ca7	52		 push	 edx
  00ca8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cab	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cad	51		 push	 ecx
  00cae	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00cb3	83 c4 38	 add	 esp, 56			; 00000038H

; 5508 : 				return TRUE;

  00cb6	b8 01 00 00 00	 mov	 eax, 1
  00cbb	e9 03 04 00 00	 jmp	 $LN1@gEventMons
$LN65@gEventMons:

; 5509 : 			}
; 5510 : 		}
; 5511 : 	}
; 5512 : 
; 5513 : #endif
; 5514 : 
; 5515 : #ifdef ADD_NEW_GEM_OF_DEFEND_FOR_CS_01_20050301
; 5516 : 	// 수호보석 드랍.
; 5517 : 	if( gIsDropGemOfDefend )
; 5518 : 	{
; 5519 : 		if( ( lpObj->MapNumber != MAP_INDEX_KALIMA7 ) && ( lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE) )
; 5520 : 		{	// 수호의 보석은 칼리마7 과 성 사냥터에서만 떨어진다.
; 5521 : 			
; 5522 : 		}
; 5523 : 		else
; 5524 : 		{
; 5525 : 			if( lpObj->Level >= gGemOfDefendDropLevel )
; 5526 : 			{
; 5527 : 				if( rand()%10000 < gGemOfDefendDropRate )
; 5528 : 				{	
; 5529 : 					type = ItemGetNumberMake(14, 31);
; 5530 : 					level = 0;
; 5531 : 					x    = lpObj->X;
; 5532 : 					y    = lpObj->Y;
; 5533 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5534 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5535 : 					return TRUE;
; 5536 : 				}
; 5537 : 			}
; 5538 : 		}
; 5539 : 	}
; 5540 : #endif
; 5541 : 	
; 5542 : #ifdef KANTURU_SPECIAL_ITEMDROP_20060808
; 5543 : if( g_bKanturuSpecialItemDropOn )
; 5544 : {
; 5545 : 	// 문스톤펜던트
; 5546 : 	if( lpObj->MapNumber == MAP_INDEX_KANTURU2 )
; 5547 : 	{
; 5548 : 		if( rand()%10000 < g_iKanturuMoonStoneDropRate )
; 5549 : 		{	
; 5550 : 			type = ItemGetNumberMake(13, 38);
; 5551 : 			level = 0;
; 5552 : 			x    = lpObj->X;
; 5553 : 			y    = lpObj->Y;
; 5554 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5555 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5556 : 			return TRUE;
; 5557 : 		}
; 5558 : 	}
; 5559 : 
; 5560 : 	// 조화의 보석
; 5561 : 	if( lpObj->MapNumber == MAP_INDEX_KANTURU1 
; 5562 : 		|| lpObj->MapNumber == MAP_INDEX_KANTURU2 
; 5563 : 		|| lpObj->MapNumber == MAP_INDEX_KANTURU_BOSS 
; 5564 : 	  )
; 5565 : 	{
; 5566 : 		if( rand()%10000 < g_iKanturuJewelOfHarmonyDropRate )
; 5567 : 		{	
; 5568 : 			type = ItemGetNumberMake(14, 41);
; 5569 : 			level = 0;
; 5570 : 			x    = lpObj->X;
; 5571 : 			y    = lpObj->Y;
; 5572 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5573 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5574 : 			return TRUE;
; 5575 : 		}
; 5576 : 	}
; 5577 : 
; 5578 : }
; 5579 : 
; 5580 : 
; 5581 : #endif // KANTURU_SPECIAL_ITEMDROP_20060808
; 5582 : 
; 5583 : #ifdef ADD_THIRD_WING_20070525	// 콘도르의불꽃 드롭 처리
; 5584 : 	if( lpObj->MapNumber == MAP_INDEX_3RD_CHANGEUP_QUEST )
; 5585 : 	{
; 5586 : 		if( rand() % 10000 < g_iCondorFlameDropRate )
; 5587 : 		{	
; 5588 : 			type = ItemGetNumberMake( 13, 52 );
; 5589 : 			level = 0;
; 5590 : 			x    = lpObj->X;
; 5591 : 			y    = lpObj->Y;
; 5592 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5593 : 			ItemSerialCreateSend( lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser );
; 5594 : 			return TRUE;
; 5595 : 		}
; 5596 : 	}
; 5597 : #endif
; 5598 : 
; 5599 : #ifdef ADD_NEW_CASTLE_HUNTZONE_REWARD_02_20050314
; 5600 : 	if( gIsDropSetItemInCastleHuntZone )
; 5601 : 	{
; 5602 : 		// 시련의 땅에서만 받을 수 있다.
; 5603 : 		if( lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE )
; 5604 : 		{	
; 5605 : 			
; 5606 : 		}
; 5607 : 		else
; 5608 : 		{
; 5609 : 			if( lpObj->Level >= gSetItemInCastleHuntZoneDropLevel )
; 5610 : 			{
; 5611 : 				if( rand()%10000 < gSetItemInCastleHuntZoneDropRate )
; 5612 : 				{
; 5613 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5614 : 
; 5615 : 					if( CHECK_LIMIT(MaxHitUser, MAX_OBJECT) )
; 5616 : 					{
; 5617 : 						LogAddTD("[Castle HuntZone] Drop SetItem [%s][%s] ", gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name);
; 5618 : #ifdef MODIFY_KUNDUN_ITEM_DROP_MAP_20060216 
; 5619 : 						MakeRewardSetItem( MaxHitUser, lpObj->X, lpObj->Y, 0, lpObj->MapNumber );
; 5620 : #else
; 5621 : 						MakeRewardSetItem( MaxHitUser, lpObj->X, lpObj->Y, 0 );
; 5622 : #endif // #ifdef MODIFY_KUNDUN_ITEM_DROP_MAP_20060216
; 5623 : 						return TRUE;
; 5624 : 					}
; 5625 : 
; 5626 : 				}
; 5627 : 			}
; 5628 : 		}
; 5629 : 	}
; 5630 : #endif
; 5631 : 
; 5632 : 
; 5633 : #ifdef HIDDEN_TREASUREBOX_EVENT_20050804	// 신비의 구슬 드롭처리
; 5634 : 	if( lpObj->MapNumber == 33 ||		// 아이다
; 5635 : 		lpObj->MapNumber == 34			// 크라이울프 1차맵
; 5636 : 		)
; 5637 : 	{
; 5638 : 		bool bDropMysteriousBead = false;
; 5639 : 		switch(lpObj->Class) 
; 5640 : 		{
; 5641 : 		case 304:	// 위치퀸
; 5642 : 		case 305:	// 블루골렘
; 5643 : 		case 306:	// 데스라이더
; 5644 : 		case 307:	// 포레스트오크
; 5645 : 		case 308:	// 데스트리
; 5646 : 		case 309:	// 헬마이네
; 5647 : 			{
; 5648 : 				if (rand()%10000 < g_iMysteriousBeadDropRate1) 
; 5649 : 				{
; 5650 : 					bDropMysteriousBead = true;	
; 5651 : 				}
; 5652 : 			}
; 5653 : 			break;
; 5654 : 		case 310:	// 척후병(근거리)
; 5655 : 		case 311:	// 척후병(중거리)
; 5656 : 		case 312:	// 척후병(원거리)
; 5657 : 		case 313:	// 웨어울프
; 5658 : 			{
; 5659 : 				if (rand()%10000 < g_iMysteriousBeadDropRate2) 
; 5660 : 				{
; 5661 : 					bDropMysteriousBead = true;	
; 5662 : 				}
; 5663 : 			}
; 5664 : 			break;
; 5665 : 		}
; 5666 : 
; 5667 : 		if (bDropMysteriousBead == true) 
; 5668 : 		{
; 5669 : 			type = ItemGetNumberMake(12, 26);
; 5670 : 			level = 0;
; 5671 : 			x    = lpObj->X;
; 5672 : 			y    = lpObj->Y;
; 5673 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5674 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5675 : 			return TRUE;
; 5676 : 		}
; 5677 : 	}
; 5678 : #endif
; 5679 : 
; 5680 : #ifdef UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123	// 여기서 마스터레벨 이벤트맵 이장아이템 재료를 드랍
; 5681 : 	// 광장 재료
; 5682 : 	if( gDevilSquareEvent )
; 5683 : 	{
; 5684 : 		if (!CHECK_DEVILSQUARE(lpObj->MapNumber)) 
; 5685 : 		{
; 5686 : 			// 7 악마의눈
; 5687 : 			if (rand()%10000 < gML_EyesOfDevilSquareDropRate) 
; 5688 : 			{
; 5689 : 				if(lpObj->Level >= 90)
; 5690 : 				{
; 5691 : 					Option1 = 0;
; 5692 : 					Option2 = 0;
; 5693 : 					Option3 = 0;
; 5694 : 					dur		= 128;
; 5695 : 					level	= 7;
; 5696 : 					x		= lpObj->X;
; 5697 : 					y		= lpObj->Y;
; 5698 : 					
; 5699 : 					type = ItemGetNumberMake(14, 17);
; 5700 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5701 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5702 : 					return TRUE;
; 5703 : 				}
; 5704 : 			}
; 5705 : 
; 5706 : 			// 7 악마의열쇠
; 5707 : 			if (rand()%10000 < gML_KeyOfDevilSquareDropRate) 
; 5708 : 			{
; 5709 : 				if(lpObj->Level >= 90)
; 5710 : 				{
; 5711 : 					Option1 = 0;
; 5712 : 					Option2 = 0;
; 5713 : 					Option3 = 0;
; 5714 : 					dur		= 128;
; 5715 : 					level	= 7;
; 5716 : 					x		= lpObj->X;
; 5717 : 					y		= lpObj->Y;
; 5718 : 					
; 5719 : 					type = ItemGetNumberMake(14, 18);
; 5720 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5721 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5722 : 					return TRUE;
; 5723 : 				}
; 5724 : 			}
; 5725 : 		}
; 5726 : 	}
; 5727 : 
; 5728 : 	// 사원 재료
; 5729 : 	if(g_bIllusionTampleEvent)
; 5730 : 	{
; 5731 : 		if (!CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) )
; 5732 : 		{
; 5733 : 			// 6 낡은 두루마리
; 5734 : 			if (rand()%10000 < gML_OldScrollDropRate) 
; 5735 : 			{
; 5736 : 				if(lpObj->Level >= 96)
; 5737 : 				{
; 5738 : 					Option1 = 0;
; 5739 : 					Option2 = 0;
; 5740 : 					Option3 = 0;
; 5741 : 					dur		= 0;
; 5742 : 					level	= 6;
; 5743 : 					x		= lpObj->X;
; 5744 : 					y		= lpObj->Y;
; 5745 : 					
; 5746 : 					type = ItemGetNumberMake(13, 49);
; 5747 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5748 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5749 : 					return TRUE;
; 5750 : 				}
; 5751 : 			}
; 5752 : 
; 5753 : 			// 6 환영교단의 서약
; 5754 : 			if (rand()%10000 < gML_CovenantOfIllusionDropRate) 
; 5755 : 			{
; 5756 : 				if(lpObj->Level >= 96)
; 5757 : 				{
; 5758 : 					Option1 = 0;
; 5759 : 					Option2 = 0;
; 5760 : 					Option3 = 0;
; 5761 : 					dur		= 0;
; 5762 : 					level	= 6;
; 5763 : 					x		= lpObj->X;
; 5764 : 					y		= lpObj->Y;
; 5765 : 					
; 5766 : 					type = ItemGetNumberMake(13, 50);
; 5767 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5768 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5769 : 					return TRUE;
; 5770 : 				}
; 5771 : 			}
; 5772 : 		}
; 5773 : 	}
; 5774 : 
; 5775 : 	// 블캐 재료
; 5776 : 	if (g_bBloodCastle) 
; 5777 : 	{
; 5778 : 		if (!CHECK_BLOODCASTLE(lpObj->MapNumber)) 
; 5779 : 		{
; 5780 : 			// 8 대천사의 서
; 5781 : 			if (rand()%10000 < gML_AngelKingsPaperDropRate) 
; 5782 : 			{
; 5783 : 				if(lpObj->Level >= 90)
; 5784 : 				{
; 5785 : 					Option1 = 0;
; 5786 : 					Option2 = 0;
; 5787 : 					Option3 = 0;
; 5788 : 					dur		= 128;
; 5789 : 					level	= 8;
; 5790 : 					x		= lpObj->X;
; 5791 : 					y		= lpObj->Y;
; 5792 : 					
; 5793 : 					type = ItemGetNumberMake(13, 16);
; 5794 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5795 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5796 : 					return TRUE;
; 5797 : 				}
; 5798 : 			}
; 5799 : 
; 5800 : 			// 8 블러드 본
; 5801 : 			if (rand()%10000 < gML_BloodBoneDropRate) 
; 5802 : 			{
; 5803 : 				if(lpObj->Level >= 90)
; 5804 : 				{
; 5805 : 					Option1 = 0;
; 5806 : 					Option2 = 0;
; 5807 : 					Option3 = 0;
; 5808 : 					dur		= 128;
; 5809 : 					level	= 8;
; 5810 : 					x		= lpObj->X;
; 5811 : 					y		= lpObj->Y;
; 5812 : 					
; 5813 : 					type = ItemGetNumberMake(13, 17);
; 5814 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5815 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5816 : 					return TRUE;
; 5817 : 				}
; 5818 : 			}
; 5819 : 		}
; 5820 : 	}
; 5821 : #endif	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 5822 : 
; 5823 : #ifdef FOR_BLOODCASTLE
; 5824 : 	if (g_bBloodCastle) 

  00cc0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  00cc7	0f 84 08 03 00
	00		 je	 $LN82@gEventMons

; 5825 : 	{
; 5826 : 		if (!CHECK_BLOODCASTLE(lpObj->MapNumber)) 

  00ccd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cd0	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00cd7	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00cda	7d 0c		 jge	 SHORT $LN101@gEventMons
  00cdc	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv648[ebp], 0
  00ce6	eb 31		 jmp	 SHORT $LN102@gEventMons
$LN101@gEventMons:
  00ce8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ceb	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00cf2	83 f8 11	 cmp	 eax, 17			; 00000011H
  00cf5	7e 0c		 jle	 SHORT $LN99@gEventMons
  00cf7	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv647[ebp], 0
  00d01	eb 0a		 jmp	 SHORT $LN100@gEventMons
$LN99@gEventMons:
  00d03	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv647[ebp], 1
$LN100@gEventMons:
  00d0d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv647[ebp]
  00d13	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv648[ebp], ecx
$LN102@gEventMons:
  00d19	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv648[ebp], 0
  00d20	0f 85 af 02 00
	00		 jne	 $LN82@gEventMons

; 5827 : 		{
; 5828 : 			Option1 = 0;

  00d26	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 5829 : 			Option2 = 0;

  00d2d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 5830 : 			Option3 = 0;

  00d34	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 5831 : 
; 5832 : 			// 1 . 스톤이 떨어질 확률
; 5833 : /*			if( g_bStoneItemDrop )
; 5834 : 			{			
; 5835 : 				if (rand()%10000 < g_iStoneDropRate) {
; 5836 : #ifdef FOR_BLOODCASTLE_TEST
; 5837 : 					dur  = 0;
; 5838 : #else
; 5839 : 					dur  = 128;
; 5840 : #endif
; 5841 : 					x    = lpObj->X;
; 5842 : 					y    = lpObj->Y;
; 5843 : 					level= 1;	
; 5844 : 					type = ItemGetNumberMake(14, 21);
; 5845 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5846 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5847 : 					return TRUE;
; 5848 : 				}
; 5849 : 			}
; 5850 : */
; 5851 : 			// 2 . 대천사의 서가 떨어질 확률
; 5852 : 			if (rand()%10000 < g_iAngelKingsPaperDropRate) 

  00d3b	e8 00 00 00 00	 call	 _rand
  00d40	99		 cdq
  00d41	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00d46	f7 f9		 idiv	 ecx
  00d48	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iAngelKingsPaperDropRate@@3HA ; g_iAngelKingsPaperDropRate
  00d4e	0f 8d 34 01 00
	00		 jge	 $LN69@gEventMons

; 5853 : 			{
; 5854 : #ifdef FOR_BLOODCASTLE_TEST
; 5855 : 				dur  = 0;
; 5856 : #else
; 5857 : 				dur  = 128;

  00d54	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43000000
  00d5c	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5858 : #endif
; 5859 : 				x    = lpObj->X;

  00d61	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d64	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00d6b	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5860 : 				y    = lpObj->Y;

  00d6e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d71	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00d78	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5861 : 
; 5862 : 				
; 5863 : 				if( lpObj->Level < 32)			// +1 ( 0~ 31)

  00d7b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d7e	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00d85	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00d88	7d 09		 jge	 SHORT $LN70@gEventMons

; 5864 : 				{
; 5865 : 					level = 1;

  00d8a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _level$[ebp], 1

; 5866 : 				}

  00d91	eb 7f		 jmp	 SHORT $LN81@gEventMons
$LN70@gEventMons:

; 5867 : 				else if( lpObj->Level < 45)		// +2 (31~ 44)

  00d93	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d96	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00d9d	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00da0	7d 09		 jge	 SHORT $LN72@gEventMons

; 5868 : 				{
; 5869 : 					level = 2;

  00da2	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _level$[ebp], 2

; 5870 : 				}

  00da9	eb 67		 jmp	 SHORT $LN81@gEventMons
$LN72@gEventMons:

; 5871 : 				else if( lpObj->Level < 57)		// +3 (45~ 56)

  00dab	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dae	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00db5	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00db8	7d 09		 jge	 SHORT $LN74@gEventMons

; 5872 : 				{
; 5873 : 					level = 3;

  00dba	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _level$[ebp], 3

; 5874 : 				}

  00dc1	eb 4f		 jmp	 SHORT $LN81@gEventMons
$LN74@gEventMons:

; 5875 : 				else if( lpObj->Level < 68)		// +4 (57~ 67)

  00dc3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dc6	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00dcd	83 f9 44	 cmp	 ecx, 68			; 00000044H
  00dd0	7d 09		 jge	 SHORT $LN76@gEventMons

; 5876 : 				{
; 5877 : 					level = 4;

  00dd2	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _level$[ebp], 4

; 5878 : 				}

  00dd9	eb 37		 jmp	 SHORT $LN81@gEventMons
$LN76@gEventMons:

; 5879 : 				else if( lpObj->Level < 76)		// +5 (68~ 75)

  00ddb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dde	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00de5	83 f9 4c	 cmp	 ecx, 76			; 0000004cH
  00de8	7d 09		 jge	 SHORT $LN78@gEventMons

; 5880 : 				{
; 5881 : 					level = 5;

  00dea	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _level$[ebp], 5

; 5882 : 				}

  00df1	eb 1f		 jmp	 SHORT $LN81@gEventMons
$LN78@gEventMons:

; 5883 : 				else if( lpObj->Level < 84)		// +6 (64~ 83)

  00df3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00df6	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00dfd	83 f9 54	 cmp	 ecx, 84			; 00000054H
  00e00	7d 09		 jge	 SHORT $LN80@gEventMons

; 5884 : 				{
; 5885 : 					level = 6;

  00e02	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _level$[ebp], 6

; 5886 : 				}

  00e09	eb 07		 jmp	 SHORT $LN81@gEventMons
$LN80@gEventMons:

; 5887 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 대천사의서 +8 드롭 확률
; 5888 : 				else if( lpObj->Level < 90 )	// +7 (75~ 89)
; 5889 : 				{
; 5890 : 					level = 7;
; 5891 : 				}
; 5892 : 				else							// +8 (90~ )
; 5893 : 				{
; 5894 : 					level = 8;
; 5895 : 				}
; 5896 : #else
; 5897 : 				else							// +7 (75~ )
; 5898 : 				{
; 5899 : 					level = 7;

  00e0b	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR _level$[ebp], 7
$LN81@gEventMons:

; 5900 : 				}
; 5901 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 5902 : 
; 5903 : #ifdef UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123	// 마스터레벨 이벤트맵 재료면 처리안함
; 5904 : 				if(level != 8)
; 5905 : 				{
; 5906 : 					type = ItemGetNumberMake(13, 16);
; 5907 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5908 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5909 : 					return TRUE;
; 5910 : 				}
; 5911 : #else	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 5912 : 				type = ItemGetNumberMake(13, 16);

  00e12	6a 10		 push	 16			; 00000010H
  00e14	6a 0d		 push	 13			; 0000000dH
  00e16	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00e1b	83 c4 08	 add	 esp, 8
  00e1e	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5913 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00e21	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e24	50		 push	 eax
  00e25	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00e2a	83 c4 04	 add	 esp, 4
  00e2d	89 45 8c	 mov	 DWORD PTR _MaxHitUser$4[ebp], eax

; 5914 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00e30	6a 00		 push	 0
  00e32	6a 00		 push	 0
  00e34	6a 00		 push	 0
  00e36	8b 45 8c	 mov	 eax, DWORD PTR _MaxHitUser$4[ebp]
  00e39	50		 push	 eax
  00e3a	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00e3e	51		 push	 ecx
  00e3f	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00e43	52		 push	 edx
  00e44	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00e48	50		 push	 eax
  00e49	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00e4e	0f b6 d1	 movzx	 edx, cl
  00e51	52		 push	 edx
  00e52	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  00e56	50		 push	 eax
  00e57	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  00e5a	51		 push	 ecx
  00e5b	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  00e5f	52		 push	 edx
  00e60	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  00e64	50		 push	 eax
  00e65	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e68	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00e6f	52		 push	 edx
  00e70	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e73	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e75	51		 push	 ecx
  00e76	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00e7b	83 c4 38	 add	 esp, 56			; 00000038H

; 5915 : 				return TRUE;

  00e7e	b8 01 00 00 00	 mov	 eax, 1
  00e83	e9 3b 02 00 00	 jmp	 $LN1@gEventMons
$LN69@gEventMons:

; 5916 : #endif	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 5917 : 			}
; 5918 : 					
; 5919 : 			// 3 . 블러드본이 떨어질 확률
; 5920 : 			if (rand()%10000 < g_iBloodBoneDropRate) 

  00e88	e8 00 00 00 00	 call	 _rand
  00e8d	99		 cdq
  00e8e	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00e93	f7 f9		 idiv	 ecx
  00e95	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iBloodBoneDropRate@@3HA ; g_iBloodBoneDropRate
  00e9b	0f 8d 34 01 00
	00		 jge	 $LN82@gEventMons

; 5921 : 			{
; 5922 : #ifdef FOR_BLOODCASTLE_TEST
; 5923 : 				dur  = 0;
; 5924 : #else
; 5925 : 				dur  = 128;

  00ea1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43000000
  00ea9	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 5926 : #endif
; 5927 : 				x    = lpObj->X;

  00eae	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00eb1	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00eb8	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 5928 : 				y    = lpObj->Y;

  00ebb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ebe	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00ec5	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 5929 : 
; 5930 : 				if( lpObj->Level < 32)			// +1 ( 0~ 31)

  00ec8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ecb	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00ed2	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00ed5	7d 09		 jge	 SHORT $LN83@gEventMons

; 5931 : 				{
; 5932 : 					level = 1;

  00ed7	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _level$[ebp], 1

; 5933 : 				}

  00ede	eb 7f		 jmp	 SHORT $LN94@gEventMons
$LN83@gEventMons:

; 5934 : 				else if( lpObj->Level < 45)		// +2 (31~ 44)

  00ee0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ee3	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00eea	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00eed	7d 09		 jge	 SHORT $LN85@gEventMons

; 5935 : 				{
; 5936 : 					level = 2;

  00eef	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _level$[ebp], 2

; 5937 : 				}

  00ef6	eb 67		 jmp	 SHORT $LN94@gEventMons
$LN85@gEventMons:

; 5938 : 				else if( lpObj->Level < 57)		// +3 (45~ 56)

  00ef8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00efb	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00f02	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00f05	7d 09		 jge	 SHORT $LN87@gEventMons

; 5939 : 				{
; 5940 : 					level = 3;

  00f07	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _level$[ebp], 3

; 5941 : 				}

  00f0e	eb 4f		 jmp	 SHORT $LN94@gEventMons
$LN87@gEventMons:

; 5942 : 				else if( lpObj->Level < 68)		// +4 (57~ 67)

  00f10	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f13	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00f1a	83 f9 44	 cmp	 ecx, 68			; 00000044H
  00f1d	7d 09		 jge	 SHORT $LN89@gEventMons

; 5943 : 				{
; 5944 : 					level = 4;

  00f1f	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _level$[ebp], 4

; 5945 : 				}

  00f26	eb 37		 jmp	 SHORT $LN94@gEventMons
$LN89@gEventMons:

; 5946 : 				else if( lpObj->Level < 76)		// +5 (68~ 75)

  00f28	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f2b	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00f32	83 f9 4c	 cmp	 ecx, 76			; 0000004cH
  00f35	7d 09		 jge	 SHORT $LN91@gEventMons

; 5947 : 				{
; 5948 : 					level = 5;

  00f37	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR _level$[ebp], 5

; 5949 : 				}

  00f3e	eb 1f		 jmp	 SHORT $LN94@gEventMons
$LN91@gEventMons:

; 5950 : 				else if( lpObj->Level < 84)		// +6 (64~ 83)

  00f40	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f43	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00f4a	83 f9 54	 cmp	 ecx, 84			; 00000054H
  00f4d	7d 09		 jge	 SHORT $LN93@gEventMons

; 5951 : 				{
; 5952 : 					level = 6;

  00f4f	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _level$[ebp], 6

; 5953 : 				}

  00f56	eb 07		 jmp	 SHORT $LN94@gEventMons
$LN93@gEventMons:

; 5954 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 블러드본 +8 드롭 확률
; 5955 : 				else if( lpObj->Level < 90 )	// +7 (75~ 89)
; 5956 : 				{
; 5957 : 					level = 7;
; 5958 : 				}
; 5959 : 				else							// +8 (90~ )
; 5960 : 				{
; 5961 : 					level = 8;
; 5962 : 				}
; 5963 : #else
; 5964 : 				else							// +7 (75~ )
; 5965 : 				{
; 5966 : 					level = 7;

  00f58	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR _level$[ebp], 7
$LN94@gEventMons:

; 5967 : 				}
; 5968 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 5969 : 				
; 5970 : #ifdef UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123	// 마스터레벨 이벤트맵 재료면 처리안함
; 5971 : 				if(level != 8)
; 5972 : 				{
; 5973 : 					type = ItemGetNumberMake(13, 17);
; 5974 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 5975 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 5976 : 					return TRUE;
; 5977 : 				}
; 5978 : #else	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 5979 : 				type = ItemGetNumberMake(13, 17);

  00f5f	6a 11		 push	 17			; 00000011H
  00f61	6a 0d		 push	 13			; 0000000dH
  00f63	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00f68	83 c4 08	 add	 esp, 8
  00f6b	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 5980 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00f6e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f71	50		 push	 eax
  00f72	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00f77	83 c4 04	 add	 esp, 4
  00f7a	89 45 88	 mov	 DWORD PTR _MaxHitUser$3[ebp], eax

; 5981 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00f7d	6a 00		 push	 0
  00f7f	6a 00		 push	 0
  00f81	6a 00		 push	 0
  00f83	8b 45 88	 mov	 eax, DWORD PTR _MaxHitUser$3[ebp]
  00f86	50		 push	 eax
  00f87	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00f8b	51		 push	 ecx
  00f8c	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00f90	52		 push	 edx
  00f91	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00f95	50		 push	 eax
  00f96	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00f9b	0f b6 d1	 movzx	 edx, cl
  00f9e	52		 push	 edx
  00f9f	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  00fa3	50		 push	 eax
  00fa4	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  00fa7	51		 push	 ecx
  00fa8	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  00fac	52		 push	 edx
  00fad	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  00fb1	50		 push	 eax
  00fb2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00fb5	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00fbc	52		 push	 edx
  00fbd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fc0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fc2	51		 push	 ecx
  00fc3	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00fc8	83 c4 38	 add	 esp, 56			; 00000038H

; 5982 : 				return TRUE;

  00fcb	b8 01 00 00 00	 mov	 eax, 1
  00fd0	e9 ee 00 00 00	 jmp	 $LN1@gEventMons
$LN82@gEventMons:

; 5983 : #endif	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 5984 : 			}
; 5985 : 		}
; 5986 : 	}
; 5987 : #endif
; 5988 : 	
; 5989 : 
; 5990 : #ifdef DARK_LORD_HEART_EVENT_20040810			// 다크로드의 마음 이벤트 아이템 드롭
; 5991 : 	if (rand()%10000 < g_iDarkLordHeartDropRate) 

  00fd5	e8 00 00 00 00	 call	 _rand
  00fda	99		 cdq
  00fdb	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00fe0	f7 f9		 idiv	 ecx
  00fe2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iDarkLordHeartDropRate@@3HA ; g_iDarkLordHeartDropRate
  00fe8	0f 8d d3 00 00
	00		 jge	 $LN96@gEventMons

; 5992 : 	{
; 5993 : 		int iDropRate = 0;

  00fee	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _iDropRate$2[ebp], 0

; 5994 : 
; 5995 : 		// 세 맵에서만 떨어진다.
; 5996 : 		if (lpTargetObj->MapNumber == MAP_INDEX_RORENCIA ||
; 5997 : 			lpTargetObj->MapNumber == MAP_INDEX_NORIA ||

  00ff5	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00ff8	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00fff	85 c9		 test	 ecx, ecx
  01001	74 22		 je	 SHORT $LN97@gEventMons
  01003	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01006	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0100d	83 f9 03	 cmp	 ecx, 3
  01010	74 13		 je	 SHORT $LN97@gEventMons
  01012	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01015	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0101c	83 f9 02	 cmp	 ecx, 2
  0101f	0f 85 9c 00 00
	00		 jne	 $LN96@gEventMons
$LN97@gEventMons:

; 5998 : 			lpTargetObj->MapNumber == MAP_INDEX_DEVIAS
; 5999 : 			)
; 6000 : 		{
; 6001 : 			type	= ItemGetNumberMake(14, 11);

  01025	6a 0b		 push	 11			; 0000000bH
  01027	6a 0e		 push	 14			; 0000000eH
  01029	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0102e	83 c4 08	 add	 esp, 8
  01031	89 45 fc	 mov	 DWORD PTR _type$[ebp], eax

; 6002 : 			level	= 13;

  01034	c7 45 f8 0d 00
	00 00		 mov	 DWORD PTR _level$[ebp], 13 ; 0000000dH

; 6003 : 			x		= lpObj->X;

  0103b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0103e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  01045	89 4d f4	 mov	 DWORD PTR _x$[ebp], ecx

; 6004 : 			y		= lpObj->Y;

  01048	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0104b	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  01052	89 4d f0	 mov	 DWORD PTR _y$[ebp], ecx

; 6005 : 			dur		= 0;

  01055	0f 57 c0	 xorps	 xmm0, xmm0
  01058	f3 0f 11 45 ec	 movss	 DWORD PTR _dur$[ebp], xmm0

; 6006 : 			
; 6007 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0105d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01060	50		 push	 eax
  01061	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  01066	83 c4 04	 add	 esp, 4
  01069	89 45 80	 mov	 DWORD PTR _MaxHitUser$1[ebp], eax

; 6008 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  0106c	6a 00		 push	 0
  0106e	6a 00		 push	 0
  01070	6a 00		 push	 0
  01072	8b 45 80	 mov	 eax, DWORD PTR _MaxHitUser$1[ebp]
  01075	50		 push	 eax
  01076	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  0107a	51		 push	 ecx
  0107b	0f b6 55 e4	 movzx	 edx, BYTE PTR _Option2$[ebp]
  0107f	52		 push	 edx
  01080	0f b6 45 e8	 movzx	 eax, BYTE PTR _Option1$[ebp]
  01084	50		 push	 eax
  01085	f3 0f 2c 4d ec	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  0108a	0f b6 d1	 movzx	 edx, cl
  0108d	52		 push	 edx
  0108e	0f b6 45 f8	 movzx	 eax, BYTE PTR _level$[ebp]
  01092	50		 push	 eax
  01093	8b 4d fc	 mov	 ecx, DWORD PTR _type$[ebp]
  01096	51		 push	 ecx
  01097	0f b6 55 f0	 movzx	 edx, BYTE PTR _y$[ebp]
  0109b	52		 push	 edx
  0109c	0f b6 45 f4	 movzx	 eax, BYTE PTR _x$[ebp]
  010a0	50		 push	 eax
  010a1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  010a4	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  010ab	52		 push	 edx
  010ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010af	8b 08		 mov	 ecx, DWORD PTR [eax]
  010b1	51		 push	 ecx
  010b2	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  010b7	83 c4 38	 add	 esp, 56			; 00000038H

; 6009 : 			return TRUE;

  010ba	b8 01 00 00 00	 mov	 eax, 1
  010bf	eb 02		 jmp	 SHORT $LN1@gEventMons
$LN96@gEventMons:

; 6010 : 		}
; 6011 : 	}	
; 6012 : #endif
; 6013 : 
; 6014 : #ifdef MU_CHN_THANKS_COOKIE_EVENT_20040908
; 6015 : 	if( ChnThanksCookieEvent->DropEventItem(lpObj->m_Index) )
; 6016 : 	{
; 6017 : 		return TRUE;
; 6018 : 	}
; 6019 : #endif
; 6020 : 	
; 6021 : #ifdef EVENT_SONGKRAN_2005_20050316
; 6022 : 	int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6023 : 	if( MaxHitUser != -1 )
; 6024 : 	{
; 6025 : 		int partycount = gParty.GetPartyCount(gObj[MaxHitUser].PartyNumber);
; 6026 : 
; 6027 : 		if( partycount > 0 )
; 6028 : 		{	// 파티를 맺었을때만 
; 6029 : 			LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);
; 6030 : 
; 6031 : 			if( lpattr )
; 6032 : 			{
; 6033 : 				if( lpattr->m_Level >= 17 )
; 6034 : 				{
; 6035 : 					if( (rand()%10000) < gHeartOfLoveDropRate )
; 6036 : 					{
; 6037 : 						// 자이언트 이상일때만
; 6038 : 						dur  = 255;
; 6039 : 						x    = lpObj->X;
; 6040 : 						y    = lpObj->Y;
; 6041 : 						level= 2;	// 폭죽
; 6042 : 						type = ItemGetNumberMake(14, 11);			
; 6043 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6044 : 						return TRUE;
; 6045 : 					}
; 6046 : 				}
; 6047 : 			}
; 6048 : 		}
; 6049 : 	}
; 6050 : #endif // EVENT_SONGKRAN_2005_20050316
; 6051 : 	
; 6052 : #ifdef CHRISTMAS_RIBBONBOX_EVENT_20051212
; 6053 : 	if( g_bRibbonBoxEvent )	// 크리스마스 리본상자 이벤트가 진행중일 때
; 6054 : 	{
; 6055 : 		// 몬스터 레벨별로 드랍된다.		
; 6056 : 		if( lpObj->Level >= g_iRedRibbonBoxDropLevelMin && lpObj->Level <= g_iRedRibbonBoxDropLevelMax )
; 6057 : 		{
; 6058 : 			// 빨간리본상자
; 6059 : 			if( ( rand() % 10000 ) < g_iRedRibbonBoxDropRate )
; 6060 : 			{
; 6061 : 				type	= ItemGetNumberMake(12, 32);
; 6062 : 				level	= 0;
; 6063 : #ifdef MODIFY_BOX_DROP_POSITION_20070308	// 빨간리본상자
; 6064 : 				x		= lpObj->X;
; 6065 : 				y		= lpObj->Y;
; 6066 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6067 : 				ItemSerialCreateSend( lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6068 : 				return TRUE;
; 6069 : #else
; 6070 : 				x		= lpTargetObj->X;
; 6071 : 				y		= lpTargetObj->Y;
; 6072 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6073 : 				ItemSerialCreateSend( lpTargetObj->m_Index, lpTargetObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6074 : 				return TRUE;
; 6075 : #endif
; 6076 : 			}
; 6077 : 		}
; 6078 : 		else if( lpObj->Level >= g_iGreenRibbonBoxDropLevelMin && lpObj->Level <= g_iGreenRibbonBoxDropLevelMax )
; 6079 : 		{
; 6080 : 			// 초록리본상자
; 6081 : 			if( ( rand() % 10000 ) < g_iGreenRibbonBoxDropRate )
; 6082 : 			{
; 6083 : 				type	= ItemGetNumberMake(12, 33);
; 6084 : 				level	= 0;
; 6085 : #ifdef MODIFY_BOX_DROP_POSITION_20070308	// 초록리본상자
; 6086 : 				x		= lpObj->X;
; 6087 : 				y		= lpObj->Y;
; 6088 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6089 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6090 : 				return TRUE;
; 6091 : #else
; 6092 : 				x		= lpTargetObj->X;
; 6093 : 				y		= lpTargetObj->Y;
; 6094 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6095 : 				ItemSerialCreateSend(lpTargetObj->m_Index, lpTargetObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6096 : 				return TRUE;
; 6097 : #endif
; 6098 : 			}
; 6099 : 		}
; 6100 : 		else if( lpObj->Level >= g_iBlueRibbonBoxDropLevelMin && lpObj->Level <= g_iBlueRibbonBoxDropLevelMax ) // 70 ~ 97
; 6101 : 		{
; 6102 : 			// 파란리본상자
; 6103 : 			if( ( rand() % 10000 ) < g_iBlueRibbonBoxDropRate )
; 6104 : 			{
; 6105 : 				type	= ItemGetNumberMake(12, 34);
; 6106 : 				level	= 0;
; 6107 : #ifdef MODIFY_BOX_DROP_POSITION_20070308	// 파란리본상자
; 6108 : 				x		= lpObj->X;
; 6109 : 				y		= lpObj->Y;							
; 6110 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6111 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6112 : 				return TRUE;
; 6113 : #else
; 6114 : 				x		= lpTargetObj->X;
; 6115 : 				y		= lpTargetObj->Y;							
; 6116 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6117 : 				ItemSerialCreateSend(lpTargetObj->m_Index, lpTargetObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6118 : 				return TRUE;
; 6119 : #endif
; 6120 : 			}
; 6121 : 		}				
; 6122 : 	}
; 6123 : #endif // #ifdef CHRISTMAS_RIBBONBOX_EVENT_20051212
; 6124 : 	
; 6125 : #ifdef VALENTINES_DAY_BOX_EVENT_20060124
; 6126 : 	if( g_bChocolateBoxEvent )	// 발렌타인데이 초콜릿상자 이벤트가 진행중일 때
; 6127 : 	{
; 6128 : 		// 몬스터 레벨별로 드랍된다.		
; 6129 : 		if( lpObj->Level >= g_iPinkChocolateBoxDropLevelMin && lpObj->Level <= g_iPinkChocolateBoxDropLevelMax )
; 6130 : 		{
; 6131 : 			// 분홍초콜릿상자 
; 6132 : 			if( ( rand() % 10000 ) < g_iPinkChocolateBoxDropRate )
; 6133 : 			{
; 6134 : 				type	= ItemGetNumberMake(14, 32);
; 6135 : 				level	= 0;
; 6136 : #ifdef MODIFY_VALENTINES_DAY_BOX_DROP_20070202
; 6137 : 				x		= lpObj->X;
; 6138 : 				y		= lpObj->Y;
; 6139 : 
; 6140 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6141 : 				ItemSerialCreateSend( lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6142 : 				return TRUE;
; 6143 : #else
; 6144 : 				x		= lpTargetObj->X;
; 6145 : 				y		= lpTargetObj->Y;
; 6146 : 
; 6147 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6148 : 				ItemSerialCreateSend( lpTargetObj->m_Index, lpTargetObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6149 : 				return TRUE;
; 6150 : #endif
; 6151 : 			}
; 6152 : 		}
; 6153 : 		else if( lpObj->Level >= g_iRedChocolateBoxDropLevelMin && lpObj->Level <= g_iRedChocolateBoxDropLevelMax )
; 6154 : 		{
; 6155 : 			// 빨간초콜릿상자
; 6156 : 			if( ( rand() % 10000 ) < g_iRedChocolateBoxDropRate )
; 6157 : 			{
; 6158 : 				type	= ItemGetNumberMake(14, 33);
; 6159 : 				level	= 0;
; 6160 : #ifdef MODIFY_VALENTINES_DAY_BOX_DROP_20070202
; 6161 : 				x		= lpObj->X;
; 6162 : 				y		= lpObj->Y;
; 6163 : 
; 6164 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6165 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6166 : 				return TRUE;
; 6167 : #else
; 6168 : 				x		= lpTargetObj->X;
; 6169 : 				y		= lpTargetObj->Y;
; 6170 : 
; 6171 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6172 : 				ItemSerialCreateSend(lpTargetObj->m_Index, lpTargetObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6173 : 				return TRUE;
; 6174 : #endif
; 6175 : 			}
; 6176 : 		}
; 6177 : 		else if( lpObj->Level >= g_iBlueChocolateBoxDropLevelMin && lpObj->Level <= g_iBlueChocolateBoxDropLevelMax ) // 70 ~ 97
; 6178 : 		{
; 6179 : 			// 파란초콜릿상자
; 6180 : 			if( ( rand() % 10000 ) < g_iBlueChocolateBoxDropRate )
; 6181 : 			{
; 6182 : 				type	= ItemGetNumberMake(14, 34);
; 6183 : 				level	= 0;
; 6184 : #ifdef MODIFY_VALENTINES_DAY_BOX_DROP_20070202
; 6185 : 				x		= lpObj->X;
; 6186 : 				y		= lpObj->Y;
; 6187 : 
; 6188 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6189 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6190 : 				return TRUE;
; 6191 : #else
; 6192 : 				x		= lpTargetObj->X;
; 6193 : 				y		= lpTargetObj->Y;
; 6194 : 								
; 6195 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6196 : 				ItemSerialCreateSend(lpTargetObj->m_Index, lpTargetObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6197 : 				return TRUE;
; 6198 : #endif	
; 6199 : 			}
; 6200 : 		}				
; 6201 : 	}
; 6202 : #endif // #ifdef VALENTINES_DAY_BOX_EVENT_20060124
; 6203 : 
; 6204 : #ifdef WHITEDAY_CANDY_BOX_EVENT_20060222
; 6205 : 	if( g_bCandyBoxEvent )	// 화이트데이 사탕상자 이벤트가 진행중일 때
; 6206 : 	{
; 6207 : 		// 몬스터 레벨별로 드랍된다.		
; 6208 : 		if( lpObj->Level >= g_iLightPurpleCandyBoxDropLevelMin && lpObj->Level <= g_iLightPurpleCandyBoxDropLevelMax )
; 6209 : 		{
; 6210 : 			// 연보라사탕상자 
; 6211 : 			if( ( rand() % 10000 ) < g_iLightPurpleCandyBoxDropRate )
; 6212 : 			{
; 6213 : 				type	= ItemGetNumberMake(14, 32);	
; 6214 : 				level	= 1;
; 6215 : #ifdef MODIFY_BOX_DROP_POSITION_20070308	// 연보라사탕상자
; 6216 : 				x		= lpObj->X;
; 6217 : 				y		= lpObj->Y;
; 6218 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6219 : 				ItemSerialCreateSend( lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6220 : 				return TRUE;
; 6221 : #else
; 6222 : 				x		= lpTargetObj->X;
; 6223 : 				y		= lpTargetObj->Y;
; 6224 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6225 : 				ItemSerialCreateSend( lpTargetObj->m_Index, lpTargetObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6226 : 				return TRUE;
; 6227 : #endif
; 6228 : 			}
; 6229 : 		}
; 6230 : 		else if( lpObj->Level >= g_iVermilionCandyBoxDropLevelMin && lpObj->Level <= g_iVermilionCandyBoxDropLevelMax )
; 6231 : 		{
; 6232 : 			// 주홍초콜릿상자
; 6233 : 			if( ( rand() % 10000 ) < g_iVermilionCandyBoxDropRate )
; 6234 : 			{
; 6235 : 				type	= ItemGetNumberMake(14, 33);
; 6236 : 				level	= 1;
; 6237 : #ifdef MODIFY_BOX_DROP_POSITION_20070308	// 주홍초콜릿상자
; 6238 : 				x		= lpObj->X;
; 6239 : 				y		= lpObj->Y;
; 6240 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6241 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6242 : 				return TRUE;
; 6243 : #else
; 6244 : 				x		= lpTargetObj->X;
; 6245 : 				y		= lpTargetObj->Y;
; 6246 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6247 : 				ItemSerialCreateSend(lpTargetObj->m_Index, lpTargetObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6248 : 				return TRUE;
; 6249 : #endif
; 6250 : 			}
; 6251 : 		}
; 6252 : 		else if( lpObj->Level >= g_iDeepBlueCandyBoxDropLevelMin && lpObj->Level <= g_iDeepBlueCandyBoxDropLevelMax ) // 70 ~ 97
; 6253 : 		{
; 6254 : 			// 감청초콜릿상자
; 6255 : 			if( ( rand() % 10000 ) < g_iDeepBlueCandyBoxDropRate )
; 6256 : 			{
; 6257 : 				type	= ItemGetNumberMake(14, 34);
; 6258 : 				level	= 1;
; 6259 : #ifdef MODIFY_BOX_DROP_POSITION_20070308	// 감청초콜릿상자
; 6260 : 				x		= lpObj->X;
; 6261 : 				y		= lpObj->Y;							
; 6262 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6263 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6264 : 				return TRUE;
; 6265 : #else
; 6266 : 				x		= lpTargetObj->X;
; 6267 : 				y		= lpTargetObj->Y;							
; 6268 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6269 : 				ItemSerialCreateSend(lpTargetObj->m_Index, lpTargetObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);				
; 6270 : 				return TRUE;
; 6271 : #endif
; 6272 : 			}
; 6273 : 		}				
; 6274 : 	}
; 6275 : #endif // #ifdef WHITEDAY_CANDY_BOX_EVENT_20060222
; 6276 : 	
; 6277 : #ifdef HALLOWINDAY_JACK_O_LANTERN_EVENT_20061017
; 6278 : 	if( g_bHallowinDayEventOn )
; 6279 : 	{
; 6280 : 		bool bIsBossMonster = false;
; 6281 : 
; 6282 : 		// 보스는 드롭하지 않음
; 6283 : 		if( lpObj->m_Index == 349 ||		// 발가스
; 6284 : 			lpObj->m_Index == 364 ||		// 마야
; 6285 : 			lpObj->m_Index == 361 ||		// 나이트메어
; 6286 : 			lpObj->m_Index == 362 ||		// 마야의 손
; 6287 : 			lpObj->m_Index == 363			// 마야의 손
; 6288 : 			)
; 6289 : 		{
; 6290 : 			bIsBossMonster = true;
; 6291 : 		}
; 6292 : 
; 6293 : #ifdef UPDATE_PUMPKIN_OF_LUCK_DROP_LEVEL_20071026	// 호박 드랍 레벨 설정_item(kor).txt의 레벨 값을 얻어와서 레벨 설정
; 6294 : 		if( bIsBossMonster == false && ( rand() % 10000 ) < g_iHallowinDayEventItemDropRate 
; 6295 : 			&& zzzItemLevel(14, 45, lpObj->Level+1))
; 6296 : #else
; 6297 : 		if( bIsBossMonster == false && ( rand() % 10000 ) < g_iHallowinDayEventItemDropRate )
; 6298 : #endif	// UPDATE_PUMPKIN_OF_LUCK_DROP_LEVEL_20071026
; 6299 : 		{
; 6300 : 			type	= ItemGetNumberMake( 14, 45 );
; 6301 : 			level	= 0;
; 6302 : 			x		= lpObj->X;
; 6303 : 			y		= lpObj->Y;
; 6304 : 			int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );
; 6305 : 			ItemSerialCreateSend( lpTargetObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, iMaxHitUser );
; 6306 : 			return TRUE;
; 6307 : 		}
; 6308 : 	}
; 6309 : #endif // HALLOWINDAY_JACK_O_LANTERN_EVENT_20061017
; 6310 : 	
; 6311 : 	
; 6312 : #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 6313 : 	if( g_bSantaPolymorphRingDropOn )
; 6314 : 	{
; 6315 : 		bool bIsBossMonster = false;
; 6316 : 
; 6317 : 		// 보스는 드롭하지 않음
; 6318 : 		if( lpObj->m_Index == 349 ||		// 발가스
; 6319 : 			lpObj->m_Index == 364 ||		// 마야
; 6320 : 			lpObj->m_Index == 361 ||		// 나이트메어
; 6321 : 			lpObj->m_Index == 362 ||		// 마야의 손
; 6322 : 			lpObj->m_Index == 363			// 마야의 손
; 6323 : 			)
; 6324 : 		{
; 6325 : 			bIsBossMonster = true;
; 6326 : 		}
; 6327 : 
; 6328 : 		if( bIsBossMonster == false &&
; 6329 : 			( ( rand() % 10000 ) < g_iSantaPolymorphRingDropRate )
; 6330 : 		  )
; 6331 : 		{
; 6332 : 			type	= ItemGetNumberMake( 13, 41 );
; 6333 : 			level	= 0;
; 6334 : 			dur		= 100;
; 6335 : 			x		= lpObj->X;
; 6336 : 			y		= lpObj->Y;
; 6337 : 			int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );
; 6338 : 			ItemSerialCreateSend( lpTargetObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, iMaxHitUser );
; 6339 : 		}
; 6340 : 	}
; 6341 : #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 6342 : 	
; 6343 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328
; 6344 : 	if(g_bIllusionTampleEvent)
; 6345 : 	{
; 6346 : 		if (!CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) )
; 6347 : 		{
; 6348 : 			Option1 = 0;
; 6349 : 			Option2 = 0;
; 6350 : 			Option3 = 0;
; 6351 : 
; 6352 : 			// 낡은 두루마리 나올 확률
; 6353 : 			if (rand()%10000 < g_iOldScrollDropRate) 
; 6354 : 			{
; 6355 : #ifdef MODIFY_ILLUSIONTEMPLE_ITEMVALUE_BUFGIX_20070904
; 6356 : 				dur	 = 0;
; 6357 : #else
; 6358 : 				dur  = 128;
; 6359 : #endif
; 6360 : 				x    = lpObj->X;
; 6361 : 				y    = lpObj->Y;
; 6362 : 
; 6363 : 				if(lpObj->Level >= 66)
; 6364 : 				{
; 6365 : 					if( lpObj->Level < 72)			// +1 ( 66 ~ 71)
; 6366 : 					{
; 6367 : 						level = 1;
; 6368 : 					}
; 6369 : 					else if( lpObj->Level < 78)		// +2 (71 ~ 77)
; 6370 : 					{
; 6371 : 						level = 2;
; 6372 : 					}
; 6373 : 					else if( lpObj->Level < 84)		// +3 (78~ 83)
; 6374 : 					{
; 6375 : 						level = 3;
; 6376 : 					}
; 6377 : 					else if( lpObj->Level < 90)		// +4 (84 ~ 89)
; 6378 : 					{
; 6379 : 						level = 4;
; 6380 : 					}
; 6381 : 					else if( lpObj->Level < 96)		// +5 (90~ 96)
; 6382 : 					{
; 6383 : 						level = 5;
; 6384 : 					}
; 6385 : 					else							// +6 (96~)
; 6386 : 					{
; 6387 : 						if(g_bUseMaxLevelIllusionTemple)
; 6388 : 						{
; 6389 : 							// 400 레벨 전용 환영 사원 사용
; 6390 : 							level = 6;
; 6391 : 						}
; 6392 : 						else
; 6393 : 						{
; 6394 : 							level = 5;
; 6395 : 						}
; 6396 : 					}
; 6397 : 
; 6398 : 
; 6399 : #ifdef UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123	// 마스터레벨 이벤트맵 재료면 처리안함
; 6400 : 					if( level != 6 )
; 6401 : 					{
; 6402 : 						type = ItemGetNumberMake(13, 49);
; 6403 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6404 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6405 : 						return TRUE;
; 6406 : 					}
; 6407 : #else	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 6408 : 					type = ItemGetNumberMake(13, 49);
; 6409 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6410 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6411 : 					return TRUE;
; 6412 : #endif	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 6413 : 				}
; 6414 : 			}
; 6415 : 
; 6416 : 			// 환영교단의 서약 나올 확률
; 6417 : 			if (rand()%10000 < g_iCovenantOfIllusionDropRate) 
; 6418 : 			{
; 6419 : #ifdef MODIFY_ILLUSIONTEMPLE_ITEMVALUE_BUFGIX_20070904
; 6420 : 				dur	 = 0;
; 6421 : #else
; 6422 : 				dur  = 128;
; 6423 : #endif
; 6424 : 				x    = lpObj->X;
; 6425 : 				y    = lpObj->Y;
; 6426 : 
; 6427 : 				if( lpObj->Level >= 70 )
; 6428 : 				{
; 6429 : 					if( lpObj->Level < 76)		// +1 (70 ~ 75)
; 6430 : 					{
; 6431 : 						level = 1;
; 6432 : 					}
; 6433 : 					else if( lpObj->Level < 82)		// +2 (76 ~ 81)
; 6434 : 					{
; 6435 : 						level = 2;
; 6436 : 					}
; 6437 : 					else if( lpObj->Level < 88)		// +3 (82 ~ 87)
; 6438 : 					{
; 6439 : 						level = 3;
; 6440 : 					}
; 6441 : 					else if( lpObj->Level < 94)		// +4 (88 ~ 93)
; 6442 : 					{
; 6443 : 						level = 4;
; 6444 : 					}
; 6445 : 					else if( lpObj->Level < 100)	// +5 (94 ~ 99)
; 6446 : 					{
; 6447 : 						level = 5;
; 6448 : 					}
; 6449 : 					else							// +6 (100 ~)
; 6450 : 					{
; 6451 : 						if(g_bUseMaxLevelIllusionTemple)
; 6452 : 						{
; 6453 : 							// 400 레벨 전용 환영 사원 사용
; 6454 : 							level = 6;
; 6455 : 						}
; 6456 : 						else
; 6457 : 						{
; 6458 : 							level = 5;
; 6459 : 						}
; 6460 : 					}
; 6461 : 				
; 6462 : #ifdef UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123	// 마스터레벨 이벤트맵 재료면 처리안함
; 6463 : 					if( level != 6 )
; 6464 : 					{
; 6465 : 						type = ItemGetNumberMake(13, 50);
; 6466 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6467 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6468 : 						return TRUE;
; 6469 : 					}
; 6470 : #else	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 6471 : 					type = ItemGetNumberMake(13, 50);
; 6472 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6473 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6474 : 					return TRUE;
; 6475 : #endif	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 6476 : 				}
; 6477 : 			}
; 6478 : 		}
; 6479 : 	}
; 6480 : #endif	// ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328
; 6481 : 
; 6482 : #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 6483 : 	if (g_bCherryBlossomEventOn) 
; 6484 : 	{
; 6485 : 		bool bIsBossMonster = false;
; 6486 : 		
; 6487 : 		// 보스는 드롭하지 않음
; 6488 : 		if( lpObj->m_Index == 349 ||		// 발가스
; 6489 : 			lpObj->m_Index == 364 ||		// 마야
; 6490 : 			lpObj->m_Index == 361 ||		// 나이트메어
; 6491 : 			lpObj->m_Index == 362 ||		// 마야의 손
; 6492 : 			lpObj->m_Index == 363			// 마야의 손
; 6493 : 			)
; 6494 : 		{
; 6495 : 			bIsBossMonster = true;
; 6496 : 		}
; 6497 : 		
; 6498 : #ifdef MODIFY_CHERRYBLOSSOM_DROP_VULCANUS_20090324
; 6499 : 		if( lpObj->MapNumber != MAP_INDEX_VULCANUS )	// 불카노스가 아니면 드랍하지 않는다.
; 6500 : 		{
; 6501 : 			return FALSE;
; 6502 : 		}
; 6503 : #endif // MODIFY_CHERRYBLOSSOM_DROP_VULCANUS_20090324
; 6504 : 		
; 6505 : 		//#ifdef UPDATE_PUMPKIN_OF_LUCK_DROP_LEVEL_20071026	// 벚꽃 드랍 레벨 설정_item(kor).txt의 레벨 값을 얻어와서 레벨 설정
; 6506 : 		//		if( bIsBossMonster == false && ( rand() % 10000 ) < g_bCherryBlossomEventItemDropRate 
; 6507 : 		//			&& zzzItemLevel(14, 84, lpObj->Level+1))
; 6508 : 		//#else
; 6509 : 		if( bIsBossMonster == false && ( rand() % 10000 ) < g_bCherryBlossomEventItemDropRate )
; 6510 : 			//#endif	// UPDATE_PUMPKIN_OF_LUCK_DROP_LEVEL_20071026
; 6511 : 		{
; 6512 : 			type	= ItemGetNumberMake( 14, 84 );	//벚꽃놀이 상자 //45
; 6513 : 			level	= 0;
; 6514 : 			x		= lpObj->X;
; 6515 : 			y		= lpObj->Y;
; 6516 : 			int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );
; 6517 : 			ItemSerialCreateSend( lpTargetObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, iMaxHitUser );
; 6518 : 			return TRUE;
; 6519 : 		}
; 6520 : 	}
; 6521 : #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 6522 : 
; 6523 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029							// 행운의 동전 드롭처리
; 6524 : 	if(g_bLuckyCoinEventOn)
; 6525 : 	{
; 6526 : 		if (rand()%10000 < g_iLuckyCoinDropRate) {
; 6527 : 			Option1 = 0;
; 6528 : 			Option2 = 0;
; 6529 : 			Option3 = 0;
; 6530 : 			level	= 0;
; 6531 : 			dur		= 1;
; 6532 : 			x		= lpObj->X;
; 6533 : 			y		= lpObj->Y;
; 6534 : 
; 6535 : 			type = ItemGetNumberMake(14, 100);						// 행운의 동전
; 6536 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 6537 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 6538 : 			return TRUE;
; 6539 : 		}
; 6540 : 	}
; 6541 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029
; 6542 : 	
; 6543 : 	return FALSE;

  010c1	33 c0		 xor	 eax, eax
$LN1@gEventMons:

; 6544 : }

  010c3	5f		 pop	 edi
  010c4	5e		 pop	 esi
  010c5	5b		 pop	 ebx
  010c6	8b e5		 mov	 esp, ebp
  010c8	5d		 pop	 ebp
  010c9	c3		 ret	 0
?gEventMonsterItemDrop@@YAHPAVOBJECTSTRUCT@@0@Z ENDP	; gEventMonsterItemDrop
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterBeattackRecv@@YAXPAEH@Z
_TEXT	SEGMENT
_n$1 = -548						; size = 4
_i$2 = -544						; size = 4
_pTargetNumber$ = -540					; size = 512
_lOfs2$ = -28						; size = 4
_lpMsg$ = -24						; size = 4
_lpMagic$ = -20						; size = 4
_tNumber$ = -16						; size = 4
_lOfs$ = -12						; size = 4
_lpCount$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?gObjMonsterBeattackRecv@@YAXPAEH@Z PROC		; gObjMonsterBeattackRecv, COMDAT

; 2016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 02 00
	00		 sub	 esp, 676		; 000002a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2017 : 	LPPMSG_BEATTACK_COUNT	lpCount = (LPPMSG_BEATTACK_COUNT)lpRecv;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00019	89 45 f8	 mov	 DWORD PTR _lpCount$[ebp], eax

; 2018 : 	
; 2019 : 	int	lOfs;
; 2020 : 	int tNumber;
; 2021 : 	CMagicInf *lpMagic;
; 2022 : 
; 2023 : 	lOfs = sizeof(PMSG_BEATTACK_COUNT);

  0001c	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _lOfs$[ebp], 8

; 2024 : 	LPPMSG_BEATTACK	lpMsg;
; 2025 : 
; 2026 : 	// 몬스터일 경우 마법 번호 얻는 처리
; 2027 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2028 : 	WORD wMagicNumber = MAKEWORD( lpCount->MagicNumberL, lpCount->MagicNumberH );
; 2029 : 	lpMagic = gObjGetMagic(&gObj[aIndex], wMagicNumber);
; 2030 : #else
; 2031 : 	lpMagic = gObjGetMagic(&gObj[aIndex], lpCount->MagicNumber);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00026	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0002a	51		 push	 ecx
  0002b	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00032	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z ; gObjGetMagic
  0003e	83 c4 08	 add	 esp, 8
  00041	89 45 ec	 mov	 DWORD PTR _lpMagic$[ebp], eax

; 2032 : #endif
; 2033 : 
; 2034 : 	if( lpMagic == NULL )

  00044	83 7d ec 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00048	75 21		 jne	 SHORT $LN8@gObjMonste

; 2035 : 	{
; 2036 : 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMonsterBeattackRecv@@YAXPAEH@Z@4JA
  0004f	83 c0 14	 add	 eax, 20			; 00000014H
  00052	50		 push	 eax
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IODFIFIN@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd@
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2037 : 		return;

  00066	e9 29 01 00 00	 jmp	 $LN1@gObjMonste
$LN8@gObjMonste:

; 2038 : 	}
; 2039 : 
; 2040 : 	int lOfs2 = lOfs;

  0006b	8b 45 f4	 mov	 eax, DWORD PTR _lOfs$[ebp]
  0006e	89 45 e4	 mov	 DWORD PTR _lOfs2$[ebp], eax

; 2041 : 	int pTargetNumber[128] = {0,};

  00071	68 00 02 00 00	 push	 512			; 00000200H
  00076	6a 00		 push	 0
  00078	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pTargetNumber$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _memset
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2042 : 
; 2043 : 	for( int i = 0; i < lpCount->Count; i++ )

  00087	c7 85 e0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$2[ebp], 0
  00091	eb 0f		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  00093	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _i$2[ebp], eax
$LN4@gObjMonste:
  000a2	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  000a5	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  000a9	39 8d e0 fd ff
	ff		 cmp	 DWORD PTR _i$2[ebp], ecx
  000af	7d 48		 jge	 SHORT $LN3@gObjMonste

; 2044 : 	{
; 2045 : 		lpMsg = (LPPMSG_BEATTACK)(lpRecv+lOfs2);

  000b1	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  000b4	03 45 e4	 add	 eax, DWORD PTR _lOfs2$[ebp]
  000b7	89 45 e8	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2046 : 		pTargetNumber[i] = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  000ba	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000bd	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000c1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000c7	0f b6 d1	 movzx	 edx, cl
  000ca	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000cd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000d6	0f b6 c1	 movzx	 eax, cl
  000d9	c1 e0 08	 shl	 eax, 8
  000dc	0b d0		 or	 edx, eax
  000de	0f b7 ca	 movzx	 ecx, dx
  000e1	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR _i$2[ebp]
  000e7	89 8c 95 e4 fd
	ff ff		 mov	 DWORD PTR _pTargetNumber$[ebp+edx*4], ecx

; 2047 : 		lOfs2 += sizeof(PMSG_BEATTACK);

  000ee	8b 45 e4	 mov	 eax, DWORD PTR _lOfs2$[ebp]
  000f1	83 c0 03	 add	 eax, 3
  000f4	89 45 e4	 mov	 DWORD PTR _lOfs2$[ebp], eax

; 2048 : 	}

  000f7	eb 9a		 jmp	 SHORT $LN2@gObjMonste
$LN3@gObjMonste:

; 2049 : 	
; 2050 : 	for( int n=0; n<lpCount->Count; n++)

  000f9	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1[ebp], 0
  00103	eb 0f		 jmp	 SHORT $LN7@gObjMonste
$LN5@gObjMonste:
  00105	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  0010b	83 c0 01	 add	 eax, 1
  0010e	89 85 dc fd ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN7@gObjMonste:
  00114	8b 45 f8	 mov	 eax, DWORD PTR _lpCount$[ebp]
  00117	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  0011b	39 8d dc fd ff
	ff		 cmp	 DWORD PTR _n$1[ebp], ecx
  00121	7d 71		 jge	 SHORT $LN1@gObjMonste

; 2051 : 	{
; 2052 : 		lpMsg = (LPPMSG_BEATTACK)(lpRecv+lOfs);

  00123	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00126	03 45 f4	 add	 eax, DWORD PTR _lOfs$[ebp]
  00129	89 45 e8	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2053 : 		tNumber = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);	

  0012c	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0012f	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00133	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00139	0f b6 d1	 movzx	 edx, cl
  0013c	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0013f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00142	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00148	0f b6 c1	 movzx	 eax, cl
  0014b	c1 e0 08	 shl	 eax, 8
  0014e	0b d0		 or	 edx, eax
  00150	0f b7 ca	 movzx	 ecx, dx
  00153	89 4d f0	 mov	 DWORD PTR _tNumber$[ebp], ecx

; 2054 : 
; 2055 : 		gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, 1, 1);

  00156	6a 00		 push	 0
  00158	6a 00		 push	 0
  0015a	6a 01		 push	 1
  0015c	6a 01		 push	 1
  0015e	8b 45 ec	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00161	50		 push	 eax
  00162	69 4d f0 a0 1b
	00 00		 imul	 ecx, DWORD PTR _tNumber$[ebp], 7072
  00169	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016f	51		 push	 ecx
  00170	69 55 0c a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00177	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017d	52		 push	 edx
  0017e	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00183	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2056 : 		
; 2057 : 		lOfs += sizeof(PMSG_BEATTACK);

  00186	8b 45 f4	 mov	 eax, DWORD PTR _lOfs$[ebp]
  00189	83 c0 03	 add	 eax, 3
  0018c	89 45 f4	 mov	 DWORD PTR _lOfs$[ebp], eax

; 2058 : 	}

  0018f	e9 71 ff ff ff	 jmp	 $LN5@gObjMonste
$LN1@gObjMonste:

; 2059 : }

  00194	5f		 pop	 edi
  00195	5e		 pop	 esi
  00196	5b		 pop	 ebx
  00197	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019a	33 cd		 xor	 ecx, ebp
  0019c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c3		 ret	 0
?gObjMonsterBeattackRecv@@YAXPAEH@Z ENDP		; gObjMonsterBeattackRecv
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterMagicAttack@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_pDuration$ = -296					; size = 12
_ASBOfs$ = -284						; size = 4
_AttackSendBuff$ = -280					; size = 256
_pAttack$ = -24						; size = 3
_pCount$ = -20						; size = 8
_count$ = -12						; size = 4
_tObjNum$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iMonsterClass$ = 12					; size = 4
?gObjMonsterMagicAttack@@YAXPAVOBJECTSTRUCT@@H@Z PROC	; gObjMonsterMagicAttack, COMDAT

; 1853 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1854 : 	int tObjNum;
; 1855 : 	int  count=0;

  00016	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 1856 : 	PMSG_BEATTACK_COUNT	pCount;
; 1857 : 	PMSG_BEATTACK		pAttack;
; 1858 : 
; 1859 : 	// 이 버퍼 크기 주의해야 한다. 
; 1860 : 	// 추후 몬스터의 뷰포트개수가 증가했을시 수정되야함! (apple)
; 1861 : 	BYTE AttackSendBuff[256];
; 1862 : 	int  ASBOfs=0;

  0001d	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _ASBOfs$[ebp], 0

; 1863 : 	
; 1864 : 	PMSG_DURATION_MAGIC_RECV pDuration;
; 1865 : 	
; 1866 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 1867 : 	pCount.MagicNumberH	= HIBYTE( 0 );
; 1868 : 	pCount.MagicNumberL	= LOBYTE( 0 );
; 1869 : #else
; 1870 : 	pCount.MagicNumber = 0;

  00027	c6 45 ef 00	 mov	 BYTE PTR _pCount$[ebp+3], 0

; 1871 : #endif
; 1872 : 	pDuration.Dir = 0;

  0002b	c6 85 de fe ff
	ff 00		 mov	 BYTE PTR _pDuration$[ebp+6], 0

; 1873 : 	pDuration.X = (BYTE)lpObj->X;

  00032	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00035	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  0003b	88 8d dc fe ff
	ff		 mov	 BYTE PTR _pDuration$[ebp+4], cl

; 1874 : 	pDuration.Y = (BYTE)lpObj->Y;

  00041	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00044	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  0004a	88 8d dd fe ff
	ff		 mov	 BYTE PTR _pDuration$[ebp+5], cl

; 1875 : 
; 1876 : #ifdef MODIFY_MONSTER_ENTIRE_ATTACK_20040915
; 1877 : 	// 쿤둔일 경우에는 데미지 판정만 한다 - apple
; 1878 : 	//if( iMonsterClass != 275 )
; 1879 : #endif
; 1880 : 	CGDurationMagicRecv(&pDuration, lpObj->m_Index);

  00050	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	51		 push	 ecx
  00056	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _pDuration$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv
  00062	83 c4 08	 add	 esp, 8

; 1881 : 		
; 1882 : 	pCount.h.c = PMHC_BYTE;

  00065	c6 45 ec c1	 mov	 BYTE PTR _pCount$[ebp], 193 ; 000000c1H

; 1883 : #ifdef PACKET_CHANGE	
; 1884 : 	pCount.h.headcode = PACKET_MAGIC_ATTACK;

  00069	c6 45 ee 1d	 mov	 BYTE PTR _pCount$[ebp+2], 29 ; 0000001dH

; 1885 : #else
; 1886 : 	pCount.h.headcode = 0x1D;
; 1887 : #endif
; 1888 : 	pCount.h.size = 0;

  0006d	c6 45 ed 00	 mov	 BYTE PTR _pCount$[ebp+1], 0

; 1889 : 	// 쿤둔(275) 기본 공격을 전체 마법으로. (apple)
; 1890 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 1891 : 	pCount.MagicNumberH	= HIBYTE( 0 );
; 1892 : 	pCount.MagicNumberL	= LOBYTE( 0 );
; 1893 : #else
; 1894 : 	pCount.MagicNumber = 0;

  00071	c6 45 ef 00	 mov	 BYTE PTR _pCount$[ebp+3], 0

; 1895 : #endif
; 1896 : 	pCount.Count = 0;

  00075	c6 45 f3 00	 mov	 BYTE PTR _pCount$[ebp+7], 0

; 1897 : 	pCount.X = (BYTE)lpObj->X;

  00079	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007c	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00082	88 4d f0	 mov	 BYTE PTR _pCount$[ebp+4], cl

; 1898 : 	pCount.Y = (BYTE)lpObj->Y;

  00085	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00088	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  0008e	88 4d f1	 mov	 BYTE PTR _pCount$[ebp+5], cl

; 1899 : 	ASBOfs = sizeof( pCount );

  00091	c7 85 e4 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _ASBOfs$[ebp], 8
$LN2@gObjMonste:

; 1900 : 	
; 1901 : 	while(1)

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	85 c0		 test	 eax, eax
  000a2	0f 84 3b 01 00
	00		 je	 $LN3@gObjMonste

; 1902 : 	{
; 1903 : 		if( lpObj->VpPlayer2[count].state )

  000a8	6b 45 f4 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000af	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  000b7	85 d2		 test	 edx, edx
  000b9	0f 84 0e 01 00
	00		 je	 $LN4@gObjMonste

; 1904 : 		{
; 1905 : 			if( lpObj->VpPlayer2[count].type == OBJTYPE_CHARACTER )

  000bf	6b 45 f4 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c6	0f b6 94 01 ec
	06 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1772]
  000ce	83 fa 01	 cmp	 edx, 1
  000d1	0f 85 f6 00 00
	00		 jne	 $LN4@gObjMonste

; 1906 : 			{
; 1907 : 				tObjNum = lpObj->VpPlayer2[count].number;

  000d7	6b 45 f4 0c	 imul	 eax, DWORD PTR _count$[ebp], 12
  000db	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000de	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  000e6	89 55 f8	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 1908 : 				if( tObjNum >= 0 )

  000e9	83 7d f8 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  000ed	0f 8c da 00 00
	00		 jl	 $LN4@gObjMonste

; 1909 : 				{
; 1910 : 					if( lpObj->Class == 77 )

  000f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f6	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000fd	83 f9 4d	 cmp	 ecx, 77			; 0000004dH
  00100	75 4e		 jne	 SHORT $LN7@gObjMonste

; 1911 : 					{
; 1912 : 						pAttack.NumberH = HIBYTE(tObjNum);

  00102	8b 45 f8	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00105	c1 e8 08	 shr	 eax, 8
  00108	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0010d	88 45 e8	 mov	 BYTE PTR _pAttack$[ebp], al

; 1913 : 						pAttack.NumberL = LOBYTE(tObjNum);

  00110	8b 45 f8	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00113	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00118	88 45 e9	 mov	 BYTE PTR _pAttack$[ebp+1], al

; 1914 : 						memcpy( AttackSendBuff+ASBOfs, (char*)&pAttack, sizeof( pAttack ));

  0011b	6a 03		 push	 3
  0011d	8d 45 e8	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00120	50		 push	 eax
  00121	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _ASBOfs$[ebp]
  00127	8d 94 0d e8 fe
	ff ff		 lea	 edx, DWORD PTR _AttackSendBuff$[ebp+ecx]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 _memcpy
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1915 : 						ASBOfs += sizeof( pAttack );

  00137	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _ASBOfs$[ebp]
  0013d	83 c0 03	 add	 eax, 3
  00140	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _ASBOfs$[ebp], eax

; 1916 : 						pCount.Count++;

  00146	8a 45 f3	 mov	 al, BYTE PTR _pCount$[ebp+7]
  00149	04 01		 add	 al, 1
  0014b	88 45 f3	 mov	 BYTE PTR _pCount$[ebp+7], al

; 1917 : 					}

  0014e	eb 7d		 jmp	 SHORT $LN4@gObjMonste
$LN7@gObjMonste:

; 1918 : 					else
; 1919 : 					{
; 1920 : #ifdef MODIFY_KUNDUN_VIEWPORT_20060523
; 1921 : 						// 쿤둔 인 경우 전체 공격일 때 거리 무시.
; 1922 : 						if( lpObj->Class == 275 || gObjCalDistance( lpObj, &gObj[tObjNum]) < 6 )

  00150	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00153	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0015a	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  00160	74 1f		 je	 SHORT $LN10@gObjMonste
  00162	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00169	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016f	50		 push	 eax
  00170	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00173	51		 push	 ecx
  00174	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00179	83 c4 08	 add	 esp, 8
  0017c	83 f8 06	 cmp	 eax, 6
  0017f	7d 4c		 jge	 SHORT $LN4@gObjMonste
$LN10@gObjMonste:

; 1923 : #else
; 1924 : 						if( gObjCalDistance( lpObj, &gObj[tObjNum]) < 6 )
; 1925 : #endif // MODIFY_KUNDUN_VIEWPORT_20060523
; 1926 : 						{
; 1927 : 							pAttack.NumberH = HIBYTE(tObjNum);

  00181	8b 45 f8	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00184	c1 e8 08	 shr	 eax, 8
  00187	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0018c	88 45 e8	 mov	 BYTE PTR _pAttack$[ebp], al

; 1928 : 							pAttack.NumberL = LOBYTE(tObjNum);

  0018f	8b 45 f8	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00192	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00197	88 45 e9	 mov	 BYTE PTR _pAttack$[ebp+1], al

; 1929 : 							memcpy( AttackSendBuff+ASBOfs, (char*)&pAttack, sizeof( pAttack ));

  0019a	6a 03		 push	 3
  0019c	8d 45 e8	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0019f	50		 push	 eax
  001a0	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _ASBOfs$[ebp]
  001a6	8d 94 0d e8 fe
	ff ff		 lea	 edx, DWORD PTR _AttackSendBuff$[ebp+ecx]
  001ad	52		 push	 edx
  001ae	e8 00 00 00 00	 call	 _memcpy
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1930 : 							ASBOfs += sizeof( pAttack );

  001b6	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _ASBOfs$[ebp]
  001bc	83 c0 03	 add	 eax, 3
  001bf	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _ASBOfs$[ebp], eax

; 1931 : 							pCount.Count++;

  001c5	8a 45 f3	 mov	 al, BYTE PTR _pCount$[ebp+7]
  001c8	04 01		 add	 al, 1
  001ca	88 45 f3	 mov	 BYTE PTR _pCount$[ebp+7], al
$LN4@gObjMonste:

; 1932 : 						}
; 1933 : 					}					
; 1934 : 				}
; 1935 : 			}
; 1936 : 		}
; 1937 : 		count++;

  001cd	8b 45 f4	 mov	 eax, DWORD PTR _count$[ebp]
  001d0	83 c0 01	 add	 eax, 1
  001d3	89 45 f4	 mov	 DWORD PTR _count$[ebp], eax

; 1938 : 		if( count > MAX_MONVIEWPORTOBJECT-1 )

  001d6	83 7d f4 13	 cmp	 DWORD PTR _count$[ebp], 19 ; 00000013H
  001da	7e 02		 jle	 SHORT $LN11@gObjMonste

; 1939 : 		{
; 1940 : 			break;

  001dc	eb 05		 jmp	 SHORT $LN3@gObjMonste
$LN11@gObjMonste:

; 1941 : 		}
; 1942 : 	}

  001de	e9 b8 fe ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 1943 : 	if( pCount.Count > 0 )

  001e3	0f b6 45 f3	 movzx	 eax, BYTE PTR _pCount$[ebp+7]
  001e7	85 c0		 test	 eax, eax
  001e9	0f 8e b8 00 00
	00		 jle	 $LN1@gObjMonste

; 1944 : 	{			
; 1945 : 		pCount.h.size = ASBOfs;

  001ef	8a 85 e4 fe ff
	ff		 mov	 al, BYTE PTR _ASBOfs$[ebp]
  001f5	88 45 ed	 mov	 BYTE PTR _pCount$[ebp+1], al

; 1946 : 		memcpy(AttackSendBuff, (char*)&pCount, sizeof(pCount));

  001f8	6a 08		 push	 8
  001fa	8d 45 ec	 lea	 eax, DWORD PTR _pCount$[ebp]
  001fd	50		 push	 eax
  001fe	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _AttackSendBuff$[ebp]
  00204	51		 push	 ecx
  00205	e8 00 00 00 00	 call	 _memcpy
  0020a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1947 : 
; 1948 : #ifdef MODIFY_MONSTER_ENTIRE_ATTACK_20040915
; 1949 : 		// 쿤둔의 환영일 경우
; 1950 : 		if (
; 1951 : 			lpObj->Class == 161 ||		// 쿤둔의 환영1
; 1952 : 			lpObj->Class == 181 || 		// 쿤둔의 환영2
; 1953 : 			lpObj->Class == 189 || 		// 쿤둔의 환영3
; 1954 : 			lpObj->Class == 197 || 		// 쿤둔의 환영4
; 1955 : 			lpObj->Class == 267 || 		// 쿤둔의 환영5

  0020d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00210	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00217	81 f9 a1 00 00
	00		 cmp	 ecx, 161		; 000000a1H
  0021d	74 5a		 je	 SHORT $LN15@gObjMonste
  0021f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00222	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00229	81 f9 b5 00 00
	00		 cmp	 ecx, 181		; 000000b5H
  0022f	74 48		 je	 SHORT $LN15@gObjMonste
  00231	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00234	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0023b	81 f9 bd 00 00
	00		 cmp	 ecx, 189		; 000000bdH
  00241	74 36		 je	 SHORT $LN15@gObjMonste
  00243	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00246	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0024d	81 f9 c5 00 00
	00		 cmp	 ecx, 197		; 000000c5H
  00253	74 24		 je	 SHORT $LN15@gObjMonste
  00255	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00258	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0025f	81 f9 0b 01 00
	00		 cmp	 ecx, 267		; 0000010bH
  00265	74 12		 je	 SHORT $LN15@gObjMonste
  00267	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00271	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  00277	75 17		 jne	 SHORT $LN13@gObjMonste
$LN15@gObjMonste:

; 1956 : 			lpObj->Class == 275 		// 쿤둔의 환영6
; 1957 : 		)
; 1958 : 		{
; 1959 : 			gObjMonsterBeattackRecv(AttackSendBuff, lpObj->m_Index);

  00279	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0027c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027e	51		 push	 ecx
  0027f	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _AttackSendBuff$[ebp]
  00285	52		 push	 edx
  00286	e8 00 00 00 00	 call	 ?gObjMonsterBeattackRecv@@YAXPAEH@Z ; gObjMonsterBeattackRecv
  0028b	83 c4 08	 add	 esp, 8

; 1960 : 		}

  0028e	eb 17		 jmp	 SHORT $LN1@gObjMonste
$LN13@gObjMonste:

; 1961 : 		else
; 1962 : 		{
; 1963 : 			CGBeattackRecv(AttackSendBuff, lpObj->m_Index, 1);

  00290	6a 01		 push	 1
  00292	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00295	8b 08		 mov	 ecx, DWORD PTR [eax]
  00297	51		 push	 ecx
  00298	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _AttackSendBuff$[ebp]
  0029e	52		 push	 edx
  0029f	e8 00 00 00 00	 call	 ?CGBeattackRecv@@YAXPAEHH@Z ; CGBeattackRecv
  002a4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjMonste:

; 1964 : 		}
; 1965 : #else
; 1966 : 		CGBeattackRecv(AttackSendBuff, lpObj->m_Index, 1);
; 1967 : #endif
; 1968 : 		
; 1969 : 	}
; 1970 : }

  002a7	5f		 pop	 edi
  002a8	5e		 pop	 esi
  002a9	5b		 pop	 ebx
  002aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ad	33 cd		 xor	 ecx, ebp
  002af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b4	8b e5		 mov	 esp, ebp
  002b6	5d		 pop	 ebp
  002b7	c3		 ret	 0
?gObjMonsterMagicAttack@@YAXPAVOBJECTSTRUCT@@H@Z ENDP	; gObjMonsterMagicAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterAttack@@YAXPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv492 = -152						; size = 4
_pAttackMsg$1 = -84					; size = 7
_pAttackMsg$2 = -76					; size = 7
_pAttackMsg$3 = -68					; size = 7
_pAttackMsg$4 = -60					; size = 7
_pAttackMsg$5 = -52					; size = 7
_pAttackMsg$6 = -44					; size = 7
_pAttackMsg$7 = -36					; size = 7
_pAttackMsg$8 = -28					; size = 7
_pAttackMsg$9 = -20					; size = 7
_pAttackMsg$10 = -12					; size = 7
_AttackType$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjMonsterAttack@@YAXPAVOBJECTSTRUCT@@0@Z PROC	; gObjMonsterAttack, COMDAT

; 2064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 2065 : 	int AttackType = lpObj->m_AttackType;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  00016	89 4d fc	 mov	 DWORD PTR _AttackType$[ebp], ecx

; 2066 : 
; 2067 : 	if( AttackType >= 100 ) AttackType = 0;

  00019	83 7d fc 64	 cmp	 DWORD PTR _AttackType$[ebp], 100 ; 00000064H
  0001d	7c 07		 jl	 SHORT $LN4@gObjMonste
  0001f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _AttackType$[ebp], 0
$LN4@gObjMonste:

; 2068 : 	
; 2069 : #ifdef ADD_CASTLE_HUNTZONE_MONSTER_01_20050111
; 2070 : 	if( lpObj->Class == 291 ||	
; 2071 : 		lpObj->Class == 295 
; 2072 : 	  )
; 2073 : 	{
; 2074 : //		PMSG_MAGICATTACK pAttackMsg;
; 2075 : //		pAttackMsg.MagicNumber = 3;// 썬더로 처리.
; 2076 : //		pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);
; 2077 : //		pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);
; 2078 : //		pAttackMsg.Dis     = 0;
; 2079 : //		CGMagicAttack(&pAttackMsg, lpObj->m_Index);
; 2080 : 	}
; 2081 : #endif
; 2082 : 
; 2083 : #ifdef ADD_NEW_MAP_KALIMA_20040518	// 칼리마 보스몹들의 추가 공격들
; 2084 : 	if (lpObj->m_iMonsterBattleDelay > 0) {	// 머뭇거리는 동안 (클라이언트 삽입 신 등) 에는 공격을 하지 않는다.

  00026	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00029	0f be 88 25 02
	00 00		 movsx	 ecx, BYTE PTR [eax+549]
  00030	85 c9		 test	 ecx, ecx
  00032	7e 05		 jle	 SHORT $LN5@gObjMonste

; 2085 : 		return;

  00034	e9 83 08 00 00	 jmp	 $LN1@gObjMonste
$LN5@gObjMonste:

; 2086 : 	}
; 2087 : 
; 2088 : 	if (
; 2089 : 		lpObj->Class == 144 ||		// 데스 엔젤1
; 2090 : 		lpObj->Class == 174 ||		// 데스 엔젤2
; 2091 : 		lpObj->Class == 182 ||		// 데스 엔젤3
; 2092 : 		lpObj->Class == 190 ||		// 데스 엔젤4
; 2093 : 		lpObj->Class == 260 ||		// 데스 엔젤5

  00039	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00043	81 f9 90 00 00
	00		 cmp	 ecx, 144		; 00000090H
  00049	74 5a		 je	 SHORT $LN7@gObjMonste
  0004b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00055	81 f9 ae 00 00
	00		 cmp	 ecx, 174		; 000000aeH
  0005b	74 48		 je	 SHORT $LN7@gObjMonste
  0005d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00060	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00067	81 f9 b6 00 00
	00		 cmp	 ecx, 182		; 000000b6H
  0006d	74 36		 je	 SHORT $LN7@gObjMonste
  0006f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00072	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00079	81 f9 be 00 00
	00		 cmp	 ecx, 190		; 000000beH
  0007f	74 24		 je	 SHORT $LN7@gObjMonste
  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0008b	81 f9 04 01 00
	00		 cmp	 ecx, 260		; 00000104H
  00091	74 12		 je	 SHORT $LN7@gObjMonste
  00093	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00096	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0009d	81 f9 0c 01 00
	00		 cmp	 ecx, 268		; 0000010cH
  000a3	75 66		 jne	 SHORT $LN6@gObjMonste
$LN7@gObjMonste:

; 2094 : 		lpObj->Class == 268			// 데스 엔젤6
; 2095 : 		)
; 2096 : 	{
; 2097 : 		// 1/2 확률로 썬더공격
; 2098 : 		if (rand()%2) {

  000a5	e8 00 00 00 00	 call	 _rand
  000aa	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000af	79 05		 jns	 SHORT $LN31@gObjMonste
  000b1	48		 dec	 eax
  000b2	83 c8 fe	 or	 eax, -2			; fffffffeH
  000b5	40		 inc	 eax
$LN31@gObjMonste:
  000b6	85 c0		 test	 eax, eax
  000b8	74 4a		 je	 SHORT $LN8@gObjMonste

; 2099 : 			PMSG_MAGICATTACK pAttackMsg;
; 2100 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2101 : 			pAttackMsg.MagicNumberH = HIBYTE( 0 );	// 기본 AttackType이 3 임
; 2102 : 			pAttackMsg.MagicNumberL = LOBYTE( 0 );
; 2103 : #else
; 2104 : 			pAttackMsg.MagicNumber = 0;				// 기본 AttackType이 3 임

  000ba	c6 45 f7 00	 mov	 BYTE PTR _pAttackMsg$10[ebp+3], 0

; 2105 : #endif
; 2106 : 			pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);

  000be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c1	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  000c8	c1 e9 08	 shr	 ecx, 8
  000cb	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000d1	88 4d f8	 mov	 BYTE PTR _pAttackMsg$10[ebp+4], cl

; 2107 : 			pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);

  000d4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d7	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  000de	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000e4	88 4d f9	 mov	 BYTE PTR _pAttackMsg$10[ebp+5], cl

; 2108 : 			pAttackMsg.Dis     = 0;

  000e7	c6 45 fa 00	 mov	 BYTE PTR _pAttackMsg$10[ebp+6], 0

; 2109 : 			CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  000eb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ee	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f0	51		 push	 ecx
  000f1	8d 55 f4	 lea	 edx, DWORD PTR _pAttackMsg$10[ebp]
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  000fa	83 c4 08	 add	 esp, 8

; 2110 : 			return;

  000fd	e9 ba 07 00 00	 jmp	 $LN1@gObjMonste

; 2111 : 		}

  00102	eb 07		 jmp	 SHORT $LN6@gObjMonste
$LN8@gObjMonste:

; 2112 : 		else {
; 2113 : 			AttackType = 0;

  00104	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _AttackType$[ebp], 0
$LN6@gObjMonste:

; 2114 : 		}
; 2115 : 	}
; 2116 : 
; 2117 : 	if (
; 2118 : 		lpObj->Class == 161 ||		// 쿤둔의 환영1
; 2119 : 		lpObj->Class == 181 || 		// 쿤둔의 환영2
; 2120 : 		lpObj->Class == 189 || 		// 쿤둔의 환영3
; 2121 : 		lpObj->Class == 197 || 		// 쿤둔의 환영4
; 2122 : 		lpObj->Class == 267 || 		// 쿤둔의 환영5

  0010b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00115	81 f9 a1 00 00
	00		 cmp	 ecx, 161		; 000000a1H
  0011b	74 5e		 je	 SHORT $LN11@gObjMonste
  0011d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00120	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00127	81 f9 b5 00 00
	00		 cmp	 ecx, 181		; 000000b5H
  0012d	74 4c		 je	 SHORT $LN11@gObjMonste
  0012f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00132	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00139	81 f9 bd 00 00
	00		 cmp	 ecx, 189		; 000000bdH
  0013f	74 3a		 je	 SHORT $LN11@gObjMonste
  00141	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00144	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0014b	81 f9 c5 00 00
	00		 cmp	 ecx, 197		; 000000c5H
  00151	74 28		 je	 SHORT $LN11@gObjMonste
  00153	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00156	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0015d	81 f9 0b 01 00
	00		 cmp	 ecx, 267		; 0000010bH
  00163	74 16		 je	 SHORT $LN11@gObjMonste
  00165	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00168	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0016f	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  00175	0f 85 94 00 00
	00		 jne	 $LN10@gObjMonste
$LN11@gObjMonste:

; 2123 : 		lpObj->Class == 275 		// 쿤둔의 환영6
; 2124 : 		)
; 2125 : 	{
; 2126 : 		// 썬더
; 2127 : 		PMSG_MAGICATTACK pAttackMsg;
; 2128 : 
; 2129 : 		// 전체마법 0번이 (attacktype이 100 이상인몬스터) 추가 되어 있기 때문에
; 2130 : 		// rand()%6 + 1이 된다. (apple)
; 2131 : 		
; 2132 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2133 : 		WORD wRandValue = ( rand() % 6 ) + 1;
; 2134 : 		pAttackMsg.MagicNumberH = HIBYTE( wRandValue );
; 2135 : 		pAttackMsg.MagicNumberL = LOBYTE( wRandValue );
; 2136 : #else
; 2137 : 		pAttackMsg.MagicNumber = rand()%6+1;

  0017b	e8 00 00 00 00	 call	 _rand
  00180	99		 cdq
  00181	b9 06 00 00 00	 mov	 ecx, 6
  00186	f7 f9		 idiv	 ecx
  00188	83 c2 01	 add	 edx, 1
  0018b	88 55 ef	 mov	 BYTE PTR _pAttackMsg$9[ebp+3], dl

; 2138 : #endif
; 2139 : 
; 2140 : 		pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);

  0018e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00191	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00198	c1 e9 08	 shr	 ecx, 8
  0019b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001a1	88 4d f0	 mov	 BYTE PTR _pAttackMsg$9[ebp+4], cl

; 2141 : 		pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);

  001a4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a7	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  001ae	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  001b4	88 4d f1	 mov	 BYTE PTR _pAttackMsg$9[ebp+5], cl

; 2142 : 		pAttackMsg.Dis     = 0;

  001b7	c6 45 f2 00	 mov	 BYTE PTR _pAttackMsg$9[ebp+6], 0

; 2143 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  001bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001be	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c0	51		 push	 ecx
  001c1	8d 55 ec	 lea	 edx, DWORD PTR _pAttackMsg$9[ebp]
  001c4	52		 push	 edx
  001c5	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  001ca	83 c4 08	 add	 esp, 8

; 2144 : 
; 2145 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2146 : 		if( wRandValue == 1 || wRandValue == 2 || wRandValue == 0)
; 2147 : 			gObjUseMonsterSpecialAbillity( lpObj );
; 2148 : #else
; 2149 : #ifdef ADD_ABILLITY_KUNDUN_01_20040920	
; 2150 : 		if( pAttackMsg.MagicNumber == 1 || pAttackMsg.MagicNumber == 2 || pAttackMsg.MagicNumber == 0)

  001cd	0f b6 45 ef	 movzx	 eax, BYTE PTR _pAttackMsg$9[ebp+3]
  001d1	83 f8 01	 cmp	 eax, 1
  001d4	74 11		 je	 SHORT $LN13@gObjMonste
  001d6	0f b6 45 ef	 movzx	 eax, BYTE PTR _pAttackMsg$9[ebp+3]
  001da	83 f8 02	 cmp	 eax, 2
  001dd	74 08		 je	 SHORT $LN13@gObjMonste
  001df	0f b6 45 ef	 movzx	 eax, BYTE PTR _pAttackMsg$9[ebp+3]
  001e3	85 c0		 test	 eax, eax
  001e5	75 0c		 jne	 SHORT $LN12@gObjMonste
$LN13@gObjMonste:

; 2151 : 			gObjUseMonsterSpecialAbillity( lpObj );

  001e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ea	50		 push	 eax
  001eb	e8 00 00 00 00	 call	 ?gObjUseMonsterSpecialAbillity@@YAXPAVOBJECTSTRUCT@@@Z ; gObjUseMonsterSpecialAbillity
  001f0	83 c4 04	 add	 esp, 4
$LN12@gObjMonste:

; 2152 : #endif
; 2153 : #endif	// ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107
; 2154 : 
; 2155 : #ifdef MODIFY_MONSTER_ENTIRE_ATTACK_20040915
; 2156 : 		gObjMonsterMagicAttack(lpObj, lpObj->Class);		// 쿤둔의 환영의 경우 범위 마법 (막마의 불꽃) 이 항상 나간다.

  001f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f6	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001fd	51		 push	 ecx
  001fe	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00201	52		 push	 edx
  00202	e8 00 00 00 00	 call	 ?gObjMonsterMagicAttack@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjMonsterMagicAttack
  00207	83 c4 08	 add	 esp, 8

; 2157 : #else
; 2158 : 		gObjMonsterMagicAttack(lpObj);						// 쿤둔의 환영의 경우 범위 마법 (막마의 불꽃) 이 항상 나간다.
; 2159 : #endif
; 2160 : 		return;

  0020a	e9 ad 06 00 00	 jmp	 $LN1@gObjMonste
$LN10@gObjMonste:

; 2161 : 	}
; 2162 : 
; 2163 : 	if (
; 2164 : 		lpObj->Class == 149 ||		// 네크론1
; 2165 : 		lpObj->Class == 179 ||		// 네크론2
; 2166 : 		lpObj->Class == 187 ||		// 네크론3
; 2167 : 		lpObj->Class == 195 ||		// 네크론4
; 2168 : 		lpObj->Class == 265 ||		// 네크론5

  0020f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00212	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00219	81 f9 95 00 00
	00		 cmp	 ecx, 149		; 00000095H
  0021f	74 5a		 je	 SHORT $LN15@gObjMonste
  00221	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00224	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0022b	81 f9 b3 00 00
	00		 cmp	 ecx, 179		; 000000b3H
  00231	74 48		 je	 SHORT $LN15@gObjMonste
  00233	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00236	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0023d	81 f9 bb 00 00
	00		 cmp	 ecx, 187		; 000000bbH
  00243	74 36		 je	 SHORT $LN15@gObjMonste
  00245	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00248	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0024f	81 f9 c3 00 00
	00		 cmp	 ecx, 195		; 000000c3H
  00255	74 24		 je	 SHORT $LN15@gObjMonste
  00257	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00261	81 f9 09 01 00
	00		 cmp	 ecx, 265		; 00000109H
  00267	74 12		 je	 SHORT $LN15@gObjMonste
  00269	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00273	81 f9 11 01 00
	00		 cmp	 ecx, 273		; 00000111H
  00279	75 5b		 jne	 SHORT $LN14@gObjMonste
$LN15@gObjMonste:

; 2169 : 		lpObj->Class == 273			// 네크론6
; 2170 : 		)
; 2171 : 	{
; 2172 : 		PMSG_MAGICATTACK pAttackMsg;
; 2173 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2174 : 		WORD wRandValue = ( rand() % 2 )+ 1;
; 2175 : 		pAttackMsg.MagicNumberH = HIBYTE( wRandValue );		// 네크론의 경우는 에너지볼과 포이즌 둘 중 하나가 나간다.
; 2176 : 		pAttackMsg.MagicNumberL = LOBYTE( wRandValue );		
; 2177 : #else
; 2178 : 		pAttackMsg.MagicNumber = rand()%2+1;				// 네크론의 경우는 에너지볼과 포이즌 둘 중 하나가 나간다.

  0027b	e8 00 00 00 00	 call	 _rand
  00280	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00285	79 05		 jns	 SHORT $LN32@gObjMonste
  00287	48		 dec	 eax
  00288	83 c8 fe	 or	 eax, -2			; fffffffeH
  0028b	40		 inc	 eax
$LN32@gObjMonste:
  0028c	83 c0 01	 add	 eax, 1
  0028f	88 45 e7	 mov	 BYTE PTR _pAttackMsg$8[ebp+3], al

; 2179 : #endif
; 2180 : 		pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);

  00292	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00295	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0029c	c1 e9 08	 shr	 ecx, 8
  0029f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002a5	88 4d e8	 mov	 BYTE PTR _pAttackMsg$8[ebp+4], cl

; 2181 : 		pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);

  002a8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ab	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  002b2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002b8	88 4d e9	 mov	 BYTE PTR _pAttackMsg$8[ebp+5], cl

; 2182 : 		pAttackMsg.Dis     = 0;

  002bb	c6 45 ea 00	 mov	 BYTE PTR _pAttackMsg$8[ebp+6], 0

; 2183 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  002bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c4	51		 push	 ecx
  002c5	8d 55 e4	 lea	 edx, DWORD PTR _pAttackMsg$8[ebp]
  002c8	52		 push	 edx
  002c9	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  002ce	83 c4 08	 add	 esp, 8

; 2184 : 		return;

  002d1	e9 e6 05 00 00	 jmp	 $LN1@gObjMonste
$LN14@gObjMonste:

; 2185 : 	}
; 2186 : 
; 2187 : 
; 2188 : 	if (
; 2189 : 		lpObj->Class == 145 ||		// 로드 센튜리온1
; 2190 : 		lpObj->Class == 175 ||		// 로드 센튜리온2
; 2191 : 		lpObj->Class == 183 ||		// 로드 센튜리온3
; 2192 : 		lpObj->Class == 191 ||		// 로드 센튜리온4
; 2193 : 		lpObj->Class == 261 ||		// 로드 센튜리온5
; 2194 : 		lpObj->Class == 269 ||		// 로드 센튜리온6
; 2195 : 		lpObj->Class == 146 ||		// 블러드 솔져1
; 2196 : 		lpObj->Class == 176 || 		// 블러드 솔져2
; 2197 : 		lpObj->Class == 184 ||		// 블러드 솔져3
; 2198 : 		lpObj->Class == 192 ||		// 블러드 솔져4
; 2199 : 		lpObj->Class == 262 ||		// 블러드 솔져5
; 2200 : 		lpObj->Class == 270 ||		// 블러드 솔져6
; 2201 : 		lpObj->Class == 147 ||		// 데빌 윙1
; 2202 : 		lpObj->Class == 177 ||		// 데빌 윙2
; 2203 : 		lpObj->Class == 185 ||		// 데빌 윙3
; 2204 : 		lpObj->Class == 193 ||		// 데빌 윙4
; 2205 : 		lpObj->Class == 263 ||		// 데빌 윙5
; 2206 : 		lpObj->Class == 271 ||		// 데빌 윙6
; 2207 : 		lpObj->Class == 148 ||		// 데스 센튜리온1
; 2208 : 		lpObj->Class == 178 ||		// 데스 센튜리온2
; 2209 : 		lpObj->Class == 186 ||		// 데스 센튜리온3
; 2210 : 		lpObj->Class == 194 ||		// 데스 센튜리온4
; 2211 : 		lpObj->Class == 264 ||		// 데스 센튜리온5
; 2212 : 		lpObj->Class == 272 ||		// 데스 센튜리온6
; 2213 : //			lpObj->Class == 149 ||		// 네크론1
; 2214 : //			lpObj->Class == 179 ||		// 네크론2
; 2215 : //			lpObj->Class == 187 ||		// 네크론3
; 2216 : //			lpObj->Class == 195 ||		// 네크론4
; 2217 : //			lpObj->Class == 265 ||		// 네크론5
; 2218 : //			lpObj->Class == 273 ||		// 네크론6
; 2219 : 		lpObj->Class == 160 ||		// 쿤둔의 잔영1
; 2220 : 		lpObj->Class == 180 ||		// 쿤둔의 잔영2
; 2221 : 		lpObj->Class == 188 ||		// 쿤둔의 잔영3
; 2222 : 		lpObj->Class == 196 ||		// 쿤둔의 잔영4
; 2223 : 		lpObj->Class == 266 ||		// 쿤둔의 잔영5

  002d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d9	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  002e0	81 f9 91 00 00
	00		 cmp	 ecx, 145		; 00000091H
  002e6	0f 84 5e 02 00
	00		 je	 $LN17@gObjMonste
  002ec	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ef	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  002f6	81 f9 af 00 00
	00		 cmp	 ecx, 175		; 000000afH
  002fc	0f 84 48 02 00
	00		 je	 $LN17@gObjMonste
  00302	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00305	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0030c	81 f9 b7 00 00
	00		 cmp	 ecx, 183		; 000000b7H
  00312	0f 84 32 02 00
	00		 je	 $LN17@gObjMonste
  00318	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00322	81 f9 bf 00 00
	00		 cmp	 ecx, 191		; 000000bfH
  00328	0f 84 1c 02 00
	00		 je	 $LN17@gObjMonste
  0032e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00331	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00338	81 f9 05 01 00
	00		 cmp	 ecx, 261		; 00000105H
  0033e	0f 84 06 02 00
	00		 je	 $LN17@gObjMonste
  00344	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00347	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0034e	81 f9 0d 01 00
	00		 cmp	 ecx, 269		; 0000010dH
  00354	0f 84 f0 01 00
	00		 je	 $LN17@gObjMonste
  0035a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00364	81 f9 92 00 00
	00		 cmp	 ecx, 146		; 00000092H
  0036a	0f 84 da 01 00
	00		 je	 $LN17@gObjMonste
  00370	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00373	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0037a	81 f9 b0 00 00
	00		 cmp	 ecx, 176		; 000000b0H
  00380	0f 84 c4 01 00
	00		 je	 $LN17@gObjMonste
  00386	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00389	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00390	81 f9 b8 00 00
	00		 cmp	 ecx, 184		; 000000b8H
  00396	0f 84 ae 01 00
	00		 je	 $LN17@gObjMonste
  0039c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003a6	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  003ac	0f 84 98 01 00
	00		 je	 $LN17@gObjMonste
  003b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b5	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003bc	81 f9 06 01 00
	00		 cmp	 ecx, 262		; 00000106H
  003c2	0f 84 82 01 00
	00		 je	 $LN17@gObjMonste
  003c8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003cb	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003d2	81 f9 0e 01 00
	00		 cmp	 ecx, 270		; 0000010eH
  003d8	0f 84 6c 01 00
	00		 je	 $LN17@gObjMonste
  003de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003e8	81 f9 93 00 00
	00		 cmp	 ecx, 147		; 00000093H
  003ee	0f 84 56 01 00
	00		 je	 $LN17@gObjMonste
  003f4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f7	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003fe	81 f9 b1 00 00
	00		 cmp	 ecx, 177		; 000000b1H
  00404	0f 84 40 01 00
	00		 je	 $LN17@gObjMonste
  0040a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0040d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00414	81 f9 b9 00 00
	00		 cmp	 ecx, 185		; 000000b9H
  0041a	0f 84 2a 01 00
	00		 je	 $LN17@gObjMonste
  00420	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00423	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0042a	81 f9 c1 00 00
	00		 cmp	 ecx, 193		; 000000c1H
  00430	0f 84 14 01 00
	00		 je	 $LN17@gObjMonste
  00436	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00439	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00440	81 f9 07 01 00
	00		 cmp	 ecx, 263		; 00000107H
  00446	0f 84 fe 00 00
	00		 je	 $LN17@gObjMonste
  0044c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0044f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00456	81 f9 0f 01 00
	00		 cmp	 ecx, 271		; 0000010fH
  0045c	0f 84 e8 00 00
	00		 je	 $LN17@gObjMonste
  00462	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00465	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0046c	81 f9 94 00 00
	00		 cmp	 ecx, 148		; 00000094H
  00472	0f 84 d2 00 00
	00		 je	 $LN17@gObjMonste
  00478	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0047b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00482	81 f9 b2 00 00
	00		 cmp	 ecx, 178		; 000000b2H
  00488	0f 84 bc 00 00
	00		 je	 $LN17@gObjMonste
  0048e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00491	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00498	81 f9 ba 00 00
	00		 cmp	 ecx, 186		; 000000baH
  0049e	0f 84 a6 00 00
	00		 je	 $LN17@gObjMonste
  004a4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004a7	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  004ae	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  004b4	0f 84 90 00 00
	00		 je	 $LN17@gObjMonste
  004ba	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004bd	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  004c4	81 f9 08 01 00
	00		 cmp	 ecx, 264		; 00000108H
  004ca	74 7e		 je	 SHORT $LN17@gObjMonste
  004cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004cf	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  004d6	81 f9 10 01 00
	00		 cmp	 ecx, 272		; 00000110H
  004dc	74 6c		 je	 SHORT $LN17@gObjMonste
  004de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  004e8	81 f9 a0 00 00
	00		 cmp	 ecx, 160		; 000000a0H
  004ee	74 5a		 je	 SHORT $LN17@gObjMonste
  004f0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f3	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  004fa	81 f9 b4 00 00
	00		 cmp	 ecx, 180		; 000000b4H
  00500	74 48		 je	 SHORT $LN17@gObjMonste
  00502	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00505	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0050c	81 f9 bc 00 00
	00		 cmp	 ecx, 188		; 000000bcH
  00512	74 36		 je	 SHORT $LN17@gObjMonste
  00514	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00517	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0051e	81 f9 c4 00 00
	00		 cmp	 ecx, 196		; 000000c4H
  00524	74 24		 je	 SHORT $LN17@gObjMonste
  00526	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00529	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00530	81 f9 0a 01 00
	00		 cmp	 ecx, 266		; 0000010aH
  00536	74 12		 je	 SHORT $LN17@gObjMonste
  00538	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00542	81 f9 12 01 00
	00		 cmp	 ecx, 274		; 00000112H
  00548	75 66		 jne	 SHORT $LN16@gObjMonste
$LN17@gObjMonste:

; 2224 : 		lpObj->Class == 274			// 쿤둔의 잔영6
; 2225 : 		)
; 2226 : 	{
; 2227 : 		// 1/2 확률로 에너지 볼 공격
; 2228 : 		if (rand()%2) {

  0054a	e8 00 00 00 00	 call	 _rand
  0054f	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00554	79 05		 jns	 SHORT $LN33@gObjMonste
  00556	48		 dec	 eax
  00557	83 c8 fe	 or	 eax, -2			; fffffffeH
  0055a	40		 inc	 eax
$LN33@gObjMonste:
  0055b	85 c0		 test	 eax, eax
  0055d	74 4a		 je	 SHORT $LN18@gObjMonste

; 2229 : 			PMSG_MAGICATTACK pAttackMsg;
; 2230 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2231 : 			pAttackMsg.MagicNumberH = HIBYTE( 1 );		// 기본 AttackType이 150인 상태에서 마법을 추가했으므로 인덱스가 1
; 2232 : 			pAttackMsg.MagicNumberL = LOBYTE( 1 );	
; 2233 : #else
; 2234 : 			pAttackMsg.MagicNumber = 1;				// 기본 AttackType이 150인 상태에서 마법을 추가했으므로 인덱스가 1

  0055f	c6 45 df 01	 mov	 BYTE PTR _pAttackMsg$7[ebp+3], 1

; 2235 : #endif
; 2236 : 			pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);

  00563	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00566	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0056d	c1 e9 08	 shr	 ecx, 8
  00570	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00576	88 4d e0	 mov	 BYTE PTR _pAttackMsg$7[ebp+4], cl

; 2237 : 			pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);

  00579	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057c	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00583	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00589	88 4d e1	 mov	 BYTE PTR _pAttackMsg$7[ebp+5], cl

; 2238 : 			pAttackMsg.Dis     = 0;

  0058c	c6 45 e2 00	 mov	 BYTE PTR _pAttackMsg$7[ebp+6], 0

; 2239 : 			CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  00590	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00593	8b 08		 mov	 ecx, DWORD PTR [eax]
  00595	51		 push	 ecx
  00596	8d 55 dc	 lea	 edx, DWORD PTR _pAttackMsg$7[ebp]
  00599	52		 push	 edx
  0059a	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  0059f	83 c4 08	 add	 esp, 8

; 2240 : 			return;

  005a2	e9 15 03 00 00	 jmp	 $LN1@gObjMonste

; 2241 : 		}

  005a7	eb 07		 jmp	 SHORT $LN16@gObjMonste
$LN18@gObjMonste:

; 2242 : 		else {
; 2243 : 			AttackType = 0;

  005a9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _AttackType$[ebp], 0
$LN16@gObjMonste:

; 2244 : 		}
; 2245 : 	}
; 2246 : #endif
; 2247 : 
; 2248 : #ifdef FOR_BLOODCASTLE
; 2249 : 	if( 
; 2250 : 		lpObj->Class == 89 ||		// 마법해골1
; 2251 : 		lpObj->Class == 95 ||		// 마법해골2
; 2252 : 		lpObj->Class == 112 ||		// 마법해골3
; 2253 : 		lpObj->Class == 118 ||		// 마법해골4
; 2254 : 		lpObj->Class == 124 ||		// 마법해골5
; 2255 : 		lpObj->Class == 130			// 마법해골6
; 2256 : #ifdef BLOODCASTLE_EXTEND_20040314	// 블러드캐슬 보스몹의 체크를 늘림
; 2257 : 		|| lpObj->Class == 143		// 마법해골7

  005b0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b3	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005ba	83 f9 59	 cmp	 ecx, 89			; 00000059H
  005bd	74 60		 je	 SHORT $LN21@gObjMonste
  005bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005c2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005c9	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  005cc	74 51		 je	 SHORT $LN21@gObjMonste
  005ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005d8	83 f9 70	 cmp	 ecx, 112		; 00000070H
  005db	74 42		 je	 SHORT $LN21@gObjMonste
  005dd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005e0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005e7	83 f9 76	 cmp	 ecx, 118		; 00000076H
  005ea	74 33		 je	 SHORT $LN21@gObjMonste
  005ec	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ef	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005f6	83 f9 7c	 cmp	 ecx, 124		; 0000007cH
  005f9	74 24		 je	 SHORT $LN21@gObjMonste
  005fb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005fe	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00605	81 f9 82 00 00
	00		 cmp	 ecx, 130		; 00000082H
  0060b	74 12		 je	 SHORT $LN21@gObjMonste
  0060d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00610	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00617	81 f9 8f 00 00
	00		 cmp	 ecx, 143		; 0000008fH
  0061d	75 5b		 jne	 SHORT $LN20@gObjMonste
$LN21@gObjMonste:

; 2258 : #endif		
; 2259 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 블러드캐슬8 보스몹의 체크를 늘림
; 2260 : 		|| lpObj->Class == 433		// 마법해골8
; 2261 : #endif		
; 2262 : 		)
; 2263 : 	{
; 2264 : 		PMSG_MAGICATTACK pAttackMsg;
; 2265 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2266 : 		WORD wRandValue = ( rand() % 2 ) + 1;
; 2267 : 		pAttackMsg.MagicNumberH = HIBYTE( wRandValue );		// 마법해골의 경우는 썬더와 에너지볼 둘 중에 하나가 나간다.
; 2268 : 		pAttackMsg.MagicNumberL = LOBYTE( wRandValue );		
; 2269 : #else
; 2270 : 		pAttackMsg.MagicNumber = rand()%2+1;				// 마법해골의 경우는 썬더와 에너지볼 둘 중에 하나가 나간다.

  0061f	e8 00 00 00 00	 call	 _rand
  00624	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00629	79 05		 jns	 SHORT $LN34@gObjMonste
  0062b	48		 dec	 eax
  0062c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0062f	40		 inc	 eax
$LN34@gObjMonste:
  00630	83 c0 01	 add	 eax, 1
  00633	88 45 d7	 mov	 BYTE PTR _pAttackMsg$6[ebp+3], al

; 2271 : #endif
; 2272 : 		pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);

  00636	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00639	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00640	c1 e9 08	 shr	 ecx, 8
  00643	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00649	88 4d d8	 mov	 BYTE PTR _pAttackMsg$6[ebp+4], cl

; 2273 : 		pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);

  0064c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0064f	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00656	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0065c	88 4d d9	 mov	 BYTE PTR _pAttackMsg$6[ebp+5], cl

; 2274 : 		pAttackMsg.Dis     = 0;

  0065f	c6 45 da 00	 mov	 BYTE PTR _pAttackMsg$6[ebp+6], 0

; 2275 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  00663	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00666	8b 08		 mov	 ecx, DWORD PTR [eax]
  00668	51		 push	 ecx
  00669	8d 55 d4	 lea	 edx, DWORD PTR _pAttackMsg$6[ebp]
  0066c	52		 push	 edx
  0066d	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  00672	83 c4 08	 add	 esp, 8

; 2276 : 		return;

  00675	e9 42 02 00 00	 jmp	 $LN1@gObjMonste
$LN20@gObjMonste:

; 2277 : 	}
; 2278 : 
; 2279 : #ifdef CHAOSCASTLE_SYSTEM_20040408		// 카오스 캐슬의 궁수들의 공격은 모두 에너지 볼이다.
; 2280 : 	if( 
; 2281 : 		lpObj->Class == 163 ||		// 카오스 캐슬 - 궁수1
; 2282 : 		lpObj->Class == 165 ||		// 카오스 캐슬 - 궁수2
; 2283 : 		lpObj->Class == 167 ||		// 카오스 캐슬 - 궁수3
; 2284 : 		lpObj->Class == 169 ||		// 카오스 캐슬 - 궁수4
; 2285 : 		lpObj->Class == 171 ||		// 카오스 캐슬 - 궁수5

  0067a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0067d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00684	81 f9 a3 00 00
	00		 cmp	 ecx, 163		; 000000a3H
  0068a	74 5a		 je	 SHORT $LN23@gObjMonste
  0068c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0068f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00696	81 f9 a5 00 00
	00		 cmp	 ecx, 165		; 000000a5H
  0069c	74 48		 je	 SHORT $LN23@gObjMonste
  0069e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006a1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006a8	81 f9 a7 00 00
	00		 cmp	 ecx, 167		; 000000a7H
  006ae	74 36		 je	 SHORT $LN23@gObjMonste
  006b0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b3	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006ba	81 f9 a9 00 00
	00		 cmp	 ecx, 169		; 000000a9H
  006c0	74 24		 je	 SHORT $LN23@gObjMonste
  006c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006c5	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006cc	81 f9 ab 00 00
	00		 cmp	 ecx, 171		; 000000abH
  006d2	74 12		 je	 SHORT $LN23@gObjMonste
  006d4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006d7	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006de	81 f9 ad 00 00
	00		 cmp	 ecx, 173		; 000000adH
  006e4	75 48		 jne	 SHORT $LN22@gObjMonste
$LN23@gObjMonste:

; 2286 : 		lpObj->Class == 173			// 카오스 캐슬 - 궁수6
; 2287 : #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	// 카오스궁수7 추가
; 2288 : 		|| lpObj->Class == 427			// 카오스 캐슬 - 궁수7
; 2289 : #endif		
; 2290 : 		)
; 2291 : 	{
; 2292 : 		PMSG_MAGICATTACK pAttackMsg;
; 2293 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2294 : 		pAttackMsg.MagicNumberH = HIBYTE( 1 );							// 카오스캐슬 궁수의 경우는 항상 에너지 볼을 쏜다.
; 2295 : 		pAttackMsg.MagicNumberL = LOBYTE( 1 );							// 카오스캐슬 궁수의 경우는 항상 에너지 볼을 쏜다.
; 2296 : #else
; 2297 : 		pAttackMsg.MagicNumber = 1;							// 카오스캐슬 궁수의 경우는 항상 에너지 볼을 쏜다.

  006e6	c6 45 cf 01	 mov	 BYTE PTR _pAttackMsg$5[ebp+3], 1

; 2298 : #endif
; 2299 : 		pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);

  006ea	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ed	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  006f4	c1 e9 08	 shr	 ecx, 8
  006f7	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  006fd	88 4d d0	 mov	 BYTE PTR _pAttackMsg$5[ebp+4], cl

; 2300 : 		pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);

  00700	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00703	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0070a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00710	88 4d d1	 mov	 BYTE PTR _pAttackMsg$5[ebp+5], cl

; 2301 : 		pAttackMsg.Dis     = 0;

  00713	c6 45 d2 00	 mov	 BYTE PTR _pAttackMsg$5[ebp+6], 0

; 2302 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  00717	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0071c	51		 push	 ecx
  0071d	8d 55 cc	 lea	 edx, DWORD PTR _pAttackMsg$5[ebp]
  00720	52		 push	 edx
  00721	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  00726	83 c4 08	 add	 esp, 8

; 2303 : 		return;

  00729	e9 8e 01 00 00	 jmp	 $LN1@gObjMonste
$LN22@gObjMonste:

; 2304 : 	}
; 2305 : #endif
; 2306 : 	
; 2307 : /*	if (
; 2308 : 		lpObj->Class == 87 ||		// 자이언트오거1
; 2309 : 		lpObj->Class == 93 ||		// 자이언트오거2
; 2310 : 		lpObj->Class == 99 ||		// 자이언트오거3
; 2311 : 		lpObj->Class == 116 ||		// 자이언트오거4
; 2312 : 		lpObj->Class == 122 ||		// 자이언트오거5
; 2313 : 		lpObj->Class == 128			// 자이언트오거6
; 2314 : 		)
; 2315 : 	{
; 2316 : 		if(rand()%2) {
; 2317 : 			// 자이언트오거의 경우는 1/2 확률로 마법공격과 일반공격을 번갈아 한다.
; 2318 : 			PMSG_MAGICATTACK pAttackMsg;
; 2319 : 			pAttackMsg.MagicNumber = 1;		// 추가되었던 번개마법
; 2320 : 			pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);
; 2321 : 			pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);
; 2322 : 			pAttackMsg.Dis     = 0;
; 2323 : 			CGMagicAttack(&pAttackMsg, lpObj->m_Index);
; 2324 : 			return;
; 2325 : 		}
; 2326 : 	}
; 2327 : */
; 2328 : 	if( 
; 2329 : 		lpObj->Class == 66 || 
; 2330 : 		lpObj->Class == 73 || 

  0072e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00731	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00738	83 f9 42	 cmp	 ecx, 66			; 00000042H
  0073b	74 1e		 je	 SHORT $LN25@gObjMonste
  0073d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00740	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00747	83 f9 49	 cmp	 ecx, 73			; 00000049H
  0074a	74 0f		 je	 SHORT $LN25@gObjMonste
  0074c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0074f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00756	83 f9 4d	 cmp	 ecx, 77			; 0000004dH
  00759	75 48		 jne	 SHORT $LN24@gObjMonste
$LN25@gObjMonste:

; 2331 : 		lpObj->Class == 77
; 2332 : 		)
; 2333 : 	{
; 2334 : 		PMSG_MAGICATTACK pAttackMsg;
; 2335 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2336 : 		pAttackMsg.MagicNumberH = HIBYTE( 1 );
; 2337 : 		pAttackMsg.MagicNumberL = LOBYTE( 1 );
; 2338 : #else
; 2339 : 		pAttackMsg.MagicNumber = 1;//(BYTE)lpObj->m_AttackType;

  0075b	c6 45 c7 01	 mov	 BYTE PTR _pAttackMsg$4[ebp+3], 1

; 2340 : #endif
; 2341 : 		pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);

  0075f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00762	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00769	c1 e9 08	 shr	 ecx, 8
  0076c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00772	88 4d c8	 mov	 BYTE PTR _pAttackMsg$4[ebp+4], cl

; 2342 : 		pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);

  00775	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00778	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0077f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00785	88 4d c9	 mov	 BYTE PTR _pAttackMsg$4[ebp+5], cl

; 2343 : 		pAttackMsg.Dis     = 0;

  00788	c6 45 ca 00	 mov	 BYTE PTR _pAttackMsg$4[ebp+6], 0

; 2344 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  0078c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0078f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00791	51		 push	 ecx
  00792	8d 55 c4	 lea	 edx, DWORD PTR _pAttackMsg$4[ebp]
  00795	52		 push	 edx
  00796	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  0079b	83 c4 08	 add	 esp, 8

; 2345 : 		return;

  0079e	e9 19 01 00 00	 jmp	 $LN1@gObjMonste
$LN24@gObjMonste:

; 2346 : 	}
; 2347 : #else
; 2348 : 	if( lpObj->Class == 66 || lpObj->Class == 73 || lpObj->Class == 77)
; 2349 : 	{	// 저주받은 왕
; 2350 : 		PMSG_MAGICATTACK pAttackMsg;
; 2351 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2352 : 		pAttackMsg.MagicNumberH = HIBYTE( 1 );
; 2353 : 		pAttackMsg.MagicNumberL = LOBYTE( 1 );
; 2354 : #else
; 2355 : 		pAttackMsg.MagicNumber = 1;//(BYTE)lpObj->m_AttackType;
; 2356 : #endif
; 2357 : 		pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);
; 2358 : 		pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);
; 2359 : 		pAttackMsg.Dis     = 0;
; 2360 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);
; 2361 : 		return;
; 2362 : 	}
; 2363 : #endif
; 2364 : 	
; 2365 : 	if( lpObj->Class == 66 || lpObj->Class == 73 || lpObj->Class == 77)

  007a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007a6	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  007ad	83 f9 42	 cmp	 ecx, 66			; 00000042H
  007b0	74 1e		 je	 SHORT $LN27@gObjMonste
  007b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007b5	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  007bc	83 f9 49	 cmp	 ecx, 73			; 00000049H
  007bf	74 0f		 je	 SHORT $LN27@gObjMonste
  007c1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007c4	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  007cb	83 f9 4d	 cmp	 ecx, 77			; 0000004dH
  007ce	75 48		 jne	 SHORT $LN26@gObjMonste
$LN27@gObjMonste:

; 2366 : 	{	// 저주받은 왕
; 2367 : 		PMSG_MAGICATTACK pAttackMsg;
; 2368 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2369 : 		pAttackMsg.MagicNumberH = HIBYTE( 1 );
; 2370 : 		pAttackMsg.MagicNumberL = LOBYTE( 1 );
; 2371 : #else
; 2372 : 		pAttackMsg.MagicNumber = 1;//(BYTE)lpObj->m_AttackType;

  007d0	c6 45 bf 01	 mov	 BYTE PTR _pAttackMsg$3[ebp+3], 1

; 2373 : #endif
; 2374 : 		pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);

  007d4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007d7	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  007de	c1 e9 08	 shr	 ecx, 8
  007e1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  007e7	88 4d c0	 mov	 BYTE PTR _pAttackMsg$3[ebp+4], cl

; 2375 : 		pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);

  007ea	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007ed	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  007f4	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  007fa	88 4d c1	 mov	 BYTE PTR _pAttackMsg$3[ebp+5], cl

; 2376 : 		pAttackMsg.Dis     = 0;

  007fd	c6 45 c2 00	 mov	 BYTE PTR _pAttackMsg$3[ebp+6], 0

; 2377 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  00801	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00804	8b 08		 mov	 ecx, DWORD PTR [eax]
  00806	51		 push	 ecx
  00807	8d 55 bc	 lea	 edx, DWORD PTR _pAttackMsg$3[ebp]
  0080a	52		 push	 edx
  0080b	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  00810	83 c4 08	 add	 esp, 8

; 2378 : 		return;

  00813	e9 a4 00 00 00	 jmp	 $LN1@gObjMonste
$LN26@gObjMonste:

; 2379 : 	}
; 2380 : 
; 2381 : 	switch(AttackType)

  00818	8b 45 fc	 mov	 eax, DWORD PTR _AttackType$[ebp]
  0081b	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv492[ebp], eax
  00821	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR tv492[ebp], 0
  00828	74 02		 je	 SHORT $LN28@gObjMonste
  0082a	eb 4d		 jmp	 SHORT $LN29@gObjMonste
$LN28@gObjMonste:

; 2382 : 	{
; 2383 : 	case 0 :	// 일반 공격
; 2384 : 		{
; 2385 : 		PMSG_ATTACK pAttackMsg;
; 2386 : #if GAME_VERSION >= G_V_99B
; 2387 : 		pAttackMsg.AttackAction = AT_ATTACK1;

  0082c	c6 45 b9 78	 mov	 BYTE PTR _pAttackMsg$2[ebp+5], 120 ; 00000078H

; 2388 : #else
; 2389 : 		pAttackMsg.AttackAction = AT_ATTACK1-20;
; 2390 : #endif
; 2391 : 		pAttackMsg.DirDis       = lpObj->Dir;

  00830	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00833	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00839	88 4d ba	 mov	 BYTE PTR _pAttackMsg$2[ebp+6], cl

; 2392 : 		pAttackMsg.NumberH		= HIBYTE(lpObj->TargetNumber);

  0083c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0083f	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00846	c1 e9 08	 shr	 ecx, 8
  00849	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0084f	88 4d b7	 mov	 BYTE PTR _pAttackMsg$2[ebp+3], cl

; 2393 : 		pAttackMsg.NumberL		= LOBYTE(lpObj->TargetNumber);

  00852	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00855	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0085c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00862	88 4d b8	 mov	 BYTE PTR _pAttackMsg$2[ebp+4], cl

; 2394 : 		CGAttack(&pAttackMsg, lpObj->m_Index);

  00865	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00868	8b 08		 mov	 ecx, DWORD PTR [eax]
  0086a	51		 push	 ecx
  0086b	8d 55 b4	 lea	 edx, DWORD PTR _pAttackMsg$2[ebp]
  0086e	52		 push	 edx
  0086f	e8 00 00 00 00	 call	 ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ; CGAttack
  00874	83 c4 08	 add	 esp, 8

; 2395 : 		}
; 2396 : 		break;

  00877	eb 43		 jmp	 SHORT $LN1@gObjMonste
$LN29@gObjMonste:

; 2397 : 	default :
; 2398 : 		{
; 2399 : 		PMSG_MAGICATTACK pAttackMsg;
; 2400 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 2401 : 		pAttackMsg.MagicNumberH = HIBYTE( 0 );
; 2402 : 		pAttackMsg.MagicNumberL = LOBYTE( 0 );
; 2403 : #else
; 2404 : 		pAttackMsg.MagicNumber = 0;//(BYTE)lpObj->m_AttackType;

  00879	c6 45 af 00	 mov	 BYTE PTR _pAttackMsg$1[ebp+3], 0

; 2405 : #endif
; 2406 : 		pAttackMsg.NumberH = HIBYTE(lpObj->TargetNumber);

  0087d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00880	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00887	c1 e9 08	 shr	 ecx, 8
  0088a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00890	88 4d b0	 mov	 BYTE PTR _pAttackMsg$1[ebp+4], cl

; 2407 : 		pAttackMsg.NumberL = LOBYTE(lpObj->TargetNumber);

  00893	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00896	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0089d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  008a3	88 4d b1	 mov	 BYTE PTR _pAttackMsg$1[ebp+5], cl

; 2408 : 		pAttackMsg.Dis     = 0;

  008a6	c6 45 b2 00	 mov	 BYTE PTR _pAttackMsg$1[ebp+6], 0

; 2409 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  008aa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  008af	51		 push	 ecx
  008b0	8d 55 ac	 lea	 edx, DWORD PTR _pAttackMsg$1[ebp]
  008b3	52		 push	 edx
  008b4	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  008b9	83 c4 08	 add	 esp, 8
$LN1@gObjMonste:

; 2410 : 		}
; 2411 : 		break;
; 2412 : 	}
; 2413 : }

  008bc	5f		 pop	 edi
  008bd	5e		 pop	 esi
  008be	5b		 pop	 ebx
  008bf	8b e5		 mov	 esp, ebp
  008c1	5d		 pop	 ebp
  008c2	c3		 ret	 0
?gObjMonsterAttack@@YAXPAVOBJECTSTRUCT@@0@Z ENDP	; gObjMonsterAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterTrapAct@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjMonsterTrapAct@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjMonsterTrapAct, COMDAT

; 3093 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3094 : 	if( lpObj->VPCount2 < 1 ) return;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	83 b8 70 0a 00
	00 01		 cmp	 DWORD PTR [eax+2672], 1
  00013	7d 05		 jge	 SHORT $LN2@gObjMonste
  00015	e9 ba 00 00 00	 jmp	 $LN1@gObjMonste
$LN2@gObjMonste:

; 3095 : 
; 3096 : 	if( lpObj->m_AttackRange > 0 )

  0001a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001d	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  00024	85 c9		 test	 ecx, ecx
  00026	7e 56		 jle	 SHORT $LN3@gObjMonste

; 3097 : 	{
; 3098 : 		if( lpObj->Dir == 3 )

  00028	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002b	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  00032	83 f9 03	 cmp	 ecx, 3
  00035	75 1c		 jne	 SHORT $LN5@gObjMonste

; 3099 : 		{
; 3100 : 			gObjTrapAttackEnemySearchX(lpObj, lpObj->m_AttackRange+1);

  00037	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003a	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  00041	83 c1 01	 add	 ecx, 1
  00044	51		 push	 ecx
  00045	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ?gObjTrapAttackEnemySearchX@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchX
  0004e	83 c4 08	 add	 esp, 8

; 3101 : 		}

  00051	eb 29		 jmp	 SHORT $LN6@gObjMonste
$LN5@gObjMonste:

; 3102 : 		else if( lpObj->Dir == 1 )

  00053	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  0005d	83 f9 01	 cmp	 ecx, 1
  00060	75 1a		 jne	 SHORT $LN6@gObjMonste

; 3103 : 		{
; 3104 : 			gObjTrapAttackEnemySearchY(lpObj, lpObj->m_AttackRange+1);

  00062	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00065	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  0006c	83 c1 01	 add	 ecx, 1
  0006f	51		 push	 ecx
  00070	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 ?gObjTrapAttackEnemySearchY@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchY
  00079	83 c4 08	 add	 esp, 8
$LN6@gObjMonste:

; 3105 : 		}
; 3106 : #ifdef ADD_KANTURU_CONDITION_20060725
; 3107 : 		else if( lpObj->Dir == 8 )
; 3108 : 		{
; 3109 : 			// 트랩 몬스터 (인덱스가 100~110상의 몬스터)의 m_AttackRange가 0이상이고 Dir이 8일 경우 범위공격 트랩
; 3110 : 			// 트랩 공격 범위에 유저를 찾는다.
; 3111 : 			gObjTrapAttackEnemySearchRange( lpObj, lpObj->m_AttackRange );
; 3112 : 		}
; 3113 : #endif
; 3114 : 	}

  0007c	eb 0c		 jmp	 SHORT $LN4@gObjMonste
$LN3@gObjMonste:

; 3115 : 	else gObjTrapAttackEnemySearch(lpObj);

  0007e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?gObjTrapAttackEnemySearch@@YAXPAVOBJECTSTRUCT@@@Z ; gObjTrapAttackEnemySearch
  00087	83 c4 04	 add	 esp, 4
$LN4@gObjMonste:

; 3116 : 
; 3117 : 	if( lpObj->TargetNumber >= 0 ) {

  0008a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008d	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00094	85 c9		 test	 ecx, ecx
  00096	7c 29		 jl	 SHORT $LN8@gObjMonste

; 3118 : 		lpObj->m_ActState.Attack = 1;

  00098	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  000a1	83 c9 02	 or	 ecx, 2
  000a4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a7	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 3119 : 		lpObj->NextActionTime = lpObj->m_AttackSpeed;	// 공격후는 시간을 좀더 지연시킴

  000ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b3	8b 91 e0 02 00
	00		 mov	 edx, DWORD PTR [ecx+736]
  000b9	89 90 18 02 00
	00		 mov	 DWORD PTR [eax+536], edx

; 3120 : 	}

  000bf	eb 13		 jmp	 SHORT $LN1@gObjMonste
$LN8@gObjMonste:

; 3121 : 	else lpObj->NextActionTime = lpObj->m_MoveSpeed;	// 공격을 안할때는 빨리 체킹하기 위해.. movespeed 를 사용..

  000c1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c4	0f bf 88 f4 02
	00 00		 movsx	 ecx, WORD PTR [eax+756]
  000cb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ce	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx
$LN1@gObjMonste:

; 3122 : }

  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
?gObjMonsterTrapAct@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjMonsterTrapAct
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterBaseAct@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv287 = -120						; size = 4
tv288 = -116						; size = 4
_tdir$1 = -48						; size = 4
_attr$2 = -41						; size = 1
_map$3 = -40						; size = 4
_tuser$4 = -36						; size = 4
_attackRange$5 = -32					; size = 4
_dis$6 = -28						; size = 4
_iRAND_CHANGE_TARGET$7 = -24				; size = 4
_lpRecallObj$8 = -20					; size = 4
_ty$9 = -16						; size = 4
_tx$10 = -12						; size = 4
_actcode1$11 = -8					; size = 4
_lpTargetObj$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterBaseAct@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjMonsterBaseAct, COMDAT

; 2667 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2668 : 	LPOBJECTSTRUCT lpTargetObj=NULL;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lpTargetObj$[ebp], 0

; 2669 : 
; 2670 : 	if( lpObj->TargetNumber >= 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00013	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0001a	85 c9		 test	 ecx, ecx
  0001c	7c 1b		 jl	 SHORT $LN2@gObjMonste

; 2671 : 		lpTargetObj = (LPOBJECTSTRUCT)&gObj[lpObj->TargetNumber];

  0001e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00021	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00028	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  0002e	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	89 55 fc	 mov	 DWORD PTR _lpTargetObj$[ebp], edx
  00037	eb 18		 jmp	 SHORT $LN3@gObjMonste
$LN2@gObjMonste:

; 2672 : 	else lpObj->m_ActState.Emotion = 0; 

  00039	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003c	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00042	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00048	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0004b	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN3@gObjMonste:

; 2673 : 
; 2674 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 슬립상태면 공격을 못함
; 2675 : 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SLEEP ) == true )
; 2676 : 		return;
; 2677 : #endif
; 2678 : 	
; 2679 : 	if( lpObj->m_ActState.Emotion == 0 )	// 보통..

  00051	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00054	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0005a	c1 e9 04	 shr	 ecx, 4
  0005d	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00060	0f 85 07 03 00
	00		 jne	 $LN4@gObjMonste

; 2680 : 	{
; 2681 : 		if( lpObj->m_Attribute != 0 )	//

  00066	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00069	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  00070	85 c9		 test	 ecx, ecx
  00072	0f 84 f0 02 00
	00		 je	 $LN6@gObjMonste

; 2682 : 		{
; 2683 : 			if( lpObj->m_ActState.Attack )	// 이전에 공격중 이었다면..

  00078	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007b	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00081	d1 e9		 shr	 ecx, 1
  00083	83 e1 01	 and	 ecx, 1
  00086	74 2f		 je	 SHORT $LN7@gObjMonste

; 2684 : 			{
; 2685 : 				lpObj->m_ActState.Attack = 0;

  00088	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008b	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00091	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00094	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00097	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2686 : 				lpObj->TargetNumber = -1;

  0009d	83 c8 ff	 or	 eax, -1
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a3	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 2687 : 				lpObj->NextActionTime = 500;

  000aa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ad	c7 80 18 02 00
	00 f4 01 00 00	 mov	 DWORD PTR [eax+536], 500 ; 000001f4H
$LN7@gObjMonste:

; 2688 : 				//if( lpObj->m_Attribute == 100 )	LogAdd("공격중 이었다면 잠깐 쉰다.");
; 2689 : 			}
; 2690 : 			
; 2691 : 			int actcode1 = (rand()%2);

  000b7	e8 00 00 00 00	 call	 _rand
  000bc	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000c1	79 05		 jns	 SHORT $LN67@gObjMonste
  000c3	48		 dec	 eax
  000c4	83 c8 fe	 or	 eax, -2			; fffffffeH
  000c7	40		 inc	 eax
$LN67@gObjMonste:
  000c8	89 45 f8	 mov	 DWORD PTR _actcode1$11[ebp], eax

; 2692 : 
; 2693 : 			if( lpObj->m_Attribute == 100 )

  000cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ce	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  000d5	83 f9 64	 cmp	 ecx, 100		; 00000064H
  000d8	75 07		 jne	 SHORT $LN8@gObjMonste

; 2694 : 			{
; 2695 : 				actcode1 = 1;

  000da	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _actcode1$11[ebp], 1
$LN8@gObjMonste:

; 2696 : 			}
; 2697 : 
; 2698 : 			// 잠깐 쉬고.. 
; 2699 : 			if( actcode1 == 0 )

  000e1	83 7d f8 00	 cmp	 DWORD PTR _actcode1$11[ebp], 0
  000e5	75 27		 jne	 SHORT $LN9@gObjMonste

; 2700 : 			{
; 2701 : 				//if( lpObj->m_Attribute == 100 )	LogAdd("잠깐 쉰다.");
; 2702 : 				lpObj->m_ActState.Rest = 1;

  000e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ea	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  000f0	83 c9 01	 or	 ecx, 1
  000f3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f6	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2703 : 				lpObj->NextActionTime = 500;

  000fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ff	c7 80 18 02 00
	00 f4 01 00 00	 mov	 DWORD PTR [eax+536], 500 ; 000001f4H

; 2704 : 				//lpObj->NextActionTime = 1;
; 2705 : 			}

  00109	e9 0f 01 00 00	 jmp	 $LN10@gObjMonste
$LN9@gObjMonste:

; 2706 : 			// 다른곳으로 이동 해 본다.
; 2707 : 
; 2708 : #ifdef ADD_NEW_SKILL_FOR_CASTLE_02_20050531
; 2709 : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2710 : 			else if( lpObj->m_MoveRange > 0 &&
; 2711 : 				( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STONE ) == false ) &&
; 2712 : 				( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STUN ) == false ) 
; 2713 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 2714 : 				&& ( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SLEEP ) == false ) 
; 2715 : #endif
; 2716 : 			       )
; 2717 : 	#else
; 2718 : 			else if( lpObj->m_MoveRange>0 && lpObj->m_SkillHarden == 0 && lpObj->m_iSkillStunTime == 0 )
; 2719 : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2720 : #else
; 2721 : 	#ifdef NEW_FORSKYLAND2
; 2722 : 			else if( lpObj->m_MoveRange>0 && lpObj->m_SkillHarden == 0)

  0010e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00111	0f bf 88 f6 02
	00 00		 movsx	 ecx, WORD PTR [eax+758]
  00118	85 c9		 test	 ecx, ecx
  0011a	0f 8e fd 00 00
	00		 jle	 $LN10@gObjMonste
  00120	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00123	83 b8 fc 19 00
	00 00		 cmp	 DWORD PTR [eax+6652], 0
  0012a	0f 85 ed 00 00
	00		 jne	 $LN10@gObjMonste

; 2723 : 	#else
; 2724 : 			else if( lpObj->m_MoveRange>0) 
; 2725 : 	#endif		
; 2726 : 
; 2727 : #endif
; 2728 : 			{
; 2729 : 				if( lpObj->m_Attribute != 100 )

  00130	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00133	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  0013a	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0013d	74 11		 je	 SHORT $LN12@gObjMonste

; 2730 : 				{
; 2731 : 					gObjMonsterMoveAction(lpObj);

  0013f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 ?gObjMonsterMoveAction@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMonsterMoveAction
  00148	83 c4 04	 add	 esp, 4

; 2732 : 				} 

  0014b	e9 cd 00 00 00	 jmp	 $LN10@gObjMonste
$LN12@gObjMonste:

; 2733 : 				else
; 2734 : 				{
; 2735 : 					int tx=0, ty=0;

  00150	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _tx$10[ebp], 0
  00157	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ty$9[ebp], 0

; 2736 : 					if( lpObj->m_RecallMon >= 0 )

  0015e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00161	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00168	0f 8c af 00 00
	00		 jl	 $LN10@gObjMonste

; 2737 : 					{
; 2738 : 						LPOBJECTSTRUCT lpRecallObj;						
; 2739 : 						if( gObj[lpObj->m_RecallMon].Connected > 2 )

  0016e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00171	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  0017b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00181	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  00186	0f 8e 91 00 00
	00		 jle	 $LN10@gObjMonste

; 2740 : 						{
; 2741 : 							lpRecallObj = &gObj[lpObj->m_RecallMon];

  0018c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018f	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  00199	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019f	89 4d ec	 mov	 DWORD PTR _lpRecallObj$8[ebp], ecx

; 2742 : 							if( !lpRecallObj->m_Rest )

  001a2	8b 45 ec	 mov	 eax, DWORD PTR _lpRecallObj$8[ebp]
  001a5	0f b6 88 bd 01
	00 00		 movzx	 ecx, BYTE PTR [eax+445]
  001ac	85 c9		 test	 ecx, ecx
  001ae	75 6d		 jne	 SHORT $LN10@gObjMonste

; 2743 : 							{
; 2744 : 								if( gObjGetTargetPos(lpObj, lpRecallObj->X, lpRecallObj->Y, tx, ty)==TRUE)

  001b0	8d 45 f0	 lea	 eax, DWORD PTR _ty$9[ebp]
  001b3	50		 push	 eax
  001b4	8d 4d f4	 lea	 ecx, DWORD PTR _tx$10[ebp]
  001b7	51		 push	 ecx
  001b8	8b 55 ec	 mov	 edx, DWORD PTR _lpRecallObj$8[ebp]
  001bb	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  001c2	50		 push	 eax
  001c3	8b 4d ec	 mov	 ecx, DWORD PTR _lpRecallObj$8[ebp]
  001c6	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  001cd	52		 push	 edx
  001ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 ?gObjGetTargetPos@@YAHPAVOBJECTSTRUCT@@HHAAH1@Z ; gObjGetTargetPos
  001d7	83 c4 14	 add	 esp, 20			; 00000014H
  001da	83 f8 01	 cmp	 eax, 1
  001dd	75 3e		 jne	 SHORT $LN10@gObjMonste

; 2745 : 								{
; 2746 : 									lpObj->MTX = tx;

  001df	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e2	66 8b 4d f4	 mov	 cx, WORD PTR _tx$10[ebp]
  001e6	66 89 88 24 01
	00 00		 mov	 WORD PTR [eax+292], cx

; 2747 : 									lpObj->MTY = ty;

  001ed	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f0	66 8b 4d f0	 mov	 cx, WORD PTR _ty$9[ebp]
  001f4	66 89 88 26 01
	00 00		 mov	 WORD PTR [eax+294], cx

; 2748 : 									lpObj->m_ActState.Move = 1;

  001fb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fe	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00204	83 c9 04	 or	 ecx, 4
  00207	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0020a	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2749 : 									lpObj->NextActionTime = 1000;

  00210	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00213	c7 80 18 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+536], 1000 ; 000003e8H
$LN10@gObjMonste:

; 2750 : 									//if( lpObj->m_Attribute == 100 )	LogAdd("주인 곁으로 이동해본다.");
; 2751 : 									//lpObj->NextActionTime = 0;
; 2752 : 								}
; 2753 : 							}
; 2754 : 						}
; 2755 : 						//gObjMonsterMoveRegen(gObj[lpObj->m_RecallMon].X, gObj[lpObj->m_RecallMon].Y, lpObj);
; 2756 : 					}
; 2757 : 				}
; 2758 : 			}
; 2759 : 
; 2760 : 			// 적을 찾아다닌다.
; 2761 : 			if( lpObj->Class == 249 || lpObj->Class == 247 ) // 경비병일땐 PK 찾는다.

  0021d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00220	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00227	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  0022d	74 16		 je	 SHORT $LN20@gObjMonste
  0022f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00232	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00239	81 f9 f7 00 00
	00		 cmp	 ecx, 247		; 000000f7H
  0023f	0f 85 9b 00 00
	00		 jne	 $LN18@gObjMonste
$LN20@gObjMonste:

; 2762 : 			{
; 2763 : 				// 수호길드 모집안내.. 행사 안내 
; 2764 : 				if( gEvent1 )

  00245	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gEvent1@@3HA, 0 ; gEvent1
  0024c	74 3a		 je	 SHORT $LN21@gObjMonste

; 2765 : 				{
; 2766 : 					if( (rand()%30) == 0 )

  0024e	e8 00 00 00 00	 call	 _rand
  00253	99		 cdq
  00254	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00259	f7 f9		 idiv	 ecx
  0025b	85 d2		 test	 edx, edx
  0025d	75 29		 jne	 SHORT $LN21@gObjMonste

; 2767 : 					{
; 2768 : 						if( lpObj->m_PK_Count == 0 )

  0025f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00262	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  00269	85 c9		 test	 ecx, ecx
  0026b	75 1b		 jne	 SHORT $LN21@gObjMonste

; 2769 : 						{
; 2770 : 							ChatSend(lpObj, g_GlobalConfig.m_szGuardMessage);

  0026d	68 fc 02 00 00	 push	 OFFSET ?g_GlobalConfig@@3VCGlobalConfig@@A+764
  00272	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00275	50		 push	 eax
  00276	e8 00 00 00 00	 call	 ?ChatSend@@YAXPAVOBJECTSTRUCT@@PAD@Z ; ChatSend
  0027b	83 c4 08	 add	 esp, 8

; 2771 : 							lpObj->m_PK_Count = 0;

  0027e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00281	c6 80 fc 00 00
	00 00		 mov	 BYTE PTR [eax+252], 0
$LN21@gObjMonste:

; 2772 : 						}
; 2773 : 					}
; 2774 : 				}
; 2775 : 
; 2776 : 				lpObj->TargetNumber = gObjGuardSearchEnemy(lpObj);

  00288	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 ?gObjGuardSearchEnemy@@YAHPAVOBJECTSTRUCT@@@Z ; gObjGuardSearchEnemy
  00291	83 c4 04	 add	 esp, 4
  00294	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00297	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 2777 : 				
; 2778 : 				if( lpObj->TargetNumber >= 0 )

  0029e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a1	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  002a8	85 c9		 test	 ecx, ecx
  002aa	7c 32		 jl	 SHORT $LN24@gObjMonste

; 2779 : 				{
; 2780 : 					if( gObj[lpObj->TargetNumber].Class >= 248 )

  002ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002af	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  002b6	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  002bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c1	0f b7 8c 10 9c
	00 00 00	 movzx	 ecx, WORD PTR [eax+edx+156]
  002c9	81 f9 f8 00 00
	00		 cmp	 ecx, 248		; 000000f8H
  002cf	7c 0d		 jl	 SHORT $LN24@gObjMonste

; 2781 : 					{
; 2782 : 						lpObj->TargetNumber = -1;

  002d1	83 c8 ff	 or	 eax, -1
  002d4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002d7	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax
$LN24@gObjMonste:

; 2783 : 					}
; 2784 : 				}
; 2785 : 			}

  002de	eb 41		 jmp	 SHORT $LN19@gObjMonste
$LN18@gObjMonste:

; 2786 : 			else 
; 2787 : 			{
; 2788 : 				if( lpObj->m_Attribute == MON_ATTR_100 )

  002e0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e3	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  002ea	83 f9 64	 cmp	 ecx, 100		; 00000064H
  002ed	75 1a		 jne	 SHORT $LN26@gObjMonste

; 2789 : 				{
; 2790 : 					//lpObj->TargetNumber = gObjCallMonsterSetEnemy(lpObj);
; 2791 : 					//if( lpObj->TargetNumber == -1 )
; 2792 : 					//{
; 2793 : 						lpObj->TargetNumber = gObjMonsterSearchEnemy(lpObj, OBJTYPE_MONSTER);

  002ef	6a 02		 push	 2
  002f1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f4	50		 push	 eax
  002f5	e8 00 00 00 00	 call	 ?gObjMonsterSearchEnemy@@YAHPAVOBJECTSTRUCT@@E@Z ; gObjMonsterSearchEnemy
  002fa	83 c4 08	 add	 esp, 8
  002fd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00300	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 2794 : 						if( lpObj->m_Attribute == 100 )	
; 2795 : 						{
; 2796 : 							//if( lpObj->TargetNumber>=0) LogAdd("적을 찾아 이동한다.");
; 2797 : 						}
; 2798 : 
; 2799 : 					//}
; 2800 : 					//else LogAdd("주인 공격 몬스터 세팅 %d", lpObj->TargetNumber);
; 2801 : 
; 2802 : 				}

  00307	eb 18		 jmp	 SHORT $LN19@gObjMonste
$LN26@gObjMonste:

; 2803 : 				else lpObj->TargetNumber = gObjMonsterSearchEnemy(lpObj, OBJTYPE_CHARACTER);

  00309	6a 01		 push	 1
  0030b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030e	50		 push	 eax
  0030f	e8 00 00 00 00	 call	 ?gObjMonsterSearchEnemy@@YAHPAVOBJECTSTRUCT@@E@Z ; gObjMonsterSearchEnemy
  00314	83 c4 08	 add	 esp, 8
  00317	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0031a	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax
$LN19@gObjMonste:

; 2804 : 			}
; 2805 : 			
; 2806 : 			// 적이 발견되면 열받아서 적을 향해 돌격~~
; 2807 : 			if( lpObj->TargetNumber >= 0 )

  00321	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00324	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0032b	85 c9		 test	 ecx, ecx
  0032d	7c 39		 jl	 SHORT $LN6@gObjMonste

; 2808 : 			{
; 2809 : 				lpObj->m_ActState.EmotionCount = 30;

  0032f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00332	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00338	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  0033e	81 c9 00 1e 00
	00		 or	 ecx, 7680		; 00001e00H
  00344	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00347	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2810 : 				lpObj->m_ActState.Emotion = 1;

  0034d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00350	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00356	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  0035c	83 c9 10	 or	 ecx, 16			; 00000010H
  0035f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00362	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN6@gObjMonste:

; 2811 : 				//if( lpObj->m_Attribute == 100 )	LogAdd("적을 향해 돌격");
; 2812 : 			}
; 2813 : 		}
; 2814 : 	}

  00368	e9 e2 06 00 00	 jmp	 $LN1@gObjMonste
$LN4@gObjMonste:

; 2815 : 	else if( lpObj->m_ActState.Emotion == 1 )	// 열받음..

  0036d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00370	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00376	c1 e9 04	 shr	 ecx, 4
  00379	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0037c	83 f9 01	 cmp	 ecx, 1
  0037f	0f 85 e2 04 00
	00		 jne	 $LN30@gObjMonste

; 2816 : 	{		
; 2817 : 		if( lpObj->m_ActState.EmotionCount > 0 ) lpObj->m_ActState.EmotionCount--;

  00385	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00388	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0038e	c1 e9 08	 shr	 ecx, 8
  00391	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00397	76 39		 jbe	 SHORT $LN32@gObjMonste
  00399	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039c	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  003a2	c1 e9 08	 shr	 ecx, 8
  003a5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003ab	83 e9 01	 sub	 ecx, 1
  003ae	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003b4	c1 e1 08	 shl	 ecx, 8
  003b7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003ba	8b 82 b0 01 00
	00		 mov	 eax, DWORD PTR [edx+432]
  003c0	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  003c5	0b c1		 or	 eax, ecx
  003c7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003ca	89 81 b0 01 00
	00		 mov	 DWORD PTR [ecx+432], eax
  003d0	eb 18		 jmp	 SHORT $LN33@gObjMonste
$LN32@gObjMonste:

; 2818 : 		else {
; 2819 : 			lpObj->m_ActState.Emotion = 0;

  003d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d5	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  003db	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  003e1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003e4	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN33@gObjMonste:

; 2820 : 		}
; 2821 : 		if( lpObj->TargetNumber >= 0 && lpObj->PathStartEnd == 0 )	// 공격 대상이 있으면..

  003ea	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ed	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  003f4	85 c9		 test	 ecx, ecx
  003f6	0f 8c 66 04 00
	00		 jl	 $LN35@gObjMonste
  003fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ff	0f be 88 30 01
	00 00		 movsx	 ecx, BYTE PTR [eax+304]
  00406	85 c9		 test	 ecx, ecx
  00408	0f 85 54 04 00
	00		 jne	 $LN35@gObjMonste

; 2822 : 		{
; 2823 : #ifdef FOR_BLOODCASTLE
; 2824 : 			if (CHECK_BLOODCASTLE(lpObj->MapNumber)) {				// 현재는 블러드캐슬만 적용됨

  0040e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00411	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00418	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0041b	7d 09		 jge	 SHORT $LN65@gObjMonste
  0041d	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv288[ebp], 0
  00424	eb 25		 jmp	 SHORT $LN66@gObjMonste
$LN65@gObjMonste:
  00426	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00429	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00430	83 f8 11	 cmp	 eax, 17			; 00000011H
  00433	7e 09		 jle	 SHORT $LN63@gObjMonste
  00435	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv287[ebp], 0
  0043c	eb 07		 jmp	 SHORT $LN64@gObjMonste
$LN63@gObjMonste:
  0043e	c7 45 88 01 00
	00 00		 mov	 DWORD PTR tv287[ebp], 1
$LN64@gObjMonste:
  00445	8b 4d 88	 mov	 ecx, DWORD PTR tv287[ebp]
  00448	89 4d 8c	 mov	 DWORD PTR tv288[ebp], ecx
$LN66@gObjMonste:
  0044b	83 7d 8c 00	 cmp	 DWORD PTR tv288[ebp], 0
  0044f	0f 84 cc 00 00
	00		 je	 $LN36@gObjMonste

; 2825 : 				INT iRAND_CHANGE_TARGET = rand()%10;

  00455	e8 00 00 00 00	 call	 _rand
  0045a	99		 cdq
  0045b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00460	f7 f9		 idiv	 ecx
  00462	89 55 e8	 mov	 DWORD PTR _iRAND_CHANGE_TARGET$7[ebp], edx

; 2826 : 				if (iRAND_CHANGE_TARGET == 3) {

  00465	83 7d e8 03	 cmp	 DWORD PTR _iRAND_CHANGE_TARGET$7[ebp], 3
  00469	75 0d		 jne	 SHORT $LN37@gObjMonste

; 2827 : 					lpObj->LastAttackerID = -1;

  0046b	83 c8 ff	 or	 eax, -1
  0046e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00471	66 89 81 b2 02
	00 00		 mov	 WORD PTR [ecx+690], ax
$LN37@gObjMonste:

; 2828 : 				}
; 2829 : 				if (iRAND_CHANGE_TARGET == 1) {

  00478	83 7d e8 01	 cmp	 DWORD PTR _iRAND_CHANGE_TARGET$7[ebp], 1
  0047c	0f 85 9f 00 00
	00		 jne	 $LN36@gObjMonste

; 2830 : 					if ((lpObj->LastAttackerID != -1) && (lpObj->LastAttackerID != lpObj->TargetNumber)) {

  00482	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00485	0f bf 88 b2 02
	00 00		 movsx	 ecx, WORD PTR [eax+690]
  0048c	83 f9 ff	 cmp	 ecx, -1
  0048f	0f 84 8c 00 00
	00		 je	 $LN36@gObjMonste
  00495	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00498	0f bf 88 b2 02
	00 00		 movsx	 ecx, WORD PTR [eax+690]
  0049f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004a2	0f bf 82 ac 02
	00 00		 movsx	 eax, WORD PTR [edx+684]
  004a9	3b c8		 cmp	 ecx, eax
  004ab	74 74		 je	 SHORT $LN36@gObjMonste

; 2831 : 						// 나를 마지막에 공격한 사람이 내가 목표로한 사람과 다르다.
; 2832 : 						if ((gObj[lpObj->LastAttackerID].Connected > 2) && (lpObj->MapNumber == gObj[lpObj->LastAttackerID].MapNumber)) {

  004ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004b0	0f bf 88 b2 02
	00 00		 movsx	 ecx, WORD PTR [eax+690]
  004b7	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  004bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004c2	83 7c 10 04 02	 cmp	 DWORD PTR [eax+edx+4], 2
  004c7	7e 58		 jle	 SHORT $LN36@gObjMonste
  004c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004cc	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  004d3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004d6	0f bf 82 b2 02
	00 00		 movsx	 eax, WORD PTR [edx+690]
  004dd	69 d0 a0 1b 00
	00		 imul	 edx, eax, 7072
  004e3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004e8	0f b6 94 10 09
	01 00 00	 movzx	 edx, BYTE PTR [eax+edx+265]
  004f0	3b ca		 cmp	 ecx, edx
  004f2	75 2d		 jne	 SHORT $LN36@gObjMonste

; 2833 : 							// 나와 같은 맵상에 접속해있다면 공격대상을 바꾼다.
; 2834 : 							lpObj->TargetNumber = lpObj->LastAttackerID;

  004f4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004fa	66 8b 91 b2 02
	00 00		 mov	 dx, WORD PTR [ecx+690]
  00501	66 89 90 ac 02
	00 00		 mov	 WORD PTR [eax+684], dx

; 2835 : 							lpTargetObj = &gObj[lpObj->LastAttackerID];

  00508	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0050b	0f bf 88 b2 02
	00 00		 movsx	 ecx, WORD PTR [eax+690]
  00512	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00518	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0051e	89 55 fc	 mov	 DWORD PTR _lpTargetObj$[ebp], edx
$LN36@gObjMonste:

; 2836 : 						}
; 2837 : 					}
; 2838 : 				}
; 2839 : 			}
; 2840 : #endif
; 2841 : 			int dis = gObjCalDistance(lpObj, lpTargetObj);

  00521	8b 45 fc	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00524	50		 push	 eax
  00525	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00528	51		 push	 ecx
  00529	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0052e	83 c4 08	 add	 esp, 8
  00531	89 45 e4	 mov	 DWORD PTR _dis$6[ebp], eax

; 2842 : 			
; 2843 : 			int attackRange;
; 2844 : 			if( lpObj->m_AttackType >= 100 )

  00534	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00537	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  0053e	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00541	7c 12		 jl	 SHORT $LN41@gObjMonste

; 2845 : 			{
; 2846 : 				attackRange = lpObj->m_AttackRange+2;

  00543	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00546	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  0054d	83 c1 02	 add	 ecx, 2
  00550	89 4d e0	 mov	 DWORD PTR _attackRange$5[ebp], ecx

; 2847 : 			}

  00553	eb 0d		 jmp	 SHORT $LN42@gObjMonste
$LN41@gObjMonste:

; 2848 : 			else attackRange = lpObj->m_AttackRange;

  00555	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00558	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  0055f	89 4d e0	 mov	 DWORD PTR _attackRange$5[ebp], ecx
$LN42@gObjMonste:

; 2849 : 
; 2850 : 			//if( lpObj->m_Attribute == 100 )	LogAdd("공격대상 체크1 거리 : %d", dis);
; 2851 : 
; 2852 : 			if(  dis <= attackRange )

  00562	8b 45 e4	 mov	 eax, DWORD PTR _dis$6[ebp]
  00565	3b 45 e0	 cmp	 eax, DWORD PTR _attackRange$5[ebp]
  00568	0f 8f dd 01 00
	00		 jg	 $LN43@gObjMonste

; 2853 : 			{			//lpObj->m_ActState.Attack = 1;
; 2854 : 				int tuser = lpObj->TargetNumber;

  0056e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00571	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00578	89 4d dc	 mov	 DWORD PTR _tuser$4[ebp], ecx

; 2855 : 				int map = gObj[tuser].MapNumber;

  0057b	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _tuser$4[ebp], 7072
  00582	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00588	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00590	89 55 d8	 mov	 DWORD PTR _map$3[ebp], edx

; 2856 : 				BYTE attr ;
; 2857 : 				if( MapC[map].CheckWall(lpObj->X, lpObj->Y, gObj[tuser].X, gObj[tuser].Y) == TRUE )

  00593	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _tuser$4[ebp], 7072
  0059a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a0	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  005a8	52		 push	 edx
  005a9	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _tuser$4[ebp], 7072
  005b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005b6	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  005be	52		 push	 edx
  005bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005c2	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  005c9	51		 push	 ecx
  005ca	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005cd	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  005d4	50		 push	 eax
  005d5	69 4d d8 8c 04
	05 00		 imul	 ecx, DWORD PTR _map$3[ebp], 328844
  005dc	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  005e2	e8 00 00 00 00	 call	 ?CheckWall@MapClass@@QAEHHHHH@Z ; MapClass::CheckWall
  005e7	83 f8 01	 cmp	 eax, 1
  005ea	0f 85 fa 00 00
	00		 jne	 $LN45@gObjMonste

; 2858 : 				{
; 2859 : 					attr = MapC[map].GetAttr(gObj[tuser].X, gObj[tuser].Y);

  005f0	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _tuser$4[ebp], 7072
  005f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005fd	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  00605	52		 push	 edx
  00606	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _tuser$4[ebp], 7072
  0060d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00613	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  0061b	52		 push	 edx
  0061c	69 4d d8 8c 04
	05 00		 imul	 ecx, DWORD PTR _map$3[ebp], 328844
  00623	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00629	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0062e	88 45 d7	 mov	 BYTE PTR _attr$2[ebp], al

; 2860 : 					if( (attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE)// 안전 속성이 아니면

  00631	0f b6 45 d7	 movzx	 eax, BYTE PTR _attr$2[ebp]
  00635	83 e0 01	 and	 eax, 1
  00638	75 17		 jne	 SHORT $LN47@gObjMonste

; 2861 : 					{
; 2862 : 						lpObj->m_ActState.Attack = 1;

  0063a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0063d	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00643	83 c9 02	 or	 ecx, 2
  00646	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00649	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2863 : 					}

  0064f	eb 46		 jmp	 SHORT $LN48@gObjMonste
$LN47@gObjMonste:

; 2864 : 					else {	// 안전 속성에 있다면.
; 2865 : 						lpObj->TargetNumber = -1;

  00651	83 c8 ff	 or	 eax, -1
  00654	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00657	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 2866 : 						lpObj->m_ActState.EmotionCount = 30;

  0065e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00661	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00667	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  0066d	81 c9 00 1e 00
	00		 or	 ecx, 7680		; 00001e00H
  00673	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00676	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2867 : 						lpObj->m_ActState.Emotion = 1;					

  0067c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0067f	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00685	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  0068b	83 c9 10	 or	 ecx, 16			; 00000010H
  0068e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00691	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN48@gObjMonste:

; 2868 : 					}
; 2869 : 					lpObj->Dir = GetPathPacketDirPos( lpTargetObj->X-lpObj->X, lpTargetObj->Y-lpObj->Y);

  00697	8b 45 fc	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0069a	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  006a1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006a4	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  006ab	2b c8		 sub	 ecx, eax
  006ad	51		 push	 ecx
  006ae	8b 4d fc	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  006b1	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  006b8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006bb	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  006c2	2b d1		 sub	 edx, ecx
  006c4	52		 push	 edx
  006c5	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  006ca	83 c4 08	 add	 esp, 8
  006cd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006d0	88 82 08 01 00
	00		 mov	 BYTE PTR [edx+264], al

; 2870 : 					lpObj->NextActionTime = lpObj->m_AttackSpeed;

  006d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006d9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006dc	8b 91 e0 02 00
	00		 mov	 edx, DWORD PTR [ecx+736]
  006e2	89 90 18 02 00
	00		 mov	 DWORD PTR [eax+536], edx

; 2871 : 					if( lpObj->m_Attribute == 100 )	{
; 2872 : 						//LogAdd("근처로 가서 공격한다. 다음 액선 시간 %d",lpObj->NextActionTime);
; 2873 : 					}
; 2874 : 				}

  006e8	eb 5c		 jmp	 SHORT $LN46@gObjMonste
$LN45@gObjMonste:

; 2875 : #ifdef MODIFY_0708_BUFFIX_20070820	// 쿤둔일 경우 공격 대상이 벽뒤에 있으면 이동
; 2876 : #ifdef MODIFY_MONSTER_ATTACK_BUGFIX_20080902	// 모든 몬스터에 적용
; 2877 : 				else
; 2878 : #else	// MODIFY_MONSTER_ATTACK_BUGFIX_20080902
; 2879 : 				else if(lpObj->Class == 275)
; 2880 : #endif	// MODIFY_MONSTER_ATTACK_BUGFIX_20080902
; 2881 : 				{
; 2882 : 					lpObj->TargetNumber			= -1;

  006ea	83 c8 ff	 or	 eax, -1
  006ed	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006f0	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 2883 : 					lpObj->m_ActState.Attack	= 0;

  006f7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006fa	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00700	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00703	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00706	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2884 : 					lpObj->NextActionTime		= 500;

  0070c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0070f	c7 80 18 02 00
	00 f4 01 00 00	 mov	 DWORD PTR [eax+536], 500 ; 000001f4H

; 2885 : 					lpObj->m_ActState.Emotion	= 0;

  00719	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071c	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00722	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00728	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0072b	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2886 : 					lpObj->m_ActState.Move		= 1;

  00731	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00734	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0073a	83 c9 04	 or	 ecx, 4
  0073d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00740	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN46@gObjMonste:

; 2887 : 				}
; 2888 : #endif				
; 2889 : 			}

  00746	e9 17 01 00 00	 jmp	 $LN35@gObjMonste
$LN43@gObjMonste:

; 2890 : 			else 
; 2891 : 			{
; 2892 : 				if( gObjMonsterGetTargetPos(lpObj) == TRUE )

  0074b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0074e	50		 push	 eax
  0074f	e8 00 00 00 00	 call	 ?gObjMonsterGetTargetPos@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterGetTargetPos
  00754	83 c4 04	 add	 esp, 4
  00757	83 f8 01	 cmp	 eax, 1
  0075a	0f 85 f6 00 00
	00		 jne	 $LN50@gObjMonste

; 2893 : 				{
; 2894 : 					if( MapC[lpObj->MapNumber].CheckWall(lpObj->X, lpObj->Y, lpObj->MTX, lpObj->MTY) == TRUE )

  00760	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00763	0f bf 88 26 01
	00 00		 movsx	 ecx, WORD PTR [eax+294]
  0076a	51		 push	 ecx
  0076b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0076e	0f bf 82 24 01
	00 00		 movsx	 eax, WORD PTR [edx+292]
  00775	50		 push	 eax
  00776	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00779	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00780	52		 push	 edx
  00781	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00784	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0078b	51		 push	 ecx
  0078c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0078f	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00796	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  0079c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  007a2	e8 00 00 00 00	 call	 ?CheckWall@MapClass@@QAEHHHHH@Z ; MapClass::CheckWall
  007a7	83 f8 01	 cmp	 eax, 1
  007aa	75 63		 jne	 SHORT $LN52@gObjMonste

; 2895 : 					{
; 2896 : 						lpObj->m_ActState.Move = 1;

  007ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007af	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  007b5	83 c9 04	 or	 ecx, 4
  007b8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007bb	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2897 : 						//lpObj->m_ActState.Attack = 1;
; 2898 : 						lpObj->NextActionTime = 400;

  007c1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007c4	c7 80 18 02 00
	00 90 01 00 00	 mov	 DWORD PTR [eax+536], 400 ; 00000190H

; 2899 : 						//lpObj->NextActionTime = 0;
; 2900 : 						lpObj->Dir = GetPathPacketDirPos( lpTargetObj->X-lpObj->X, lpTargetObj->Y-lpObj->Y);

  007ce	8b 45 fc	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  007d1	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  007d8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007db	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  007e2	2b c8		 sub	 ecx, eax
  007e4	51		 push	 ecx
  007e5	8b 4d fc	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  007e8	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  007ef	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007f2	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  007f9	2b d1		 sub	 edx, ecx
  007fb	52		 push	 edx
  007fc	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  00801	83 c4 08	 add	 esp, 8
  00804	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00807	88 82 08 01 00
	00		 mov	 BYTE PTR [edx+264], al

; 2901 : 						//if( lpObj->m_Attribute == 100 )	LogAdd("몬스터 근처로 이동 %d",lpObj->NextActionTime);
; 2902 : 					}

  0080d	eb 45		 jmp	 SHORT $LN53@gObjMonste
$LN52@gObjMonste:

; 2903 : 					else
; 2904 : 					{
; 2905 : 						gObjMonsterMoveAction(lpObj);

  0080f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00812	50		 push	 eax
  00813	e8 00 00 00 00	 call	 ?gObjMonsterMoveAction@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMonsterMoveAction
  00818	83 c4 04	 add	 esp, 4

; 2906 : 						lpObj->m_ActState.Emotion = 3;

  0081b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0081e	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00824	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  0082a	83 c9 30	 or	 ecx, 48			; 00000030H
  0082d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00830	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2907 : 						lpObj->m_ActState.EmotionCount = 10;

  00836	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00839	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0083f	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  00845	81 c9 00 0a 00
	00		 or	 ecx, 2560		; 00000a00H
  0084b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0084e	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN53@gObjMonste:

; 2908 : 						//if( lpObj->m_Attribute == 100 )	LogAdd("몬스터 근처로 이동2 %d",lpObj->m_ActState.EmotionCount);
; 2909 : 					}
; 2910 : 				}

  00854	eb 0c		 jmp	 SHORT $LN35@gObjMonste
$LN50@gObjMonste:

; 2911 : 				else 
; 2912 : 				{
; 2913 : 					/*lpObj->TargetNumber = -1;
; 2914 : 					lpObj->m_ActState.Attack = 0;
; 2915 : 					lpObj->NextActionTime = 500;
; 2916 : 					lpObj->m_ActState.Emotion = 3;
; 2917 : 					lpObj->m_ActState.EmotionCount = 5;
; 2918 : 					*/
; 2919 : 					gObjMonsterMoveAction(lpObj);

  00856	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00859	50		 push	 eax
  0085a	e8 00 00 00 00	 call	 ?gObjMonsterMoveAction@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMonsterMoveAction
  0085f	83 c4 04	 add	 esp, 4
$LN35@gObjMonste:

; 2920 : 					//if( lpObj->m_Attribute == 100 )	LogAdd("몬스터 근처로 이동3 %d",lpObj->m_ActState.EmotionCount);
; 2921 : 				}
; 2922 : 			}
; 2923 : 		}
; 2924 : 		else {			
; 2925 : 		}
; 2926 : 	}

  00862	e9 e8 01 00 00	 jmp	 $LN1@gObjMonste
$LN30@gObjMonste:

; 2927 : 	else if( lpObj->m_ActState.Emotion == 2 )	// 비열해졌다.

  00867	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0086a	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00870	c1 e9 04	 shr	 ecx, 4
  00873	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00876	83 f9 02	 cmp	 ecx, 2
  00879	0f 85 1c 01 00
	00		 jne	 $LN54@gObjMonste

; 2928 : 	{
; 2929 : 		// 잠깐 도망가 본다.
; 2930 : 		if( lpObj->m_ActState.EmotionCount > 0 ) lpObj->m_ActState.EmotionCount--;

  0087f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00882	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00888	c1 e9 08	 shr	 ecx, 8
  0088b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00891	76 39		 jbe	 SHORT $LN56@gObjMonste
  00893	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00896	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0089c	c1 e9 08	 shr	 ecx, 8
  0089f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  008a5	83 e9 01	 sub	 ecx, 1
  008a8	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  008ae	c1 e1 08	 shl	 ecx, 8
  008b1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008b4	8b 82 b0 01 00
	00		 mov	 eax, DWORD PTR [edx+432]
  008ba	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  008bf	0b c1		 or	 eax, ecx
  008c1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  008c4	89 81 b0 01 00
	00		 mov	 DWORD PTR [ecx+432], eax
  008ca	eb 18		 jmp	 SHORT $LN57@gObjMonste
$LN56@gObjMonste:

; 2931 : 		else {
; 2932 : 			lpObj->m_ActState.Emotion = 0;

  008cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008cf	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  008d5	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  008db	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008de	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN57@gObjMonste:

; 2933 : 		}
; 2934 : 		lpObj->m_ActState.Move = 1;

  008e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008e7	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  008ed	83 c9 04	 or	 ecx, 4
  008f0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008f3	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2935 : 		lpObj->NextActionTime = 800;

  008f9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008fc	c7 80 18 02 00
	00 20 03 00 00	 mov	 DWORD PTR [eax+536], 800 ; 00000320H

; 2936 : 
; 2937 : 		if( lpTargetObj!=NULL)

  00906	83 7d fc 00	 cmp	 DWORD PTR _lpTargetObj$[ebp], 0
  0090a	0f 84 86 00 00
	00		 je	 $LN58@gObjMonste

; 2938 : 		{
; 2939 : 			int tdir = GetPathPacketDirPos( lpTargetObj->X-lpObj->X, lpTargetObj->Y-lpObj->Y)*2;

  00910	8b 45 fc	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00913	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0091a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0091d	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  00924	2b c8		 sub	 ecx, eax
  00926	51		 push	 ecx
  00927	8b 4d fc	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0092a	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  00931	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00934	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0093b	2b d1		 sub	 edx, ecx
  0093d	52		 push	 edx
  0093e	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  00943	83 c4 08	 add	 esp, 8
  00946	0f b6 d0	 movzx	 edx, al
  00949	d1 e2		 shl	 edx, 1
  0094b	89 55 d0	 mov	 DWORD PTR _tdir$1[ebp], edx

; 2940 : 			
; 2941 : 			lpObj->MTX += RoadPathTable[tdir]*-3;	// 일단 도망간다.

  0094e	8b 45 d0	 mov	 eax, DWORD PTR _tdir$1[ebp]
  00951	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[eax*2]
  00959	6b d1 fd	 imul	 edx, ecx, -3
  0095c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0095f	0f bf 88 24 01
	00 00		 movsx	 ecx, WORD PTR [eax+292]
  00966	03 ca		 add	 ecx, edx
  00968	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0096b	66 89 8a 24 01
	00 00		 mov	 WORD PTR [edx+292], cx

; 2942 : 			lpObj->MTY += RoadPathTable[tdir+1]*-3;

  00972	8b 45 d0	 mov	 eax, DWORD PTR _tdir$1[ebp]
  00975	0f bf 0c 45 02
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[eax*2+2]
  0097d	6b d1 fd	 imul	 edx, ecx, -3
  00980	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00983	0f bf 88 26 01
	00 00		 movsx	 ecx, WORD PTR [eax+294]
  0098a	03 ca		 add	 ecx, edx
  0098c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0098f	66 89 8a 26 01
	00 00		 mov	 WORD PTR [edx+294], cx
$LN58@gObjMonste:

; 2943 : 		}
; 2944 : 		//if( lpObj->m_Attribute == 100 )	LogAdd("도망간다.");
; 2945 : 	}

  00996	e9 b4 00 00 00	 jmp	 $LN1@gObjMonste
$LN54@gObjMonste:

; 2946 : 	else if( lpObj->m_ActState.Emotion == 3 )	// 잠시 데미지를 입어 지연을 준다.

  0099b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0099e	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  009a4	c1 e9 04	 shr	 ecx, 4
  009a7	83 e1 0f	 and	 ecx, 15			; 0000000fH
  009aa	83 f9 03	 cmp	 ecx, 3
  009ad	0f 85 9c 00 00
	00		 jne	 $LN1@gObjMonste

; 2947 : 	{
; 2948 : 		if( lpObj->m_ActState.EmotionCount > 0 ) lpObj->m_ActState.EmotionCount--;

  009b3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009b6	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  009bc	c1 e9 08	 shr	 ecx, 8
  009bf	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  009c5	76 39		 jbe	 SHORT $LN60@gObjMonste
  009c7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009ca	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  009d0	c1 e9 08	 shr	 ecx, 8
  009d3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  009d9	83 e9 01	 sub	 ecx, 1
  009dc	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  009e2	c1 e1 08	 shl	 ecx, 8
  009e5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009e8	8b 82 b0 01 00
	00		 mov	 eax, DWORD PTR [edx+432]
  009ee	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  009f3	0b c1		 or	 eax, ecx
  009f5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009f8	89 81 b0 01 00
	00		 mov	 DWORD PTR [ecx+432], eax
  009fe	eb 18		 jmp	 SHORT $LN61@gObjMonste
$LN60@gObjMonste:

; 2949 : 		else {
; 2950 : 			lpObj->m_ActState.Emotion = 0;

  00a00	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a03	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00a09	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00a0f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a12	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN61@gObjMonste:

; 2951 : 		}
; 2952 : 		lpObj->m_ActState.Move = 0;

  00a18	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a1b	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00a21	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00a24	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a27	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2953 : 		lpObj->m_ActState.Attack = 0;

  00a2d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a30	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00a36	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00a39	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a3c	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2954 : 		lpObj->NextActionTime = 400;

  00a42	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a45	c7 80 18 02 00
	00 90 01 00 00	 mov	 DWORD PTR [eax+536], 400 ; 00000190H
$LN1@gObjMonste:

; 2955 : 		//if( lpObj->m_Attribute == 100 )	LogAdd("데미지후 지연");
; 2956 : 	}
; 2957 : }

  00a4f	5f		 pop	 edi
  00a50	5e		 pop	 esi
  00a51	5b		 pop	 ebx
  00a52	8b e5		 mov	 esp, ebp
  00a54	5d		 pop	 ebp
  00a55	c3		 ret	 0
?gObjMonsterBaseAct@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjMonsterBaseAct
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FgQeustNpcTeleport@@YAXXZ
text$yd	SEGMENT
??__FgQeustNpcTeleport@@YAXXZ PROC			; `dynamic atexit destructor for 'gQeustNpcTeleport'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  0000e	e8 00 00 00 00	 call	 ??1CQeustNpcTeleport@@QAE@XZ ; CQeustNpcTeleport::~CQeustNpcTeleport
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FgQeustNpcTeleport@@YAXXZ ENDP			; `dynamic atexit destructor for 'gQeustNpcTeleport''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ??__EgQeustNpcTeleport@@YAXXZ
text$di	SEGMENT
??__EgQeustNpcTeleport@@YAXXZ PROC			; `dynamic initializer for 'gQeustNpcTeleport'', COMDAT

; 119  : CQeustNpcTeleport	gQeustNpcTeleport;			// NPC에게 말건 사람의 참조 포인트

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  0000e	e8 00 00 00 00	 call	 ??0CQeustNpcTeleport@@QAE@XZ ; CQeustNpcTeleport::CQeustNpcTeleport
  00013	68 00 00 00 00	 push	 OFFSET ??__FgQeustNpcTeleport@@YAXXZ ; `dynamic atexit destructor for 'gQeustNpcTeleport''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EgQeustNpcTeleport@@YAXXZ ENDP			; `dynamic initializer for 'gQeustNpcTeleport''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FKUNDUN_EVENT_LOG@@YAXXZ
text$yd	SEGMENT
??__FKUNDUN_EVENT_LOG@@YAXXZ PROC			; `dynamic atexit destructor for 'KUNDUN_EVENT_LOG'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  0000e	e8 00 00 00 00	 call	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FKUNDUN_EVENT_LOG@@YAXXZ ENDP			; `dynamic atexit destructor for 'KUNDUN_EVENT_LOG''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ??__EKUNDUN_EVENT_LOG@@YAXXZ
text$di	SEGMENT
??__EKUNDUN_EVENT_LOG@@YAXXZ PROC			; `dynamic initializer for 'KUNDUN_EVENT_LOG'', COMDAT

; 68   : CLogToFile	KUNDUN_EVENT_LOG ("KUNDUN_EVENT_LOG", ".\\KUNDUN_EVENT_LOG");		// 로그파일 객체

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	6a 01		 push	 1
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CIMLGFIE@?4?2KUNDUN_EVENT_LOG@
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BACGIKG@KUNDUN_EVENT_LOG@
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  0001a	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  0001f	68 00 00 00 00	 push	 OFFSET ??__FKUNDUN_EVENT_LOG@@YAXXZ ; `dynamic atexit destructor for 'KUNDUN_EVENT_LOG''
  00024	e8 00 00 00 00	 call	 _atexit
  00029	83 c4 04	 add	 esp, 4
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??__EKUNDUN_EVENT_LOG@@YAXXZ ENDP			; `dynamic initializer for 'KUNDUN_EVENT_LOG''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1번 캐슬 - 축석

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1번 캐슬 - 영석

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2번 캐슬 - 축석

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2번 캐슬 - 영석

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3번 캐슬 - 축석

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3번 캐슬 - 영석

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4번 캐슬 - 축석

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4번 캐슬 - 영석

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5번 캐슬 - 축석

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5번 캐슬 - 영석

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6번 캐슬 - 축석

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6번 캐슬 - 영석

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?Run@CQeustNpcTeleport@@QAEXH@Z
_TEXT	SEGMENT
_tableindex$1 = -16					; size = 4
_pAttack$2 = -12					; size = 8
_this$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?Run@CQeustNpcTeleport@@QAEXH@Z PROC			; CQeustNpcTeleport::Run, COMDAT
; _this$ = ecx

; 6549 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 6550 : 	if( RefCount > 0 )

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	7e 05		 jle	 SHORT $LN4@Run

; 6551 : 	{	// 말걸고 있으면... 
; 6552 : 		return;

  00014	e9 07 03 00 00	 jmp	 $LN1@Run
$LN4@Run:

; 6553 : 	}
; 6554 : 
; 6555 : 	TimeCount++;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0001f	83 c1 01	 add	 ecx, 1
  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 6556 : 	if( TimeCount > gQuestNPCTeleportTime )

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0002e	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gQuestNPCTeleportTime@@3HA ; gQuestNPCTeleportTime
  00034	0f 8e e6 02 00
	00		 jle	 $LN1@Run

; 6557 : 	{	// 텔레포트 		
; 6558 : 		TimeCount = 0;		

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 6559 : 		
; 6560 : 		PMSG_MAGICATTACK_RESULT	pAttack;
; 6561 : 	
; 6562 : 		PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof( pAttack));

  00044	6a 08		 push	 8
  00046	6a 19		 push	 25			; 00000019H
  00048	8d 45 f4	 lea	 eax, DWORD PTR _pAttack$2[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6563 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD 
; 6564 : 		pAttack.MagicNumberH   = HIBYTE( AT_SKILL_TELEPORT );
; 6565 : 		pAttack.MagicNumberL   = LOBYTE( AT_SKILL_TELEPORT );
; 6566 : #else
; 6567 : 		pAttack.MagicNumber   = AT_SKILL_TELEPORT;

  00054	c6 45 f7 06	 mov	 BYTE PTR _pAttack$2[ebp+3], 6

; 6568 : #endif
; 6569 : 		pAttack.SourceNumberH = HIBYTE(aIndex);

  00058	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0005b	c1 e8 08	 shr	 eax, 8
  0005e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00063	88 45 f8	 mov	 BYTE PTR _pAttack$2[ebp+4], al

; 6570 : 		pAttack.SourceNumberL = LOBYTE(aIndex);	

  00066	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00069	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0006e	88 45 f9	 mov	 BYTE PTR _pAttack$2[ebp+5], al

; 6571 : 		pAttack.TargetNumberH = HIBYTE(aIndex);

  00071	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00074	c1 e8 08	 shr	 eax, 8
  00077	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007c	88 45 fa	 mov	 BYTE PTR _pAttack$2[ebp+6], al

; 6572 : 		pAttack.TargetNumberL = LOBYTE(aIndex);	

  0007f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00082	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00087	88 45 fb	 mov	 BYTE PTR _pAttack$2[ebp+7], al

; 6573 : 
; 6574 : 		MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);			

  0008a	0f b6 45 f5	 movzx	 eax, BYTE PTR _pAttack$2[ebp+1]
  0008e	50		 push	 eax
  0008f	8d 4d f4	 lea	 ecx, DWORD PTR _pAttack$2[ebp]
  00092	51		 push	 ecx
  00093	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0009a	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6575 : 
; 6576 : 		gObjViewportListProtocolDestroy(&gObj[aIndex]);

  000a9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b0	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
  000bc	83 c4 04	 add	 esp, 4

; 6577 : 		gObjClearViewport(&gObj[aIndex]);

  000bf	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  000d2	83 c4 04	 add	 esp, 4
$LN2@Run:

; 6578 : 
; 6579 : 		int		tableindex;
; 6580 : 
; 6581 : 		while(1)

  000d5	b8 01 00 00 00	 mov	 eax, 1
  000da	85 c0		 test	 eax, eax
  000dc	74 2c		 je	 SHORT $LN3@Run

; 6582 : 		{
; 6583 : 			tableindex = rand()%4;

  000de	e8 00 00 00 00	 call	 _rand
  000e3	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000e8	79 05		 jns	 SHORT $LN8@Run
  000ea	48		 dec	 eax
  000eb	83 c8 fc	 or	 eax, -4			; fffffffcH
  000ee	40		 inc	 eax
$LN8@Run:
  000ef	89 45 f0	 mov	 DWORD PTR _tableindex$1[ebp], eax

; 6584 : 			if( LastMapNumber != tableindex )

  000f2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000f8	3b 4d f0	 cmp	 ecx, DWORD PTR _tableindex$1[ebp]
  000fb	74 0b		 je	 SHORT $LN6@Run

; 6585 : 			{
; 6586 : 				LastMapNumber = tableindex;

  000fd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00100	8b 4d f0	 mov	 ecx, DWORD PTR _tableindex$1[ebp]
  00103	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 6587 : 				break;

  00106	eb 02		 jmp	 SHORT $LN3@Run
$LN6@Run:

; 6588 : 			}
; 6589 : 		}			

  00108	eb cb		 jmp	 SHORT $LN2@Run
$LN3@Run:

; 6590 : 		
; 6591 : 		gObj[aIndex].X			= m_QuestNPCTeleportPos[tableindex].x;

  0010a	8b 45 f0	 mov	 eax, DWORD PTR _tableindex$1[ebp]
  0010d	c1 e0 04	 shl	 eax, 4
  00110	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00117	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011d	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00120	66 8b 44 06 28	 mov	 ax, WORD PTR [esi+eax+40]
  00125	66 89 84 0a 04
	01 00 00	 mov	 WORD PTR [edx+ecx+260], ax

; 6592 : 		gObj[aIndex].Y			= m_QuestNPCTeleportPos[tableindex].y;

  0012d	8b 45 f0	 mov	 eax, DWORD PTR _tableindex$1[ebp]
  00130	c1 e0 04	 shl	 eax, 4
  00133	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0013a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00140	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00143	66 8b 44 06 2c	 mov	 ax, WORD PTR [esi+eax+44]
  00148	66 89 84 0a 06
	01 00 00	 mov	 WORD PTR [edx+ecx+262], ax

; 6593 : 
; 6594 : 		gObj[aIndex].TX = gObj[aIndex].X;

  00150	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00157	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0015e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00164	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016a	66 8b 84 06 04
	01 00 00	 mov	 ax, WORD PTR [esi+eax+260]
  00172	66 89 84 0a 20
	01 00 00	 mov	 WORD PTR [edx+ecx+288], ax

; 6595 : 		gObj[aIndex].TY = gObj[aIndex].Y;

  0017a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00181	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00188	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00194	66 8b 84 06 06
	01 00 00	 mov	 ax, WORD PTR [esi+eax+262]
  0019c	66 89 84 0a 22
	01 00 00	 mov	 WORD PTR [edx+ecx+290], ax

; 6596 : 		gObj[aIndex].MTX = gObj[aIndex].X;

  001a4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ab	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001be	66 8b 84 06 04
	01 00 00	 mov	 ax, WORD PTR [esi+eax+260]
  001c6	66 89 84 0a 24
	01 00 00	 mov	 WORD PTR [edx+ecx+292], ax

; 6597 : 		gObj[aIndex].MTY = gObj[aIndex].Y;

  001ce	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001d5	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e8	66 8b 84 06 06
	01 00 00	 mov	 ax, WORD PTR [esi+eax+262]
  001f0	66 89 84 0a 26
	01 00 00	 mov	 WORD PTR [edx+ecx+294], ax

; 6598 : 		
; 6599 : 
; 6600 : 		gObj[aIndex].m_OldX		= gObj[aIndex].TX;

  001f8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ff	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00206	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0020c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00212	66 8b 84 06 20
	01 00 00	 mov	 ax, WORD PTR [esi+eax+288]
  0021a	66 89 84 0a 1c
	01 00 00	 mov	 WORD PTR [edx+ecx+284], ax

; 6601 : 		gObj[aIndex].m_OldY		= gObj[aIndex].TY;

  00222	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00229	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00230	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00236	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023c	66 8b 84 06 22
	01 00 00	 mov	 ax, WORD PTR [esi+eax+290]
  00244	66 89 84 0a 1e
	01 00 00	 mov	 WORD PTR [edx+ecx+286], ax

; 6602 : 
; 6603 : 		gObj[aIndex].MapNumber = m_QuestNPCTeleportPos[tableindex].mapnum;

  0024c	8b 45 f0	 mov	 eax, DWORD PTR _tableindex$1[ebp]
  0024f	c1 e0 04	 shl	 eax, 4
  00252	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00259	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0025f	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00262	8a 44 06 24	 mov	 al, BYTE PTR [esi+eax+36]
  00266	88 84 0a 09 01
	00 00		 mov	 BYTE PTR [edx+ecx+265], al

; 6604 : 		gObj[aIndex].Dir = m_QuestNPCTeleportPos[tableindex].dir;

  0026d	8b 45 f0	 mov	 eax, DWORD PTR _tableindex$1[ebp]
  00270	c1 e0 04	 shl	 eax, 4
  00273	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0027a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00280	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00283	8a 44 06 30	 mov	 al, BYTE PTR [esi+eax+48]
  00287	88 84 0a 08 01
	00 00		 mov	 BYTE PTR [edx+ecx+264], al

; 6605 : 
; 6606 : 		gObj[aIndex].StartX = (BYTE)gObj[aIndex].X;

  0028e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00295	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0029c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a8	8a 84 06 04 01
	00 00		 mov	 al, BYTE PTR [esi+eax+260]
  002af	88 84 0a 1a 01
	00 00		 mov	 BYTE PTR [edx+ecx+282], al

; 6607 : 		gObj[aIndex].StartY = (BYTE)gObj[aIndex].Y;

  002b6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002bd	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ca	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d0	8a 84 06 06 01
	00 00		 mov	 al, BYTE PTR [esi+eax+262]
  002d7	88 84 0a 1b 01
	00 00		 mov	 BYTE PTR [edx+ecx+283], al

; 6608 : 
; 6609 : 		gObj[aIndex].m_State	= OBJST_CREATE;

  002de	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002eb	c7 84 01 b8 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+440], 1

; 6610 : 		gObj[aIndex].PathCount = 0;	

  002f6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00303	c7 84 01 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+296], 0

; 6611 : 
; 6612 : 		LogAdd("NPC %d로 이동", tableindex);			

  0030e	8b 45 f0	 mov	 eax, DWORD PTR _tableindex$1[ebp]
  00311	50		 push	 eax
  00312	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PGINOIGE@NPC?5?$CFd?$LH?N?5?$MA?L?$LF?$LP@
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0031d	83 c4 08	 add	 esp, 8
$LN1@Run:

; 6613 : 	}
; 6614 : 
; 6615 : }

  00320	5f		 pop	 edi
  00321	5e		 pop	 esi
  00322	5b		 pop	 ebx
  00323	8b e5		 mov	 esp, ebp
  00325	5d		 pop	 ebp
  00326	c2 04 00	 ret	 4
?Run@CQeustNpcTeleport@@QAEXH@Z ENDP			; CQeustNpcTeleport::Run
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.h
;	COMDAT ??1CQeustNpcTeleport@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CQeustNpcTeleport@@QAE@XZ PROC			; CQeustNpcTeleport::~CQeustNpcTeleport, COMDAT
; _this$ = ecx

; 134  : 	~CQeustNpcTeleport(){DeleteCriticalSection(&CsRef);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??1CQeustNpcTeleport@@QAE@XZ ENDP			; CQeustNpcTeleport::~CQeustNpcTeleport
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.h
;	COMDAT ??0CQeustNpcTeleport@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CQeustNpcTeleport@@QAE@XZ PROC			; CQeustNpcTeleport::CQeustNpcTeleport, COMDAT
; _this$ = ecx

; 116  : 	CQeustNpcTeleport()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	{
; 118  : 		LastMapNumber = -1;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [eax+32], -1

; 119  : 		RefCount = 0;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 120  : 		InitializeCriticalSection(&CsRef);

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c0 04	 add	 eax, 4
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 121  : 		TimeCount = 0;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 122  : 		m_QuestNPCTeleportPos[0].mapnum = MAP_INDEX_DEVIAS;	m_QuestNPCTeleportPos[0].x = 198;

  00036	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0003b	6b c8 00	 imul	 ecx, eax, 0
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	c7 44 0a 24 02
	00 00 00	 mov	 DWORD PTR [edx+ecx+36], 2
  00049	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0004e	6b c8 00	 imul	 ecx, eax, 0
  00051	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00054	c7 44 0a 28 c6
	00 00 00	 mov	 DWORD PTR [edx+ecx+40], 198 ; 000000c6H

; 123  : 		m_QuestNPCTeleportPos[0].y = 47;					m_QuestNPCTeleportPos[0].dir = 2;

  0005c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00061	6b c8 00	 imul	 ecx, eax, 0
  00064	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00067	c7 44 0a 2c 2f
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 47 ; 0000002fH
  0006f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00074	6b c8 00	 imul	 ecx, eax, 0
  00077	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	c7 44 0a 30 02
	00 00 00	 mov	 DWORD PTR [edx+ecx+48], 2

; 124  : 
; 125  : 		m_QuestNPCTeleportPos[1].mapnum = MAP_INDEX_RORENCIA;	m_QuestNPCTeleportPos[1].x = 137;

  00082	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00087	c1 e0 00	 shl	 eax, 0
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	c7 44 01 24 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+36], 0
  00095	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0009a	c1 e0 00	 shl	 eax, 0
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	c7 44 01 28 89
	00 00 00	 mov	 DWORD PTR [ecx+eax+40], 137 ; 00000089H

; 126  : 		m_QuestNPCTeleportPos[1].y = 87;						m_QuestNPCTeleportPos[1].dir = 1;

  000a8	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000ad	c1 e0 00	 shl	 eax, 0
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	c7 44 01 2c 57
	00 00 00	 mov	 DWORD PTR [ecx+eax+44], 87 ; 00000057H
  000bb	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000c0	c1 e0 00	 shl	 eax, 0
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	c7 44 01 30 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+48], 1

; 127  : 
; 128  : 		m_QuestNPCTeleportPos[2].mapnum = MAP_INDEX_NORIA;	m_QuestNPCTeleportPos[2].x = 169;

  000ce	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000d3	d1 e0		 shl	 eax, 1
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	c7 44 01 24 03
	00 00 00	 mov	 DWORD PTR [ecx+eax+36], 3
  000e0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000e5	d1 e0		 shl	 eax, 1
  000e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	c7 44 01 28 a9
	00 00 00	 mov	 DWORD PTR [ecx+eax+40], 169 ; 000000a9H

; 129  : 		m_QuestNPCTeleportPos[2].y = 89;					m_QuestNPCTeleportPos[2].dir = 2;

  000f2	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000f7	d1 e0		 shl	 eax, 1
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	c7 44 01 2c 59
	00 00 00	 mov	 DWORD PTR [ecx+eax+44], 89 ; 00000059H
  00104	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00109	d1 e0		 shl	 eax, 1
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	c7 44 01 30 02
	00 00 00	 mov	 DWORD PTR [ecx+eax+48], 2

; 130  : 
; 131  : 		m_QuestNPCTeleportPos[3].mapnum = MAP_INDEX_ATHLANSE;	m_QuestNPCTeleportPos[3].x = 17;

  00116	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0011b	6b c8 03	 imul	 ecx, eax, 3
  0011e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00121	c7 44 0a 24 07
	00 00 00	 mov	 DWORD PTR [edx+ecx+36], 7
  00129	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0012e	6b c8 03	 imul	 ecx, eax, 3
  00131	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00134	c7 44 0a 28 11
	00 00 00	 mov	 DWORD PTR [edx+ecx+40], 17 ; 00000011H

; 132  : 		m_QuestNPCTeleportPos[3].y = 25;						m_QuestNPCTeleportPos[3].dir = 2;

  0013c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00141	6b c8 03	 imul	 ecx, eax, 3
  00144	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00147	c7 44 0a 2c 19
	00 00 00	 mov	 DWORD PTR [edx+ecx+44], 25 ; 00000019H
  0014f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00154	6b c8 03	 imul	 ecx, eax, 3
  00157	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0015a	c7 44 0a 30 02
	00 00 00	 mov	 DWORD PTR [edx+ecx+48], 2

; 133  : 	};

  00162	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	8b e5		 mov	 esp, ebp
  0016a	5d		 pop	 ebp
  0016b	c3		 ret	 0
??0CQeustNpcTeleport@@QAE@XZ ENDP			; CQeustNpcTeleport::CQeustNpcTeleport
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjUseMonsterSpecialAbillity@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pAttackMsg$1 = -8					; size = 7
_lpMonsterObj$ = 8					; size = 4
?gObjUseMonsterSpecialAbillity@@YAXPAVOBJECTSTRUCT@@@Z PROC ; gObjUseMonsterSpecialAbillity, COMDAT

; 1974 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1975 : 	// *. 6칼리마의 쿤둔일때 
; 1976 : 	if( lpMonsterObj->Class == 275 )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  0000c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00013	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  00019	0f 85 a7 00 00
	00		 jne	 $LN5@gObjUseMon

; 1977 : 	{
; 1978 : 		PMSG_MAGICATTACK pAttackMsg;
; 1979 : 
; 1980 : 		// 소환 마법 인덱스 = 1
; 1981 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 스킬번호 BYTE -> WORD
; 1982 : 		pAttackMsg.MagicNumberH	= HIBYTE( 1 );				
; 1983 : 		pAttackMsg.MagicNumberL	= LOBYTE( 1 );				
; 1984 : #else
; 1985 : 		pAttackMsg.MagicNumber	= 1;				

  0001f	c6 45 fb 01	 mov	 BYTE PTR _pAttackMsg$1[ebp+3], 1

; 1986 : #endif		
; 1987 : 		pAttackMsg.NumberH		= HIBYTE(lpMonsterObj->TargetNumber);

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  00026	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0002d	c1 e9 08	 shr	 ecx, 8
  00030	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00036	88 4d fc	 mov	 BYTE PTR _pAttackMsg$1[ebp+4], cl

; 1988 : 		pAttackMsg.NumberL		= LOBYTE(lpMonsterObj->TargetNumber);

  00039	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  0003c	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00043	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00049	88 4d fd	 mov	 BYTE PTR _pAttackMsg$1[ebp+5], cl

; 1989 : 		pAttackMsg.Dis			= 0;

  0004c	c6 45 fe 00	 mov	 BYTE PTR _pAttackMsg$1[ebp+6], 0

; 1990 : 	
; 1991 : 		// 피가 얼마 남지 않았을때 부하 몹 소환!
; 1992 : 		// 마법 인덱스 1 번이 소환 마법
; 1993 : 
; 1994 : 		
; 1995 : 		// 2. 몬스터 소환을 5번 시전 한다.
; 1996 : 		if( lpMonsterObj->Life < (lpMonsterObj->MaxLife / 25) )

  00050	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  00053	f3 0f 10 80 c0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+192]
  0005b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41c80000
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonsterObj$[ebp]
  00066	0f 2f 81 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [ecx+188]
  0006d	76 26		 jbe	 SHORT $LN3@gObjUseMon

; 1997 : 		{
; 1998 : 
; 1999 : 			CGMagicAttack(&pAttackMsg, lpMonsterObj->m_Index);

  0006f	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  00072	8b 08		 mov	 ecx, DWORD PTR [eax]
  00074	51		 push	 ecx
  00075	8d 55 f8	 lea	 edx, DWORD PTR _pAttackMsg$1[ebp]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  0007e	83 c4 08	 add	 esp, 8

; 2000 : 			CGMagicAttack(&pAttackMsg, lpMonsterObj->m_Index);

  00081	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	8d 55 f8	 lea	 edx, DWORD PTR _pAttackMsg$1[ebp]
  0008a	52		 push	 edx
  0008b	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  00090	83 c4 08	 add	 esp, 8

; 2001 : 		}

  00093	eb 31		 jmp	 SHORT $LN5@gObjUseMon
$LN3@gObjUseMon:

; 2002 : 		// 1. 몬스터 소환을 3번 시전 한다.
; 2003 : 		else if( lpMonsterObj->Life < (lpMonsterObj->MaxLife / 5) )

  00095	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  00098	f3 0f 10 80 c0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+192]
  000a0	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40a00000
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonsterObj$[ebp]
  000ab	0f 2f 81 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [ecx+188]
  000b2	76 12		 jbe	 SHORT $LN5@gObjUseMon

; 2004 : 		{
; 2005 : 			CGMagicAttack(&pAttackMsg, lpMonsterObj->m_Index);

  000b4	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	51		 push	 ecx
  000ba	8d 55 f8	 lea	 edx, DWORD PTR _pAttackMsg$1[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  000c3	83 c4 08	 add	 esp, 8
$LN5@gObjUseMon:

; 2006 : 		}
; 2007 : 	}
; 2008 : 
; 2009 : }

  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?gObjUseMonsterSpecialAbillity@@YAXPAVOBJECTSTRUCT@@@Z ENDP ; gObjUseMonsterSpecialAbillity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjRefillMonsterHP@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv76 = -76						; size = 4
_iRefillHP$ = -8					; size = 4
_iMonsterHP$ = -4					; size = 4
_lpMonsterObj$ = 8					; size = 4
_iRefillHPSec$ = 12					; size = 4
?gObjRefillMonsterHP@@YAXPAVOBJECTSTRUCT@@H@Z PROC	; gObjRefillMonsterHP, COMDAT

; 3243 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3244 : 	INT iMonsterHP = lpMonsterObj->Life;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  0000c	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  00014	89 4d fc	 mov	 DWORD PTR _iMonsterHP$[ebp], ecx

; 3245 : 	INT	iRefillHP  = 0;

  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iRefillHP$[ebp], 0

; 3246 : 
; 3247 : 	// 6칼리마 쿤둔일 경우
; 3248 : 	
; 3249 : #ifdef CHANGE_KUNDUN_SETTING_01_20050221
; 3250 : 	// 죽어 있으면 return
; 3251 : 	if( lpMonsterObj->Live == 0 )

  0001e	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  00021	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00025	85 c9		 test	 ecx, ecx
  00027	75 05		 jne	 SHORT $LN2@gObjRefill

; 3252 : 	{
; 3253 : 		return;

  00029	e9 ef 00 00 00	 jmp	 $LN1@gObjRefill
$LN2@gObjRefill:

; 3254 : 	}
; 3255 : #endif
; 3256 : 	
; 3257 : 	if( lpMonsterObj->Class == 275 )

  0002e	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  00031	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00038	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  0003e	0f 85 98 00 00
	00		 jne	 $LN5@gObjRefill

; 3258 : 	{
; 3259 : #ifdef ADD_KUNDUN_CONTROL_20040923
; 3260 : 		// 쿤둔 특별한 피회복 시간이 지났으면
; 3261 : 		if( lpMonsterObj->iObjectSecTimer > giKundunRefillHPTime )

  00044	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  00047	8b 88 e8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6632]
  0004d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?giKundunRefillHPTime@@3HA ; giKundunRefillHPTime
  00053	7e 72		 jle	 SHORT $LN4@gObjRefill

; 3262 : 		{
; 3263 : 			// 피회복
; 3264 : 			iRefillHP = rand() % ( giKundunRefillHP > 0 ? giKundunRefillHP : 1 );

  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?giKundunRefillHP@@3HA, 0 ; giKundunRefillHP
  0005c	7e 0a		 jle	 SHORT $LN9@gObjRefill
  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?giKundunRefillHP@@3HA ; giKundunRefillHP
  00063	89 45 b4	 mov	 DWORD PTR tv76[ebp], eax
  00066	eb 07		 jmp	 SHORT $LN10@gObjRefill
$LN9@gObjRefill:
  00068	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
$LN10@gObjRefill:
  0006f	e8 00 00 00 00	 call	 _rand
  00074	99		 cdq
  00075	f7 7d b4	 idiv	 DWORD PTR tv76[ebp]
  00078	89 55 f8	 mov	 DWORD PTR _iRefillHP$[ebp], edx

; 3265 : 			
; 3266 : 			lpMonsterObj->iObjectSecTimer = 0;

  0007b	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  0007e	c7 80 e8 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6632], 0

; 3267 : 
; 3268 : 			KUNDUN_EVENT_LOG.Output("[KUNDUN] HP Log -> [%d]회복  [%d]회복시간  [%7.0f]현재HP", 

  00088	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  0008b	f3 0f 5a 80 bc
	00 00 00	 cvtss2sd xmm0, DWORD PTR [eax+188]
  00093	83 ec 08	 sub	 esp, 8
  00096	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?giKundunRefillHPTime@@3HA ; giKundunRefillHPTime
  000a1	51		 push	 ecx
  000a2	8b 55 f8	 mov	 edx, DWORD PTR _iRefillHP$[ebp]
  000a5	52		 push	 edx
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@LBLCMLBJ@?$FLKUNDUN?$FN?5HP?5Log?5?9?$DO?5?$FL?$CFd?$FN?H?$LI?$LK?$LJ?5?5?$FL?$CF@
  000ab	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  000b0	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  000b5	83 c4 18	 add	 esp, 24			; 00000018H

; 3269 : 									iRefillHP, giKundunRefillHPTime, lpMonsterObj->Life);
; 3270 : 
; 3271 : 			lpMonsterObj->iObjectSecTimer = 0;

  000b8	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  000bb	c7 80 e8 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6632], 0

; 3272 : 			
; 3273 : 		}

  000c5	eb 15		 jmp	 SHORT $LN5@gObjRefill
$LN4@gObjRefill:

; 3274 : 		else
; 3275 : 		{
; 3276 : 			lpMonsterObj->iObjectSecTimer++;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  000ca	8b 88 e8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6632]
  000d0	83 c1 01	 add	 ecx, 1
  000d3	8b 55 08	 mov	 edx, DWORD PTR _lpMonsterObj$[ebp]
  000d6	89 8a e8 19 00
	00		 mov	 DWORD PTR [edx+6632], ecx
$LN5@gObjRefill:

; 3277 : 		}
; 3278 : #endif
; 3279 : 		
; 3280 : #ifdef EXTEND_LOG_SYSTEM_20060202
; 3281 : 		if( lpMonsterObj->iObjectSecTimer % giKundunHPLogSaveTime == 0 )
; 3282 : 		{
; 3283 : 			LogAddTD("[KUNDUN][Status Log] HP:%d RefillHP:%d Map:%d X:%d Y:%d",
; 3284 : 					iMonsterHP, iRefillHP, lpMonsterObj->MapNumber, lpMonsterObj->X, lpMonsterObj->Y);
; 3285 : 
; 3286 : 			if( gObjIsConnected( lpMonsterObj->LastAttackerID ) )
; 3287 : 			{
; 3288 : 				LPOBJECTSTRUCT lpAttackObj = &gObj[lpMonsterObj->LastAttackerID];
; 3289 : 
; 3290 : 				LogAddTD("[KUNDUN][Attacker Info] [%s][%s] HP:%d MP:%d X:%d Y:%d",
; 3291 : 					lpAttackObj->AccountID, lpAttackObj->Name,
; 3292 : 					lpAttackObj->Life, lpAttackObj->Mana, lpAttackObj->X, lpAttackObj->Y );
; 3293 : 			}
; 3294 : 		}
; 3295 : #endif
; 3296 : 		
; 3297 : #ifdef MU_CRYWOLF_BENEFIT_20051215
; 3298 : 		// MVP 성공 : 쿤둔 자생 없어짐.
; 3299 : 		if( 
; 3300 : 			g_CrywolfSync.GetOccupationState() == CRYWOLF_OCCUPATION_STATE_PEACE
; 3301 : #ifdef MODIFY_CRYWOLF_BENEFIT_01_20060315		
; 3302 : 			&& g_CrywolfSync.GetKundunHPRefillState() == CRYWOLF_BENEFIT_KUNDUN_HP_REFILL_OFF
; 3303 : 			&& g_iCrywolfApplyMvpBenefit
; 3304 : #endif // MODIFY_CRYWOLF_BENEFIT_01_20060315
; 3305 : 		  )
; 3306 : 		{
; 3307 : 			iRefillHP		= 0;
; 3308 : 			iRefillHPSec	= 0;
; 3309 : 
; 3310 : #if TESTSERVER == 1
; 3311 : 			LogAddTD( "★☆ 크라이울프 혜택 적용 : 쿤둔 자생 없어짐 상태 (%d)", g_CrywolfSync.GetKundunHPRefillState() );
; 3312 : #endif
; 3313 : 
; 3314 : 		}
; 3315 : #endif // MU_CRYWOLF_BENEFIT_20051215
; 3316 : 
; 3317 : 	}
; 3318 : 
; 3319 : 	iMonsterHP = iMonsterHP + iRefillHP + iRefillHPSec;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _iMonsterHP$[ebp]
  000df	03 45 f8	 add	 eax, DWORD PTR _iRefillHP$[ebp]
  000e2	03 45 0c	 add	 eax, DWORD PTR _iRefillHPSec$[ebp]
  000e5	89 45 fc	 mov	 DWORD PTR _iMonsterHP$[ebp], eax

; 3320 : 
; 3321 : 	if( iMonsterHP > lpMonsterObj->MaxLife )

  000e8	f3 0f 2a 45 fc	 cvtsi2ss xmm0, DWORD PTR _iMonsterHP$[ebp]
  000ed	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  000f0	0f 2f 80 c0 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+192]
  000f7	76 14		 jbe	 SHORT $LN6@gObjRefill

; 3322 : 		lpMonsterObj->Life = lpMonsterObj->MaxLife;

  000f9	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonsterObj$[ebp]
  000ff	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00105	89 90 bc 00 00
	00		 mov	 DWORD PTR [eax+188], edx
  0010b	eb 10		 jmp	 SHORT $LN7@gObjRefill
$LN6@gObjRefill:

; 3323 : 	else
; 3324 : 		lpMonsterObj->Life = iMonsterHP;

  0010d	f3 0f 2a 45 fc	 cvtsi2ss xmm0, DWORD PTR _iMonsterHP$[ebp]
  00112	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterObj$[ebp]
  00115	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0
$LN7@gObjRefill:
$LN1@gObjRefill:

; 3325 : 	
; 3326 : #ifdef ADD_KUNDUN_CONTROL_20040923
; 3327 : 	
; 3328 : #ifndef CHANGE_KUNDUN_SETTING_01_20050221
; 3329 : #ifdef FOR_KOREA
; 3330 : 	if( rand() % 5 == 0 && (lpMonsterObj->Class == 275) )
; 3331 : 	{
; 3332 : 		for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)
; 3333 : 		{
; 3334 : 			if( rand()%5 == 0 )
; 3335 : 			{
; 3336 : 				if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) )
; 3337 : 				{
; 3338 : 					if( gObj[n].MapNumber == MAP_INDEX_KALIMA6 )
; 3339 : 					{
; 3340 : 						TNotice _Notice(TNOTICE_TYPE_LEFTTOP);
; 3341 : 						_Notice.SendToUser( n, "쿤둔의 생명이 %7.0f 남았습니다.", lpMonsterObj->Life );
; 3342 : 					}
; 3343 : 				}
; 3344 : 			}
; 3345 : 		}
; 3346 : 
; 3347 : 	}
; 3348 : #endif
; 3349 : #endif // CHANGE_KUNDUN_SETTING_01_20050221
; 3350 : 
; 3351 : #endif // ADD_KUNDUN_CONTROL_20040923
; 3352 : 
; 3353 : }

  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
?gObjRefillMonsterHP@@YAXPAVOBJECTSTRUCT@@H@Z ENDP	; gObjRefillMonsterHP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterDieRewardItems@@YAXPAVOBJECTSTRUCT@@0HHHHHHH@Z
_TEXT	SEGMENT
tv192 = -164						; size = 4
_optionc$1 = -96					; size = 4
_option3rand$2 = -92					; size = 4
_option2rand$3 = -88					; size = 4
_option1rand$4 = -84					; size = 4
_cDropY$5 = -78						; size = 1
_cDropX$6 = -77						; size = 1
_i$7 = -76						; size = 4
_iCommonDropPer$ = -72					; size = 4
_iExtDropPer$ = -68					; size = 4
_iSetDropPer$ = -64					; size = 4
_MaxHitUser$ = -60					; size = 4
_DropItem$ = -56					; size = 4
_exitem_drop$ = -52					; size = 4
_item_drop$ = -48					; size = 4
_NOption$ = -41						; size = 1
_Option3$ = -40						; size = 4
_Option2$ = -36						; size = 4
_Option1$ = -32						; size = 4
_dur$ = -28						; size = 4
_y$ = -24						; size = 4
_x$ = -20						; size = 4
_level$ = -16						; size = 4
_type$ = -12						; size = 4
_DropItemNum$ = -8					; size = 4
_store_count$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_iCount$ = 16						; size = 4
_iDropRateCommonItem$ = 20				; size = 4
_iDropRateExcellentItem$ = 24				; size = 4
_iDropRateSetItem$ = 28					; size = 4
_bMustHaveSkill$ = 32					; size = 4
_bMustHaveLuck$ = 36					; size = 4
_bMustHaveAdditionalOption$ = 40			; size = 4
?gObjMonsterDieRewardItems@@YAXPAVOBJECTSTRUCT@@0HHHHHHH@Z PROC ; gObjMonsterDieRewardItems, COMDAT

; 3371 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3372 : 
; 3373 : 	int store_count=0;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _store_count$[ebp], 0

; 3374 : 	int DropItemNum = 0;

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _DropItemNum$[ebp], 0

; 3375 : 	int type, level, x, y;
; 3376 : 	float dur=0;

  0001a	0f 57 c0	 xorps	 xmm0, xmm0
  0001d	f3 0f 11 45 e4	 movss	 DWORD PTR _dur$[ebp], xmm0

; 3377 : 	int Option1 = 0;

  00022	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 3378 : 	int Option2 = 0;

  00029	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 3379 : 	int Option3 = 0;

  00030	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 3380 : 	BYTE NOption= 0;

  00037	c6 45 d7 00	 mov	 BYTE PTR _NOption$[ebp], 0

; 3381 : 	BOOL item_drop=0;

  0003b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0

; 3382 : 	BOOL exitem_drop=0;

  00042	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _exitem_drop$[ebp], 0

; 3383 : 	CItem * DropItem=NULL;

  00049	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _DropItem$[ebp], 0

; 3384 : 
; 3385 : 	// Item Looting 설정
; 3386 : 	int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00050	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 c4	 mov	 DWORD PTR _MaxHitUser$[ebp], eax

; 3387 : 
; 3388 : 	// iCount 만큼 드랍 위치 설정
; 3389 : 	
; 3390 : 	// 세트 아이템
; 3391 : 	int iSetDropPer		= iDropRateSetItem;

  0005f	8b 45 1c	 mov	 eax, DWORD PTR _iDropRateSetItem$[ebp]
  00062	89 45 c0	 mov	 DWORD PTR _iSetDropPer$[ebp], eax

; 3392 : 	int iExtDropPer		= iDropRateExcellentItem;

  00065	8b 45 18	 mov	 eax, DWORD PTR _iDropRateExcellentItem$[ebp]
  00068	89 45 bc	 mov	 DWORD PTR _iExtDropPer$[ebp], eax

; 3393 : 	int iCommonDropPer	= iDropRateCommonItem;

  0006b	8b 45 14	 mov	 eax, DWORD PTR _iDropRateCommonItem$[ebp]
  0006e	89 45 b8	 mov	 DWORD PTR _iCommonDropPer$[ebp], eax

; 3394 : 
; 3395 : 	for( int i=0; i<iCount; i++ )

  00071	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _i$7[ebp], 0
  00078	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  0007a	8b 45 b4	 mov	 eax, DWORD PTR _i$7[ebp]
  0007d	83 c0 01	 add	 eax, 1
  00080	89 45 b4	 mov	 DWORD PTR _i$7[ebp], eax
$LN4@gObjMonste:
  00083	8b 45 b4	 mov	 eax, DWORD PTR _i$7[ebp]
  00086	3b 45 10	 cmp	 eax, DWORD PTR _iCount$[ebp]
  00089	0f 8d de 02 00
	00		 jge	 $LN3@gObjMonste

; 3396 : 	{
; 3397 : 		UCHAR cDropX = lpObj->X;

  0008f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00092	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00098	88 4d b3	 mov	 BYTE PTR _cDropX$6[ebp], cl

; 3398 : 		UCHAR cDropY = lpObj->Y;

  0009b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009e	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  000a4	88 4d b2	 mov	 BYTE PTR _cDropY$5[ebp], cl

; 3399 : 
; 3400 : 		if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 4, 4, 10 ) )

  000a7	6a 0a		 push	 10			; 0000000aH
  000a9	6a 04		 push	 4
  000ab	6a 04		 push	 4
  000ad	8d 45 b2	 lea	 eax, DWORD PTR _cDropY$5[ebp]
  000b0	50		 push	 eax
  000b1	8d 4d b3	 lea	 ecx, DWORD PTR _cDropX$6[ebp]
  000b4	51		 push	 ecx
  000b5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b8	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ; gObjGetRandomItemDropLocation
  000c5	83 c4 18	 add	 esp, 24			; 00000018H
  000c8	85 c0		 test	 eax, eax
  000ca	75 18		 jne	 SHORT $LN7@gObjMonste

; 3401 : 		{
; 3402 : 			cDropX = (BYTE)lpObj->X;

  000cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cf	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  000d5	88 4d b3	 mov	 BYTE PTR _cDropX$6[ebp], cl

; 3403 : 			cDropY = (BYTE)lpObj->Y;

  000d8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000db	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  000e1	88 4d b2	 mov	 BYTE PTR _cDropY$5[ebp], cl
$LN7@gObjMonste:

; 3404 : 		}
; 3405 : 
; 3406 : 		// 액설런트 아이템
; 3407 : 		if( rand()%10000 < iExtDropPer )

  000e4	e8 00 00 00 00	 call	 _rand
  000e9	99		 cdq
  000ea	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  000ef	f7 f9		 idiv	 ecx
  000f1	3b 55 bc	 cmp	 edx, DWORD PTR _iExtDropPer$[ebp]
  000f4	7d 41		 jge	 SHORT $LN8@gObjMonste

; 3408 : 		{
; 3409 : 			DropItem = g_MonsterItemMng.GetItem(lpObj->Level - 25);

  000f6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f9	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00100	83 e9 19	 sub	 ecx, 25			; 00000019H
  00103	51		 push	 ecx
  00104	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterItemMng@@3VCMonsterItemMng@@A ; g_MonsterItemMng
  00109	e8 00 00 00 00	 call	 ?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z ; CMonsterItemMng::GetItem
  0010e	89 45 c8	 mov	 DWORD PTR _DropItem$[ebp], eax

; 3410 : 			if( DropItem == NULL )

  00111	83 7d c8 00	 cmp	 DWORD PTR _DropItem$[ebp], 0
  00115	75 10		 jne	 SHORT $LN10@gObjMonste

; 3411 : 			{
; 3412 : 				item_drop = 0;

  00117	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0

; 3413 : 				exitem_drop = 0;

  0011e	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _exitem_drop$[ebp], 0

; 3414 : 			}

  00125	eb 0e		 jmp	 SHORT $LN11@gObjMonste
$LN10@gObjMonste:

; 3415 : 			else
; 3416 : 			{
; 3417 : 				item_drop = 1;

  00127	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 1

; 3418 : 				exitem_drop = 1;

  0012e	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _exitem_drop$[ebp], 1
$LN11@gObjMonste:

; 3419 : 			}
; 3420 : 		}

  00135	eb 40		 jmp	 SHORT $LN14@gObjMonste
$LN8@gObjMonste:

; 3421 : 		// 일반 아이템
; 3422 : 		else
; 3423 : 		if( rand()%10000 < iCommonDropPer ) 

  00137	e8 00 00 00 00	 call	 _rand
  0013c	99		 cdq
  0013d	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00142	f7 f9		 idiv	 ecx
  00144	3b 55 b8	 cmp	 edx, DWORD PTR _iCommonDropPer$[ebp]
  00147	7d 2e		 jge	 SHORT $LN14@gObjMonste

; 3424 : 		{
; 3425 : 			DropItem = g_MonsterItemMng.GetItem(lpObj->Level);

  00149	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00153	51		 push	 ecx
  00154	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterItemMng@@3VCMonsterItemMng@@A ; g_MonsterItemMng
  00159	e8 00 00 00 00	 call	 ?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z ; CMonsterItemMng::GetItem
  0015e	89 45 c8	 mov	 DWORD PTR _DropItem$[ebp], eax

; 3426 : 			if( DropItem == NULL )

  00161	83 7d c8 00	 cmp	 DWORD PTR _DropItem$[ebp], 0
  00165	75 09		 jne	 SHORT $LN13@gObjMonste

; 3427 : 			{
; 3428 : 				item_drop = 0;

  00167	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0

; 3429 : 			}

  0016e	eb 07		 jmp	 SHORT $LN14@gObjMonste
$LN13@gObjMonste:

; 3430 : 			else
; 3431 : 			{
; 3432 : 				item_drop = 1;

  00170	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 1
$LN14@gObjMonste:

; 3433 : 			}
; 3434 : 		}
; 3435 : 
; 3436 : 		if( item_drop )

  00177	83 7d d0 00	 cmp	 DWORD PTR _item_drop$[ebp], 0
  0017b	0f 84 e7 01 00
	00		 je	 $LN27@gObjMonste

; 3437 : 		{
; 3438 : 			type = DropItem->m_Type;

  00181	8b 45 c8	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00184	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00188	89 4d f4	 mov	 DWORD PTR _type$[ebp], ecx

; 3439 : 			level= DropItem->m_Level;

  0018b	8b 45 c8	 mov	 eax, DWORD PTR _DropItem$[ebp]
  0018e	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00192	89 4d f0	 mov	 DWORD PTR _level$[ebp], ecx

; 3440 : 			dur  = DropItem->m_Durability;

  00195	8b 45 c8	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00198	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0019d	f3 0f 11 45 e4	 movss	 DWORD PTR _dur$[ebp], xmm0

; 3441 : 			x    = cDropX;

  001a2	0f b6 45 b3	 movzx	 eax, BYTE PTR _cDropX$6[ebp]
  001a6	89 45 ec	 mov	 DWORD PTR _x$[ebp], eax

; 3442 : 			y    = cDropY;

  001a9	0f b6 45 b2	 movzx	 eax, BYTE PTR _cDropY$5[ebp]
  001ad	89 45 e8	 mov	 DWORD PTR _y$[ebp], eax

; 3443 : 			
; 3444 : 			int option1rand, option2rand, option3rand, optionc;
; 3445 : 			
; 3446 : 			// 엑설런트 아이템의 경우 스킬은 무조건 붙으며 기존 옵션들은 정말 희박함
; 3447 : 			if( exitem_drop )

  001b0	83 7d cc 00	 cmp	 DWORD PTR _exitem_drop$[ebp], 0
  001b4	74 4d		 je	 SHORT $LN16@gObjMonste

; 3448 : 			{
; 3449 : 				option1rand = 100;

  001b6	c7 45 ac 64 00
	00 00		 mov	 DWORD PTR _option1rand$4[ebp], 100 ; 00000064H

; 3450 : 				option2rand = 1;

  001bd	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR _option2rand$3[ebp], 1

; 3451 : 				option3rand = (rand()%100);

  001c4	e8 00 00 00 00	 call	 _rand
  001c9	99		 cdq
  001ca	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001cf	f7 f9		 idiv	 ecx
  001d1	89 55 a4	 mov	 DWORD PTR _option3rand$2[ebp], edx

; 3452 : 				optionc		= (rand()%3);

  001d4	e8 00 00 00 00	 call	 _rand
  001d9	99		 cdq
  001da	b9 03 00 00 00	 mov	 ecx, 3
  001df	f7 f9		 idiv	 ecx
  001e1	89 55 a0	 mov	 DWORD PTR _optionc$1[ebp], edx

; 3453 : 				NOption		= NewOptionRand(lpObj->Level);

  001e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e7	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  001ee	51		 push	 ecx
  001ef	e8 00 00 00 00	 call	 ?NewOptionRand@@YAEH@Z	; NewOptionRand
  001f4	83 c4 04	 add	 esp, 4
  001f7	88 45 d7	 mov	 BYTE PTR _NOption$[ebp], al

; 3454 : 				level       = 0;

  001fa	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 3455 : 			}

  00201	eb 32		 jmp	 SHORT $LN17@gObjMonste
$LN16@gObjMonste:

; 3456 : 			else
; 3457 : 			{
; 3458 : 				option1rand = 6;				// 일반적인 옵션1 (스킬) 붙을 확률 6/100

  00203	c7 45 ac 06 00
	00 00		 mov	 DWORD PTR _option1rand$4[ebp], 6

; 3459 : 				option2rand = 4;				// 일반적인 옵션2 (행운) 붙을 확률 4/100

  0020a	c7 45 a8 04 00
	00 00		 mov	 DWORD PTR _option2rand$3[ebp], 4

; 3460 : 				option3rand = (rand()%100);		// 일반적인 옵션3 (추가포인트) 붙을 확률 랜덤/100

  00211	e8 00 00 00 00	 call	 _rand
  00216	99		 cdq
  00217	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0021c	f7 f9		 idiv	 ecx
  0021e	89 55 a4	 mov	 DWORD PTR _option3rand$2[ebp], edx

; 3461 : 				optionc		= (rand()%3);

  00221	e8 00 00 00 00	 call	 _rand
  00226	99		 cdq
  00227	b9 03 00 00 00	 mov	 ecx, 3
  0022c	f7 f9		 idiv	 ecx
  0022e	89 55 a0	 mov	 DWORD PTR _optionc$1[ebp], edx

; 3462 : 				NOption     = 0;

  00231	c6 45 d7 00	 mov	 BYTE PTR _NOption$[ebp], 0
$LN17@gObjMonste:

; 3463 : 			}
; 3464 : 			
; 3465 : 			// 스킬아이템 확률을 대폭 낮춘다.
; 3466 : 			if((rand()%100) < option1rand ) Option1 = 1;

  00235	e8 00 00 00 00	 call	 _rand
  0023a	99		 cdq
  0023b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00240	f7 f9		 idiv	 ecx
  00242	3b 55 ac	 cmp	 edx, DWORD PTR _option1rand$4[ebp]
  00245	7d 07		 jge	 SHORT $LN18@gObjMonste
  00247	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1
$LN18@gObjMonste:

; 3467 : 			if((rand()%100) < option2rand ) Option2 = 1;

  0024e	e8 00 00 00 00	 call	 _rand
  00253	99		 cdq
  00254	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00259	f7 f9		 idiv	 ecx
  0025b	3b 55 a8	 cmp	 edx, DWORD PTR _option2rand$3[ebp]
  0025e	7d 07		 jge	 SHORT $LN19@gObjMonste
  00260	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN19@gObjMonste:

; 3468 : 			
; 3469 : 			switch( optionc )

  00267	8b 45 a0	 mov	 eax, DWORD PTR _optionc$1[ebp]
  0026a	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv192[ebp], eax
  00270	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR tv192[ebp], 0
  00277	74 14		 je	 SHORT $LN20@gObjMonste
  00279	83 bd 5c ff ff
	ff 01		 cmp	 DWORD PTR tv192[ebp], 1
  00280	74 1a		 je	 SHORT $LN22@gObjMonste
  00282	83 bd 5c ff ff
	ff 02		 cmp	 DWORD PTR tv192[ebp], 2
  00289	74 20		 je	 SHORT $LN24@gObjMonste
  0028b	eb 2b		 jmp	 SHORT $LN5@gObjMonste
$LN20@gObjMonste:

; 3470 : 			{
; 3471 : 			case 0 :
; 3472 : 				if( option3rand < 4 ) Option3 = 3;	// 옵션

  0028d	83 7d a4 04	 cmp	 DWORD PTR _option3rand$2[ebp], 4
  00291	7d 07		 jge	 SHORT $LN21@gObjMonste
  00293	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3
$LN21@gObjMonste:

; 3473 : 				break;

  0029a	eb 1c		 jmp	 SHORT $LN5@gObjMonste
$LN22@gObjMonste:

; 3474 : 			case 1 :
; 3475 : 				if( option3rand < 8 ) Option3 = 2;	// 옵션

  0029c	83 7d a4 08	 cmp	 DWORD PTR _option3rand$2[ebp], 8
  002a0	7d 07		 jge	 SHORT $LN23@gObjMonste
  002a2	c7 45 d8 02 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 2
$LN23@gObjMonste:

; 3476 : 				break;

  002a9	eb 0d		 jmp	 SHORT $LN5@gObjMonste
$LN24@gObjMonste:

; 3477 : 			case 2 :
; 3478 : 				if( option3rand < 12 ) Option3 = 1;	// 옵션

  002ab	83 7d a4 0c	 cmp	 DWORD PTR _option3rand$2[ebp], 12 ; 0000000cH
  002af	7d 07		 jge	 SHORT $LN25@gObjMonste
  002b1	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 1
$LN25@gObjMonste:
$LN5@gObjMonste:

; 3479 : 				break;
; 3480 : 			}
; 3481 : 			
; 3482 : 			if( DropItem->m_serial )

  002b8	8b 45 c8	 mov	 eax, DWORD PTR _DropItem$[ebp]
  002bb	0f be 48 04	 movsx	 ecx, BYTE PTR [eax+4]
  002bf	85 c9		 test	 ecx, ecx
  002c1	74 53		 je	 SHORT $LN26@gObjMonste

; 3483 : 			{
; 3484 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser, NOption );

  002c3	6a 00		 push	 0
  002c5	6a 00		 push	 0
  002c7	0f b6 45 d7	 movzx	 eax, BYTE PTR _NOption$[ebp]
  002cb	50		 push	 eax
  002cc	8b 4d c4	 mov	 ecx, DWORD PTR _MaxHitUser$[ebp]
  002cf	51		 push	 ecx
  002d0	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option3$[ebp]
  002d4	52		 push	 edx
  002d5	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option2$[ebp]
  002d9	50		 push	 eax
  002da	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  002de	51		 push	 ecx
  002df	f3 0f 2c 55 e4	 cvttss2si edx, DWORD PTR _dur$[ebp]
  002e4	0f b6 c2	 movzx	 eax, dl
  002e7	50		 push	 eax
  002e8	0f b6 4d f0	 movzx	 ecx, BYTE PTR _level$[ebp]
  002ec	51		 push	 ecx
  002ed	8b 55 f4	 mov	 edx, DWORD PTR _type$[ebp]
  002f0	52		 push	 edx
  002f1	0f b6 45 e8	 movzx	 eax, BYTE PTR _y$[ebp]
  002f5	50		 push	 eax
  002f6	0f b6 4d ec	 movzx	 ecx, BYTE PTR _x$[ebp]
  002fa	51		 push	 ecx
  002fb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002fe	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00305	50		 push	 eax
  00306	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00309	8b 11		 mov	 edx, DWORD PTR [ecx]
  0030b	52		 push	 edx
  0030c	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00311	83 c4 38	 add	 esp, 56			; 00000038H

; 3485 : 			}

  00314	eb 52		 jmp	 SHORT $LN27@gObjMonste
$LN26@gObjMonste:

; 3486 : 			else 
; 3487 : 			{
; 3488 : 				MapC[lpObj->MapNumber].MonsterItemDrop(type, level, dur, x, y, Option1, Option2, Option3, NOption, 0, MaxHitUser);			

  00316	6a 00		 push	 0
  00318	8b 45 c4	 mov	 eax, DWORD PTR _MaxHitUser$[ebp]
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	0f b6 4d d7	 movzx	 ecx, BYTE PTR _NOption$[ebp]
  00322	51		 push	 ecx
  00323	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option3$[ebp]
  00327	52		 push	 edx
  00328	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option2$[ebp]
  0032c	50		 push	 eax
  0032d	0f b6 4d e0	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  00331	51		 push	 ecx
  00332	8b 55 e8	 mov	 edx, DWORD PTR _y$[ebp]
  00335	52		 push	 edx
  00336	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  00339	50		 push	 eax
  0033a	51		 push	 ecx
  0033b	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _dur$[ebp]
  00340	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00345	8b 4d f0	 mov	 ecx, DWORD PTR _level$[ebp]
  00348	51		 push	 ecx
  00349	8b 55 f4	 mov	 edx, DWORD PTR _type$[ebp]
  0034c	52		 push	 edx
  0034d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00350	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00357	69 c9 8c 04 05
	00		 imul	 ecx, ecx, 328844
  0035d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00363	e8 00 00 00 00	 call	 ?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z ; MapClass::MonsterItemDrop
$LN27@gObjMonste:

; 3489 : 			}
; 3490 : 		}
; 3491 : 
; 3492 : 	}

  00368	e9 0d fd ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 3493 : }

  0036d	5f		 pop	 edi
  0036e	5e		 pop	 esi
  0036f	5b		 pop	 ebx
  00370	8b e5		 mov	 esp, ebp
  00372	5d		 pop	 ebp
  00373	c3		 ret	 0
?gObjMonsterDieRewardItems@@YAXPAVOBJECTSTRUCT@@0HHHHHHH@Z ENDP ; gObjMonsterDieRewardItems
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterDieGiveItem@@YAXPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv265 = -268						; size = 4
tv256 = -268						; size = 4
tv189 = -268						; size = 4
tv86 = -268						; size = 4
tv746 = -264						; size = 4
tv266 = -264						; size = 4
tv257 = -264						; size = 4
tv190 = -264						; size = 4
tv87 = -264						; size = 4
_y$1 = -196						; size = 4
_x$2 = -192						; size = 4
_MaxHitUser$3 = -188					; size = 4
_money$4 = -184						; size = 4
_y$5 = -180						; size = 4
_x$6 = -176						; size = 4
_MaxHitUser$7 = -172					; size = 4
_optionc$8 = -168					; size = 4
_option3rand$9 = -164					; size = 4
_option2rand$10 = -160					; size = 4
_option1rand$11 = -156					; size = 4
_I$12 = -152						; size = 4
_i$13 = -148						; size = 4
_foundChangeupitem$14 = -144				; size = 4
_ItemDropPer$ = -140					; size = 4
_MaxHitUser$15 = -136					; size = 4
_MaxHitUser$16 = -132					; size = 4
_MaxHitUser$17 = -128					; size = 4
_MaxHitUser$18 = -124					; size = 4
_MaxHitUser$19 = -120					; size = 4
_MaxHitUser$20 = -116					; size = 4
_MaxHitUser$21 = -112					; size = 4
_MaxHitUser$22 = -108					; size = 4
_MaxHitUser$23 = -104					; size = 4
_y$24 = -100						; size = 4
_x$25 = -96						; size = 4
_n$26 = -92						; size = 4
_moneyrate$ = -88					; size = 4
_itemrate$ = -84					; size = 4
_lpMH$27 = -80						; size = 4
_cDropY$28 = -74					; size = 1
_cDropX$29 = -73					; size = 1
_i$30 = -72						; size = 4
_iMaxNumOfRewardItem$31 = -68				; size = 4
_MaxHitUser$32 = -64					; size = 4
_DropItem$ = -60					; size = 4
_n$ = -56						; size = 4
_item_drop$ = -52					; size = 4
_NOption$ = -45						; size = 1
_Option3$ = -44						; size = 4
_Option2$ = -40						; size = 4
_Option1$ = -36						; size = 4
_dur$ = -32						; size = 4
_y$ = -28						; size = 4
_x$ = -24						; size = 4
_level$ = -20						; size = 4
_type$ = -16						; size = 4
_DropItemNum$ = -12					; size = 4
_ExtDropPer$ = -8					; size = 4
_store_count$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjMonsterDieGiveItem@@YAXPAVOBJECTSTRUCT@@0@Z PROC	; gObjMonsterDieGiveItem, COMDAT

; 3499 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 3500 : 	int store_count=0;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _store_count$[ebp], 0

; 3501 : 	int ExtDropPer=0;

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ExtDropPer$[ebp], 0

; 3502 : 	int DropItemNum = 0;

  0001a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _DropItemNum$[ebp], 0

; 3503 : 	int type, level, x, y;
; 3504 : 	float dur=0;

  00021	0f 57 c0	 xorps	 xmm0, xmm0
  00024	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 3505 : 	int Option1 = 0;

  00029	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 3506 : 	int Option2 = 0;

  00030	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 3507 : 	int Option3 = 0;

  00037	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 3508 : 	BYTE NOption= 0;

  0003e	c6 45 d3 00	 mov	 BYTE PTR _NOption$[ebp], 0

; 3509 : 	BOOL item_drop=0;

  00042	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0

; 3510 : 	int n;
; 3511 : 	CItem * DropItem=NULL;

  00049	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _DropItem$[ebp], 0

; 3512 : 	
; 3513 : #ifdef CHN_PLAYTIME_LIMIT_SYSTEM_20050818	// 중국변경> . 전체 몬스터 아이템 드롭 확률을 조정함.
; 3514 : 	if (g_bChnPlayTimeLimitOn) {
; 3515 : 		INT iItemDrapRate = 100;
; 3516 : #ifdef MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 3517 : 		if( lpTargetObj->m_iVerifyType != PLAYTIME_LIMIT_VERIFY_ADULT )
; 3518 : 		{
; 3519 : 			if (lpTargetObj->m_iPlayTimeLimit >= 5*60*60)
; 3520 : 			{
; 3521 : 				iItemDrapRate = g_iChnPlayTimeLimitLevel2ItemDrop;
; 3522 : 			}
; 3523 : 			else if (lpTargetObj->m_iPlayTimeLimit >= 3*60*60) {
; 3524 : 				iItemDrapRate = g_iChnPlayTimeLimitLevel1ItemDrop;
; 3525 : 			}
; 3526 : 		}
; 3527 : #else
; 3528 : 		if (lpTargetObj->m_iPlayTimeLimit >= 5*60*60)
; 3529 : 		{
; 3530 : 			iItemDrapRate = g_iChnPlayTimeLimitLevel2ItemDrop;
; 3531 : 		}
; 3532 : 		else if (lpTargetObj->m_iPlayTimeLimit >= 3*60*60) {
; 3533 : 			iItemDrapRate = g_iChnPlayTimeLimitLevel1ItemDrop;
; 3534 : 		}
; 3535 : #endif // CHN_PLAYTIME_LIMIT_SYSTEM_20050818
; 3536 : 		
; 3537 : 		if (!iItemDrapRate)
; 3538 : 			return;
; 3539 : 
; 3540 : 		if (rand()%100 >= iItemDrapRate) {	// 중국추가> . 돈 드롭액수만 50%
; 3541 : 
; 3542 : 			// 돈을 떨어트린다.	
; 3543 : 			if(rand()%2) {
; 3544 : 				int x, y;
; 3545 : 				float money;
; 3546 : 				
; 3547 : 				x    = lpObj->X;
; 3548 : 				y    = lpObj->Y;
; 3549 : 				
; 3550 : 				money = (float)lpObj->Money;
; 3551 : 				
; 3552 : 				// 몬스터 죽였을때 얻는돈
; 3553 : 				money += money/100*(lpTargetObj->MonsterDieGetMoney*(iItemDrapRate/100));
; 3554 : 				money += 7;
; 3555 : 
; 3556 : #ifdef FOR_NEW_TESTSERVER			
; 3557 : 				money *= 3;		// 젠 드롭 3배
; 3558 : #endif
; 3559 : 				
; 3560 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 3561 : 				if( CHECK_DEVILSQUARE(lpObj->MapNumber) )
; 3562 : #else
; 3563 : 				if( lpObj->MapNumber == 9 )
; 3564 : #endif
; 3565 : 				{	// 악마의 광장에서는 돈을 누적한다
; 3566 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3567 : #ifdef MODIFY_MAXHITUSER_BUG_FIX_20070711
; 3568 : 					if(MaxHitUser == -1)
; 3569 : 						return;
; 3570 : #endif
; 3571 : 					gObj[MaxHitUser].m_nEventMoney += (int)money;				
; 3572 : 				}
; 3573 : 				else
; 3574 : 				{
; 3575 : 					MapC[lpObj->MapNumber].MoneyItemDrop((int)money, x ,y);
; 3576 : 				}
; 3577 : 			}
; 3578 : 			return;
; 3579 : 		}
; 3580 : 	}
; 3581 : #endif
; 3582 : 	
; 3583 : #ifdef VTM_PLAYTIME_LIMIT_SYSTEM_20060626	// 베트남> . 전체 몬스터 아이템 드롭 확률을 조정함.
; 3584 : 	if (g_bVtmPlayTimeLimitOn) 
; 3585 : 	{
; 3586 : 		INT iItemDrapRate = 100;
; 3587 : 		if (lpTargetObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel2Time * 60) 
; 3588 : 		{
; 3589 : 			iItemDrapRate = g_iVtmPlayTimeLimitLevel2ItemDrop;
; 3590 : 		}
; 3591 : 		else if (lpTargetObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel1Time * 60) 
; 3592 : 		{
; 3593 : 			iItemDrapRate = g_iVtmPlayTimeLimitLevel1ItemDrop;
; 3594 : 		}
; 3595 : 		
; 3596 : 		if (!iItemDrapRate)
; 3597 : 			return;
; 3598 : 
; 3599 : 		if (rand()%100 >= iItemDrapRate) 
; 3600 : 		{	// 중국추가> . 돈 드롭액수만 50%
; 3601 : 
; 3602 : 			// 돈을 떨어트린다.	
; 3603 : 			if(rand()%2) {
; 3604 : 				int x, y;
; 3605 : 				float money;
; 3606 : 				
; 3607 : 				x    = lpObj->X;
; 3608 : 				y    = lpObj->Y;
; 3609 : 				
; 3610 : 				money = (float)lpObj->Money;
; 3611 : 				
; 3612 : 				// 몬스터 죽였을때 얻는돈
; 3613 : 				money += money/100*(lpTargetObj->MonsterDieGetMoney*(iItemDrapRate/100));
; 3614 : 				money += 7;
; 3615 : 
; 3616 : #ifdef FOR_NEW_TESTSERVER			
; 3617 : 				money *= 3;		// 젠 드롭 3배
; 3618 : #endif
; 3619 : 				
; 3620 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 3621 : 				if( CHECK_DEVILSQUARE(lpObj->MapNumber) )
; 3622 : #else
; 3623 : 				if( lpObj->MapNumber == 9 )
; 3624 : #endif
; 3625 : 				{	// 악마의 광장에서는 돈을 누적한다
; 3626 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3627 : #ifdef MODIFY_MAXHITUSER_BUG_FIX_20070711
; 3628 : 					if(MaxHitUser == -1)
; 3629 : 						return;
; 3630 : #endif
; 3631 : 					gObj[MaxHitUser].m_nEventMoney += (int)money;				
; 3632 : 				}
; 3633 : 				else
; 3634 : 				{
; 3635 : 					MapC[lpObj->MapNumber].MoneyItemDrop((int)money, x ,y);
; 3636 : 				}
; 3637 : 			}
; 3638 : 			return;
; 3639 : 		}
; 3640 : 	}
; 3641 : #endif
; 3642 : 	
; 3643 : #ifdef ADD_NEWPVP_PKFIELD
; 3644 : 	if (g_NewPVP.IsVulcanusMonster(lpObj->Class))
; 3645 : 	{
; 3646 : 		// 아이템은 누적 데미지의 합이 가장 큰 캐릭터에게 지급된다.
; 3647 : 		int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3648 : 		if (g_NewPVP.DropItem(lpTargetObj, lpObj->MapNumber, lpObj->X, lpObj->Y, iMaxHitUser))
; 3649 : 			return;
; 3650 : 	}
; 3651 : #endif // ADD_NEWPVP_PKFIELD
; 3652 : 	
; 3653 : #ifdef UPDATE_NEWYEAR_LUCKYBAG_MONSTER_20070131	// 설날복주머니일 경우 아이템 드럽
; 3654 : 	if( lpObj->Class == MON_NEWYEAR_LUCKYBAG )
; 3655 : 	{
; 3656 : 		// 아이템은 누적 데미지의 합이 가장 큰 캐릭터에게 지급된다.
; 3657 : 		int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );	
; 3658 : 
; 3659 : 		//LogAddTD();
; 3660 : 
; 3661 : 		UCHAR cDropX = lpObj->X;
; 3662 : 		UCHAR cDropY = lpObj->Y;
; 3663 : 
; 3664 : 		//if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 2, 2, 2 ) )
; 3665 : 		//{
; 3666 : 		//	cDropX = (BYTE)lpObj->X;
; 3667 : 		//	cDropY = (BYTE)lpObj->Y;
; 3668 : 		//}
; 3669 : 		
; 3670 : 		NewYearLuckyBagItemBagOpen(lpTargetObj, lpObj->MapNumber, cDropX, cDropY);
; 3671 : 		return;
; 3672 : 	}
; 3673 : #endif
; 3674 : 
; 3675 : #ifdef ADD_CRYWOLF_MONSTER_ITEMDROP_20060404	// 크라이울프 다크엘프 아이템 드랍
; 3676 : 	if( lpObj->Class == CRYWOLF_MON_DARKELF )
; 3677 : 	{
; 3678 : 		if( g_bCrywolfMonsterDarkElfItemDrop )
; 3679 : 		{		
; 3680 : 			int ItemDropRate = rand() % 10000;
; 3681 : 			if( ItemDropRate <= g_iCrywolfMonsterDarkElfItemDropRate )
; 3682 : 			{			
; 3683 : 				// 아이템은 누적 데미지의 합이 가장 큰 캐릭터에게 지급된다.
; 3684 : 				int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );		
; 3685 : 				
; 3686 : 				LogAddTD("[ Crywolf ][Reward] Monster Dark Elf ItemDrop MaxHitUser [%s][%s]", lpTargetObj->AccountID, lpTargetObj->Name );
; 3687 : 
; 3688 : 				UCHAR cDropX = lpObj->X;
; 3689 : 				UCHAR cDropY = lpObj->Y;
; 3690 : 
; 3691 : 				if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 4, 4, 10 ) )
; 3692 : 				{
; 3693 : 					cDropX = (BYTE)lpObj->X;
; 3694 : 					cDropY = (BYTE)lpObj->Y;
; 3695 : 				}
; 3696 : 
; 3697 : 				CrywolfDarkElfItemBagOpen( lpTargetObj, lpObj->MapNumber, cDropX, cDropY );
; 3698 : 			}
; 3699 : 		}
; 3700 : 		
; 3701 : 		return;
; 3702 : 	}
; 3703 : #endif	// #ifdef ADD_CRYWOLF_MONSTER_ITEMDROP_20060404
; 3704 : 
; 3705 : #ifdef ADD_CRYWOLF_MONSTER_ITEMDROP_20060404		// 크라이울프 보스몬스터 발가스 아이템 드랍
; 3706 : 	if( lpObj->Class == CRYWOLF_MON_BALGARS )
; 3707 : 	{
; 3708 : 		if( g_bCrywolfBossMonsterItemDrop )
; 3709 : 		{		
; 3710 : 			int ItemDropRate = rand() % 10000;
; 3711 : 			if( ItemDropRate <= g_iCrywolfBossMonsterItemDropRate )
; 3712 : 			{
; 3713 : 				// 아이템은 누적 데미지의 합이 가장 큰 캐릭터에게 지급된다.
; 3714 : 				int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );		
; 3715 : 				
; 3716 : 				LogAddTD("[ Crywolf ][Reward] Boss Monster ItemDrop MaxHitUser [%s][%s]", lpTargetObj->AccountID, lpTargetObj->Name );
; 3717 : 
; 3718 : 				UCHAR cDropX = lpObj->X;
; 3719 : 				UCHAR cDropY = lpObj->Y;
; 3720 : 
; 3721 : 				if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 4, 4, 10 ) )
; 3722 : 				{
; 3723 : 					cDropX = (BYTE)lpObj->X;
; 3724 : 					cDropY = (BYTE)lpObj->Y;
; 3725 : 				}
; 3726 : 
; 3727 : 				CrywolfBossMonsterItemBagOpen( lpTargetObj, lpObj->MapNumber, cDropX, cDropY );
; 3728 : 			}
; 3729 : 		}
; 3730 : 		return;
; 3731 : 	}
; 3732 : #endif	// #ifdef ADD_CRYWOLF_MONSTER_ITEMDROP_20060404
; 3733 : 
; 3734 : #ifdef KANTURU_MONSTER_ITEMDROP_20060807	// 칸투르 몬스터 아이템 드랍
; 3735 : 	// 마야 손
; 3736 : 	if( lpObj->Class == KANTURU_MONSTER_MAYA_LEFTHAND || lpObj->Class == KANTURU_MONSTER_MAYA_RIGHTHAND )
; 3737 : 	{
; 3738 : 		if( g_bKanturuMayaHandItemDrop )
; 3739 : 		{		
; 3740 : 			int ItemDropRate = rand() % 10000;
; 3741 : 			if( ItemDropRate <= g_iKanturuMayaHandItemDropRate )
; 3742 : 			{			
; 3743 : 				// 아이템은 누적 데미지의 합이 가장 큰 캐릭터에게 지급된다.
; 3744 : 				int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );		
; 3745 : 				
; 3746 : 				LogAddTD("[ KANTURU ][ Reward ] MayaHand ItemDrop MaxHitUser [%s][%s]", lpTargetObj->AccountID, lpTargetObj->Name );
; 3747 : 
; 3748 : 				UCHAR cDropX = lpObj->X;
; 3749 : 				UCHAR cDropY = lpObj->Y;
; 3750 : 
; 3751 : 				if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 4, 4, 10 ) )
; 3752 : 				{
; 3753 : 					cDropX = (BYTE)lpObj->X;
; 3754 : 					cDropY = (BYTE)lpObj->Y;
; 3755 : 				}
; 3756 : 
; 3757 : 				KanturuMayaHandItemBagOpen( lpTargetObj, lpObj->MapNumber, cDropX, cDropY );
; 3758 : 			}
; 3759 : 		}
; 3760 : 		
; 3761 : 		return;
; 3762 : 	}
; 3763 : 
; 3764 : 	// 나이트메어
; 3765 : 	if( lpObj->Class == KANTURU_MONSTER_NIGHTMARE )
; 3766 : 	{
; 3767 : 		if( g_bKanturuNightmareItemDrop )
; 3768 : 		{		
; 3769 : 			int ItemDropRate = rand() % 10000;
; 3770 : 			if( ItemDropRate <= g_iKanturuNightmareItemDropRate )
; 3771 : 			{			
; 3772 : 				// 아이템은 누적 데미지의 합이 가장 큰 캐릭터에게 지급된다.
; 3773 : 				int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );		
; 3774 : 				
; 3775 : 				LogAddTD("[ KANTURU ][ Reward ] Nightmare ItemDrop MaxHitUser [%s][%s]", lpTargetObj->AccountID, lpTargetObj->Name );
; 3776 : 
; 3777 : 				UCHAR cDropX = lpObj->X;
; 3778 : 				UCHAR cDropY = lpObj->Y;
; 3779 : 
; 3780 : 				if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 4, 4, 10 ) )
; 3781 : 				{
; 3782 : 					cDropX = (BYTE)lpObj->X;
; 3783 : 					cDropY = (BYTE)lpObj->Y;
; 3784 : 				}
; 3785 : 
; 3786 : 				KanturuNightmareItemBagOpen( lpTargetObj, lpObj->MapNumber, cDropX, cDropY );
; 3787 : 			}
; 3788 : 		}
; 3789 : 		
; 3790 : 		return;
; 3791 : 	}
; 3792 : #endif	// #ifdef KANTURU_MONSTER_ITEMDROP_20060807
; 3793 : 
; 3794 : #ifdef ADD_RAKLION_20080408
; 3795 : 	if( lpObj->Class == RAKLION_SELUPAN && lpObj->Connected==CSS_GAMEPLAYING )
; 3796 : 	{
; 3797 : 		if( g_bRaklionSelupanItemDrop )
; 3798 : 		{		
; 3799 : 			int ItemDropRate = rand() % 10000;
; 3800 : 			if( ItemDropRate <= g_iRaklionSelupanItemDropRate )
; 3801 : 			{
; 3802 : 				// 아이템은 누적 데미지의 합이 가장 큰 캐릭터에게 지급된다.
; 3803 : 				int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );		
; 3804 : 				
; 3805 : 				LogAddTD("[ RAKLION ][ Reward ] Raklion ItemDrop MaxHitUser [%s][%s]", lpTargetObj->AccountID, lpTargetObj->Name );
; 3806 : 				
; 3807 : 				UCHAR cDropX = lpObj->X;
; 3808 : 				UCHAR cDropY = lpObj->Y;
; 3809 : 				
; 3810 : 				for( INT iCount=0; iCount<10; ++iCount )
; 3811 : 				{
; 3812 : 					if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 2, 2, 10 ) )
; 3813 : 					{
; 3814 : 						cDropX = (BYTE)lpObj->X;
; 3815 : 						cDropY = (BYTE)lpObj->Y;
; 3816 : 					}
; 3817 : 					
; 3818 : 					RaklionSelupanItemBagOpen( lpTargetObj, lpObj->MapNumber, cDropX, cDropY );
; 3819 : 				}
; 3820 : 			}
; 3821 : 		}
; 3822 : 		
; 3823 : 		return;
; 3824 : 	}
; 3825 : #endif // ADD_RAKLION_20080408
; 3826 : 	
; 3827 : #ifdef CASTLE_NPC_DONT_DROP_ITEM_20050517	// 공성전 NPC들은 아이템을 떨구지 않는다.
; 3828 : 	if (lpObj->m_btCsNpcType != CS_NPC_TYPE_NONE)
; 3829 : 		return;
; 3830 : #endif
; 3831 : 
; 3832 : #ifdef ADD_NEW_CASTLE_HUNTZONE_REWARD_01_20050303
; 3833 : 	if( lpObj->Class == 295 ) // 성사냥터 보스몹 에로힘.
; 3834 : 	{
; 3835 : 		// Item Looting 설정
; 3836 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3837 : 
; 3838 : 		INT iMaxNumOfRewardItem = 1;
; 3839 : 		for( int i=0; i<iMaxNumOfRewardItem; i++)
; 3840 : 		{
; 3841 : 			UCHAR cDropX = lpObj->X;
; 3842 : 			UCHAR cDropY = lpObj->Y;
; 3843 : 
; 3844 : 			LogAddTD("[Castle HuntZone] Boss Monster ItemDrop MaxHitUser [%d][%s][%s]", i, lpTargetObj->AccountID, lpTargetObj->Name );
; 3845 : 
; 3846 : 			if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 4, 4, 10 ) )
; 3847 : 			{
; 3848 : 				cDropX = (BYTE)lpObj->X;
; 3849 : 				cDropY = (BYTE)lpObj->Y;
; 3850 : 			}
; 3851 : 
; 3852 : 			if( i == 0 ) // 한개만 떨어질 경우
; 3853 : 			{
; 3854 : 				cDropX = (BYTE)lpObj->X;
; 3855 : 				cDropY = (BYTE)lpObj->Y;
; 3856 : 			}
; 3857 : 			
; 3858 : 			CastleHuntZoneBossRewardOpen( lpTargetObj, lpObj->MapNumber, cDropX, cDropY);
; 3859 : 
; 3860 : 		}
; 3861 : 
; 3862 : 		return;
; 3863 : 	}
; 3864 : #endif
; 3865 : 
; 3866 : #ifdef MODIFY_KUNDUN_REWARD_01_20040915
; 3867 : 	// 쿤둔이 죽었을때 아이템을 떨군다.
; 3868 : 	if( lpObj->Class == 275 )

  00050	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0005a	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  00060	0f 85 6f 03 00
	00		 jne	 $LN16@gObjMonste

; 3869 : 	{
; 3870 : 		// 0. 쿤둔이 죽었다는 로그를 기록한다.
; 3871 : 		LogAddTD("[★★Kundun EVENT] Kundun die, Killer [%s][%s]", lpTargetObj->AccountID, lpTargetObj->Name );

  00066	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00069	83 c0 73	 add	 eax, 115		; 00000073H
  0006c	50		 push	 eax
  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00070	83 c1 68	 add	 ecx, 104		; 00000068H
  00073	51		 push	 ecx
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3872 : 		KUNDUN_EVENT_LOG.Output("[★★Kundun EVENT] Kundun die, Killer [%s][%s]", lpTargetObj->AccountID, lpTargetObj->Name );

  00082	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00085	83 c0 73	 add	 eax, 115		; 00000073H
  00088	50		 push	 eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0008c	83 c1 68	 add	 ecx, 104		; 00000068H
  0008f	51		 push	 ecx
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5@
  00095	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  0009a	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0009f	83 c4 10	 add	 esp, 16			; 00000010H

; 3873 : 
; 3874 : 		// 1. 현재 칼리마6에 있는 모든 유저들을 로그로 기록한다.
; 3875 : 		// MODIFY_KUNDUN_LOG_20060201
; 3876 : 		// 20060201 로그 주석 처리 (RKFKA)
; 3877 : //		for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)
; 3878 : //		{
; 3879 : //			if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) )
; 3880 : //			{
; 3881 : //				if( gObj[n].MapNumber == MAP_INDEX_KALIMA6 )
; 3882 : //				{
; 3883 : //					LogAddTD("[★Kundun EVENT] In KALIMA(6), User List [%s][%s]", gObj[n].AccountID, gObj[n].Name );
; 3884 : //					KUNDUN_EVENT_LOG.Output("[★Kundun EVENT] In KALIMA(6), User List [%s][%s]", gObj[n].AccountID, gObj[n].Name );
; 3885 : //				}
; 3886 : //			}
; 3887 : //		}
; 3888 : 
; 3889 : 
; 3890 : 		// Item Looting 설정
; 3891 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  000a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  000ab	83 c4 04	 add	 esp, 4
  000ae	89 45 c0	 mov	 DWORD PTR _MaxHitUser$32[ebp], eax

; 3892 : 		
; 3893 : #ifdef CHANGE_KUNDUN_SETTING_01_20050221
; 3894 : 		INT iMaxNumOfRewardItem = 3;

  000b1	c7 45 bc 03 00
	00 00		 mov	 DWORD PTR _iMaxNumOfRewardItem$31[ebp], 3

; 3895 : 		for( int i=0; i<iMaxNumOfRewardItem; i++)

  000b8	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _i$30[ebp], 0
  000bf	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  000c1	8b 45 b8	 mov	 eax, DWORD PTR _i$30[ebp]
  000c4	83 c0 01	 add	 eax, 1
  000c7	89 45 b8	 mov	 DWORD PTR _i$30[ebp], eax
$LN4@gObjMonste:
  000ca	8b 45 b8	 mov	 eax, DWORD PTR _i$30[ebp]
  000cd	3b 45 bc	 cmp	 eax, DWORD PTR _iMaxNumOfRewardItem$31[ebp]
  000d0	0f 8d fa 02 00
	00		 jge	 $LN3@gObjMonste

; 3896 : #else
; 3897 : 		for( int i=0; i<5; i++ )
; 3898 : #endif
; 3899 : 		{
; 3900 : 			UCHAR cDropX = lpObj->X;

  000d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d9	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  000df	88 4d b7	 mov	 BYTE PTR _cDropX$29[ebp], cl

; 3901 : 			UCHAR cDropY = lpObj->Y;

  000e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e5	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  000eb	88 4d b6	 mov	 BYTE PTR _cDropY$28[ebp], cl

; 3902 : 			
; 3903 : 			if( CHECK_LIMIT(MaxHitUser, MAX_OBJECT) )

  000ee	83 7d c0 00	 cmp	 DWORD PTR _MaxHitUser$32[ebp], 0
  000f2	7d 0c		 jge	 SHORT $LN110@gObjMonste
  000f4	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv87[ebp], 0
  000fe	eb 2b		 jmp	 SHORT $LN111@gObjMonste
$LN110@gObjMonste:
  00100	81 7d c0 e7 1c
	00 00		 cmp	 DWORD PTR _MaxHitUser$32[ebp], 7399 ; 00001ce7H
  00107	7e 0c		 jle	 SHORT $LN108@gObjMonste
  00109	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv86[ebp], 0
  00113	eb 0a		 jmp	 SHORT $LN109@gObjMonste
$LN108@gObjMonste:
  00115	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv86[ebp], 1
$LN109@gObjMonste:
  0011f	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv86[ebp]
  00125	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv87[ebp], eax
$LN111@gObjMonste:
  0012b	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR tv87[ebp], 0
  00132	74 72		 je	 SHORT $LN17@gObjMonste

; 3904 : 			{
; 3905 : 				LogAddTD("[★Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser [%d][%s][%s]", i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name );

  00134	69 45 c0 a0 1b
	00 00		 imul	 eax, DWORD PTR _MaxHitUser$32[ebp], 7072
  0013b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00141	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00145	52		 push	 edx
  00146	69 45 c0 a0 1b
	00 00		 imul	 eax, DWORD PTR _MaxHitUser$32[ebp], 7072
  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00153	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00157	52		 push	 edx
  00158	8b 45 b8	 mov	 eax, DWORD PTR _i$30[ebp]
  0015b	50		 push	 eax
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5@
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00167	83 c4 10	 add	 esp, 16			; 00000010H

; 3906 : 				KUNDUN_EVENT_LOG.Output("[★Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser [%d][%s][%s]", i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name );

  0016a	69 45 c0 a0 1b
	00 00		 imul	 eax, DWORD PTR _MaxHitUser$32[ebp], 7072
  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00177	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0017b	52		 push	 edx
  0017c	69 45 c0 a0 1b
	00 00		 imul	 eax, DWORD PTR _MaxHitUser$32[ebp], 7072
  00183	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00189	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0018d	52		 push	 edx
  0018e	8b 45 b8	 mov	 eax, DWORD PTR _i$30[ebp]
  00191	50		 push	 eax
  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5@
  00197	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  0019c	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  001a1	83 c4 14	 add	 esp, 20			; 00000014H

; 3907 : 
; 3908 : 				// MODIFY_KUNDUN_LOG_20060201
; 3909 : 				//LogAddTD("[★Kundun EVENT] In KALIMA(6), ItemDrop MaxHitUser [%d][%s][%s]", i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name );
; 3910 : 				//KUNDUN_EVENT_LOG.Output("[★Kundun EVENT] In KALIMA(6), ItemDrop MaxHitUser [%d][%s][%s]", i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name );
; 3911 : 			}

  001a4	eb 44		 jmp	 SHORT $LN18@gObjMonste
$LN17@gObjMonste:

; 3912 : 			else
; 3913 : 			{
; 3914 : 				LogAddTD("[★Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser [%d][%s][%s]", i, lpTargetObj->AccountID, lpTargetObj->Name );

  001a6	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001a9	83 c0 73	 add	 eax, 115		; 00000073H
  001ac	50		 push	 eax
  001ad	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  001b0	83 c1 68	 add	 ecx, 104		; 00000068H
  001b3	51		 push	 ecx
  001b4	8b 55 b8	 mov	 edx, DWORD PTR _i$30[ebp]
  001b7	52		 push	 edx
  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5@
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c3	83 c4 10	 add	 esp, 16			; 00000010H

; 3915 : 				KUNDUN_EVENT_LOG.Output("[★Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser [%d][%s][%s]", i, lpTargetObj->AccountID, lpTargetObj->Name );

  001c6	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001c9	83 c0 73	 add	 eax, 115		; 00000073H
  001cc	50		 push	 eax
  001cd	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  001d0	83 c1 68	 add	 ecx, 104		; 00000068H
  001d3	51		 push	 ecx
  001d4	8b 55 b8	 mov	 edx, DWORD PTR _i$30[ebp]
  001d7	52		 push	 edx
  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5@
  001dd	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  001e2	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  001e7	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@gObjMonste:

; 3916 : 
; 3917 : 				// MODIFY_KUNDUN_LOG_20060201
; 3918 : 				//LogAddTD("[★Kundun EVENT] In KALIMA(6), ItemDrop MaxHitUser [%d][%s][%s]", i, lpTargetObj->AccountID, lpTargetObj->Name );
; 3919 : 				//KUNDUN_EVENT_LOG.Output("[★Kundun EVENT] In KALIMA(6), ItemDrop MaxHitUser [%d][%s][%s]", i, lpTargetObj->AccountID, lpTargetObj->Name );
; 3920 : 			}
; 3921 : 			
; 3922 : 			if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 4, 4, 10 ) )

  001ea	6a 0a		 push	 10			; 0000000aH
  001ec	6a 04		 push	 4
  001ee	6a 04		 push	 4
  001f0	8d 45 b6	 lea	 eax, DWORD PTR _cDropY$28[ebp]
  001f3	50		 push	 eax
  001f4	8d 4d b7	 lea	 ecx, DWORD PTR _cDropX$29[ebp]
  001f7	51		 push	 ecx
  001f8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001fb	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ; gObjGetRandomItemDropLocation
  00208	83 c4 18	 add	 esp, 24			; 00000018H
  0020b	85 c0		 test	 eax, eax
  0020d	75 18		 jne	 SHORT $LN19@gObjMonste

; 3923 : 			{
; 3924 : 				cDropX = (BYTE)lpObj->X;

  0020f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00212	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00218	88 4d b7	 mov	 BYTE PTR _cDropX$29[ebp], cl

; 3925 : 				cDropY = (BYTE)lpObj->Y;

  0021b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0021e	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00224	88 4d b6	 mov	 BYTE PTR _cDropY$28[ebp], cl
$LN19@gObjMonste:

; 3926 : 			}
; 3927 : 			
; 3928 : 			if( lpObj->Class == 275 )

  00227	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00231	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  00237	75 75		 jne	 SHORT $LN21@gObjMonste

; 3929 : 			{
; 3930 : 				if( rand()%10000 < (g_GlobalConfig.m_iAncientDrop*(lpObj->m_wAncientDropRate/100.0f)) )

  00239	e8 00 00 00 00	 call	 _rand
  0023e	99		 cdq
  0023f	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00244	f7 f9		 idiv	 ecx
  00246	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  0024a	f3 0f 2a 0d d8
	00 00 00	 cvtsi2ss xmm1, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+216
  00252	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00255	0f b7 82 34 1a
	00 00		 movzx	 eax, WORD PTR [edx+6708]
  0025c	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  00260	f3 0f 5e 15 00
	00 00 00	 divss	 xmm2, DWORD PTR __real@42c80000
  00268	f3 0f 59 ca	 mulss	 xmm1, xmm2
  0026c	0f 2f c8	 comiss	 xmm1, xmm0
  0026f	76 3d		 jbe	 SHORT $LN21@gObjMonste

; 3931 : 				{
; 3932 : 					// Type 1일 경우 쿤둔을 죽인것에 대한 보상!
; 3933 : #ifdef MODIFY_KUNDUN_ITEM_DROP_MAP_20060216
; 3934 : 					MakeRewardSetItem( MaxHitUser, cDropX, cDropY, 1, lpObj->MapNumber );
; 3935 : #else
; 3936 : 					MakeRewardSetItem( MaxHitUser, cDropX, cDropY, 1 );

  00271	6a 01		 push	 1
  00273	0f b6 45 b6	 movzx	 eax, BYTE PTR _cDropY$28[ebp]
  00277	50		 push	 eax
  00278	0f b6 4d b7	 movzx	 ecx, BYTE PTR _cDropX$29[ebp]
  0027c	51		 push	 ecx
  0027d	8b 55 c0	 mov	 edx, DWORD PTR _MaxHitUser$32[ebp]
  00280	52		 push	 edx
  00281	e8 00 00 00 00	 call	 ?MakeRewardSetItem@@YAXHEEH@Z ; MakeRewardSetItem
  00286	83 c4 10	 add	 esp, 16			; 00000010H

; 3937 : #endif // #ifdef MODIFY_KUNDUN_ITEM_DROP_MAP_20060216
; 3938 : 					LogAddTD("[○Kundun EVENT] Drop SetItem ");

  00289	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5@
  0028e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00294	83 c4 04	 add	 esp, 4

; 3939 : 					KUNDUN_EVENT_LOG.Output("[○Kundun EVENT] Drop SetItem ");

  00297	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5@
  0029c	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  002a1	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  002a6	83 c4 08	 add	 esp, 8

; 3940 : 					continue;

  002a9	e9 13 fe ff ff	 jmp	 $LN2@gObjMonste
$LN21@gObjMonste:

; 3941 : 				}
; 3942 : 			}
; 3943 : 			
; 3944 : 			// 쿤둔 (칼리마7) 일 경우는 무조건 아이템이 드롭된다.
; 3945 : 			if( CHECK_LIMIT(MaxHitUser, MAX_OBJECT) )

  002ae	83 7d c0 00	 cmp	 DWORD PTR _MaxHitUser$32[ebp], 0
  002b2	7d 0c		 jge	 SHORT $LN114@gObjMonste
  002b4	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv190[ebp], 0
  002be	eb 2b		 jmp	 SHORT $LN115@gObjMonste
$LN114@gObjMonste:
  002c0	81 7d c0 e7 1c
	00 00		 cmp	 DWORD PTR _MaxHitUser$32[ebp], 7399 ; 00001ce7H
  002c7	7e 0c		 jle	 SHORT $LN112@gObjMonste
  002c9	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv189[ebp], 0
  002d3	eb 0a		 jmp	 SHORT $LN113@gObjMonste
$LN112@gObjMonste:
  002d5	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv189[ebp], 1
$LN113@gObjMonste:
  002df	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv189[ebp]
  002e5	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv190[ebp], eax
$LN115@gObjMonste:
  002eb	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR tv190[ebp], 0
  002f2	74 72		 je	 SHORT $LN22@gObjMonste

; 3946 : 			{
; 3947 : 				// ADD_KUNDUN_ITEM_DROP_LOG_20060309
; 3948 : 				LogAddTD("[○Kundun EVENT] Drop Item [%d][%s][%s]", i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name );				

  002f4	69 45 c0 a0 1b
	00 00		 imul	 eax, DWORD PTR _MaxHitUser$32[ebp], 7072
  002fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00301	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00305	52		 push	 edx
  00306	69 45 c0 a0 1b
	00 00		 imul	 eax, DWORD PTR _MaxHitUser$32[ebp], 7072
  0030d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00313	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00317	52		 push	 edx
  00318	8b 45 b8	 mov	 eax, DWORD PTR _i$30[ebp]
  0031b	50		 push	 eax
  0031c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN@
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00327	83 c4 10	 add	 esp, 16			; 00000010H

; 3949 : 				KUNDUN_EVENT_LOG.Output("[○Kundun EVENT] Drop Item [%d][%s][%s]", i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name );

  0032a	69 45 c0 a0 1b
	00 00		 imul	 eax, DWORD PTR _MaxHitUser$32[ebp], 7072
  00331	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00337	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0033b	52		 push	 edx
  0033c	69 45 c0 a0 1b
	00 00		 imul	 eax, DWORD PTR _MaxHitUser$32[ebp], 7072
  00343	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00349	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0034d	52		 push	 edx
  0034e	8b 45 b8	 mov	 eax, DWORD PTR _i$30[ebp]
  00351	50		 push	 eax
  00352	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN@
  00357	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  0035c	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00361	83 c4 14	 add	 esp, 20			; 00000014H

; 3950 : 			}

  00364	eb 44		 jmp	 SHORT $LN23@gObjMonste
$LN22@gObjMonste:

; 3951 : 			else
; 3952 : 			{
; 3953 : 				// ADD_KUNDUN_ITEM_DROP_LOG_20060309
; 3954 : 				LogAddTD("[○Kundun EVENT] Drop Item [%d][%s][%s]", i, lpTargetObj->AccountID, lpTargetObj->Name );

  00366	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00369	83 c0 73	 add	 eax, 115		; 00000073H
  0036c	50		 push	 eax
  0036d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00370	83 c1 68	 add	 ecx, 104		; 00000068H
  00373	51		 push	 ecx
  00374	8b 55 b8	 mov	 edx, DWORD PTR _i$30[ebp]
  00377	52		 push	 edx
  00378	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN@
  0037d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00383	83 c4 10	 add	 esp, 16			; 00000010H

; 3955 : 				KUNDUN_EVENT_LOG.Output("[○Kundun EVENT] Drop Item [%d][%s][%s]", i, lpTargetObj->AccountID, lpTargetObj->Name );

  00386	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00389	83 c0 73	 add	 eax, 115		; 00000073H
  0038c	50		 push	 eax
  0038d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00390	83 c1 68	 add	 ecx, 104		; 00000068H
  00393	51		 push	 ecx
  00394	8b 55 b8	 mov	 edx, DWORD PTR _i$30[ebp]
  00397	52		 push	 edx
  00398	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN@
  0039d	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  003a2	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  003a7	83 c4 14	 add	 esp, 20			; 00000014H
$LN23@gObjMonste:

; 3956 : 			}
; 3957 : 
; 3958 : 			// MODIFY_ITEM_DROP_MAP_OF_EROHIM_KUNDUN_20050610
; 3959 : 			KundunEventItemBoxOpen( lpTargetObj, lpObj->MapNumber, cDropX, cDropY);

  003aa	0f b6 45 b6	 movzx	 eax, BYTE PTR _cDropY$28[ebp]
  003ae	50		 push	 eax
  003af	0f b6 4d b7	 movzx	 ecx, BYTE PTR _cDropX$29[ebp]
  003b3	51		 push	 ecx
  003b4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003b7	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  003be	50		 push	 eax
  003bf	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  003c2	51		 push	 ecx
  003c3	e8 00 00 00 00	 call	 ?KundunEventItemBoxOpen@@YAXPAVOBJECTSTRUCT@@EEE@Z ; KundunEventItemBoxOpen
  003c8	83 c4 10	 add	 esp, 16			; 00000010H

; 3960 : 		}

  003cb	e9 f1 fc ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 3961 : 
; 3962 : 		return;

  003d0	e9 71 11 00 00	 jmp	 $LN1@gObjMonste
$LN16@gObjMonste:

; 3963 : 	}
; 3964 : #endif
; 3965 : 
; 3966 : 
; 3967 : 	if( lpObj->Class == 249 || lpTargetObj->Class == 249 || 
; 3968 : 		lpObj->Class == 247 || lpTargetObj->Class == 247 ) 

  003d5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d8	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003df	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  003e5	74 36		 je	 SHORT $LN25@gObjMonste
  003e7	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003ea	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003f1	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  003f7	74 24		 je	 SHORT $LN25@gObjMonste
  003f9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003fc	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00403	81 f9 f7 00 00
	00		 cmp	 ecx, 247		; 000000f7H
  00409	74 12		 je	 SHORT $LN25@gObjMonste
  0040b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0040e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00415	81 f9 f7 00 00
	00		 cmp	 ecx, 247		; 000000f7H
  0041b	75 05		 jne	 SHORT $LN24@gObjMonste
$LN25@gObjMonste:

; 3969 : 	{		
; 3970 : 		return;

  0041d	e9 24 11 00 00	 jmp	 $LN1@gObjMonste
$LN24@gObjMonste:

; 3971 : 	}
; 3972 : 	
; 3973 : 	if( lpObj->m_RecallMon >= 0 )						// 소환 몬스터는 아이템이나 돈을 떨구지 않는다.

  00422	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00425	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  0042c	7c 05		 jl	 SHORT $LN26@gObjMonste

; 3974 : 	{	
; 3975 : 		
; 3976 : 		return;

  0042e	e9 13 11 00 00	 jmp	 $LN1@gObjMonste
$LN26@gObjMonste:

; 3977 : 	}
; 3978 : 
; 3979 : #ifdef FOR_BLOODCASTLE
; 3980 : 	if(lpObj->Class == 131)								// 성문일 경우에는 아무것도 떨구지 않는다.

  00433	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00436	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0043d	81 f9 83 00 00
	00		 cmp	 ecx, 131		; 00000083H
  00443	75 05		 jne	 SHORT $LN27@gObjMonste

; 3981 : 	{
; 3982 : 		return;

  00445	e9 fc 10 00 00	 jmp	 $LN1@gObjMonste
$LN27@gObjMonste:

; 3983 : 	}
; 3984 : 
; 3985 : 	if (CHECK_LIMIT(lpObj->Class-BC_SAINT_STATUE_1, 3))	// 성자의석상 시리즈 일때도 아무것도 떨구지 않는다. (=> 리젠될 때 떨군다.)

  0044a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0044d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00454	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  0045a	79 0c		 jns	 SHORT $LN118@gObjMonste
  0045c	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv257[ebp], 0
  00466	eb 36		 jmp	 SHORT $LN119@gObjMonste
$LN118@gObjMonste:
  00468	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0046b	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  00472	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  00477	83 f8 02	 cmp	 eax, 2
  0047a	7e 0c		 jle	 SHORT $LN116@gObjMonste
  0047c	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv256[ebp], 0
  00486	eb 0a		 jmp	 SHORT $LN117@gObjMonste
$LN116@gObjMonste:
  00488	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv256[ebp], 1
$LN117@gObjMonste:
  00492	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv256[ebp]
  00498	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv257[ebp], ecx
$LN119@gObjMonste:
  0049e	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR tv257[ebp], 0
  004a5	74 05		 je	 SHORT $LN28@gObjMonste

; 3986 : 	{
; 3987 : 		return;

  004a7	e9 9a 10 00 00	 jmp	 $LN1@gObjMonste
$LN28@gObjMonste:

; 3988 : 	}
; 3989 : #endif
; 3990 : 
; 3991 : #ifdef ADD_RAKLION_20080408								// 라클리온 거미알은 아이템 드랍을 하지 않는다
; 3992 : 	if( lpObj->Class == 460 || lpObj->Class == 461 || lpObj->Class == 462 )
; 3993 : 	{
; 3994 : 		return;
; 3995 : 	}
; 3996 : #endif // ADD_RAKLION_20080408
; 3997 : 	
; 3998 : 
; 3999 : #ifdef CHAOSCASTLE_SYSTEM_20040408						// 몬스터가 죽어서 아이템을 드롭한다 -> 카오스 캐슬의 몬스터는 지정된 아이템만 드롭한다.
; 4000 : 	if (CHECK_CHAOSCASTLE(lpObj->MapNumber)) 

  004ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004af	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  004b6	83 f9 12	 cmp	 ecx, 18			; 00000012H
  004b9	7d 0c		 jge	 SHORT $LN122@gObjMonste
  004bb	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv266[ebp], 0
  004c5	eb 31		 jmp	 SHORT $LN123@gObjMonste
$LN122@gObjMonste:
  004c7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004ca	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  004d1	83 f8 17	 cmp	 eax, 23			; 00000017H
  004d4	7e 0c		 jle	 SHORT $LN120@gObjMonste
  004d6	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv265[ebp], 0
  004e0	eb 0a		 jmp	 SHORT $LN121@gObjMonste
$LN120@gObjMonste:
  004e2	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv265[ebp], 1
$LN121@gObjMonste:
  004ec	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv265[ebp]
  004f2	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv266[ebp], ecx
$LN123@gObjMonste:
  004f8	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR tv266[ebp], 0
  004ff	74 47		 je	 SHORT $LN29@gObjMonste

; 4001 : 	{
; 4002 : #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	// 카오스캐슬 번호 구하기
; 4003 : 		g_ChaosCastle.SearchNDropMonsterItem ( g_ChaosCastle.GetChaosCastleByMapNum( lpObj->MapNumber ), lpObj->m_Index, lpTargetObj->m_Index );
; 4004 : #else
; 4005 : 		g_ChaosCastle.SearchNDropMonsterItem (lpObj->MapNumber-MAP_INDEX_CHAOSCASTLE1, lpObj->m_Index, lpTargetObj->m_Index);

  00501	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00504	8b 08		 mov	 ecx, DWORD PTR [eax]
  00506	51		 push	 ecx
  00507	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0050a	8b 02		 mov	 eax, DWORD PTR [edx]
  0050c	50		 push	 eax
  0050d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00510	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00517	83 ea 12	 sub	 edx, 18			; 00000012H
  0051a	52		 push	 edx
  0051b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00520	e8 00 00 00 00	 call	 ?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::SearchNDropMonsterItem

; 4006 : #endif
; 4007 : 		// 여기에서 리젠 시키지 말고 지운다.
; 4008 : 		gObjDel (lpObj->m_Index);

  00525	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00528	8b 08		 mov	 ecx, DWORD PTR [eax]
  0052a	51		 push	 ecx
  0052b	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00530	83 c4 04	 add	 esp, 4

; 4009 : 		
; 4010 : #ifdef FOR_KOREA		
; 4011 : 		// 특정 확률에 따라 카오스캐슬 오프라인 경품에 당첨될 수 있다.
; 4012 : 		g_ChaosCastle.CheckRegisterOfflineGift(lpTargetObj->m_Index);

  00533	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00536	8b 08		 mov	 ecx, DWORD PTR [eax]
  00538	51		 push	 ecx
  00539	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0053e	e8 00 00 00 00	 call	 ?CheckRegisterOfflineGift@CChaosCastle@@QAEXH@Z ; CChaosCastle::CheckRegisterOfflineGift

; 4013 : #endif
; 4014 : 		return;

  00543	e9 fe 0f 00 00	 jmp	 $LN1@gObjMonste
$LN29@gObjMonste:

; 4015 : 	}
; 4016 : 
; 4017 : #ifdef MU_CHN_OFFLINE_GIFT_EVENT_20040908				// 중국 경품 이벤트 (어느 맵이나 받을 수 있다.)
; 4018 : 	g_ChaosCastle.CheckRegisterOfflineGift(lpTargetObj->m_Index);
; 4019 : #endif
; 4020 : 
; 4021 : #endif
; 4022 : 	
; 4023 : 
; 4024 : #ifdef MONSTER_HERD_SYSTEM_20031120
; 4025 : 	if (lpObj->m_bIsInMonsterHerd) 

  00548	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0054b	83 b8 ec 0e 00
	00 00		 cmp	 DWORD PTR [eax+3820], 0
  00552	74 2c		 je	 SHORT $LN32@gObjMonste

; 4026 : 	{
; 4027 : 		MonsterHerd * lpMH = lpObj->m_lpMonsterHerd;

  00554	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00557	8b 88 f4 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3828]
  0055d	89 4d b0	 mov	 DWORD PTR _lpMH$27[ebp], ecx

; 4028 : 
; 4029 : 		if (lpMH) {

  00560	83 7d b0 00	 cmp	 DWORD PTR _lpMH$27[ebp], 0
  00564	74 1a		 je	 SHORT $LN32@gObjMonste

; 4030 : 			if (lpMH->MonsterHerdItemDrop(lpObj))

  00566	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00569	50		 push	 eax
  0056a	8b 4d b0	 mov	 ecx, DWORD PTR _lpMH$27[ebp]
  0056d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0056f	8b 4d b0	 mov	 ecx, DWORD PTR _lpMH$27[ebp]
  00572	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00575	ff d0		 call	 eax
  00577	85 c0		 test	 eax, eax
  00579	74 05		 je	 SHORT $LN32@gObjMonste

; 4031 : 				return;

  0057b	e9 c6 0f 00 00	 jmp	 $LN1@gObjMonste
$LN32@gObjMonste:

; 4032 : 		}
; 4033 : 	}
; 4034 : #endif
; 4035 : 	
; 4036 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	// 환영 사원에서 몬스터 아이템 드랍
; 4037 : 	if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 4038 : 	{
; 4039 : 		int iMaxHitUser = gObjMonsterTopHitDamageUser( lpObj );	
; 4040 : 		
; 4041 : 		g_IllusionTempleEvent.MonsterDieItemDrop(lpTargetObj);
; 4042 : 		return;
; 4043 : 	}
; 4044 : #endif
; 4045 : 	
; 4046 : #ifdef CHUSEOK_MONSTER_EVENT_20070823	// 추석 몬스터이벤트 - 달토끼 아이템 드랍
; 4047 : 	if( lpObj->Class == 413 )
; 4048 : 	{
; 4049 : 		ChuseokMonsterEventItemBagOpen( lpTargetObj, lpObj->MapNumber, lpObj->X, lpObj->Y );		
; 4050 : 		return;	
; 4051 : 	}
; 4052 : #endif
; 4053 : 
; 4054 : #ifdef ADD_SUMMER_FIRECRACKER_MONSTER_EVENT_20090610	// 여름 불꽃 유령 이벤트
; 4055 : 	if( lpObj->Class == 463 )	// 불꽃 유령
; 4056 : 	{
; 4057 : 		FireCrackerMonsterEventItemBagOpen( lpTargetObj, lpObj->MapNumber, lpObj->X, lpObj->Y );		
; 4058 : 		return;	
; 4059 : 	}
; 4060 : #endif // ADD_SUMMER_FIRECRACKER_MONSTER_EVENT_20090610
; 4061 : 
; 4062 : 	int itemrate=lpObj->m_ItemRate;

  00580	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00583	0f bf 88 00 03
	00 00		 movsx	 ecx, WORD PTR [eax+768]
  0058a	89 4d ac	 mov	 DWORD PTR _itemrate$[ebp], ecx

; 4063 : 	int moneyrate=lpObj->m_MoneyRate;

  0058d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00590	0f bf 88 02 03
	00 00		 movsx	 ecx, WORD PTR [eax+770]
  00597	89 4d a8	 mov	 DWORD PTR _moneyrate$[ebp], ecx

; 4064 : 
; 4065 : 	if( itemrate < 1 ) itemrate = 1;

  0059a	83 7d ac 01	 cmp	 DWORD PTR _itemrate$[ebp], 1
  0059e	7d 07		 jge	 SHORT $LN33@gObjMonste
  005a0	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _itemrate$[ebp], 1
$LN33@gObjMonste:

; 4066 : 	if( moneyrate < 1 ) moneyrate = 1;

  005a7	83 7d a8 01	 cmp	 DWORD PTR _moneyrate$[ebp], 1
  005ab	7d 07		 jge	 SHORT $LN34@gObjMonste
  005ad	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR _moneyrate$[ebp], 1
$LN34@gObjMonste:

; 4067 : 
; 4068 : 	if( lpObj->Class == 44 )	// 환수 드래곤 일 경우

  005b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b7	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005be	83 f9 2c	 cmp	 ecx, 44			; 0000002cH
  005c1	0f 85 ca 01 00
	00		 jne	 $LN35@gObjMonste

; 4069 : 	{
; 4070 : 		
; 4071 : #ifdef	MODIFY_JEWELOFBLESS_SELL_BUGFIX
; 4072 : 		dur = 0;

  005c7	0f 57 c0	 xorps	 xmm0, xmm0
  005ca	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4073 : #else
; 4074 : 		dur  = 255;
; 4075 : #endif
; 4076 : 		x    = lpObj->X;

  005cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d2	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  005d9	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4077 : 		y    = lpObj->Y;

  005dc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005df	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  005e6	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4078 : 		level= 0;

  005e9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 4079 : 		if( (rand()%4) > 0 )	// 1/5 로 아이템 나올 활률

  005f0	e8 00 00 00 00	 call	 _rand
  005f5	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  005fa	79 05		 jns	 SHORT $LN124@gObjMonste
  005fc	48		 dec	 eax
  005fd	83 c8 fc	 or	 eax, -4			; fffffffcH
  00600	40		 inc	 eax
$LN124@gObjMonste:
  00601	85 c0		 test	 eax, eax
  00603	0f 8e 8d 00 00
	00		 jle	 $LN37@gObjMonste

; 4080 : 		{
; 4081 : 			for( int n=0; n<4; n++)

  00609	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _n$26[ebp], 0
  00610	eb 09		 jmp	 SHORT $LN7@gObjMonste
$LN5@gObjMonste:
  00612	8b 45 a4	 mov	 eax, DWORD PTR _n$26[ebp]
  00615	83 c0 01	 add	 eax, 1
  00618	89 45 a4	 mov	 DWORD PTR _n$26[ebp], eax
$LN7@gObjMonste:
  0061b	83 7d a4 04	 cmp	 DWORD PTR _n$26[ebp], 4
  0061f	7d 70		 jge	 SHORT $LN6@gObjMonste

; 4082 : 			{
; 4083 : 				int x, y;
; 4084 : 				x    = lpObj->X-2;

  00621	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00624	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0062b	83 e9 02	 sub	 ecx, 2
  0062e	89 4d a0	 mov	 DWORD PTR _x$25[ebp], ecx

; 4085 : 				y    = lpObj->Y-2;

  00631	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00634	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0063b	83 e9 02	 sub	 ecx, 2
  0063e	89 4d 9c	 mov	 DWORD PTR _y$24[ebp], ecx

; 4086 : 				x   += rand()%3;

  00641	e8 00 00 00 00	 call	 _rand
  00646	99		 cdq
  00647	b9 03 00 00 00	 mov	 ecx, 3
  0064c	f7 f9		 idiv	 ecx
  0064e	03 55 a0	 add	 edx, DWORD PTR _x$25[ebp]
  00651	89 55 a0	 mov	 DWORD PTR _x$25[ebp], edx

; 4087 : 				y   += rand()%3;			

  00654	e8 00 00 00 00	 call	 _rand
  00659	99		 cdq
  0065a	b9 03 00 00 00	 mov	 ecx, 3
  0065f	f7 f9		 idiv	 ecx
  00661	03 55 9c	 add	 edx, DWORD PTR _y$24[ebp]
  00664	89 55 9c	 mov	 DWORD PTR _y$24[ebp], edx

; 4088 : 				MapC[lpObj->MapNumber].MoneyItemDrop(10000, x ,y);

  00667	8b 45 9c	 mov	 eax, DWORD PTR _y$24[ebp]
  0066a	50		 push	 eax
  0066b	8b 4d a0	 mov	 ecx, DWORD PTR _x$25[ebp]
  0066e	51		 push	 ecx
  0066f	68 10 27 00 00	 push	 10000			; 00002710H
  00674	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00677	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0067e	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00684	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0068a	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 4089 : 			}			

  0068f	eb 81		 jmp	 SHORT $LN5@gObjMonste
$LN6@gObjMonste:

; 4090 : 			return;

  00691	e9 b0 0e 00 00	 jmp	 $LN1@gObjMonste
$LN37@gObjMonste:

; 4091 : 		}
; 4092 : 		if( (rand()%3) < 2 )

  00696	e8 00 00 00 00	 call	 _rand
  0069b	99		 cdq
  0069c	b9 03 00 00 00	 mov	 ecx, 3
  006a1	f7 f9		 idiv	 ecx
  006a3	83 fa 02	 cmp	 edx, 2
  006a6	7d 73		 jge	 SHORT $LN38@gObjMonste

; 4093 : 		{
; 4094 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  006a8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ab	50		 push	 eax
  006ac	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  006b1	83 c4 04	 add	 esp, 4
  006b4	89 45 98	 mov	 DWORD PTR _MaxHitUser$23[ebp], eax

; 4095 : 			type = ItemGetNumberMake(14, 13);

  006b7	6a 0d		 push	 13			; 0000000dH
  006b9	6a 0e		 push	 14			; 0000000eH
  006bb	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  006c0	83 c4 08	 add	 esp, 8
  006c3	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4096 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  006c6	6a 00		 push	 0
  006c8	6a 00		 push	 0
  006ca	6a 00		 push	 0
  006cc	8b 45 98	 mov	 eax, DWORD PTR _MaxHitUser$23[ebp]
  006cf	50		 push	 eax
  006d0	0f b6 4d d4	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  006d4	51		 push	 ecx
  006d5	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option2$[ebp]
  006d9	52		 push	 edx
  006da	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option1$[ebp]
  006de	50		 push	 eax
  006df	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  006e4	0f b6 d1	 movzx	 edx, cl
  006e7	52		 push	 edx
  006e8	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  006ec	50		 push	 eax
  006ed	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  006f0	51		 push	 ecx
  006f1	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  006f5	52		 push	 edx
  006f6	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  006fa	50		 push	 eax
  006fb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006fe	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00705	52		 push	 edx
  00706	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00709	8b 08		 mov	 ecx, DWORD PTR [eax]
  0070b	51		 push	 ecx
  0070c	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00711	83 c4 38	 add	 esp, 56			; 00000038H

; 4097 : 			return;

  00714	e9 2d 0e 00 00	 jmp	 $LN1@gObjMonste

; 4098 : 		}

  00719	eb 71		 jmp	 SHORT $LN39@gObjMonste
$LN38@gObjMonste:

; 4099 : 		else
; 4100 : 		{
; 4101 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0071b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071e	50		 push	 eax
  0071f	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00724	83 c4 04	 add	 esp, 4
  00727	89 45 94	 mov	 DWORD PTR _MaxHitUser$22[ebp], eax

; 4102 : 			type = ItemGetNumberMake(14, 14);

  0072a	6a 0e		 push	 14			; 0000000eH
  0072c	6a 0e		 push	 14			; 0000000eH
  0072e	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00733	83 c4 08	 add	 esp, 8
  00736	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4103 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00739	6a 00		 push	 0
  0073b	6a 00		 push	 0
  0073d	6a 00		 push	 0
  0073f	8b 45 94	 mov	 eax, DWORD PTR _MaxHitUser$22[ebp]
  00742	50		 push	 eax
  00743	0f b6 4d d4	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00747	51		 push	 ecx
  00748	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option2$[ebp]
  0074c	52		 push	 edx
  0074d	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00751	50		 push	 eax
  00752	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00757	0f b6 d1	 movzx	 edx, cl
  0075a	52		 push	 edx
  0075b	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  0075f	50		 push	 eax
  00760	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  00763	51		 push	 ecx
  00764	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  00768	52		 push	 edx
  00769	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  0076d	50		 push	 eax
  0076e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00771	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00778	52		 push	 edx
  00779	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0077c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0077e	51		 push	 ecx
  0077f	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00784	83 c4 38	 add	 esp, 56			; 00000038H

; 4104 : 			return;

  00787	e9 ba 0d 00 00	 jmp	 $LN1@gObjMonste
$LN39@gObjMonste:

; 4105 : 		}		
; 4106 : 	}

  0078c	e9 7c 04 00 00	 jmp	 $LN53@gObjMonste
$LN35@gObjMonste:

; 4107 : 	else if( lpObj->Class == 43 )	// 황금버지드래곤 일 경우

  00791	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00794	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0079b	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  0079e	0f 85 a4 00 00
	00		 jne	 $LN40@gObjMonste

; 4108 : 	{
; 4109 : 		dur  = 255;

  007a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  007ac	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4110 : 		x    = lpObj->X;

  007b1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007b4	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  007bb	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4111 : 		y    = lpObj->Y;

  007be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007c1	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  007c8	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4112 : 		level= 0;

  007cb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 4113 : 		type = ItemGetNumberMake(14, 11);

  007d2	6a 0b		 push	 11			; 0000000bH
  007d4	6a 0e		 push	 14			; 0000000eH
  007d6	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  007db	83 c4 08	 add	 esp, 8
  007de	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4114 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  007e1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007e4	50		 push	 eax
  007e5	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  007ea	83 c4 04	 add	 esp, 4
  007ed	89 45 90	 mov	 DWORD PTR _MaxHitUser$21[ebp], eax

; 4115 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  007f0	6a 00		 push	 0
  007f2	6a 00		 push	 0
  007f4	6a 00		 push	 0
  007f6	8b 45 90	 mov	 eax, DWORD PTR _MaxHitUser$21[ebp]
  007f9	50		 push	 eax
  007fa	0f b6 4d d4	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  007fe	51		 push	 ecx
  007ff	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00803	52		 push	 edx
  00804	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00808	50		 push	 eax
  00809	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  0080e	0f b6 d1	 movzx	 edx, cl
  00811	52		 push	 edx
  00812	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  00816	50		 push	 eax
  00817	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  0081a	51		 push	 ecx
  0081b	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  0081f	52		 push	 edx
  00820	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  00824	50		 push	 eax
  00825	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00828	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0082f	52		 push	 edx
  00830	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00833	8b 08		 mov	 ecx, DWORD PTR [eax]
  00835	51		 push	 ecx
  00836	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0083b	83 c4 38	 add	 esp, 56			; 00000038H

; 4116 : 		return;

  0083e	e9 03 0d 00 00	 jmp	 $LN1@gObjMonste

; 4117 : 	}

  00843	e9 c5 03 00 00	 jmp	 $LN53@gObjMonste
$LN40@gObjMonste:

; 4118 : #ifndef ADD_GOLDEN_EVENT_RENEWAL_20090311
; 4119 : 	else if( lpObj->Class == 53 )

  00848	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0084b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00852	83 f9 35	 cmp	 ecx, 53			; 00000035H
  00855	0f 85 a4 00 00
	00		 jne	 $LN42@gObjMonste

; 4120 : 	{	// 타이탄
; 4121 : #ifdef ELEGORADO_EVENT
; 4122 : 		dur  = 255;

  0085b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00863	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4123 : 		x    = lpObj->X;

  00868	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0086b	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00872	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4124 : 		y    = lpObj->Y;

  00875	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00878	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0087f	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4125 : 		level= 9;	// 엘도라도의 상자

  00882	c7 45 ec 09 00
	00 00		 mov	 DWORD PTR _level$[ebp], 9

; 4126 : 		type = ItemGetNumberMake(14, 11);

  00889	6a 0b		 push	 11			; 0000000bH
  0088b	6a 0e		 push	 14			; 0000000eH
  0088d	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00892	83 c4 08	 add	 esp, 8
  00895	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4127 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00898	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0089b	50		 push	 eax
  0089c	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  008a1	83 c4 04	 add	 esp, 4
  008a4	89 45 8c	 mov	 DWORD PTR _MaxHitUser$20[ebp], eax

; 4128 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  008a7	6a 00		 push	 0
  008a9	6a 00		 push	 0
  008ab	6a 00		 push	 0
  008ad	8b 45 8c	 mov	 eax, DWORD PTR _MaxHitUser$20[ebp]
  008b0	50		 push	 eax
  008b1	0f b6 4d d4	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  008b5	51		 push	 ecx
  008b6	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option2$[ebp]
  008ba	52		 push	 edx
  008bb	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option1$[ebp]
  008bf	50		 push	 eax
  008c0	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  008c5	0f b6 d1	 movzx	 edx, cl
  008c8	52		 push	 edx
  008c9	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  008cd	50		 push	 eax
  008ce	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  008d1	51		 push	 ecx
  008d2	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  008d6	52		 push	 edx
  008d7	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  008db	50		 push	 eax
  008dc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  008df	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  008e6	52		 push	 edx
  008e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  008ec	51		 push	 ecx
  008ed	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  008f2	83 c4 38	 add	 esp, 56			; 00000038H

; 4129 : 		return;

  008f5	e9 4c 0c 00 00	 jmp	 $LN1@gObjMonste

; 4130 : #else
; 4131 : 		if( AttackEvent53BagOpen(lpObj) == TRUE ) return;
; 4132 : 		itemrate = 1;
; 4133 : #endif
; 4134 : 	}

  008fa	e9 0e 03 00 00	 jmp	 $LN53@gObjMonste
$LN42@gObjMonste:

; 4135 : 	else if( lpObj->Class == 55 )

  008ff	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00902	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00909	83 f9 37	 cmp	 ecx, 55			; 00000037H
  0090c	75 22		 jne	 SHORT $LN44@gObjMonste

; 4136 : 	{	// 데쓰킹
; 4137 : 		if( AttackEvent55BagOpen(lpObj) == TRUE ) return;

  0090e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00911	50		 push	 eax
  00912	e8 00 00 00 00	 call	 ?AttackEvent55BagOpen@@YAHPAVOBJECTSTRUCT@@@Z ; AttackEvent55BagOpen
  00917	83 c4 04	 add	 esp, 4
  0091a	83 f8 01	 cmp	 eax, 1
  0091d	75 05		 jne	 SHORT $LN46@gObjMonste
  0091f	e9 22 0c 00 00	 jmp	 $LN1@gObjMonste
$LN46@gObjMonste:

; 4138 : 		itemrate = 1;

  00924	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _itemrate$[ebp], 1

; 4139 : 	}

  0092b	e9 dd 02 00 00	 jmp	 $LN53@gObjMonste
$LN44@gObjMonste:

; 4140 : #ifdef ELEGORADO_EVENT
; 4141 : 	else if( lpObj->Class == 78 )

  00930	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00933	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0093a	83 f9 4e	 cmp	 ecx, 78			; 0000004eH
  0093d	0f 85 a4 00 00
	00		 jne	 $LN47@gObjMonste

; 4142 : 	{	// 황금 고블린		
; 4143 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00943	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00946	50		 push	 eax
  00947	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0094c	83 c4 04	 add	 esp, 4
  0094f	89 45 88	 mov	 DWORD PTR _MaxHitUser$19[ebp], eax

; 4144 : 		
; 4145 : 		x    = lpObj->X;

  00952	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00955	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0095c	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4146 : 		y    = lpObj->Y;		

  0095f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00962	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00969	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4147 : 		dur  = 255;

  0096c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00974	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4148 : 		level= 8;

  00979	c7 45 ec 08 00
	00 00		 mov	 DWORD PTR _level$[ebp], 8

; 4149 : 		type = ItemGetNumberMake(14, 11);

  00980	6a 0b		 push	 11			; 0000000bH
  00982	6a 0e		 push	 14			; 0000000eH
  00984	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00989	83 c4 08	 add	 esp, 8
  0098c	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4150 : 		
; 4151 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  0098f	6a 00		 push	 0
  00991	6a 00		 push	 0
  00993	6a 00		 push	 0
  00995	8b 45 88	 mov	 eax, DWORD PTR _MaxHitUser$19[ebp]
  00998	50		 push	 eax
  00999	0f b6 4d d4	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  0099d	51		 push	 ecx
  0099e	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option2$[ebp]
  009a2	52		 push	 edx
  009a3	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option1$[ebp]
  009a7	50		 push	 eax
  009a8	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  009ad	0f b6 d1	 movzx	 edx, cl
  009b0	52		 push	 edx
  009b1	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  009b5	50		 push	 eax
  009b6	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  009b9	51		 push	 ecx
  009ba	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  009be	52		 push	 edx
  009bf	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  009c3	50		 push	 eax
  009c4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009c7	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  009ce	52		 push	 edx
  009cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  009d4	51		 push	 ecx
  009d5	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  009da	83 c4 38	 add	 esp, 56			; 00000038H

; 4152 : 		return;

  009dd	e9 64 0b 00 00	 jmp	 $LN1@gObjMonste

; 4153 : 	}

  009e2	e9 26 02 00 00	 jmp	 $LN53@gObjMonste
$LN47@gObjMonste:

; 4154 : 	else if( lpObj->Class == 79 )

  009e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009ea	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  009f1	83 f9 4f	 cmp	 ecx, 79			; 0000004fH
  009f4	0f 85 a4 00 00
	00		 jne	 $LN49@gObjMonste

; 4155 : 	{	// 골드 데르콘	
; 4156 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  009fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009fd	50		 push	 eax
  009fe	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00a03	83 c4 04	 add	 esp, 4
  00a06	89 45 84	 mov	 DWORD PTR _MaxHitUser$18[ebp], eax

; 4157 : 		
; 4158 : 		x    = lpObj->X;

  00a09	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a0c	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00a13	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4159 : 		y    = lpObj->Y;

  00a16	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a19	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00a20	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4160 : 
; 4161 : 		dur  = 255;		

  00a23	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00a2b	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4162 : 		level= 10;

  00a30	c7 45 ec 0a 00
	00 00		 mov	 DWORD PTR _level$[ebp], 10 ; 0000000aH

; 4163 : 		type = ItemGetNumberMake(14, 11);		

  00a37	6a 0b		 push	 11			; 0000000bH
  00a39	6a 0e		 push	 14			; 0000000eH
  00a3b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00a40	83 c4 08	 add	 esp, 8
  00a43	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4164 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00a46	6a 00		 push	 0
  00a48	6a 00		 push	 0
  00a4a	6a 00		 push	 0
  00a4c	8b 45 84	 mov	 eax, DWORD PTR _MaxHitUser$18[ebp]
  00a4f	50		 push	 eax
  00a50	0f b6 4d d4	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00a54	51		 push	 ecx
  00a55	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00a59	52		 push	 edx
  00a5a	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00a5e	50		 push	 eax
  00a5f	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00a64	0f b6 d1	 movzx	 edx, cl
  00a67	52		 push	 edx
  00a68	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  00a6c	50		 push	 eax
  00a6d	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  00a70	51		 push	 ecx
  00a71	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  00a75	52		 push	 edx
  00a76	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  00a7a	50		 push	 eax
  00a7b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a7e	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00a85	52		 push	 edx
  00a86	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a89	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a8b	51		 push	 ecx
  00a8c	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00a91	83 c4 38	 add	 esp, 56			; 00000038H

; 4165 : 		return;

  00a94	e9 ad 0a 00 00	 jmp	 $LN1@gObjMonste

; 4166 : 	}

  00a99	e9 6f 01 00 00	 jmp	 $LN53@gObjMonste
$LN49@gObjMonste:

; 4167 : 	else if( lpObj->Class == 80 )

  00a9e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aa1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00aa8	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00aab	0f 85 a4 00 00
	00		 jne	 $LN51@gObjMonste

; 4168 : 	{	// 데블 리자드킹
; 4169 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00ab1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ab4	50		 push	 eax
  00ab5	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00aba	83 c4 04	 add	 esp, 4
  00abd	89 45 80	 mov	 DWORD PTR _MaxHitUser$17[ebp], eax

; 4170 : 		
; 4171 : 		x    = lpObj->X;

  00ac0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ac3	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00aca	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4172 : 		y    = lpObj->Y;

  00acd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ad0	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00ad7	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4173 : 
; 4174 : 		dur  = 255;	

  00ada	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00ae2	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4175 : 		level= 11;

  00ae7	c7 45 ec 0b 00
	00 00		 mov	 DWORD PTR _level$[ebp], 11 ; 0000000bH

; 4176 : 		type = ItemGetNumberMake(14, 11);		

  00aee	6a 0b		 push	 11			; 0000000bH
  00af0	6a 0e		 push	 14			; 0000000eH
  00af2	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00af7	83 c4 08	 add	 esp, 8
  00afa	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4177 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00afd	6a 00		 push	 0
  00aff	6a 00		 push	 0
  00b01	6a 00		 push	 0
  00b03	8b 45 80	 mov	 eax, DWORD PTR _MaxHitUser$17[ebp]
  00b06	50		 push	 eax
  00b07	0f b6 4d d4	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00b0b	51		 push	 ecx
  00b0c	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00b10	52		 push	 edx
  00b11	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00b15	50		 push	 eax
  00b16	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00b1b	0f b6 d1	 movzx	 edx, cl
  00b1e	52		 push	 edx
  00b1f	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  00b23	50		 push	 eax
  00b24	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  00b27	51		 push	 ecx
  00b28	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  00b2c	52		 push	 edx
  00b2d	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  00b31	50		 push	 eax
  00b32	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b35	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00b3c	52		 push	 edx
  00b3d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b40	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b42	51		 push	 ecx
  00b43	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00b48	83 c4 38	 add	 esp, 56			; 00000038H

; 4178 : 		return;

  00b4b	e9 f6 09 00 00	 jmp	 $LN1@gObjMonste

; 4179 : 	}

  00b50	e9 b8 00 00 00	 jmp	 $LN53@gObjMonste
$LN51@gObjMonste:

; 4180 : 	else if( lpObj->Class == 82 )

  00b55	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b58	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b5f	83 f9 52	 cmp	 ecx, 82			; 00000052H
  00b62	0f 85 a5 00 00
	00		 jne	 $LN53@gObjMonste

; 4181 : 	{	// 칸투르 1		
; 4182 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00b68	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b6b	50		 push	 eax
  00b6c	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00b71	83 c4 04	 add	 esp, 4
  00b74	89 85 7c ff ff
	ff		 mov	 DWORD PTR _MaxHitUser$16[ebp], eax

; 4183 : 
; 4184 : 		x    = lpObj->X;

  00b7a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b7d	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00b84	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4185 : 		y    = lpObj->Y;

  00b87	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b8a	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00b91	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4186 : 
; 4187 : 		dur  = 255;		

  00b94	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00b9c	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4188 : 		level= 12;				

  00ba1	c7 45 ec 0c 00
	00 00		 mov	 DWORD PTR _level$[ebp], 12 ; 0000000cH

; 4189 : 		type = ItemGetNumberMake(14, 11);	

  00ba8	6a 0b		 push	 11			; 0000000bH
  00baa	6a 0e		 push	 14			; 0000000eH
  00bac	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00bb1	83 c4 08	 add	 esp, 8
  00bb4	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4190 : 
; 4191 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00bb7	6a 00		 push	 0
  00bb9	6a 00		 push	 0
  00bbb	6a 00		 push	 0
  00bbd	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _MaxHitUser$16[ebp]
  00bc3	50		 push	 eax
  00bc4	0f b6 4d d4	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00bc8	51		 push	 ecx
  00bc9	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00bcd	52		 push	 edx
  00bce	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00bd2	50		 push	 eax
  00bd3	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00bd8	0f b6 d1	 movzx	 edx, cl
  00bdb	52		 push	 edx
  00bdc	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  00be0	50		 push	 eax
  00be1	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  00be4	51		 push	 ecx
  00be5	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  00be9	52		 push	 edx
  00bea	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  00bee	50		 push	 eax
  00bef	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bf2	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00bf9	52		 push	 edx
  00bfa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bfd	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bff	51		 push	 ecx
  00c00	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00c05	83 c4 38	 add	 esp, 56			; 00000038H

; 4192 : 		return;

  00c08	e9 39 09 00 00	 jmp	 $LN1@gObjMonste
$LN53@gObjMonste:

; 4193 : 	}
; 4194 : #endif
; 4195 : #else //ADD_GOLDEN_EVENT_RENEWAL_20090311
; 4196 : 	else if(lpObj->Class == 78 || lpObj->Class == 502 || lpObj->Class == 493)	
; 4197 : 	{
; 4198 : 		
; 4199 : 		// 황금버지드래곤, 황금고블린 , 황금토끼, 황금다크나이트 (황금타이탄은 아래로 뺏다)
; 4200 : 		dur  = 255;
; 4201 : 		x    = lpObj->X;
; 4202 : 		y    = lpObj->Y;
; 4203 : 		level= 8;
; 4204 : 		type = ItemGetNumberMake(14, 11);
; 4205 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4206 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 4207 : 		return;
; 4208 : 	}
; 4209 : 	else if( lpObj->Class == 53 ||  lpObj->Class == 54 )
; 4210 : 	{	// 타이탄, 황금 솔져 
; 4211 : #ifdef ELEGORADO_EVENT
; 4212 : 		dur  = 255;
; 4213 : 		x    = lpObj->X;
; 4214 : 		y    = lpObj->Y;
; 4215 : 		level= 8;	// 엘도라도의 상자
; 4216 : 		type = ItemGetNumberMake(14, 11);
; 4217 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4218 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 4219 : 		return;
; 4220 : #else
; 4221 : 		if( AttackEvent53BagOpen(lpObj) == TRUE ) return;
; 4222 : 		itemrate = 1;
; 4223 : #endif
; 4224 : 	}
; 4225 : 	
; 4226 : 	
; 4227 : 	else if( lpObj->Class == 80 || lpObj->Class == 81 || lpObj->Class == 494)
; 4228 : 	{	// 데블 리자드킹 , 황금베파르 , 황금 데빌
; 4229 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4230 : 		
; 4231 : 		x    = lpObj->X;
; 4232 : 		y    = lpObj->Y;
; 4233 : 		
; 4234 : 		dur  = 255;	
; 4235 : 		level= 9;
; 4236 : 		type = ItemGetNumberMake(14, 11);		
; 4237 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 4238 : 		return;
; 4239 : 	}
; 4240 : 	else if( lpObj->Class == 82 || lpObj->Class == 83 || lpObj->Class == 495 || lpObj->Class == 496)
; 4241 : 	{	// 황금탄탈로스 , 황금휠 , 황금돌괴물, 황금크러스트
; 4242 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4243 : 		
; 4244 : 		x    = lpObj->X;
; 4245 : 		y    = lpObj->Y;
; 4246 : 		
; 4247 : 		dur  = 255;		
; 4248 : 		level= 10;				
; 4249 : 		type = ItemGetNumberMake(14, 11);	
; 4250 : 		
; 4251 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 4252 : 		return;
; 4253 : 	}
; 4254 : 	else if( lpObj->Class == 497 || lpObj->Class == 498)
; 4255 : 	{
; 4256 : 		// 황금 사티로스, 황금트윈테일
; 4257 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4258 : 		
; 4259 : 		x    = lpObj->X;
; 4260 : 		y    = lpObj->Y;
; 4261 : 		
; 4262 : 		dur  = 255;		
; 4263 : 		level= 11;				
; 4264 : 		type = ItemGetNumberMake(14, 11);	
; 4265 : 		
; 4266 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 4267 : 		return;
; 4268 : 	}
; 4269 : 	else if( lpObj->Class == 499 || lpObj->Class == 500)
; 4270 : 	{
; 4271 : 		//황금아이언나이트, 황금네이핀
; 4272 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4273 : 		
; 4274 : 		x    = lpObj->X;
; 4275 : 		y    = lpObj->Y;
; 4276 : 		
; 4277 : 		dur  = 255;		
; 4278 : 		level= 12;				
; 4279 : 		type = ItemGetNumberMake(14, 11);	
; 4280 : 		
; 4281 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 4282 : 		return;
; 4283 : 	}
; 4284 : 	else if( lpObj->Class == 79 )
; 4285 : 	{	// 골드 데르콘	
; 4286 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4287 : 		
; 4288 : 		UCHAR cDropX = lpObj->X;
; 4289 : 		UCHAR cDropY = lpObj->Y;
; 4290 : 
; 4291 : 		dur  = 255;		
; 4292 : 		int nLevel[3] = {8,9,10};
; 4293 : 
; 4294 : 				
; 4295 : 		for( INT iCount = 0; iCount < 5; iCount++ )
; 4296 : 		{
; 4297 : 			if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 2, 2, 10 ) )
; 4298 : 			{
; 4299 : 				cDropX = lpObj->X;
; 4300 : 				cDropY = lpObj->Y;
; 4301 : 			}
; 4302 : 			level= nLevel[rand()%3];
; 4303 : 			type = ItemGetNumberMake(14, 11);		
; 4304 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, cDropX, cDropY, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 4305 : 		}
; 4306 : 
; 4307 : 		
; 4308 : 		return;
; 4309 : 	}
; 4310 : 	else if(lpObj->Class == 501)
; 4311 : 	{
; 4312 : 		// 그레이트 황금 드래곤 
; 4313 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4314 : 		
; 4315 : 		UCHAR cDropX = lpObj->X;
; 4316 : 		UCHAR cDropY = lpObj->Y;
; 4317 : 
; 4318 : 		dur  = 255;		
; 4319 : 		int nLevel[2] = {11,12};
; 4320 : 		
; 4321 : 		
; 4322 : 		for( INT iCount = 0; iCount < 5; iCount++ )
; 4323 : 		{
; 4324 : 			if( !gObjGetRandomItemDropLocation( lpObj->MapNumber, cDropX, cDropY, 2, 2, 10 ) )
; 4325 : 			{
; 4326 : 				cDropX = lpObj->X;
; 4327 : 				cDropY = lpObj->Y;
; 4328 : 			}
; 4329 : 			level= nLevel[rand()%2];
; 4330 : 			type = ItemGetNumberMake(14, 11);		
; 4331 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, cDropX, cDropY, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);
; 4332 : 		}
; 4333 : 		
; 4334 : 		
; 4335 : 		return;
; 4336 : 	}
; 4337 : 
; 4338 : 	else if( lpObj->Class == 55 )
; 4339 : 	{	// 데쓰킹
; 4340 : 		if( AttackEvent55BagOpen(lpObj) == TRUE ) return;
; 4341 : 		itemrate = 1;
; 4342 : 	}
; 4343 : #endif //ADD_GOLDEN_EVENT_RENEWAL_20090311
; 4344 : 
; 4345 : 
; 4346 : 	// 이벤트 아이템 드랍을 설정한다
; 4347 : 	if( gEventMonsterItemDrop(lpObj, lpTargetObj) )

  00c0d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c10	50		 push	 eax
  00c11	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c14	51		 push	 ecx
  00c15	e8 00 00 00 00	 call	 ?gEventMonsterItemDrop@@YAHPAVOBJECTSTRUCT@@0@Z ; gEventMonsterItemDrop
  00c1a	83 c4 08	 add	 esp, 8
  00c1d	85 c0		 test	 eax, eax
  00c1f	74 05		 je	 SHORT $LN54@gObjMonste

; 4348 : 	{		
; 4349 : 		return;	

  00c21	e9 20 09 00 00	 jmp	 $LN1@gObjMonste
$LN54@gObjMonste:

; 4350 : 	}
; 4351 : 
; 4352 : 
; 4353 : #ifdef HAPPY_POUCH	//happycat@20050201 (복주머니) - 국내 설 이벤트
; 4354 : 	CMobDropItemInfo ItemInfo;
; 4355 : 
; 4356 : 	if (g_GameEvent.GetEventItem(lpObj->MapNumber, ItemInfo))
; 4357 : 	{
; 4358 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y, 
; 4359 : 			ItemInfo.m_wType, ItemInfo.m_level, ItemInfo.m_fDurability, ItemInfo.m_option1, ItemInfo.m_option2, ItemInfo.m_option3, gObjMonsterTopHitDamageUser(lpObj));
; 4360 : 		return; // apple★20050203
; 4361 : 	}
; 4362 : 
; 4363 : #endif
; 4364 : 
; 4365 : #ifdef NEW_SKILL_FORSKYLAND
; 4366 : 	// 퀘스트 아이템 드랍을 설정한다
; 4367 : 	if( g_QuestInfo.MonsterItemDrop(lpObj) )

  00c26	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c29	50		 push	 eax
  00c2a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00c2f	e8 00 00 00 00	 call	 ?MonsterItemDrop@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@@Z ; CQuestInfo::MonsterItemDrop
  00c34	85 c0		 test	 eax, eax
  00c36	74 05		 je	 SHORT $LN55@gObjMonste

; 4368 : 	{		
; 4369 : 		return;	

  00c38	e9 09 09 00 00	 jmp	 $LN1@gObjMonste
$LN55@gObjMonste:

; 4370 : 	}
; 4371 : #endif
; 4372 : 
; 4373 : 	// 레벨 20 이하이면 사과 드롭 확률이 높아진다.
; 4374 : 	if (lpTargetObj->Level <= 20) {

  00c3d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c40	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00c47	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00c4a	0f 8f b9 00 00
	00		 jg	 $LN57@gObjMonste

; 4375 : 		if (rand()%10000 < APPLE_DROPRATE) 

  00c50	e8 00 00 00 00	 call	 _rand
  00c55	99		 cdq
  00c56	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00c5b	f7 f9		 idiv	 ecx
  00c5d	81 fa d0 07 00
	00		 cmp	 edx, 2000		; 000007d0H
  00c63	0f 8d a0 00 00
	00		 jge	 $LN57@gObjMonste

; 4376 : 		{
; 4377 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00c69	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c6c	50		 push	 eax
  00c6d	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00c72	83 c4 04	 add	 esp, 4
  00c75	89 85 78 ff ff
	ff		 mov	 DWORD PTR _MaxHitUser$15[ebp], eax

; 4378 : 			x    = lpObj->X;

  00c7b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c7e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00c85	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4379 : 			y    = lpObj->Y;

  00c88	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c8b	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00c92	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4380 : 			dur  = 1;		

  00c95	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c9d	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4381 : 			level= 0;		

  00ca2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 4382 : 			type = ItemGetNumberMake(14, 0);	

  00ca9	6a 00		 push	 0
  00cab	6a 0e		 push	 14			; 0000000eH
  00cad	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00cb2	83 c4 08	 add	 esp, 8
  00cb5	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4383 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser);

  00cb8	6a 00		 push	 0
  00cba	6a 00		 push	 0
  00cbc	6a 00		 push	 0
  00cbe	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _MaxHitUser$15[ebp]
  00cc4	50		 push	 eax
  00cc5	0f b6 4d d4	 movzx	 ecx, BYTE PTR _Option3$[ebp]
  00cc9	51		 push	 ecx
  00cca	0f b6 55 d8	 movzx	 edx, BYTE PTR _Option2$[ebp]
  00cce	52		 push	 edx
  00ccf	0f b6 45 dc	 movzx	 eax, BYTE PTR _Option1$[ebp]
  00cd3	50		 push	 eax
  00cd4	f3 0f 2c 4d e0	 cvttss2si ecx, DWORD PTR _dur$[ebp]
  00cd9	0f b6 d1	 movzx	 edx, cl
  00cdc	52		 push	 edx
  00cdd	0f b6 45 ec	 movzx	 eax, BYTE PTR _level$[ebp]
  00ce1	50		 push	 eax
  00ce2	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  00ce5	51		 push	 ecx
  00ce6	0f b6 55 e4	 movzx	 edx, BYTE PTR _y$[ebp]
  00cea	52		 push	 edx
  00ceb	0f b6 45 e8	 movzx	 eax, BYTE PTR _x$[ebp]
  00cef	50		 push	 eax
  00cf0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cf3	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00cfa	52		 push	 edx
  00cfb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cfe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d00	51		 push	 ecx
  00d01	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00d06	83 c4 38	 add	 esp, 56			; 00000038H
$LN57@gObjMonste:

; 4384 : 		}
; 4385 : 	}
; 4386 : 
; 4387 : 	
; 4388 : 	
; 4389 : #ifdef CHANGE_EX_ITEM_DROP_RATE_20040524	
; 4390 : 	ExtDropPer = rand()%lpTargetObj->m_wExcellentDropRate;
; 4391 : #else
; 4392 : 	// ADD_REWARD_ABOUT_KALIMA_BOSS_01_20040907 
; 4393 : 	// 1200->2000으로 수정 - 2004.09.08 (apple)
; 4394 : 	ExtDropPer = rand()%lpTargetObj->m_wExcellentDropRate;

  00d09	e8 00 00 00 00	 call	 _rand
  00d0e	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00d11	0f b7 89 32 1a
	00 00		 movzx	 ecx, WORD PTR [ecx+6706]
  00d18	99		 cdq
  00d19	f7 f9		 idiv	 ecx
  00d1b	89 55 f8	 mov	 DWORD PTR _ExtDropPer$[ebp], edx

; 4395 : #endif
; 4396 : 	
; 4397 : 
; 4398 : #ifdef FOR_BLOODCASTLE
; 4399 : 	// 블러드캐슬 몬스터일 경우 새로운 엑셀 드롭율을 적용한다.
; 4400 : //	if (CHECK_BLOODCASTLE(lpObj->MapNumber))
; 4401 : //		ExtDropPer = rand() % g_BloodCastle.GetExcelItemDropRate();
; 4402 : #endif
; 4403 : 
; 4404 : 	int	ItemDropPer = gItemDropPer;

  00d1e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gItemDropPer@@3HA ; gItemDropPer
  00d23	89 85 74 ff ff
	ff		 mov	 DWORD PTR _ItemDropPer$[ebp], eax

; 4405 : 
; 4406 : 	ItemDropPer += gItemDropPer*lpTargetObj->SetOpImproveItemDropRate/100;

  00d29	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d2c	0f b6 88 4d 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3917]
  00d33	8b c1		 mov	 eax, ecx
  00d35	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?gItemDropPer@@3HA ; gItemDropPer
  00d3c	99		 cdq
  00d3d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00d42	f7 f9		 idiv	 ecx
  00d44	03 85 74 ff ff
	ff		 add	 eax, DWORD PTR _ItemDropPer$[ebp]
  00d4a	89 85 74 ff ff
	ff		 mov	 DWORD PTR _ItemDropPer$[ebp], eax

; 4407 : 
; 4408 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 4409 : #ifdef ADD_CASHITEM_4RD_MARK_20080723
; 4410 : 	{
; 4411 : 		int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4412 : 		if( iMaxHitUser >= 0 )
; 4413 : 		{
; 4414 : 			int iItemDropRate = gObjGetTotalValueOfEffect( &gObj[iMaxHitUser], EFFECTTYPE_ITEMDROPRATE );
; 4415 : 			if( iItemDropRate > 0 )
; 4416 : 			{
; 4417 : 				ItemDropPer = ItemDropPer * iItemDropRate / 100;
; 4418 : 				ExtDropPer = rand() % ( 2000 / iItemDropRate * 100 );
; 4419 : 			}
; 4420 : 		}
; 4421 : 	}
; 4422 : #endif // ADD_CASHITEM_4RD_MARK_20080723
; 4423 : 
; 4424 : #ifndef MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC	
; 4425 : #ifdef BUGFIX_BUFF_EFFECT_SYSTEM_FOR_PCBANG_ITEM_20071205	// PC방 아이템 획득 확률 증가
; 4426 : #endif // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 4427 : 	int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4428 : 	if( iMaxHitUser >= 0 )
; 4429 : 	{
; 4430 : 		int iItemDropRate = gObjGetTotalValueOfEffect( &gObj[iMaxHitUser], EFFECTTYPE_ITEMDROPRATE );
; 4431 : 		
; 4432 : 		if( iItemDropRate > 0 )
; 4433 : 		{
; 4434 : 			ItemDropPer = ItemDropPer * iItemDropRate / 100;
; 4435 : 			ExtDropPer = rand() % ( 2000 / iItemDropRate * 100 );
; 4436 : 		}		
; 4437 : 	}
; 4438 : #ifndef MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 4439 : #endif
; 4440 : #endif // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 4441 : #else
; 4442 : 
; 4443 : #ifdef ADD_PCS_MARK_OF_EXP_20070205
; 4444 : 	ItemDropPer = (int)(ItemDropPer * ((float) lpTargetObj->m_wItemDropRate / 100 ));

  00d50	f3 0f 2a 85 74
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _ItemDropPer$[ebp]
  00d58	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d5b	0f b7 88 2e 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6702]
  00d62	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00d66	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@42c80000
  00d6e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00d72	f3 0f 2c d0	 cvttss2si edx, xmm0
  00d76	89 95 74 ff ff
	ff		 mov	 DWORD PTR _ItemDropPer$[ebp], edx

; 4445 : #endif // ADD_PCS_MARK_OF_EXP_20070205
; 4446 : 	
; 4447 : #ifdef PCBANG_POINT_SYSTEM_20070206		// 아이템 획득 확률 증가
; 4448 : 	// PC방 포인트 아이템 획득확률이 적용된 유저 처리
; 4449 : 	int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 4450 : #ifdef MODIFY_MAXHITUSER_BUG_FIX_20070711
; 4451 : 	if(iMaxHitUser >= 0)
; 4452 : 	{
; 4453 : 		if( gObj[iMaxHitUser].m_iPCBangPointItemTime > 0 && gObj[iMaxHitUser].m_iPCBangPointItemGiveItemPer > 0 )
; 4454 : 
; 4455 : 		{
; 4456 : 			if( ItemDropPer > 0 )
; 4457 : 			{
; 4458 : 				ItemDropPer = ItemDropPer * gObj[iMaxHitUser].m_iPCBangPointItemGiveItemPer / 100;
; 4459 : 				ExtDropPer = rand() % ( 2000 / gObj[iMaxHitUser].m_iPCBangPointItemGiveItemPer * 100 );
; 4460 : 			}
; 4461 : 		}
; 4462 : 	}
; 4463 : #else	// MODIFY_MAXHITUSER_BUG_FIX_20070711
; 4464 : 	if( gObj[iMaxHitUser].m_iPCBangPointItemTime > 0 && gObj[iMaxHitUser].m_iPCBangPointItemGiveItemPer > 0 )
; 4465 : 
; 4466 : 	{
; 4467 : 		if( ItemDropPer > 0 )
; 4468 : 		{
; 4469 : 			ItemDropPer = ItemDropPer * gObj[iMaxHitUser].m_iPCBangPointItemGiveItemPer / 100;
; 4470 : 			ExtDropPer = rand() % ( 2000 / gObj[iMaxHitUser].m_iPCBangPointItemGiveItemPer * 100 );
; 4471 : 		}
; 4472 : 	}
; 4473 : #endif	// MODIFY_MAXHITUSER_BUG_FIX_20070711
; 4474 : #endif	
; 4475 : 
; 4476 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 4477 : 	
; 4478 : 	// 1/100 로 엑설런트 아이템을 떨어트린다.
; 4479 : 	if( ExtDropPer == 1 )

  00d7c	83 7d f8 01	 cmp	 DWORD PTR _ExtDropPer$[ebp], 1
  00d80	0f 85 b4 00 00
	00		 jne	 $LN58@gObjMonste

; 4480 : 	{
; 4481 : 		
; 4482 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 4483 : 		DropItem = g_MonsterItemMng.GetItem(lpObj->Level-25);

  00d86	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d89	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00d90	83 e9 19	 sub	 ecx, 25			; 00000019H
  00d93	51		 push	 ecx
  00d94	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterItemMng@@3VCMonsterItemMng@@A ; g_MonsterItemMng
  00d99	e8 00 00 00 00	 call	 ?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z ; CMonsterItemMng::GetItem
  00d9e	89 45 c4	 mov	 DWORD PTR _DropItem$[ebp], eax

; 4484 : 
; 4485 : #ifdef MODIFY_380_EXCELENT_ITEM_DISABLE_20080212	// 380 아이템 엑 안떨어지게
; 4486 : 		if( DropItem != NULL && g_kItemSystemFor380.Is380Item( DropItem ))
; 4487 : 		{
; 4488 : 			DropItem = NULL;
; 4489 : 		}
; 4490 : #endif	// MODIFY_380_EXCELENT_ITEM_DISABLE_20080212
; 4491 : 		
; 4492 : 		if( DropItem == NULL )

  00da1	83 7d c4 00	 cmp	 DWORD PTR _DropItem$[ebp], 0
  00da5	75 0c		 jne	 SHORT $LN60@gObjMonste

; 4493 : 		{
; 4494 : 			item_drop = 0;

  00da7	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0

; 4495 : 		}

  00dae	e9 85 00 00 00	 jmp	 $LN65@gObjMonste
$LN60@gObjMonste:

; 4496 : 		else
; 4497 : 		{
; 4498 : 			BOOL foundChangeupitem = FALSE;

  00db3	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _foundChangeupitem$14[ebp], 0

; 4499 : 			for( int i = 0; i < 4; i++ )

  00dbd	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$13[ebp], 0
  00dc7	eb 0f		 jmp	 SHORT $LN10@gObjMonste
$LN8@gObjMonste:
  00dc9	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _i$13[ebp]
  00dcf	83 c0 01	 add	 eax, 1
  00dd2	89 85 6c ff ff
	ff		 mov	 DWORD PTR _i$13[ebp], eax
$LN10@gObjMonste:
  00dd8	83 bd 6c ff ff
	ff 04		 cmp	 DWORD PTR _i$13[ebp], 4
  00ddf	7d 20		 jge	 SHORT $LN9@gObjMonste

; 4500 : 			{	// 전직용 아이템들은 엑설런트 아이템이 떨어질 확률을 더 낮게 한다
; 4501 : 				if( DropItem->m_RequireClass[i] > 1 )

  00de1	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00de4	03 85 6c ff ff
	ff		 add	 eax, DWORD PTR _i$13[ebp]
  00dea	0f b6 48 50	 movzx	 ecx, BYTE PTR [eax+80]
  00dee	83 f9 01	 cmp	 ecx, 1
  00df1	7e 0c		 jle	 SHORT $LN62@gObjMonste

; 4502 : 				{
; 4503 : 					foundChangeupitem = TRUE;

  00df3	c7 85 70 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _foundChangeupitem$14[ebp], 1

; 4504 : 					break;

  00dfd	eb 02		 jmp	 SHORT $LN9@gObjMonste
$LN62@gObjMonste:

; 4505 : 				}		
; 4506 : 			}

  00dff	eb c8		 jmp	 SHORT $LN8@gObjMonste
$LN9@gObjMonste:

; 4507 : 			
; 4508 : 			if( foundChangeupitem )

  00e01	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR _foundChangeupitem$14[ebp], 0
  00e08	74 10		 je	 SHORT $LN63@gObjMonste

; 4509 : 			{
; 4510 : 				ExtDropPer = rand()%100;			

  00e0a	e8 00 00 00 00	 call	 _rand
  00e0f	99		 cdq
  00e10	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00e15	f7 f9		 idiv	 ecx
  00e17	89 55 f8	 mov	 DWORD PTR _ExtDropPer$[ebp], edx
$LN63@gObjMonste:

; 4511 : 			}		
; 4512 : 			
; 4513 : 			if( ExtDropPer )

  00e1a	83 7d f8 00	 cmp	 DWORD PTR _ExtDropPer$[ebp], 0
  00e1e	74 18		 je	 SHORT $LN65@gObjMonste

; 4514 : 			{
; 4515 : 				if( (rand()%itemrate) < ItemDropPer )	

  00e20	e8 00 00 00 00	 call	 _rand
  00e25	99		 cdq
  00e26	f7 7d ac	 idiv	 DWORD PTR _itemrate$[ebp]
  00e29	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _ItemDropPer$[ebp]
  00e2f	7d 07		 jge	 SHORT $LN65@gObjMonste

; 4516 : 				{
; 4517 : 					item_drop = 1;

  00e31	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 1
$LN65@gObjMonste:

; 4518 : 				}
; 4519 : 			}
; 4520 : 		}
; 4521 : #else // UPGRADE_GAMESERVER_01_20041006
; 4522 : 		
; 4523 : 		// 몬스터 창고에서 엑설런트 아이템을 꺼낸다.
; 4524 : 		store_count = lpObj->WarehouseCount;
; 4525 : 		if( CHECK_LIMIT_NONZERO( store_count, MAX_WAREHOUSEITEMS) == FALSE) 
; 4526 : 		{			
; 4527 : 			return;
; 4528 : 		}
; 4529 : 		DropItemNum = rand()%store_count;
; 4530 : 		DropItem = &lpObj->pWarehouse[DropItemNum];
; 4531 : 
; 4532 : #ifdef NEW_SKILL_FORSKYLAND		
; 4533 : 		BOOL	foundChangeupitem = FALSE;
; 4534 : 		for( int i = 0; i < 4; i++ )
; 4535 : 		{	// 전직용 아이템들은 엑설런트 아이템이 떨어질 확률을 더 낮게 한다
; 4536 : 			if( DropItem->m_RequireClass[i] > 1 )
; 4537 : 			{
; 4538 : 				foundChangeupitem = TRUE;
; 4539 : 				break;
; 4540 : 			}		
; 4541 : 		}
; 4542 : 
; 4543 : 		if( foundChangeupitem )
; 4544 : 		{
; 4545 : 			ExtDropPer = rand()%100;			
; 4546 : 		}		
; 4547 : 
; 4548 : 		if( ExtDropPer )
; 4549 : 		{
; 4550 : 			if( (rand()%itemrate) < ItemDropPer )
; 4551 : 			{
; 4552 : 				item_drop = 1;
; 4553 : 			}
; 4554 : 		}
; 4555 : #else // NEW_SKILL_FORSKYLAND
; 4556 : 		if( (rand()%itemrate) < ItemDropPer )
; 4557 : 		{
; 4558 : 			item_drop = 1;
; 4559 : 		}
; 4560 : #endif // NEW_SKILL_FORSKYLAND
; 4561 : #endif // UPGRADE_GAMESERVER_01_20041006
; 4562 : 
; 4563 : 
; 4564 : 	}

  00e38	eb 3f		 jmp	 SHORT $LN68@gObjMonste
$LN58@gObjMonste:

; 4565 : 	else
; 4566 : 	{
; 4567 : 		if( (rand()%itemrate) < ItemDropPer )

  00e3a	e8 00 00 00 00	 call	 _rand
  00e3f	99		 cdq
  00e40	f7 7d ac	 idiv	 DWORD PTR _itemrate$[ebp]
  00e43	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _ItemDropPer$[ebp]
  00e49	7d 2e		 jge	 SHORT $LN68@gObjMonste

; 4568 : 		{			
; 4569 : 			DropItem = g_MonsterItemMng.GetItem(lpObj->Level);

  00e4b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e4e	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00e55	51		 push	 ecx
  00e56	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterItemMng@@3VCMonsterItemMng@@A ; g_MonsterItemMng
  00e5b	e8 00 00 00 00	 call	 ?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z ; CMonsterItemMng::GetItem
  00e60	89 45 c4	 mov	 DWORD PTR _DropItem$[ebp], eax

; 4570 : 			if( DropItem == NULL )

  00e63	83 7d c4 00	 cmp	 DWORD PTR _DropItem$[ebp], 0
  00e67	75 09		 jne	 SHORT $LN67@gObjMonste

; 4571 : 			{
; 4572 : 				item_drop = 0;

  00e69	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0

; 4573 : 			}

  00e70	eb 07		 jmp	 SHORT $LN68@gObjMonste
$LN67@gObjMonste:

; 4574 : 			else
; 4575 : 			{
; 4576 : 				item_drop = 1;

  00e72	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 1
$LN68@gObjMonste:

; 4577 : 			}
; 4578 : 		}
; 4579 : 	}
; 4580 : 
; 4581 : 	// 아이템이 없으면 아이템 드롭 없다.
; 4582 : 	if( item_drop )

  00e79	83 7d cc 00	 cmp	 DWORD PTR _item_drop$[ebp], 0
  00e7d	0f 84 ac 00 00
	00		 je	 $LN75@gObjMonste

; 4583 : 	{
; 4584 : 		if( DropItem->IsItem()==FALSE ) item_drop = 0;

  00e83	8b 4d c4	 mov	 ecx, DWORD PTR _DropItem$[ebp]
  00e86	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00e8b	85 c0		 test	 eax, eax
  00e8d	75 07		 jne	 SHORT $LN70@gObjMonste
  00e8f	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0
$LN70@gObjMonste:

; 4585 : 
; 4586 : 		if( (DropItem->m_Type >= ITEM_ETC) && (DropItem->m_Type <= ITEM_ETC + MAX_ITEM_INDEX)) {

  00e96	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00e99	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00e9d	81 f9 e0 01 00
	00		 cmp	 ecx, 480		; 000001e0H
  00ea3	7c 19		 jl	 SHORT $LN71@gObjMonste
  00ea5	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00ea8	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00eac	81 f9 00 02 00
	00		 cmp	 ecx, 512		; 00000200H
  00eb2	7f 0a		 jg	 SHORT $LN71@gObjMonste

; 4587 : 			INT I = 0;

  00eb4	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _I$12[ebp], 0
$LN71@gObjMonste:

; 4588 : 		}
; 4589 : 				
; 4590 : #ifdef NEW_FORSKYLAND2
; 4591 : 		// 데빌스퀘어 드롭 아이템 제한(극히 드물게)
; 4592 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 4593 : 		if( CHECK_DEVILSQUARE(lpObj->MapNumber) )
; 4594 : #else
; 4595 : 		if( lpObj->MapNumber == MAP_INDEX_DEVILSQUARE )

  00ebe	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ec1	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00ec8	83 f9 09	 cmp	 ecx, 9
  00ecb	75 2c		 jne	 SHORT $LN74@gObjMonste

; 4596 : #endif
; 4597 : 		{	
; 4598 : 			if( !IsCanNotItemDtopInDevilSquare(DropItem->m_Type) )

  00ecd	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00ed0	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00ed4	51		 push	 ecx
  00ed5	e8 00 00 00 00	 call	 ?IsCanNotItemDtopInDevilSquare@@YAHH@Z ; IsCanNotItemDtopInDevilSquare
  00eda	83 c4 04	 add	 esp, 4
  00edd	85 c0		 test	 eax, eax
  00edf	75 18		 jne	 SHORT $LN74@gObjMonste

; 4599 : 			{
; 4600 : 				if( rand()%10 != 0 )

  00ee1	e8 00 00 00 00	 call	 _rand
  00ee6	99		 cdq
  00ee7	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00eec	f7 f9		 idiv	 ecx
  00eee	85 d2		 test	 edx, edx
  00ef0	74 07		 je	 SHORT $LN74@gObjMonste

; 4601 : 				{
; 4602 : 					item_drop = 0;

  00ef2	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0
$LN74@gObjMonste:

; 4603 : 				}
; 4604 : 			}
; 4605 : 		}
; 4606 : #endif
; 4607 : 		
; 4608 : #ifdef MODIFY_LIMIT_SOCKET_ITEM_DROP_MAP_RAKLION_20080825
; 4609 : 	// 소켓 아이템은 라클리온 맵에서만 드롭 되도록 수정
; 4610 : 		if( g_SocketOptionSystem.IsEnableSocketItem( DropItem->m_Type ) == true )
; 4611 : 		{
; 4612 : 			if( g_SocketOptionSystem.IsEnableDropSocketItemMap( lpObj->MapNumber ) == false )
; 4613 : 			{
; 4614 : 				item_drop = 0;
; 4615 : 			}
; 4616 : 		}
; 4617 : #endif // MODIFY_LIMIT_SOCKET_ITEM_DROP_MAP_RAKLION_20080825
; 4618 : 
; 4619 : #ifdef FEATHEROFLOKE_ITEMDROP_CHECK
; 4620 : 		if( g_GlobalConfig.m_bFeatherOnlyIcarus == TRUE && DropItem->m_Type == MAKE_ITEMNUM(13,14) && lpObj->MapNumber != MAP_INDEX_ICARUS )

  00ef9	83 3d 10 00 00
	00 01		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+16, 1
  00f00	75 2d		 jne	 SHORT $LN75@gObjMonste
  00f02	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00f05	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00f09	6a 0e		 push	 14			; 0000000eH
  00f0b	6a 0d		 push	 13			; 0000000dH
  00f0d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00f12	83 c4 08	 add	 esp, 8
  00f15	3b f0		 cmp	 esi, eax
  00f17	75 16		 jne	 SHORT $LN75@gObjMonste
  00f19	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f1c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00f23	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00f26	74 07		 je	 SHORT $LN75@gObjMonste

; 4621 : 		{	// 로크의 깃털이 이카루스가 아닌곳이면 떨어지지 않는다
; 4622 : 			item_drop = 0;

  00f28	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0
$LN75@gObjMonste:

; 4623 : 		}
; 4624 : #endif
; 4625 : 
; 4626 : #ifdef MU_CRYWOLF_PENALTY_20051215
; 4627 : 		// MVP 실패 : 보석 드랍률 하락.
; 4628 : 		if( g_CrywolfSync.GetOccupationState() == CRYWOLF_OCCUPATION_STATE_OCCUPIED 
; 4629 : 			&& g_iCrywolfApplyMvpPenalty
; 4630 : 		  )
; 4631 : 		{
; 4632 : 			if(	DropItem->m_Type == MAKE_ITEMNUM(14, 13)	// 축석
; 4633 : 				|| DropItem->m_Type == MAKE_ITEMNUM(14, 14)	// 영석
; 4634 : 				|| DropItem->m_Type == MAKE_ITEMNUM(14, 16)	// 생석
; 4635 : 				|| DropItem->m_Type == MAKE_ITEMNUM(14, 22)	// 창석
; 4636 : 				|| DropItem->m_Type == MAKE_ITEMNUM(12, 15)	// 혼석
; 4637 : 				|| DropItem->m_Type == MAKE_ITEMNUM(14, 31)	// 수호 보석) 
; 4638 : 			  )
; 4639 : 			{
; 4640 : 				if( rand()%100 > g_CrywolfSync.GetGemDropPenaltiyRate() )
; 4641 : 				{
; 4642 : 					item_drop = 0;
; 4643 : 				}
; 4644 : 			}
; 4645 : 
; 4646 : 		}
; 4647 : #endif
; 4648 : 
; 4649 : 	}
; 4650 : 	
; 4651 : //#if (TESTSERVER==0)
; 4652 : 	if( item_drop )

  00f2f	83 7d cc 00	 cmp	 DWORD PTR _item_drop$[ebp], 0
  00f33	0f 84 0a 03 00
	00		 je	 $LN76@gObjMonste

; 4653 : //#endif
; 4654 : 	{
; 4655 : 		type = DropItem->m_Type;

  00f39	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00f3c	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00f40	89 4d f0	 mov	 DWORD PTR _type$[ebp], ecx

; 4656 : 		level= DropItem->m_Level;

  00f43	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00f46	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00f4a	89 4d ec	 mov	 DWORD PTR _level$[ebp], ecx

; 4657 : 
; 4658 : #ifdef MODIFY_EXCELLENT_ITEM_DUR_01_20041202
; 4659 : 		if( ExtDropPer == 1 )

  00f4d	83 7d f8 01	 cmp	 DWORD PTR _ExtDropPer$[ebp], 1
  00f51	75 21		 jne	 SHORT $LN78@gObjMonste

; 4660 : 	#ifdef MODIFY_EXCELLENT_DROP_DURATION_BUG_20060524
; 4661 : 			// 엑설런트 아이템인 경우 아이템의 레벨을 0으로 한다.
; 4662 : 			// DropItem->m_Level값으로 dur을 구하기 때문에 실제 생성시 값 차이가 난다.
; 4663 : 			dur  = ItemGetDurability( DropItem->m_Type, 0, TRUE, FALSE );

  00f53	6a 00		 push	 0
  00f55	6a 01		 push	 1
  00f57	6a 00		 push	 0
  00f59	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00f5c	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00f60	51		 push	 ecx
  00f61	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00f66	83 c4 10	 add	 esp, 16			; 00000010H
  00f69	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00f6d	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0
  00f72	eb 0d		 jmp	 SHORT $LN79@gObjMonste
$LN78@gObjMonste:

; 4664 : 	#else
; 4665 : 			dur  = ItemGetDurability( DropItem->m_Type, DropItem->m_Level, TRUE, FALSE );
; 4666 : 	#endif // MODIFY_EXCELLENT_DROP_DURATION_BUG_20060524
; 4667 : 		else
; 4668 : 			dur  = DropItem->m_Durability;

  00f74	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00f77	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00f7c	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0
$LN79@gObjMonste:

; 4669 : #else
; 4670 : 		dur  = DropItem->m_Durability;
; 4671 : #endif
; 4672 : 
; 4673 : 		x    = lpObj->X;

  00f81	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f84	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00f8b	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4674 : 		y    = lpObj->Y;

  00f8e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f91	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00f98	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4675 : 				
; 4676 : 		
; 4677 : 		int option1rand, option2rand, option3rand, optionc;
; 4678 : 		
; 4679 : 
; 4680 : 		// 엑설런트 아이템의 경우 스킬은 무조건 붙으며 기존 옵션들은 정말 희박함
; 4681 : 		if( ExtDropPer == 1 )

  00f9b	83 7d f8 01	 cmp	 DWORD PTR _ExtDropPer$[ebp], 1
  00f9f	75 59		 jne	 SHORT $LN80@gObjMonste

; 4682 : 		{
; 4683 : 			option1rand = 100;

  00fa1	c7 85 64 ff ff
	ff 64 00 00 00	 mov	 DWORD PTR _option1rand$11[ebp], 100 ; 00000064H

; 4684 : 			option2rand = 1;

  00fab	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _option2rand$10[ebp], 1

; 4685 : 			option3rand = (rand()%100);

  00fb5	e8 00 00 00 00	 call	 _rand
  00fba	99		 cdq
  00fbb	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00fc0	f7 f9		 idiv	 ecx
  00fc2	89 95 5c ff ff
	ff		 mov	 DWORD PTR _option3rand$9[ebp], edx

; 4686 : 			optionc		= (rand()%3);

  00fc8	e8 00 00 00 00	 call	 _rand
  00fcd	99		 cdq
  00fce	b9 03 00 00 00	 mov	 ecx, 3
  00fd3	f7 f9		 idiv	 ecx
  00fd5	89 95 58 ff ff
	ff		 mov	 DWORD PTR _optionc$8[ebp], edx

; 4687 : 			NOption		= NewOptionRand(lpObj->Level);

  00fdb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fde	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00fe5	51		 push	 ecx
  00fe6	e8 00 00 00 00	 call	 ?NewOptionRand@@YAEH@Z	; NewOptionRand
  00feb	83 c4 04	 add	 esp, 4
  00fee	88 45 d3	 mov	 BYTE PTR _NOption$[ebp], al

; 4688 : 			level       = 0;

  00ff1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 4689 : 		}

  00ff8	eb 3e		 jmp	 SHORT $LN81@gObjMonste
$LN80@gObjMonste:

; 4690 : 		else
; 4691 : 		{
; 4692 : 			option1rand = 6;				// 일반적인 옵션1 (스킬) 붙을 확률 6/100

  00ffa	c7 85 64 ff ff
	ff 06 00 00 00	 mov	 DWORD PTR _option1rand$11[ebp], 6

; 4693 : 			option2rand = 4;				// 일반적인 옵션2 (행운) 붙을 확률 4/100

  01004	c7 85 60 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR _option2rand$10[ebp], 4

; 4694 : 			option3rand = (rand()%100);		// 일반적인 옵션3 (추가포인트) 붙을 확률 랜덤/100

  0100e	e8 00 00 00 00	 call	 _rand
  01013	99		 cdq
  01014	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01019	f7 f9		 idiv	 ecx
  0101b	89 95 5c ff ff
	ff		 mov	 DWORD PTR _option3rand$9[ebp], edx

; 4695 : 			optionc		= (rand()%3);

  01021	e8 00 00 00 00	 call	 _rand
  01026	99		 cdq
  01027	b9 03 00 00 00	 mov	 ecx, 3
  0102c	f7 f9		 idiv	 ecx
  0102e	89 95 58 ff ff
	ff		 mov	 DWORD PTR _optionc$8[ebp], edx

; 4696 : 			NOption     = 0;

  01034	c6 45 d3 00	 mov	 BYTE PTR _NOption$[ebp], 0
$LN81@gObjMonste:

; 4697 : 		}
; 4698 : 
; 4699 : 		// 스킬아이템 확률을 대폭 낮춘다.
; 4700 : 		if((rand()%100) < option1rand ) Option1 = 1;

  01038	e8 00 00 00 00	 call	 _rand
  0103d	99		 cdq
  0103e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  01043	f7 f9		 idiv	 ecx
  01045	3b 95 64 ff ff
	ff		 cmp	 edx, DWORD PTR _option1rand$11[ebp]
  0104b	7d 07		 jge	 SHORT $LN82@gObjMonste
  0104d	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1
$LN82@gObjMonste:

; 4701 : 		if((rand()%100) < option2rand ) Option2 = 1;

  01054	e8 00 00 00 00	 call	 _rand
  01059	99		 cdq
  0105a	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0105f	f7 f9		 idiv	 ecx
  01061	3b 95 60 ff ff
	ff		 cmp	 edx, DWORD PTR _option2rand$10[ebp]
  01067	7d 07		 jge	 SHORT $LN83@gObjMonste
  01069	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN83@gObjMonste:

; 4702 : 
; 4703 : 		switch( optionc )

  01070	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _optionc$8[ebp]
  01076	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv746[ebp], eax
  0107c	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR tv746[ebp], 0
  01083	74 14		 je	 SHORT $LN84@gObjMonste
  01085	83 bd f8 fe ff
	ff 01		 cmp	 DWORD PTR tv746[ebp], 1
  0108c	74 1d		 je	 SHORT $LN86@gObjMonste
  0108e	83 bd f8 fe ff
	ff 02		 cmp	 DWORD PTR tv746[ebp], 2
  01095	74 26		 je	 SHORT $LN88@gObjMonste
  01097	eb 34		 jmp	 SHORT $LN11@gObjMonste
$LN84@gObjMonste:

; 4704 : 		{
; 4705 : 		case 0 :
; 4706 : 			if( option3rand < 4 ) Option3 = 3;	// 옵션

  01099	83 bd 5c ff ff
	ff 04		 cmp	 DWORD PTR _option3rand$9[ebp], 4
  010a0	7d 07		 jge	 SHORT $LN85@gObjMonste
  010a2	c7 45 d4 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3
$LN85@gObjMonste:

; 4707 : 			break;

  010a9	eb 22		 jmp	 SHORT $LN11@gObjMonste
$LN86@gObjMonste:

; 4708 : 		case 1 :
; 4709 : 			if( option3rand < 8 ) Option3 = 2;	// 옵션

  010ab	83 bd 5c ff ff
	ff 08		 cmp	 DWORD PTR _option3rand$9[ebp], 8
  010b2	7d 07		 jge	 SHORT $LN87@gObjMonste
  010b4	c7 45 d4 02 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 2
$LN87@gObjMonste:

; 4710 : 			break;

  010bb	eb 10		 jmp	 SHORT $LN11@gObjMonste
$LN88@gObjMonste:

; 4711 : 		case 2 :
; 4712 : 			if( option3rand < 12 ) Option3 = 1;	// 옵션

  010bd	83 bd 5c ff ff
	ff 0c		 cmp	 DWORD PTR _option3rand$9[ebp], 12 ; 0000000cH
  010c4	7d 07		 jge	 SHORT $LN89@gObjMonste
  010c6	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 1
$LN89@gObjMonste:
$LN11@gObjMonste:

; 4713 : 			break;
; 4714 : 		}
; 4715 : 
; 4716 : //#if (TESTSERVER==0)
; 4717 : 		if( lpObj->Class == 43  )

  010cd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010d0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  010d7	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  010da	75 1e		 jne	 SHORT $LN90@gObjMonste

; 4718 : //#endif
; 4719 : 		{
; 4720 : 			Option1 = DropItem->m_Option1;

  010dc	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  010df	0f b6 48 78	 movzx	 ecx, BYTE PTR [eax+120]
  010e3	89 4d dc	 mov	 DWORD PTR _Option1$[ebp], ecx

; 4721 : 			Option2 = DropItem->m_Option2;

  010e6	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  010e9	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  010ed	89 4d d8	 mov	 DWORD PTR _Option2$[ebp], ecx

; 4722 : 			Option3 = DropItem->m_Option3;

  010f0	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  010f3	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  010f7	89 4d d4	 mov	 DWORD PTR _Option3$[ebp], ecx
$LN90@gObjMonste:

; 4723 : 		}
; 4724 : 		
; 4725 : 		// 영석/축석/혼석 에는 옵션이나 스킬들이 안붙게..
; 4726 : 		if( type == MAKE_ITEMNUM(12,15) ||
; 4727 : 			type == MAKE_ITEMNUM(14,13) ||
; 4728 : 			type == MAKE_ITEMNUM(14,14) ||

  010fa	6a 0f		 push	 15			; 0000000fH
  010fc	6a 0c		 push	 12			; 0000000cH
  010fe	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01103	83 c4 08	 add	 esp, 8
  01106	39 45 f0	 cmp	 DWORD PTR _type$[ebp], eax
  01109	74 33		 je	 SHORT $LN92@gObjMonste
  0110b	6a 0d		 push	 13			; 0000000dH
  0110d	6a 0e		 push	 14			; 0000000eH
  0110f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01114	83 c4 08	 add	 esp, 8
  01117	39 45 f0	 cmp	 DWORD PTR _type$[ebp], eax
  0111a	74 22		 je	 SHORT $LN92@gObjMonste
  0111c	6a 0e		 push	 14			; 0000000eH
  0111e	6a 0e		 push	 14			; 0000000eH
  01120	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01125	83 c4 08	 add	 esp, 8
  01128	39 45 f0	 cmp	 DWORD PTR _type$[ebp], eax
  0112b	74 11		 je	 SHORT $LN92@gObjMonste
  0112d	6a 10		 push	 16			; 00000010H
  0112f	6a 0e		 push	 14			; 0000000eH
  01131	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01136	83 c4 08	 add	 esp, 8
  01139	39 45 f0	 cmp	 DWORD PTR _type$[ebp], eax
  0113c	75 19		 jne	 SHORT $LN91@gObjMonste
$LN92@gObjMonste:

; 4729 : #ifdef ADD_NEW_GEM_OF_DEFEND_FOR_CS_01_20050301
; 4730 : 			type == MAKE_ITEMNUM(14,31) ||
; 4731 : #endif
; 4732 : 			type == MAKE_ITEMNUM(14,16) )
; 4733 : 		{
; 4734 : 			Option1 = 0;

  0113e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0

; 4735 : 			Option2 = 0;

  01145	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0

; 4736 : 			Option3 = 0;

  0114c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 4737 : 			NOption = 0;

  01153	c6 45 d3 00	 mov	 BYTE PTR _NOption$[ebp], 0
$LN91@gObjMonste:

; 4738 : 		}
; 4739 : 		
; 4740 : 		
; 4741 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  01157	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0115a	50		 push	 eax
  0115b	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  01160	83 c4 04	 add	 esp, 4
  01163	89 85 54 ff ff
	ff		 mov	 DWORD PTR _MaxHitUser$7[ebp], eax

; 4742 : 
; 4743 : 		if( DropItem->m_serial )

  01169	8b 45 c4	 mov	 eax, DWORD PTR _DropItem$[ebp]
  0116c	0f be 48 04	 movsx	 ecx, BYTE PTR [eax+4]
  01170	85 c9		 test	 ecx, ecx
  01172	74 56		 je	 SHORT $LN93@gObjMonste

; 4744 : 		{
; 4745 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, Option1, Option2, Option3, MaxHitUser, NOption );

  01174	6a 00		 push	 0
  01176	6a 00		 push	 0
  01178	0f b6 45 d3	 movzx	 eax, BYTE PTR _NOption$[ebp]
  0117c	50		 push	 eax
  0117d	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _MaxHitUser$7[ebp]
  01183	51		 push	 ecx
  01184	0f b6 55 d4	 movzx	 edx, BYTE PTR _Option3$[ebp]
  01188	52		 push	 edx
  01189	0f b6 45 d8	 movzx	 eax, BYTE PTR _Option2$[ebp]
  0118d	50		 push	 eax
  0118e	0f b6 4d dc	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  01192	51		 push	 ecx
  01193	f3 0f 2c 55 e0	 cvttss2si edx, DWORD PTR _dur$[ebp]
  01198	0f b6 c2	 movzx	 eax, dl
  0119b	50		 push	 eax
  0119c	0f b6 4d ec	 movzx	 ecx, BYTE PTR _level$[ebp]
  011a0	51		 push	 ecx
  011a1	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  011a4	52		 push	 edx
  011a5	0f b6 45 e4	 movzx	 eax, BYTE PTR _y$[ebp]
  011a9	50		 push	 eax
  011aa	0f b6 4d e8	 movzx	 ecx, BYTE PTR _x$[ebp]
  011ae	51		 push	 ecx
  011af	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  011b2	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  011b9	50		 push	 eax
  011ba	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  011bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  011bf	52		 push	 edx
  011c0	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  011c5	83 c4 38	 add	 esp, 56			; 00000038H

; 4746 : 		}

  011c8	eb 55		 jmp	 SHORT $LN94@gObjMonste
$LN93@gObjMonste:

; 4747 : 		else 
; 4748 : 		{
; 4749 : 			MapC[lpObj->MapNumber].MonsterItemDrop(type, level, dur, x, y, Option1, Option2, Option3, NOption, 0, MaxHitUser);			

  011ca	6a 00		 push	 0
  011cc	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _MaxHitUser$7[ebp]
  011d2	50		 push	 eax
  011d3	6a 00		 push	 0
  011d5	0f b6 4d d3	 movzx	 ecx, BYTE PTR _NOption$[ebp]
  011d9	51		 push	 ecx
  011da	0f b6 55 d4	 movzx	 edx, BYTE PTR _Option3$[ebp]
  011de	52		 push	 edx
  011df	0f b6 45 d8	 movzx	 eax, BYTE PTR _Option2$[ebp]
  011e3	50		 push	 eax
  011e4	0f b6 4d dc	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  011e8	51		 push	 ecx
  011e9	8b 55 e4	 mov	 edx, DWORD PTR _y$[ebp]
  011ec	52		 push	 edx
  011ed	8b 45 e8	 mov	 eax, DWORD PTR _x$[ebp]
  011f0	50		 push	 eax
  011f1	51		 push	 ecx
  011f2	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _dur$[ebp]
  011f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011fc	8b 4d ec	 mov	 ecx, DWORD PTR _level$[ebp]
  011ff	51		 push	 ecx
  01200	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  01203	52		 push	 edx
  01204	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01207	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0120e	69 c9 8c 04 05
	00		 imul	 ecx, ecx, 328844
  01214	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0121a	e8 00 00 00 00	 call	 ?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z ; MapClass::MonsterItemDrop
$LN94@gObjMonste:

; 4750 : 		}
; 4751 : 
; 4752 : 		cexDrop.DropItem(lpObj,&gObj[MaxHitUser]);

  0121f	69 85 54 ff ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _MaxHitUser$7[ebp], 7072
  01229	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0122f	50		 push	 eax
  01230	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01233	51		 push	 ecx
  01234	b9 00 00 00 00	 mov	 ecx, OFFSET ?cexDrop@@3VcDropSystem@@A ; cexDrop
  01239	e8 00 00 00 00	 call	 ?DropItem@cDropSystem@@QAE_NPAVOBJECTSTRUCT@@0@Z ; cDropSystem::DropItem

; 4753 : 	}

  0123e	e9 51 01 00 00	 jmp	 $LN98@gObjMonste
$LN76@gObjMonste:

; 4754 : //#if (TESTSERVER==0)
; 4755 : 	else 
; 4756 : 	{
; 4757 : 		if( lpObj->Money < 1 ) 

  01243	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01246	83 b8 b0 00 00
	00 01		 cmp	 DWORD PTR [eax+176], 1
  0124d	7d 05		 jge	 SHORT $LN95@gObjMonste

; 4758 : 		{			
; 4759 : 			return;

  0124f	e9 f2 02 00 00	 jmp	 $LN1@gObjMonste
$LN95@gObjMonste:

; 4760 : 		}
; 4761 : 		
; 4762 : 		if( (rand()%moneyrate) < 10 )

  01254	e8 00 00 00 00	 call	 _rand
  01259	99		 cdq
  0125a	f7 7d a8	 idiv	 DWORD PTR _moneyrate$[ebp]
  0125d	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  01260	0f 8d 2e 01 00
	00		 jge	 $LN98@gObjMonste

; 4763 : 		{
; 4764 : 			// 돈을 떨어트린다.			
; 4765 : 			int x, y;
; 4766 : 			float money;
; 4767 : 			
; 4768 : 			x    = lpObj->X;

  01266	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01269	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  01270	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _x$6[ebp], ecx

; 4769 : 			y    = lpObj->Y;

  01276	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01279	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  01280	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _y$5[ebp], ecx

; 4770 : 			
; 4771 : 			money = (float)lpObj->Money;

  01286	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01289	f3 0f 2a 80 b0
	00 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+176]
  01291	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _money$4[ebp], xmm0

; 4772 : 			
; 4773 : #ifdef UPDATE_ZEN_DROP_DOWN_20080806	// 몬스터 죽였을 시 드롭젠 (경험치 / 2)
; 4774 : #ifndef FOR_NEW_TESTSERVER			
; 4775 : 			money /= 2;

  01299	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _money$4[ebp]
  012a1	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  012a9	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _money$4[ebp], xmm0

; 4776 : #endif
; 4777 : 			// 몬스터 죽였을때 얻는돈
; 4778 : 			money += money/100*lpTargetObj->MonsterDieGetMoney;

  012b1	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _money$4[ebp]
  012b9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  012c1	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  012c4	0f bf 88 16 01
	00 00		 movsx	 ecx, WORD PTR [eax+278]
  012cb	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  012cf	f3 0f 59 c1	 mulss	 xmm0, xmm1
  012d3	f3 0f 58 85 48
	ff ff ff	 addss	 xmm0, DWORD PTR _money$4[ebp]
  012db	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _money$4[ebp], xmm0

; 4779 : #else	// UPDATE_ZEN_DROP_DOWN_20080806
; 4780 : 			// 몬스터 죽였을때 얻는돈
; 4781 : 			money += money/100*lpTargetObj->MonsterDieGetMoney;
; 4782 : 
; 4783 : 			money += 7;
; 4784 : #endif	// UPDATE_ZEN_DROP_DOWN_20080806
; 4785 : 
; 4786 : #ifdef FOR_NEW_TESTSERVER			
; 4787 : //			money *= 3;		// 젠 드롭 3배
; 4788 : #endif
; 4789 : 			
; 4790 : #ifdef ADD_ZEN_OPTION_20070903	// 추가 젠
; 4791 : 			money *= gAddZen;

  012e3	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _money$4[ebp]
  012eb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?gAddZen@@3MA
  012f3	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _money$4[ebp], xmm0

; 4792 : #endif
; 4793 : 
; 4794 : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122		// 패시브 1차 - 젠 증가
; 4795 : 			if( lpTargetObj->m_MPSkillOpt.iMpsPlusZen > 0 )
; 4796 : 			{
; 4797 : 				// 드롭젠 (경험치 / 2) 젠증가 스킬에 적용 (20081107 - grooving)
; 4798 : 				money += ( money * lpTargetObj->m_MPSkillOpt.iMpsPlusZen ) / 100;
; 4799 : 			}
; 4800 : #endif
; 4801 : 			
; 4802 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 4803 : 			if( CHECK_DEVILSQUARE(lpObj->MapNumber) )
; 4804 : #else
; 4805 : 			if( lpObj->MapNumber == 9 )

  012fb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012fe	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  01305	83 f9 09	 cmp	 ecx, 9
  01308	75 58		 jne	 SHORT $LN97@gObjMonste

; 4806 : #endif
; 4807 : 			{	// 악마의 광장에서는 돈을 누적한다
; 4808 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0130a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0130d	50		 push	 eax
  0130e	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  01313	83 c4 04	 add	 esp, 4
  01316	89 85 44 ff ff
	ff		 mov	 DWORD PTR _MaxHitUser$3[ebp], eax

; 4809 : #ifdef MODIFY_MAXHITUSER_BUG_FIX_20070711
; 4810 : 				if(MaxHitUser == -1)

  0131c	83 bd 44 ff ff
	ff ff		 cmp	 DWORD PTR _MaxHitUser$3[ebp], -1
  01323	75 05		 jne	 SHORT $LN99@gObjMonste

; 4811 : 					return;

  01325	e9 1c 02 00 00	 jmp	 $LN1@gObjMonste
$LN99@gObjMonste:

; 4812 : #endif
; 4813 : 				gObj[MaxHitUser].m_nEventMoney += (int)money;				

  0132a	69 85 44 ff ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _MaxHitUser$3[ebp], 7072
  01334	f3 0f 2c 8d 48
	ff ff ff	 cvttss2si ecx, DWORD PTR _money$4[ebp]
  0133c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01342	03 8c 02 cc 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3276]
  01349	69 85 44 ff ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _MaxHitUser$3[ebp], 7072
  01353	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01359	89 8c 02 cc 0c
	00 00		 mov	 DWORD PTR [edx+eax+3276], ecx

; 4814 : 			}

  01360	eb 32		 jmp	 SHORT $LN98@gObjMonste
$LN97@gObjMonste:

; 4815 : 			else
; 4816 : 			{
; 4817 : 				MapC[lpObj->MapNumber].MoneyItemDrop((int)money, x ,y);

  01362	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _y$5[ebp]
  01368	50		 push	 eax
  01369	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _x$6[ebp]
  0136f	51		 push	 ecx
  01370	f3 0f 2c 95 48
	ff ff ff	 cvttss2si edx, DWORD PTR _money$4[ebp]
  01378	52		 push	 edx
  01379	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0137c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  01383	69 c9 8c 04 05
	00		 imul	 ecx, ecx, 328844
  01389	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0138f	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN98@gObjMonste:

; 4818 : 			}
; 4819 : 		}		
; 4820 : 	}
; 4821 : //#endif
; 4822 : 	if( lpObj->Money < 1 ) 

  01394	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01397	83 b8 b0 00 00
	00 01		 cmp	 DWORD PTR [eax+176], 1
  0139e	7d 05		 jge	 SHORT $LN100@gObjMonste

; 4823 : 	{		
; 4824 : 		return;

  013a0	e9 a1 01 00 00	 jmp	 $LN1@gObjMonste
$LN100@gObjMonste:

; 4825 : 	}
; 4826 : 
; 4827 : 	if( lpObj->m_stateEngagePVP == PVP_USER_PLAYING )

  013a5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013a8	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  013af	75 05		 jne	 SHORT $LN101@gObjMonste

; 4828 : 		return;

  013b1	e9 90 01 00 00	 jmp	 $LN1@gObjMonste
$LN101@gObjMonste:

; 4829 : 
; 4830 : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 4831 : 	if( CHECK_DEVILSQUARE(lpObj->MapNumber) )
; 4832 : #else
; 4833 : 	if( lpObj->MapNumber == 9 )

  013b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013b9	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  013c0	83 f9 09	 cmp	 ecx, 9
  013c3	75 05		 jne	 SHORT $LN102@gObjMonste

; 4834 : #endif
; 4835 : 		return;

  013c5	e9 7c 01 00 00	 jmp	 $LN1@gObjMonste
$LN102@gObjMonste:

; 4836 : 		
; 4837 : 	// 400분의 1로 돈을 4개 뭉태기로 떨어트린다.
; 4838 : 	if( (rand()%400) == 1 )

  013ca	e8 00 00 00 00	 call	 _rand
  013cf	99		 cdq
  013d0	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  013d5	f7 f9		 idiv	 ecx
  013d7	83 fa 01	 cmp	 edx, 1
  013da	0f 85 ac 00 00
	00		 jne	 $LN14@gObjMonste

; 4839 : 	{		
; 4840 : 		for( n=0; n<4; n++)

  013e0	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  013e7	eb 09		 jmp	 SHORT $LN15@gObjMonste
$LN13@gObjMonste:
  013e9	8b 45 c8	 mov	 eax, DWORD PTR _n$[ebp]
  013ec	83 c0 01	 add	 eax, 1
  013ef	89 45 c8	 mov	 DWORD PTR _n$[ebp], eax
$LN15@gObjMonste:
  013f2	83 7d c8 04	 cmp	 DWORD PTR _n$[ebp], 4
  013f6	0f 8d 90 00 00
	00		 jge	 $LN14@gObjMonste

; 4841 : 		{
; 4842 : 			int x, y;
; 4843 : 			x   = lpObj->X-2;

  013fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013ff	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  01406	83 e9 02	 sub	 ecx, 2
  01409	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _x$2[ebp], ecx

; 4844 : 			y   = lpObj->Y-2;

  0140f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01412	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  01419	83 e9 02	 sub	 ecx, 2
  0141c	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _y$1[ebp], ecx

; 4845 : 			x   += rand()%3;

  01422	e8 00 00 00 00	 call	 _rand
  01427	99		 cdq
  01428	b9 03 00 00 00	 mov	 ecx, 3
  0142d	f7 f9		 idiv	 ecx
  0142f	03 95 40 ff ff
	ff		 add	 edx, DWORD PTR _x$2[ebp]
  01435	89 95 40 ff ff
	ff		 mov	 DWORD PTR _x$2[ebp], edx

; 4846 : 			y   += rand()%3;

  0143b	e8 00 00 00 00	 call	 _rand
  01440	99		 cdq
  01441	b9 03 00 00 00	 mov	 ecx, 3
  01446	f7 f9		 idiv	 ecx
  01448	03 95 3c ff ff
	ff		 add	 edx, DWORD PTR _y$1[ebp]
  0144e	89 95 3c ff ff
	ff		 mov	 DWORD PTR _y$1[ebp], edx

; 4847 : 			MapC[lpObj->MapNumber].MoneyItemDrop(lpObj->Money, x ,y);

  01454	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _y$1[ebp]
  0145a	50		 push	 eax
  0145b	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _x$2[ebp]
  01461	51		 push	 ecx
  01462	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01465	8b 82 b0 00 00
	00		 mov	 eax, DWORD PTR [edx+176]
  0146b	50		 push	 eax
  0146c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0146f	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  01476	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  0147c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  01482	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 4848 : 		}

  01487	e9 5d ff ff ff	 jmp	 $LN13@gObjMonste
$LN14@gObjMonste:

; 4849 : 	}
; 4850 : 	if( gEvent1ItemDropTodayPercent > 0 )

  0148c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gEvent1ItemDropTodayPercent@@3HA, 0 ; gEvent1ItemDropTodayPercent
  01493	0f 8e ad 00 00
	00		 jle	 $LN106@gObjMonste

; 4851 : 	{
; 4852 : 		if( (rand()%gEvent1ItemDropTodayPercent) == 0 )

  01499	e8 00 00 00 00	 call	 _rand
  0149e	99		 cdq
  0149f	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?gEvent1ItemDropTodayPercent@@3HA ; gEvent1ItemDropTodayPercent
  014a5	85 d2		 test	 edx, edx
  014a7	0f 85 99 00 00
	00		 jne	 $LN106@gObjMonste

; 4853 : 		{
; 4854 : 			if( gEvent1ItemDropTodayCount < gEvent1ItemDropTodayMax ) 

  014ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEvent1ItemDropTodayCount@@3HA ; gEvent1ItemDropTodayCount
  014b2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?gEvent1ItemDropTodayMax@@3HA ; gEvent1ItemDropTodayMax
  014b8	0f 8d 88 00 00
	00		 jge	 $LN106@gObjMonste

; 4855 : 			{
; 4856 : 				gEvent1ItemDropTodayCount++;

  014be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEvent1ItemDropTodayCount@@3HA ; gEvent1ItemDropTodayCount
  014c3	83 c0 01	 add	 eax, 1
  014c6	a3 00 00 00 00	 mov	 DWORD PTR ?gEvent1ItemDropTodayCount@@3HA, eax ; gEvent1ItemDropTodayCount

; 4857 : 				type = ItemGetNumberMake(14, 12);

  014cb	6a 0c		 push	 12			; 0000000cH
  014cd	6a 0e		 push	 14			; 0000000eH
  014cf	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  014d4	83 c4 08	 add	 esp, 8
  014d7	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 4858 : 				
; 4859 : 				// 러브팡팡 아이템 
; 4860 : 				dur		= 0;

  014da	0f 57 c0	 xorps	 xmm0, xmm0
  014dd	f3 0f 11 45 e0	 movss	 DWORD PTR _dur$[ebp], xmm0

; 4861 : 				x		= lpObj->X;

  014e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014e5	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  014ec	89 4d e8	 mov	 DWORD PTR _x$[ebp], ecx

; 4862 : 				y		= lpObj->Y;

  014ef	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014f2	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  014f9	89 4d e4	 mov	 DWORD PTR _y$[ebp], ecx

; 4863 : 				level	= 1;

  014fc	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _level$[ebp], 1

; 4864 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE)x, (BYTE)y, type, level, (BYTE)dur, 0, 0, 0);

  01503	6a 00		 push	 0
  01505	6a 00		 push	 0
  01507	6a 00		 push	 0
  01509	6a ff		 push	 -1
  0150b	6a 00		 push	 0
  0150d	6a 00		 push	 0
  0150f	6a 00		 push	 0
  01511	f3 0f 2c 45 e0	 cvttss2si eax, DWORD PTR _dur$[ebp]
  01516	0f b6 c8	 movzx	 ecx, al
  01519	51		 push	 ecx
  0151a	0f b6 55 ec	 movzx	 edx, BYTE PTR _level$[ebp]
  0151e	52		 push	 edx
  0151f	8b 45 f0	 mov	 eax, DWORD PTR _type$[ebp]
  01522	50		 push	 eax
  01523	0f b6 4d e4	 movzx	 ecx, BYTE PTR _y$[ebp]
  01527	51		 push	 ecx
  01528	0f b6 55 e8	 movzx	 edx, BYTE PTR _x$[ebp]
  0152c	52		 push	 edx
  0152d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01530	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  01537	51		 push	 ecx
  01538	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0153b	8b 02		 mov	 eax, DWORD PTR [edx]
  0153d	50		 push	 eax
  0153e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  01543	83 c4 38	 add	 esp, 56			; 00000038H
$LN106@gObjMonste:
$LN1@gObjMonste:

; 4865 : #ifdef REMOVE_LOVELOVE_EVENT_COUPLING_WITH_JOINSERVER_20060319
; 4866 : 				/*
; 4867 : 				 *	러브러브 이벤트와 인증서버와의 커플링 제거
; 4868 : 				 *		< commonserver.cfg >
; 4869 : 				 *		EVENT1						= 0	; 0 : 러브러브 이벤트 안함 1:  러브러브 이벤트 함
; 4870 : 				 *		Event1ItemDropTodayMax		= 0	; 오늘 이벤트로 떨어질 아이템 수
; 4871 : 				 * 		Event1ItemDropTodayPercent	= 0
; 4872 : 				 *
; 4873 : 				 */
; 4874 : #else
; 4875 : 				LoveHeartCreateSend();
; 4876 : #endif
; 4877 : 			}
; 4878 : 		}
; 4879 : 	}
; 4880 : }

  01546	5f		 pop	 edi
  01547	5e		 pop	 esi
  01548	5b		 pop	 ebx
  01549	8b e5		 mov	 esp, ebp
  0154b	5d		 pop	 ebp
  0154c	c3		 ret	 0
?gObjMonsterDieGiveItem@@YAXPAVOBJECTSTRUCT@@0@Z ENDP	; gObjMonsterDieGiveItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?NewOptionRand@@YAEH@Z
_TEXT	SEGMENT
_NOption$ = -1						; size = 1
_level$ = 8						; size = 4
?NewOptionRand@@YAEH@Z PROC				; NewOptionRand, COMDAT

; 3126 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3127 : 	BYTE NOption=0;

  00009	c6 45 ff 00	 mov	 BYTE PTR _NOption$[ebp], 0

; 3128 : 	
; 3129 : 	NOption = 1<<(rand()%6);

  0000d	e8 00 00 00 00	 call	 _rand
  00012	99		 cdq
  00013	b9 06 00 00 00	 mov	 ecx, 6
  00018	f7 f9		 idiv	 ecx
  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	8b ca		 mov	 ecx, edx
  00021	d3 e0		 shl	 eax, cl
  00023	88 45 ff	 mov	 BYTE PTR _NOption$[ebp], al

; 3130 : 
; 3131 : 	if( NOption & 0x02 )

  00026	0f b6 45 ff	 movzx	 eax, BYTE PTR _NOption$[ebp]
  0002a	83 e0 02	 and	 eax, 2
  0002d	74 2e		 je	 SHORT $LN2@NewOptionR

; 3132 : 	{	// 방어 성공률 확률을 낮춘다
; 3133 : 		if( rand()%2 ) 

  0002f	e8 00 00 00 00	 call	 _rand
  00034	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00039	79 05		 jns	 SHORT $LN6@NewOptionR
  0003b	48		 dec	 eax
  0003c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0003f	40		 inc	 eax
$LN6@NewOptionR:
  00040	85 c0		 test	 eax, eax
  00042	74 19		 je	 SHORT $LN2@NewOptionR

; 3134 : 		{
; 3135 : 			NOption = 1<<(rand()%6);

  00044	e8 00 00 00 00	 call	 _rand
  00049	99		 cdq
  0004a	b9 06 00 00 00	 mov	 ecx, 6
  0004f	f7 f9		 idiv	 ecx
  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	8b ca		 mov	 ecx, edx
  00058	d3 e0		 shl	 eax, cl
  0005a	88 45 ff	 mov	 BYTE PTR _NOption$[ebp], al
$LN2@NewOptionR:

; 3136 : 		}
; 3137 : 	}
; 3138 : 
; 3139 : 	if( rand()%4 == 0 ) NOption |= 1<<(rand()%6);

  0005d	e8 00 00 00 00	 call	 _rand
  00062	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00067	79 05		 jns	 SHORT $LN7@NewOptionR
  00069	48		 dec	 eax
  0006a	83 c8 fc	 or	 eax, -4			; fffffffcH
  0006d	40		 inc	 eax
$LN7@NewOptionR:
  0006e	85 c0		 test	 eax, eax
  00070	75 1f		 jne	 SHORT $LN4@NewOptionR
  00072	e8 00 00 00 00	 call	 _rand
  00077	99		 cdq
  00078	b9 06 00 00 00	 mov	 ecx, 6
  0007d	f7 f9		 idiv	 ecx
  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	8b ca		 mov	 ecx, edx
  00086	d3 e0		 shl	 eax, cl
  00088	0f b6 4d ff	 movzx	 ecx, BYTE PTR _NOption$[ebp]
  0008c	0b c8		 or	 ecx, eax
  0008e	88 4d ff	 mov	 BYTE PTR _NOption$[ebp], cl
$LN4@NewOptionR:

; 3140 : 
; 3141 : 	return NOption;

  00091	8a 45 ff	 mov	 al, BYTE PTR _NOption$[ebp]

; 3142 : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?NewOptionRand@@YAEH@Z ENDP				; NewOptionRand
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjSkylandBossSheildAttack@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_shieldindex$ = -8					; size = 4
_tObjNum$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjSkylandBossSheildAttack@@YAXPAVOBJECTSTRUCT@@@Z PROC ; gObjSkylandBossSheildAttack, COMDAT

; 3154 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3155 : 	if( lpObj->VPCount2 < 1 ) return;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	83 b8 70 0a 00
	00 01		 cmp	 DWORD PTR [eax+2672], 1
  00013	7d 05		 jge	 SHORT $LN5@gObjSkylan
  00015	e9 7c 01 00 00	 jmp	 $LN1@gObjSkylan
$LN5@gObjSkylan:

; 3156 : 
; 3157 : 	int tObjNum;
; 3158 : 
; 3159 : 	if( lpObj->m_SkyBossMonSheildLinkIndex == -1 )

  0001a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001d	83 b8 c4 0e 00
	00 ff		 cmp	 DWORD PTR [eax+3780], -1
  00024	75 05		 jne	 SHORT $LN6@gObjSkylan

; 3160 : 	{
; 3161 : 		return;

  00026	e9 6b 01 00 00	 jmp	 $LN1@gObjSkylan
$LN6@gObjSkylan:

; 3162 : 	}
; 3163 : 
; 3164 : 	if( !lpObj->m_SkyBossMonSheild )

  0002b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002e	83 b8 c8 0e 00
	00 00		 cmp	 DWORD PTR [eax+3784], 0
  00035	75 05		 jne	 SHORT $LN7@gObjSkylan

; 3165 : 		return;

  00037	e9 5a 01 00 00	 jmp	 $LN1@gObjSkylan
$LN7@gObjSkylan:

; 3166 : 
; 3167 : 	lpObj->TargetNumber = -1;

  0003c	83 c8 ff	 or	 eax, -1
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00042	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 3168 : 
; 3169 : 	int shieldindex = lpObj->m_SkyBossMonSheildLinkIndex;

  00049	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004c	8b 88 c4 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3780]
  00052	89 4d f8	 mov	 DWORD PTR _shieldindex$[ebp], ecx

; 3170 : 	if( gObj[shieldindex].Life < 0 )

  00055	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _shieldindex$[ebp], 7072
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00062	0f 57 c0	 xorps	 xmm0, xmm0
  00065	0f 2f 84 01 bc
	00 00 00	 comiss	 xmm0, DWORD PTR [ecx+eax+188]
  0006d	76 05		 jbe	 SHORT $LN8@gObjSkylan

; 3171 : 	{
; 3172 : 		return;

  0006f	e9 22 01 00 00	 jmp	 $LN1@gObjSkylan
$LN8@gObjSkylan:

; 3173 : 	}
; 3174 : 
; 3175 : 	if( lpObj->m_AttackRange > 0 )

  00074	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00077	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  0007e	85 c9		 test	 ecx, ecx
  00080	0f 8e c6 00 00
	00		 jle	 $LN3@gObjSkylan

; 3176 : 	{
; 3177 : 		for( int i=0; i<MAX_MONVIEWPORTOBJECT; i++)

  00086	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0008d	eb 09		 jmp	 SHORT $LN4@gObjSkylan
$LN2@gObjSkylan:
  0008f	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00092	83 c0 01	 add	 eax, 1
  00095	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@gObjSkylan:
  00098	83 7d f4 14	 cmp	 DWORD PTR _i$1[ebp], 20	; 00000014H
  0009c	0f 8d aa 00 00
	00		 jge	 $LN3@gObjSkylan

; 3178 : 		{
; 3179 : 			tObjNum = lpObj->VpPlayer2[i].number;

  000a2	6b 45 f4 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a9	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  000b1	89 55 fc	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 3180 : 			if( tObjNum >= 0  )

  000b4	83 7d fc 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  000b8	0f 8c 89 00 00
	00		 jl	 $LN13@gObjSkylan

; 3181 : 			{
; 3182 : 				if( gObj[tObjNum].Type == OBJTYPE_CHARACTER && gObj[tObjNum].Live )

  000be	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cb	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000d0	83 fa 01	 cmp	 edx, 1
  000d3	75 72		 jne	 SHORT $LN13@gObjSkylan
  000d5	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e2	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  000e7	85 d2		 test	 edx, edx
  000e9	74 5c		 je	 SHORT $LN13@gObjSkylan

; 3183 : 				{
; 3184 : 					if( gObjCheckTileArea(gObj[tObjNum].m_Index, lpObj->X, lpObj->Y, 2) )

  000eb	6a 02		 push	 2
  000ed	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f0	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000f7	51		 push	 ecx
  000f8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000fb	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00102	50		 push	 eax
  00103	69 4d fc a0 1b
	00 00		 imul	 ecx, DWORD PTR _tObjNum$[ebp], 7072
  0010a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00110	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ?gObjCheckTileArea@@YAHHHHH@Z ; gObjCheckTileArea
  00119	83 c4 10	 add	 esp, 16			; 00000010H
  0011c	85 c0		 test	 eax, eax
  0011e	74 27		 je	 SHORT $LN13@gObjSkylan

; 3185 : 					{
; 3186 : 						if( (gObj[tObjNum].Authority&AUTHORITY_ADMIN) != AUTHORITY_ADMIN ) 

  00120	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012d	8b 94 01 a4 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+420]
  00134	83 e2 02	 and	 edx, 2
  00137	75 0e		 jne	 SHORT $LN13@gObjSkylan

; 3187 : 						{
; 3188 : 							lpObj->TargetNumber = tObjNum;

  00139	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013c	66 8b 4d fc	 mov	 cx, WORD PTR _tObjNum$[ebp]
  00140	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx
$LN13@gObjSkylan:

; 3189 : 						}
; 3190 : 					}
; 3191 : 				}
; 3192 : 			}
; 3193 : 		}

  00147	e9 43 ff ff ff	 jmp	 $LN2@gObjSkylan
$LN3@gObjSkylan:

; 3194 : 	}
; 3195 : 
; 3196 : 	if( lpObj->TargetNumber >= 0 ) {

  0014c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014f	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00156	85 c9		 test	 ecx, ecx
  00158	7c 29		 jl	 SHORT $LN14@gObjSkylan

; 3197 : 		lpObj->m_ActState.Attack = 1;

  0015a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015d	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00163	83 c9 02	 or	 ecx, 2
  00166	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00169	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 3198 : 		lpObj->NextActionTime = lpObj->m_AttackSpeed;	// 공격후는 시간을 좀더 지연시킴

  0016f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00172	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00175	8b 91 e0 02 00
	00		 mov	 edx, DWORD PTR [ecx+736]
  0017b	89 90 18 02 00
	00		 mov	 DWORD PTR [eax+536], edx

; 3199 : 	}

  00181	eb 13		 jmp	 SHORT $LN15@gObjSkylan
$LN14@gObjSkylan:

; 3200 : 	else lpObj->NextActionTime = lpObj->m_MoveSpeed;	// 공격을 안할때는 빨리 체킹하기 위해.. movespeed 를 사용..	

  00183	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00186	0f bf 88 f4 02
	00 00		 movsx	 ecx, WORD PTR [eax+756]
  0018d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00190	89 8a 18 02 00
	00		 mov	 DWORD PTR [edx+536], ecx
$LN15@gObjSkylan:
$LN1@gObjSkylan:

; 3201 : }

  00196	5f		 pop	 edi
  00197	5e		 pop	 esi
  00198	5b		 pop	 ebx
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
?gObjSkylandBossSheildAttack@@YAXPAVOBJECTSTRUCT@@@Z ENDP ; gObjSkylandBossSheildAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterLastHitDamageUser@@YAHPAVOBJECTSTRUCT@@AAH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_LastHitUser$ = -8					; size = 4
_LastHitTime$ = -4					; size = 4
_lpMonObj$ = 8						; size = 4
_hitindex$ = 12						; size = 4
?gObjMonsterLastHitDamageUser@@YAHPAVOBJECTSTRUCT@@AAH@Z PROC ; gObjMonsterLastHitDamageUser, COMDAT

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 502  : //	int tObjNum;
; 503  : 	DWORD LastHitTime=0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _LastHitTime$[ebp], 0

; 504  : 	int LastHitUser=-1;

  00010	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _LastHitUser$[ebp], -1

; 505  : 	
; 506  : 	for( int n=0; n<MAX_HITDAMAGE; n++)

  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0001e	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  00020	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjMonste:
  00029	83 7d f4 28	 cmp	 DWORD PTR _n$1[ebp], 40	; 00000028H
  0002d	7d 53		 jge	 SHORT $LN3@gObjMonste

; 507  : 	{
; 508  : 		if( lpMonObj->sHD[n].number >= 0 )

  0002f	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  00036	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  0003e	85 d2		 test	 edx, edx
  00040	7c 3e		 jl	 SHORT $LN5@gObjMonste

; 509  : 		{
; 510  : 			if( lpMonObj->sHD[n].LastHitTime > LastHitTime ) 

  00042	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  00049	8b 94 01 7c 0a
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2684]
  00050	3b 55 fc	 cmp	 edx, DWORD PTR _LastHitTime$[ebp]
  00053	76 2b		 jbe	 SHORT $LN5@gObjMonste

; 511  : 			{
; 512  : 				LastHitTime = lpMonObj->sHD[n].LastHitTime;

  00055	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  0005c	8b 94 01 7c 0a
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2684]
  00063	89 55 fc	 mov	 DWORD PTR _LastHitTime$[ebp], edx

; 513  : 				LastHitUser = lpMonObj->sHD[n].number;

  00066	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  0006d	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  00075	89 55 f8	 mov	 DWORD PTR _LastHitUser$[ebp], edx

; 514  : 				hitindex = n;

  00078	8b 45 0c	 mov	 eax, DWORD PTR _hitindex$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _n$1[ebp]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@gObjMonste:

; 515  : 			}
; 516  : 		}
; 517  : 	}

  00080	eb 9e		 jmp	 SHORT $LN2@gObjMonste
$LN3@gObjMonste:

; 518  : 	return LastHitUser;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _LastHitUser$[ebp]

; 519  : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?gObjMonsterLastHitDamageUser@@YAHPAVOBJECTSTRUCT@@AAH@Z ENDP ; gObjMonsterLastHitDamageUser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?PathFindMoveMsgSend@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -184						; size = 4
_pos$2 = -177						; size = 1
_sy$3 = -176						; size = 4
_sx$4 = -172						; size = 4
_ty$5 = -168						; size = 4
_tx$6 = -164						; size = 4
_bPathFound$ = -160					; size = 4
_bPath$ = -156						; size = 8
_pMove$ = -148						; size = 13
_path$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?PathFindMoveMsgSend@@YAHPAVOBJECTSTRUCT@@@Z PROC	; PathFindMoveMsgSend, COMDAT

; 2458 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2459 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2460 : 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STONE ) == true
; 2461 : 		|| gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STUN ) == true 
; 2462 : 	  )
; 2463 : 	{
; 2464 : 		return FALSE;
; 2465 : 	}
; 2466 : #else
; 2467 : 	#ifdef NEW_FORSKYLAND2
; 2468 : 	if( lpObj->m_SkillHarden )

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	83 b8 fc 19 00
	00 00		 cmp	 DWORD PTR [eax+6652], 0
  00020	74 07		 je	 SHORT $LN5@PathFindMo

; 2469 : 		return FALSE;

  00022	33 c0		 xor	 eax, eax
  00024	e9 6d 04 00 00	 jmp	 $LN1@PathFindMo
$LN5@PathFindMo:

; 2470 : 	#endif
; 2471 : 
; 2472 : 	#ifdef ADD_NEW_SKILL_FOR_CASTLE_02_20050531
; 2473 : 	if( lpObj->m_iSkillStunTime > 0 )
; 2474 : 		return FALSE;
; 2475 : 	#endif
; 2476 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2477 : 
; 2478 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 슬립상태에서는 순간이동을 할 수 없다
; 2479 : 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SLEEP ) == true )
; 2480 : 	{
; 2481 : 		return FALSE;
; 2482 : 	}
; 2483 : #endif
; 2484 : 
; 2485 : 	PATH_t			path;
; 2486 : 	
; 2487 : 	
; 2488 : 	PMSG_MOVE		pMove;
; 2489 : 	pMove.h.c		 = PMHC_BYTE;

  00029	c6 85 6c ff ff
	ff c1		 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H

; 2490 : #ifdef PACKET_CHANGE	
; 2491 : 	pMove.h.headcode = PACKET_MOVE;

  00030	c6 85 6e ff ff
	ff d7		 mov	 BYTE PTR _pMove$[ebp+2], 215 ; 000000d7H

; 2492 : #else
; 2493 : 	pMove.h.headcode = 0x10;
; 2494 : #endif
; 2495 : 	pMove.h.size     = sizeof( pMove );

  00037	c6 85 6d ff ff
	ff 0d		 mov	 BYTE PTR _pMove$[ebp+1], 13 ; 0000000dH

; 2496 : 	pMove.X          = (BYTE)lpObj->X;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00041	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00047	88 8d 6f ff ff
	ff		 mov	 BYTE PTR _pMove$[ebp+3], cl

; 2497 : 	pMove.Y			 = (BYTE)lpObj->Y;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00050	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00056	88 8d 70 ff ff
	ff		 mov	 BYTE PTR _pMove$[ebp+4], cl

; 2498 : 		
; 2499 : 	BYTE bPath[MAX_PATHDIR];
; 2500 : 		
; 2501 : #ifdef MONSTER_HERD_SYSTEM_20031120
; 2502 : 	BOOL bPathFound = FALSE;

  0005c	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _bPathFound$[ebp], 0

; 2503 : 	if (lpObj->Type == OBJTYPE_MONSTER &&

  00066	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00069	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0006d	83 f9 02	 cmp	 ecx, 2
  00070	75 65		 jne	 SHORT $LN6@PathFindMo
  00072	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00075	83 b8 ec 0e 00
	00 00		 cmp	 DWORD PTR [eax+3820], 0
  0007c	74 59		 je	 SHORT $LN6@PathFindMo

; 2504 : 		lpObj->m_bIsInMonsterHerd
; 2505 : 		)
; 2506 : 		bPathFound = MapC[lpObj->MapNumber].PathFinding3(lpObj->X, lpObj->Y, lpObj->MTX, lpObj->MTY, &path);

  0007e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00084	50		 push	 eax
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00088	0f bf 91 26 01
	00 00		 movsx	 edx, WORD PTR [ecx+294]
  0008f	52		 push	 edx
  00090	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00093	0f bf 88 24 01
	00 00		 movsx	 ecx, WORD PTR [eax+292]
  0009a	51		 push	 ecx
  0009b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009e	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  000a5	50		 push	 eax
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a9	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  000b0	52		 push	 edx
  000b1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b4	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000bb	69 c9 8c 04 05
	00		 imul	 ecx, ecx, 328844
  000c1	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000c7	e8 00 00 00 00	 call	 ?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ; MapClass::PathFinding3
  000cc	0f b6 d0	 movzx	 edx, al
  000cf	89 95 60 ff ff
	ff		 mov	 DWORD PTR _bPathFound$[ebp], edx
  000d5	eb 57		 jmp	 SHORT $LN7@PathFindMo
$LN6@PathFindMo:

; 2507 : 	else
; 2508 : 		bPathFound = MapC[lpObj->MapNumber].PathFinding2(lpObj->X, lpObj->Y, lpObj->MTX, lpObj->MTY, &path);

  000d7	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e1	0f bf 91 26 01
	00 00		 movsx	 edx, WORD PTR [ecx+294]
  000e8	52		 push	 edx
  000e9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ec	0f bf 88 24 01
	00 00		 movsx	 ecx, WORD PTR [eax+292]
  000f3	51		 push	 ecx
  000f4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f7	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  000fe	50		 push	 eax
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00102	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  00109	52		 push	 edx
  0010a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00114	69 c9 8c 04 05
	00		 imul	 ecx, ecx, 328844
  0011a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00120	e8 00 00 00 00	 call	 ?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ; MapClass::PathFinding2
  00125	0f b6 d0	 movzx	 edx, al
  00128	89 95 60 ff ff
	ff		 mov	 DWORD PTR _bPathFound$[ebp], edx
$LN7@PathFindMo:

; 2509 : 
; 2510 : 	if (bPathFound)

  0012e	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR _bPathFound$[ebp], 0
  00135	0f 84 59 03 00
	00		 je	 $LN8@PathFindMo

; 2511 : #else
; 2512 : 	if( MapC[lpObj->MapNumber].PathFinding2(lpObj->X, lpObj->Y, lpObj->MTX, lpObj->MTY, &path) == TRUE)
; 2513 : #endif	
; 2514 : 	{
; 2515 : 		int tx, ty, sx, sy;
; 2516 : 		BYTE pos=0;

  0013b	c6 85 4f ff ff
	ff 00		 mov	 BYTE PTR _pos$2[ebp], 0

; 2517 : 		
; 2518 : 		memset(bPath, 0, MAX_PATHDIR);

  00142	6a 08		 push	 8
  00144	6a 00		 push	 0
  00146	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _bPath$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _memset
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2519 : 		
; 2520 : 		bPath[0] = (lpObj->Dir<<4)+((path.PathNum-1)&0x0F);

  00155	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00158	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  0015f	c1 e1 04	 shl	 ecx, 4
  00162	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _path$[ebp]
  00168	83 ea 01	 sub	 edx, 1
  0016b	83 e2 0f	 and	 edx, 15			; 0000000fH
  0016e	03 ca		 add	 ecx, edx
  00170	b8 01 00 00 00	 mov	 eax, 1
  00175	6b d0 00	 imul	 edx, eax, 0
  00178	88 8c 15 64 ff
	ff ff		 mov	 BYTE PTR _bPath$[ebp+edx], cl

; 2521 : 		
; 2522 : 		sx = lpObj->X;

  0017f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00182	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00189	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _sx$4[ebp], ecx

; 2523 : 		sy = lpObj->Y;

  0018f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00192	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00199	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _sy$3[ebp], ecx

; 2524 : 		lpObj->PathX[0] = lpObj->X;

  0019f	b8 02 00 00 00	 mov	 eax, 2
  001a4	6b c8 00	 imul	 ecx, eax, 0
  001a7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001aa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ad	66 8b 80 04 01
	00 00		 mov	 ax, WORD PTR [eax+260]
  001b4	66 89 84 0a 50
	01 00 00	 mov	 WORD PTR [edx+ecx+336], ax

; 2525 : 		lpObj->PathY[0] = lpObj->Y;

  001bc	b8 02 00 00 00	 mov	 eax, 2
  001c1	6b c8 00	 imul	 ecx, eax, 0
  001c4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001c7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ca	66 8b 80 06 01
	00 00		 mov	 ax, WORD PTR [eax+262]
  001d1	66 89 84 0a 6e
	01 00 00	 mov	 WORD PTR [edx+ecx+366], ax

; 2526 : 		lpObj->PathDir[0] = lpObj->Dir;

  001d9	b8 01 00 00 00	 mov	 eax, 1
  001de	6b c8 00	 imul	 ecx, eax, 0
  001e1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e7	8a 80 08 01 00
	00		 mov	 al, BYTE PTR [eax+264]
  001ed	88 84 0a 8c 01
	00 00		 mov	 BYTE PTR [edx+ecx+396], al

; 2527 : 		for( int n=1; n<path.PathNum; n++)

  001f4	c7 85 48 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _n$1[ebp], 1
  001fe	eb 0f		 jmp	 SHORT $LN4@PathFindMo
$LN2@PathFindMo:
  00200	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00206	83 c0 01	 add	 eax, 1
  00209	89 85 48 ff ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN4@PathFindMo:
  0020f	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00215	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _path$[ebp]
  0021b	0f 8d 16 01 00
	00		 jge	 $LN3@PathFindMo

; 2528 : 		{
; 2529 : 			tx = path.PathX[n];

  00221	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00227	8b 4c 85 80	 mov	 ecx, DWORD PTR _path$[ebp+eax*4+4]
  0022b	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _tx$6[ebp], ecx

; 2530 : 			ty = path.PathY[n];

  00231	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00237	8b 4c 85 bc	 mov	 ecx, DWORD PTR _path$[ebp+eax*4+64]
  0023b	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _ty$5[ebp], ecx

; 2531 : 
; 2532 : 			pos = GetPathPacketDirPos( tx-sx, ty-sy);

  00241	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _ty$5[ebp]
  00247	2b 85 50 ff ff
	ff		 sub	 eax, DWORD PTR _sy$3[ebp]
  0024d	50		 push	 eax
  0024e	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _tx$6[ebp]
  00254	2b 8d 54 ff ff
	ff		 sub	 ecx, DWORD PTR _sx$4[ebp]
  0025a	51		 push	 ecx
  0025b	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  00260	83 c4 08	 add	 esp, 8
  00263	88 85 4f ff ff
	ff		 mov	 BYTE PTR _pos$2[ebp], al

; 2533 : 
; 2534 : 			lpObj->PathX[n] = tx;

  00269	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  0026f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00272	66 8b 95 5c ff
	ff ff		 mov	 dx, WORD PTR _tx$6[ebp]
  00279	66 89 94 41 50
	01 00 00	 mov	 WORD PTR [ecx+eax*2+336], dx

; 2535 : 			lpObj->PathY[n] = ty;

  00281	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00287	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0028a	66 8b 95 58 ff
	ff ff		 mov	 dx, WORD PTR _ty$5[ebp]
  00291	66 89 94 41 6e
	01 00 00	 mov	 WORD PTR [ecx+eax*2+366], dx

; 2536 : 			lpObj->PathDir[n] = pos;

  00299	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029c	03 85 48 ff ff
	ff		 add	 eax, DWORD PTR _n$1[ebp]
  002a2	8a 8d 4f ff ff
	ff		 mov	 cl, BYTE PTR _pos$2[ebp]
  002a8	88 88 8c 01 00
	00		 mov	 BYTE PTR [eax+396], cl

; 2537 : 			
; 2538 : 			sx = tx;

  002ae	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _tx$6[ebp]
  002b4	89 85 54 ff ff
	ff		 mov	 DWORD PTR _sx$4[ebp], eax

; 2539 : 			sy = ty;

  002ba	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _ty$5[ebp]
  002c0	89 85 50 ff ff
	ff		 mov	 DWORD PTR _sy$3[ebp], eax

; 2540 : 			if( (n%2) == 1 ) {

  002c6	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  002cc	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002d1	79 05		 jns	 SHORT $LN13@PathFindMo
  002d3	48		 dec	 eax
  002d4	83 c8 fe	 or	 eax, -2			; fffffffeH
  002d7	40		 inc	 eax
$LN13@PathFindMo:
  002d8	83 f8 01	 cmp	 eax, 1
  002db	75 21		 jne	 SHORT $LN9@PathFindMo

; 2541 : 				bPath[(n+1)/2] = pos<<4;

  002dd	0f b6 8d 4f ff
	ff ff		 movzx	 ecx, BYTE PTR _pos$2[ebp]
  002e4	c1 e1 04	 shl	 ecx, 4
  002e7	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  002ed	83 c0 01	 add	 eax, 1
  002f0	99		 cdq
  002f1	2b c2		 sub	 eax, edx
  002f3	d1 f8		 sar	 eax, 1
  002f5	88 8c 05 64 ff
	ff ff		 mov	 BYTE PTR _bPath$[ebp+eax], cl

; 2542 : 			}

  002fc	eb 34		 jmp	 SHORT $LN10@PathFindMo
$LN9@PathFindMo:

; 2543 : 			else bPath[(n+1)/2] |= pos;

  002fe	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00304	83 c0 01	 add	 eax, 1
  00307	99		 cdq
  00308	2b c2		 sub	 eax, edx
  0030a	d1 f8		 sar	 eax, 1
  0030c	0f b6 8d 4f ff
	ff ff		 movzx	 ecx, BYTE PTR _pos$2[ebp]
  00313	0f b6 9c 05 64
	ff ff ff	 movzx	 ebx, BYTE PTR _bPath$[ebp+eax]
  0031b	0b d9		 or	 ebx, ecx
  0031d	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00323	83 c0 01	 add	 eax, 1
  00326	99		 cdq
  00327	2b c2		 sub	 eax, edx
  00329	d1 f8		 sar	 eax, 1
  0032b	88 9c 05 64 ff
	ff ff		 mov	 BYTE PTR _bPath$[ebp+eax], bl
$LN10@PathFindMo:

; 2544 : 		}

  00332	e9 c9 fe ff ff	 jmp	 $LN2@PathFindMo
$LN3@PathFindMo:

; 2545 : 		//--------
; 2546 : 		lpObj->Dir       = bPath[0]>>4;

  00337	b8 01 00 00 00	 mov	 eax, 1
  0033c	6b c8 00	 imul	 ecx, eax, 0
  0033f	0f b6 94 0d 64
	ff ff ff	 movzx	 edx, BYTE PTR _bPath$[ebp+ecx]
  00347	c1 fa 04	 sar	 edx, 4
  0034a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034d	88 90 08 01 00
	00		 mov	 BYTE PTR [eax+264], dl

; 2547 : 		lpObj->PathCount = (bPath[0]&0x0f);

  00353	b8 01 00 00 00	 mov	 eax, 1
  00358	6b c8 00	 imul	 ecx, eax, 0
  0035b	0f b6 94 0d 64
	ff ff ff	 movzx	 edx, BYTE PTR _bPath$[ebp+ecx]
  00363	83 e2 0f	 and	 edx, 15			; 0000000fH
  00366	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00369	89 90 28 01 00
	00		 mov	 DWORD PTR [eax+296], edx

; 2548 : 		lpObj->PathCur   = 1;

  0036f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00372	c7 80 2c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+300], 1

; 2549 : 		
; 2550 : 		// ADD_NEW_MONSTER_SYSTEM_02_20050725 -- 양쪽에서 부딪혀서 여기껄 막아놓았다.
; 2551 : 		// 일단 풀어놓음.
; 2552 : 		lpObj->PathTime  = GetTickCount();

  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00382	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00385	89 81 9c 01 00
	00		 mov	 DWORD PTR [ecx+412], eax

; 2553 : 
; 2554 : 		//lpObj->X         = lpObj->MTX;
; 2555 : 		//lpObj->Y         = lpObj->MTY;
; 2556 : 		
; 2557 : 		//AttackDir = lpObj->Dir;//GetPathPacketDirPos( rtx-sx, rty-sy);
; 2558 : 		bPath[0] &= 0x0F;

  0038b	b8 01 00 00 00	 mov	 eax, 1
  00390	6b c8 00	 imul	 ecx, eax, 0
  00393	0f b6 94 0d 64
	ff ff ff	 movzx	 edx, BYTE PTR _bPath$[ebp+ecx]
  0039b	83 e2 0f	 and	 edx, 15			; 0000000fH
  0039e	b8 01 00 00 00	 mov	 eax, 1
  003a3	6b c8 00	 imul	 ecx, eax, 0
  003a6	88 94 0d 64 ff
	ff ff		 mov	 BYTE PTR _bPath$[ebp+ecx], dl

; 2559 : 		bPath[0] |= pos<<4;

  003ad	b8 01 00 00 00	 mov	 eax, 1
  003b2	6b c8 00	 imul	 ecx, eax, 0
  003b5	0f b6 95 4f ff
	ff ff		 movzx	 edx, BYTE PTR _pos$2[ebp]
  003bc	c1 e2 04	 shl	 edx, 4
  003bf	0f b6 84 0d 64
	ff ff ff	 movzx	 eax, BYTE PTR _bPath$[ebp+ecx]
  003c7	0b c2		 or	 eax, edx
  003c9	b9 01 00 00 00	 mov	 ecx, 1
  003ce	6b d1 00	 imul	 edx, ecx, 0
  003d1	88 84 15 64 ff
	ff ff		 mov	 BYTE PTR _bPath$[ebp+edx], al

; 2560 : 
; 2561 : 		memcpy(pMove.Path, bPath, MAX_PATHDIR);

  003d8	6a 08		 push	 8
  003da	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _bPath$[ebp]
  003e0	50		 push	 eax
  003e1	8d 8d 71 ff ff
	ff		 lea	 ecx, DWORD PTR _pMove$[ebp+5]
  003e7	51		 push	 ecx
  003e8	e8 00 00 00 00	 call	 _memcpy
  003ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2562 : 		
; 2563 : 		if( lpObj->PathCount > 0 )

  003f0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f3	83 b8 28 01 00
	00 00		 cmp	 DWORD PTR [eax+296], 0
  003fa	7e 7c		 jle	 SHORT $LN11@PathFindMo

; 2564 : 		{
; 2565 : 			MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  003fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ff	0f bf 88 1e 01
	00 00		 movsx	 ecx, WORD PTR [eax+286]
  00406	51		 push	 ecx
  00407	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0040a	0f bf 82 1c 01
	00 00		 movsx	 eax, WORD PTR [edx+284]
  00411	50		 push	 eax
  00412	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00415	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0041c	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00422	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00428	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 2566 : 			MapC[lpObj->MapNumber].SetStandAttr(sx, sy);

  0042d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _sy$3[ebp]
  00433	50		 push	 eax
  00434	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _sx$4[ebp]
  0043a	51		 push	 ecx
  0043b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0043e	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00445	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  0044b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00451	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 2567 : 			lpObj->m_OldX = sx;

  00456	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00459	66 8b 8d 54 ff
	ff ff		 mov	 cx, WORD PTR _sx$4[ebp]
  00460	66 89 88 1c 01
	00 00		 mov	 WORD PTR [eax+284], cx

; 2568 : 			lpObj->m_OldY = sy;

  00467	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0046a	66 8b 8d 50 ff
	ff ff		 mov	 cx, WORD PTR _sy$3[ebp]
  00471	66 89 88 1e 01
	00 00		 mov	 WORD PTR [eax+286], cx
$LN11@PathFindMo:

; 2569 : 		}
; 2570 : 		PMoveProc(&pMove, lpObj->m_Index);

  00478	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0047b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0047d	51		 push	 ecx
  0047e	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR _pMove$[ebp]
  00484	52		 push	 edx
  00485	e8 00 00 00 00	 call	 ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ; PMoveProc
  0048a	83 c4 08	 add	 esp, 8

; 2571 : 		//vChatSend(lpObj, "이동시작 %d / %d  -> %d / %d", lpObj->X, lpObj->Y, lpObj->MTX, lpObj->MTY);
; 2572 : 		return TRUE;

  0048d	b8 01 00 00 00	 mov	 eax, 1
  00492	eb 02		 jmp	 SHORT $LN1@PathFindMo
$LN8@PathFindMo:

; 2573 : 	}
; 2574 : 	return FALSE;

  00494	33 c0		 xor	 eax, eax
$LN1@PathFindMo:

; 2575 : }

  00496	5f		 pop	 edi
  00497	5e		 pop	 esi
  00498	5b		 pop	 ebx
  00499	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049c	33 cd		 xor	 ecx, ebp
  0049e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a3	8b e5		 mov	 esp, ebp
  004a5	5d		 pop	 ebp
  004a6	c3		 ret	 0
?PathFindMoveMsgSend@@YAHPAVOBJECTSTRUCT@@@Z ENDP	; PathFindMoveMsgSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterMoveAction@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv73 = -112						; size = 4
_attr$2 = -41						; size = 1
_mchk$3 = -40						; size = 4
_tpy$ = -34						; size = 1
_tpx$ = -33						; size = 1
_searchc$ = -32						; size = 4
_maxmoverange$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
?gObjMonsterMoveAction@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjMonsterMoveAction, COMDAT

; 2580 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?gObjMonsterMoveAction@@YAXPAVOBJECTSTRUCT@@@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 c4 a0	 add	 esp, -96		; ffffffa0H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 2581 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2582 : 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STONE ) == true
; 2583 : 		|| gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STUN ) == true 
; 2584 : 	  )
; 2585 : 	{
; 2586 : 		return;
; 2587 : 	}
; 2588 : #else
; 2589 : 	#ifdef NEW_FORSKYLAND2
; 2590 : 	if( lpObj->m_SkillHarden != 0 )

  00033	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00036	83 b8 fc 19 00
	00 00		 cmp	 DWORD PTR [eax+6652], 0
  0003d	74 05		 je	 SHORT $LN4@gObjMonste

; 2591 : 		return;

  0003f	e9 2a 02 00 00	 jmp	 $LN12@gObjMonste
$LN4@gObjMonste:

; 2592 : 	#endif
; 2593 : 
; 2594 : 	#ifdef ADD_NEW_SKILL_FOR_CASTLE_02_20050531
; 2595 : 	if( lpObj->m_iSkillStunTime > 0 )
; 2596 : 		return;
; 2597 : 	#endif
; 2598 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 2599 : 
; 2600 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 슬립상태에서는 이동을 할 수 없다
; 2601 : 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SLEEP ) == true )
; 2602 : 	{
; 2603 : 		return;
; 2604 : 	}
; 2605 : #endif
; 2606 : 
; 2607 : 	int maxmoverange = (lpObj->m_MoveRange*2)+1;

  00044	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00047	0f bf 88 f6 02
	00 00		 movsx	 ecx, WORD PTR [eax+758]
  0004e	8d 54 09 01	 lea	 edx, DWORD PTR [ecx+ecx+1]
  00052	89 55 e4	 mov	 DWORD PTR _maxmoverange$[ebp], edx

; 2608 : 	int searchc=10;

  00055	c7 45 e0 0a 00
	00 00		 mov	 DWORD PTR _searchc$[ebp], 10 ; 0000000aH

; 2609 : 	BYTE tpx, tpy;
; 2610 : 	lpObj->NextActionTime = 1000;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005f	c7 80 18 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+536], 1000 ; 000003e8H
$LN2@gObjMonste:

; 2611 : 				
; 2612 : 	while(searchc--)

  00069	8b 45 e0	 mov	 eax, DWORD PTR _searchc$[ebp]
  0006c	89 45 90	 mov	 DWORD PTR tv73[ebp], eax
  0006f	8b 4d e0	 mov	 ecx, DWORD PTR _searchc$[ebp]
  00072	83 e9 01	 sub	 ecx, 1
  00075	89 4d e0	 mov	 DWORD PTR _searchc$[ebp], ecx
  00078	83 7d 90 00	 cmp	 DWORD PTR tv73[ebp], 0
  0007c	0f 84 ec 01 00
	00		 je	 $LN12@gObjMonste

; 2613 : 	{
; 2614 : 		__try

  00082	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 2615 : 		{
; 2616 : 			tpx = (lpObj->X-lpObj->m_MoveRange)+(rand()%maxmoverange);

  00089	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	0f bf 98 04 01
	00 00		 movsx	 ebx, WORD PTR [eax+260]
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00096	0f bf 91 f6 02
	00 00		 movsx	 edx, WORD PTR [ecx+758]
  0009d	2b da		 sub	 ebx, edx
  0009f	e8 00 00 00 00	 call	 _rand
  000a4	8b 4d e4	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  000a7	99		 cdq
  000a8	f7 f9		 idiv	 ecx
  000aa	03 da		 add	 ebx, edx
  000ac	88 5d df	 mov	 BYTE PTR _tpx$[ebp], bl

; 2617 : 			tpy = (lpObj->Y-lpObj->m_MoveRange)+(rand()%maxmoverange);		

  000af	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b2	0f bf 98 06 01
	00 00		 movsx	 ebx, WORD PTR [eax+262]
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bc	0f bf 91 f6 02
	00 00		 movsx	 edx, WORD PTR [ecx+758]
  000c3	2b da		 sub	 ebx, edx
  000c5	e8 00 00 00 00	 call	 _rand
  000ca	8b 4d e4	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  000cd	99		 cdq
  000ce	f7 f9		 idiv	 ecx
  000d0	03 da		 add	 ebx, edx
  000d2	88 5d de	 mov	 BYTE PTR _tpy$[ebp], bl

; 2618 : 		}

  000d5	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000dc	eb 17		 jmp	 SHORT $LN16@gObjMonste
$LN13@gObjMonste:
$LN18@gObjMonste:

; 2619 : 		__except( maxmoverange = 1, EXCEPTION_EXECUTE_HANDLER )

  000de	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _maxmoverange$[ebp], 1
  000e5	b8 01 00 00 00	 mov	 eax, 1
$LN15@gObjMonste:
$LN17@gObjMonste:
  000ea	c3		 ret	 0
$LN14@gObjMonste:
  000eb	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 2618 : 		}

  000ee	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN16@gObjMonste:

; 2620 : 		{
; 2621 : 		}
; 2622 : 		
; 2623 : 		// 너무 멀리 가지 않았나?? 체크
; 2624 : 		BOOL mchk = gObjMonsterMoveCheck(lpObj, tpx, tpy);

  000f5	0f b6 45 de	 movzx	 eax, BYTE PTR _tpy$[ebp]
  000f9	50		 push	 eax
  000fa	0f b6 4d df	 movzx	 ecx, BYTE PTR _tpx$[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00102	52		 push	 edx
  00103	e8 00 00 00 00	 call	 ?gObjMonsterMoveCheck@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjMonsterMoveCheck
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	89 45 d8	 mov	 DWORD PTR _mchk$3[ebp], eax

; 2625 : 		/*if( mchk == FALSE )
; 2626 : 		{
; 2627 : 			tpx = lpObj->StartX;
; 2628 : 			tpy = lpObj->StartY;
; 2629 : 			mchk = TRUE;
; 2630 : 		}*/
; 2631 : 		BYTE attr = MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  0010e	0f b6 45 de	 movzx	 eax, BYTE PTR _tpy$[ebp]
  00112	50		 push	 eax
  00113	0f b6 4d df	 movzx	 ecx, BYTE PTR _tpx$[ebp]
  00117	51		 push	 ecx
  00118	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0011b	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00122	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00128	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0012e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00133	88 45 d7	 mov	 BYTE PTR _attr$2[ebp], al

; 2632 : 		// 경비병일땐 안전지대도 갈수 있다.
; 2633 : 		if( (lpObj->Class == 249 || lpObj->Class == 247) && mchk )

  00136	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00139	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00140	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  00146	74 12		 je	 SHORT $LN8@gObjMonste
  00148	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00152	81 f9 f7 00 00
	00		 cmp	 ecx, 247		; 000000f7H
  00158	75 59		 jne	 SHORT $LN6@gObjMonste
$LN8@gObjMonste:
  0015a	83 7d d8 00	 cmp	 DWORD PTR _mchk$3[ebp], 0
  0015e	74 53		 je	 SHORT $LN6@gObjMonste

; 2634 : 		{
; 2635 : 			if( ((attr&MAP_ATTR_STAND)!=MAP_ATTR_STAND) )

  00160	0f b6 45 d7	 movzx	 eax, BYTE PTR _attr$2[ebp]
  00164	83 e0 02	 and	 eax, 2
  00167	75 45		 jne	 SHORT $LN9@gObjMonste

; 2636 : 			{
; 2637 : 				lpObj->MTX = tpx;

  00169	66 0f b6 45 df	 movzx	 ax, BYTE PTR _tpx$[ebp]
  0016e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00171	66 89 81 24 01
	00 00		 mov	 WORD PTR [ecx+292], ax

; 2638 : 				lpObj->MTY = tpy;

  00178	66 0f b6 45 de	 movzx	 ax, BYTE PTR _tpy$[ebp]
  0017d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00180	66 89 81 26 01
	00 00		 mov	 WORD PTR [ecx+294], ax

; 2639 : 				lpObj->m_ActState.Move = 1;

  00187	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018a	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00190	83 c9 04	 or	 ecx, 4
  00193	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00196	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2640 : 				lpObj->NextActionTime = 3000;

  0019c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019f	c7 80 18 02 00
	00 b8 0b 00 00	 mov	 DWORD PTR [eax+536], 3000 ; 00000bb8H

; 2641 : 				break;

  001a9	e9 c0 00 00 00	 jmp	 $LN12@gObjMonste
$LN9@gObjMonste:

; 2642 : 			}
; 2643 : 		}

  001ae	e9 b6 00 00 00	 jmp	 $LN7@gObjMonste
$LN6@gObjMonste:

; 2644 : 		else 
; 2645 : 		{
; 2646 : 			if( ((attr&MAP_ATTR_SAFTYZONE)!=MAP_ATTR_SAFTYZONE) && 
; 2647 : 				((attr&MAP_ATTR_STAND)!=MAP_ATTR_STAND) && 
; 2648 : 				((attr&MAP_ATTR_BLOCK)!=MAP_ATTR_BLOCK) && 
; 2649 : 				((attr&MAP_ATTR_HOLLOW)!=MAP_ATTR_HOLLOW) && 

  001b3	0f b6 45 d7	 movzx	 eax, BYTE PTR _attr$2[ebp]
  001b7	83 e0 01	 and	 eax, 1
  001ba	0f 85 a9 00 00
	00		 jne	 $LN7@gObjMonste
  001c0	0f b6 45 d7	 movzx	 eax, BYTE PTR _attr$2[ebp]
  001c4	83 e0 02	 and	 eax, 2
  001c7	0f 85 9c 00 00
	00		 jne	 $LN7@gObjMonste
  001cd	0f b6 45 d7	 movzx	 eax, BYTE PTR _attr$2[ebp]
  001d1	83 e0 04	 and	 eax, 4
  001d4	0f 85 8f 00 00
	00		 jne	 $LN7@gObjMonste
  001da	0f b6 45 d7	 movzx	 eax, BYTE PTR _attr$2[ebp]
  001de	83 e0 08	 and	 eax, 8
  001e1	0f 85 82 00 00
	00		 jne	 $LN7@gObjMonste
  001e7	83 7d d8 00	 cmp	 DWORD PTR _mchk$3[ebp], 0
  001eb	74 7c		 je	 SHORT $LN7@gObjMonste

; 2650 : 				mchk )
; 2651 : 			{
; 2652 : 				lpObj->TargetNumber       = -1;

  001ed	83 c8 ff	 or	 eax, -1
  001f0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f3	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 2653 : 				lpObj->m_ActState.Attack  = 0;

  001fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fd	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00203	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00206	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00209	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2654 : 				lpObj->NextActionTime     = 500;

  0020f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00212	c7 80 18 02 00
	00 f4 01 00 00	 mov	 DWORD PTR [eax+536], 500 ; 000001f4H

; 2655 : 				lpObj->m_ActState.Emotion = 0;

  0021c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0021f	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00225	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  0022b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0022e	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2656 : 				lpObj->MTX = tpx;

  00234	66 0f b6 45 df	 movzx	 ax, BYTE PTR _tpx$[ebp]
  00239	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0023c	66 89 81 24 01
	00 00		 mov	 WORD PTR [ecx+292], ax

; 2657 : 				lpObj->MTY = tpy;

  00243	66 0f b6 45 de	 movzx	 ax, BYTE PTR _tpy$[ebp]
  00248	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0024b	66 89 81 26 01
	00 00		 mov	 WORD PTR [ecx+294], ax

; 2658 : 				lpObj->m_ActState.Move = 1;

  00252	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00255	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0025b	83 c9 04	 or	 ecx, 4
  0025e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00261	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 2659 : 				//lpObj->NextActionTime = 1000;
; 2660 : 				break;

  00267	eb 05		 jmp	 SHORT $LN12@gObjMonste
$LN7@gObjMonste:

; 2661 : 			}			
; 2662 : 		}
; 2663 : 	}

  00269	e9 fb fd ff ff	 jmp	 $LN2@gObjMonste
$LN12@gObjMonste:

; 2664 : }

  0026e	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00271	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00278	59		 pop	 ecx
  00279	5f		 pop	 edi
  0027a	5e		 pop	 esi
  0027b	5b		 pop	 ebx
  0027c	8b e5		 mov	 esp, ebp
  0027e	5d		 pop	 ebp
  0027f	c3		 ret	 0
?gObjMonsterMoveAction@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjMonsterMoveAction
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterGetTargetPos@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv75 = -120						; size = 4
tv170 = -116						; size = 4
tv76 = -116						; size = 4
_dis$ = -48						; size = 4
_vpn$ = -44						; size = 4
_lpTargetObj$ = -40					; size = 4
_result$ = -36						; size = 4
_attr$ = -29						; size = 1
_searchcount$ = -28					; size = 4
_sn$ = -24						; size = 4
_searchp$ = -20						; size = 4
_mty$ = -16						; size = 4
_mtx$ = -12						; size = 4
_tpy$ = -8						; size = 4
_tpx$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterGetTargetPos@@YAHPAVOBJECTSTRUCT@@@Z PROC	; gObjMonsterGetTargetPos, COMDAT

; 575  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 576  : 	int tpx, tpy, mtx, mty;
; 577  : 	int searchp=0, sn=0;

  00009	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _searchp$[ebp], 0
  00010	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _sn$[ebp], 0

; 578  : 	int searchcount=7;

  00017	c7 45 e4 07 00
	00 00		 mov	 DWORD PTR _searchcount$[ebp], 7

; 579  : 	BYTE attr;
; 580  : 	BOOL result;
; 581  : 
; 582  : #ifdef ADD_NEW_SKILL_FOR_CASTLE_02_20050531
; 583  : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 584  : 	if( lpObj->m_MoveRange == 0
; 585  : 		&& ( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STONE ) == true )
; 586  : 		&& ( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STUN ) == true )
; 587  : 	  )
; 588  : 	#else
; 589  : 	if( lpObj->m_MoveRange == 0 && lpObj->m_SkillHarden != 0 && lpObj->m_iSkillStunTime > 0 )
; 590  : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 591  : 		return FALSE;
; 592  : #else
; 593  : 	#ifdef NEW_FORSKYLAND2
; 594  : 	if( lpObj->m_MoveRange == 0 && lpObj->m_SkillHarden != 0 )

  0001e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00021	0f bf 88 f6 02
	00 00		 movsx	 ecx, WORD PTR [eax+758]
  00028	85 c9		 test	 ecx, ecx
  0002a	75 13		 jne	 SHORT $LN4@gObjMonste
  0002c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002f	83 b8 fc 19 00
	00 00		 cmp	 DWORD PTR [eax+6652], 0
  00036	74 07		 je	 SHORT $LN4@gObjMonste

; 595  : 		return FALSE;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 bc 03 00 00	 jmp	 $LN1@gObjMonste
$LN4@gObjMonste:

; 596  : 	#else
; 597  : 	if( lpObj->m_MoveRange == 0 ) return FALSE;
; 598  : 	#endif
; 599  : 
; 600  : #endif
; 601  : 
; 602  : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// 슬립상태 상대의 위치를 못얻음
; 603  : 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SLEEP ) == true )
; 604  : 	{
; 605  : 		return FALSE;
; 606  : 	}
; 607  : #endif
; 608  : 	
; 609  : 	LPOBJECTSTRUCT lpTargetObj;
; 610  : 
; 611  : 	if( !CHECK_LIMIT(lpObj->TargetNumber, MAX_OBJECT) ) return FALSE;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00042	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00049	85 c9		 test	 ecx, ecx
  0004b	7d 09		 jge	 SHORT $LN28@gObjMonste
  0004d	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  00054	eb 27		 jmp	 SHORT $LN29@gObjMonste
$LN28@gObjMonste:
  00056	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00059	0f bf 82 ac 02
	00 00		 movsx	 eax, WORD PTR [edx+684]
  00060	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00065	7e 09		 jle	 SHORT $LN26@gObjMonste
  00067	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  0006e	eb 07		 jmp	 SHORT $LN27@gObjMonste
$LN26@gObjMonste:
  00070	c7 45 88 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
$LN27@gObjMonste:
  00077	8b 4d 88	 mov	 ecx, DWORD PTR tv75[ebp]
  0007a	89 4d 8c	 mov	 DWORD PTR tv76[ebp], ecx
$LN29@gObjMonste:
  0007d	83 7d 8c 00	 cmp	 DWORD PTR tv76[ebp], 0
  00081	75 07		 jne	 SHORT $LN5@gObjMonste
  00083	33 c0		 xor	 eax, eax
  00085	e9 71 03 00 00	 jmp	 $LN1@gObjMonste
$LN5@gObjMonste:

; 612  : 
; 613  : 	lpTargetObj = (LPOBJECTSTRUCT)&gObj[lpObj->TargetNumber];

  0008a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008d	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00094	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  0009a	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a0	89 55 d8	 mov	 DWORD PTR _lpTargetObj$[ebp], edx

; 614  : 
; 615  : 	if( lpTargetObj->Teleport )

  000a3	8b 45 d8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000a6	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  000ad	85 c9		 test	 ecx, ecx
  000af	74 07		 je	 SHORT $LN6@gObjMonste

; 616  : 	{
; 617  : 		return FALSE;

  000b1	33 c0		 xor	 eax, eax
  000b3	e9 43 03 00 00	 jmp	 $LN1@gObjMonste
$LN6@gObjMonste:

; 618  : 	}
; 619  : 
; 620  : 	int vpn = gObjMonsterViewportIsCharacter(lpObj);

  000b8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?gObjMonsterViewportIsCharacter@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterViewportIsCharacter
  000c1	83 c4 04	 add	 esp, 4
  000c4	89 45 d4	 mov	 DWORD PTR _vpn$[ebp], eax

; 621  : 	if( vpn < 0 ) return FALSE;

  000c7	83 7d d4 00	 cmp	 DWORD PTR _vpn$[ebp], 0
  000cb	7d 07		 jge	 SHORT $LN7@gObjMonste
  000cd	33 c0		 xor	 eax, eax
  000cf	e9 27 03 00 00	 jmp	 $LN1@gObjMonste
$LN7@gObjMonste:

; 622  : 
; 623  : 	
; 624  : 
; 625  : 	mtx = tpx = lpTargetObj->X;

  000d4	8b 45 d8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000d7	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000de	89 4d fc	 mov	 DWORD PTR _tpx$[ebp], ecx
  000e1	8b 55 fc	 mov	 edx, DWORD PTR _tpx$[ebp]
  000e4	89 55 f4	 mov	 DWORD PTR _mtx$[ebp], edx

; 626  : 	mty = tpy = lpTargetObj->Y;

  000e7	8b 45 d8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000ea	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000f1	89 4d f8	 mov	 DWORD PTR _tpy$[ebp], ecx
  000f4	8b 55 f8	 mov	 edx, DWORD PTR _tpy$[ebp]
  000f7	89 55 f0	 mov	 DWORD PTR _mty$[ebp], edx

; 627  : 	
; 628  : 	int dis;
; 629  : 
; 630  : 
; 631  : 	if( lpObj->m_AttackType >= 100 )

  000fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fd	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  00104	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00107	7c 12		 jl	 SHORT $LN8@gObjMonste

; 632  : 	{
; 633  : 		dis = lpObj->m_AttackRange+2;

  00109	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  00113	83 c1 02	 add	 ecx, 2
  00116	89 4d d0	 mov	 DWORD PTR _dis$[ebp], ecx

; 634  : 	}

  00119	eb 0d		 jmp	 SHORT $LN9@gObjMonste
$LN8@gObjMonste:

; 635  : 	else dis = lpObj->m_AttackRange;

  0011b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011e	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  00125	89 4d d0	 mov	 DWORD PTR _dis$[ebp], ecx
$LN9@gObjMonste:

; 636  : 	
; 637  : 	// 타겟 근처로 위치를 잡는다.
; 638  : 	if( lpObj->X < mtx ) tpx -= dis;

  00128	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012b	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00132	3b 4d f4	 cmp	 ecx, DWORD PTR _mtx$[ebp]
  00135	7d 09		 jge	 SHORT $LN10@gObjMonste
  00137	8b 45 fc	 mov	 eax, DWORD PTR _tpx$[ebp]
  0013a	2b 45 d0	 sub	 eax, DWORD PTR _dis$[ebp]
  0013d	89 45 fc	 mov	 DWORD PTR _tpx$[ebp], eax
$LN10@gObjMonste:

; 639  : 	if( lpObj->X > mtx ) tpx += dis;

  00140	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00143	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0014a	3b 4d f4	 cmp	 ecx, DWORD PTR _mtx$[ebp]
  0014d	7e 09		 jle	 SHORT $LN11@gObjMonste
  0014f	8b 45 fc	 mov	 eax, DWORD PTR _tpx$[ebp]
  00152	03 45 d0	 add	 eax, DWORD PTR _dis$[ebp]
  00155	89 45 fc	 mov	 DWORD PTR _tpx$[ebp], eax
$LN11@gObjMonste:

; 640  : 	if( lpObj->Y < mty ) tpy -= dis;

  00158	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015b	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00162	3b 4d f0	 cmp	 ecx, DWORD PTR _mty$[ebp]
  00165	7d 09		 jge	 SHORT $LN12@gObjMonste
  00167	8b 45 f8	 mov	 eax, DWORD PTR _tpy$[ebp]
  0016a	2b 45 d0	 sub	 eax, DWORD PTR _dis$[ebp]
  0016d	89 45 f8	 mov	 DWORD PTR _tpy$[ebp], eax
$LN12@gObjMonste:

; 641  : 	if( lpObj->Y > mty ) tpy += dis;

  00170	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00173	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0017a	3b 4d f0	 cmp	 ecx, DWORD PTR _mty$[ebp]
  0017d	7e 09		 jle	 SHORT $LN13@gObjMonste
  0017f	8b 45 f8	 mov	 eax, DWORD PTR _tpy$[ebp]
  00182	03 45 d0	 add	 eax, DWORD PTR _dis$[ebp]
  00185	89 45 f8	 mov	 DWORD PTR _tpy$[ebp], eax
$LN13@gObjMonste:

; 642  : 
; 643  : 	searchp = GetPathPacketDirPos(lpTargetObj->X-tpx, lpTargetObj->Y-tpy)*2;

  00188	8b 45 d8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0018b	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00192	2b 4d f8	 sub	 ecx, DWORD PTR _tpy$[ebp]
  00195	51		 push	 ecx
  00196	8b 55 d8	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00199	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  001a0	2b 45 fc	 sub	 eax, DWORD PTR _tpx$[ebp]
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  001a9	83 c4 08	 add	 esp, 8
  001ac	0f b6 c8	 movzx	 ecx, al
  001af	d1 e1		 shl	 ecx, 1
  001b1	89 4d ec	 mov	 DWORD PTR _searchp$[ebp], ecx

; 644  : 	if( MapC[lpObj->MapNumber].GetStandAttr( tpx, tpy) == FALSE )	// 갈수 없다면.

  001b4	8b 45 f8	 mov	 eax, DWORD PTR _tpy$[ebp]
  001b7	50		 push	 eax
  001b8	8b 4d fc	 mov	 ecx, DWORD PTR _tpx$[ebp]
  001bb	51		 push	 ecx
  001bc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001bf	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  001c6	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  001cc	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  001d2	e8 00 00 00 00	 call	 ?GetStandAttr@MapClass@@QAEHHH@Z ; MapClass::GetStandAttr
  001d7	85 c0		 test	 eax, eax
  001d9	0f 85 4a 01 00
	00		 jne	 $LN14@gObjMonste
$LN2@gObjMonste:

; 645  : 	{
; 646  : 		while(searchcount--)

  001df	8b 45 e4	 mov	 eax, DWORD PTR _searchcount$[ebp]
  001e2	89 45 8c	 mov	 DWORD PTR tv170[ebp], eax
  001e5	8b 4d e4	 mov	 ecx, DWORD PTR _searchcount$[ebp]
  001e8	83 e9 01	 sub	 ecx, 1
  001eb	89 4d e4	 mov	 DWORD PTR _searchcount$[ebp], ecx
  001ee	83 7d 8c 00	 cmp	 DWORD PTR tv170[ebp], 0
  001f2	0f 84 25 01 00
	00		 je	 $LN3@gObjMonste

; 647  : 		{
; 648  : 			mtx = lpTargetObj->X+RoadPathTable[searchp];

  001f8	8b 45 d8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001fb	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00202	8b 55 ec	 mov	 edx, DWORD PTR _searchp$[ebp]
  00205	0f bf 04 55 00
	00 00 00	 movsx	 eax, WORD PTR ?RoadPathTable@@3PAFA[edx*2]
  0020d	03 c8		 add	 ecx, eax
  0020f	89 4d f4	 mov	 DWORD PTR _mtx$[ebp], ecx

; 649  : 			mty = lpTargetObj->Y+RoadPathTable[searchp+1];

  00212	8b 45 d8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00215	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0021c	8b 55 ec	 mov	 edx, DWORD PTR _searchp$[ebp]
  0021f	0f bf 04 55 02
	00 00 00	 movsx	 eax, WORD PTR ?RoadPathTable@@3PAFA[edx*2+2]
  00227	03 c8		 add	 ecx, eax
  00229	89 4d f0	 mov	 DWORD PTR _mty$[ebp], ecx

; 650  : 			
; 651  : 			//  자리가 비어있으면..
; 652  : 			attr= MapC[lpObj->MapNumber].GetAttr(mtx, mty);

  0022c	8b 45 f0	 mov	 eax, DWORD PTR _mty$[ebp]
  0022f	50		 push	 eax
  00230	8b 4d f4	 mov	 ecx, DWORD PTR _mtx$[ebp]
  00233	51		 push	 ecx
  00234	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00237	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0023e	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00244	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0024a	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0024f	88 45 e3	 mov	 BYTE PTR _attr$[ebp], al

; 653  : 			result = gObjMonsterMoveCheck(lpObj, mtx, mty);

  00252	8b 45 f0	 mov	 eax, DWORD PTR _mty$[ebp]
  00255	50		 push	 eax
  00256	8b 4d f4	 mov	 ecx, DWORD PTR _mtx$[ebp]
  00259	51		 push	 ecx
  0025a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0025d	52		 push	 edx
  0025e	e8 00 00 00 00	 call	 ?gObjMonsterMoveCheck@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjMonsterMoveCheck
  00263	83 c4 0c	 add	 esp, 12			; 0000000cH
  00266	89 45 dc	 mov	 DWORD PTR _result$[ebp], eax

; 654  : 
; 655  : 			if( lpObj->Class == 249 )

  00269	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00273	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  00279	75 37		 jne	 SHORT $LN16@gObjMonste

; 656  : 			{
; 657  : 				if( ((attr&MAP_ATTR_STAND) != MAP_ATTR_STAND) && (result==TRUE) )

  0027b	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0027f	83 e0 02	 and	 eax, 2
  00282	75 2c		 jne	 SHORT $LN18@gObjMonste
  00284	83 7d dc 01	 cmp	 DWORD PTR _result$[ebp], 1
  00288	75 26		 jne	 SHORT $LN18@gObjMonste

; 658  : 				{
; 659  : 					lpObj->MTX = mtx;

  0028a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028d	66 8b 4d f4	 mov	 cx, WORD PTR _mtx$[ebp]
  00291	66 89 88 24 01
	00 00		 mov	 WORD PTR [eax+292], cx

; 660  : 					lpObj->MTY = mty;

  00298	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029b	66 8b 4d f0	 mov	 cx, WORD PTR _mty$[ebp]
  0029f	66 89 88 26 01
	00 00		 mov	 WORD PTR [eax+294], cx

; 661  : 					return TRUE;

  002a6	b8 01 00 00 00	 mov	 eax, 1
  002ab	e9 4b 01 00 00	 jmp	 $LN1@gObjMonste
$LN18@gObjMonste:

; 662  : 				}
; 663  : 			}

  002b0	eb 50		 jmp	 SHORT $LN17@gObjMonste
$LN16@gObjMonste:

; 664  : 			else
; 665  : 			{
; 666  : 				if(    ((attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE) 
; 667  : 					&& ((attr&MAP_ATTR_STAND) != MAP_ATTR_STAND) 
; 668  : 					&& ((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) 
; 669  : 					&& ((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW) 
; 670  : 					&& (result==TRUE) )

  002b2	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  002b6	83 e0 01	 and	 eax, 1
  002b9	75 47		 jne	 SHORT $LN17@gObjMonste
  002bb	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  002bf	83 e0 02	 and	 eax, 2
  002c2	75 3e		 jne	 SHORT $LN17@gObjMonste
  002c4	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  002c8	83 e0 04	 and	 eax, 4
  002cb	75 35		 jne	 SHORT $LN17@gObjMonste
  002cd	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  002d1	83 e0 08	 and	 eax, 8
  002d4	75 2c		 jne	 SHORT $LN17@gObjMonste
  002d6	83 7d dc 01	 cmp	 DWORD PTR _result$[ebp], 1
  002da	75 26		 jne	 SHORT $LN17@gObjMonste

; 671  : 				{
; 672  : 					lpObj->MTX = mtx;

  002dc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002df	66 8b 4d f4	 mov	 cx, WORD PTR _mtx$[ebp]
  002e3	66 89 88 24 01
	00 00		 mov	 WORD PTR [eax+292], cx

; 673  : 					lpObj->MTY = mty;

  002ea	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ed	66 8b 4d f0	 mov	 cx, WORD PTR _mty$[ebp]
  002f1	66 89 88 26 01
	00 00		 mov	 WORD PTR [eax+294], cx

; 674  : 					return TRUE;

  002f8	b8 01 00 00 00	 mov	 eax, 1
  002fd	e9 f9 00 00 00	 jmp	 $LN1@gObjMonste
$LN17@gObjMonste:

; 675  : 				}
; 676  : 			}
; 677  : 			searchp += 2;

  00302	8b 45 ec	 mov	 eax, DWORD PTR _searchp$[ebp]
  00305	83 c0 02	 add	 eax, 2
  00308	89 45 ec	 mov	 DWORD PTR _searchp$[ebp], eax

; 678  : 
; 679  : 			if( searchp > 15 ) searchp = 0;

  0030b	83 7d ec 0f	 cmp	 DWORD PTR _searchp$[ebp], 15 ; 0000000fH
  0030f	7e 07		 jle	 SHORT $LN20@gObjMonste
  00311	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _searchp$[ebp], 0
$LN20@gObjMonste:

; 680  : 		}		

  00318	e9 c2 fe ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 681  : 		return FALSE;

  0031d	33 c0		 xor	 eax, eax
  0031f	e9 d7 00 00 00	 jmp	 $LN1@gObjMonste

; 682  : 	}

  00324	e9 d0 00 00 00	 jmp	 $LN15@gObjMonste
$LN14@gObjMonste:

; 683  : 	else
; 684  : 	{
; 685  : 		attr= MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  00329	8b 45 f8	 mov	 eax, DWORD PTR _tpy$[ebp]
  0032c	50		 push	 eax
  0032d	8b 4d fc	 mov	 ecx, DWORD PTR _tpx$[ebp]
  00330	51		 push	 ecx
  00331	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00334	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0033b	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00341	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00347	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0034c	88 45 e3	 mov	 BYTE PTR _attr$[ebp], al

; 686  : 		result = gObjMonsterMoveCheck(lpObj, mtx, mty);

  0034f	8b 45 f0	 mov	 eax, DWORD PTR _mty$[ebp]
  00352	50		 push	 eax
  00353	8b 4d f4	 mov	 ecx, DWORD PTR _mtx$[ebp]
  00356	51		 push	 ecx
  00357	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0035a	52		 push	 edx
  0035b	e8 00 00 00 00	 call	 ?gObjMonsterMoveCheck@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjMonsterMoveCheck
  00360	83 c4 0c	 add	 esp, 12			; 0000000cH
  00363	89 45 dc	 mov	 DWORD PTR _result$[ebp], eax

; 687  : 
; 688  : 		if( lpObj->Class == 249 )

  00366	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00369	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00370	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  00376	75 34		 jne	 SHORT $LN21@gObjMonste

; 689  : 		{
; 690  : 			if( ((attr&MAP_ATTR_STAND) != MAP_ATTR_STAND) && (result==TRUE) ) 

  00378	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0037c	83 e0 02	 and	 eax, 2
  0037f	75 29		 jne	 SHORT $LN23@gObjMonste
  00381	83 7d dc 01	 cmp	 DWORD PTR _result$[ebp], 1
  00385	75 23		 jne	 SHORT $LN23@gObjMonste

; 691  : 			{
; 692  : 				lpObj->MTX = tpx;

  00387	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0038a	66 8b 4d fc	 mov	 cx, WORD PTR _tpx$[ebp]
  0038e	66 89 88 24 01
	00 00		 mov	 WORD PTR [eax+292], cx

; 693  : 				lpObj->MTY = tpy;

  00395	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00398	66 8b 4d f8	 mov	 cx, WORD PTR _tpy$[ebp]
  0039c	66 89 88 26 01
	00 00		 mov	 WORD PTR [eax+294], cx

; 694  : 				return TRUE;

  003a3	b8 01 00 00 00	 mov	 eax, 1
  003a8	eb 51		 jmp	 SHORT $LN1@gObjMonste
$LN23@gObjMonste:

; 695  : 			}
; 696  : 
; 697  : 		}

  003aa	eb 4d		 jmp	 SHORT $LN15@gObjMonste
$LN21@gObjMonste:

; 698  : 		else
; 699  : 		{
; 700  : 			if( ((attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE) && 
; 701  : 				((attr&MAP_ATTR_STAND) != MAP_ATTR_STAND) &&
; 702  : 				((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) &&
; 703  : 				((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW) && 

  003ac	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  003b0	83 e0 01	 and	 eax, 1
  003b3	75 44		 jne	 SHORT $LN15@gObjMonste
  003b5	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  003b9	83 e0 02	 and	 eax, 2
  003bc	75 3b		 jne	 SHORT $LN15@gObjMonste
  003be	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  003c2	83 e0 04	 and	 eax, 4
  003c5	75 32		 jne	 SHORT $LN15@gObjMonste
  003c7	0f b6 45 e3	 movzx	 eax, BYTE PTR _attr$[ebp]
  003cb	83 e0 08	 and	 eax, 8
  003ce	75 29		 jne	 SHORT $LN15@gObjMonste
  003d0	83 7d dc 01	 cmp	 DWORD PTR _result$[ebp], 1
  003d4	75 23		 jne	 SHORT $LN15@gObjMonste

; 704  : 				(result==TRUE) ) // 안전지대와 못 가는길이면..
; 705  : 			{
; 706  : 				lpObj->MTX = tpx;

  003d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d9	66 8b 4d fc	 mov	 cx, WORD PTR _tpx$[ebp]
  003dd	66 89 88 24 01
	00 00		 mov	 WORD PTR [eax+292], cx

; 707  : 				lpObj->MTY = tpy;

  003e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e7	66 8b 4d f8	 mov	 cx, WORD PTR _tpy$[ebp]
  003eb	66 89 88 26 01
	00 00		 mov	 WORD PTR [eax+294], cx

; 708  : 				return TRUE;

  003f2	b8 01 00 00 00	 mov	 eax, 1
  003f7	eb 02		 jmp	 SHORT $LN1@gObjMonste
$LN15@gObjMonste:

; 709  : 			}
; 710  : 		}
; 711  : 	}
; 712  : 	return FALSE;

  003f9	33 c0		 xor	 eax, eax
$LN1@gObjMonste:

; 713  : }

  003fb	5f		 pop	 edi
  003fc	5e		 pop	 esi
  003fd	5b		 pop	 ebx
  003fe	8b e5		 mov	 esp, ebp
  00400	5d		 pop	 ebp
  00401	c3		 ret	 0
?gObjMonsterGetTargetPos@@YAHPAVOBJECTSTRUCT@@@Z ENDP	; gObjMonsterGetTargetPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterSearchEnemy@@YAHPAVOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_t2$ = -40						; size = 4
_t1$ = -36						; size = 4
_count$ = -32						; size = 4
_tObjNum$ = -28						; size = 4
_searchtarget$ = -24					; size = 4
_mindis$ = -20						; size = 4
_dis$ = -16						; size = 4
_ty$ = -12						; size = 4
_tx$ = -8						; size = 4
_n$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_objtype$ = 12						; size = 1
?gObjMonsterSearchEnemy@@YAHPAVOBJECTSTRUCT@@E@Z PROC	; gObjMonsterSearchEnemy, COMDAT

; 854  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 855  : 	int n;
; 856  : 	int tx, ty;
; 857  : 	int dis;
; 858  : 	int mindis=lpObj->m_ViewRange;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f bf 88 fc 02
	00 00		 movsx	 ecx, WORD PTR [eax+764]
  00013	89 4d ec	 mov	 DWORD PTR _mindis$[ebp], ecx

; 859  : 	int searchtarget=-1;

  00016	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _searchtarget$[ebp], -1

; 860  : 	int tObjNum;
; 861  : 	int count=3;

  0001d	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _count$[ebp], 3

; 862  : 	int t1, t2;
; 863  : 
; 864  : 	t1 = objtype;//&OBJTYPE_CHARACTER;

  00024	0f b6 45 0c	 movzx	 eax, BYTE PTR _objtype$[ebp]
  00028	89 45 dc	 mov	 DWORD PTR _t1$[ebp], eax

; 865  : 	t2 = objtype;//&OBJTYPE_MONSTER;

  0002b	0f b6 45 0c	 movzx	 eax, BYTE PTR _objtype$[ebp]
  0002f	89 45 d8	 mov	 DWORD PTR _t2$[ebp], eax

; 866  : 
; 867  : 	for( n=0; n<MAX_MONVIEWPORTOBJECT; n++)

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00039	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjMonste:
  00044	83 7d fc 14	 cmp	 DWORD PTR _n$[ebp], 20	; 00000014H
  00048	0f 8d ab 01 00
	00		 jge	 $LN3@gObjMonste

; 868  : 	{
; 869  : 		tObjNum = lpObj->VpPlayer2[n].number;

  0004e	6b 45 fc 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00055	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  0005d	89 55 e4	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 870  : 		if( tObjNum >= 0 )

  00060	83 7d e4 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00064	0f 8c 8a 01 00
	00		 jl	 $LN14@gObjMonste

; 871  : 		{
; 872  : 			if( (gObj[tObjNum].Type == t1 ||
; 873  : 				gObj[tObjNum].Type == t2 ) &&

  0006a	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00077	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0007c	3b 55 dc	 cmp	 edx, DWORD PTR _t1$[ebp]
  0007f	74 1b		 je	 SHORT $LN7@gObjMonste
  00081	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008e	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00093	3b 55 d8	 cmp	 edx, DWORD PTR _t2$[ebp]
  00096	0f 85 58 01 00
	00		 jne	 $LN14@gObjMonste
$LN7@gObjMonste:
  0009c	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a9	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  000ae	85 d2		 test	 edx, edx
  000b0	0f 84 3e 01 00
	00		 je	 $LN14@gObjMonste

; 874  : 				gObj[tObjNum].Live)	// 유저가 할당되어 있다면..
; 875  : 			{
; 876  : 				if( (gObj[tObjNum].Class >= 100 && gObj[tObjNum].Class < 110) ||

  000b6	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c3	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  000cb	83 fa 64	 cmp	 edx, 100		; 00000064H
  000ce	7c 1a		 jl	 SHORT $LN11@gObjMonste
  000d0	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000dd	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  000e5	83 fa 6e	 cmp	 edx, 110		; 0000006eH
  000e8	7c 2e		 jl	 SHORT $LN10@gObjMonste
$LN11@gObjMonste:
  000ea	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f7	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  000fc	83 fa 02	 cmp	 edx, 2
  000ff	75 1c		 jne	 SHORT $LN8@gObjMonste
  00101	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010e	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  00116	7c 05		 jl	 SHORT $LN8@gObjMonste
$LN10@gObjMonste:

; 877  : 					(gObj[tObjNum].Type==OBJTYPE_MONSTER&&gObj[tObjNum].m_RecallMon>=0) )
; 878  : 				{
; 879  : 				}

  00118	e9 d7 00 00 00	 jmp	 $LN14@gObjMonste
$LN8@gObjMonste:

; 880  : 				else
; 881  : 				{
; 882  : #ifdef ADD_NEWPVP_PKFIELD
; 883  : 					if ( g_NewPVP.IsObserver(gObj[tObjNum]) )
; 884  : 						continue;
; 885  : #endif // ADD_NEWPVP_PKFIELD
; 886  : 					
; 887  : #ifdef UPDATE_GM_FUNCTION_20070228	// EVENT_GM 일 경우도 공격 안되게
; 888  : 					if( (gObj[tObjNum].Authority&AUTHORITY_ADMIN) != AUTHORITY_ADMIN
; 889  : 						&& (gObj[tObjNum].Authority&AUTHORITY_EVENT_GM) != AUTHORITY_EVENT_GM )
; 890  : #else
; 891  : 					if( (gObj[tObjNum].Authority&AUTHORITY_ADMIN) != AUTHORITY_ADMIN ) 

  0011d	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012a	8b 94 01 a4 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+420]
  00131	83 e2 02	 and	 edx, 2
  00134	0f 85 ba 00 00
	00		 jne	 $LN14@gObjMonste

; 892  : #endif
; 893  : 					{
; 894  : 						if( !gObj[tObjNum].Teleport )

  0013a	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00141	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00147	0f be 94 01 fc
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+508]
  0014f	85 d2		 test	 edx, edx
  00151	0f 85 9d 00 00
	00		 jne	 $LN14@gObjMonste

; 895  : 						{
; 896  : 							tx = lpObj->X-gObj[tObjNum].X;

  00157	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015a	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00161	69 55 e4 a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  00168	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016d	0f bf 94 10 04
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+260]
  00175	2b ca		 sub	 ecx, edx
  00177	89 4d f8	 mov	 DWORD PTR _tx$[ebp], ecx

; 897  : 							ty = lpObj->Y-gObj[tObjNum].Y;

  0017a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017d	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00184	69 55 e4 a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  0018b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00190	0f bf 94 10 06
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+262]
  00198	2b ca		 sub	 ecx, edx
  0019a	89 4d f4	 mov	 DWORD PTR _ty$[ebp], ecx

; 898  : 							
; 899  : 							dis = (int)sqrt((double)(tx*tx)+(ty*ty));

  0019d	8b 45 f8	 mov	 eax, DWORD PTR _tx$[ebp]
  001a0	0f af 45 f8	 imul	 eax, DWORD PTR _tx$[ebp]
  001a4	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  001a8	8b 4d f4	 mov	 ecx, DWORD PTR _ty$[ebp]
  001ab	0f af 4d f4	 imul	 ecx, DWORD PTR _ty$[ebp]
  001af	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  001b3	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001b7	83 ec 08	 sub	 esp, 8
  001ba	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001bf	e8 00 00 00 00	 call	 _sqrt
  001c4	83 c4 08	 add	 esp, 8
  001c7	e8 00 00 00 00	 call	 __ftol2_sse
  001cc	89 45 f0	 mov	 DWORD PTR _dis$[ebp], eax

; 900  : 							lpObj->VpPlayer2[n].dis = dis;

  001cf	6b 45 fc 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  001d3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d6	8b 55 f0	 mov	 edx, DWORD PTR _dis$[ebp]
  001d9	89 94 01 f0 06
	00 00		 mov	 DWORD PTR [ecx+eax+1776], edx

; 901  : 							//if( dis <= 3 )	// 최소 영역에 들어오고..
; 902  : 							{	// 다른 애들보다 가까이 있다면..
; 903  : 								if( dis < mindis ) 

  001e0	8b 45 f0	 mov	 eax, DWORD PTR _dis$[ebp]
  001e3	3b 45 ec	 cmp	 eax, DWORD PTR _mindis$[ebp]
  001e6	7d 0c		 jge	 SHORT $LN14@gObjMonste

; 904  : 								{					
; 905  : 									searchtarget = tObjNum;

  001e8	8b 45 e4	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  001eb	89 45 e8	 mov	 DWORD PTR _searchtarget$[ebp], eax

; 906  : 									mindis = dis;

  001ee	8b 45 f0	 mov	 eax, DWORD PTR _dis$[ebp]
  001f1	89 45 ec	 mov	 DWORD PTR _mindis$[ebp], eax
$LN14@gObjMonste:

; 907  : 								}
; 908  : 							}
; 909  : 						}
; 910  : 					}
; 911  : 				}
; 912  : 			}
; 913  : 		}
; 914  : 	}

  001f4	e9 42 fe ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 915  : 
; 916  : 	return searchtarget;

  001f9	8b 45 e8	 mov	 eax, DWORD PTR _searchtarget$[ebp]

; 917  : }

  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi
  001fe	5b		 pop	 ebx
  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
?gObjMonsterSearchEnemy@@YAHPAVOBJECTSTRUCT@@E@Z ENDP	; gObjMonsterSearchEnemy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjCallMonsterSetEnemy@@YAHPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpCallObj$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_Target$ = 12						; size = 4
?gObjCallMonsterSetEnemy@@YAHPAVOBJECTSTRUCT@@H@Z PROC	; gObjCallMonsterSetEnemy, COMDAT

; 830  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 831  : 	if( lpObj->Type != OBJTYPE_CHARACTER ) return -1;	

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 08		 je	 SHORT $LN2@gObjCallMo
  00015	83 c8 ff	 or	 eax, -1
  00018	e9 96 00 00 00	 jmp	 $LN1@gObjCallMo
$LN2@gObjCallMo:

; 832  : 	LPOBJECTSTRUCT lpCallObj;
; 833  : 
; 834  : #ifdef MODIFY_TARGETNUMBER_RECALLMON_INDEX_BUFGIX_20080711
; 835  : 	if( lpObj->m_RecallMon < 0 ) return -1;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00020	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00027	7d 08		 jge	 SHORT $LN3@gObjCallMo
  00029	83 c8 ff	 or	 eax, -1
  0002c	e9 82 00 00 00	 jmp	 $LN1@gObjCallMo
$LN3@gObjCallMo:

; 836  : #endif	// MODIFY_TARGETNUMBER_RECALLMON_INDEX_BUFGIX_20080711
; 837  : 	
; 838  : 	lpCallObj = (LPOBJECTSTRUCT)&gObj[lpObj->m_RecallMon];

  00031	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00034	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  0003e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00044	89 4d fc	 mov	 DWORD PTR _lpCallObj$[ebp], ecx

; 839  : 
; 840  : 	if( lpCallObj->TargetNumber >= 0 ) return -1;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  0004a	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00051	85 c9		 test	 ecx, ecx
  00053	7c 05		 jl	 SHORT $LN4@gObjCallMo
  00055	83 c8 ff	 or	 eax, -1
  00058	eb 59		 jmp	 SHORT $LN1@gObjCallMo
$LN4@gObjCallMo:

; 841  : 
; 842  : 	if( lpCallObj->TargetNumber != Target )

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  0005d	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00064	3b 4d 0c	 cmp	 ecx, DWORD PTR _Target$[ebp]
  00067	74 47		 je	 SHORT $LN5@gObjCallMo

; 843  : 	{
; 844  : 	//if( lpCallObj->TargetNumber = 0 )
; 845  : 		lpCallObj->TargetNumber = Target;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  0006c	66 8b 4d 0c	 mov	 cx, WORD PTR _Target$[ebp]
  00070	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx

; 846  : 		//LogAdd("주인 공격 몬스터 세팅 %d", Target);
; 847  : 		lpCallObj->m_ActState.EmotionCount = 30;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  0007a	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00080	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  00086	81 c9 00 1e 00
	00		 or	 ecx, 7680		; 00001e00H
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _lpCallObj$[ebp]
  0008f	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 848  : 		lpCallObj->m_ActState.Emotion = 1;

  00095	8b 45 fc	 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  00098	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0009e	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  000a4	83 c9 10	 or	 ecx, 16			; 00000010H
  000a7	8b 55 fc	 mov	 edx, DWORD PTR _lpCallObj$[ebp]
  000aa	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN5@gObjCallMo:

; 849  : 	}
; 850  : 	return -1;

  000b0	83 c8 ff	 or	 eax, -1
$LN1@gObjCallMo:

; 851  : }

  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?gObjCallMonsterSetEnemy@@YAHPAVOBJECTSTRUCT@@H@Z ENDP	; gObjCallMonsterSetEnemy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterHitDamageUserDel@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_delindex$ = -8						; size = 4
_delok$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterHitDamageUserDel@@YAHPAVOBJECTSTRUCT@@@Z PROC ; gObjMonsterHitDamageUserDel, COMDAT

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 386  : 	int delok=0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _delok$[ebp], 0

; 387  : 	int delindex=-1;

  00010	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _delindex$[ebp], -1

; 388  : 
; 389  : 	for(int n=0; n<MAX_HITDAMAGE; n++)

  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0001e	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  00020	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjMonste:
  00029	83 7d f4 28	 cmp	 DWORD PTR _n$1[ebp], 40	; 00000028H
  0002d	0f 8d 42 01 00
	00		 jge	 $LN3@gObjMonste

; 390  : 	{
; 391  : 		if( lpObj->sHD[n].number >= 0 )

  00033	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0003a	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  00042	85 d2		 test	 edx, edx
  00044	0f 8c 26 01 00
	00		 jl	 $LN5@gObjMonste

; 392  : 		{
; 393  : 			delok = 0;

  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _delok$[ebp], 0

; 394  : 			// 접속해 있고..
; 395  : 			if( gObjIsConnected(lpObj->sHD[n].number) == TRUE )

  00051	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00058	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00066	83 c4 04	 add	 esp, 4
  00069	83 f8 01	 cmp	 eax, 1
  0006c	0f 85 c1 00 00
	00		 jne	 $LN6@gObjMonste

; 396  : 			{
; 397  : 				// 마지막 타격이 20초 지난 사용자는 잊어버린다.
; 398  : 				if( (GetTickCount()-(lpObj->sHD[n].LastHitTime)) > (1000*20) )

  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00078	6b 4d f4 0c	 imul	 ecx, DWORD PTR _n$1[ebp], 12
  0007c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0007f	2b 84 0a 7c 0a
	00 00		 sub	 eax, DWORD PTR [edx+ecx+2684]
  00086	3d 20 4e 00 00	 cmp	 eax, 20000		; 00004e20H
  0008b	76 07		 jbe	 SHORT $LN8@gObjMonste

; 399  : 				{
; 400  : 					delok = 1;

  0008d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _delok$[ebp], 1
$LN8@gObjMonste:

; 401  : 				}
; 402  : 				// 같은 맵에 위치하지 않았다면..
; 403  : 				if( gObj[lpObj->sHD[n].number].MapNumber != lpObj->MapNumber )

  00094	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009b	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  000a3	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000b7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ba	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000c1	3b d1		 cmp	 edx, ecx
  000c3	74 09		 je	 SHORT $LN9@gObjMonste

; 404  : 				{
; 405  : 					delok = 1;

  000c5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _delok$[ebp], 1

; 406  : 				}

  000cc	eb 63		 jmp	 SHORT $LN10@gObjMonste
$LN9@gObjMonste:

; 407  : 				else	// 같은 맵에 있다면.. 위치를 체크한다.
; 408  : 				{
; 409  : 					if( gObjCheckTileArea(	lpObj->m_Index, gObj[lpObj->sHD[n].number].X, gObj[lpObj->sHD[n].number].Y, 20) == FALSE )

  000ce	6a 14		 push	 20			; 00000014H
  000d0	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d7	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  000df	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000eb	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  000f3	52		 push	 edx
  000f4	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000fb	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  00103	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010f	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00117	52		 push	 edx
  00118	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 ?gObjCheckTileArea@@YAHHHHH@Z ; gObjCheckTileArea
  00123	83 c4 10	 add	 esp, 16			; 00000010H
  00126	85 c0		 test	 eax, eax
  00128	75 07		 jne	 SHORT $LN10@gObjMonste

; 410  : 					{
; 411  : 						delok = 1;	// 뷰 포트에 없다.

  0012a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _delok$[ebp], 1
$LN10@gObjMonste:

; 412  : 					}
; 413  : 				}
; 414  : 			}

  00131	eb 07		 jmp	 SHORT $LN7@gObjMonste
$LN6@gObjMonste:

; 415  : 			else delok = 1;	// 접속해 있지 않다면			

  00133	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _delok$[ebp], 1
$LN7@gObjMonste:

; 416  : 			if( delok == 1 ) {

  0013a	83 7d fc 01	 cmp	 DWORD PTR _delok$[ebp], 1
  0013e	75 30		 jne	 SHORT $LN5@gObjMonste

; 417  : 				lpObj->sHD[n].number = -1;

  00140	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00144	83 c9 ff	 or	 ecx, -1
  00147	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0014a	66 89 8c 02 74
	0a 00 00	 mov	 WORD PTR [edx+eax+2676], cx

; 418  : 				delindex = n;

  00152	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00155	89 45 f8	 mov	 DWORD PTR _delindex$[ebp], eax

; 419  : 				lpObj->sHDCount--;

  00158	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015b	66 8b 88 54 0c
	00 00		 mov	 cx, WORD PTR [eax+3156]
  00162	66 83 e9 01	 sub	 cx, 1
  00166	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00169	66 89 8a 54 0c
	00 00		 mov	 WORD PTR [edx+3156], cx
$LN5@gObjMonste:

; 420  : 			}
; 421  : 		}
; 422  : 	}

  00170	e9 ab fe ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 423  : 	return delindex;

  00175	8b 45 f8	 mov	 eax, DWORD PTR _delindex$[ebp]

; 424  : }

  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	5b		 pop	 ebx
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
?gObjMonsterHitDamageUserDel@@YAHPAVOBJECTSTRUCT@@@Z ENDP ; gObjMonsterHitDamageUserDel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterHitDamageInit@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterHitDamageInit@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjMonsterHitDamageInit, COMDAT

; 372  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 373  : 	for( int i=0; i<MAX_HITDAMAGE; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@gObjMonste:
  0001b	83 7d fc 28	 cmp	 DWORD PTR _i$1[ebp], 40	; 00000028H
  0001f	7d 14		 jge	 SHORT $LN3@gObjMonste

; 374  : 	{
; 375  : 		lpObj->sHD[i].number = -1;

  00021	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  00025	83 c9 ff	 or	 ecx, -1
  00028	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0002b	66 89 8c 02 74
	0a 00 00	 mov	 WORD PTR [edx+eax+2676], cx

; 376  : 	}

  00033	eb dd		 jmp	 SHORT $LN2@gObjMonste
$LN3@gObjMonste:

; 377  : 	lpObj->sHDCount = 0;

  00035	33 c0		 xor	 eax, eax
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0003a	66 89 81 54 0c
	00 00		 mov	 WORD PTR [ecx+3156], ax

; 378  : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?gObjMonsterHitDamageInit@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjMonsterHitDamageInit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterSetHitDamage@@YAXPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_blank$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_hit_player$ = 12					; size = 4
_hit_damage$ = 16					; size = 4
?gObjMonsterSetHitDamage@@YAXPAVOBJECTSTRUCT@@HH@Z PROC	; gObjMonsterSetHitDamage, COMDAT

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 434  : 	int blank=-1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _blank$[ebp], -1

; 435  : 
; 436  : 	for(int n=0; n<MAX_HITDAMAGE; n++)

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjMonste:
  00022	83 7d f8 28	 cmp	 DWORD PTR _n$1[ebp], 40	; 00000028H
  00026	0f 8d ab 00 00
	00		 jge	 $LN3@gObjMonste

; 437  : 	{
; 438  : 		if( lpObj->sHD[n].number >= 0 )

  0002c	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00033	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  0003b	85 d2		 test	 edx, edx
  0003d	0f 8c 83 00 00
	00		 jl	 $LN5@gObjMonste

; 439  : 		{
; 440  : 			if( lpObj->sHD[n].number == hit_player )

  00043	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0004a	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  00052	3b 55 0c	 cmp	 edx, DWORD PTR _hit_player$[ebp]
  00055	75 6d		 jne	 SHORT $LN7@gObjMonste

; 441  : 			{
; 442  : 				lpObj->sHD[n].HitDamage   += hit_damage;

  00057	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0005e	8b 94 01 78 0a
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2680]
  00065	03 55 10	 add	 edx, DWORD PTR _hit_damage$[ebp]
  00068	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0006f	89 94 01 78 0a
	00 00		 mov	 DWORD PTR [ecx+eax+2680], edx

; 443  : 				lpObj->sHD[n].LastHitTime  = GetTickCount();				

  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0007c	6b 4d f8 0c	 imul	 ecx, DWORD PTR _n$1[ebp], 12
  00080	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00083	89 84 0a 7c 0a
	00 00		 mov	 DWORD PTR [edx+ecx+2684], eax

; 444  : 
; 445  : 				if( lpObj->sHD[n].HitDamage > lpObj->MaxLife )

  0008a	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00091	f3 0f 2a 84 01
	78 0a 00 00	 cvtsi2ss xmm0, DWORD PTR [ecx+eax+2680]
  0009a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009d	0f 2f 82 c0 00
	00 00		 comiss	 xmm0, DWORD PTR [edx+192]
  000a4	76 19		 jbe	 SHORT $LN8@gObjMonste

; 446  : 					lpObj->sHD[n].HitDamage = (int)lpObj->MaxLife;

  000a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a9	f3 0f 2c 88 c0
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+192]
  000b1	6b 55 f8 0c	 imul	 edx, DWORD PTR _n$1[ebp], 12
  000b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b8	89 8c 10 78 0a
	00 00		 mov	 DWORD PTR [eax+edx+2680], ecx
$LN8@gObjMonste:

; 447  : 				return;

  000bf	e9 c7 00 00 00	 jmp	 $LN1@gObjMonste
$LN7@gObjMonste:

; 448  : 			}
; 449  : 		}

  000c4	eb 0c		 jmp	 SHORT $LN9@gObjMonste
$LN5@gObjMonste:

; 450  : 		else {
; 451  : 			if( blank < 0 ) blank = n;

  000c6	83 7d fc 00	 cmp	 DWORD PTR _blank$[ebp], 0
  000ca	7d 06		 jge	 SHORT $LN9@gObjMonste
  000cc	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  000cf	89 45 fc	 mov	 DWORD PTR _blank$[ebp], eax
$LN9@gObjMonste:

; 452  : 		}
; 453  : 	}

  000d2	e9 42 ff ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 454  : 
; 455  : 	if( blank < 0 )

  000d7	83 7d fc 00	 cmp	 DWORD PTR _blank$[ebp], 0
  000db	7d 0f		 jge	 SHORT $LN10@gObjMonste

; 456  : 	{
; 457  : 		// 빈 공간이 부족하다.. 공간을 확보하기 위해 지운다.
; 458  : 		blank = gObjMonsterHitDamageUserDel(lpObj);

  000dd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageUserDel@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageUserDel
  000e6	83 c4 04	 add	 esp, 4
  000e9	89 45 fc	 mov	 DWORD PTR _blank$[ebp], eax
$LN10@gObjMonste:

; 459  : 	}
; 460  : 	
; 461  : 	// 기존 사용자가 아닐땐 빈공간에 새로 추가한다...
; 462  : 	// 이때.. 빈 공간이 없으면 추가할수 없기때문에.. 시간이 오래된 유저를 삭제한다.
; 463  : 	if( blank >= 0 )

  000ec	83 7d fc 00	 cmp	 DWORD PTR _blank$[ebp], 0
  000f0	0f 8c 87 00 00
	00		 jl	 $LN11@gObjMonste

; 464  : 	{
; 465  : 		lpObj->sHD[blank].number		= hit_player;

  000f6	6b 45 fc 0c	 imul	 eax, DWORD PTR _blank$[ebp], 12
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000fd	66 8b 55 0c	 mov	 dx, WORD PTR _hit_player$[ebp]
  00101	66 89 94 01 74
	0a 00 00	 mov	 WORD PTR [ecx+eax+2676], dx

; 466  : 		lpObj->sHD[blank].HitDamage		= hit_damage;

  00109	6b 45 fc 0c	 imul	 eax, DWORD PTR _blank$[ebp], 12
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00110	8b 55 10	 mov	 edx, DWORD PTR _hit_damage$[ebp]
  00113	89 94 01 78 0a
	00 00		 mov	 DWORD PTR [ecx+eax+2680], edx

; 467  : 		if( lpObj->sHD[blank].HitDamage > lpObj->MaxLife )

  0011a	6b 45 fc 0c	 imul	 eax, DWORD PTR _blank$[ebp], 12
  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00121	f3 0f 2a 84 01
	78 0a 00 00	 cvtsi2ss xmm0, DWORD PTR [ecx+eax+2680]
  0012a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0012d	0f 2f 82 c0 00
	00 00		 comiss	 xmm0, DWORD PTR [edx+192]
  00134	76 19		 jbe	 SHORT $LN13@gObjMonste

; 468  : 			lpObj->sHD[blank].HitDamage = (int)lpObj->MaxLife;

  00136	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00139	f3 0f 2c 88 c0
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+192]
  00141	6b 55 fc 0c	 imul	 edx, DWORD PTR _blank$[ebp], 12
  00145	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00148	89 8c 10 78 0a
	00 00		 mov	 DWORD PTR [eax+edx+2680], ecx
$LN13@gObjMonste:

; 469  : 		lpObj->sHD[blank].LastHitTime	= GetTickCount();

  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00155	6b 4d fc 0c	 imul	 ecx, DWORD PTR _blank$[ebp], 12
  00159	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015c	89 84 0a 7c 0a
	00 00		 mov	 DWORD PTR [edx+ecx+2684], eax

; 470  : 		lpObj->sHDCount++;

  00163	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00166	66 8b 88 54 0c
	00 00		 mov	 cx, WORD PTR [eax+3156]
  0016d	66 83 c1 01	 add	 cx, 1
  00171	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00174	66 89 8a 54 0c
	00 00		 mov	 WORD PTR [edx+3156], cx

; 471  : 	}

  0017b	eb 0e		 jmp	 SHORT $LN12@gObjMonste
$LN11@gObjMonste:

; 472  : 	else 
; 473  : 	{
; 474  : 		LogAdd("error-L2 : Hit Damage Set error");

  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MINPGEPL@error?9L2?5?3?5Hit?5Damage?5Set?5error@
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00188	83 c4 04	 add	 esp, 4
$LN12@gObjMonste:
$LN1@gObjMonste:

; 475  : 	}
; 476  : }

  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5b		 pop	 ebx
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
?gObjMonsterSetHitDamage@@YAXPAVOBJECTSTRUCT@@HH@Z ENDP	; gObjMonsterSetHitDamage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv196 = -88						; size = 4
tv197 = -84						; size = 4
_map$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjMonsterRegen, COMDAT

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 173  : 	int map[3] = { 0, 2, 3};

  00013	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _map$[ebp], 0
  0001a	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _map$[ebp+4], 2
  00021	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _map$[ebp+8], 3

; 174  : 
; 175  : 	gObjViewportListProtocolDestroy(lpObj);

  00028	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
  00031	83 c4 04	 add	 esp, 4

; 176  : 	gObjViewportClose(lpObj);

  00034	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportClose
  0003d	83 c4 04	 add	 esp, 4

; 177  : 
; 178  : 	lpObj->m_ActState.Attack		= 0;

  00040	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00043	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00049	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0004c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0004f	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 179  : 	lpObj->m_ActState.EmotionCount	= 0;

  00055	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00058	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0005e	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  00064	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00067	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 180  : 	lpObj->m_ActState.Escape		= 0;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00070	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00076	83 e1 f7	 and	 ecx, -9			; fffffff7H
  00079	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0007c	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 181  : 	lpObj->m_ActState.Move			= 0;

  00082	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00085	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0008b	83 e1 fb	 and	 ecx, -5			; fffffffbH
  0008e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00091	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 182  : 	lpObj->m_ActState.Rest			= 0;

  00097	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009a	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  000a0	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000a3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a6	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 183  : 	lpObj->m_ActState.Emotion		= 0;

  000ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000af	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  000b5	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  000bb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000be	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 184  : 	lpObj->TargetNumber				= -1;

  000c4	83 c8 ff	 or	 eax, -1
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ca	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 185  : 	lpObj->NextActionTime			= 5000;

  000d1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d4	c7 80 18 02 00
	00 88 13 00 00	 mov	 DWORD PTR [eax+536], 5000 ; 00001388H

; 186  : 		
; 187  : 	if( lpObj->Class == 43 )

  000de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000e8	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  000eb	0f 85 01 01 00
	00		 jne	 $LN2@gObjMonste

; 188  : 	{
; 189  : 		lpObj->MapNumber = map[rand()%3];

  000f1	e8 00 00 00 00	 call	 _rand
  000f6	99		 cdq
  000f7	b9 03 00 00 00	 mov	 ecx, 3
  000fc	f7 f9		 idiv	 ecx
  000fe	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00101	8a 4c 95 f0	 mov	 cl, BYTE PTR _map$[ebp+edx*4]
  00105	88 88 09 01 00
	00		 mov	 BYTE PTR [eax+265], cl

; 190  : 
; 191  : 		if( !gMSetBase.GetBoxPosition(lpObj->MapNumber, 10, 10, 240, 240, lpObj->X, lpObj->Y) )

  0010b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010e	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00113	50		 push	 eax
  00114	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00117	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  0011d	51		 push	 ecx
  0011e	68 f0 00 00 00	 push	 240			; 000000f0H
  00123	68 f0 00 00 00	 push	 240			; 000000f0H
  00128	6a 0a		 push	 10			; 0000000aH
  0012a	6a 0a		 push	 10			; 0000000aH
  0012c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0012f	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00136	50		 push	 eax
  00137	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  0013c	e8 00 00 00 00	 call	 ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition
  00141	85 c0		 test	 eax, eax
  00143	75 34		 jne	 SHORT $LN4@gObjMonste

; 192  : 		{
; 193  : 			lpObj->Live	   = 0;

  00145	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00148	c6 40 66 00	 mov	 BYTE PTR [eax+102], 0

; 194  : 			lpObj->m_State   = OBJST_DYING;	

  0014c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014f	c7 80 b8 01 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+440], 4

; 195  : 			lpObj->RegenTime = GetTickCount();

  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0015f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00162	89 81 04 02 00
	00		 mov	 DWORD PTR [ecx+516], eax

; 196  : 			lpObj->DieRegen  = 1;			

  00168	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016b	c6 80 fe 01 00
	00 01		 mov	 BYTE PTR [eax+510], 1

; 197  : 			return FALSE;

  00172	33 c0		 xor	 eax, eax
  00174	e9 9e 02 00 00	 jmp	 $LN1@gObjMonste
$LN4@gObjMonste:

; 198  : 		}
; 199  : 		
; 200  : 		lpObj->TX = lpObj->X;

  00179	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0017f	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  00186	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 201  : 		lpObj->TY = lpObj->Y;

  0018d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00193	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  0019a	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 202  : 		lpObj->MTX = lpObj->X;

  001a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a7	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  001ae	66 89 90 24 01
	00 00		 mov	 WORD PTR [eax+292], dx

; 203  : 		lpObj->MTY = lpObj->Y;

  001b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001bb	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  001c2	66 89 90 26 01
	00 00		 mov	 WORD PTR [eax+294], dx

; 204  : 		lpObj->StartX = (BYTE)lpObj->X;

  001c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001cc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001cf	8a 91 04 01 00
	00		 mov	 dl, BYTE PTR [ecx+260]
  001d5	88 90 1a 01 00
	00		 mov	 BYTE PTR [eax+282], dl

; 205  : 		lpObj->StartY = (BYTE)lpObj->Y;

  001db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001de	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e1	8a 91 06 01 00
	00		 mov	 dl, BYTE PTR [ecx+262]
  001e7	88 90 1b 01 00
	00		 mov	 BYTE PTR [eax+283], dl

; 206  : 	}

  001ed	e9 14 02 00 00	 jmp	 $LN3@gObjMonste
$LN2@gObjMonste:

; 207  : 	else if( lpObj->Class == 44 )

  001f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f5	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001fc	83 f9 2c	 cmp	 ecx, 44			; 0000002cH
  001ff	75 05		 jne	 SHORT $LN5@gObjMonste

; 208  : 	{
; 209  : 	}

  00201	e9 00 02 00 00	 jmp	 $LN3@gObjMonste
$LN5@gObjMonste:

; 210  : 	else if( lpObj->Class == 53 || lpObj->Class == 54 ||
; 211  : 			 lpObj->Class == 55 || lpObj->Class == 56)

  00206	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00209	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00210	83 f9 35	 cmp	 ecx, 53			; 00000035H
  00213	74 2d		 je	 SHORT $LN9@gObjMonste
  00215	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00218	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0021f	83 f9 36	 cmp	 ecx, 54			; 00000036H
  00222	74 1e		 je	 SHORT $LN9@gObjMonste
  00224	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00227	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0022e	83 f9 37	 cmp	 ecx, 55			; 00000037H
  00231	74 0f		 je	 SHORT $LN9@gObjMonste
  00233	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00236	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0023d	83 f9 38	 cmp	 ecx, 56			; 00000038H
  00240	75 0c		 jne	 SHORT $LN7@gObjMonste
$LN9@gObjMonste:

; 212  : 	{
; 213  : 		/* /* (수정해라)
; 214  : 		lpObj->Live	   = 0;
; 215  : 		lpObj->m_State   = OBJST_DYING;	
; 216  : 		lpObj->RegenTime = GetTickCount();
; 217  : 		lpObj->DieRegen  = 1;			
; 218  : 		*/
; 219  : 		return FALSE;

  00242	33 c0		 xor	 eax, eax
  00244	e9 ce 01 00 00	 jmp	 $LN1@gObjMonste

; 220  : 	}

  00249	e9 b8 01 00 00	 jmp	 $LN3@gObjMonste
$LN7@gObjMonste:

; 221  : 	else if( lpObj->Class >= 78 && lpObj->Class <= 83 )

  0024e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00251	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00258	83 f9 4e	 cmp	 ecx, 78			; 0000004eH
  0025b	7c 1b		 jl	 SHORT $LN10@gObjMonste
  0025d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00260	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00267	83 f9 53	 cmp	 ecx, 83			; 00000053H
  0026a	7f 0c		 jg	 SHORT $LN10@gObjMonste

; 222  : 	{	// 이벤트 몬스터는 부활시키지 않는다		
; 223  : 		/*/* (수정해라)
; 224  : 		lpObj->Live	   = 0;
; 225  : 		lpObj->m_State   = OBJST_DYING;	
; 226  : 		lpObj->RegenTime = GetTickCount();
; 227  : 		lpObj->DieRegen  = 1;			
; 228  : 		*/
; 229  : 		return FALSE;		

  0026c	33 c0		 xor	 eax, eax
  0026e	e9 a4 01 00 00	 jmp	 $LN1@gObjMonste

; 230  : 	}

  00273	e9 8e 01 00 00	 jmp	 $LN3@gObjMonste
$LN10@gObjMonste:

; 231  : #ifdef ADD_GOLDEN_EVENT_RENEWAL_20090311	
; 232  : 	else if( lpObj->Class >= 493 && lpObj->Class <= 502 )
; 233  : 	{	// 이벤트 몬스터는 부활시키지 않는다		
; 234  : 		
; 235  : 		return FALSE;		
; 236  : 	}
; 237  : #endif //ADD_GOLDEN_EVENT_RENEWAL_20090311
; 238  : #ifdef BUGFIX_KALIMAGATE_VANISHING_20041006
; 239  : 	else if( CHECK_KALIMAGATE(lpObj->m_Attribute) ) {

  00278	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0027b	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  00282	83 f9 33	 cmp	 ecx, 51			; 00000033H
  00285	7d 09		 jge	 SHORT $LN18@gObjMonste
  00287	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv197[ebp], 0
  0028e	eb 25		 jmp	 SHORT $LN19@gObjMonste
$LN18@gObjMonste:
  00290	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00293	0f bf 82 fe 02
	00 00		 movsx	 eax, WORD PTR [edx+766]
  0029a	83 f8 38	 cmp	 eax, 56			; 00000038H
  0029d	7e 09		 jle	 SHORT $LN16@gObjMonste
  0029f	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv196[ebp], 0
  002a6	eb 07		 jmp	 SHORT $LN17@gObjMonste
$LN16@gObjMonste:
  002a8	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv196[ebp], 1
$LN17@gObjMonste:
  002af	8b 4d a8	 mov	 ecx, DWORD PTR tv196[ebp]
  002b2	89 4d ac	 mov	 DWORD PTR tv197[ebp], ecx
$LN19@gObjMonste:
  002b5	83 7d ac 00	 cmp	 DWORD PTR tv197[ebp], 0
  002b9	74 68		 je	 SHORT $LN12@gObjMonste

; 240  : 		// 혹시라도 이곳에 들어오면 리젠값을 수정한다. (마석은 여기에 들어올 이유가 없다.)
; 241  : 		lpObj->Live			= 1;

  002bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002be	c6 40 66 01	 mov	 BYTE PTR [eax+102], 1

; 242  : 		lpObj->DieRegen		= 0;

  002c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c5	c6 80 fe 01 00
	00 00		 mov	 BYTE PTR [eax+510], 0

; 243  : 		CreateFrustrum(lpObj->X,lpObj->Y, lpObj->m_Index);

  002cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d1	51		 push	 ecx
  002d2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002d5	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  002dc	50		 push	 eax
  002dd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002e0	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  002e7	52		 push	 edx
  002e8	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  002ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 244  : 		gObjClearViewport(lpObj);

  002f0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f3	50		 push	 eax
  002f4	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  002f9	83 c4 04	 add	 esp, 4

; 245  : 		gObjViewportListCreate(lpObj->m_Index);

  002fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ff	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00302	51		 push	 ecx
  00303	e8 00 00 00 00	 call	 ?gObjViewportListCreate@@YAXF@Z ; gObjViewportListCreate
  00308	83 c4 04	 add	 esp, 4

; 246  : 		gObjViewportListProtocolCreate(lpObj);

  0030b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030e	50		 push	 eax
  0030f	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00314	83 c4 04	 add	 esp, 4

; 247  : 		return FALSE;

  00317	33 c0		 xor	 eax, eax
  00319	e9 f9 00 00 00	 jmp	 $LN1@gObjMonste

; 248  : 	}

  0031e	e9 e3 00 00 00	 jmp	 $LN3@gObjMonste
$LN12@gObjMonste:

; 249  : #endif
; 250  : #ifdef ADD_RAKLION_20080408
; 251  : 	else if( lpObj->Class == 460 || lpObj->Class == 461 || lpObj->Class == 462 )
; 252  : 	{
; 253  : 		// 라클리온 거미알은 이곳에서 부활시키지 않는다		
; 254  : 		if( g_Raklion.GetRaklionState() != RAKLION_STATE_END )
; 255  : 			return FALSE;
; 256  : 	}
; 257  : 	else if( lpObj->Class == 459 )
; 258  : 	{
; 259  : 		// 라클리온 보스는 이곳에서 부활 시키지 않는다
; 260  : 		if( g_Raklion.GetRaklionState() != RAKLION_STATE_STANDBY
; 261  : 			|| g_Raklion.GetRaklionState() != RAKLION_STATE_READY )
; 262  : 			return FALSE;
; 263  : 	}
; 264  : #ifdef MODIFY_RAKLION_COOLUTIN_AND_IRON_KNIGHT_REGEN_BUGFIX_20080828
; 265  : 	else if( lpObj->Class == RAKLION_COOLUTIN && lpObj->MapNumber==MAP_INDEX_RAKLION_BOSS
; 266  : 			|| lpObj->Class == RAKLION_IRON_KNIGHT && lpObj->MapNumber==MAP_INDEX_RAKLION_BOSS
; 267  : 			)
; 268  : 	{
; 269  : 		// 라클리온 보스가 소환한 몬스터는 여기서 부활 시키지 않는다
; 270  : 		return FALSE;
; 271  : 	}
; 272  : #else
; 273  : 	else if( lpObj->Class == RAKLION_COOLUTIN || lpObj->Class == RAKLION_IRON_KNIGHT )
; 274  : 	{
; 275  : 		// 라클리온 보스가 소환한 몬스터는 여기서 부활 시키지 않는다
; 276  : 		if( lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS )
; 277  : 			return FALSE;
; 278  : 	}
; 279  : #endif // MODIFY_RAKLION_COOLUTIN_AND_IRON_KNIGHT_REGEN_BUGFIX_20080828
; 280  : #endif // ADD_RAKLION_20080408
; 281  : 	else 
; 282  : 	{
; 283  : 		if( !gMSetBase.GetPosition(lpObj->m_PosNum, lpObj->MapNumber, lpObj->X, lpObj->Y) )

  00323	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00326	05 06 01 00 00	 add	 eax, 262		; 00000106H
  0032b	50		 push	 eax
  0032c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0032f	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00335	51		 push	 ecx
  00336	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00339	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  00341	0f b7 c8	 movzx	 ecx, ax
  00344	51		 push	 ecx
  00345	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00348	0f bf 82 0c 02
	00 00		 movsx	 eax, WORD PTR [edx+524]
  0034f	50		 push	 eax
  00350	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  00355	e8 00 00 00 00	 call	 ?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z ; CMonsterSetBase::GetPosition
  0035a	85 c0		 test	 eax, eax
  0035c	75 34		 jne	 SHORT $LN14@gObjMonste

; 284  : 		{
; 285  : #ifdef CASTLEDEEP_EVENT_20050413
; 286  : 			if (lpObj->m_Attribute == MON_ATTR_CASTLEDEEP) {
; 287  : 				// 로랜협곡 몬스터는 자신의 마지막위치 주변에 랜덤하게 출현시킨다.
; 288  : 				BYTE btX, btY;
; 289  : 				btX = lpObj->X;
; 290  : 				btY = lpObj->Y;
; 291  : 				if (gObjGetRandomFreeLocation(lpObj->MapNumber, btX, btY, 5, 5, 30) == FALSE) {
; 292  : 					return FALSE;
; 293  : 				}
; 294  : 				lpObj->X = btX;
; 295  : 				lpObj->Y = btY;
; 296  : 			}
; 297  : 			else {
; 298  : #endif
; 299  : 			lpObj->Live	   = 0;

  0035e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00361	c6 40 66 00	 mov	 BYTE PTR [eax+102], 0

; 300  : 			lpObj->m_State   = OBJST_DYING;	

  00365	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00368	c7 80 b8 01 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+440], 4

; 301  : 			lpObj->RegenTime = GetTickCount();

  00372	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00378	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0037b	89 81 04 02 00
	00		 mov	 DWORD PTR [ecx+516], eax

; 302  : 			lpObj->DieRegen  = 1;			

  00381	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00384	c6 80 fe 01 00
	00 01		 mov	 BYTE PTR [eax+510], 1

; 303  : 			return FALSE;

  0038b	33 c0		 xor	 eax, eax
  0038d	e9 85 00 00 00	 jmp	 $LN1@gObjMonste
$LN14@gObjMonste:

; 304  : #ifdef CASTLEDEEP_EVENT_20050413
; 305  : 			}
; 306  : #endif
; 307  : 		}
; 308  : 
; 309  : 		lpObj->MTX		= lpObj->X;

  00392	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00395	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00398	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  0039f	66 89 90 24 01
	00 00		 mov	 WORD PTR [eax+292], dx

; 310  : 		lpObj->MTY		= lpObj->Y;

  003a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003ac	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  003b3	66 89 90 26 01
	00 00		 mov	 WORD PTR [eax+294], dx

; 311  : 		lpObj->TX		= lpObj->X;

  003ba	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003bd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003c0	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  003c7	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 312  : 		lpObj->TY		= lpObj->Y;

  003ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003d4	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  003db	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 313  : 		lpObj->StartX	= (BYTE)lpObj->X;

  003e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003e8	8a 91 04 01 00
	00		 mov	 dl, BYTE PTR [ecx+260]
  003ee	88 90 1a 01 00
	00		 mov	 BYTE PTR [eax+282], dl

; 314  : 		lpObj->StartY	= (BYTE)lpObj->Y;

  003f4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003fa	8a 91 06 01 00
	00		 mov	 dl, BYTE PTR [ecx+262]
  00400	88 90 1b 01 00
	00		 mov	 BYTE PTR [eax+283], dl
$LN3@gObjMonste:

; 315  : 	}	
; 316  : 	gObjMonsterHitDamageInit(lpObj);

  00406	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00409	50		 push	 eax
  0040a	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageInit@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit
  0040f	83 c4 04	 add	 esp, 4

; 317  : 
; 318  : #ifdef MU_CRYWOLF_BENEFIT_20051215
; 319  : 	if( lpObj->MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE 
; 320  : 		&& g_CrywolfSync.GetCrywolfState() >= CRYWOLF_STATE_NOTIFY_2
; 321  : 		&& g_CrywolfSync.GetCrywolfState() <= CRYWOLF_STATE_END			)
; 322  : 	{
; 323  : 		// MVP 몹은 체력 하락이 적용되지 않는다.
; 324  : 	}
; 325  : 	else
; 326  : 	{
; 327  : 		// MVP 성공 : 몬스터 체력 감소
; 328  : 		if( g_CrywolfSync.GetOccupationState() == CRYWOLF_OCCUPATION_STATE_PEACE 
; 329  : 			&& g_iCrywolfApplyMvpBenefit	
; 330  : 		  )
; 331  : 		{
; 332  : 			
; 333  : #ifdef MODIFY_CRYWOLF_BENEFIT_01_20060315
; 334  : 			lpObj->Life		= lpObj->m_iScriptMaxLife	* g_CrywolfSync.GetMonHPBenefitRate() / 100;
; 335  : 			lpObj->MaxLife	= lpObj->m_iScriptMaxLife	* g_CrywolfSync.GetMonHPBenefitRate() / 100;
; 336  : #else
; 337  : 			lpObj->Life		= lpObj->Life				* g_CrywolfSync.GetMonHPBenefitRate() / 100;
; 338  : #endif // MODIFY_CRYWOLF_BENEFIT_01_20060315
; 339  : 
; 340  : #if TESTSERVER == 1
; 341  : 			LogAddTD( "★☆ 크라이울프 몬스터 혜택 적용 (%d)[%s] : %f / %f / %d", 
; 342  : 				lpObj->m_Index, lpObj->Name, lpObj->Life, lpObj->MaxLife, lpObj->m_iScriptMaxLife );
; 343  : #endif // TESTSERVER == 1
; 344  : 	
; 345  : 		}
; 346  : 	}
; 347  : #endif // MU_CRYWOLF_BENEFIT_20051215
; 348  : 
; 349  : 
; 350  : 	return TRUE;

  00412	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjMonste:

; 351  : 	//gObjViewportListProtocolCreate(lpObj);
; 352  : }

  00417	5f		 pop	 edi
  00418	5e		 pop	 esi
  00419	5b		 pop	 ebx
  0041a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041d	33 cd		 xor	 ecx, ebp
  0041f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00424	8b e5		 mov	 esp, ebp
  00426	5d		 pop	 ebp
  00427	c3		 ret	 0
?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjMonsterRegen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterStateProc@@YAXPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
tv678 = -132						; size = 4
tv662 = -132						; size = 4
tv361 = -132						; size = 4
tv269 = -132						; size = 4
tv150 = -132						; size = 4
tv679 = -128						; size = 4
tv663 = -128						; size = 4
tv362 = -128						; size = 4
tv270 = -128						; size = 4
tv151 = -128						; size = 4
tv67 = -128						; size = 4
_pMsg$1 = -60						; size = 14
_centerlife$2 = -44					; size = 4
_attackRange$3 = -40					; size = 4
_dis$4 = -36						; size = 4
_map$5 = -32						; size = 4
_tuser$6 = -28						; size = 4
_wall$7 = -21						; size = 1
_attackRange$8 = -20					; size = 4
_dis$9 = -16						; size = 4
_attr$10 = -9						; size = 1
_map$11 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
?gObjMonsterStateProc@@YAXPAVOBJECTSTRUCT@@HH@Z PROC	; gObjMonsterStateProc, COMDAT

; 988  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 989  : #ifdef ADD_NEW_MAP_KALIMA_20040518
; 990  : 	if (lpObj->m_iMonsterBattleDelay > 0) {

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	0f be 88 25 02
	00 00		 movsx	 ecx, BYTE PTR [eax+549]
  00020	85 c9		 test	 ecx, ecx
  00022	7e 05		 jle	 SHORT $LN4@gObjMonste

; 991  : 		// 머뭇거리는 동안은 아무 행동도 하지 않는다.
; 992  : 		return;

  00024	e9 e5 0c 00 00	 jmp	 $LN1@gObjMonste
$LN4@gObjMonste:

; 993  : 	}
; 994  : #endif
; 995  : 
; 996  : 	switch( aMsgCode )

  00029	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  0002c	89 45 80	 mov	 DWORD PTR tv67[ebp], eax
  0002f	83 7d 80 07	 cmp	 DWORD PTR tv67[ebp], 7
  00033	0f 87 d5 0c 00
	00		 ja	 $LN2@gObjMonste
  00039	8b 4d 80	 mov	 ecx, DWORD PTR tv67[ebp]
  0003c	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN92@gObjMonste[ecx*4]
$LN5@gObjMonste:

; 997  : 	{
; 998  : 	case 0 :	// 공격당했다.
; 999  : 		if( lpObj->m_Attribute == 0 ) return;	// 공격당하기만 하는 캐릭터라면..

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  0004d	85 c9		 test	 ecx, ecx
  0004f	75 05		 jne	 SHORT $LN6@gObjMonste
  00051	e9 b8 0c 00 00	 jmp	 $LN1@gObjMonste
$LN6@gObjMonste:

; 1000 : 		
; 1001 : 		if( gObj[aIndex].Live == 0 ||

  00056	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00063	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  00068	85 d2		 test	 edx, edx
  0006a	74 17		 je	 SHORT $LN8@gObjMonste
  0006c	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00079	83 bc 01 b8 01
	00 00 02	 cmp	 DWORD PTR [ecx+eax+440], 2
  00081	74 05		 je	 SHORT $LN7@gObjMonste
$LN8@gObjMonste:

; 1002 : 			gObj[aIndex].m_State != OBJST_PLAYING ) return;	// 상대가 죽어있다면..

  00083	e9 86 0c 00 00	 jmp	 $LN1@gObjMonste
$LN7@gObjMonste:

; 1003 : 
; 1004 : 		if( lpObj->m_ActState.Emotion == 0 ) 

  00088	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008b	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00091	c1 e9 04	 shr	 ecx, 4
  00094	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00097	75 3b		 jne	 SHORT $LN9@gObjMonste

; 1005 : 		{
; 1006 : 			lpObj->m_ActState.Emotion = 1;

  00099	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009c	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  000a2	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  000a8	83 c9 10	 or	 ecx, 16			; 00000010H
  000ab	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ae	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1007 : 			lpObj->m_ActState.EmotionCount = 10;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b7	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  000bd	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  000c3	81 c9 00 0a 00
	00		 or	 ecx, 2560		; 00000a00H
  000c9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000cc	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1008 : 		}

  000d2	eb 32		 jmp	 SHORT $LN11@gObjMonste
$LN9@gObjMonste:

; 1009 : 		else if( lpObj->m_ActState.Emotion == 1 ) 

  000d4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d7	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  000dd	c1 e9 04	 shr	 ecx, 4
  000e0	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000e3	83 f9 01	 cmp	 ecx, 1
  000e6	75 1e		 jne	 SHORT $LN11@gObjMonste

; 1010 : 		{
; 1011 : 			lpObj->m_ActState.EmotionCount = 10;

  000e8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000eb	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  000f1	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  000f7	81 c9 00 0a 00
	00		 or	 ecx, 2560		; 00000a00H
  000fd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00100	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN11@gObjMonste:

; 1012 : 		}
; 1013 : 		if( !lpObj->m_ActState.Attack && lpObj->PathStartEnd == 0 )	// 공격중이아니면..

  00106	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00109	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0010f	d1 e9		 shr	 ecx, 1
  00111	83 e1 01	 and	 ecx, 1
  00114	0f 85 95 02 00
	00		 jne	 $LN12@gObjMonste
  0011a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011d	0f be 88 30 01
	00 00		 movsx	 ecx, BYTE PTR [eax+304]
  00124	85 c9		 test	 ecx, ecx
  00126	0f 85 83 02 00
	00		 jne	 $LN12@gObjMonste

; 1014 : 		{			
; 1015 : 			if( CHECK_LIMIT(aIndex, MAX_OBJECT ) )

  0012c	83 7d 10 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00130	7d 09		 jge	 SHORT $LN74@gObjMonste
  00132	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv151[ebp], 0
  00139	eb 28		 jmp	 SHORT $LN75@gObjMonste
$LN74@gObjMonste:
  0013b	81 7d 10 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00142	7e 0c		 jle	 SHORT $LN72@gObjMonste
  00144	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv150[ebp], 0
  0014e	eb 0a		 jmp	 SHORT $LN73@gObjMonste
$LN72@gObjMonste:
  00150	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv150[ebp], 1
$LN73@gObjMonste:
  0015a	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv150[ebp]
  00160	89 45 80	 mov	 DWORD PTR tv151[ebp], eax
$LN75@gObjMonste:
  00163	83 7d 80 00	 cmp	 DWORD PTR tv151[ebp], 0
  00167	0f 84 3d 02 00
	00		 je	 $LN35@gObjMonste

; 1016 : 			{
; 1017 : 				//int tuser = lpObj->TargetNumber;
; 1018 : 				int map = gObj[aIndex].MapNumber;

  0016d	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017a	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00182	89 55 f8	 mov	 DWORD PTR _map$11[ebp], edx

; 1019 : 				BYTE attr ;
; 1020 : 
; 1021 : 				int dis = gObjCalDistance(lpObj, &gObj[aIndex]);

  00185	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0018c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00192	50		 push	 eax
  00193	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00196	51		 push	 ecx
  00197	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0019c	83 c4 08	 add	 esp, 8
  0019f	89 45 f0	 mov	 DWORD PTR _dis$9[ebp], eax

; 1022 : 				int attackRange;
; 1023 : 
; 1024 : 				if( lpObj->m_AttackType >= 100 )

  001a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a5	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  001ac	83 f9 64	 cmp	 ecx, 100		; 00000064H
  001af	7c 12		 jl	 SHORT $LN15@gObjMonste

; 1025 : 				{
; 1026 : 					attackRange = lpObj->m_AttackRange+2;

  001b1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b4	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  001bb	83 c1 02	 add	 ecx, 2
  001be	89 4d ec	 mov	 DWORD PTR _attackRange$8[ebp], ecx

; 1027 : 				}

  001c1	eb 0d		 jmp	 SHORT $LN16@gObjMonste
$LN15@gObjMonste:

; 1028 : 				else attackRange = lpObj->m_AttackRange;

  001c3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c6	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  001cd	89 4d ec	 mov	 DWORD PTR _attackRange$8[ebp], ecx
$LN16@gObjMonste:

; 1029 : 
; 1030 : 				if( dis <= attackRange )

  001d0	8b 45 f0	 mov	 eax, DWORD PTR _dis$9[ebp]
  001d3	3b 45 ec	 cmp	 eax, DWORD PTR _attackRange$8[ebp]
  001d6	0f 8f b2 00 00
	00		 jg	 $LN17@gObjMonste

; 1031 : 				{
; 1032 : 					if( gObj[aIndex].m_RecallMon >= 0 )

  001dc	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e9	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  001f1	7c 43		 jl	 SHORT $LN19@gObjMonste

; 1033 : 					{						
; 1034 : 						if( lpObj->m_RecallMon >= 0 )

  001f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f6	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  001fd	7c 27		 jl	 SHORT $LN21@gObjMonste

; 1035 : 						{
; 1036 : 							// 소환몬스터일 경우 몬스터만 공격 가능
; 1037 : 							if( gObj[aIndex].Type == OBJTYPE_MONSTER)

  001ff	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00206	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0020c	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00211	83 fa 02	 cmp	 edx, 2
  00214	75 0e		 jne	 SHORT $LN23@gObjMonste

; 1038 : 							{
; 1039 : 								lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고

  00216	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00219	66 8b 4d 10	 mov	 cx, WORD PTR _aIndex$[ebp]
  0021d	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx
$LN23@gObjMonste:

; 1040 : 							}
; 1041 : 						}

  00224	eb 0e		 jmp	 SHORT $LN22@gObjMonste
$LN21@gObjMonste:

; 1042 : 						else
; 1043 : 						{
; 1044 : 							lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고

  00226	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00229	66 8b 4d 10	 mov	 cx, WORD PTR _aIndex$[ebp]
  0022d	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx
$LN22@gObjMonste:

; 1045 : 						}
; 1046 : 					}

  00234	eb 53		 jmp	 SHORT $LN26@gObjMonste
$LN19@gObjMonste:

; 1047 : 					else {
; 1048 : #ifdef MONSTER_HERD_SYSTEM_20031120
; 1049 : 						if( rand()%100 < 90 )				// 몬스터가 공격에 증각 반응

  00236	e8 00 00 00 00	 call	 _rand
  0023b	99		 cdq
  0023c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00241	f7 f9		 idiv	 ecx
  00243	83 fa 5a	 cmp	 edx, 90			; 0000005aH
  00246	7d 41		 jge	 SHORT $LN26@gObjMonste

; 1050 : 						{
; 1051 : 							
; 1052 : 							if( lpObj->m_RecallMon >= 0 )

  00248	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0024b	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00252	7c 27		 jl	 SHORT $LN25@gObjMonste

; 1053 : 							{
; 1054 : 								// 소환몬스터일 경우 몬스터만 공격 가능
; 1055 : 								if( gObj[aIndex].Type == OBJTYPE_MONSTER)

  00254	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00261	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00266	83 fa 02	 cmp	 edx, 2
  00269	75 0e		 jne	 SHORT $LN27@gObjMonste

; 1056 : 								{
; 1057 : 									lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고

  0026b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026e	66 8b 4d 10	 mov	 cx, WORD PTR _aIndex$[ebp]
  00272	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx
$LN27@gObjMonste:

; 1058 : 								}
; 1059 : 							}

  00279	eb 0e		 jmp	 SHORT $LN26@gObjMonste
$LN25@gObjMonste:

; 1060 : 							else
; 1061 : 							{
; 1062 : 								lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고

  0027b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0027e	66 8b 4d 10	 mov	 cx, WORD PTR _aIndex$[ebp]
  00282	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx
$LN26@gObjMonste:

; 1063 : 							}
; 1064 : 						}
; 1065 : #else
; 1066 : 						if( (rand()%3) == 0 )
; 1067 : 						{
; 1068 : 							
; 1069 : 							if( lpObj->m_RecallMon >= 0 )
; 1070 : 							{
; 1071 : 								// 소환몬스터일 경우 몬스터만 공격 가능
; 1072 : 								if( gObj[aIndex].Type == OBJTYPE_MONSTER)
; 1073 : 								{
; 1074 : 									lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고
; 1075 : 								}
; 1076 : 							}
; 1077 : 							else
; 1078 : 							{
; 1079 : 								lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고
; 1080 : 							}
; 1081 : 						}
; 1082 : #endif
; 1083 : 	
; 1084 : 					}
; 1085 : 				}

  00289	e9 ca 00 00 00	 jmp	 $LN32@gObjMonste
$LN17@gObjMonste:

; 1086 : 				// 벽이 있다면 공격을 안한다.
; 1087 : 				else 
; 1088 : 				{
; 1089 : 					BYTE wall=0;

  0028e	c6 45 eb 00	 mov	 BYTE PTR _wall$7[ebp], 0

; 1090 : 					wall = MapC[map].CheckWall2(lpObj->X, lpObj->Y, gObj[aIndex].X, gObj[aIndex].Y);

  00292	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0029f	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  002a7	52		 push	 edx
  002a8	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b5	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  002bd	52		 push	 edx
  002be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c1	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  002c8	51		 push	 ecx
  002c9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002cc	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  002d3	50		 push	 eax
  002d4	69 4d f8 8c 04
	05 00		 imul	 ecx, DWORD PTR _map$11[ebp], 328844
  002db	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  002e1	e8 00 00 00 00	 call	 ?CheckWall2@MapClass@@QAEEHHHH@Z ; MapClass::CheckWall2
  002e6	88 45 eb	 mov	 BYTE PTR _wall$7[ebp], al

; 1091 : 
; 1092 : 					if( wall == 0x01 )

  002e9	0f b6 45 eb	 movzx	 eax, BYTE PTR _wall$7[ebp]
  002ed	83 f8 01	 cmp	 eax, 1
  002f0	75 66		 jne	 SHORT $LN28@gObjMonste

; 1093 : 					{
; 1094 : 						attr = MapC[map].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);

  002f2	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ff	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  00307	52		 push	 edx
  00308	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0030f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00315	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  0031d	52		 push	 edx
  0031e	69 4d f8 8c 04
	05 00		 imul	 ecx, DWORD PTR _map$11[ebp], 328844
  00325	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0032b	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00330	88 45 f7	 mov	 BYTE PTR _attr$10[ebp], al

; 1095 : 						if( (attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE)

  00333	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$10[ebp]
  00337	83 e0 01	 and	 eax, 1
  0033a	75 1c		 jne	 SHORT $LN31@gObjMonste

; 1096 : 						{
; 1097 : 							if( lpObj->TargetNumber < 0 ) // 공격상대가 없다면..

  0033c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033f	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00346	85 c9		 test	 ecx, ecx
  00348	7d 0e		 jge	 SHORT $LN31@gObjMonste

; 1098 : 							{
; 1099 : 								lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고

  0034a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034d	66 8b 4d 10	 mov	 cx, WORD PTR _aIndex$[ebp]
  00351	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx
$LN31@gObjMonste:
$LN28@gObjMonste:
$LN32@gObjMonste:

; 1100 : 							}
; 1101 : 						}
; 1102 : 					}
; 1103 : 					else if( wall == 0x02 ) // 캐릭터가 앞에 있으면..
; 1104 : 					{
; 1105 : 					}
; 1106 : 					else {	// 벽이거나 중간에 막혀 있다면..
; 1107 : 						//lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고	
; 1108 : 					}
; 1109 : 				}
; 1110 : 
; 1111 : #ifdef MONSTER_HERD_SYSTEM_20031120
; 1112 : 				if (lpObj->m_bIsInMonsterHerd &&

  00358	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035b	83 b8 ec 0e 00
	00 00		 cmp	 DWORD PTR [eax+3820], 0
  00362	74 46		 je	 SHORT $LN35@gObjMonste
  00364	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00367	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0036e	3b 4d 10	 cmp	 ecx, DWORD PTR _aIndex$[ebp]
  00371	75 37		 jne	 SHORT $LN35@gObjMonste

; 1113 : 					lpObj->TargetNumber == aIndex
; 1114 : 					)
; 1115 : 				{
; 1116 : 					if (lpObj->m_lpMonsterHerd != NULL)

  00373	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00376	83 b8 f4 0e 00
	00 00		 cmp	 DWORD PTR [eax+3828], 0
  0037d	74 2b		 je	 SHORT $LN35@gObjMonste

; 1117 : 						lpObj->m_lpMonsterHerd->BeenAttacked (lpObj, &gObj[aIndex]);

  0037f	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00386	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0038c	50		 push	 eax
  0038d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00390	51		 push	 ecx
  00391	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00394	8b 82 f4 0e 00
	00		 mov	 eax, DWORD PTR [edx+3828]
  0039a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0039d	8b 10		 mov	 edx, DWORD PTR [eax]
  0039f	8b 89 f4 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3828]
  003a5	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  003a8	ff d0		 call	 eax
$LN35@gObjMonste:

; 1118 : 				}
; 1119 : #endif
; 1120 : 			}
; 1121 : 		}

  003aa	e9 fb 01 00 00	 jmp	 $LN45@gObjMonste
$LN12@gObjMonste:

; 1122 : 		else 
; 1123 : 		{	// 공격중일때는 계속 공격한다.. 어떤 넘은 상대를 바꾼다..
; 1124 : 			if( ((rand()%2) == 1) && lpObj->PathStartEnd == 0 )

  003af	e8 00 00 00 00	 call	 _rand
  003b4	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  003b9	79 05		 jns	 SHORT $LN93@gObjMonste
  003bb	48		 dec	 eax
  003bc	83 c8 fe	 or	 eax, -2			; fffffffeH
  003bf	40		 inc	 eax
$LN93@gObjMonste:
  003c0	83 f8 01	 cmp	 eax, 1
  003c3	0f 85 72 01 00
	00		 jne	 $LN36@gObjMonste
  003c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003cc	0f be 88 30 01
	00 00		 movsx	 ecx, BYTE PTR [eax+304]
  003d3	85 c9		 test	 ecx, ecx
  003d5	0f 85 60 01 00
	00		 jne	 $LN36@gObjMonste

; 1125 : 			{
; 1126 : 				int tuser = lpObj->TargetNumber;

  003db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003de	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  003e5	89 4d e4	 mov	 DWORD PTR _tuser$6[ebp], ecx

; 1127 : 				
; 1128 : 				if (!CHECK_LIMIT(tuser, MAX_OBJECT))		return;

  003e8	83 7d e4 00	 cmp	 DWORD PTR _tuser$6[ebp], 0
  003ec	7d 09		 jge	 SHORT $LN78@gObjMonste
  003ee	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv270[ebp], 0
  003f5	eb 28		 jmp	 SHORT $LN79@gObjMonste
$LN78@gObjMonste:
  003f7	81 7d e4 e7 1c
	00 00		 cmp	 DWORD PTR _tuser$6[ebp], 7399 ; 00001ce7H
  003fe	7e 0c		 jle	 SHORT $LN76@gObjMonste
  00400	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv269[ebp], 0
  0040a	eb 0a		 jmp	 SHORT $LN77@gObjMonste
$LN76@gObjMonste:
  0040c	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv269[ebp], 1
$LN77@gObjMonste:
  00416	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv269[ebp]
  0041c	89 45 80	 mov	 DWORD PTR tv270[ebp], eax
$LN79@gObjMonste:
  0041f	83 7d 80 00	 cmp	 DWORD PTR tv270[ebp], 0
  00423	75 05		 jne	 SHORT $LN38@gObjMonste
  00425	e9 e4 08 00 00	 jmp	 $LN1@gObjMonste
$LN38@gObjMonste:

; 1129 : 
; 1130 : 				int map = gObj[tuser].MapNumber;

  0042a	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tuser$6[ebp], 7072
  00431	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00437	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0043f	89 55 e0	 mov	 DWORD PTR _map$5[ebp], edx

; 1131 : 				// 벽이 있다면 공격을 안한다.
; 1132 : 
; 1133 : 				int dis = gObjCalDistance(lpObj, &gObj[aIndex]);

  00442	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00449	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0044f	50		 push	 eax
  00450	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00453	51		 push	 ecx
  00454	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00459	83 c4 08	 add	 esp, 8
  0045c	89 45 dc	 mov	 DWORD PTR _dis$4[ebp], eax

; 1134 : 				int attackRange;
; 1135 : 
; 1136 : 				if( lpObj->m_AttackType >= 100 )

  0045f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00462	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  00469	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0046c	7c 12		 jl	 SHORT $LN39@gObjMonste

; 1137 : 				{
; 1138 : 					attackRange = lpObj->m_AttackRange+2;

  0046e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00471	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  00478	83 c1 02	 add	 ecx, 2
  0047b	89 4d d8	 mov	 DWORD PTR _attackRange$3[ebp], ecx

; 1139 : 				}

  0047e	eb 0d		 jmp	 SHORT $LN40@gObjMonste
$LN39@gObjMonste:

; 1140 : 				else attackRange = lpObj->m_AttackRange;

  00480	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00483	0f bf 88 f8 02
	00 00		 movsx	 ecx, WORD PTR [eax+760]
  0048a	89 4d d8	 mov	 DWORD PTR _attackRange$3[ebp], ecx
$LN40@gObjMonste:

; 1141 : 
; 1142 : 				if( dis <= attackRange )

  0048d	8b 45 dc	 mov	 eax, DWORD PTR _dis$4[ebp]
  00490	3b 45 d8	 cmp	 eax, DWORD PTR _attackRange$3[ebp]
  00493	7f 25		 jg	 SHORT $LN41@gObjMonste

; 1143 : 				{
; 1144 : 					lpObj->m_ActState.Attack = 1;

  00495	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00498	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0049e	83 c9 02	 or	 ecx, 2
  004a1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004a4	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1145 : 					lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고

  004aa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004ad	66 8b 4d 10	 mov	 cx, WORD PTR _aIndex$[ebp]
  004b1	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx

; 1146 : 				}

  004b8	eb 7f		 jmp	 SHORT $LN43@gObjMonste
$LN41@gObjMonste:

; 1147 : 				else if( MapC[map].CheckWall2(lpObj->X, lpObj->Y, gObj[tuser].X, gObj[tuser].Y) == TRUE )

  004ba	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tuser$6[ebp], 7072
  004c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004c7	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  004cf	52		 push	 edx
  004d0	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _tuser$6[ebp], 7072
  004d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004dd	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  004e5	52		 push	 edx
  004e6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e9	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  004f0	51		 push	 ecx
  004f1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004f4	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  004fb	50		 push	 eax
  004fc	69 4d e0 8c 04
	05 00		 imul	 ecx, DWORD PTR _map$5[ebp], 328844
  00503	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00509	e8 00 00 00 00	 call	 ?CheckWall2@MapClass@@QAEEHHHH@Z ; MapClass::CheckWall2
  0050e	0f b6 c8	 movzx	 ecx, al
  00511	83 f9 01	 cmp	 ecx, 1
  00514	75 23		 jne	 SHORT $LN43@gObjMonste

; 1148 : 				{
; 1149 : 					lpObj->m_ActState.Attack = 1;

  00516	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00519	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0051f	83 c9 02	 or	 ecx, 2
  00522	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00525	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1150 : 					lpObj->TargetNumber = aIndex;	// 공격상대로 지정하고

  0052b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0052e	66 8b 4d 10	 mov	 cx, WORD PTR _aIndex$[ebp]
  00532	66 89 88 ac 02
	00 00		 mov	 WORD PTR [eax+684], cx
$LN43@gObjMonste:

; 1151 : 				}
; 1152 : 			}

  00539	eb 6f		 jmp	 SHORT $LN45@gObjMonste
$LN36@gObjMonste:

; 1153 : 			else 
; 1154 : 			{
; 1155 : 				int centerlife = (int)(lpObj->MaxLife);	

  0053b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053e	f3 0f 2c 88 c0
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+192]
  00546	89 4d d4	 mov	 DWORD PTR _centerlife$2[ebp], ecx

; 1156 : 				centerlife >>= 1;	// maxlife/2

  00549	8b 45 d4	 mov	 eax, DWORD PTR _centerlife$2[ebp]
  0054c	d1 f8		 sar	 eax, 1
  0054e	89 45 d4	 mov	 DWORD PTR _centerlife$2[ebp], eax

; 1157 : 				if( lpObj->Life < centerlife )

  00551	f3 0f 2a 45 d4	 cvtsi2ss xmm0, DWORD PTR _centerlife$2[ebp]
  00556	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00559	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00560	76 48		 jbe	 SHORT $LN45@gObjMonste

; 1158 : 				{
; 1159 : 					if( lpObj->m_Attribute != 2 )	//

  00562	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00565	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  0056c	83 f9 02	 cmp	 ecx, 2
  0056f	74 39		 je	 SHORT $LN45@gObjMonste

; 1160 : 					{
; 1161 : 						lpObj->m_ActState.Emotion = 2;	// 도망간다.

  00571	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00574	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0057a	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00580	83 c9 20	 or	 ecx, 32			; 00000020H
  00583	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00586	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1162 : 						lpObj->m_ActState.EmotionCount = 2;

  0058c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0058f	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00595	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  0059b	81 c9 00 02 00
	00		 or	 ecx, 512		; 00000200H
  005a1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005a4	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN45@gObjMonste:

; 1163 : 					}
; 1164 : 				}
; 1165 : 			}
; 1166 : 		}
; 1167 : 		break;

  005aa	e9 5f 07 00 00	 jmp	 $LN2@gObjMonste
$LN46@gObjMonste:

; 1168 : 	case 1 :	// 내가(몬스터가) 죽었다
; 1169 : #ifdef CASTLE_MAIN_SCHEDULER_20041111		// 공성관련 NPC 들이 죽었을 경우 여기서 처리한다.
; 1170 : 		if (lpObj->m_btCsNpcType != CS_NPC_TYPE_NONE) {
; 1171 : 			switch (lpObj->m_btCsNpcType) {
; 1172 : 			case CS_NPC_TYPE_DB_DFN :		// 공성전 NPC - 수성측 DB
; 1173 : 				g_CastleSiege.DelNPC(lpObj->m_Index, lpObj->Class, lpObj->m_iCsNpcExistVal, TRUE);
; 1174 : 				break;
; 1175 : 			case CS_NPC_TYPE_INS_DFN :		// 공성전 NPC - 수성측
; 1176 : 				g_CastleSiege.DelNPC(lpObj->m_Index, lpObj->Class, lpObj->m_iCsNpcExistVal);
; 1177 : 				break;
; 1178 : 			case CS_NPC_TYPE_INS_ATK :		// 공성전 NPC - 공성측
; 1179 : 				g_CastleSiege.DelNPC(lpObj->m_Index, lpObj->Class, lpObj->m_iCsNpcExistVal);
; 1180 : 				break;
; 1181 : 			}
; 1182 : #ifdef ADD_NEW_MERCENARY_FOR_CASTLE_01_20041214		
; 1183 : 			if (lpObj->Class == NPC_INDEX_SPEARMAN || lpObj->Class == NPC_INDEX_BOWMAN) 
; 1184 : 			{
; 1185 : 				g_CsNPC_Mercenary.DeleteMercenary( lpObj->m_Index );
; 1186 : 			}
; 1187 : #endif
; 1188 : #ifdef CASTLE_NPC_LIFESTONE_WORK_20041208	// 2005.05.23 추가 (b4nfter)
; 1189 : 			if(lpObj->Class == NPC_INDEX_LIFESTONE)
; 1190 : 			{
; 1191 : 				g_CsNPC_LifeStone.DeleteLifeStone(lpObj->m_Index);
; 1192 : 			}
; 1193 : #endif
; 1194 : 			gObjDel(lpObj->m_Index);
; 1195 : 		}
; 1196 : #endif
; 1197 : 		
; 1198 : #ifdef HIDDEN_KALIMA_20050706				// 쿤둔의 잔영이 죽으면 그 자리에 마석을 소환한다.
; 1199 : 		if (CHECK_KALIMAMAP(lpObj->MapNumber)) {
; 1200 : 			if (
; 1201 : //			lpObj->Class == 147	||			// 테스트
; 1202 : //			lpObj->Class == 177 ||			// 테스트
; 1203 : //			lpObj->Class == 185 ||			// 테스트
; 1204 : //			lpObj->Class == 193 ||			// 테스트
; 1205 : //			lpObj->Class == 263				// 테스트
; 1206 : 			lpObj->Class == 161 ||			// 쿤둔의 잔영1
; 1207 : 			lpObj->Class == 181 || 			// 쿤둔의 잔영2
; 1208 : 			lpObj->Class == 189 || 			// 쿤둔의 잔영3
; 1209 : 			lpObj->Class == 197 || 			// 쿤둔의 잔영4
; 1210 : 			lpObj->Class == 267				// 쿤둔의 잔영5
; 1211 : 			)
; 1212 : 			{
; 1213 : 				g_KalimaGate.CreateKalimaGate2(aIndex, lpObj->MapNumber, lpObj->X, lpObj->Y);
; 1214 : 			}
; 1215 : 		}
; 1216 : #endif
; 1217 : 		
; 1218 : #ifdef MODIFY_QUEST_SYSTEM_20070525	// 퀘스트 완료요건이 몬스터Kill인지 확인한다.
; 1219 : 		// 퀘스트 몬스터를 이곳에 미리 등록한다.
; 1220 : 		// 차후 퀘스트가 늘어나면 다른 방법을 찾을것.
; 1221 : 		if( lpObj->Class == 409		// 발람(훈련병)
; 1222 : 			|| lpObj->Class == 410	// 데스스피릿(훈련병)
; 1223 : 			|| lpObj->Class == 411	// 소람(훈련병)
; 1224 : 			|| lpObj->Class == 412	// 다크엘프(훈련병) 
; 1225 : 			)
; 1226 : 		{
; 1227 : 			g_QuestInfo.CheckQuestMonsterKill( lpObj, &gObj[aIndex] );
; 1228 : 		}		
; 1229 : #endif
; 1230 : 
; 1231 : 		gObjMonsterDieGiveItem(lpObj, &gObj[aIndex]);

  005af	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005b6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005bc	50		 push	 eax
  005bd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005c0	51		 push	 ecx
  005c1	e8 00 00 00 00	 call	 ?gObjMonsterDieGiveItem@@YAXPAVOBJECTSTRUCT@@0@Z ; gObjMonsterDieGiveItem
  005c6	83 c4 08	 add	 esp, 8

; 1232 : 		lpObj->NextActionTime = 500;

  005c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005cc	c7 80 18 02 00
	00 f4 01 00 00	 mov	 DWORD PTR [eax+536], 500 ; 000001f4H

; 1233 : 		if( lpObj->m_RecallMon >= 0 )

  005d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d9	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  005e0	7c 12		 jl	 SHORT $LN47@gObjMonste

; 1234 : 		{
; 1235 : 			gObjMonsterCallKill(lpObj->m_RecallMon);

  005e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005e5	8b 88 a4 02 00
	00		 mov	 ecx, DWORD PTR [eax+676]
  005eb	51		 push	 ecx
  005ec	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  005f1	83 c4 04	 add	 esp, 4
$LN47@gObjMonste:

; 1236 : 		}
; 1237 : 
; 1238 : #ifdef FOR_BLOODCASTLE		// 2004.02.02 블러드캐슬 몬스터 수 버그 수정 - 몬스터 수 체크부분 (이 루틴에 추가 됨)
; 1239 : 		if( CHECK_BLOODCASTLE(lpObj->MapNumber) && lpObj->Type >= OBJTYPE_MONSTER )

  005f4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f7	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  005fe	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00601	7d 09		 jge	 SHORT $LN82@gObjMonste
  00603	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv362[ebp], 0
  0060a	eb 2e		 jmp	 SHORT $LN83@gObjMonste
$LN82@gObjMonste:
  0060c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0060f	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00616	83 f8 11	 cmp	 eax, 17			; 00000011H
  00619	7e 0c		 jle	 SHORT $LN80@gObjMonste
  0061b	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv361[ebp], 0
  00625	eb 0a		 jmp	 SHORT $LN81@gObjMonste
$LN80@gObjMonste:
  00627	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv361[ebp], 1
$LN81@gObjMonste:
  00631	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv361[ebp]
  00637	89 4d 80	 mov	 DWORD PTR tv362[ebp], ecx
$LN83@gObjMonste:
  0063a	83 7d 80 00	 cmp	 DWORD PTR tv362[ebp], 0
  0063e	0f 84 96 04 00
	00		 je	 $LN58@gObjMonste
  00644	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00647	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0064b	83 f9 02	 cmp	 ecx, 2
  0064e	0f 8c 86 04 00
	00		 jl	 $LN58@gObjMonste

; 1240 : 		{
; 1241 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 블러드캐슬 다리 인덱스 변경
; 1242 : 			int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( lpObj->MapNumber );
; 1243 : #endif			
; 1244 : 			if (
; 1245 : 				lpObj->Class == 89 ||		// 마법해골1
; 1246 : 				lpObj->Class == 95 ||		// 마법해골2
; 1247 : 				lpObj->Class == 112 ||		// 마법해골3
; 1248 : 				lpObj->Class == 118 ||		// 마법해골4
; 1249 : 				lpObj->Class == 124 ||		// 마법해골5
; 1250 : 				lpObj->Class == 130			// 마법해골6
; 1251 : #ifdef BLOODCASTLE_EXTEND_20040314			// 블러드캐슬 보스몹의 체크를 늘림 (몬스터 죽였을 때)
; 1252 : 				|| lpObj->Class == 143		// 마법해골7

  00654	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00657	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0065e	83 f9 59	 cmp	 ecx, 89			; 00000059H
  00661	74 60		 je	 SHORT $LN51@gObjMonste
  00663	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00666	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0066d	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  00670	74 51		 je	 SHORT $LN51@gObjMonste
  00672	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00675	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0067c	83 f9 70	 cmp	 ecx, 112		; 00000070H
  0067f	74 42		 je	 SHORT $LN51@gObjMonste
  00681	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00684	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0068b	83 f9 76	 cmp	 ecx, 118		; 00000076H
  0068e	74 33		 je	 SHORT $LN51@gObjMonste
  00690	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00693	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0069a	83 f9 7c	 cmp	 ecx, 124		; 0000007cH
  0069d	74 24		 je	 SHORT $LN51@gObjMonste
  0069f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006a2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006a9	81 f9 82 00 00
	00		 cmp	 ecx, 130		; 00000082H
  006af	74 12		 je	 SHORT $LN51@gObjMonste
  006b1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b4	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006bb	81 f9 8f 00 00
	00		 cmp	 ecx, 143		; 0000008fH
  006c1	75 37		 jne	 SHORT $LN49@gObjMonste
$LN51@gObjMonste:

; 1253 : #endif				
; 1254 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		// 블러드캐슬8 보스몹의 체크를 늘림 (몬스터 죽였을 때)
; 1255 : 				|| lpObj->Class == 433		// 마법해골8
; 1256 : #endif				
; 1257 : 				)
; 1258 : 			{
; 1259 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 블러드캐슬 다리 인덱스 변경				
; 1260 : 				g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT++;
; 1261 : #else
; 1262 : 				g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT++;

  006c3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006c6	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  006cd	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  006d0	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  006d6	8b 82 88 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+392]
  006dc	83 c0 01	 add	 eax, 1
  006df	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006e2	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  006e9	83 ea 0b	 sub	 edx, 11			; 0000000bH
  006ec	69 ca 04 02 00
	00		 imul	 ecx, edx, 516
  006f2	89 81 88 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+392], eax

; 1263 : #endif
; 1264 : 			}

  006f8	eb 35		 jmp	 SHORT $LN50@gObjMonste
$LN49@gObjMonste:

; 1265 : 			else {
; 1266 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 블러드캐슬 다리 인덱스 변경	
; 1267 : 				g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT++;
; 1268 : #else
; 1269 : 				g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_KILL_COUNT++;

  006fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006fd	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00704	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00707	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0070d	8b 82 78 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+376]
  00713	83 c0 01	 add	 eax, 1
  00716	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00719	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00720	83 ea 0b	 sub	 edx, 11			; 0000000bH
  00723	69 ca 04 02 00
	00		 imul	 ecx, edx, 516
  00729	89 81 78 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+376], eax
$LN50@gObjMonste:

; 1270 : 
; 1271 : #endif
; 1272 : 			}
; 1273 : 
; 1274 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 블러드캐슬 다리 인덱스 변경	
; 1275 : 			if (g_BloodCastle.CheckMonsterKillCount(iBridgeIndex)) {
; 1276 : 				// 1 . 일반몬스터 할당량 완료체크				
; 1277 : 				if (!g_BloodCastle.m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE) {
; 1278 : 					// 몬스터 할당량을 채웠다면 할당량이 완료되었음을 체크
; 1279 : 					g_BloodCastle.m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE = TRUE;
; 1280 : 					g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = -1;
; 1281 : 					// 사람들에게 다리가 내려왔음을 알림 -> 클라이언트는 다리 내려오는 속성
; 1282 : 					PMSG_STATEBLOODCASTLE pMsg;
; 1283 : 					PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(pMsg));
; 1284 : 					pMsg.btPlayState		= BC_STATE_MONSTEREND;
; 1285 : 					pMsg.wRemainSec			= 0;
; 1286 : 					pMsg.wMaxKillMonster	= 0;
; 1287 : 					pMsg.wCurKillMonster	= 0;
; 1288 : 					pMsg.wUserHaveWeapon	= 0;
; 1289 : 					pMsg.btWeaponNum		= -1;
; 1290 : 					g_BloodCastle.SendBridgeAnyMsg((LPBYTE)&pMsg, pMsg.h.size, iBridgeIndex);
; 1291 : 					// 일단 성문앞 다리의 서버쪽 속성만 바꾼다.
; 1292 : 					g_BloodCastle.ReleaseCastleBridge(iBridgeIndex);
; 1293 : 					// 성문앞의 다리의 속성을 해제할 시간을 세팅
; 1294 : 					g_BloodCastle.m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = GetTickCount() + BC_MAX_TICK_DOOR_OPEN;
; 1295 : 
; 1296 : 					LogAddTD("[Blood Castle] (%d) All of the Monster Terminated -> %d", 
; 1297 : 						iBridgeIndex+1, 
; 1298 : 						g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT
; 1299 : 						);
; 1300 : 					
; 1301 : 					// 보스몬스터 할당량을 계산한다.
; 1302 : 					g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT = g_BloodCastle.GetCurrentLiveUserCount(iBridgeIndex) * BC_PERUSER_BOSS_MONSTER_KILL;
; 1303 : 					g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;
; 1304 : 
; 1305 : 					if( g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT > 10 )
; 1306 : 					{
; 1307 : 						g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT = 10;
; 1308 : 					}
; 1309 : 				}
; 1310 : 
; 1311 : 				if (g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_MONSTER_SUCCESS_MSG_COUNT < BC_MAX_MONSTER_SUCCESS_MSG) {
; 1312 : 					g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_MONSTER_SUCCESS_MSG_COUNT++;
; 1313 : 					// 몬스터 할당량이 채워졌다고 해당 다리 사람들에게 공지한다.
; 1314 : 					g_BloodCastle.SendNoticeMessage(iBridgeIndex, lMsg.Get(1168));							// "몬스터 제거완료!! 성문공격"
; 1315 : 				}
; 1316 : 			}
; 1317 : 
; 1318 : 
; 1319 : 			if (g_BloodCastle.m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE &&
; 1320 : 				g_BloodCastle.CheckBossKillCount(iBridgeIndex)
; 1321 : 				) 
; 1322 : 			{
; 1323 : 				// 2 . 보스몬스터 할당량 완료체크
; 1324 : 				if (!g_BloodCastle.m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE) {
; 1325 : 					// 몬스터 할당량을 채웠다면 할당량이 완료되었음을 체크
; 1326 : 					g_BloodCastle.m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE = TRUE;
; 1327 : 					g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT = -1;
; 1328 : 
; 1329 : 					g_BloodCastle.SetSaintStatue(iBridgeIndex);
; 1330 : 
; 1331 : 					LogAddTD("[Blood Castle] (%d) All of the Boss Monster Terminated -> %d", 
; 1332 : 						iBridgeIndex + 1, 
; 1333 : 						g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT);
; 1334 : 				}
; 1335 : 
; 1336 : 				if (g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT < BC_MAX_MONSTER_SUCCESS_MSG) {
; 1337 : 					g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT++;
; 1338 : 					// 보스몬스터 할당량이 채워졌다고 해당 다리 사람들에게 공지한다.
; 1339 : 					g_BloodCastle.SendNoticeMessage(iBridgeIndex, lMsg.Get(1180));		// "보스몬스터 제거완료!! 석상을 파괴하세요!"
; 1340 : 				}
; 1341 : 			}
; 1342 : #else	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 1343 : 			if (g_BloodCastle.CheckMonsterKillCount(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1)) {

  0072f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00732	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00739	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0073c	51		 push	 ecx
  0073d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00742	e8 00 00 00 00	 call	 ?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckMonsterKillCount
  00747	0f b6 d0	 movzx	 edx, al
  0074a	85 d2		 test	 edx, edx
  0074c	0f 84 22 02 00
	00		 je	 $LN55@gObjMonste

; 1344 : 				// 1 . 일반몬스터 할당량 완료체크
; 1345 : 				if (!g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_bBC_MONSTER_KILL_COMPLETE) {

  00752	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00755	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0075c	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0075f	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00765	0f b6 82 60 01
	00 00		 movzx	 eax, BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+352]
  0076c	85 c0		 test	 eax, eax
  0076e	0f 85 86 01 00
	00		 jne	 $LN54@gObjMonste

; 1346 : 					// 몬스터 할당량을 채웠다면 할당량이 완료되었음을 체크
; 1347 : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_bBC_MONSTER_KILL_COMPLETE = TRUE;

  00774	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00777	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0077e	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00781	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00787	c6 82 60 01 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+352], 1

; 1348 : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_MAX_COUNT = -1;

  0078e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00791	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00798	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0079b	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  007a1	c7 82 74 01 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+372], -1

; 1349 : 					// 사람들에게 다리가 내려왔음을 알림 -> 클라이언트는 다리 내려오는 속성
; 1350 : 					PMSG_STATEBLOODCASTLE pMsg;
; 1351 : 					PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(pMsg));

  007ab	6a 0e		 push	 14			; 0000000eH
  007ad	68 9b 00 00 00	 push	 155			; 0000009bH
  007b2	8d 45 c4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  007b5	50		 push	 eax
  007b6	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  007bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1352 : 					pMsg.btPlayState		= BC_STATE_MONSTEREND;

  007be	c6 45 c7 03	 mov	 BYTE PTR _pMsg$1[ebp+3], 3

; 1353 : 					pMsg.wRemainSec			= 0;

  007c2	33 c0		 xor	 eax, eax
  007c4	66 89 45 c8	 mov	 WORD PTR _pMsg$1[ebp+4], ax

; 1354 : 					pMsg.wMaxKillMonster	= 0;

  007c8	33 c0		 xor	 eax, eax
  007ca	66 89 45 ca	 mov	 WORD PTR _pMsg$1[ebp+6], ax

; 1355 : 					pMsg.wCurKillMonster	= 0;

  007ce	33 c0		 xor	 eax, eax
  007d0	66 89 45 cc	 mov	 WORD PTR _pMsg$1[ebp+8], ax

; 1356 : 					pMsg.wUserHaveWeapon	= 0;

  007d4	33 c0		 xor	 eax, eax
  007d6	66 89 45 ce	 mov	 WORD PTR _pMsg$1[ebp+10], ax

; 1357 : 					pMsg.btWeaponNum		= -1;

  007da	c6 45 d0 ff	 mov	 BYTE PTR _pMsg$1[ebp+12], 255 ; 000000ffH

; 1358 : 					g_BloodCastle.SendBridgeAnyMsg((LPBYTE)&pMsg, pMsg.h.size, lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1);

  007de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007e1	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  007e8	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  007eb	51		 push	 ecx
  007ec	0f b6 55 c5	 movzx	 edx, BYTE PTR _pMsg$1[ebp+1]
  007f0	52		 push	 edx
  007f1	8d 45 c4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  007f4	50		 push	 eax
  007f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  007fa	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 1359 : 					// 일단 성문앞 다리의 서버쪽 속성만 바꾼다.
; 1360 : 					g_BloodCastle.ReleaseCastleBridge(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1);

  007ff	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00802	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00809	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0080c	51		 push	 ecx
  0080d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00812	e8 00 00 00 00	 call	 ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleBridge

; 1361 : 					// 성문앞의 다리의 속성을 해제할 시간을 세팅
; 1362 : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_dwBC_TICK_DOOR_OPEN = GetTickCount() + BC_MAX_TICK_DOOR_OPEN;

  00817	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0081d	05 b8 0b 00 00	 add	 eax, 3000		; 00000bb8H
  00822	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00825	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0082c	83 ea 0b	 sub	 edx, 11			; 0000000bH
  0082f	69 ca 04 02 00
	00		 imul	 ecx, edx, 516
  00835	89 81 80 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+384], eax

; 1363 : 
; 1364 : 					LogAddTD("[Blood Castle] (%d) All of the Monster Terminated -> %d", 

  0083b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0083e	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00845	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00848	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0084e	8b 82 78 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+376]
  00854	50		 push	 eax
  00855	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00858	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0085f	83 ea 0a	 sub	 edx, 10			; 0000000aH
  00862	52		 push	 edx
  00863	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@FKJGCAAF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5@
  00868	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0086e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1365 : 						lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1+1, 
; 1366 : 						g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_KILL_COUNT
; 1367 : 						);
; 1368 : 					
; 1369 : 					// 보스몬스터 할당량을 계산한다.
; 1370 : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = g_BloodCastle.GetCurrentLiveUserCount(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1) * BC_PERUSER_BOSS_MONSTER_KILL;

  00871	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00874	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0087b	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0087e	51		 push	 ecx
  0087f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00884	e8 00 00 00 00	 call	 ?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentLiveUserCount
  00889	d1 e0		 shl	 eax, 1
  0088b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0088e	0f b6 8a 09 01
	00 00		 movzx	 ecx, BYTE PTR [edx+265]
  00895	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00898	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0089e	89 82 84 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+388], eax

; 1371 : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;

  008a4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008a7	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  008ae	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  008b1	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  008b7	c7 82 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+392], 0

; 1372 : 
; 1373 : 					if( g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT > 10 )

  008c1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008c4	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  008cb	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  008ce	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  008d4	83 ba 84 01 00
	00 0a		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+388], 10 ; 0000000aH
  008db	7e 1d		 jle	 SHORT $LN54@gObjMonste

; 1374 : 					{
; 1375 : 						g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = 10;

  008dd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008e0	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  008e7	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  008ea	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  008f0	c7 82 84 01 00
	00 0a 00 00 00	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+388], 10 ; 0000000aH
$LN54@gObjMonste:

; 1376 : 					}
; 1377 : 				}
; 1378 : 
; 1379 : 				if (g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_SUCCESS_MSG_COUNT < BC_MAX_MONSTER_SUCCESS_MSG) {

  008fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008fd	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00904	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00907	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0090d	83 ba 7c 01 00
	00 01		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+380], 1
  00914	7d 5e		 jge	 SHORT $LN55@gObjMonste

; 1380 : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_SUCCESS_MSG_COUNT++;

  00916	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00919	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00920	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00923	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00929	8b 82 7c 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+380]
  0092f	83 c0 01	 add	 eax, 1
  00932	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00935	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0093c	83 ea 0b	 sub	 edx, 11			; 0000000bH
  0093f	69 ca 04 02 00
	00		 imul	 ecx, edx, 516
  00945	89 81 7c 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+380], eax

; 1381 : 					// 몬스터 할당량이 채워졌다고 해당 다리 사람들에게 공지한다.
; 1382 : 					g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1, lMsg.Get(1168));							// "몬스터 제거완료!! 성문공격"

  0094b	68 90 04 00 00	 push	 1168			; 00000490H
  00950	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00955	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0095b	50		 push	 eax
  0095c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0095f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00966	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00969	51		 push	 ecx
  0096a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0096f	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage
$LN55@gObjMonste:

; 1383 : 				}
; 1384 : 			}
; 1385 : 
; 1386 : 
; 1387 : 			if (g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_bBC_MONSTER_KILL_COMPLETE &&

  00974	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00977	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0097e	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00981	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00987	0f b6 82 60 01
	00 00		 movzx	 eax, BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+352]
  0098e	85 c0		 test	 eax, eax
  00990	0f 84 44 01 00
	00		 je	 $LN58@gObjMonste
  00996	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00999	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  009a0	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  009a3	51		 push	 ecx
  009a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  009a9	e8 00 00 00 00	 call	 ?CheckBossKillCount@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckBossKillCount
  009ae	0f b6 d0	 movzx	 edx, al
  009b1	85 d2		 test	 edx, edx
  009b3	0f 84 21 01 00
	00		 je	 $LN58@gObjMonste

; 1388 : 				g_BloodCastle.CheckBossKillCount(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1)
; 1389 : 				) 
; 1390 : 			{
; 1391 : 				// 2 . 보스몬스터 할당량 완료체크
; 1392 : 				if (!g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_bBC_BOSS_MONSTER_KILL_COMPLETE) {

  009b9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009bc	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  009c3	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  009c6	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  009cc	0f b6 82 61 01
	00 00		 movzx	 eax, BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+353]
  009d3	85 c0		 test	 eax, eax
  009d5	0f 85 85 00 00
	00		 jne	 $LN57@gObjMonste

; 1393 : 					// 몬스터 할당량을 채웠다면 할당량이 완료되었음을 체크
; 1394 : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_bBC_BOSS_MONSTER_KILL_COMPLETE = TRUE;

  009db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009de	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  009e5	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  009e8	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  009ee	c6 82 61 01 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+353], 1

; 1395 : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = -1;

  009f5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009f8	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  009ff	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00a02	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00a08	c7 82 84 01 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+388], -1

; 1396 : 
; 1397 : 					g_BloodCastle.SetSaintStatue(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1);

  00a12	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a15	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00a1c	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00a1f	51		 push	 ecx
  00a20	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00a25	e8 00 00 00 00	 call	 ?SetSaintStatue@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetSaintStatue

; 1398 : 
; 1399 : 					LogAddTD("[Blood Castle] (%d) All of the Boss Monster Terminated -> %d", 

  00a2a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a2d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00a34	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00a37	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00a3d	8b 82 88 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+392]
  00a43	50		 push	 eax
  00a44	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a47	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00a4e	83 ea 0a	 sub	 edx, 10			; 0000000aH
  00a51	52		 push	 edx
  00a52	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@OMDKGOEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5@
  00a57	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00a5d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@gObjMonste:

; 1400 : 						lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1+1, 
; 1401 : 						g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT);
; 1402 : 				}
; 1403 : 
; 1404 : 				if (g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT < BC_MAX_MONSTER_SUCCESS_MSG) {

  00a60	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a63	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00a6a	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00a6d	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00a73	83 ba 8c 01 00
	00 01		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+396], 1
  00a7a	7d 5e		 jge	 SHORT $LN58@gObjMonste

; 1405 : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT++;

  00a7c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a7f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00a86	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00a89	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00a8f	8b 82 8c 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+396]
  00a95	83 c0 01	 add	 eax, 1
  00a98	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a9b	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00aa2	83 ea 0b	 sub	 edx, 11			; 0000000bH
  00aa5	69 ca 04 02 00
	00		 imul	 ecx, edx, 516
  00aab	89 81 8c 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+396], eax

; 1406 : 					// 보스몬스터 할당량이 채워졌다고 해당 다리 사람들에게 공지한다.
; 1407 : 					g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1, lMsg.Get(1180));		// "보스몬스터 제거완료!! 석상을 파괴하세요!"

  00ab1	68 9c 04 00 00	 push	 1180			; 0000049cH
  00ab6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00abb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00ac1	50		 push	 eax
  00ac2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ac5	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00acc	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00acf	51		 push	 ecx
  00ad0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00ad5	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage
$LN58@gObjMonste:

; 1408 : 				}
; 1409 : 			}
; 1410 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010			
; 1411 : 		}
; 1412 : #endif
; 1413 : 		break;

  00ada	e9 2f 02 00 00	 jmp	 $LN2@gObjMonste
$LN59@gObjMonste:

; 1414 : 	case 2 :	// 강한 공격을 당했다. (뒤로 물러난다)
; 1415 : #ifdef FOR_BLOODCASTLE
; 1416 : 		if( gObj[aIndex].Live ) {

  00adf	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ae6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00aec	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  00af1	85 d2		 test	 edx, edx
  00af3	0f 84 f1 00 00
	00		 je	 $LN62@gObjMonste

; 1417 : 			if (!CHECK_BLOODCASTLE(gObj[aIndex].MapNumber)) {

  00af9	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b00	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b06	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00b0e	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00b11	7d 09		 jge	 SHORT $LN86@gObjMonste
  00b13	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv663[ebp], 0
  00b1a	eb 39		 jmp	 SHORT $LN87@gObjMonste
$LN86@gObjMonste:
  00b1c	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b29	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00b31	83 fa 11	 cmp	 edx, 17			; 00000011H
  00b34	7e 0c		 jle	 SHORT $LN84@gObjMonste
  00b36	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv662[ebp], 0
  00b40	eb 0a		 jmp	 SHORT $LN85@gObjMonste
$LN84@gObjMonste:
  00b42	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv662[ebp], 1
$LN85@gObjMonste:
  00b4c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv662[ebp]
  00b52	89 45 80	 mov	 DWORD PTR tv663[ebp], eax
$LN87@gObjMonste:
  00b55	83 7d 80 00	 cmp	 DWORD PTR tv663[ebp], 0
  00b59	0f 85 8b 00 00
	00		 jne	 $LN62@gObjMonste

; 1418 : 				if ((gObj[aIndex].Class != 131) || (!CHECK_LIMIT(lpObj->Class-BC_SAINT_STATUE_1, 3))) {

  00b5f	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b66	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b6c	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00b74	81 fa 83 00 00
	00		 cmp	 edx, 131		; 00000083H
  00b7a	75 54		 jne	 SHORT $LN63@gObjMonste
  00b7c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b7f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b86	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  00b8c	79 09		 jns	 SHORT $LN90@gObjMonste
  00b8e	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv679[ebp], 0
  00b95	eb 33		 jmp	 SHORT $LN91@gObjMonste
$LN90@gObjMonste:
  00b97	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b9a	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  00ba1	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  00ba6	83 f8 02	 cmp	 eax, 2
  00ba9	7e 0c		 jle	 SHORT $LN88@gObjMonste
  00bab	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv678[ebp], 0
  00bb5	eb 0a		 jmp	 SHORT $LN89@gObjMonste
$LN88@gObjMonste:
  00bb7	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv678[ebp], 1
$LN89@gObjMonste:
  00bc1	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv678[ebp]
  00bc7	89 4d 80	 mov	 DWORD PTR tv679[ebp], ecx
$LN91@gObjMonste:
  00bca	83 7d 80 00	 cmp	 DWORD PTR tv679[ebp], 0
  00bce	75 1a		 jne	 SHORT $LN62@gObjMonste
$LN63@gObjMonste:

; 1419 : 					gObjBackSpring(lpObj, &gObj[aIndex]);

  00bd0	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00bd7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bdd	50		 push	 eax
  00bde	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00be1	51		 push	 ecx
  00be2	e8 00 00 00 00	 call	 ?gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjBackSpring
  00be7	83 c4 08	 add	 esp, 8
$LN62@gObjMonste:

; 1420 : 				}
; 1421 : 			}
; 1422 : 		}
; 1423 : #else
; 1424 : 		if( gObj[aIndex].Live )
; 1425 : 			gObjBackSpring(lpObj, &gObj[aIndex]);
; 1426 : #endif
; 1427 : 		break;

  00bea	e9 1f 01 00 00	 jmp	 $LN2@gObjMonste
$LN64@gObjMonste:

; 1428 : 	case 3 :	// 공격 대상자가 죽었다..
; 1429 : 		lpObj->TargetNumber = -1;

  00bef	83 c8 ff	 or	 eax, -1
  00bf2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bf5	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 1430 : #ifdef FOR_BLOODCASTLE
; 1431 : 		lpObj->LastAttackerID = -1;

  00bfc	83 c8 ff	 or	 eax, -1
  00bff	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c02	66 89 81 b2 02
	00 00		 mov	 WORD PTR [ecx+690], ax

; 1432 : #endif
; 1433 : 		lpObj->m_ActState.Emotion = 0;

  00c09	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c0c	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00c12	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00c18	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c1b	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1434 : 		lpObj->m_ActState.Attack = 0;

  00c21	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c24	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00c2a	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00c2d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c30	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1435 : 		lpObj->m_ActState.Move = 0;

  00c36	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c39	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00c3f	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00c42	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c45	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1436 : 		lpObj->NextActionTime = 1000;

  00c4b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c4e	c7 80 18 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+536], 1000 ; 000003e8H

; 1437 : 		break;

  00c58	e9 b1 00 00 00	 jmp	 $LN2@gObjMonste
$LN65@gObjMonste:

; 1438 : 	case 4 :	// 공격을 당해 잠시 머뭇거린다.
; 1439 : 		lpObj->m_ActState.Emotion = 3;

  00c5d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c60	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00c66	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00c6c	83 c9 30	 or	 ecx, 48			; 00000030H
  00c6f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c72	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1440 : 		lpObj->m_ActState.EmotionCount = 1;

  00c78	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c7b	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00c81	81 e1 ff 00 ff
	ff		 and	 ecx, -65281		; ffff00ffH
  00c87	81 c9 00 01 00
	00		 or	 ecx, 256		; 00000100H
  00c8d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c90	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1441 : 		break;

  00c96	eb 76		 jmp	 SHORT $LN2@gObjMonste
$LN66@gObjMonste:

; 1442 : 	case 5 :
; 1443 : 		gObjMemFree(lpObj->m_Index);

  00c98	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c9b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c9d	51		 push	 ecx
  00c9e	e8 00 00 00 00	 call	 ?gObjMemFree@@YAFH@Z	; gObjMemFree
  00ca3	83 c4 04	 add	 esp, 4

; 1444 : 		break;

  00ca6	eb 66		 jmp	 SHORT $LN2@gObjMonste
$LN67@gObjMonste:

; 1445 : 	case 6 : 
; 1446 : 		if( gObj[aIndex].Live )

  00ca8	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00caf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00cb5	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  00cba	85 d2		 test	 edx, edx
  00cbc	74 1c		 je	 SHORT $LN68@gObjMonste

; 1447 : 			gObjBackSpring2(lpObj, &gObj[aIndex], 2);

  00cbe	6a 02		 push	 2
  00cc0	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00cc7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ccd	50		 push	 eax
  00cce	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cd1	51		 push	 ecx
  00cd2	e8 00 00 00 00	 call	 ?gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z ; gObjBackSpring2
  00cd7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN68@gObjMonste:

; 1448 : 		break;

  00cda	eb 32		 jmp	 SHORT $LN2@gObjMonste
$LN69@gObjMonste:

; 1449 : 	case 7 : 
; 1450 : 		if( gObj[aIndex].Live )

  00cdc	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ce3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ce9	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  00cee	85 d2		 test	 edx, edx
  00cf0	74 1c		 je	 SHORT $LN70@gObjMonste

; 1451 : 			gObjBackSpring2(lpObj, &gObj[aIndex], 3);

  00cf2	6a 03		 push	 3
  00cf4	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00cfb	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d01	50		 push	 eax
  00d02	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d05	51		 push	 ecx
  00d06	e8 00 00 00 00	 call	 ?gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z ; gObjBackSpring2
  00d0b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN70@gObjMonste:
$LN2@gObjMonste:
$LN1@gObjMonste:

; 1452 : 		break;
; 1453 : #ifdef MODIFY_NEW_MONSTER_AI_01_2006724
; 1454 : 	case MSG_ATTACK_NORMAL :  // 딜레이있는 일반 공격 설정
; 1455 : 		gObjAttack(lpObj, &gObj[aIndex], 0, 0, 0);		
; 1456 : 		//MsgOutput(aIndex, "[MSG_ATTACKPROC][NORMAL ATTACK] %s... ", lpObj->Name);
; 1457 : 		break;
; 1458 : 	case MSG_MONSTER_SKILL_POISON :	// 딜레이 있는 스킬 공격 설정
; 1459 : 		{
; 1460 : 			LPOBJECTSTRUCT lpTargetObj = &gObj[aIndex];
; 1461 : 			// 독 스킬
; 1462 : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1463 : 			if( gObjCheckUsedBuffEffect( lpTargetObj, BUFFTYPE_POISON ) == false )
; 1464 : 			{
; 1465 : 				if( retResistance( lpTargetObj, RESISTANCE_POISON ) == FALSE )
; 1466 : 				{
; 1467 : #ifdef MODIFY_BUFFSYSTEM_BUGFIX_01_20071128
; 1468 : 					lpTargetObj->lpAttackObj = lpObj;
; 1469 : #endif // MODIFY_BUFFSYSTEM_BUGFIX_01_20071128
; 1470 : 					gObjAddBuffEffect( lpTargetObj, BUFFTYPE_POISON, EFFECTTYPE_POISON_DMG_TICK, 3, 0, 0, aMsgSubCode );
; 1471 : 				}
; 1472 : 			}
; 1473 : 	#else
; 1474 : 		#ifdef ADD_SKILL_WITH_COMBO		
; 1475 : 			if( lpTargetObj->m_PoisonType == 0 ) // 현재 중독 마법에 걸려있다면 다시 걸리지 않게..
; 1476 : 		#else
; 1477 : 			if( lpTargetObj->m_PoisonBeattackCount == 0 ) // 현재 중독 마법에 걸려있다면 다시 걸리지 않게..
; 1478 : 		#endif	//#ifdef ADD_SKILL_WITH_COMBO
; 1479 : 			{
; 1480 : 				if( retResistance(lpTargetObj, RESISTANCE_POISON) == FALSE ) 
; 1481 : 				{
; 1482 : 		#ifdef ADD_SKILL_WITH_COMBO
; 1483 : 					lpTargetObj->m_PoisonType = AT_SKILL_POISON;
; 1484 : 		#endif	//#ifdef ADD_SKILL_WITH_COMBO
; 1485 : 					lpTargetObj->m_PoisonBeattackCount	= aMsgSubCode;	// 초 설정
; 1486 : 					lpTargetObj->lpAttackObj			= lpObj;
; 1487 : 					lpTargetObj->m_ViewSkillState		|= 0x01; //	1번째 비트
; 1488 : 					GCStateInfoSend(lpTargetObj, 1, lpTargetObj->m_ViewSkillState);
; 1489 : 				}
; 1490 : 			}
; 1491 : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004		
; 1492 : 		}
; 1493 : 		break;
; 1494 : 	case MSG_MONSTER_SKILL_SPRING: // 딜레이 있는 밀기 공격
; 1495 : 		{
; 1496 : 			// aMsgSubCode : 거리
; 1497 : 			LPOBJECTSTRUCT lpTargetObj = &gObj[aIndex];
; 1498 : 			gObjBackSpring2( lpTargetObj, lpObj, aMsgSubCode );
; 1499 : 		}
; 1500 : 		break;
; 1501 : #endif // MODIFY_NEW_MONSTER_AI_01_2006724
; 1502 : 	}
; 1503 : }

  00d0e	5f		 pop	 edi
  00d0f	5e		 pop	 esi
  00d10	5b		 pop	 ebx
  00d11	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d14	33 cd		 xor	 ecx, ebp
  00d16	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d1b	8b e5		 mov	 esp, ebp
  00d1d	5d		 pop	 ebp
  00d1e	c3		 ret	 0
  00d1f	90		 npad	 1
$LN92@gObjMonste:
  00d20	00 00 00 00	 DD	 $LN5@gObjMonste
  00d24	00 00 00 00	 DD	 $LN46@gObjMonste
  00d28	00 00 00 00	 DD	 $LN59@gObjMonste
  00d2c	00 00 00 00	 DD	 $LN64@gObjMonste
  00d30	00 00 00 00	 DD	 $LN65@gObjMonste
  00d34	00 00 00 00	 DD	 $LN66@gObjMonste
  00d38	00 00 00 00	 DD	 $LN67@gObjMonste
  00d3c	00 00 00 00	 DD	 $LN69@gObjMonste
?gObjMonsterStateProc@@YAXPAVOBJECTSTRUCT@@HH@Z ENDP	; gObjMonsterStateProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterProcess@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv145 = -96						; size = 4
tv136 = -96						; size = 4
tv90 = -96						; size = 4
tv146 = -92						; size = 4
tv137 = -92						; size = 4
tv91 = -92						; size = 4
_MagicAttack$1 = -24					; size = 4
_AttackType$2 = -20					; size = 4
_CallMonMove$3 = -16					; size = 4
_lpCallObj$4 = -12					; size = 4
_team$5 = -8						; size = 4
_ground$6 = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterProcess@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjMonsterProcess, COMDAT

; 1509 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1510 : 	gObjMsgProc(lpObj);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjMsgProc@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMsgProc
  00012	83 c4 04	 add	 esp, 4

; 1511 : 
; 1512 : 	if( lpObj->Live == 0 ) 

  00015	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00018	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  0001c	85 c9		 test	 ecx, ecx
  0001e	75 05		 jne	 SHORT $LN2@gObjMonste

; 1513 : 		return;

  00020	e9 60 07 00 00	 jmp	 $LN1@gObjMonste
$LN2@gObjMonste:

; 1514 : 
; 1515 : #ifdef ADD_NEW_MAP_KALIMA_20040518						// 칼리마 보스몹들의 추가 공격들
; 1516 : 	if (lpObj->m_iMonsterBattleDelay > 0) {	// 딜레이 시간을 주기적으로 계속 깎는다.

  00025	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00028	0f be 88 25 02
	00 00		 movsx	 ecx, BYTE PTR [eax+549]
  0002f	85 c9		 test	 ecx, ecx
  00031	7e 15		 jle	 SHORT $LN3@gObjMonste

; 1517 : 		lpObj->m_iMonsterBattleDelay --;

  00033	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00036	8a 88 25 02 00
	00		 mov	 cl, BYTE PTR [eax+549]
  0003c	80 e9 01	 sub	 cl, 1
  0003f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00042	88 8a 25 02 00
	00		 mov	 BYTE PTR [edx+549], cl
$LN3@gObjMonste:

; 1518 : 	}
; 1519 : #endif
; 1520 : 
; 1521 : 	if( (GetTickCount()-lpObj->CurActionTime) < (lpObj->NextActionTime+lpObj->DelayActionTime) ) return;

  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00051	2b 81 14 02 00
	00		 sub	 eax, DWORD PTR [ecx+532]
  00057	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005a	8b 8a 18 02 00
	00		 mov	 ecx, DWORD PTR [edx+536]
  00060	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00063	03 8a 1c 02 00
	00		 add	 ecx, DWORD PTR [edx+540]
  00069	3b c1		 cmp	 eax, ecx
  0006b	73 05		 jae	 SHORT $LN4@gObjMonste
  0006d	e9 13 07 00 00	 jmp	 $LN1@gObjMonste
$LN4@gObjMonste:

; 1522 : 	lpObj->CurActionTime = GetTickCount();	

  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007b	89 81 14 02 00
	00		 mov	 DWORD PTR [ecx+532], eax

; 1523 : 	
; 1524 : #ifdef FOR_BLOODCASTLE
; 1525 : 	if (CHECK_BLOODCASTLE(lpObj->MapNumber)) {

  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0008b	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0008e	7d 09		 jge	 SHORT $LN52@gObjMonste
  00090	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
  00097	eb 25		 jmp	 SHORT $LN53@gObjMonste
$LN52@gObjMonste:
  00099	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009c	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000a3	83 f8 11	 cmp	 eax, 17			; 00000011H
  000a6	7e 09		 jle	 SHORT $LN50@gObjMonste
  000a8	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
  000af	eb 07		 jmp	 SHORT $LN51@gObjMonste
$LN50@gObjMonste:
  000b1	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv90[ebp], 1
$LN51@gObjMonste:
  000b8	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  000bb	89 4d a4	 mov	 DWORD PTR tv91[ebp], ecx
$LN53@gObjMonste:
  000be	83 7d a4 00	 cmp	 DWORD PTR tv91[ebp], 0
  000c2	74 62		 je	 SHORT $LN5@gObjMonste

; 1526 : 		if ( (lpObj->Class == 131) || (CHECK_LIMIT(lpObj->Class-BC_SAINT_STATUE_1, 3))) {	// 성문이나 성자의석상은 않움직인다.

  000c4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c7	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000ce	81 f9 83 00 00
	00		 cmp	 ecx, 131		; 00000083H
  000d4	74 4b		 je	 SHORT $LN7@gObjMonste
  000d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d9	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000e0	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  000e6	79 09		 jns	 SHORT $LN56@gObjMonste
  000e8	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
  000ef	eb 2a		 jmp	 SHORT $LN57@gObjMonste
$LN56@gObjMonste:
  000f1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f4	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  000fb	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  00100	83 f8 02	 cmp	 eax, 2
  00103	7e 09		 jle	 SHORT $LN54@gObjMonste
  00105	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
  0010c	eb 07		 jmp	 SHORT $LN55@gObjMonste
$LN54@gObjMonste:
  0010e	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv136[ebp], 1
$LN55@gObjMonste:
  00115	8b 4d a0	 mov	 ecx, DWORD PTR tv136[ebp]
  00118	89 4d a4	 mov	 DWORD PTR tv137[ebp], ecx
$LN57@gObjMonste:
  0011b	83 7d a4 00	 cmp	 DWORD PTR tv137[ebp], 0
  0011f	74 05		 je	 SHORT $LN5@gObjMonste
$LN7@gObjMonste:

; 1527 : 			return;

  00121	e9 5f 06 00 00	 jmp	 $LN1@gObjMonste
$LN5@gObjMonste:

; 1528 : 		}
; 1529 : 	}
; 1530 : #endif
; 1531 : 
; 1532 : #ifdef ADD_NEW_MAP_KALIMA_20040518						// 마석은 움직이지 않는다. -> 공격도 않한다. 대신 자신위에 서 있는 사용자를 찾아서 이동시키고 시간에 따라 수명도 줄어든다.
; 1533 : 	if (CHECK_KALIMAGATE (lpObj->m_Attribute)) 

  00126	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00129	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  00130	83 f9 33	 cmp	 ecx, 51			; 00000033H
  00133	7d 09		 jge	 SHORT $LN60@gObjMonste
  00135	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
  0013c	eb 25		 jmp	 SHORT $LN61@gObjMonste
$LN60@gObjMonste:
  0013e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00141	0f bf 82 fe 02
	00 00		 movsx	 eax, WORD PTR [edx+766]
  00148	83 f8 38	 cmp	 eax, 56			; 00000038H
  0014b	7e 09		 jle	 SHORT $LN58@gObjMonste
  0014d	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv145[ebp], 0
  00154	eb 07		 jmp	 SHORT $LN59@gObjMonste
$LN58@gObjMonste:
  00156	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv145[ebp], 1
$LN59@gObjMonste:
  0015d	8b 4d a0	 mov	 ecx, DWORD PTR tv145[ebp]
  00160	89 4d a4	 mov	 DWORD PTR tv146[ebp], ecx
$LN61@gObjMonste:
  00163	83 7d a4 00	 cmp	 DWORD PTR tv146[ebp], 0
  00167	74 15		 je	 SHORT $LN8@gObjMonste

; 1534 : 	{
; 1535 : 
; 1536 : 	#ifdef HIDDEN_KALIMA_20050706
; 1537 : 		if ( lpObj->m_Attribute== MON_ATTR_KALIMAGATE_NXT ) 
; 1538 : 		{
; 1539 : 			g_KalimaGate.KalimaGateAct2(lpObj->m_Index);
; 1540 : 			return;
; 1541 : 		}
; 1542 : 	#endif
; 1543 : 
; 1544 : 		g_KalimaGate.KalimaGateAct(lpObj->m_Index);

  00169	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016e	51		 push	 ecx
  0016f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  00174	e8 00 00 00 00	 call	 ?KalimaGateAct@CKalimaGate@@QAEXH@Z ; CKalimaGate::KalimaGateAct

; 1545 : 		return;

  00179	e9 07 06 00 00	 jmp	 $LN1@gObjMonste
$LN8@gObjMonste:

; 1546 : 	}
; 1547 : #endif
; 1548 : 
; 1549 : 
; 1550 : #ifdef CASTLE_NPC_GUARDIANSTATUE_WORK_20041207			// 수호석상은 움직이지 않는다.
; 1551 : 	if (lpObj->Class == 283) {
; 1552 : 		return;
; 1553 : 	}
; 1554 : #endif
; 1555 : 
; 1556 : #ifdef CASTLE_NPC_CANNON_TOWER_20041223					// 캐논타워는 별도로 공격한다.
; 1557 : 	if (lpObj->Class == 288) {
; 1558 : 		return;
; 1559 : 	}
; 1560 : #endif
; 1561 : 	
; 1562 : #ifdef CASTLE_NPC_LIFESTONE_WORK_20041208				// 라이프스톤은 움직이지 않는다.
; 1563 : 	if( lpObj->Class ==  NPC_INDEX_LIFESTONE )
; 1564 : 	{
; 1565 : 		return;
; 1566 : 	}
; 1567 : #endif
; 1568 : 	
; 1569 : #ifdef FOR_BLOODCASTLE
; 1570 : 	if( lpObj->Class >= 100 && lpObj->Class <= 110 )	// 트랩일때

  0017e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00181	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00188	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0018b	7c 20		 jl	 SHORT $LN9@gObjMonste
  0018d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00190	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00197	83 f9 6e	 cmp	 ecx, 110		; 0000006eH
  0019a	7f 11		 jg	 SHORT $LN9@gObjMonste

; 1571 : #else
; 1572 : 	if( lpObj->Class >= 100 && lpObj->Class < 110 )		// 트랩일때
; 1573 : #endif
; 1574 : 	{
; 1575 : 		gObjMonsterTrapAct(lpObj);

  0019c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 ?gObjMonsterTrapAct@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMonsterTrapAct
  001a5	83 c4 04	 add	 esp, 4

; 1576 : 	}

  001a8	e9 a3 00 00 00	 jmp	 $LN10@gObjMonste
$LN9@gObjMonste:

; 1577 : 	else if( lpObj->Class == 200 )		// 배틀사커 축구공일 때

  001ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001b7	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  001bd	75 4e		 jne	 SHORT $LN11@gObjMonste

; 1578 : 	{
; 1579 : 		int ground;
; 1580 : 		int team;
; 1581 : 		team = gCheckGoal(lpObj->X, lpObj->Y, ground);

  001bf	8d 45 fc	 lea	 eax, DWORD PTR _ground$6[ebp]
  001c2	50		 push	 eax
  001c3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c6	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  001cd	52		 push	 edx
  001ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d1	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  001d8	51		 push	 ecx
  001d9	e8 00 00 00 00	 call	 ?gCheckGoal@@YAHHHAAH@Z	; gCheckGoal
  001de	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e1	89 45 f8	 mov	 DWORD PTR _team$5[ebp], eax

; 1582 : 		if( team >= 0 )

  001e4	83 7d f8 00	 cmp	 DWORD PTR _team$5[ebp], 0
  001e8	7c 21		 jl	 SHORT $LN13@gObjMonste

; 1583 : 		{
; 1584 : #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 1585 : 			GCBTGoalSend(ground, lpObj->X, lpObj->Y);
; 1586 : #endif			
; 1587 : 			gObjMonsterRegen(lpObj);

  001ea	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterRegen
  001f3	83 c4 04	 add	 esp, 4

; 1588 : 			gBattleSoccerScoreUpdate(ground, team);

  001f6	8b 45 f8	 mov	 eax, DWORD PTR _team$5[ebp]
  001f9	50		 push	 eax
  001fa	8b 4d fc	 mov	 ecx, DWORD PTR _ground$6[ebp]
  001fd	51		 push	 ecx
  001fe	e8 00 00 00 00	 call	 ?gBattleSoccerScoreUpdate@@YAHHH@Z ; gBattleSoccerScoreUpdate
  00203	83 c4 08	 add	 esp, 8

; 1589 : 			return;

  00206	e9 7a 05 00 00	 jmp	 $LN1@gObjMonste
$LN13@gObjMonste:

; 1590 : 		}
; 1591 : 	}

  0020b	eb 43		 jmp	 SHORT $LN10@gObjMonste
$LN11@gObjMonste:

; 1592 : #ifdef ADD_NEW_MERCENARY_FOR_CASTLE_01_20041214	
; 1593 : 	// 공성전 용병은 다르게 행동한다.
; 1594 : 	else if( lpObj->Class == NPC_INDEX_SPEARMAN || lpObj->Class == NPC_INDEX_BOWMAN )
; 1595 : 	{
; 1596 : 		g_CsNPC_Mercenary.MercenaryAct(lpObj->m_Index);
; 1597 : 	}
; 1598 : #endif
; 1599 : 	else 
; 1600 : 	{
; 1601 : 
; 1602 : #ifdef MONSTER_HERD_SYSTEM_20031120
; 1603 : 		if (lpObj->m_bIsInMonsterHerd) {

  0020d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00210	83 b8 ec 0e 00
	00 00		 cmp	 DWORD PTR [eax+3820], 0
  00217	74 2b		 je	 SHORT $LN14@gObjMonste

; 1604 : 			if (lpObj->m_lpMonsterHerd != NULL)

  00219	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0021c	83 b8 f4 0e 00
	00 00		 cmp	 DWORD PTR [eax+3828], 0
  00223	74 1d		 je	 SHORT $LN16@gObjMonste

; 1605 : 				lpObj->m_lpMonsterHerd->MonsterBaseAct(lpObj);

  00225	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00228	50		 push	 eax
  00229	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0022c	8b 91 f4 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3828]
  00232	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00235	8b 12		 mov	 edx, DWORD PTR [edx]
  00237	8b 88 f4 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3828]
  0023d	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00240	ff d0		 call	 eax
$LN16@gObjMonste:

; 1606 : 		}

  00242	eb 0c		 jmp	 SHORT $LN10@gObjMonste
$LN14@gObjMonste:

; 1607 : 		else
; 1608 : #endif
; 1609 : 			gObjMonsterBaseAct(lpObj);

  00244	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?gObjMonsterBaseAct@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMonsterBaseAct
  0024d	83 c4 04	 add	 esp, 4
$LN10@gObjMonste:

; 1610 : 	}
; 1611 : 	
; 1612 : 	// 소환 몬스터 일 때 -> 주인과의 위치 확인 후 멀면 텔레포트
; 1613 : 	if( lpObj->m_Attribute == 100 )		

  00250	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00253	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  0025a	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0025d	0f 85 bf 00 00
	00		 jne	 $LN17@gObjMonste

; 1614 : 	{
; 1615 : 		if( lpObj->m_RecallMon >= 0 && lpObj->m_RecallMon < MAX_OBJECT )

  00263	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00266	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  0026d	0f 8c af 00 00
	00		 jl	 $LN17@gObjMonste
  00273	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00276	81 b8 a4 02 00
	00 e8 1c 00 00	 cmp	 DWORD PTR [eax+676], 7400 ; 00001ce8H
  00280	0f 8d 9c 00 00
	00		 jge	 $LN17@gObjMonste

; 1616 : 		{
; 1617 : 			LPOBJECTSTRUCT lpCallObj;
; 1618 : 			int				CallMonMove=0;

  00286	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _CallMonMove$3[ebp], 0

; 1619 : 			lpCallObj = &gObj[lpObj->m_RecallMon];

  0028d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00290	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  0029a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a0	89 4d f4	 mov	 DWORD PTR _lpCallObj$4[ebp], ecx

; 1620 : 			
; 1621 : 			if( lpObj->MapNumber != lpCallObj->MapNumber ) CallMonMove = 1;

  002a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a6	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  002ad	8b 55 f4	 mov	 edx, DWORD PTR _lpCallObj$4[ebp]
  002b0	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  002b7	3b c8		 cmp	 ecx, eax
  002b9	74 07		 je	 SHORT $LN19@gObjMonste
  002bb	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _CallMonMove$3[ebp], 1
$LN19@gObjMonste:

; 1622 : 			if( (gObjCalDistance(lpCallObj, lpObj)) > 14 ) CallMonMove = 1;

  002c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c5	50		 push	 eax
  002c6	8b 4d f4	 mov	 ecx, DWORD PTR _lpCallObj$4[ebp]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  002cf	83 c4 08	 add	 esp, 8
  002d2	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  002d5	7e 07		 jle	 SHORT $LN20@gObjMonste
  002d7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _CallMonMove$3[ebp], 1
$LN20@gObjMonste:

; 1623 : 			
; 1624 : 			if( CallMonMove == 1 ) 

  002de	83 7d f0 01	 cmp	 DWORD PTR _CallMonMove$3[ebp], 1
  002e2	75 3e		 jne	 SHORT $LN17@gObjMonste

; 1625 : 			{
; 1626 : 				gObjTeleportMagicUse(lpObj->m_Index, (BYTE)lpCallObj->X+1, (BYTE)lpCallObj->Y);

  002e4	8b 45 f4	 mov	 eax, DWORD PTR _lpCallObj$4[ebp]
  002e7	0f b6 88 06 01
	00 00		 movzx	 ecx, BYTE PTR [eax+262]
  002ee	51		 push	 ecx
  002ef	8b 55 f4	 mov	 edx, DWORD PTR _lpCallObj$4[ebp]
  002f2	0f b6 82 04 01
	00 00		 movzx	 eax, BYTE PTR [edx+260]
  002f9	83 c0 01	 add	 eax, 1
  002fc	50		 push	 eax
  002fd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00300	8b 11		 mov	 edx, DWORD PTR [ecx]
  00302	52		 push	 edx
  00303	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse
  00308	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 : 				lpObj->MapNumber = lpCallObj->MapNumber;

  0030b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030e	8b 4d f4	 mov	 ecx, DWORD PTR _lpCallObj$4[ebp]
  00311	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  00317	88 90 09 01 00
	00		 mov	 BYTE PTR [eax+265], dl

; 1628 : 				//LogAdd("위치 이동 %d %d", lpCallObj->X+1, lpCallObj->Y);
; 1629 : 				return;

  0031d	e9 63 04 00 00	 jmp	 $LN1@gObjMonste
$LN17@gObjMonste:

; 1630 : 			}
; 1631 : 		}
; 1632 : 	}
; 1633 : 
; 1634 : 	if( lpObj->m_ActState.Move )

  00322	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00325	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0032b	c1 e9 02	 shr	 ecx, 2
  0032e	83 e1 01	 and	 ecx, 1
  00331	74 40		 je	 SHORT $LN22@gObjMonste

; 1635 : 	{
; 1636 : 		if( PathFindMoveMsgSend(lpObj) == TRUE )

  00333	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 ?PathFindMoveMsgSend@@YAHPAVOBJECTSTRUCT@@@Z ; PathFindMoveMsgSend
  0033c	83 c4 04	 add	 esp, 4
  0033f	83 f8 01	 cmp	 eax, 1
  00342	75 15		 jne	 SHORT $LN24@gObjMonste

; 1637 : 		{
; 1638 : 			lpObj->m_ActState.Move = 0;			

  00344	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00347	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0034d	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00350	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00353	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN24@gObjMonste:

; 1639 : 		}
; 1640 : 		lpObj->m_ActState.Move = 0;

  00359	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035c	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00362	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00365	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00368	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1641 : 
; 1642 : 	}

  0036e	e9 12 04 00 00	 jmp	 $LN1@gObjMonste
$LN22@gObjMonste:

; 1643 : 	else if( lpObj->m_ActState.Attack == 1 )

  00373	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00376	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0037c	d1 e9		 shr	 ecx, 1
  0037e	83 e1 01	 and	 ecx, 1
  00381	0f 84 fe 03 00
	00		 je	 $LN1@gObjMonste

; 1644 : 	{
; 1645 : #ifdef ADD_RAKLION_20080408		// 라클리온 세루판은 공격을 모두 따로 처리하고 있다.
; 1646 : 		if( lpObj->Connected==3 && lpObj->Type==OBJTYPE_MONSTER && lpObj->Class==RAKLION_SELUPAN )
; 1647 : 			return;
; 1648 : #endif // ADD_RAKLION_20080408
; 1649 : 
; 1650 : #ifdef ADD_NEW_MONSTER_SYSTEM_01_20050714
; 1651 : 		// 아이다 몹 이상 부터 적용되는 몬스터 공격 시스템.(스킬 사용)
; 1652 : 		if( TMonsterSkillManager::CheckMonsterSkill(lpObj->Class) )
; 1653 : 		{
; 1654 : 			BOOL bEnableAttack = TRUE;
; 1655 : 			// 1) 타겟이 없을때.
; 1656 : 			if( lpObj->TargetNumber < 0 )
; 1657 : #ifdef MODIFY_TARGETNUMBER_RECALLMON_INDEX_BUFGIX_20080711
; 1658 : 			{
; 1659 : 				lpObj->TargetNumber			= -1;
; 1660 : 				lpObj->m_ActState.Emotion	= 0;
; 1661 : 				lpObj->m_ActState.Attack	= 0;
; 1662 : 				lpObj->m_ActState.Move		= 0;
; 1663 : 				lpObj->NextActionTime		= 1000;
; 1664 : 				return;
; 1665 : 			}
; 1666 : #else	// MODIFY_TARGETNUMBER_RECALLMON_INDEX_BUFGIX_20080711
; 1667 : 				bEnableAttack = FALSE;
; 1668 : #endif	// MODIFY_TARGETNUMBER_RECALLMON_INDEX_BUFGIX_20080711
; 1669 : 
; 1670 : 			// 1) 죽었고
; 1671 : 			// 2) 텔레포트 중일 때
; 1672 : 			if( !gObj[lpObj->TargetNumber].Live 
; 1673 : 				|| gObj[lpObj->TargetNumber].Teleport)
; 1674 : 			{
; 1675 : 				bEnableAttack = FALSE;
; 1676 : 			}
; 1677 : 
; 1678 : 			// 1) 게임 진행 중이 아니고,
; 1679 : 			// 2) 종료 중이고,
; 1680 : 			if( gObj[lpObj->TargetNumber].Connected <= 2 
; 1681 : 				|| gObj[lpObj->TargetNumber].CloseCount != -1 )
; 1682 : 			{
; 1683 : 				bEnableAttack = FALSE;
; 1684 : 			}
; 1685 : 
; 1686 : 			if( !bEnableAttack )
; 1687 : 			{
; 1688 : 				lpObj->TargetNumber			= -1;
; 1689 : 				lpObj->m_ActState.Emotion	= 0;
; 1690 : 				lpObj->m_ActState.Attack	= 0;
; 1691 : 				lpObj->m_ActState.Move		= 0;
; 1692 : 				lpObj->NextActionTime		= 1000;
; 1693 : 				return;
; 1694 : 			}
; 1695 : 
; 1696 : 			// 여기서 스킬매니저가 처리
; 1697 : 
; 1698 : 			// AI에서 스킬 처리!!!!!!!
; 1699 : 
; 1700 : 			// 1. 일반 공격
; 1701 : 			if( rand()% 4 == 0 )
; 1702 : 			{
; 1703 : 				PMSG_ATTACK pAttackMsg;
; 1704 : 				pAttackMsg.AttackAction = AT_ATTACK1;
; 1705 : 				pAttackMsg.DirDis       = lpObj->Dir;
; 1706 : 				pAttackMsg.NumberH		= HIBYTE(lpObj->TargetNumber);
; 1707 : 				pAttackMsg.NumberL		= LOBYTE(lpObj->TargetNumber);
; 1708 : 
; 1709 : #ifdef MODIFY_NEW_MONSTER_AI_01_2006724
; 1710 : 				//CGAttack(&pAttackMsg, lpObj->m_Index);
; 1711 : #else
; 1712 : 				CGAttack(&pAttackMsg, lpObj->m_Index);
; 1713 : #endif
; 1714 : 
; 1715 : #ifdef ADD_TRAP_OBJECT_EXTEND_20060731
; 1716 : 				GCActionSend(lpObj, AT_ATTACK1, lpObj->m_Index, lpObj->TargetNumber );
; 1717 : #else
; 1718 : 				GCActionSend(lpObj, AT_ATTACK1, lpObj->m_Index);
; 1719 : #endif // ADD_TRAP_OBJECT_EXTEND_20060731
; 1720 : 				
; 1721 : 				gObjAttack(lpObj, &gObj[lpObj->TargetNumber], NULL, 0, 0);
; 1722 : 			}
; 1723 : 			else
; 1724 : 			{
; 1725 : 				// 2. 몬스터 스킬 공격
; 1726 : 				TMonsterSkillManager::UseMonsterSkill( lpObj->m_Index, lpObj->TargetNumber, 0 );
; 1727 : 			}
; 1728 : 	
; 1729 : 			lpObj->m_ActState.Attack = 0;
; 1730 : 
; 1731 : 			return;
; 1732 : 		}
; 1733 : 		// 적용의 시작 부분.
; 1734 : #endif
; 1735 : 
; 1736 : 		int AttackType = lpObj->m_AttackType;

  00387	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0038a	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  00391	89 4d ec	 mov	 DWORD PTR _AttackType$2[ebp], ecx

; 1737 : 		int MagicAttack=0;

  00394	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _MagicAttack$1[ebp], 0

; 1738 : 
; 1739 : 		if( AttackType >= 100 )

  0039b	83 7d ec 64	 cmp	 DWORD PTR _AttackType$2[ebp], 100 ; 00000064H
  0039f	7c 2a		 jl	 SHORT $LN27@gObjMonste

; 1740 : 		{
; 1741 : 			if( (rand()%5) == 0 )	// 5 분의 1 확률로 마법공격

  003a1	e8 00 00 00 00	 call	 _rand
  003a6	99		 cdq
  003a7	b9 05 00 00 00	 mov	 ecx, 5
  003ac	f7 f9		 idiv	 ecx
  003ae	85 d2		 test	 edx, edx
  003b0	75 12		 jne	 SHORT $LN28@gObjMonste

; 1742 : 			{
; 1743 : 				AttackType -= 100;

  003b2	8b 45 ec	 mov	 eax, DWORD PTR _AttackType$2[ebp]
  003b5	83 e8 64	 sub	 eax, 100		; 00000064H
  003b8	89 45 ec	 mov	 DWORD PTR _AttackType$2[ebp], eax

; 1744 : 				MagicAttack = 1;

  003bb	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _MagicAttack$1[ebp], 1

; 1745 : 			}

  003c2	eb 07		 jmp	 SHORT $LN27@gObjMonste
$LN28@gObjMonste:

; 1746 : 			else 
; 1747 : 			{
; 1748 : 				AttackType = 0;

  003c4	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _AttackType$2[ebp], 0
$LN27@gObjMonste:

; 1749 : 			}
; 1750 : 		}
; 1751 : 
; 1752 : 		if( MagicAttack || lpObj->m_AttackType == 50 )

  003cb	83 7d e8 00	 cmp	 DWORD PTR _MagicAttack$1[ebp], 0
  003cf	75 13		 jne	 SHORT $LN32@gObjMonste
  003d1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d4	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  003db	83 f9 32	 cmp	 ecx, 50			; 00000032H
  003de	0f 85 be 01 00
	00		 jne	 $LN30@gObjMonste
$LN32@gObjMonste:

; 1753 : 		{
; 1754 : 			if( lpObj->TargetNumber >= 0 )

  003e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e7	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  003ee	85 c9		 test	 ecx, ecx
  003f0	0f 8c a7 01 00
	00		 jl	 $LN33@gObjMonste

; 1755 : 			{	
; 1756 : 				if( gObj[lpObj->TargetNumber].Connected > 2 && gObj[lpObj->TargetNumber].CloseCount == -1 )

  003f6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f9	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00400	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00406	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0040b	83 7c 10 04 02	 cmp	 DWORD PTR [eax+edx+4], 2
  00410	0f 8e 2b 01 00
	00		 jle	 $LN34@gObjMonste
  00416	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00419	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00420	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00426	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0042b	0f be 4c 10 0a	 movsx	 ecx, BYTE PTR [eax+edx+10]
  00430	83 f9 ff	 cmp	 ecx, -1
  00433	0f 85 08 01 00
	00		 jne	 $LN34@gObjMonste

; 1757 : 				{
; 1758 : 					if( !gObj[lpObj->TargetNumber].Live )

  00439	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0043c	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00443	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00449	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0044e	0f b6 4c 10 66	 movzx	 ecx, BYTE PTR [eax+edx+102]
  00453	85 c9		 test	 ecx, ecx
  00455	75 61		 jne	 SHORT $LN36@gObjMonste

; 1759 : 					{
; 1760 : 						lpObj->TargetNumber = -1;

  00457	83 c8 ff	 or	 eax, -1
  0045a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0045d	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 1761 : 						lpObj->m_ActState.Emotion = 0;

  00464	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00467	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0046d	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00473	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00476	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1762 : 						lpObj->m_ActState.Attack = 0;

  0047c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0047f	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00485	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00488	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0048b	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1763 : 						lpObj->m_ActState.Move = 0;

  00491	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00494	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0049a	83 e1 fb	 and	 ecx, -5			; fffffffbH
  0049d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004a0	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1764 : 						lpObj->NextActionTime =		1000;

  004a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004a9	c7 80 18 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+536], 1000 ; 000003e8H

; 1765 : 						//if( lpObj->m_Attribute == 100 )	LogAdd("상대가 죽었다.. 차분히 기다린다.");
; 1766 : 					}

  004b3	e9 87 00 00 00	 jmp	 $LN37@gObjMonste
$LN36@gObjMonste:

; 1767 : 					else {
; 1768 : 						if( !gObj[lpObj->TargetNumber].Teleport )

  004b8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004bb	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  004c2	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  004c8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004cd	0f be 8c 10 fc
	01 00 00	 movsx	 ecx, BYTE PTR [eax+edx+508]
  004d5	85 c9		 test	 ecx, ecx
  004d7	75 66		 jne	 SHORT $LN37@gObjMonste

; 1769 : 						{
; 1770 : 							gObjMonsterMagicAttack(lpObj);

  004d9	6a ff		 push	 -1
  004db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004de	50		 push	 eax
  004df	e8 00 00 00 00	 call	 ?gObjMonsterMagicAttack@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjMonsterMagicAttack
  004e4	83 c4 08	 add	 esp, 8

; 1771 : 
; 1772 : #ifdef MONSTER_HERD_SYSTEM_20031120
; 1773 : 							if (
; 1774 : 								lpObj->Type == OBJTYPE_MONSTER &&

  004e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004ea	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  004ee	83 f9 02	 cmp	 ecx, 2
  004f1	75 4c		 jne	 SHORT $LN37@gObjMonste
  004f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f6	83 b8 ec 0e 00
	00 00		 cmp	 DWORD PTR [eax+3820], 0
  004fd	74 40		 je	 SHORT $LN37@gObjMonste

; 1775 : 								lpObj->m_bIsInMonsterHerd
; 1776 : 								) 
; 1777 : 							{
; 1778 : 								if (lpObj->m_lpMonsterHerd != NULL)		// 무리에서 공격 시 행동을 지정할 때 이 메서드를 오버라이딩

  004ff	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00502	83 b8 f4 0e 00
	00 00		 cmp	 DWORD PTR [eax+3828], 0
  00509	74 34		 je	 SHORT $LN37@gObjMonste

; 1779 : 									lpObj->m_lpMonsterHerd->MonsterAttackAction(lpObj, &gObj[lpObj->TargetNumber]);

  0050b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0050e	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00515	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  0051b	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00521	52		 push	 edx
  00522	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00525	50		 push	 eax
  00526	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00529	8b 91 f4 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3828]
  0052f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00532	8b 12		 mov	 edx, DWORD PTR [edx]
  00534	8b 88 f4 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3828]
  0053a	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  0053d	ff d0		 call	 eax
$LN37@gObjMonste:

; 1780 : 							}
; 1781 : #endif
; 1782 : 						}
; 1783 : 					}					
; 1784 : 				}

  0053f	eb 5c		 jmp	 SHORT $LN33@gObjMonste
$LN34@gObjMonste:

; 1785 : 				else
; 1786 : 				{
; 1787 : 					lpObj->TargetNumber = -1;

  00541	83 c8 ff	 or	 eax, -1
  00544	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00547	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 1788 : 					lpObj->m_ActState.Emotion = 0;

  0054e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00551	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00557	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  0055d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00560	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1789 : 					lpObj->m_ActState.Attack = 0;

  00566	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00569	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0056f	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00572	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00575	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1790 : 					lpObj->m_ActState.Move = 0;

  0057b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057e	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00584	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00587	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0058a	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1791 : 					lpObj->NextActionTime = 1000;

  00590	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00593	c7 80 18 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+536], 1000 ; 000003e8H
$LN33@gObjMonste:

; 1792 : 				}
; 1793 : 			}
; 1794 : 		}

  0059d	e9 ce 01 00 00	 jmp	 $LN31@gObjMonste
$LN30@gObjMonste:

; 1795 : 		else
; 1796 : 		{
; 1797 : 			if( lpObj->TargetNumber >= 0 )

  005a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005a5	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  005ac	85 c9		 test	 ecx, ecx
  005ae	0f 8c bc 01 00
	00		 jl	 $LN31@gObjMonste

; 1798 : 			{	
; 1799 : 				if( gObj[lpObj->TargetNumber].Connected > 2 && gObj[lpObj->TargetNumber].CloseCount == -1 )

  005b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b7	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  005be	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  005c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c9	83 7c 10 04 02	 cmp	 DWORD PTR [eax+edx+4], 2
  005ce	0f 8e 40 01 00
	00		 jle	 $LN42@gObjMonste
  005d4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d7	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  005de	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  005e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005e9	0f be 4c 10 0a	 movsx	 ecx, BYTE PTR [eax+edx+10]
  005ee	83 f9 ff	 cmp	 ecx, -1
  005f1	0f 85 1d 01 00
	00		 jne	 $LN42@gObjMonste

; 1800 : 				{
; 1801 : 					if( !gObj[lpObj->TargetNumber].Live  )

  005f7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005fa	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00601	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00607	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0060c	0f b6 4c 10 66	 movzx	 ecx, BYTE PTR [eax+edx+102]
  00611	85 c9		 test	 ecx, ecx
  00613	75 61		 jne	 SHORT $LN44@gObjMonste

; 1802 : 					{
; 1803 : 						lpObj->TargetNumber = -1;

  00615	83 c8 ff	 or	 eax, -1
  00618	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0061b	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 1804 : 						lpObj->m_ActState.Emotion = 0;

  00622	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00625	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0062b	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00631	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00634	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1805 : 						lpObj->m_ActState.Attack = 0;

  0063a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0063d	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00643	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00646	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00649	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1806 : 						lpObj->m_ActState.Move = 0;

  0064f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00652	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00658	83 e1 fb	 and	 ecx, -5			; fffffffbH
  0065b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0065e	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1807 : 						lpObj->NextActionTime = 1000;

  00664	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00667	c7 80 18 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+536], 1000 ; 000003e8H

; 1808 : 						//if( lpObj->m_Attribute == 100 )	LogAdd("상대가 죽었다.. 차분히 기다린다.");
; 1809 : 					}

  00671	e9 9c 00 00 00	 jmp	 $LN45@gObjMonste
$LN44@gObjMonste:

; 1810 : 					else {
; 1811 : 						if( !gObj[lpObj->TargetNumber].Teleport )

  00676	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00679	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00680	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00686	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0068b	0f be 8c 10 fc
	01 00 00	 movsx	 ecx, BYTE PTR [eax+edx+508]
  00693	85 c9		 test	 ecx, ecx
  00695	75 7b		 jne	 SHORT $LN45@gObjMonste

; 1812 : 						{
; 1813 : 							gObjMonsterAttack(lpObj, &gObj[lpObj->TargetNumber]);

  00697	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0069a	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  006a1	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  006a7	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006ad	52		 push	 edx
  006ae	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b1	50		 push	 eax
  006b2	e8 00 00 00 00	 call	 ?gObjMonsterAttack@@YAXPAVOBJECTSTRUCT@@0@Z ; gObjMonsterAttack
  006b7	83 c4 08	 add	 esp, 8

; 1814 : 						
; 1815 : #ifdef MONSTER_HERD_SYSTEM_20031120
; 1816 : 							if (
; 1817 : 								lpObj->Type == OBJTYPE_MONSTER &&

  006ba	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006bd	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  006c1	83 f9 02	 cmp	 ecx, 2
  006c4	75 4c		 jne	 SHORT $LN45@gObjMonste
  006c6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006c9	83 b8 ec 0e 00
	00 00		 cmp	 DWORD PTR [eax+3820], 0
  006d0	74 40		 je	 SHORT $LN45@gObjMonste

; 1818 : 								lpObj->m_bIsInMonsterHerd
; 1819 : 								) 
; 1820 : 							{
; 1821 : 								if (lpObj->m_lpMonsterHerd != NULL)		// 무리에서 공격 시 행동을 지정할 때 이 메서드를 오버라이딩

  006d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006d5	83 b8 f4 0e 00
	00 00		 cmp	 DWORD PTR [eax+3828], 0
  006dc	74 34		 je	 SHORT $LN45@gObjMonste

; 1822 : 									lpObj->m_lpMonsterHerd->MonsterAttackAction(lpObj, &gObj[lpObj->TargetNumber]);

  006de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006e1	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  006e8	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  006ee	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006f4	52		 push	 edx
  006f5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006f8	50		 push	 eax
  006f9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006fc	8b 91 f4 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3828]
  00702	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00705	8b 12		 mov	 edx, DWORD PTR [edx]
  00707	8b 88 f4 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3828]
  0070d	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00710	ff d0		 call	 eax
$LN45@gObjMonste:

; 1823 : 							}
; 1824 : #endif						
; 1825 : 						}
; 1826 : 					}				
; 1827 : 				}

  00712	eb 5c		 jmp	 SHORT $LN31@gObjMonste
$LN42@gObjMonste:

; 1828 : 				else
; 1829 : 				{
; 1830 : 					lpObj->TargetNumber = -1;

  00714	83 c8 ff	 or	 eax, -1
  00717	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0071a	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 1831 : 					lpObj->m_ActState.Emotion = 0;

  00721	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00724	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  0072a	81 e1 0f ff ff
	ff		 and	 ecx, -241		; ffffff0fH
  00730	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00733	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1832 : 					lpObj->m_ActState.Attack = 0;

  00739	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0073c	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00742	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00745	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00748	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1833 : 					lpObj->m_ActState.Move = 0;

  0074e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00751	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00757	83 e1 fb	 and	 ecx, -5			; fffffffbH
  0075a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0075d	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx

; 1834 : 					lpObj->NextActionTime = 1000;

  00763	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00766	c7 80 18 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [eax+536], 1000 ; 000003e8H
$LN31@gObjMonste:

; 1835 : 				}
; 1836 : 			}
; 1837 : 		}
; 1838 : 		lpObj->m_ActState.Attack = 0;

  00770	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00773	8b 88 b0 01 00
	00		 mov	 ecx, DWORD PTR [eax+432]
  00779	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0077c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0077f	89 8a b0 01 00
	00		 mov	 DWORD PTR [edx+432], ecx
$LN1@gObjMonste:

; 1839 : 	}
; 1840 : 	else 
; 1841 : 	{
; 1842 : 
; 1843 : 	}
; 1844 : }

  00785	5f		 pop	 edi
  00786	5e		 pop	 esi
  00787	5b		 pop	 ebx
  00788	8b e5		 mov	 esp, ebp
  0078a	5d		 pop	 ebp
  0078b	c3		 ret	 0
?gObjMonsterProcess@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjMonsterProcess
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_MaxHitDamageUser$ = -8					; size = 4
_MaxHitDamage$ = -4					; size = 4
_lpMonObj$ = 8						; size = 4
?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z PROC ; gObjMonsterTopHitDamageUser, COMDAT

; 479  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 480  : //	int tObjNum;
; 481  : 	int MaxHitDamage=0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _MaxHitDamage$[ebp], 0

; 482  : 	int MaxHitDamageUser=-1;

  00010	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _MaxHitDamageUser$[ebp], -1

; 483  : 	
; 484  : 	for( int n=0; n<MAX_HITDAMAGE; n++)

  00017	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0001e	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  00020	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjMonste:
  00029	83 7d f4 28	 cmp	 DWORD PTR _n$1[ebp], 40	; 00000028H
  0002d	7d 4b		 jge	 SHORT $LN3@gObjMonste

; 485  : 	{
; 486  : 		if( lpMonObj->sHD[n].number >= 0 )

  0002f	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  00036	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  0003e	85 d2		 test	 edx, edx
  00040	7c 36		 jl	 SHORT $LN5@gObjMonste

; 487  : 		{
; 488  : 			if( lpMonObj->sHD[n].HitDamage > MaxHitDamage ) 

  00042	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  00049	8b 94 01 78 0a
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2680]
  00050	3b 55 fc	 cmp	 edx, DWORD PTR _MaxHitDamage$[ebp]
  00053	7e 23		 jle	 SHORT $LN5@gObjMonste

; 489  : 			{
; 490  : 				MaxHitDamage = lpMonObj->sHD[n].HitDamage;

  00055	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  0005c	8b 94 01 78 0a
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2680]
  00063	89 55 fc	 mov	 DWORD PTR _MaxHitDamage$[ebp], edx

; 491  : 				MaxHitDamageUser = lpMonObj->sHD[n].number;

  00066	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  0006d	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  00075	89 55 f8	 mov	 DWORD PTR _MaxHitDamageUser$[ebp], edx
$LN5@gObjMonste:

; 492  : 			}
; 493  : 		}
; 494  : 	}

  00078	eb a6		 jmp	 SHORT $LN2@gObjMonste
$LN3@gObjMonste:

; 495  : 	return MaxHitDamageUser;

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _MaxHitDamageUser$[ebp]

; 496  : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ENDP ; gObjMonsterTopHitDamageUser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
