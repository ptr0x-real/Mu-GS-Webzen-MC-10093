; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MultiAttackHackCheck.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CMultiAttackHackCheck@@QAE@XZ		; CMultiAttackHackCheck::CMultiAttackHackCheck
PUBLIC	??1CMultiAttackHackCheck@@UAE@XZ		; CMultiAttackHackCheck::~CMultiAttackHackCheck
PUBLIC	?Init@CMultiAttackHackCheck@@QAEXXZ		; CMultiAttackHackCheck::Init
PUBLIC	?Insert@CMultiAttackHackCheck@@QAEHHEE@Z	; CMultiAttackHackCheck::Insert
PUBLIC	?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z ; CMultiAttackHackCheck::CheckPenetrationSkill
PUBLIC	??_GCMultiAttackHackCheck@@UAEPAXI@Z		; CMultiAttackHackCheck::`scalar deleting destructor'
PUBLIC	??_7CMultiAttackHackCheck@@6B@			; CMultiAttackHackCheck::`vftable'
PUBLIC	?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
PUBLIC	??_R4CMultiAttackHackCheck@@6B@			; CMultiAttackHackCheck::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMultiAttackHackCheck@@@8		; CMultiAttackHackCheck `RTTI Type Descriptor'
PUBLIC	??_R3CMultiAttackHackCheck@@8			; CMultiAttackHackCheck::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMultiAttackHackCheck@@8			; CMultiAttackHackCheck::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMultiAttackHackCheck@@8		; CMultiAttackHackCheck::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memset:PROC
EXTRN	??_ECMultiAttackHackCheck@@UAEPAXI@Z:PROC	; CMultiAttackHackCheck::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
_BSS	SEGMENT
?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A DB 048e2fc0H DUP (?) ; gMultiAttackHackCheck
_BSS	ENDS
CRT$XCU	SEGMENT
?gMultiAttackHackCheck$initializer$@@3P6AXXZA DD FLAT:??__EgMultiAttackHackCheck@@YAXXZ ; gMultiAttackHackCheck$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CMultiAttackHackCheck@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMultiAttackHackCheck@@8 DD FLAT:??_R0?AVCMultiAttackHackCheck@@@8 ; CMultiAttackHackCheck::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMultiAttackHackCheck@@8
rdata$r	ENDS
;	COMDAT ??_R2CMultiAttackHackCheck@@8
rdata$r	SEGMENT
??_R2CMultiAttackHackCheck@@8 DD FLAT:??_R1A@?0A@EA@CMultiAttackHackCheck@@8 ; CMultiAttackHackCheck::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMultiAttackHackCheck@@8
rdata$r	SEGMENT
??_R3CMultiAttackHackCheck@@8 DD 00H			; CMultiAttackHackCheck::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMultiAttackHackCheck@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMultiAttackHackCheck@@@8
data$r	SEGMENT
??_R0?AVCMultiAttackHackCheck@@@8 DD FLAT:??_7type_info@@6B@ ; CMultiAttackHackCheck `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMultiAttackHackCheck@@', 00H
data$r	ENDS
;	COMDAT ??_R4CMultiAttackHackCheck@@6B@
rdata$r	SEGMENT
??_R4CMultiAttackHackCheck@@6B@ DD 00H			; CMultiAttackHackCheck::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMultiAttackHackCheck@@@8
	DD	FLAT:??_R3CMultiAttackHackCheck@@8
rdata$r	ENDS
;	COMDAT ??_7CMultiAttackHackCheck@@6B@
CONST	SEGMENT
??_7CMultiAttackHackCheck@@6B@ DD FLAT:??_R4CMultiAttackHackCheck@@6B@ ; CMultiAttackHackCheck::`vftable'
	DD	FLAT:??_ECMultiAttackHackCheck@@UAEPAXI@Z
CONST	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FgMultiAttackHackCheck@@YAXXZ
text$yd	SEGMENT
??__FgMultiAttackHackCheck@@YAXXZ PROC			; `dynamic atexit destructor for 'gMultiAttackHackCheck'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1CMultiAttackHackCheck@@UAE@XZ ; CMultiAttackHackCheck::~CMultiAttackHackCheck
  0000e	68 e8 1c 00 00	 push	 7400			; 00001ce8H
  00013	68 58 28 00 00	 push	 10328			; 00002858H
  00018	68 00 00 00 00	 push	 OFFSET ?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
  0001d	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??__FgMultiAttackHackCheck@@YAXXZ ENDP			; `dynamic atexit destructor for 'gMultiAttackHackCheck''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MultiAttackHackCheck.cpp
;	COMDAT ??__EgMultiAttackHackCheck@@YAXXZ
text$di	SEGMENT
??__EgMultiAttackHackCheck@@YAXXZ PROC			; `dynamic initializer for 'gMultiAttackHackCheck'', COMDAT

; 18   : CMultiAttackHackCheck	gMultiAttackHackCheck[MAX_OBJECT];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??1CMultiAttackHackCheck@@UAE@XZ ; CMultiAttackHackCheck::~CMultiAttackHackCheck
  0000e	68 00 00 00 00	 push	 OFFSET ??0CMultiAttackHackCheck@@QAE@XZ ; CMultiAttackHackCheck::CMultiAttackHackCheck
  00013	68 e8 1c 00 00	 push	 7400			; 00001ce8H
  00018	68 58 28 00 00	 push	 10328			; 00002858H
  0001d	68 00 00 00 00	 push	 OFFSET ?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
  00022	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00027	68 00 00 00 00	 push	 OFFSET ??__FgMultiAttackHackCheck@@YAXXZ ; `dynamic atexit destructor for 'gMultiAttackHackCheck''
  0002c	e8 00 00 00 00	 call	 _atexit
  00031	83 c4 04	 add	 esp, 4
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??__EgMultiAttackHackCheck@@YAXXZ ENDP			; `dynamic initializer for 'gMultiAttackHackCheck''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCMultiAttackHackCheck@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMultiAttackHackCheck@@UAEPAXI@Z PROC		; CMultiAttackHackCheck::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CMultiAttackHackCheck@@UAE@XZ ; CMultiAttackHackCheck::~CMultiAttackHackCheck
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 58 28 00 00	 push	 10328			; 00002858H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GCMultiAttackHackCheck@@UAEPAXI@Z ENDP		; CMultiAttackHackCheck::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MultiAttackHackCheck.cpp
;	COMDAT ?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_aTargetIndex$ = 8					; size = 4
_skillnum$ = 12						; size = 1
_serial$ = 16						; size = 1
?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z PROC ; CMultiAttackHackCheck::CheckPenetrationSkill, COMDAT
; _this$ = ecx

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 101  : 	//if( gObj[aTargetIndex].Type == OBJTYPE_MONSTER )
; 102  : 		//return TRUE;
; 103  : 
; 104  : 	if( skillnum != AT_SKILL_PENETRATION )

  0000c	0f b6 45 0c	 movzx	 eax, BYTE PTR _skillnum$[ebp]
  00010	83 f8 34	 cmp	 eax, 52			; 00000034H
  00013	74 0a		 je	 SHORT $LN5@CheckPenet

; 105  : 	{	// 아쿠아 플러시는 현재 시리얼이 안들어 오므로 무효... (클라이언트 수정후 적용해야 된다)
; 106  : 		return TRUE;

  00015	b8 01 00 00 00	 mov	 eax, 1
  0001a	e9 4c 01 00 00	 jmp	 $LN1@CheckPenet
$LN5@CheckPenet:

; 107  : 	}
; 108  : 	m_iCount;	
; 109  : 
; 110  : 	if( serial == 10 )

  0001f	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00023	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00026	75 08		 jne	 SHORT $LN6@CheckPenet

; 111  : 		Init();

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?Init@CMultiAttackHackCheck@@QAEXXZ ; CMultiAttackHackCheck::Init
$LN6@CheckPenet:

; 112  : 	
; 113  : 	for( int i = 0; i < MAHC_MAX_CHECKTABLE; i++ )

  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@CheckPenet
$LN2@CheckPenet:
  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@CheckPenet:
  00042	83 7d f8 28	 cmp	 DWORD PTR _i$1[ebp], 40	; 00000028H
  00046	0f 8d ae 00 00
	00		 jge	 $LN3@CheckPenet

; 114  : 	{
; 115  : 		if( m_Table[i].number == aTargetIndex )

  0004c	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  0005b	3b 55 08	 cmp	 edx, DWORD PTR _aTargetIndex$[ebp]
  0005e	0f 85 91 00 00
	00		 jne	 $LN7@CheckPenet

; 116  : 		{
; 117  : 			if( serial == 10 && m_Table[i].Serial[serial] )

  00064	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00068	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0006b	75 39		 jne	 SHORT $LN8@CheckPenet
  0006d	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  0007b	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  0007f	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  00084	85 c9		 test	 ecx, ecx
  00086	74 1e		 je	 SHORT $LN8@CheckPenet

; 118  : 			{	// 한바퀴 돌면 초기화 해 준다
; 119  : 				memset(m_Table[i].Serial, 0x00, MAHC_MAX_SERIAL);

  00088	68 ff 00 00 00	 push	 255			; 000000ffH
  0008d	6a 00		 push	 0
  0008f	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  00096	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _memset
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CheckPenet:

; 120  : 			}	
; 121  : 
; 122  : 			m_Table[i].Serial[serial]++;

  000a6	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  000aa	69 4d f8 02 01
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 258
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b4	8d 4c 0a 08	 lea	 ecx, DWORD PTR [edx+ecx+8]
  000b8	8a 54 01 02	 mov	 dl, BYTE PTR [ecx+eax+2]
  000bc	80 c2 01	 add	 dl, 1
  000bf	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  000c3	69 4d f8 02 01
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 258
  000ca	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  000cd	8d 4c 0e 08	 lea	 ecx, DWORD PTR [esi+ecx+8]
  000d1	88 54 01 02	 mov	 BYTE PTR [ecx+eax+2], dl

; 123  : 			if( m_Table[i].Serial[serial]  > 1 )

  000d5	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  000e3	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  000e7	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  000ec	83 f9 01	 cmp	 ecx, 1
  000ef	7e 04		 jle	 SHORT $LN7@CheckPenet

; 124  : 			{	// 같은 캐릭터에게 같은 시리얼의 번호의 공격을 3번이상 받았다.
; 125  : #if TESTSERVER == 1
; 126  : 				LogAddC(LOGC_LIGHTRED, "Serial:%d,%d", serial, m_Table[i].Serial[serial]);
; 127  : #endif
; 128  : 				return FALSE;

  000f1	33 c0		 xor	 eax, eax
  000f3	eb 76		 jmp	 SHORT $LN1@CheckPenet
$LN7@CheckPenet:

; 129  : 			}			
; 130  : 		}
; 131  : 	}

  000f5	e9 3f ff ff ff	 jmp	 $LN2@CheckPenet
$LN3@CheckPenet:

; 132  : 
; 133  : 	m_Table[m_iCount].number = aTargetIndex;

  000fa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	69 48 04 02 01
	00 00		 imul	 ecx, DWORD PTR [eax+4], 258
  00104	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00107	66 8b 45 08	 mov	 ax, WORD PTR _aTargetIndex$[ebp]
  0010b	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 134  : 	m_Table[m_iCount].Serial[serial]++;

  00110	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00114	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	69 51 04 02 01
	00 00		 imul	 edx, DWORD PTR [ecx+4], 258
  0011e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	8d 54 11 08	 lea	 edx, DWORD PTR [ecx+edx+8]
  00125	8a 44 02 02	 mov	 al, BYTE PTR [edx+eax+2]
  00129	04 01		 add	 al, 1
  0012b	0f b6 4d 10	 movzx	 ecx, BYTE PTR _serial$[ebp]
  0012f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00132	69 52 04 02 01
	00 00		 imul	 edx, DWORD PTR [edx+4], 258
  00139	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0013c	8d 54 16 08	 lea	 edx, DWORD PTR [esi+edx+8]
  00140	88 44 0a 02	 mov	 BYTE PTR [edx+ecx+2], al

; 135  : 
; 136  : 	//LogAddC(LOGC_BLUE, "Serial:%d,%d", serial,m_Table[m_iCount].Serial[serial]);
; 137  : 
; 138  : 	m_iCount++;

  00144	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00147	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014a	83 c1 01	 add	 ecx, 1
  0014d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00150	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 139  : 	if( m_iCount >= MAHC_MAX_CHECKTABLE )

  00153	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00156	83 78 04 28	 cmp	 DWORD PTR [eax+4], 40	; 00000028H
  0015a	7c 0a		 jl	 SHORT $LN10@CheckPenet

; 140  : 	{
; 141  : 		m_iCount = 0;

  0015c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN10@CheckPenet:

; 142  : 	}
; 143  : 	return TRUE;

  00166	b8 01 00 00 00	 mov	 eax, 1
$LN1@CheckPenet:

; 144  : }

  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 0c 00	 ret	 12			; 0000000cH
?CheckPenetrationSkill@CMultiAttackHackCheck@@QAEHHEE@Z ENDP ; CMultiAttackHackCheck::CheckPenetrationSkill
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MultiAttackHackCheck.cpp
;	COMDAT ?Insert@CMultiAttackHackCheck@@QAEHHEE@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_aTargetIndex$ = 8					; size = 4
_skillnum$ = 12						; size = 1
_serial$ = 16						; size = 1
?Insert@CMultiAttackHackCheck@@QAEHHEE@Z PROC		; CMultiAttackHackCheck::Insert, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 	if( gObj[aTargetIndex].Type == OBJTYPE_MONSTER || serial < 0 || serial > MAHC_MAX_SERIAL-1 )

  0000c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00019	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0001e	83 fa 02	 cmp	 edx, 2
  00021	74 13		 je	 SHORT $LN6@Insert
  00023	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	7c 0b		 jl	 SHORT $LN6@Insert
  0002b	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  0002f	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00034	7e 0a		 jle	 SHORT $LN5@Insert
$LN6@Insert:

; 44   : 		return TRUE;

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	e9 7e 01 00 00	 jmp	 $LN1@Insert
$LN5@Insert:

; 45   : 
; 46   : 	if( skillnum == 12 )

  00040	0f b6 45 0c	 movzx	 eax, BYTE PTR _skillnum$[ebp]
  00044	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00047	75 0a		 jne	 SHORT $LN7@Insert

; 47   : 	{	// 아쿠아 플러시는 현재 시리얼이 안들어 오므로 무효... (클라이언트 수정후 적용해야 된다)
; 48   : 		return TRUE;

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	e9 6b 01 00 00	 jmp	 $LN1@Insert
$LN7@Insert:

; 49   : 	}
; 50   : 	m_iCount;
; 51   : 	
; 52   : 	for( int i = 0; i < MAHC_MAX_CHECKTABLE; i++ )

  00053	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0005a	eb 09		 jmp	 SHORT $LN4@Insert
$LN2@Insert:
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005f	83 c0 01	 add	 eax, 1
  00062	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Insert:
  00065	83 7d f8 28	 cmp	 DWORD PTR _i$1[ebp], 40	; 00000028H
  00069	0f 8d de 00 00
	00		 jge	 $LN3@Insert

; 53   : 	{
; 54   : 		if( m_Table[i].number == aTargetIndex )

  0006f	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	0f bf 54 01 08	 movsx	 edx, WORD PTR [ecx+eax+8]
  0007e	3b 55 08	 cmp	 edx, DWORD PTR _aTargetIndex$[ebp]
  00081	0f 85 c1 00 00
	00		 jne	 $LN8@Insert

; 55   : 		{
; 56   : 			if( serial == MAHC_MAX_SERIAL-1 && m_Table[i].Serial[serial] )

  00087	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  0008b	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00090	75 39		 jne	 SHORT $LN9@Insert
  00092	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  000a0	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  000a4	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 1e		 je	 SHORT $LN9@Insert

; 57   : 			{	// 한바퀴 돌면 초기화 해 준다
; 58   : 				memset(m_Table[i].Serial, 0x00, MAHC_MAX_SERIAL);

  000ad	68 ff 00 00 00	 push	 255			; 000000ffH
  000b2	6a 00		 push	 0
  000b4	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _memset
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@Insert:

; 59   : 			}	
; 60   : 
; 61   : 			m_Table[i].Serial[serial]++;

  000cb	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  000cf	69 4d f8 02 01
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 258
  000d6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d9	8d 4c 0a 08	 lea	 ecx, DWORD PTR [edx+ecx+8]
  000dd	8a 54 01 02	 mov	 dl, BYTE PTR [ecx+eax+2]
  000e1	80 c2 01	 add	 dl, 1
  000e4	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  000e8	69 4d f8 02 01
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 258
  000ef	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  000f2	8d 4c 0e 08	 lea	 ecx, DWORD PTR [esi+ecx+8]
  000f6	88 54 01 02	 mov	 BYTE PTR [ecx+eax+2], dl

; 62   : 
; 63   : 			if( skillnum == 9 )

  000fa	0f b6 45 0c	 movzx	 eax, BYTE PTR _skillnum$[ebp]
  000fe	83 f8 09	 cmp	 eax, 9
  00101	75 25		 jne	 SHORT $LN10@Insert

; 64   : 			{	// 악령은 8개가 하나의 시리얼을 가진다(-_-;;)
; 65   : 				if( m_Table[i].Serial[serial]  > 6 )

  00103	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  0010a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00111	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00115	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  0011a	83 f9 06	 cmp	 ecx, 6
  0011d	7e 07		 jle	 SHORT $LN12@Insert

; 66   : 				{	
; 67   : #if TESTSERVER == 1
; 68   : 					LogAddTD("Error: %d, %d, %d", skillnum, serial, m_Table[i].Serial[serial]);
; 69   : #endif
; 70   : 					return FALSE;

  0011f	33 c0		 xor	 eax, eax
  00121	e9 98 00 00 00	 jmp	 $LN1@Insert
$LN12@Insert:

; 71   : 				}
; 72   : 			}

  00126	eb 20		 jmp	 SHORT $LN8@Insert
$LN10@Insert:

; 73   : 			else
; 74   : 			{
; 75   : 				if( m_Table[i].Serial[serial]  > 6 )

  00128	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  0012f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00132	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00136	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  0013a	0f b6 4c 02 02	 movzx	 ecx, BYTE PTR [edx+eax+2]
  0013f	83 f9 06	 cmp	 ecx, 6
  00142	7e 04		 jle	 SHORT $LN8@Insert

; 76   : 				{	// 같은 캐릭터에게 같은 시리얼의 번호의 공격을 3번이상 받았다.
; 77   : #if TESTSERVER == 1
; 78   : 					LogAddTD("Error: %d, %d, %d", skillnum, serial, m_Table[i].Serial[serial]);
; 79   : #endif
; 80   : 					return FALSE;

  00144	33 c0		 xor	 eax, eax
  00146	eb 76		 jmp	 SHORT $LN1@Insert
$LN8@Insert:

; 81   : 				}
; 82   : 			}
; 83   : 		}
; 84   : 	}

  00148	e9 0f ff ff ff	 jmp	 $LN2@Insert
$LN3@Insert:

; 85   : 
; 86   : 	m_Table[m_iCount].number = aTargetIndex;

  0014d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00150	69 48 04 02 01
	00 00		 imul	 ecx, DWORD PTR [eax+4], 258
  00157	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0015a	66 8b 45 08	 mov	 ax, WORD PTR _aTargetIndex$[ebp]
  0015e	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 87   : 	m_Table[m_iCount].Serial[serial]++;

  00163	0f b6 45 10	 movzx	 eax, BYTE PTR _serial$[ebp]
  00167	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	69 51 04 02 01
	00 00		 imul	 edx, DWORD PTR [ecx+4], 258
  00171	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	8d 54 11 08	 lea	 edx, DWORD PTR [ecx+edx+8]
  00178	8a 44 02 02	 mov	 al, BYTE PTR [edx+eax+2]
  0017c	04 01		 add	 al, 1
  0017e	0f b6 4d 10	 movzx	 ecx, BYTE PTR _serial$[ebp]
  00182	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00185	69 52 04 02 01
	00 00		 imul	 edx, DWORD PTR [edx+4], 258
  0018c	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0018f	8d 54 16 08	 lea	 edx, DWORD PTR [esi+edx+8]
  00193	88 44 0a 02	 mov	 BYTE PTR [edx+ecx+2], al

; 88   : 
; 89   : 	m_iCount++;

  00197	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0019d	83 c1 01	 add	 ecx, 1
  001a0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001a3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 90   : 	if( m_iCount >= MAHC_MAX_CHECKTABLE )

  001a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a9	83 78 04 28	 cmp	 DWORD PTR [eax+4], 40	; 00000028H
  001ad	7c 0a		 jl	 SHORT $LN14@Insert

; 91   : 	{
; 92   : 		m_iCount = 0;

  001af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN14@Insert:

; 93   : 	}
; 94   : 	return TRUE;

  001b9	b8 01 00 00 00	 mov	 eax, 1
$LN1@Insert:

; 95   : }

  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5b		 pop	 ebx
  001c1	8b e5		 mov	 esp, ebp
  001c3	5d		 pop	 ebp
  001c4	c2 0c 00	 ret	 12			; 0000000cH
?Insert@CMultiAttackHackCheck@@QAEHHEE@Z ENDP		; CMultiAttackHackCheck::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MultiAttackHackCheck.cpp
;	COMDAT ?Init@CMultiAttackHackCheck@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?Init@CMultiAttackHackCheck@@QAEXXZ PROC		; CMultiAttackHackCheck::Init, COMDAT
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 32   : 	m_iCount = 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 33   : 
; 34   : 	for( int i = 0; i < MAHC_MAX_CHECKTABLE; i++ )

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN4@Init
$LN2@Init:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Init:
  00028	83 7d f8 28	 cmp	 DWORD PTR _i$1[ebp], 40	; 00000028H
  0002c	7d 32		 jge	 SHORT $LN1@Init

; 35   : 	{
; 36   : 		m_Table[i].number = -1;

  0002e	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  00035	83 c9 ff	 or	 ecx, -1
  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx

; 37   : 		memset(m_Table[i].Serial, 0x00, MAHC_MAX_SERIAL);

  00040	68 ff 00 00 00	 push	 255			; 000000ffH
  00045	6a 00		 push	 0
  00047	69 45 f8 02 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 258
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8d 54 01 0a	 lea	 edx, DWORD PTR [ecx+eax+10]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 _memset
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 38   : 	}

  0005e	eb bf		 jmp	 SHORT $LN2@Init
$LN1@Init:

; 39   : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?Init@CMultiAttackHackCheck@@QAEXXZ ENDP		; CMultiAttackHackCheck::Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MultiAttackHackCheck.cpp
;	COMDAT ??1CMultiAttackHackCheck@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMultiAttackHackCheck@@UAE@XZ PROC			; CMultiAttackHackCheck::~CMultiAttackHackCheck, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMultiAttackHackCheck@@6B@

; 27   : 
; 28   : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CMultiAttackHackCheck@@UAE@XZ ENDP			; CMultiAttackHackCheck::~CMultiAttackHackCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MultiAttackHackCheck.cpp
;	COMDAT ??0CMultiAttackHackCheck@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMultiAttackHackCheck@@QAE@XZ PROC			; CMultiAttackHackCheck::CMultiAttackHackCheck, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMultiAttackHackCheck@@6B@

; 22   : 	Init();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?Init@CMultiAttackHackCheck@@QAEXXZ ; CMultiAttackHackCheck::Init

; 23   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0CMultiAttackHackCheck@@QAE@XZ ENDP			; CMultiAttackHackCheck::CMultiAttackHackCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MultiAttackHackCheck.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MultiAttackHackCheck.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
