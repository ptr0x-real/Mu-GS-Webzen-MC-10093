; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?CheckTerrain@CTerrainManager@@QAE_NH@Z		; CTerrainManager::CheckTerrain
PUBLIC	?FindIndex@CMoveCommand@@AAEHPAD@Z		; CMoveCommand::FindIndex
PUBLIC	??0CMoveCommand@@QAE@XZ				; CMoveCommand::CMoveCommand
PUBLIC	??1CMoveCommand@@UAE@XZ				; CMoveCommand::~CMoveCommand
PUBLIC	?Init@CMoveCommand@@QAEXXZ			; CMoveCommand::Init
PUBLIC	?Load@CMoveCommand@@QAEHPAD@Z			; CMoveCommand::Load
PUBLIC	?LoadMoveLevel@CMoveCommand@@QAEHPAD@Z		; CMoveCommand::LoadMoveLevel
PUBLIC	?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z		; CMoveCommand::GetMoveLevel
PUBLIC	?CheckMainToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z ; CMoveCommand::CheckMainToMove
PUBLIC	?CheckEquipmentToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove
PUBLIC	?CheckInterfaceToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
PUBLIC	?Move@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@PAD@Z	; CMoveCommand::Move
PUBLIC	?MoveFree2Kalima@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z ; CMoveCommand::MoveFree2Kalima
PUBLIC	??_GCMoveCommand@@UAEPAXI@Z			; CMoveCommand::`scalar deleting destructor'
PUBLIC	?GetKalimaGateLevel@@YAHPAVOBJECTSTRUCT@@@Z	; GetKalimaGateLevel
PUBLIC	??_7CMoveCommand@@6B@				; CMoveCommand::`vftable'
PUBLIC	?gMoveCommand@@3VCMoveCommand@@A		; gMoveCommand
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0BP@OIMJHLAA@MoveCommand?5?$CFs?5File?5Load?5Error@ ; `string'
PUBLIC	??_C@_0BN@DLJJBGJJ@MoveCommand?5script?5load?5fail@ ; `string'
PUBLIC	??_C@_0BN@FOCHKGPP@MoveLevel?5?$CFs?5File?5Load?5Error@ ; `string'
PUBLIC	??_C@_0BL@MDABMPEB@MoveLevel?5script?5load?5fail@ ; `string'
PUBLIC	??_C@_0CO@EGHEKHC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Move?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5@ ; `string'
PUBLIC	??_C@_0CC@CALMLEOA@Necesitas?5ser?5minimo?5nivel?5VIP?5@ ; `string'
PUBLIC	??_C@_0CB@ODKFONDI@Necesitas?5minimo?5tener?5?$CFd?5Reset@ ; `string'
PUBLIC	??_C@_0DF@GFFIBCDJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Success?5?3?5@ ; `string'
PUBLIC	??_C@_0CJ@FKMIFCDG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Fail?5MapNu@ ; `string'
PUBLIC	??_R4CMoveCommand@@6B@				; CMoveCommand::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMoveCommand@@@8			; CMoveCommand `RTTI Type Descriptor'
PUBLIC	??_R3CMoveCommand@@8				; CMoveCommand::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMoveCommand@@8				; CMoveCommand::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMoveCommand@@8			; CMoveCommand::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	__stricmp:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_atof:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?gObjMovePlayer@@YAHHEEEEE@Z:PROC		; gObjMovePlayer
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCRecallMonLife@@YAXHHH@Z:PROC			; GCRecallMonLife
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	??_ECMoveCommand@@UAEPAXI@Z:PROC		; CMoveCommand::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?g_TerrainManager@@3VCTerrainManager@@A:BYTE	; g_TerrainManager
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
?gMoveCommand@@3VCMoveCommand@@A DB 03e84H DUP (?)	; gMoveCommand
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CMoveCommand@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMoveCommand@@8 DD FLAT:??_R0?AVCMoveCommand@@@8 ; CMoveCommand::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMoveCommand@@8
rdata$r	ENDS
;	COMDAT ??_R2CMoveCommand@@8
rdata$r	SEGMENT
??_R2CMoveCommand@@8 DD FLAT:??_R1A@?0A@EA@CMoveCommand@@8 ; CMoveCommand::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMoveCommand@@8
rdata$r	SEGMENT
??_R3CMoveCommand@@8 DD 00H				; CMoveCommand::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMoveCommand@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMoveCommand@@@8
data$r	SEGMENT
??_R0?AVCMoveCommand@@@8 DD FLAT:??_7type_info@@6B@	; CMoveCommand `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMoveCommand@@', 00H
data$r	ENDS
;	COMDAT ??_R4CMoveCommand@@6B@
rdata$r	SEGMENT
??_R4CMoveCommand@@6B@ DD 00H				; CMoveCommand::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMoveCommand@@@8
	DD	FLAT:??_R3CMoveCommand@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CJ@FKMIFCDG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Fail?5MapNu@
CONST	SEGMENT
??_C@_0CJ@FKMIFCDG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Fail?5MapNu@ DB '['
	DB	'%s][%s] Use [%s %s] Fail MapNumber = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GFFIBCDJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Success?5?3?5@
CONST	SEGMENT
??_C@_0DF@GFFIBCDJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Success?5?3?5@ DB '['
	DB	'%s][%s] Use [%s %s] Success : reduces money %d - %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ODKFONDI@Necesitas?5minimo?5tener?5?$CFd?5Reset@
CONST	SEGMENT
??_C@_0CB@ODKFONDI@Necesitas?5minimo?5tener?5?$CFd?5Reset@ DB 'Necesitas '
	DB	'minimo tener %d Resets', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CALMLEOA@Necesitas?5ser?5minimo?5nivel?5VIP?5@
CONST	SEGMENT
??_C@_0CC@CALMLEOA@Necesitas?5ser?5minimo?5nivel?5VIP?5@ DB 'Necesitas se'
	DB	'r minimo nivel VIP %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EGHEKHC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Move?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5@
CONST	SEGMENT
??_C@_0CO@EGHEKHC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Move?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5@ DB '['
	DB	'%s][%s] Use Move [%d][%d][%d] - [%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MDABMPEB@MoveLevel?5script?5load?5fail@
CONST	SEGMENT
??_C@_0BL@MDABMPEB@MoveLevel?5script?5load?5fail@ DB 'MoveLevel script lo'
	DB	'ad fail', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FOCHKGPP@MoveLevel?5?$CFs?5File?5Load?5Error@
CONST	SEGMENT
??_C@_0BN@FOCHKGPP@MoveLevel?5?$CFs?5File?5Load?5Error@ DB 'MoveLevel %s '
	DB	'File Load Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DLJJBGJJ@MoveCommand?5script?5load?5fail@
CONST	SEGMENT
??_C@_0BN@DLJJBGJJ@MoveCommand?5script?5load?5fail@ DB 'MoveCommand scrip'
	DB	't load fail', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OIMJHLAA@MoveCommand?5?$CFs?5File?5Load?5Error@
CONST	SEGMENT
??_C@_0BP@OIMJHLAA@MoveCommand?5?$CFs?5File?5Load?5Error@ DB 'MoveCommand'
	DB	' %s File Load Error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A DD 0fH	; g_sttKALIMAGATE_LEVEL
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
_DATA	ENDS
;	COMDAT ??_7CMoveCommand@@6B@
CONST	SEGMENT
??_7CMoveCommand@@6B@ DD FLAT:??_R4CMoveCommand@@6B@	; CMoveCommand::`vftable'
	DD	FLAT:??_ECMoveCommand@@UAEPAXI@Z
CONST	ENDS
CRT$XCU	SEGMENT
?gMoveCommand$initializer$@@3P6AXXZA DD FLAT:??__EgMoveCommand@@YAXXZ ; gMoveCommand$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?GetKalimaGateLevel@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iLevel$1 = -8						; size = 4
_iLevel$2 = -4						; size = 4
_lpObj$ = 8						; size = 4
?GetKalimaGateLevel@@YAHPAVOBJECTSTRUCT@@@Z PROC	; GetKalimaGateLevel, COMDAT

; 1068 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1069 : 	if (lpObj->Class == CLASS_MAGUMSA || lpObj->Class == CLASS_DARKLORD) 

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00013	83 f9 03	 cmp	 ecx, 3
  00016	74 0f		 je	 SHORT $LN10@GetKalimaG
  00018	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00022	83 f9 04	 cmp	 ecx, 4
  00025	75 51		 jne	 SHORT $LN8@GetKalimaG
$LN10@GetKalimaG:

; 1070 : 	{
; 1071 : 		for (int iLevel = 0 ; iLevel < MAX_KALIMAGATE_COUNT ; iLevel++) 

  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _iLevel$2[ebp], 0
  0002e	eb 09		 jmp	 SHORT $LN4@GetKalimaG
$LN2@GetKalimaG:
  00030	8b 45 fc	 mov	 eax, DWORD PTR _iLevel$2[ebp]
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 fc	 mov	 DWORD PTR _iLevel$2[ebp], eax
$LN4@GetKalimaG:
  00039	83 7d fc 06	 cmp	 DWORD PTR _iLevel$2[ebp], 6
  0003d	7d 37		 jge	 SHORT $LN3@GetKalimaG

; 1072 : 		{
; 1073 : 			if ( (lpObj->Level >= g_sttKALIMAGATE_LEVEL[iLevel].iLOWER_BOUND_MAGUMSA) && (lpObj->Level <= g_sttKALIMAGATE_LEVEL[iLevel].iUPPER_BOUND_MAGUMSA))

  0003f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00042	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00049	8b 55 fc	 mov	 edx, DWORD PTR _iLevel$2[ebp]
  0004c	c1 e2 04	 shl	 edx, 4
  0004f	3b 8a 08 00 00
	00		 cmp	 ecx, DWORD PTR ?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A[edx+8]
  00055	7c 1d		 jl	 SHORT $LN11@GetKalimaG
  00057	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005a	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00061	8b 55 fc	 mov	 edx, DWORD PTR _iLevel$2[ebp]
  00064	c1 e2 04	 shl	 edx, 4
  00067	3b 8a 0c 00 00
	00		 cmp	 ecx, DWORD PTR ?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A[edx+12]
  0006d	7f 05		 jg	 SHORT $LN11@GetKalimaG

; 1074 : 				return iLevel;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _iLevel$2[ebp]
  00072	eb 56		 jmp	 SHORT $LN1@GetKalimaG
$LN11@GetKalimaG:

; 1075 : 		}

  00074	eb ba		 jmp	 SHORT $LN2@GetKalimaG
$LN3@GetKalimaG:

; 1076 : 	}

  00076	eb 4f		 jmp	 SHORT $LN9@GetKalimaG
$LN8@GetKalimaG:

; 1077 : 	else 
; 1078 : 	{
; 1079 : 		for (int iLevel = 0 ; iLevel < MAX_KALIMAGATE_COUNT ; iLevel++) 

  00078	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iLevel$1[ebp], 0
  0007f	eb 09		 jmp	 SHORT $LN7@GetKalimaG
$LN5@GetKalimaG:
  00081	8b 45 f8	 mov	 eax, DWORD PTR _iLevel$1[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 f8	 mov	 DWORD PTR _iLevel$1[ebp], eax
$LN7@GetKalimaG:
  0008a	83 7d f8 06	 cmp	 DWORD PTR _iLevel$1[ebp], 6
  0008e	7d 37		 jge	 SHORT $LN9@GetKalimaG

; 1080 : 		{
; 1081 : 			if ( (lpObj->Level >= g_sttKALIMAGATE_LEVEL[iLevel].iLOWER_BOUND) && (lpObj->Level <= g_sttKALIMAGATE_LEVEL[iLevel].iUPPER_BOUND))

  00090	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00093	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0009a	8b 55 f8	 mov	 edx, DWORD PTR _iLevel$1[ebp]
  0009d	c1 e2 04	 shl	 edx, 4
  000a0	3b 8a 00 00 00
	00		 cmp	 ecx, DWORD PTR ?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A[edx]
  000a6	7c 1d		 jl	 SHORT $LN12@GetKalimaG
  000a8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ab	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000b2	8b 55 f8	 mov	 edx, DWORD PTR _iLevel$1[ebp]
  000b5	c1 e2 04	 shl	 edx, 4
  000b8	3b 8a 04 00 00
	00		 cmp	 ecx, DWORD PTR ?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A[edx+4]
  000be	7f 05		 jg	 SHORT $LN12@GetKalimaG

; 1082 : 				return iLevel;

  000c0	8b 45 f8	 mov	 eax, DWORD PTR _iLevel$1[ebp]
  000c3	eb 05		 jmp	 SHORT $LN1@GetKalimaG
$LN12@GetKalimaG:

; 1083 : 		}

  000c5	eb ba		 jmp	 SHORT $LN5@GetKalimaG
$LN9@GetKalimaG:

; 1084 : 	}
; 1085 : 	
; 1086 : 	return -1;

  000c7	83 c8 ff	 or	 eax, -1
$LN1@GetKalimaG:

; 1087 : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
?GetKalimaGateLevel@@YAHPAVOBJECTSTRUCT@@@Z ENDP	; GetKalimaGateLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FgMoveCommand@@YAXXZ
text$yd	SEGMENT
??__FgMoveCommand@@YAXXZ PROC				; `dynamic atexit destructor for 'gMoveCommand'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  0000e	e8 00 00 00 00	 call	 ??1CMoveCommand@@UAE@XZ	; CMoveCommand::~CMoveCommand
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FgMoveCommand@@YAXXZ ENDP				; `dynamic atexit destructor for 'gMoveCommand''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ??__EgMoveCommand@@YAXXZ
text$di	SEGMENT
??__EgMoveCommand@@YAXXZ PROC				; `dynamic initializer for 'gMoveCommand'', COMDAT

; 64   : CMoveCommand	gMoveCommand;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  0000e	e8 00 00 00 00	 call	 ??0CMoveCommand@@QAE@XZ	; CMoveCommand::CMoveCommand
  00013	68 00 00 00 00	 push	 OFFSET ??__FgMoveCommand@@YAXXZ ; `dynamic atexit destructor for 'gMoveCommand''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EgMoveCommand@@YAXXZ ENDP				; `dynamic initializer for 'gMoveCommand''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1번 캐슬 - 축석

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1번 캐슬 - 영석

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2번 캐슬 - 축석

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2번 캐슬 - 영석

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3번 캐슬 - 축석

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3번 캐슬 - 영석

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4번 캐슬 - 축석

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4번 캐슬 - 영석

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5번 캐슬 - 축석

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5번 캐슬 - 영석

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6번 캐슬 - 축석

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6번 캐슬 - 영석

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCMoveCommand@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMoveCommand@@UAEPAXI@Z PROC			; CMoveCommand::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CMoveCommand@@UAE@XZ	; CMoveCommand::~CMoveCommand
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 84 3e 00 00	 push	 16004			; 00003e84H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GCMoveCommand@@UAEPAXI@Z ENDP			; CMoveCommand::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?MoveFree2Kalima@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iGateNumber$ = -12					; size = 4
_iIdx$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?MoveFree2Kalima@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z PROC ; CMoveCommand::MoveFree2Kalima, COMDAT
; _this$ = ecx

; 1199 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1200 : 	int iIdx = GetKalimaGateLevel( lpObj );	

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?GetKalimaGateLevel@@YAHPAVOBJECTSTRUCT@@@Z ; GetKalimaGateLevel
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR _iIdx$[ebp], eax

; 1201 : 
; 1202 : #ifndef PCBANG_FREE_KALIMA_EVENT_20060124
; 1203 : 
; 1204 : #ifdef HIDDEN_KALIMA_20050706
; 1205 : 	
; 1206 : #ifdef MODIFY_KALIMAMOVE_COMMAND_FOR_BLUEPOUCH_20050811
; 1207 : 	// 히든 칼리마는 못들어간다.
; 1208 : 	if( iIdx >= MAX_KALIMAGATE_COUNT - 1 )
; 1209 : 	{
; 1210 : 		// 바로 아래 단계 칼리마(6칼리마로 이동)
; 1211 : 		iIdx = MAX_KALIMAGATE_COUNT - 2;
; 1212 : 	}
; 1213 : #endif // MODIFY_KALIMAMOVE_COMMAND_FOR_BLUEPOUCH_20050811
; 1214 : 
; 1215 : #endif // HIDDEN_KALIMA_20050706
; 1216 : 
; 1217 : #endif // PCBANG_FREE_KALIMA_EVENT_20060124
; 1218 : 	
; 1219 : 	if (iIdx < 0) return FALSE;

  0001b	83 7d f8 00	 cmp	 DWORD PTR _iIdx$[ebp], 0
  0001f	7d 04		 jge	 SHORT $LN2@MoveFree2K
  00021	33 c0		 xor	 eax, eax
  00023	eb 1b		 jmp	 SHORT $LN1@MoveFree2K
$LN2@MoveFree2K:

; 1220 : 	
; 1221 : 	int iGateNumber = 88 + iIdx;	

  00025	8b 45 f8	 mov	 eax, DWORD PTR _iIdx$[ebp]
  00028	83 c0 58	 add	 eax, 88			; 00000058H
  0002b	89 45 f4	 mov	 DWORD PTR _iGateNumber$[ebp], eax

; 1222 : 
; 1223 : 	return gObjMoveGate(lpObj->m_Index, iGateNumber);	

  0002e	8b 45 f4	 mov	 eax, DWORD PTR _iGateNumber$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0003d	83 c4 08	 add	 esp, 8
$LN1@MoveFree2K:

; 1224 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?MoveFree2Kalima@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z ENDP ; CMoveCommand::MoveFree2Kalima
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?Move@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_szTemp$1 = -808					; size = 256
_szTemp$2 = -552					; size = 256
_szTemp$3 = -296					; size = 256
_MapNumber$ = -40					; size = 4
_NeedZen$ = -36						; size = 4
_NeedLevel$ = -32					; size = 4
_nMoveIndex$ = -28					; size = 4
_index$ = -24						; size = 4
_subMoney$ = -20					; size = 4
_overLevel$ = -16					; size = 4
_m_number$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_mapname$ = 12						; size = 4
?Move@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@PAD@Z PROC	; CMoveCommand::Move, COMDAT
; _this$ = ecx

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 03 00
	00		 sub	 esp, 936		; 000003a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 430  : 	int	m_number   = -1;

  00019	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _m_number$[ebp], -1

; 431  : 	int	overLevel  = 0;

  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _overLevel$[ebp], 0

; 432  : 	int	subMoney   = 2000;

  00027	c7 45 ec d0 07
	00 00		 mov	 DWORD PTR _subMoney$[ebp], 2000 ; 000007d0H

; 433  : 	
; 434  : #ifdef ADD_MAPMOVE_PROTOCOL_20090327
; 435  : 	char mapname[255];
; 436  : 	int index = FindIndex( iMapIndex );
; 437  : 	if( index == -1 )
; 438  : 	{
; 439  : 		LogAddTD( "[MapMove Failed] Invalid Map Index (%s/%s) (Index : %d)", lpObj->AccountID, lpObj->Name, iMapIndex );
; 440  : 		return FALSE;
; 441  : 	}
; 442  : 	memcpy( mapname, m_MoveCommandData[index].Name, 255 );
; 443  : #else
; 444  : 	int index = FindIndex(mapname);

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _mapname$[ebp]
  00031	50		 push	 eax
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?FindIndex@CMoveCommand@@AAEHPAD@Z ; CMoveCommand::FindIndex
  0003a	89 45 e8	 mov	 DWORD PTR _index$[ebp], eax

; 445  : #endif // ADD_MAPMOVE_PROTOCOL_20090327
; 446  : 
; 447  : #ifdef ADD_PCS_MARKITEM_MAP_MOVE_BOUND_20070221
; 448  : 	if( g_bUseMoveMapBound == TRUE )
; 449  : 	{
; 450  : 	#ifdef MODIFY_MAPMOVEBOUNCE_CHECK_OPTION_20070521
; 451  : 		if( g_CashItemPeriodSystem.CheckMapBoundFreeItemUse( lpObj ) == FALSE )
; 452  : 	#else
; 453  : 		if( lpObj->m_iPeriodItemEffectIndex == -1 )
; 454  : 	#endif // MODIFY_MAPMOVEBOUNCE_CHECK_OPTION_20070521
; 455  : 		{
; 456  : 			if( CheckMoveMapBound( index ) == FALSE )
; 457  : 			{
; 458  : 				return FALSE;
; 459  : 			}
; 460  : 		}
; 461  : 	}
; 462  : #endif // ADD_PCS_MARKITEM_MAP_MOVE_BOUND_20070221
; 463  : 
; 464  : #ifdef MODIFY_MOVEMAP_BUGFIX_20080109	// movereq파일의 인덱스로 수정
; 465  : 	int nMoveIndex = m_MoveCommandData[index].Index;

  0003d	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 54 01 04	 mov	 edx, DWORD PTR [ecx+eax+4]
  0004b	89 55 e4	 mov	 DWORD PTR _nMoveIndex$[ebp], edx

; 466  : #endif	// MODIFY_MOVEMAP_BUGFIX_20080109
; 467  : 
; 468  : #ifdef ADD_NEWPVP_PKFIELD
; 469  : 	// NON-PK서버는 결투및 불카누스폐허 맵으로 이동 불가 VULCANUS_MOVEREQINDEX	42
; 470  : 	if (nMoveIndex == 42)
; 471  : 	{
; 472  : 		if (gNonPK)
; 473  : 		{
; 474  : 			// "NON-PK 서버에서는 이동할 수 없습니다."
; 475  : 			GCServerMsgStringSend(lMsg.Get(3418), lpObj->m_Index, 1);
; 476  : 			return FALSE;
; 477  : 		}
; 478  : 	}
; 479  : #endif // ADD_NEWPVP_PKFIELD
; 480  : 	
; 481  : #ifdef MU_CASTLESIEGE_SERVER_SYNC_20041130				// 공성전 기간 중에는 수비측이라도 이동명령으로 로랜협곡으로 갈 수 없다.
; 482  : #ifdef MODIFY_MOVEMAP_BUGFIX_20080109	// movereq파일의 인덱스로 수정
; 483  : 	if (nMoveIndex == 24) {
; 484  : #else	// MODIFY_MOVEMAP_BUGFIX_20080109
; 485  : 	if (index == 23) {									// CS_MOVENUM_LORENDEEP
; 486  : #endif	// MODIFY_MOVEMAP_BUGFIX_20080109
; 487  : 		if (g_CastleSiegeSync.GetCastleState() == CASTLESIEGE_SYNC_STATE_STARTSIEGE) {
; 488  : 			return FALSE;
; 489  : 		}
; 490  : 
; 491  : 		if (g_CastleSiegeSync.CheckCastleOwnerMember(lpObj->m_Index) == FALSE &&
; 492  : 			g_CastleSiegeSync.CheckCastleOwnerUnionMember(lpObj->m_Index) == FALSE
; 493  : 			) 
; 494  : 		{
; 495  : 			return FALSE;
; 496  : 		}
; 497  : 	}
; 498  : #endif
; 499  : 	
; 500  : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_6_200708013	// 사원에서는 '/이동 아틀란스, /이동 이카루스'
; 501  : 	if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) 
; 502  : #ifdef MODIFY_MOVEMAP_BUGFIX_20080109
; 503  : 		&& (nMoveIndex == 11 || nMoveIndex == 12 || nMoveIndex == 13		// 아틀란스
; 504  : 		|| nMoveIndex == 23))												// 이카루스
; 505  : #else	// MODIFY_MOVEMAP_BUGFIX_20080109
; 506  : 		&& (index == 10 || index == 11 || index == 12		// 아틀란스
; 507  : 		|| index == 25))									// 이카루스
; 508  : #endif	// MODIFY_MOVEMAP_BUGFIX_20080109
; 509  : 	{
; 510  : 		return FALSE;
; 511  : 	}
; 512  : #endif
; 513  : 	
; 514  : #ifdef PCBANG_FREE_KALIMA_EVENT_20060124
; 515  : 	// PC방 유저만 이동 가능
; 516  : 
; 517  : 	#ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 518  : 		// 20060918 수정 ( 칼리마 무료 이동 조건 : PC방 접속 유저, 파란 복주머니 사용 유저 )
; 519  : 		if( lpObj->m_bPCBangCouponUser || lpObj->m_lFreeKalimaTime )
; 520  : 	#else
; 521  : 		if( lpObj->m_lFreeKalimaTime )
; 522  : 	#endif
; 523  : 		{
; 524  : 			if( MoveFreeKalima( lpObj, mapname ) )
; 525  : 				return TRUE;
; 526  : 		}
; 527  : 
; 528  : 	// MODIFY_LOCALIZING_WTF_20060309 로컬라이징 wtf 파일 업데이트 0.99.60 - 0.99.94
; 529  : 	if( strcmp( mapname, lMsg.Get(3346) ) == 0 )			// "칼리마"
; 530  : 	{
; 531  : 		GCServerMsgStringSend(lMsg.Get(1256), lpObj->m_Index, 1);
; 532  : 	}
; 533  : #endif // PCBANG_FREE_KALIMA_EVENT_20060124
; 534  : 
; 535  : 	if( index == -1 )

  0004e	83 7d e8 ff	 cmp	 DWORD PTR _index$[ebp], -1
  00052	75 07		 jne	 SHORT $LN2@Move

; 536  : 	{
; 537  : 
; 538  : #if TESTSERVER == 1	// 테섭용 이동
; 539  : 		return TestServerMove(lpObj, mapname);
; 540  : #else
; 541  : 		return FALSE;		// 해당되는 이동 데이터가 없다

  00054	33 c0		 xor	 eax, eax
  00056	e9 5f 03 00 00	 jmp	 $LN1@Move
$LN2@Move:

; 542  : #endif
; 543  : 	}
; 544  : 
; 545  : 
; 546  : 	int	NeedLevel = m_MoveCommandData[index].NeedLevel;

  0005b	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8b 94 01 0c 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+268]
  0006c	89 55 e0	 mov	 DWORD PTR _NeedLevel$[ebp], edx

; 547  : 	int	NeedZen = m_MoveCommandData[index].NeedZen;

  0006f	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	8b 94 01 08 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+264]
  00080	89 55 dc	 mov	 DWORD PTR _NeedZen$[ebp], edx

; 548  : 	int	MapNumber = m_MoveCommandData[index].MapNumber;

  00083	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	8b 94 01 10 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+272]
  00094	89 55 d8	 mov	 DWORD PTR _MapNumber$[ebp], edx

; 549  : 
; 550  : #if TESTSERVER == 1
; 551  : 	//NeedLevel = 0;
; 552  : #endif
; 553  : 
; 554  : #ifdef DARKLORD_WORK
; 555  : 	if (lpObj->Class == CLASS_DARKLORD||lpObj->Class == CLASS_MAGUMSA) 

  00097	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000a1	83 f9 04	 cmp	 ecx, 4
  000a4	74 0f		 je	 SHORT $LN4@Move
  000a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a9	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000b0	83 f9 03	 cmp	 ecx, 3
  000b3	75 16		 jne	 SHORT $LN3@Move
$LN4@Move:

; 556  : #else					
; 557  : 	if( lpObj->Class == CLASS_MAGUMSA )	
; 558  : #endif
; 559  : 	{	
; 560  : 		if( NeedLevel > 0 )

  000b5	83 7d e0 00	 cmp	 DWORD PTR _NeedLevel$[ebp], 0
  000b9	7e 10		 jle	 SHORT $LN3@Move

; 561  : 		{
; 562  : #ifdef MODIFY_MAGUMSA_MOVE_LEVEL_20040517
; 563  : #ifdef UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108	// 평온의 늪은 마검사, 다크로드라도 Movereq.txt 파을에 따라 입장
; 564  : 			//if(GateNumber != 273)
; 565  : #endif	// UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108
; 566  : 			NeedLevel = ((NeedLevel*2)/3);

  000bb	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  000be	d1 e0		 shl	 eax, 1
  000c0	99		 cdq
  000c1	b9 03 00 00 00	 mov	 ecx, 3
  000c6	f7 f9		 idiv	 ecx
  000c8	89 45 e0	 mov	 DWORD PTR _NeedLevel$[ebp], eax
$LN3@Move:

; 567  : #else
; 568  : 			NeedLevel = ((NeedLevel/3)*2);
; 569  : #endif			
; 570  : 		}
; 571  : 	}
; 572  : 
; 573  : 	if( g_TerrainManager.CheckTerrain(MapNumber) == true )

  000cb	8b 45 d8	 mov	 eax, DWORD PTR _MapNumber$[ebp]
  000ce	50		 push	 eax
  000cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  000d4	e8 00 00 00 00	 call	 ?CheckTerrain@CTerrainManager@@QAE_NH@Z ; CTerrainManager::CheckTerrain
  000d9	0f b6 c8	 movzx	 ecx, al
  000dc	83 f9 01	 cmp	 ecx, 1
  000df	0f 85 9e 02 00
	00		 jne	 $LN6@Move

; 574  : 	{
; 575  : 		LogAddTD("[%s][%s] Use Move [%d][%d][%d] - [%d][%d][%d]", 

  000e5	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  000ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	8b 94 01 28 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+296]
  000f6	52		 push	 edx
  000f7	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  000fe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	8b 94 01 24 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+292]
  00108	52		 push	 edx
  00109	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  0010c	50		 push	 eax
  0010d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00110	8b 91 78 1a 00
	00		 mov	 edx, DWORD PTR [ecx+6776]
  00116	52		 push	 edx
  00117	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011a	0f b6 88 5d 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6749]
  00121	51		 push	 ecx
  00122	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00125	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  0012c	50		 push	 eax
  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00130	83 c1 73	 add	 ecx, 115		; 00000073H
  00133	51		 push	 ecx
  00134	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00137	83 c2 68	 add	 edx, 104		; 00000068H
  0013a	52		 push	 edx
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@EGHEKHC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5Move?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5@
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00146	83 c4 24	 add	 esp, 36			; 00000024H

; 576  : 			lpObj->AccountID, lpObj->Name, lpObj->Level, lpObj->m_AccountType, lpObj->m_iResetNumber,
; 577  : 			NeedLevel, m_MoveCommandData[index].VIP, m_MoveCommandData[index].Reset); 
; 578  : 		if( lpObj->Level >= NeedLevel )

  00149	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00153	3b 4d e0	 cmp	 ecx, DWORD PTR _NeedLevel$[ebp]
  00156	0f 8c eb 01 00
	00		 jl	 $LN7@Move

; 579  : 		{
; 580  : 			if(lpObj->m_AccountType < m_MoveCommandData[index].VIP)

  0015c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015f	0f b6 88 5d 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6749]
  00166	69 55 e8 28 01
	00 00		 imul	 edx, DWORD PTR _index$[ebp], 296
  0016d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00170	3b 8c 10 24 01
	00 00		 cmp	 ecx, DWORD PTR [eax+edx+292]
  00177	7d 43		 jge	 SHORT $LN9@Move

; 581  : 			{
; 582  : 				char szTemp[256];
; 583  : 				wsprintf(szTemp, "Necesitas ser minimo nivel VIP %d", m_MoveCommandData[index].VIP);

  00179	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  00180	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00183	8b 94 01 24 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+292]
  0018a	52		 push	 edx
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@CALMLEOA@Necesitas?5ser?5minimo?5nivel?5VIP?5@
  00190	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$3[ebp]
  00196	50		 push	 eax
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 584  : 				GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  001a0	6a 01		 push	 1
  001a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a7	51		 push	 ecx
  001a8	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$3[ebp]
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 585  : 			}

  001b7	e9 89 01 00 00	 jmp	 $LN10@Move
$LN9@Move:

; 586  : 			else if(lpObj->m_iResetNumber < m_MoveCommandData[index].Reset)

  001bc	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  001c3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001c9	8b 89 78 1a 00
	00		 mov	 ecx, DWORD PTR [ecx+6776]
  001cf	3b 8c 02 28 01
	00 00		 cmp	 ecx, DWORD PTR [edx+eax+296]
  001d6	7d 43		 jge	 SHORT $LN11@Move

; 587  : 			{
; 588  : 				char szTemp[256];
; 589  : 				wsprintf(szTemp, "Necesitas minimo tener %d Resets", m_MoveCommandData[index].Reset);

  001d8	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  001df	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e2	8b 94 01 28 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+296]
  001e9	52		 push	 edx
  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@ODKFONDI@Necesitas?5minimo?5tener?5?$CFd?5Reset@
  001ef	8d 85 d8 fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$2[ebp]
  001f5	50		 push	 eax
  001f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 590  : 				GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  001ff	6a 01		 push	 1
  00201	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00204	8b 08		 mov	 ecx, DWORD PTR [eax]
  00206	51		 push	 ecx
  00207	8d 95 d8 fd ff
	ff		 lea	 edx, DWORD PTR _szTemp$2[ebp]
  0020d	52		 push	 edx
  0020e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00213	83 c4 0c	 add	 esp, 12			; 0000000cH

; 591  : 			}

  00216	e9 2a 01 00 00	 jmp	 $LN10@Move
$LN11@Move:

; 592  : 			else if( lpObj->Money-NeedZen >= 0 ) 

  0021b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0021e	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00224	2b 4d dc	 sub	 ecx, DWORD PTR _NeedZen$[ebp]
  00227	0f 88 f7 00 00
	00		 js	 $LN13@Move

; 593  : 			{
; 594  : 				if( gObjMovePlayer(lpObj->m_Index, m_MoveCommandData[index].MapNumber, m_MoveCommandData[index].X1, m_MoveCommandData[index].Y1, m_MoveCommandData[index].X2, m_MoveCommandData[index].Y2) )

  0022d	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  00234	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00237	0f b6 94 01 20
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+288]
  0023f	52		 push	 edx
  00240	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  00247	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0024a	0f b6 94 01 1c
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+284]
  00252	52		 push	 edx
  00253	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  0025a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0025d	0f b6 94 01 18
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+280]
  00265	52		 push	 edx
  00266	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  0026d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00270	0f b6 94 01 14
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+276]
  00278	52		 push	 edx
  00279	69 45 e8 28 01
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 296
  00280	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00283	0f b6 94 01 10
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+272]
  0028b	52		 push	 edx
  0028c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00291	51		 push	 ecx
  00292	e8 00 00 00 00	 call	 ?gObjMovePlayer@@YAHHEEEEE@Z ; gObjMovePlayer
  00297	83 c4 18	 add	 esp, 24			; 00000018H
  0029a	85 c0		 test	 eax, eax
  0029c	0f 84 80 00 00
	00		 je	 $LN15@Move

; 595  : 				{
; 596  : #ifdef PERSONAL_SHOP_20040113	// 같은 맵에 이동할 경우를 대비하여 개인상점 뷰포트를 무조건 다시 그리라고 세팅
; 597  : 					lpObj->m_bPShopRedrawAbs = true;		

  002a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a5	c6 80 fb 0c 00
	00 01		 mov	 BYTE PTR [eax+3323], 1

; 598  : #endif
; 599  : 					lpObj->Money -= NeedZen;

  002ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002af	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  002b5	2b 4d dc	 sub	 ecx, DWORD PTR _NeedZen$[ebp]
  002b8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002bb	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 600  : 					
; 601  : 					LogAddTD("[%s][%s] Use [%s %s] Success : reduces money %d - %d", 

  002c1	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  002c4	50		 push	 eax
  002c5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c8	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  002ce	52		 push	 edx
  002cf	8b 45 0c	 mov	 eax, DWORD PTR _mapname$[ebp]
  002d2	50		 push	 eax
  002d3	68 b9 0b 00 00	 push	 3001			; 00000bb9H
  002d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002e3	50		 push	 eax
  002e4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002e7	83 c1 73	 add	 ecx, 115		; 00000073H
  002ea	51		 push	 ecx
  002eb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002ee	83 c2 68	 add	 edx, 104		; 00000068H
  002f1	52		 push	 edx
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GFFIBCDJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Success?5?3?5@
  002f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002fd	83 c4 1c	 add	 esp, 28			; 0000001cH

; 602  : 							lpObj->AccountID, lpObj->Name, 
; 603  : 							lMsg.Get(3001), mapname,
; 604  : 							lpObj->Money, NeedLevel); 
; 605  : 					GCMoneySend(lpObj->m_Index, lpObj->Money);

  00300	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00303	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00309	51		 push	 ecx
  0030a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0030d	8b 02		 mov	 eax, DWORD PTR [edx]
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00315	83 c4 08	 add	 esp, 8

; 606  : 
; 607  : #ifdef ADD_RAKLION_20080408		// 라클리온 보스존에서 이동시 처리 추가
; 608  : 					if( lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS )
; 609  : 						g_RaklionBattleUserMng.DeleteUserData( lpObj->m_Index );
; 610  : #endif // ADD_RAKLION_20080408
; 611  : 
; 612  : 					return TRUE;

  00318	b8 01 00 00 00	 mov	 eax, 1
  0031d	e9 98 00 00 00	 jmp	 $LN1@Move
$LN15@Move:

; 613  : 				}				
; 614  : 			}	

  00322	eb 21		 jmp	 SHORT $LN10@Move
$LN13@Move:

; 615  : 			else
; 616  : 			{
; 617  : 				GCServerMsgStringSend(lMsg.Get(1126), lpObj->m_Index, 1);

  00324	6a 01		 push	 1
  00326	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00329	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032b	51		 push	 ecx
  0032c	68 66 04 00 00	 push	 1126			; 00000466H
  00331	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00336	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0033c	50		 push	 eax
  0033d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00342	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@Move:

; 618  : 			}
; 619  : 		}

  00345	eb 3c		 jmp	 SHORT $LN6@Move
$LN7@Move:

; 620  : 		else
; 621  : 		{	// %d 레벨 이상 이동 할수 있는 곳 입니다
; 622  : 			char szTemp[256];
; 623  : 			wsprintf(szTemp, lMsg.Get(1117), NeedLevel);

  00347	8b 45 e0	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  0034a	50		 push	 eax
  0034b	68 5d 04 00 00	 push	 1117			; 0000045dH
  00350	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00355	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0035b	50		 push	 eax
  0035c	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _szTemp$1[ebp]
  00362	51		 push	 ecx
  00363	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00369	83 c4 0c	 add	 esp, 12			; 0000000cH

; 624  : 			GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  0036c	6a 01		 push	 1
  0036e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00371	8b 08		 mov	 ecx, DWORD PTR [eax]
  00373	51		 push	 ecx
  00374	8d 95 d8 fc ff
	ff		 lea	 edx, DWORD PTR _szTemp$1[ebp]
  0037a	52		 push	 edx
  0037b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00380	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@Move:

; 625  : 		}
; 626  : 	}
; 627  : 
; 628  : 	//"[%s][%s] 이동 명령어 실패
; 629  : 	LogAddTD("[%s][%s] Use [%s %s] Fail MapNumber = %d", 

  00383	8b 45 d8	 mov	 eax, DWORD PTR _MapNumber$[ebp]
  00386	50		 push	 eax
  00387	8b 4d 0c	 mov	 ecx, DWORD PTR _mapname$[ebp]
  0038a	51		 push	 ecx
  0038b	68 b9 0b 00 00	 push	 3001			; 00000bb9H
  00390	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00395	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0039b	50		 push	 eax
  0039c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0039f	83 c2 73	 add	 edx, 115		; 00000073H
  003a2	52		 push	 edx
  003a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a6	83 c0 68	 add	 eax, 104		; 00000068H
  003a9	50		 push	 eax
  003aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FKMIFCDG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5?$FL?$CFs?5?$CFs?$FN?5Fail?5MapNu@
  003af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003b5	83 c4 18	 add	 esp, 24			; 00000018H

; 630  : 			 lpObj->AccountID, lpObj->Name, 
; 631  : 			 lMsg.Get(3001), mapname,
; 632  : 			 MapNumber); 
; 633  : 	return FALSE;

  003b8	33 c0		 xor	 eax, eax
$LN1@Move:

; 634  : }

  003ba	5f		 pop	 edi
  003bb	5e		 pop	 esi
  003bc	5b		 pop	 ebx
  003bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c0	33 cd		 xor	 ecx, ebp
  003c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c7	8b e5		 mov	 esp, ebp
  003c9	5d		 pop	 ebp
  003ca	c2 08 00	 ret	 8
?Move@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@PAD@Z ENDP	; CMoveCommand::Move
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?CheckInterfaceToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?CheckInterfaceToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z PROC ; CMoveCommand::CheckInterfaceToMove, COMDAT
; _this$ = ecx

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 346  : 	// 인터페이스가 사용 중이면..
; 347  : 	if( lpObj->m_IfState.use == 1 )

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00015	80 e1 03	 and	 cl, 3
  00018	0f b6 d1	 movzx	 edx, cl
  0001b	83 fa 01	 cmp	 edx, 1
  0001e	75 04		 jne	 SHORT $LN2@CheckInter

; 348  : 		return FALSE;

  00020	33 c0		 xor	 eax, eax
  00022	eb 18		 jmp	 SHORT $LN1@CheckInter
$LN2@CheckInter:

; 349  : 
; 350  : #ifdef PERSONAL_SHOP_20040113
; 351  : 	if( lpObj->m_bPShopOpen == TRUE )

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00027	0f b6 88 f8 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3320]
  0002e	83 f9 01	 cmp	 ecx, 1
  00031	75 04		 jne	 SHORT $LN3@CheckInter

; 352  : 		return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	eb 05		 jmp	 SHORT $LN1@CheckInter
$LN3@CheckInter:

; 353  : #endif
; 354  : 	
; 355  : 	return TRUE;

  00037	b8 01 00 00 00	 mov	 eax, 1
$LN1@CheckInter:

; 356  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?CheckInterfaceToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z ENDP ; CMoveCommand::CheckInterfaceToMove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?CheckEquipmentToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_iTargetMapNumber$ = 12					; size = 4
?CheckEquipmentToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@H@Z PROC ; CMoveCommand::CheckEquipmentToMove, COMDAT
; _this$ = ecx

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  : 	// 아틀란스 또는 천공맵에서는 유니리아를 타고 이동할수 없다
; 289  : 	// 아틀란스로 이동 할경우 유니리아를 타면 이동할수 없다
; 290  : 	if( iTargetMapNumber == MAP_INDEX_ATHLANSE )	

  0000c	83 7d 0c 07	 cmp	 DWORD PTR _iTargetMapNumber$[ebp], 7
  00010	75 74		 jne	 SHORT $LN2@CheckEquip

; 291  : 	{	
; 292  : 		if( lpObj->pInventory[EQUIPMENT_HELPER].IsItem())

  00012	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00017	c1 e1 03	 shl	 ecx, 3
  0001a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001d	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00023	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00028	85 c0		 test	 eax, eax
  0002a	74 5a		 je	 SHORT $LN2@CheckEquip

; 293  : 		{							
; 294  : 			if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,2) )

  0002c	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00031	c1 e0 03	 shl	 eax, 3
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00037	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0003d	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00042	6a 02		 push	 2
  00044	6a 0d		 push	 13			; 0000000dH
  00046	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0004b	83 c4 08	 add	 esp, 8
  0004e	3b f0		 cmp	 esi, eax
  00050	75 07		 jne	 SHORT $LN4@CheckEquip

; 295  : 			{
; 296  : 				return FALSE;

  00052	33 c0		 xor	 eax, eax
  00054	e9 7a 01 00 00	 jmp	 $LN1@CheckEquip
$LN4@CheckEquip:

; 297  : 			}
; 298  : 
; 299  : 			if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,3) )

  00059	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0005e	c1 e0 03	 shl	 eax, 3
  00061	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00064	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0006a	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0006f	6a 03		 push	 3
  00071	6a 0d		 push	 13			; 0000000dH
  00073	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00078	83 c4 08	 add	 esp, 8
  0007b	3b f0		 cmp	 esi, eax
  0007d	75 07		 jne	 SHORT $LN2@CheckEquip

; 300  : 			{
; 301  : 				return FALSE;

  0007f	33 c0		 xor	 eax, eax
  00081	e9 4d 01 00 00	 jmp	 $LN1@CheckEquip
$LN2@CheckEquip:

; 302  : 			}
; 303  : 		}
; 304  : 	}
; 305  : 
; 306  : 	if( iTargetMapNumber == MAP_INDEX_ICARUS )

  00086	83 7d 0c 0a	 cmp	 DWORD PTR _iTargetMapNumber$[ebp], 10 ; 0000000aH
  0008a	0f 85 3e 01 00
	00		 jne	 $LN6@CheckEquip

; 307  : 	{
; 308  : 		if( (lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,3) && 
; 309  : 			 lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(13,30) &&	// 망토
; 310  : #ifdef ADD_ITEM_FENRIR_01_20051110
; 311  : 			lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,37) &&	// 펜릴
; 312  : #endif
; 313  : #ifdef MODIFY_RECALL_PARTY_SKILL_SUMMONER_BUGFIX_20080829
; 314  : 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(12, 36) &&	// 폭풍의 날개
; 315  : 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(12, 37) &&	// 시공의 날개
; 316  : 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(12, 38) &&	// 환영의 날개
; 317  : 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(12, 39) &&	// 파멸의 날개
; 318  : 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(12, 40) &&	// 제왕의 망토
; 319  : 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(12, 41) &&	// 소환 술사 1차 날개
; 320  : 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(12, 42) &&	// 소환 술사 2차 날개
; 321  : 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(12, 43) &&	// 소환 술사 3차 날개
; 322  : 			lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13, 4) &&	// 다크 호스
; 323  : #endif // MODIFY_RECALL_PARTY_SKILL_SUMMONER_BUGFIX_20080829
; 324  : 			(lpObj->pInventory[EQUIPMENT_WING].m_Type < MAKE_ITEMNUM(12,0) || lpObj->pInventory[EQUIPMENT_WING].m_Type > MAKE_ITEMNUM(12,6) )) ||
; 325  : 			 lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,2) ||
; 326  : 			 lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13,10) ||

  00090	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00095	c1 e0 03	 shl	 eax, 3
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009b	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000a1	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000a6	6a 03		 push	 3
  000a8	6a 0d		 push	 13			; 0000000dH
  000aa	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000af	83 c4 08	 add	 esp, 8
  000b2	3b f0		 cmp	 esi, eax
  000b4	74 76		 je	 SHORT $LN9@CheckEquip
  000b6	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000bb	6b c8 07	 imul	 ecx, eax, 7
  000be	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c1	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000c7	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  000cc	6a 1e		 push	 30			; 0000001eH
  000ce	6a 0d		 push	 13			; 0000000dH
  000d0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d5	83 c4 08	 add	 esp, 8
  000d8	3b f0		 cmp	 esi, eax
  000da	74 50		 je	 SHORT $LN9@CheckEquip
  000dc	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000e1	6b c8 07	 imul	 ecx, eax, 7
  000e4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e7	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000ed	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  000f2	6a 00		 push	 0
  000f4	6a 0c		 push	 12			; 0000000cH
  000f6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000fb	83 c4 08	 add	 esp, 8
  000fe	3b f0		 cmp	 esi, eax
  00100	0f 8c 98 00 00
	00		 jl	 $LN8@CheckEquip
  00106	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0010b	6b c8 07	 imul	 ecx, eax, 7
  0010e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00111	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00117	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0011c	6a 06		 push	 6
  0011e	6a 0c		 push	 12			; 0000000cH
  00120	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00125	83 c4 08	 add	 esp, 8
  00128	3b f0		 cmp	 esi, eax
  0012a	7f 72		 jg	 SHORT $LN8@CheckEquip
$LN9@CheckEquip:
  0012c	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00131	c1 e0 03	 shl	 eax, 3
  00134	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00137	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0013d	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00142	6a 02		 push	 2
  00144	6a 0d		 push	 13			; 0000000dH
  00146	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0014b	83 c4 08	 add	 esp, 8
  0014e	3b f0		 cmp	 esi, eax
  00150	74 4c		 je	 SHORT $LN8@CheckEquip
  00152	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00157	6b c8 0b	 imul	 ecx, eax, 11
  0015a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015d	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00163	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00168	6a 0a		 push	 10			; 0000000aH
  0016a	6a 0d		 push	 13			; 0000000dH
  0016c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00171	83 c4 08	 add	 esp, 8
  00174	3b f0		 cmp	 esi, eax
  00176	74 26		 je	 SHORT $LN8@CheckEquip
  00178	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0017d	6b c8 0a	 imul	 ecx, eax, 10
  00180	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00183	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00189	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0018e	6a 0a		 push	 10			; 0000000aH
  00190	6a 0d		 push	 13			; 0000000dH
  00192	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00197	83 c4 08	 add	 esp, 8
  0019a	3b f0		 cmp	 esi, eax
  0019c	75 04		 jne	 SHORT $LN7@CheckEquip
$LN8@CheckEquip:

; 327  : 			 lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13,10) 
; 328  : 		  )
; 329  : 		{	
; 330  : 			return FALSE;

  0019e	33 c0		 xor	 eax, eax
  001a0	eb 31		 jmp	 SHORT $LN1@CheckEquip
$LN7@CheckEquip:

; 331  : 		}
; 332  : 
; 333  : 		// 소환 몬스터 제거
; 334  : 		if( lpObj->m_RecallMon >= 0 ) 

  001a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a5	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  001ac	7c 20		 jl	 SHORT $LN6@CheckEquip

; 335  : 		{
; 336  : 			GCRecallMonLife(lpObj->m_Index, 60, 0);

  001ae	6a 00		 push	 0
  001b0	6a 3c		 push	 60			; 0000003cH
  001b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b7	51		 push	 ecx
  001b8	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  001bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 337  : 			gObjMonsterCallKill(lpObj->m_Index);

  001c0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  001cb	83 c4 04	 add	 esp, 4
$LN6@CheckEquip:

; 338  : 		}
; 339  : 	}
; 340  : 
; 341  : 	return TRUE;

  001ce	b8 01 00 00 00	 mov	 eax, 1
$LN1@CheckEquip:

; 342  : }

  001d3	5f		 pop	 edi
  001d4	5e		 pop	 esi
  001d5	5b		 pop	 ebx
  001d6	8b e5		 mov	 esp, ebp
  001d8	5d		 pop	 ebp
  001d9	c2 08 00	 ret	 8
?CheckEquipmentToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@H@Z ENDP ; CMoveCommand::CheckEquipmentToMove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?CheckMainToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv88 = -76						; size = 4
tv79 = -76						; size = 4
tv70 = -76						; size = 4
tv89 = -72						; size = 4
tv80 = -72						; size = 4
tv71 = -72						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?CheckMainToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z PROC ; CMoveCommand::CheckMainToMove, COMDAT
; _this$ = ecx

; 245  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 246  : 	if( CHECK_BLOODCASTLE(lpObj->MapNumber) ) 

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00016	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00019	7d 09		 jge	 SHORT $LN9@CheckMainT
  0001b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00022	eb 25		 jmp	 SHORT $LN10@CheckMainT
$LN9@CheckMainT:
  00024	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00027	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0002e	83 f8 11	 cmp	 eax, 17			; 00000011H
  00031	7e 09		 jle	 SHORT $LN7@CheckMainT
  00033	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  0003a	eb 07		 jmp	 SHORT $LN8@CheckMainT
$LN7@CheckMainT:
  0003c	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
$LN8@CheckMainT:
  00043	8b 4d b4	 mov	 ecx, DWORD PTR tv70[ebp]
  00046	89 4d b8	 mov	 DWORD PTR tv71[ebp], ecx
$LN10@CheckMainT:
  00049	83 7d b8 00	 cmp	 DWORD PTR tv71[ebp], 0
  0004d	74 07		 je	 SHORT $LN2@CheckMainT

; 247  : 		return FALSE;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 a6 00 00 00	 jmp	 $LN1@CheckMainT
$LN2@CheckMainT:

; 248  : 
; 249  : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 250  : 	if( CHECK_CHAOSCASTLE(lpObj->MapNumber) )

  00056	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00059	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00060	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00063	7d 09		 jge	 SHORT $LN13@CheckMainT
  00065	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  0006c	eb 25		 jmp	 SHORT $LN14@CheckMainT
$LN13@CheckMainT:
  0006e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00071	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00078	83 f8 17	 cmp	 eax, 23			; 00000017H
  0007b	7e 09		 jle	 SHORT $LN11@CheckMainT
  0007d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00084	eb 07		 jmp	 SHORT $LN12@CheckMainT
$LN11@CheckMainT:
  00086	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN12@CheckMainT:
  0008d	8b 4d b4	 mov	 ecx, DWORD PTR tv79[ebp]
  00090	89 4d b8	 mov	 DWORD PTR tv80[ebp], ecx
$LN14@CheckMainT:
  00093	83 7d b8 00	 cmp	 DWORD PTR tv80[ebp], 0
  00097	74 04		 je	 SHORT $LN3@CheckMainT

; 251  : 		return FALSE;

  00099	33 c0		 xor	 eax, eax
  0009b	eb 5f		 jmp	 SHORT $LN1@CheckMainT
$LN3@CheckMainT:

; 252  : #endif
; 253  : 
; 254  : #ifdef ADD_NEW_MAP_KALIMA_20040518
; 255  : 	if( CHECK_KALIMAMAP(lpObj->MapNumber) )

  0009d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a0	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000a7	83 f9 18	 cmp	 ecx, 24			; 00000018H
  000aa	7d 09		 jge	 SHORT $LN17@CheckMainT
  000ac	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
  000b3	eb 25		 jmp	 SHORT $LN18@CheckMainT
$LN17@CheckMainT:
  000b5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b8	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000bf	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  000c2	7e 09		 jle	 SHORT $LN15@CheckMainT
  000c4	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
  000cb	eb 07		 jmp	 SHORT $LN16@CheckMainT
$LN15@CheckMainT:
  000cd	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
$LN16@CheckMainT:
  000d4	8b 4d b4	 mov	 ecx, DWORD PTR tv88[ebp]
  000d7	89 4d b8	 mov	 DWORD PTR tv89[ebp], ecx
$LN18@CheckMainT:
  000da	83 7d b8 00	 cmp	 DWORD PTR tv89[ebp], 0
  000de	74 04		 je	 SHORT $LN4@CheckMainT

; 256  : 		return FALSE;

  000e0	33 c0		 xor	 eax, eax
  000e2	eb 18		 jmp	 SHORT $LN1@CheckMainT
$LN4@CheckMainT:

; 257  : #endif
; 258  : 
; 259  : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 260  : 	if( CHECK_DEVILSQUARE(lpObj->MapNumber) )
; 261  : #else
; 262  : 	if( lpObj->MapNumber == MAP_INDEX_DEVILSQUARE )

  000e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e7	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000ee	83 f9 09	 cmp	 ecx, 9
  000f1	75 04		 jne	 SHORT $LN5@CheckMainT

; 263  : #endif
; 264  : 		return FALSE;

  000f3	33 c0		 xor	 eax, eax
  000f5	eb 05		 jmp	 SHORT $LN1@CheckMainT
$LN5@CheckMainT:

; 265  : 
; 266  : #ifdef ADD_KANTURU_20060627	// 칸투르 보스맵에서 다크로드 소환 금지
; 267  : 	if( lpObj->MapNumber == MAP_INDEX_KANTURU_BOSS )
; 268  : 	{
; 269  : 		return FALSE;
; 270  : 	}
; 271  : #endif
; 272  : 
; 273  : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	// 환영 사원에서 성물을 들고 있는 캐릭 소환 금지
; 274  : 	if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 275  : 	{
; 276  : 		if(g_IllusionTempleEvent.CheckRelics(lpObj->m_Index))
; 277  : 		{
; 278  : 			return FALSE;
; 279  : 		}
; 280  : 	}
; 281  : #endif
; 282  : 
; 283  : 	return TRUE;

  000f7	b8 01 00 00 00	 mov	 eax, 1
$LN1@CheckMainT:

; 284  : }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?CheckMainToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z ENDP ; CMoveCommand::CheckMainToMove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_mapnumber$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_Class$ = 20						; size = 4
?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z PROC		; CMoveCommand::GetMoveLevel, COMDAT
; _this$ = ecx

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 218  : 	for( int i = 0; i < MAX_MOVE_COMMAND_COUNT; i++ )

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@GetMoveLev
$LN2@GetMoveLev:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@GetMoveLev:
  0001e	83 7d f8 32	 cmp	 DWORD PTR _i$1[ebp], 50	; 00000032H
  00022	0f 8d a0 00 00
	00		 jge	 $LN3@GetMoveLev

; 219  : 	{
; 220  : 		if( m_MoveLevel[i].MapNumber == mapnumber )

  00028	6b 45 f8 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 94 01 d8 39
	00 00		 mov	 edx, DWORD PTR [ecx+eax+14808]
  00036	3b 55 08	 cmp	 edx, DWORD PTR _mapnumber$[ebp]
  00039	0f 85 84 00 00
	00		 jne	 $LN5@GetMoveLev

; 221  : 		{
; 222  : 			if( x >= m_MoveLevel[i].X && x <= m_MoveLevel[i].TX &&
; 223  : 				y >= m_MoveLevel[i].Y && y <= m_MoveLevel[i].TY )

  0003f	6b 45 f8 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00049	3b 94 01 dc 39
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+14812]
  00050	7c 71		 jl	 SHORT $LN5@GetMoveLev
  00052	6b 45 f8 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  0005c	3b 94 01 e4 39
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+14820]
  00063	7f 5e		 jg	 SHORT $LN5@GetMoveLev
  00065	6b 45 f8 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  0006f	3b 94 01 e0 39
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+14816]
  00076	7c 4b		 jl	 SHORT $LN5@GetMoveLev
  00078	6b 45 f8 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8b 55 10	 mov	 edx, DWORD PTR _y$[ebp]
  00082	3b 94 01 e8 39
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+14824]
  00089	7f 38		 jg	 SHORT $LN5@GetMoveLev

; 224  : 			{
; 225  : #ifdef UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108 // 평온의 늪일 경우 마검사나 다크로드도 Movereq.txt 파을에 따라 입장
; 226  : 				if( mapnumber == MAP_INDEX_SWAMP_OF_CALMNESS )
; 227  : 					return m_MoveLevel[i].MoveLevel;
; 228  : #endif	// UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108
; 229  : 				
; 230  : 				if( Class == CLASS_DARKLORD || Class == CLASS_MAGUMSA )					

  0008b	83 7d 14 04	 cmp	 DWORD PTR _Class$[ebp], 4
  0008f	74 06		 je	 SHORT $LN9@GetMoveLev
  00091	83 7d 14 03	 cmp	 DWORD PTR _Class$[ebp], 3
  00095	75 1c		 jne	 SHORT $LN7@GetMoveLev
$LN9@GetMoveLev:

; 231  : 					return (m_MoveLevel[i].MoveLevel*2)/3;

  00097	6b 45 f8 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	8b 84 01 d4 39
	00 00		 mov	 eax, DWORD PTR [ecx+eax+14804]
  000a5	d1 e0		 shl	 eax, 1
  000a7	99		 cdq
  000a8	b9 03 00 00 00	 mov	 ecx, 3
  000ad	f7 f9		 idiv	 ecx
  000af	eb 1a		 jmp	 SHORT $LN1@GetMoveLev
  000b1	eb 10		 jmp	 SHORT $LN5@GetMoveLev
$LN7@GetMoveLev:

; 232  : 				else
; 233  : 					return m_MoveLevel[i].MoveLevel;

  000b3	6b 45 f8 18	 imul	 eax, DWORD PTR _i$1[ebp], 24
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	8b 84 01 d4 39
	00 00		 mov	 eax, DWORD PTR [ecx+eax+14804]
  000c1	eb 08		 jmp	 SHORT $LN1@GetMoveLev
$LN5@GetMoveLev:

; 234  : 			}			
; 235  : 		}
; 236  : 	
; 237  : 	}

  000c3	e9 4d ff ff ff	 jmp	 $LN2@GetMoveLev
$LN3@GetMoveLev:

; 238  : 	return -1;

  000c8	83 c8 ff	 or	 eax, -1
$LN1@GetMoveLev:

; 239  : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 10 00	 ret	 16			; 00000010H
?GetMoveLevel@CMoveCommand@@QAEHHHHH@Z ENDP		; CMoveCommand::GetMoveLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?LoadMoveLevel@CMoveCommand@@QAEHPAD@Z
_TEXT	SEGMENT
_counter$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?LoadMoveLevel@CMoveCommand@@QAEHPAD@Z PROC		; CMoveCommand::LoadMoveLevel, COMDAT
; _this$ = ecx

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 177  : 	memset(m_MoveLevel, -1, sizeof(m_MoveLevel));

  0000c	68 b0 04 00 00	 push	 1200			; 000004b0H
  00011	6a ff		 push	 -1
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	05 d4 39 00 00	 add	 eax, 14804		; 000039d4H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memset
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 178  : 
; 179  : 	if((SMDFile=fopen(filename,"r")) == NULL)

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00029	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _fopen
  00032	83 c4 08	 add	 esp, 8
  00035	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  0003a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  00041	75 18		 jne	 SHORT $LN4@LoadMoveLe

; 180  : 	{
; 181  : 		MsgBox("MoveLevel %s File Load Error", filename);

  00043	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00046	50		 push	 eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FOCHKGPP@MoveLevel?5?$CFs?5File?5Load?5Error@
  0004c	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00051	83 c4 08	 add	 esp, 8

; 182  : 		return FALSE;

  00054	33 c0		 xor	 eax, eax
  00056	e9 27 01 00 00	 jmp	 $LN1@LoadMoveLe
$LN4@LoadMoveLe:

; 183  : 	}
; 184  : 	SMDToken Token;
; 185  : 
; 186  : 	int	counter = 0;

  0005b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _counter$[ebp], 0
$LN2@LoadMoveLe:

; 187  : 
; 188  : 	while( true )

  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	85 c0		 test	 eax, eax
  00069	0f 84 00 01 00
	00		 je	 $LN3@LoadMoveLe

; 189  : 	{
; 190  : 		Token = (*GetToken)();

  0006f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00074	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 191  : 		if(Token == END) break;		

  00077	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  0007b	75 05		 jne	 SHORT $LN5@LoadMoveLe
  0007d	e9 ed 00 00 00	 jmp	 $LN3@LoadMoveLe
$LN5@LoadMoveLe:

; 192  : 		if(Token == NUMBER)

  00082	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00086	0f 85 b7 00 00
	00		 jne	 $LN6@LoadMoveLe

; 193  : 		{	
; 194  : 			m_MoveLevel[counter].MoveLevel = (int)TokenNumber;

  0008c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00094	6b 4d f4 18	 imul	 ecx, DWORD PTR _counter$[ebp], 24
  00098	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	89 84 0a d4 39
	00 00		 mov	 DWORD PTR [edx+ecx+14804], eax

; 195  : 			
; 196  : 			Token = (*GetToken)(); m_MoveLevel[counter].MapNumber = (int)TokenNumber;

  000a2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000a7	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  000aa	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000b2	6b 4d f4 18	 imul	 ecx, DWORD PTR _counter$[ebp], 24
  000b6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b9	89 84 0a d8 39
	00 00		 mov	 DWORD PTR [edx+ecx+14808], eax

; 197  : 			Token = (*GetToken)(); m_MoveLevel[counter].X = (int)TokenNumber;

  000c0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000c5	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  000c8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000d0	6b 4d f4 18	 imul	 ecx, DWORD PTR _counter$[ebp], 24
  000d4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d7	89 84 0a dc 39
	00 00		 mov	 DWORD PTR [edx+ecx+14812], eax

; 198  : 			Token = (*GetToken)(); m_MoveLevel[counter].Y = (int)TokenNumber;

  000de	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000e3	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  000e6	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000ee	6b 4d f4 18	 imul	 ecx, DWORD PTR _counter$[ebp], 24
  000f2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f5	89 84 0a e0 39
	00 00		 mov	 DWORD PTR [edx+ecx+14816], eax

; 199  : 			Token = (*GetToken)(); m_MoveLevel[counter].TX = (int)TokenNumber;

  000fc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00101	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00104	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0010c	6b 4d f4 18	 imul	 ecx, DWORD PTR _counter$[ebp], 24
  00110	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00113	89 84 0a e4 39
	00 00		 mov	 DWORD PTR [edx+ecx+14820], eax

; 200  : 			Token = (*GetToken)(); m_MoveLevel[counter].TY = (int)TokenNumber;

  0011a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0011f	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00122	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0012a	6b 4d f4 18	 imul	 ecx, DWORD PTR _counter$[ebp], 24
  0012e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00131	89 84 0a e8 39
	00 00		 mov	 DWORD PTR [edx+ecx+14824], eax

; 201  : 			counter++;

  00138	8b 45 f4	 mov	 eax, DWORD PTR _counter$[ebp]
  0013b	83 c0 01	 add	 eax, 1
  0013e	89 45 f4	 mov	 DWORD PTR _counter$[ebp], eax

; 202  : 		}

  00141	eb 27		 jmp	 SHORT $LN7@LoadMoveLe
$LN6@LoadMoveLe:

; 203  : 		else
; 204  : 		{
; 205  : 			Init();

  00143	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	e8 00 00 00 00	 call	 ?Init@CMoveCommand@@QAEXXZ ; CMoveCommand::Init

; 206  : 			fclose(SMDFile);

  0014b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _fclose
  00156	83 c4 04	 add	 esp, 4

; 207  : 			MsgBox("MoveLevel script load fail");

  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MDABMPEB@MoveLevel?5script?5load?5fail@
  0015e	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00163	83 c4 04	 add	 esp, 4

; 208  : 			return FALSE;

  00166	33 c0		 xor	 eax, eax
  00168	eb 18		 jmp	 SHORT $LN1@LoadMoveLe
$LN7@LoadMoveLe:

; 209  : 		}
; 210  : 	}

  0016a	e9 f3 fe ff ff	 jmp	 $LN2@LoadMoveLe
$LN3@LoadMoveLe:

; 211  : 	
; 212  : 	fclose(SMDFile);

  0016f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _fclose
  0017a	83 c4 04	 add	 esp, 4

; 213  : 	return TRUE;

  0017d	b8 01 00 00 00	 mov	 eax, 1
$LN1@LoadMoveLe:

; 214  : }

  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5b		 pop	 ebx
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c2 04 00	 ret	 4
?LoadMoveLevel@CMoveCommand@@QAEHPAD@Z ENDP		; CMoveCommand::LoadMoveLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?Load@CMoveCommand@@QAEHPAD@Z
_TEXT	SEGMENT
_counter$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?Load@CMoveCommand@@QAEHPAD@Z PROC			; CMoveCommand::Load, COMDAT
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 	Init();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Init@CMoveCommand@@QAEXXZ ; CMoveCommand::Init

; 91   : 
; 92   : 	if((SMDFile=fopen(filename,"r")) == NULL)

  00014	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00019	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _fopen
  00022	83 c4 08	 add	 esp, 8
  00025	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  0002a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  00031	75 18		 jne	 SHORT $LN4@Load

; 93   : 	{
; 94   : 		MsgBox("MoveCommand %s File Load Error", filename);

  00033	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OIMJHLAA@MoveCommand?5?$CFs?5File?5Load?5Error@
  0003c	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00041	83 c4 08	 add	 esp, 8

; 95   : 		return FALSE;

  00044	33 c0		 xor	 eax, eax
  00046	e9 fa 01 00 00	 jmp	 $LN1@Load
$LN4@Load:

; 96   : 	}
; 97   : 	SMDToken Token;
; 98   : 
; 99   : 	int	counter = 0;

  0004b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _counter$[ebp], 0

; 100  : 
; 101  : 	memset(m_MoveCommandData,0,sizeof(MOVE_COMMAND_DATA)*MAX_MOVE_COMMAND_COUNT);

  00052	68 d0 39 00 00	 push	 14800			; 000039d0H
  00057	6a 00		 push	 0
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 c0 04	 add	 eax, 4
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _memset
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Load:

; 102  : 
; 103  : 	while( true )

  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	85 c0		 test	 eax, eax
  0006f	0f 84 bd 01 00
	00		 je	 $LN3@Load

; 104  : 	{
; 105  : 		Token = (*GetToken)();

  00075	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0007a	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 106  : 		if(Token == END || counter >= MAX_MOVE_COMMAND_COUNT) break;		

  0007d	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00081	74 06		 je	 SHORT $LN6@Load
  00083	83 7d f4 32	 cmp	 DWORD PTR _counter$[ebp], 50 ; 00000032H
  00087	7c 05		 jl	 SHORT $LN5@Load
$LN6@Load:
  00089	e9 a4 01 00 00	 jmp	 $LN3@Load
$LN5@Load:

; 107  : 		if(Token == NUMBER)

  0008e	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00092	0f 85 6e 01 00
	00		 jne	 $LN7@Load

; 108  : 		{	
; 109  : 			m_MoveCommandData[counter].Index = (int)TokenNumber;

  00098	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000a0	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  000a7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	89 44 0a 04	 mov	 DWORD PTR [edx+ecx+4], eax

; 110  : 			Token = (*GetToken)(); strcpy(m_MoveCommandData[counter].Name,TokenString);

  000ae	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000b3	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  000b6	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  000bb	69 45 f4 28 01
	00 00		 imul	 eax, DWORD PTR _counter$[ebp], 296
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _strcpy
  000cf	83 c4 08	 add	 esp, 8

; 111  : 			Token = (*GetToken)(); m_MoveCommandData[counter].NeedZen = (int)TokenNumber;

  000d2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000d7	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  000da	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000e2	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  000e9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000ec	89 84 0a 08 01
	00 00		 mov	 DWORD PTR [edx+ecx+264], eax

; 112  : 			Token = (*GetToken)(); m_MoveCommandData[counter].NeedLevel = (int)TokenNumber;

  000f3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000f8	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  000fb	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00103	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  0010a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0010d	89 84 0a 0c 01
	00 00		 mov	 DWORD PTR [edx+ecx+268], eax

; 113  : 			Token = (*GetToken)(); m_MoveCommandData[counter].MapNumber = (int)TokenNumber;

  00114	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00119	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0011c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00124	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  0012b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0012e	89 84 0a 10 01
	00 00		 mov	 DWORD PTR [edx+ecx+272], eax

; 114  : 			Token = (*GetToken)(); m_MoveCommandData[counter].X1 = (int)TokenNumber;

  00135	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0013a	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0013d	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00145	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  0014c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0014f	89 84 0a 14 01
	00 00		 mov	 DWORD PTR [edx+ecx+276], eax

; 115  : 			Token = (*GetToken)(); m_MoveCommandData[counter].Y1 = (int)TokenNumber;

  00156	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0015b	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0015e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00166	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  0016d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00170	89 84 0a 18 01
	00 00		 mov	 DWORD PTR [edx+ecx+280], eax

; 116  : 			Token = (*GetToken)(); m_MoveCommandData[counter].X2 = (int)TokenNumber;

  00177	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0017c	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0017f	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00187	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  0018e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00191	89 84 0a 1c 01
	00 00		 mov	 DWORD PTR [edx+ecx+284], eax

; 117  : 			Token = (*GetToken)(); m_MoveCommandData[counter].Y2 = (int)TokenNumber;

  00198	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0019d	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  001a0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001a8	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  001af	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001b2	89 84 0a 20 01
	00 00		 mov	 DWORD PTR [edx+ecx+288], eax

; 118  : 			Token = (*GetToken)(); m_MoveCommandData[counter].VIP = (int)TokenNumber;

  001b9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001be	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  001c1	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001c9	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  001d0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001d3	89 84 0a 24 01
	00 00		 mov	 DWORD PTR [edx+ecx+292], eax

; 119  : 			Token = (*GetToken)(); m_MoveCommandData[counter].Reset = (int)TokenNumber;

  001da	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001df	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  001e2	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001ea	69 4d f4 28 01
	00 00		 imul	 ecx, DWORD PTR _counter$[ebp], 296
  001f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f4	89 84 0a 28 01
	00 00		 mov	 DWORD PTR [edx+ecx+296], eax

; 120  : 			counter++;

  001fb	8b 45 f4	 mov	 eax, DWORD PTR _counter$[ebp]
  001fe	83 c0 01	 add	 eax, 1
  00201	89 45 f4	 mov	 DWORD PTR _counter$[ebp], eax

; 121  : 		}

  00204	eb 27		 jmp	 SHORT $LN8@Load
$LN7@Load:

; 122  : 		else
; 123  : 		{
; 124  : 			Init();

  00206	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	e8 00 00 00 00	 call	 ?Init@CMoveCommand@@QAEXXZ ; CMoveCommand::Init

; 125  : 			fclose(SMDFile);

  0020e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 _fclose
  00219	83 c4 04	 add	 esp, 4

; 126  : 			MsgBox("MoveCommand script load fail");

  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DLJJBGJJ@MoveCommand?5script?5load?5fail@
  00221	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00226	83 c4 04	 add	 esp, 4

; 127  : 			return FALSE;

  00229	33 c0		 xor	 eax, eax
  0022b	eb 18		 jmp	 SHORT $LN1@Load
$LN8@Load:

; 128  : 		}
; 129  : 	}

  0022d	e9 36 fe ff ff	 jmp	 $LN2@Load
$LN3@Load:

; 130  : 	
; 131  : 	fclose(SMDFile);

  00232	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 _fclose
  0023d	83 c4 04	 add	 esp, 4

; 132  : 	return TRUE;

  00240	b8 01 00 00 00	 mov	 eax, 1
$LN1@Load:

; 133  : }

  00245	5f		 pop	 edi
  00246	5e		 pop	 esi
  00247	5b		 pop	 ebx
  00248	8b e5		 mov	 esp, ebp
  0024a	5d		 pop	 ebp
  0024b	c2 04 00	 ret	 4
?Load@CMoveCommand@@QAEHPAD@Z ENDP			; CMoveCommand::Load
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?Init@CMoveCommand@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?Init@CMoveCommand@@QAEXXZ PROC				; CMoveCommand::Init, COMDAT
; _this$ = ecx

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 	memset(m_MoveCommandData, 0, sizeof(m_MoveCommandData));

  0000c	68 d0 39 00 00	 push	 14800			; 000039d0H
  00011	6a 00		 push	 0
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _memset
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   : 	for( int i = 0; i <	MAX_MOVE_COMMAND_COUNT; i++ )

  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00029	eb 09		 jmp	 SHORT $LN4@Init
$LN2@Init:
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002e	83 c0 01	 add	 eax, 1
  00031	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Init:
  00034	83 7d f8 32	 cmp	 DWORD PTR _i$1[ebp], 50	; 00000032H
  00038	7d 14		 jge	 SHORT $LN1@Init

; 83   : 	{
; 84   : 		m_MoveCommandData[i].Index = -1;

  0003a	69 45 f8 28 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 296
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	c7 44 01 04 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+4], -1

; 85   : 	}

  0004c	eb dd		 jmp	 SHORT $LN2@Init
$LN1@Init:

; 86   : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?Init@CMoveCommand@@QAEXXZ ENDP				; CMoveCommand::Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ??1CMoveCommand@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMoveCommand@@UAE@XZ PROC				; CMoveCommand::~CMoveCommand, COMDAT
; _this$ = ecx

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMoveCommand@@6B@

; 76   : 
; 77   : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CMoveCommand@@UAE@XZ ENDP				; CMoveCommand::~CMoveCommand
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ??0CMoveCommand@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMoveCommand@@QAE@XZ PROC				; CMoveCommand::CMoveCommand, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMoveCommand@@6B@

; 71   : 
; 72   : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CMoveCommand@@QAE@XZ ENDP				; CMoveCommand::CMoveCommand
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?FindIndex@CMoveCommand@@AAEHPAD@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_mapname$ = 8						; size = 4
?FindIndex@CMoveCommand@@AAEHPAD@Z PROC			; CMoveCommand::FindIndex, COMDAT
; _this$ = ecx

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 361  : 	for( int i = 0; i < MAX_MOVE_COMMAND_COUNT; i++ )

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@FindIndex
$LN2@FindIndex:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@FindIndex:
  0001e	83 7d f8 32	 cmp	 DWORD PTR _i$1[ebp], 50	; 00000032H
  00022	7d 3c		 jge	 SHORT $LN3@FindIndex

; 362  : 	{
; 363  : 		if( m_MoveCommandData[i].Index == -1 )

  00024	69 45 f8 28 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 296
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 7c 01 04 ff	 cmp	 DWORD PTR [ecx+eax+4], -1
  00033	75 05		 jne	 SHORT $LN5@FindIndex

; 364  : 			return -1;

  00035	83 c8 ff	 or	 eax, -1
  00038	eb 29		 jmp	 SHORT $LN1@FindIndex
$LN5@FindIndex:

; 365  : 
; 366  : 		if( _stricmp(mapname, m_MoveCommandData[i].Name ) == 0)

  0003a	69 45 f8 28 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 296
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00048	52		 push	 edx
  00049	8b 45 08	 mov	 eax, DWORD PTR _mapname$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __stricmp
  00052	83 c4 08	 add	 esp, 8
  00055	85 c0		 test	 eax, eax
  00057	75 05		 jne	 SHORT $LN6@FindIndex

; 367  : 		{
; 368  : 			return i;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005c	eb 05		 jmp	 SHORT $LN1@FindIndex
$LN6@FindIndex:

; 369  : 		}
; 370  : 	}

  0005e	eb b5		 jmp	 SHORT $LN2@FindIndex
$LN3@FindIndex:

; 371  : 
; 372  : 	return -1;

  00060	83 c8 ff	 or	 eax, -1
$LN1@FindIndex:

; 373  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
?FindIndex@CMoveCommand@@AAEHPAD@Z ENDP			; CMoveCommand::FindIndex
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\Readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 수정

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TerrainManager.h
;	COMDAT ?CheckTerrain@CTerrainManager@@QAE_NH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_MapNumber$ = 8						; size = 4
?CheckTerrain@CTerrainManager@@QAE_NH@Z PROC		; CTerrainManager::CheckTerrain, COMDAT
; _this$ = ecx

; 57   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 		return this->m_bMapCheck[MapNumber];

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00012	8b 55 08	 mov	 edx, DWORD PTR _MapNumber$[ebp]
  00015	8a 04 11	 mov	 al, BYTE PTR [ecx+edx]

; 59   : 	}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?CheckTerrain@CTerrainManager@@QAE_NH@Z ENDP		; CTerrainManager::CheckTerrain
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MoveCommand.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
