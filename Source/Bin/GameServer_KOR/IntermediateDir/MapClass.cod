; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?Size@CTerrainManager@@QAE?BHXZ			; CTerrainManager::Size
PUBLIC	?GetDist@PATH@@AAEHHHHH@Z			; PATH::GetDist
PUBLIC	?VerifyThatOnPath@PATH@@AAEHHH@Z		; PATH::VerifyThatOnPath
PUBLIC	?CanWeMoveForward@PATH@@AAEHHH@Z		; PATH::CanWeMoveForward
PUBLIC	?CanWeMoveForward2@PATH@@AAEHHH@Z		; PATH::CanWeMoveForward2
PUBLIC	?IsThisSpotOK@PATH@@AAEHHH@Z			; PATH::IsThisSpotOK
PUBLIC	?FindNextDir@PATH@@AAEHHHHHH_N0@Z		; PATH::FindNextDir
PUBLIC	?FindNextDir2@PATH@@AAEHHHHHH_N0@Z		; PATH::FindNextDir2
PUBLIC	??0PATH@@QAE@XZ					; PATH::PATH
PUBLIC	??1PATH@@QAE@XZ					; PATH::~PATH
PUBLIC	?FindPath@PATH@@QAE_NHHHH_N@Z			; PATH::FindPath
PUBLIC	?FindPath2@PATH@@QAE_NHHHH_N@Z			; PATH::FindPath2
PUBLIC	?SetMapDimensions@PATH@@QAEXHHPAE@Z		; PATH::SetMapDimensions
PUBLIC	?GetPath@PATH@@QAEHXZ				; PATH::GetPath
PUBLIC	?GetPathX@PATH@@QAEPAEXZ			; PATH::GetPathX
PUBLIC	?GetPathY@PATH@@QAEPAEXZ			; PATH::GetPathY
PUBLIC	??_GPATH@@QAEPAXI@Z				; PATH::`scalar deleting destructor'
PUBLIC	?SaveItemInfo@MapClass@@QAEXXZ			; MapClass::SaveItemInfo
PUBLIC	?GetLevelPos@MapClass@@QAEXFAAF0@Z		; MapClass::GetLevelPos
PUBLIC	?GetMapPos@MapClass@@QAEXFAAF0@Z		; MapClass::GetMapPos
PUBLIC	?GetRandomLengthPos@MapClass@@QAEXAAF0H@Z	; MapClass::GetRandomLengthPos
PUBLIC	?SearchStandAttr@MapClass@@QAEXAAF0@Z		; MapClass::SearchStandAttr
PUBLIC	?AttrLoad@MapClass@@QAEHPAD@Z			; MapClass::AttrLoad
PUBLIC	?LoadMapAttr@MapClass@@QAEXPADH@Z		; MapClass::LoadMapAttr
PUBLIC	?CheckWall@MapClass@@QAEHHHHH@Z			; MapClass::CheckWall
PUBLIC	?CheckWall2@MapClass@@QAEEHHHH@Z		; MapClass::CheckWall2
PUBLIC	?ItemInit@MapClass@@QAEXXZ			; MapClass::ItemInit
PUBLIC	?ItemGive@MapClass@@QAEHHH_N@Z			; MapClass::ItemGive
PUBLIC	?ClearItem@MapClass@@QAEHPAVOBJECTSTRUCT@@H@Z	; MapClass::ClearItem
PUBLIC	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z	; MapClass::ItemDrop
PUBLIC	?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z	; MapClass::MonsterItemDrop
PUBLIC	?MoneyItemDrop@MapClass@@QAEHHHH@Z		; MapClass::MoneyItemDrop
PUBLIC	?WeatherVariationProcess@MapClass@@QAEXXZ	; MapClass::WeatherVariationProcess
PUBLIC	?GetWeather@MapClass@@QAEEXZ			; MapClass::GetWeather
PUBLIC	?SetWeather@MapClass@@QAEXEE@Z			; MapClass::SetWeather
PUBLIC	?StateSetDestroy@MapClass@@QAEXXZ		; MapClass::StateSetDestroy
PUBLIC	?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z	; MapClass::PathFinding2
PUBLIC	?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z	; MapClass::PathFinding3
PUBLIC	?SetStandAttr@MapClass@@QAEXHH@Z		; MapClass::SetStandAttr
PUBLIC	?ClearStandAttr@MapClass@@QAEXHH@Z		; MapClass::ClearStandAttr
PUBLIC	?GetStandAttr@MapClass@@QAEHHH@Z		; MapClass::GetStandAttr
PUBLIC	?GetAttr@MapClass@@QAEEHH@Z			; MapClass::GetAttr
PUBLIC	?init@MapClass@@QAEXXZ				; MapClass::init
PUBLIC	?free@MapClass@@QAEXXZ				; MapClass::free
PUBLIC	??0MapClass@@QAE@XZ				; MapClass::MapClass
PUBLIC	??1MapClass@@UAE@XZ				; MapClass::~MapClass
PUBLIC	??_GMapClass@@UAEPAXI@Z				; MapClass::`scalar deleting destructor'
PUBLIC	?MapNumberCheck@@YAHH@Z				; MapNumberCheck
PUBLIC	?TERRAIN_INDEX_REPEAT@@YAHHH@Z			; TERRAIN_INDEX_REPEAT
PUBLIC	??_7MapClass@@6B@				; MapClass::`vftable'
PUBLIC	??_C@_0BL@CIFNLNKN@?4?4?2data?2TerrainManager?4cfg@ ; `string'
PUBLIC	?__LINE__Var@?0??GetLevelPos@MapClass@@QAEXFAAF0@Z@4JA ; `MapClass::GetLevelPos'::`1'::__LINE__Var
PUBLIC	??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	?__LINE__Var@?0??GetMapPos@MapClass@@QAEXFAAF0@Z@4JA ; `MapClass::GetMapPos'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z@4JA ; `MapClass::MonsterItemDrop'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z@4JA ; `MapClass::ItemDrop'::`1'::__LINE__Var
PUBLIC	??_C@_0EL@BKCBEOOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	?__LINE__Var@?0??ItemGive@MapClass@@QAEHHH_N@Z@4JA ; `MapClass::ItemGive'::`1'::__LINE__Var
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_R4MapClass@@6B@				; MapClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMapClass@@@8				; MapClass `RTTI Type Descriptor'
PUBLIC	??_R3MapClass@@8				; MapClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MapClass@@8				; MapClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MapClass@@8			; MapClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__SetRect@20:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_rand:PROC
EXTRN	_sqrt:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	??0CMapItem@@QAE@XZ:PROC			; CMapItem::CMapItem
EXTRN	??1CMapItem@@UAE@XZ:PROC			; CMapItem::~CMapItem
EXTRN	?CreateItem@CMapItem@@QAEXHHHHMEEEEEK@Z:PROC	; CMapItem::CreateItem
EXTRN	?DropCreateItem@CMapItem@@QAEXHHHHMEEEEEKHH@Z:PROC ; CMapItem::DropCreateItem
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?CGWeatherSend@@YAXHE@Z:PROC			; CGWeatherSend
EXTRN	?Load@CTerrainManager@@QAEXPBD@Z:PROC		; CTerrainManager::Load
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	??_EMapClass@@UAEPAXI@Z:PROC			; MapClass::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__except_handler4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_TerrainManager@@3VCTerrainManager@@A:BYTE	; g_TerrainManager
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gLootingTime@@3HA:DWORD			; gLootingTime
EXTRN	?gZenDurationTime@@3HA:DWORD			; gZenDurationTime
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ??_R1A@?0A@EA@MapClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MapClass@@8 DD FLAT:??_R0?AVMapClass@@@8	; MapClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MapClass@@8
rdata$r	ENDS
;	COMDAT ??_R2MapClass@@8
rdata$r	SEGMENT
??_R2MapClass@@8 DD FLAT:??_R1A@?0A@EA@MapClass@@8	; MapClass::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MapClass@@8
rdata$r	SEGMENT
??_R3MapClass@@8 DD 00H					; MapClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MapClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMapClass@@@8
data$r	SEGMENT
??_R0?AVMapClass@@@8 DD FLAT:??_7type_info@@6B@		; MapClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMapClass@@', 00H
data$r	ENDS
;	COMDAT ??_R4MapClass@@6B@
rdata$r	SEGMENT
??_R4MapClass@@6B@ DD 00H				; MapClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMapClass@@@8
	DD	FLAT:??_R3MapClass@@8
rdata$r	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ItemGive@MapClass@@QAEHHH_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ItemGive@MapClass@@QAEHHH_N@Z@4JA DD 027aH ; `MapClass::ItemGive'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EL@BKCBEOOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0EL@BKCBEOOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) Dropped Angel King'''
	DB	's Weapon (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z@4JA DD 01ebH ; `MapClass::ItemDrop'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z@4JA DD 018fH ; `MapClass::MonsterItemDrop'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GetMapPos@MapClass@@QAEXFAAF0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetMapPos@MapClass@@QAEXFAAF0@Z@4JA DD 0acH ; `MapClass::GetMapPos'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onl'
	DB	'ine\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetLevelPos@MapClass@@QAEXFAAF0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetLevelPos@MapClass@@QAEXFAAF0@Z@4JA DD 065H ; `MapClass::GetLevelPos'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BL@CIFNLNKN@?4?4?2data?2TerrainManager?4cfg@
CONST	SEGMENT
??_C@_0BL@CIFNLNKN@?4?4?2data?2TerrainManager?4cfg@ DB '..\data\TerrainMa'
	DB	'nager.cfg', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7MapClass@@6B@
CONST	SEGMENT
??_7MapClass@@6B@ DD FLAT:??_R4MapClass@@6B@		; MapClass::`vftable'
	DD	FLAT:??_EMapClass@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MapClass@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MapClass@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MapClass@@QAE@XZ$0
__ehfuncinfo$??0MapClass@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MapClass@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?init@MapClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@MapClass@@QAEXXZ$0
__ehfuncinfo$?init@MapClass@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?init@MapClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetMapPos@MapClass@@QAEXFAAF0@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff74H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN15@GetMapPos
	DD	FLAT:$LN11@GetMapPos
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetLevelPos@MapClass@@QAEXFAAF0@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff74H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN13@GetLevelPo
	DD	FLAT:$LN9@GetLevelPo
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?TERRAIN_INDEX_REPEAT@@YAHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?TERRAIN_INDEX_REPEAT@@YAHHH@Z PROC			; TERRAIN_INDEX_REPEAT, COMDAT

; 1010 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1011 : 	return (y&TERRAIN_SIZE_MASK)*TERRAIN_SIZE+(x&TERRAIN_SIZE_MASK);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0000c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00011	c1 e0 08	 shl	 eax, 8
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00017	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001d	03 c1		 add	 eax, ecx

; 1012 : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?TERRAIN_INDEX_REPEAT@@YAHHH@Z ENDP			; TERRAIN_INDEX_REPEAT
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?MapNumberCheck@@YAHH@Z
_TEXT	SEGMENT
_map$ = 8						; size = 4
?MapNumberCheck@@YAHH@Z PROC				; MapNumberCheck, COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	if( map < 0 || map > g_TerrainManager.Size()-1 ) return FALSE;

  00009	83 7d 08 00	 cmp	 DWORD PTR _map$[ebp], 0
  0000d	7c 12		 jl	 SHORT $LN3@MapNumberC
  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00014	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  00019	83 e8 01	 sub	 eax, 1
  0001c	39 45 08	 cmp	 DWORD PTR _map$[ebp], eax
  0001f	7e 04		 jle	 SHORT $LN2@MapNumberC
$LN3@MapNumberC:
  00021	33 c0		 xor	 eax, eax
  00023	eb 05		 jmp	 SHORT $LN1@MapNumberC
$LN2@MapNumberC:

; 96   : 	return TRUE;

  00025	b8 01 00 00 00	 mov	 eax, 1
$LN1@MapNumberC:

; 97   : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?MapNumberCheck@@YAHH@Z ENDP				; MapNumberCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GMapClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMapClass@@UAEPAXI@Z PROC				; MapClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1MapClass@@UAE@XZ	; MapClass::~MapClass
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 8c 04 05 00	 push	 328844			; 0005048cH
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GMapClass@@UAEPAXI@Z ENDP				; MapClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ??1MapClass@@UAE@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1MapClass@@UAE@XZ PROC				; MapClass::~MapClass, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1MapClass@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MapClass@@6B@

; 88   : 	delete[] gRegenRect;

  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 88 84 04 05
	00		 mov	 ecx, DWORD PTR [eax+328836]
  0003d	89 4d ac	 mov	 DWORD PTR $T2[ebp], ecx
  00040	8b 55 ac	 mov	 edx, DWORD PTR $T2[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00049	83 c4 04	 add	 esp, 4

; 89   : 	free();

  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?free@MapClass@@QAEXXZ	; MapClass::free

; 90   : }

  00054	68 00 00 00 00	 push	 OFFSET ??1CMapItem@@UAE@XZ ; CMapItem::~CMapItem
  00059	68 2c 01 00 00	 push	 300			; 0000012cH
  0005e	68 48 04 00 00	 push	 1096			; 00000448H
  00063	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00066	83 c0 20	 add	 eax, 32			; 00000020H
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
  00081	cc		 int	 3
  00082	cc		 int	 3
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1MapClass@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1MapClass@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1MapClass@@UAE@XZ ENDP				; MapClass::~MapClass
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ??0MapClass@@QAE@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0MapClass@@QAE@XZ PROC				; MapClass::MapClass, COMDAT
; _this$ = ecx

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0MapClass@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MapClass@@6B@
  00034	68 00 00 00 00	 push	 OFFSET ??1CMapItem@@UAE@XZ ; CMapItem::~CMapItem
  00039	68 00 00 00 00	 push	 OFFSET ??0CMapItem@@QAE@XZ ; CMapItem::CMapItem
  0003e	68 2c 01 00 00	 push	 300			; 0000012cH
  00043	68 48 04 00 00	 push	 1096			; 00000448H
  00048	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	83 c0 20	 add	 eax, 32			; 00000020H
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 51   : 	if(g_TerrainManager.Size() < 1)

  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00060	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  00065	83 f8 01	 cmp	 eax, 1
  00068	7d 0f		 jge	 SHORT $LN2@MapClass

; 52   : 		g_TerrainManager.Load();

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CIFNLNKN@?4?4?2data?2TerrainManager?4cfg@
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00074	e8 00 00 00 00	 call	 ?Load@CTerrainManager@@QAEXPBD@Z ; CTerrainManager::Load
$LN2@MapClass:

; 53   : 
; 54   : 	gRegenRect = new RECT[g_TerrainManager.Size()];

  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  0007e	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  00083	33 c9		 xor	 ecx, ecx
  00085	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0008a	f7 e2		 mul	 edx
  0008c	0f 90 c1	 seto	 cl
  0008f	f7 d9		 neg	 ecx
  00091	0b c8		 or	 ecx, eax
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00099	83 c4 04	 add	 esp, 4
  0009c	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax
  0009f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	8b 4d ac	 mov	 ecx, DWORD PTR $T2[ebp]
  000a5	89 88 84 04 05
	00		 mov	 DWORD PTR [eax+328836], ecx

; 55   : 
; 56   : 	m_Weather = 0;

  000ab	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 57   : 	m_WeatherTimer = GetTickCount();

  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 58   : 	m_NextWeatherTimer = (10*1000)+(rand()%(10*1000));

  000be	e8 00 00 00 00	 call	 _rand
  000c3	99		 cdq
  000c4	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  000c9	f7 f9		 idiv	 ecx
  000cb	81 c2 10 27 00
	00		 add	 edx, 10000		; 00002710H
  000d1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 59   : 	init();

  000d7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	e8 00 00 00 00	 call	 ?init@MapClass@@QAEXXZ	; MapClass::init

; 60   : 
; 61   : 	SetRect(&gRegenRect[0], 130,116,151,137);	// 로렌시아

  000df	68 89 00 00 00	 push	 137			; 00000089H
  000e4	68 97 00 00 00	 push	 151			; 00000097H
  000e9	6a 74		 push	 116			; 00000074H
  000eb	68 82 00 00 00	 push	 130			; 00000082H
  000f0	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000f5	6b c8 00	 imul	 ecx, eax, 0
  000f8	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000fb	03 8a 84 04 05
	00		 add	 ecx, DWORD PTR [edx+328836]
  00101	51		 push	 ecx
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 62   : 	//SetRect(&gRegenRect[1], 130,116,151,137);	// 던전 
; 63   : 	SetRect(&gRegenRect[1], 106,236,112,243);	// 던전 

  00108	68 f3 00 00 00	 push	 243			; 000000f3H
  0010d	6a 70		 push	 112			; 00000070H
  0010f	68 ec 00 00 00	 push	 236			; 000000ecH
  00114	6a 6a		 push	 106			; 0000006aH
  00116	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0011b	c1 e0 00	 shl	 eax, 0
  0011e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	03 81 84 04 05
	00		 add	 eax, DWORD PTR [ecx+328836]
  00127	50		 push	 eax
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 64   : 	SetRect(&gRegenRect[2], 197, 35,218, 50);	// 데비아스

  0012e	6a 32		 push	 50			; 00000032H
  00130	68 da 00 00 00	 push	 218			; 000000daH
  00135	6a 23		 push	 35			; 00000023H
  00137	68 c5 00 00 00	 push	 197			; 000000c5H
  0013c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00141	d1 e0		 shl	 eax, 1
  00143	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	03 81 84 04 05
	00		 add	 eax, DWORD PTR [ecx+328836]
  0014c	50		 push	 eax
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 65   : 	SetRect(&gRegenRect[3], 174,101,187,125);   // 요정숲

  00153	6a 7d		 push	 125			; 0000007dH
  00155	68 bb 00 00 00	 push	 187			; 000000bbH
  0015a	6a 65		 push	 101			; 00000065H
  0015c	68 ae 00 00 00	 push	 174			; 000000aeH
  00161	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00166	6b c8 03	 imul	 ecx, eax, 3
  00169	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0016c	03 8a 84 04 05
	00		 add	 ecx, DWORD PTR [edx+328836]
  00172	51		 push	 ecx
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 66   : 	SetRect(&gRegenRect[4], 201, 70,213, 81);   // LOST TOWER

  00179	6a 51		 push	 81			; 00000051H
  0017b	68 d5 00 00 00	 push	 213			; 000000d5H
  00180	6a 46		 push	 70			; 00000046H
  00182	68 c9 00 00 00	 push	 201			; 000000c9H
  00187	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0018c	c1 e0 02	 shl	 eax, 2
  0018f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00192	03 81 84 04 05
	00		 add	 eax, DWORD PTR [ecx+328836]
  00198	50		 push	 eax
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 67   : 	SetRect(&gRegenRect[5],  89,135, 90,136);   // 쿤둔맵

  0019f	68 88 00 00 00	 push	 136			; 00000088H
  001a4	6a 5a		 push	 90			; 0000005aH
  001a6	68 87 00 00 00	 push	 135			; 00000087H
  001ab	6a 59		 push	 89			; 00000059H
  001ad	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001b2	6b c8 05	 imul	 ecx, eax, 5
  001b5	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001b8	03 8a 84 04 05
	00		 add	 ecx, DWORD PTR [edx+328836]
  001be	51		 push	 ecx
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 68   : 	SetRect(&gRegenRect[6],  89,135, 90,136);   // 

  001c5	68 88 00 00 00	 push	 136			; 00000088H
  001ca	6a 5a		 push	 90			; 0000005aH
  001cc	68 87 00 00 00	 push	 135			; 00000087H
  001d1	6a 59		 push	 89			; 00000059H
  001d3	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001d8	6b c8 06	 imul	 ecx, eax, 6
  001db	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001de	03 8a 84 04 05
	00		 add	 ecx, DWORD PTR [edx+328836]
  001e4	51		 push	 ecx
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 69   : 	SetRect(&gRegenRect[7],  14, 11, 27, 23);   // 아틀란스

  001eb	6a 17		 push	 23			; 00000017H
  001ed	6a 1b		 push	 27			; 0000001bH
  001ef	6a 0b		 push	 11			; 0000000bH
  001f1	6a 0e		 push	 14			; 0000000eH
  001f3	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001f8	6b c8 07	 imul	 ecx, eax, 7
  001fb	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001fe	03 8a 84 04 05
	00		 add	 ecx, DWORD PTR [edx+328836]
  00204	51		 push	 ecx
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 70   : 	SetRect(&gRegenRect[8], 187, 54,203, 69);   // 사막

  0020b	6a 45		 push	 69			; 00000045H
  0020d	68 cb 00 00 00	 push	 203			; 000000cbH
  00212	6a 36		 push	 54			; 00000036H
  00214	68 bb 00 00 00	 push	 187			; 000000bbH
  00219	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0021e	c1 e0 03	 shl	 eax, 3
  00221	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00224	03 81 84 04 05
	00		 add	 eax, DWORD PTR [ecx+328836]
  0022a	50		 push	 eax
  0022b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20

; 71   : 
; 72   : #ifdef ADD_NEW_MAP_AIDA_20050617
; 73   : 	SetRect(&gRegenRect[MAP_INDEX_AIDA], 82,	8,	87,	14);   // 아이다
; 74   : #endif
; 75   : 	
; 76   : #ifdef ADD_NEW_MAP_CRYWOLF_FIRSTZONE_20050414
; 77   : 	SetRect(&gRegenRect[MAP_INDEX_CRYWOLF_FIRSTZONE], 133,	41,	140, 44);   // 크라이울프
; 78   : #endif
; 79   : 
; 80   : #ifdef ADD_SEASON_3_NEW_MAP_20070910
; 81   : 	SetRect(&gRegenRect[MAP_INDEX_ELBELAND], 40,	214,	43,	224);	   // 엘베란드
; 82   : #endif
; 83   : 	m_ItemCount = 0;

  00231	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00234	c7 80 80 04 05
	00 00 00 00 00	 mov	 DWORD PTR [eax+328832], 0

; 84   : }

  0023e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00245	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00248	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0024b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00252	59		 pop	 ecx
  00253	5f		 pop	 edi
  00254	5e		 pop	 esi
  00255	5b		 pop	 ebx
  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MapClass@@QAE@XZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1CMapItem@@UAE@XZ ; CMapItem::~CMapItem
  00005	68 2c 01 00 00	 push	 300			; 0000012cH
  0000a	68 48 04 00 00	 push	 1096			; 00000448H
  0000f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 c0 20	 add	 eax, 32			; 00000020H
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0001b	c3		 ret	 0
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
__ehhandler$??0MapClass@@QAE@XZ:
  00021	90		 npad	 1
  00022	90		 npad	 1
  00023	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00027	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002a	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0MapClass@@QAE@XZ
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0MapClass@@QAE@XZ ENDP				; MapClass::MapClass
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.h
;	COMDAT ?free@MapClass@@QAEXXZ
_TEXT	SEGMENT
tv76 = -76						; size = 4
$T1 = -72						; size = 4
_this$ = -4						; size = 4
?free@MapClass@@QAEXXZ PROC				; MapClass::free, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : 		if( m_attrbuf != NULL ) 

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00013	74 17		 je	 SHORT $LN2@free

; 147  : 		{	
; 148  : 			GlobalFree( m_attrbuf );

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0001b	51		 push	 ecx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 149  : 			m_attrbuf = NULL;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN2@free:

; 150  : 		}
; 151  : 		if( path != NULL )

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00033	74 2f		 je	 SHORT $LN1@free

; 152  : 		{
; 153  : 			delete path;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0003b	89 4d b8	 mov	 DWORD PTR $T1[ebp], ecx
  0003e	83 7d b8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00042	74 0f		 je	 SHORT $LN5@free
  00044	6a 01		 push	 1
  00046	8b 4d b8	 mov	 ecx, DWORD PTR $T1[ebp]
  00049	e8 00 00 00 00	 call	 ??_GPATH@@QAEPAXI@Z
  0004e	89 45 b4	 mov	 DWORD PTR tv76[ebp], eax
  00051	eb 07		 jmp	 SHORT $LN6@free
$LN5@free:
  00053	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN6@free:

; 154  : 			path = NULL;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN1@free:

; 155  : 		}
; 156  : 	};

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?free@MapClass@@QAEXXZ ENDP				; MapClass::free
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.h
;	COMDAT ?init@MapClass@@QAEXXZ
_TEXT	SEGMENT
tv77 = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?init@MapClass@@QAEXXZ PROC				; MapClass::init, COMDAT
; _this$ = ecx

; 138  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?init@MapClass@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		m_attrbuf = NULL;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 140  : 		path      = new PATH;

  00035	68 54 04 00 00	 push	 1108			; 00000454H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	83 7d a8 00	 cmp	 DWORD PTR $T2[ebp], 0
  00050	74 0d		 je	 SHORT $LN3@init
  00052	8b 4d a8	 mov	 ecx, DWORD PTR $T2[ebp]
  00055	e8 00 00 00 00	 call	 ??0PATH@@QAE@XZ		; PATH::PATH
  0005a	89 45 a4	 mov	 DWORD PTR tv77[ebp], eax
  0005d	eb 07		 jmp	 SHORT $LN4@init
$LN3@init:
  0005f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN4@init:
  00066	8b 45 a4	 mov	 eax, DWORD PTR tv77[ebp]
  00069	89 45 ac	 mov	 DWORD PTR $T3[ebp], eax
  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 55 ac	 mov	 edx, DWORD PTR $T3[ebp]
  00079	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 141  : 		m_width   = 0;

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 142  : 		m_height  = 0;

  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 143  : 	};

  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@MapClass@@QAEXXZ$0:
  00000	68 54 04 00 00	 push	 1108			; 00000454H
  00005	8b 45 a8	 mov	 eax, DWORD PTR $T2[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
__ehhandler$?init@MapClass@@QAEXXZ:
  00017	90		 npad	 1
  00018	90		 npad	 1
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?init@MapClass@@QAEXXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?init@MapClass@@QAEXXZ ENDP				; MapClass::init
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?GetAttr@MapClass@@QAEEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetAttr@MapClass@@QAEEHH@Z PROC			; MapClass::GetAttr, COMDAT
; _this$ = ecx

; 903  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 904  : 	if( x < 0 ) return MAP_ATTR_BLOCK;

  0000c	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00010	7d 04		 jge	 SHORT $LN2@GetAttr
  00012	b0 04		 mov	 al, 4
  00014	eb 40		 jmp	 SHORT $LN1@GetAttr
$LN2@GetAttr:

; 905  : 	if( y < 0 ) return MAP_ATTR_BLOCK;

  00016	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  0001a	7d 04		 jge	 SHORT $LN3@GetAttr
  0001c	b0 04		 mov	 al, 4
  0001e	eb 36		 jmp	 SHORT $LN1@GetAttr
$LN3@GetAttr:

; 906  : 	if( x > m_width-1 ) return MAP_ATTR_BLOCK;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00026	83 e9 01	 sub	 ecx, 1
  00029	39 4d 08	 cmp	 DWORD PTR _x$[ebp], ecx
  0002c	7e 04		 jle	 SHORT $LN4@GetAttr
  0002e	b0 04		 mov	 al, 4
  00030	eb 24		 jmp	 SHORT $LN1@GetAttr
$LN4@GetAttr:

; 907  : 	if( y > m_height-1 ) return MAP_ATTR_BLOCK;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00038	83 e9 01	 sub	 ecx, 1
  0003b	39 4d 0c	 cmp	 DWORD PTR _y$[ebp], ecx
  0003e	7e 04		 jle	 SHORT $LN5@GetAttr
  00040	b0 04		 mov	 al, 4
  00042	eb 12		 jmp	 SHORT $LN1@GetAttr
$LN5@GetAttr:

; 908  : 	
; 909  : 	return (BYTE)(m_attrbuf[(y*MAX_TERRAIN_SIZE)+x]);

  00044	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00047	c1 e0 08	 shl	 eax, 8
  0004a	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00053	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
$LN1@GetAttr:

; 910  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
?GetAttr@MapClass@@QAEEHH@Z ENDP			; MapClass::GetAttr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?GetStandAttr@MapClass@@QAEHHH@Z
_TEXT	SEGMENT
_attr$ = -5						; size = 1
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetStandAttr@MapClass@@QAEHHH@Z PROC			; MapClass::GetStandAttr, COMDAT
; _this$ = ecx

; 914  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 915  : 	if( x > m_width-1 ) return FALSE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00012	83 e9 01	 sub	 ecx, 1
  00015	39 4d 08	 cmp	 DWORD PTR _x$[ebp], ecx
  00018	7e 04		 jle	 SHORT $LN2@GetStandAt
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 53		 jmp	 SHORT $LN1@GetStandAt
$LN2@GetStandAt:

; 916  : 	if( y > m_height-1 ) return FALSE;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00024	83 e9 01	 sub	 ecx, 1
  00027	39 4d 0c	 cmp	 DWORD PTR _y$[ebp], ecx
  0002a	7e 04		 jle	 SHORT $LN3@GetStandAt
  0002c	33 c0		 xor	 eax, eax
  0002e	eb 41		 jmp	 SHORT $LN1@GetStandAt
$LN3@GetStandAt:

; 917  : 	BYTE attr;
; 918  : 
; 919  : 	attr = m_attrbuf[(y*MAX_TERRAIN_SIZE)+x];

  00030	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00033	c1 e0 08	 shl	 eax, 8
  00036	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0003f	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00042	88 45 fb	 mov	 BYTE PTR _attr$[ebp], al

; 920  : 	
; 921  : 	if( (attr&MAP_ATTR_STAND)	== MAP_ATTR_STAND ) return FALSE;

  00045	0f b6 45 fb	 movzx	 eax, BYTE PTR _attr$[ebp]
  00049	83 e0 02	 and	 eax, 2
  0004c	74 04		 je	 SHORT $LN4@GetStandAt
  0004e	33 c0		 xor	 eax, eax
  00050	eb 1f		 jmp	 SHORT $LN1@GetStandAt
$LN4@GetStandAt:

; 922  : 	if( (attr&MAP_ATTR_BLOCK)	== MAP_ATTR_BLOCK ) return FALSE;

  00052	0f b6 45 fb	 movzx	 eax, BYTE PTR _attr$[ebp]
  00056	83 e0 04	 and	 eax, 4
  00059	74 04		 je	 SHORT $LN5@GetStandAt
  0005b	33 c0		 xor	 eax, eax
  0005d	eb 12		 jmp	 SHORT $LN1@GetStandAt
$LN5@GetStandAt:

; 923  : 	if( (attr&MAP_ATTR_HOLLOW)	== MAP_ATTR_HOLLOW) return FALSE;

  0005f	0f b6 45 fb	 movzx	 eax, BYTE PTR _attr$[ebp]
  00063	83 e0 08	 and	 eax, 8
  00066	74 04		 je	 SHORT $LN6@GetStandAt
  00068	33 c0		 xor	 eax, eax
  0006a	eb 05		 jmp	 SHORT $LN1@GetStandAt
$LN6@GetStandAt:

; 924  : 	
; 925  : 	return TRUE;

  0006c	b8 01 00 00 00	 mov	 eax, 1
$LN1@GetStandAt:

; 926  : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
?GetStandAttr@MapClass@@QAEHHH@Z ENDP			; MapClass::GetStandAttr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?ClearStandAttr@MapClass@@QAEXHH@Z
_TEXT	SEGMENT
tv75 = -76						; size = 4
tv68 = -76						; size = 4
tv76 = -72						; size = 4
tv69 = -72						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?ClearStandAttr@MapClass@@QAEXHH@Z PROC			; MapClass::ClearStandAttr, COMDAT
; _this$ = ecx

; 966  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 967  : #ifdef CLEAR_STANDATTR_OBJDEL_20050325
; 968  : 	if (!CHECK_LIMIT(x, m_width))	return;

  0000c	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN8@ClearStand
  00012	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00019	eb 24		 jmp	 SHORT $LN9@ClearStand
$LN8@ClearStand:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00021	83 e9 01	 sub	 ecx, 1
  00024	39 4d 08	 cmp	 DWORD PTR _x$[ebp], ecx
  00027	7e 09		 jle	 SHORT $LN6@ClearStand
  00029	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00030	eb 07		 jmp	 SHORT $LN7@ClearStand
$LN6@ClearStand:
  00032	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
$LN7@ClearStand:
  00039	8b 55 b4	 mov	 edx, DWORD PTR tv68[ebp]
  0003c	89 55 b8	 mov	 DWORD PTR tv69[ebp], edx
$LN9@ClearStand:
  0003f	83 7d b8 00	 cmp	 DWORD PTR tv69[ebp], 0
  00043	75 02		 jne	 SHORT $LN2@ClearStand
  00045	eb 7d		 jmp	 SHORT $LN1@ClearStand
$LN2@ClearStand:

; 969  : 	if (!CHECK_LIMIT(y, m_height))	return;

  00047	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  0004b	7d 09		 jge	 SHORT $LN12@ClearStand
  0004d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  00054	eb 24		 jmp	 SHORT $LN13@ClearStand
$LN12@ClearStand:
  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005c	83 e9 01	 sub	 ecx, 1
  0005f	39 4d 0c	 cmp	 DWORD PTR _y$[ebp], ecx
  00062	7e 09		 jle	 SHORT $LN10@ClearStand
  00064	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  0006b	eb 07		 jmp	 SHORT $LN11@ClearStand
$LN10@ClearStand:
  0006d	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
$LN11@ClearStand:
  00074	8b 55 b4	 mov	 edx, DWORD PTR tv75[ebp]
  00077	89 55 b8	 mov	 DWORD PTR tv76[ebp], edx
$LN13@ClearStand:
  0007a	83 7d b8 00	 cmp	 DWORD PTR tv76[ebp], 0
  0007e	75 02		 jne	 SHORT $LN3@ClearStand
  00080	eb 42		 jmp	 SHORT $LN1@ClearStand
$LN3@ClearStand:

; 970  : #else
; 971  : 	if( x > m_width-1 ) return;
; 972  : 	if( y > m_height-1 ) return;
; 973  : #endif
; 974  : 	if( (m_attrbuf[(y*MAX_TERRAIN_SIZE)+x]&MAP_ATTR_STAND) == MAP_ATTR_STAND ) m_attrbuf[(y*MAX_TERRAIN_SIZE)+x] &= 0xFD;

  00082	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00085	c1 e0 08	 shl	 eax, 8
  00088	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00091	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  00095	83 e0 02	 and	 eax, 2
  00098	74 2a		 je	 SHORT $LN1@ClearStand
  0009a	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0009d	c1 e0 08	 shl	 eax, 8
  000a0	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000a9	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  000ad	25 fd 00 00 00	 and	 eax, 253		; 000000fdH
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000b5	c1 e1 08	 shl	 ecx, 8
  000b8	03 4d 08	 add	 ecx, DWORD PTR _x$[ebp]
  000bb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000be	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  000c1	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$LN1@ClearStand:

; 975  : }

  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c2 08 00	 ret	 8
?ClearStandAttr@MapClass@@QAEXHH@Z ENDP			; MapClass::ClearStandAttr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?SetStandAttr@MapClass@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetStandAttr@MapClass@@QAEXHH@Z PROC			; MapClass::SetStandAttr, COMDAT
; _this$ = ecx

; 958  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 959  : 	if( x > m_width-1 ) return;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00012	83 e9 01	 sub	 ecx, 1
  00015	39 4d 08	 cmp	 DWORD PTR _x$[ebp], ecx
  00018	7e 02		 jle	 SHORT $LN2@SetStandAt
  0001a	eb 38		 jmp	 SHORT $LN1@SetStandAt
$LN2@SetStandAt:

; 960  : 	if( y > m_height-1 ) return;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00022	83 e9 01	 sub	 ecx, 1
  00025	39 4d 0c	 cmp	 DWORD PTR _y$[ebp], ecx
  00028	7e 02		 jle	 SHORT $LN3@SetStandAt
  0002a	eb 28		 jmp	 SHORT $LN1@SetStandAt
$LN3@SetStandAt:

; 961  : 	m_attrbuf[(y*MAX_TERRAIN_SIZE)+x] |= MAP_ATTR_STAND;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0002f	c1 e0 08	 shl	 eax, 8
  00032	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0003b	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  0003f	83 c8 02	 or	 eax, 2
  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00045	c1 e1 08	 shl	 ecx, 8
  00048	03 4d 08	 add	 ecx, DWORD PTR _x$[ebp]
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  00051	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$LN1@SetStandAt:

; 962  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
?SetStandAttr@MapClass@@QAEXHH@Z ENDP			; MapClass::SetStandAttr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z
_TEXT	SEGMENT
_i$1 = -24						; size = 4
_y$2 = -20						; size = 4
_x$3 = -16						; size = 4
_PathNum$4 = -12					; size = 4
_Success$ = -5						; size = 1
_this$ = -4						; size = 4
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
_a$ = 24						; size = 4
?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z PROC	; MapClass::PathFinding3, COMDAT
; _this$ = ecx

; 1048 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1049 : 	bool Success = path->FindPath2(sx,sy,tx,ty,true);

  0000c	6a 01		 push	 1
  0000e	8b 45 14	 mov	 eax, DWORD PTR _ty$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 10	 mov	 ecx, DWORD PTR _tx$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR _sx$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00024	e8 00 00 00 00	 call	 ?FindPath2@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath2
  00029	88 45 fb	 mov	 BYTE PTR _Success$[ebp], al

; 1050 : 	if(!Success)

  0002c	0f b6 45 fb	 movzx	 eax, BYTE PTR _Success$[ebp]
  00030	85 c0		 test	 eax, eax
  00032	75 20		 jne	 SHORT $LN5@PathFindin

; 1051 : 	{
; 1052 : 		Success = path->FindPath2(sx,sy,tx,ty,false);

  00034	6a 00		 push	 0
  00036	8b 45 14	 mov	 eax, DWORD PTR _ty$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _tx$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00041	52		 push	 edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _sx$[ebp]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0004c	e8 00 00 00 00	 call	 ?FindPath2@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath2
  00051	88 45 fb	 mov	 BYTE PTR _Success$[ebp], al
$LN5@PathFindin:

; 1053 : 	}
; 1054 : 	if(Success)

  00054	0f b6 45 fb	 movzx	 eax, BYTE PTR _Success$[ebp]
  00058	85 c0		 test	 eax, eax
  0005a	0f 84 8a 00 00
	00		 je	 $LN6@PathFindin

; 1055 : 	{
; 1056 : 		int PathNum = path->GetPath();

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00066	e8 00 00 00 00	 call	 ?GetPath@PATH@@QAEHXZ	; PATH::GetPath
  0006b	89 45 f4	 mov	 DWORD PTR _PathNum$4[ebp], eax

; 1057 : 
; 1058 : 		if( PathNum > 1 )

  0006e	83 7d f4 01	 cmp	 DWORD PTR _PathNum$4[ebp], 1
  00072	7e 76		 jle	 SHORT $LN6@PathFindin

; 1059 : 		{
; 1060 : 			a->PathNum = PathNum;

  00074	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  00077	8b 4d f4	 mov	 ecx, DWORD PTR _PathNum$4[ebp]
  0007a	89 08		 mov	 DWORD PTR [eax], ecx

; 1061 : 
; 1062 : 			unsigned char *x = path->GetPathX();

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00082	e8 00 00 00 00	 call	 ?GetPathX@PATH@@QAEPAEXZ ; PATH::GetPathX
  00087	89 45 f0	 mov	 DWORD PTR _x$3[ebp], eax

; 1063 : 			unsigned char *y = path->GetPathY();

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00090	e8 00 00 00 00	 call	 ?GetPathY@PATH@@QAEPAEXZ ; PATH::GetPathY
  00095	89 45 ec	 mov	 DWORD PTR _y$2[ebp], eax

; 1064 : 
; 1065 : 			for(int i=0;i<a->PathNum;i++)

  00098	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0009f	eb 09		 jmp	 SHORT $LN4@PathFindin
$LN2@PathFindin:
  000a1	8b 45 e8	 mov	 eax, DWORD PTR _i$1[ebp]
  000a4	83 c0 01	 add	 eax, 1
  000a7	89 45 e8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@PathFindin:
  000aa	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  000ad	8b 4d e8	 mov	 ecx, DWORD PTR _i$1[ebp]
  000b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000b2	7d 28		 jge	 SHORT $LN3@PathFindin

; 1066 : 			{
; 1067 : 				a->PathX[i] = x[i];

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _x$3[ebp]
  000b7	03 45 e8	 add	 eax, DWORD PTR _i$1[ebp]
  000ba	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000bd	8b 55 e8	 mov	 edx, DWORD PTR _i$1[ebp]
  000c0	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  000c3	89 4c 90 04	 mov	 DWORD PTR [eax+edx*4+4], ecx

; 1068 : 				a->PathY[i] = y[i];

  000c7	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  000ca	03 45 e8	 add	 eax, DWORD PTR _i$1[ebp]
  000cd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d0	8b 55 e8	 mov	 edx, DWORD PTR _i$1[ebp]
  000d3	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  000d6	89 4c 90 40	 mov	 DWORD PTR [eax+edx*4+64], ecx

; 1069 : 			}

  000da	eb c5		 jmp	 SHORT $LN2@PathFindin
$LN3@PathFindin:

; 1070 : 			a->CurrentPath = 0;

  000dc	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  000df	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], 0

; 1071 : 						
; 1072 : 			return TRUE;

  000e6	b0 01		 mov	 al, 1
  000e8	eb 02		 jmp	 SHORT $LN1@PathFindin
$LN6@PathFindin:

; 1073 : 		}
; 1074 : 	}
; 1075 : 	return FALSE;

  000ea	32 c0		 xor	 al, al
$LN1@PathFindin:

; 1076 : }

  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 14 00	 ret	 20			; 00000014H
?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ENDP	; MapClass::PathFinding3
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z
_TEXT	SEGMENT
_i$1 = -24						; size = 4
_y$2 = -20						; size = 4
_x$3 = -16						; size = 4
_PathNum$4 = -12					; size = 4
_Success$ = -5						; size = 1
_this$ = -4						; size = 4
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_tx$ = 16						; size = 4
_ty$ = 20						; size = 4
_a$ = 24						; size = 4
?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z PROC	; MapClass::PathFinding2, COMDAT
; _this$ = ecx

; 979  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 980  : 	bool Success = path->FindPath(sx,sy,tx,ty,true);

  0000c	6a 01		 push	 1
  0000e	8b 45 14	 mov	 eax, DWORD PTR _ty$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 10	 mov	 ecx, DWORD PTR _tx$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR _sx$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00024	e8 00 00 00 00	 call	 ?FindPath@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath
  00029	88 45 fb	 mov	 BYTE PTR _Success$[ebp], al

; 981  : 	if(!Success)

  0002c	0f b6 45 fb	 movzx	 eax, BYTE PTR _Success$[ebp]
  00030	85 c0		 test	 eax, eax
  00032	75 20		 jne	 SHORT $LN5@PathFindin

; 982  : 	{
; 983  : 		Success = path->FindPath(sx,sy,tx,ty,false);

  00034	6a 00		 push	 0
  00036	8b 45 14	 mov	 eax, DWORD PTR _ty$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _tx$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00041	52		 push	 edx
  00042	8b 45 08	 mov	 eax, DWORD PTR _sx$[ebp]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0004c	e8 00 00 00 00	 call	 ?FindPath@PATH@@QAE_NHHHH_N@Z ; PATH::FindPath
  00051	88 45 fb	 mov	 BYTE PTR _Success$[ebp], al
$LN5@PathFindin:

; 984  : 	}
; 985  : 	if(Success)

  00054	0f b6 45 fb	 movzx	 eax, BYTE PTR _Success$[ebp]
  00058	85 c0		 test	 eax, eax
  0005a	0f 84 8a 00 00
	00		 je	 $LN6@PathFindin

; 986  : 	{
; 987  : 		int PathNum = path->GetPath();

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00066	e8 00 00 00 00	 call	 ?GetPath@PATH@@QAEHXZ	; PATH::GetPath
  0006b	89 45 f4	 mov	 DWORD PTR _PathNum$4[ebp], eax

; 988  : 
; 989  : 		if( PathNum > 1 )

  0006e	83 7d f4 01	 cmp	 DWORD PTR _PathNum$4[ebp], 1
  00072	7e 76		 jle	 SHORT $LN6@PathFindin

; 990  : 		{
; 991  : 			a->PathNum = PathNum;

  00074	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  00077	8b 4d f4	 mov	 ecx, DWORD PTR _PathNum$4[ebp]
  0007a	89 08		 mov	 DWORD PTR [eax], ecx

; 992  : 
; 993  : 			unsigned char *x = path->GetPathX();

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00082	e8 00 00 00 00	 call	 ?GetPathX@PATH@@QAEPAEXZ ; PATH::GetPathX
  00087	89 45 f0	 mov	 DWORD PTR _x$3[ebp], eax

; 994  : 			unsigned char *y = path->GetPathY();

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00090	e8 00 00 00 00	 call	 ?GetPathY@PATH@@QAEPAEXZ ; PATH::GetPathY
  00095	89 45 ec	 mov	 DWORD PTR _y$2[ebp], eax

; 995  : 
; 996  : 			for(int i=0;i<a->PathNum;i++)

  00098	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0009f	eb 09		 jmp	 SHORT $LN4@PathFindin
$LN2@PathFindin:
  000a1	8b 45 e8	 mov	 eax, DWORD PTR _i$1[ebp]
  000a4	83 c0 01	 add	 eax, 1
  000a7	89 45 e8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@PathFindin:
  000aa	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  000ad	8b 4d e8	 mov	 ecx, DWORD PTR _i$1[ebp]
  000b0	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000b2	7d 28		 jge	 SHORT $LN3@PathFindin

; 997  : 			{
; 998  : 				a->PathX[i] = x[i];

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _x$3[ebp]
  000b7	03 45 e8	 add	 eax, DWORD PTR _i$1[ebp]
  000ba	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000bd	8b 55 e8	 mov	 edx, DWORD PTR _i$1[ebp]
  000c0	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  000c3	89 4c 90 04	 mov	 DWORD PTR [eax+edx*4+4], ecx

; 999  : 				a->PathY[i] = y[i];

  000c7	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  000ca	03 45 e8	 add	 eax, DWORD PTR _i$1[ebp]
  000cd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d0	8b 55 e8	 mov	 edx, DWORD PTR _i$1[ebp]
  000d3	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  000d6	89 4c 90 40	 mov	 DWORD PTR [eax+edx*4+64], ecx

; 1000 : 			}

  000da	eb c5		 jmp	 SHORT $LN2@PathFindin
$LN3@PathFindin:

; 1001 : 			a->CurrentPath = 0;

  000dc	8b 45 18	 mov	 eax, DWORD PTR _a$[ebp]
  000df	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], 0

; 1002 : 						
; 1003 : 			return TRUE;

  000e6	b0 01		 mov	 al, 1
  000e8	eb 02		 jmp	 SHORT $LN1@PathFindin
$LN6@PathFindin:

; 1004 : 		}
; 1005 : 	}
; 1006 : 	return FALSE;

  000ea	32 c0		 xor	 al, al
$LN1@PathFindin:

; 1007 : }

  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 14 00	 ret	 20			; 00000014H
?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ENDP	; MapClass::PathFinding2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?StateSetDestroy@MapClass@@QAEXXZ
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_CurTime$ = -8						; size = 4
_this$ = -4						; size = 4
?StateSetDestroy@MapClass@@QAEXXZ PROC			; MapClass::StateSetDestroy, COMDAT
; _this$ = ecx

; 792  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 793  : 	DWORD CurTime=GetTickCount();

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00012	89 45 f8	 mov	 DWORD PTR _CurTime$[ebp], eax

; 794  : 	for( int n=0; n<MAX_MAPITEM; n++)

  00015	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0001c	eb 09		 jmp	 SHORT $LN4@StateSetDe
$LN2@StateSetDe:
  0001e	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00021	83 c0 01	 add	 eax, 1
  00024	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@StateSetDe:
  00027	81 7d f4 2c 01
	00 00		 cmp	 DWORD PTR _n$1[ebp], 300 ; 0000012cH
  0002e	0f 8d 6d 01 00
	00		 jge	 $LN1@StateSetDe

; 795  : 	{
; 796  : 		// 비어있는 공간을 찾아서..		
; 797  : 		// 시간이 지난 아이템은 삭제한다.
; 798  : 		if( m_cItem[n].IsItem() )

  00034	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00042	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00047	85 c0		 test	 eax, eax
  00049	74 76		 je	 SHORT $LN5@StateSetDe

; 799  : 		{
; 800  : 			if( m_cItem[n].m_State == OBJST_CREATE )

  0004b	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	83 bc 01 d0 00
	00 00 01	 cmp	 DWORD PTR [ecx+eax+208], 1
  0005d	75 17		 jne	 SHORT $LN6@StateSetDe

; 801  : 			{
; 802  : 				m_cItem[n].m_State = OBJST_PLAYING;

  0005f	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	c7 84 01 d0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR [ecx+eax+208], 2

; 803  : 			}

  00074	eb 4b		 jmp	 SHORT $LN5@StateSetDe
$LN6@StateSetDe:

; 804  : 			else if( m_cItem[n].m_State == OBJST_DIECMD )

  00076	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	83 bc 01 d0 00
	00 00 08	 cmp	 DWORD PTR [ecx+eax+208], 8
  00088	75 37		 jne	 SHORT $LN5@StateSetDe

; 805  : 			{
; 806  : 				m_cItem[n].Clear();

  0008a	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00098	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 807  : 				m_cItem[n].live = 0;

  0009d	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	c6 84 01 ce 00
	00 00 00	 mov	 BYTE PTR [ecx+eax+206], 0

; 808  : 				m_cItem[n].Give = 1;

  000af	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	c6 84 01 cf 00
	00 00 01	 mov	 BYTE PTR [ecx+eax+207], 1
$LN5@StateSetDe:

; 809  : 			}
; 810  : 		}
; 811  : 		if( m_cItem[n].IsItem() )

  000c1	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  000cf	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000d4	85 c0		 test	 eax, eax
  000d6	0f 84 c0 00 00
	00		 je	 $LN9@StateSetDe

; 812  : 		{
; 813  : 			if( m_cItem[n].m_State != OBJST_DIECMD )

  000dc	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	83 bc 01 d0 00
	00 00 08	 cmp	 DWORD PTR [ecx+eax+208], 8
  000ee	0f 84 a8 00 00
	00		 je	 $LN9@StateSetDe

; 814  : 			{
; 815  : #ifndef FOR_ONAIR				
; 816  : 				if( CurTime > m_cItem[n].m_Time )

  000f4	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  000fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	8b 55 f8	 mov	 edx, DWORD PTR _CurTime$[ebp]
  00101	3b 94 01 d4 00
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+212]
  00108	0f 86 8e 00 00
	00		 jbe	 $LN9@StateSetDe

; 817  : 				{
; 818  : 					LogAddTD(lMsg.Get(1100), m_cItem[n].GetName(), m_cItem[n].m_Type, m_cItem[n].m_Level, m_cItem[n].m_Special[0], m_cItem[n].m_Number);

  0010e	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	8b 54 01 24	 mov	 edx, DWORD PTR [ecx+eax+36]
  0011c	52		 push	 edx
  0011d	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  00124	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	8d 54 01 20	 lea	 edx, DWORD PTR [ecx+eax+32]
  0012b	b8 01 00 00 00	 mov	 eax, 1
  00130	6b c8 00	 imul	 ecx, eax, 0
  00133	0f b6 54 0a 35	 movzx	 edx, BYTE PTR [edx+ecx+53]
  00138	52		 push	 edx
  00139	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	0f bf 54 01 2c	 movsx	 edx, WORD PTR [ecx+eax+44]
  00148	52		 push	 edx
  00149	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  00150	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	0f bf 54 01 2a	 movsx	 edx, WORD PTR [ecx+eax+42]
  00158	52		 push	 edx
  00159	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  00160	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00163	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00167	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0016c	50		 push	 eax
  0016d	68 4c 04 00 00	 push	 1100			; 0000044cH
  00172	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0017d	50		 push	 eax
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00184	83 c4 18	 add	 esp, 24			; 00000018H

; 819  : 					//LogAddTD(lMsg.Get(1100), m_cItem[n].GetName(), m_cItem[n].m_Type, m_cItem[n].m_Level, m_cItem[n].m_Special[0]);
; 820  : 					m_cItem[n].m_State	= OBJST_DIECMD;

  00187	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 1096
  0018e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00191	c7 84 01 d0 00
	00 00 08 00 00
	00		 mov	 DWORD PTR [ecx+eax+208], 8
$LN9@StateSetDe:

; 821  : 
; 822  : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	// 성물이 없어졌으므로 석상 생성시간 설정
; 823  : 					if(m_cItem[n].m_Type == MAKE_ITEMNUM(14, 64))
; 824  : 					{
; 825  : 						g_IllusionTempleEvent.SetStatusRegenTime(thisMapNumber);
; 826  : 					}
; 827  : #endif
; 828  : 				}
; 829  : #endif
; 830  : 			}
; 831  : 		}
; 832  : 	}

  0019c	e9 7d fe ff ff	 jmp	 $LN2@StateSetDe
$LN1@StateSetDe:

; 833  : }

  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5b		 pop	 ebx
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
?StateSetDestroy@MapClass@@QAEXXZ ENDP			; MapClass::StateSetDestroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?SetWeather@MapClass@@QAEXEE@Z
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_weather$ = -9						; size = 1
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_a_weather$ = 8						; size = 1
_a_variation$ = 12					; size = 1
?SetWeather@MapClass@@QAEXEE@Z PROC			; MapClass::SetWeather, COMDAT
; _this$ = ecx

; 259  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 260  : 	LPOBJECTSTRUCT	lpObj;
; 261  : 	BYTE	weather;
; 262  : 
; 263  : 	m_Weather = a_weather;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 4d 08	 mov	 cl, BYTE PTR _a_weather$[ebp]
  00012	88 48 04	 mov	 BYTE PTR [eax+4], cl

; 264  : 	m_WeatherVariation = a_variation;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8a 4d 0c	 mov	 cl, BYTE PTR _a_variation$[ebp]
  0001b	88 48 05	 mov	 BYTE PTR [eax+5], cl

; 265  : 
; 266  : 	weather  = m_Weather<<4;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00025	c1 e1 04	 shl	 ecx, 4
  00028	88 4d f7	 mov	 BYTE PTR _weather$[ebp], cl

; 267  : 	weather |= m_WeatherVariation;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00032	0f b6 55 f7	 movzx	 edx, BYTE PTR _weather$[ebp]
  00036	0b d1		 or	 edx, ecx
  00038	88 55 f7	 mov	 BYTE PTR _weather$[ebp], dl

; 268  : 
; 269  : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0003b	c7 45 f0 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00042	eb 09		 jmp	 SHORT $LN4@SetWeather
$LN2@SetWeather:
  00044	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@SetWeather:
  0004d	81 7d f0 e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00054	7d 4c		 jge	 SHORT $LN1@SetWeather

; 270  : 	{
; 271  : 		lpObj = (LPOBJECTSTRUCT)&gObj[n];		

  00056	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0005d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00063	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 272  : 		if( lpObj->Connected > 1 && lpObj->Live && (lpObj->MapNumber == thisMapNumber ) )

  00066	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00069	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  0006d	7e 31		 jle	 SHORT $LN5@SetWeather
  0006f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00072	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00076	85 c9		 test	 ecx, ecx
  00078	74 26		 je	 SHORT $LN5@SetWeather
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00084	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00087	3b 8a 88 04 05
	00		 cmp	 ecx, DWORD PTR [edx+328840]
  0008d	75 11		 jne	 SHORT $LN5@SetWeather

; 273  : 		{
; 274  : 			CGWeatherSend(n, weather);

  0008f	0f b6 45 f7	 movzx	 eax, BYTE PTR _weather$[ebp]
  00093	50		 push	 eax
  00094	8b 4d f0	 mov	 ecx, DWORD PTR _n$1[ebp]
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ?CGWeatherSend@@YAXHE@Z	; CGWeatherSend
  0009d	83 c4 08	 add	 esp, 8
$LN5@SetWeather:

; 275  : 		}		
; 276  : 	}

  000a0	eb a2		 jmp	 SHORT $LN2@SetWeather
$LN1@SetWeather:

; 277  : }

  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
?SetWeather@MapClass@@QAEXEE@Z ENDP			; MapClass::SetWeather
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?GetWeather@MapClass@@QAEEXZ
_TEXT	SEGMENT
_weather$ = -5						; size = 1
_this$ = -4						; size = 4
?GetWeather@MapClass@@QAEEXZ PROC			; MapClass::GetWeather, COMDAT
; _this$ = ecx

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 	BYTE	weather;
; 249  : 
; 250  : 	weather  = m_Weather<<4;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00013	c1 e1 04	 shl	 ecx, 4
  00016	88 4d fb	 mov	 BYTE PTR _weather$[ebp], cl

; 251  : 	weather |= m_WeatherVariation;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00020	0f b6 55 fb	 movzx	 edx, BYTE PTR _weather$[ebp]
  00024	0b d1		 or	 edx, ecx
  00026	88 55 fb	 mov	 BYTE PTR _weather$[ebp], dl

; 252  : 	
; 253  : 
; 254  : 	return weather;

  00029	8a 45 fb	 mov	 al, BYTE PTR _weather$[ebp]

; 255  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GetWeather@MapClass@@QAEEXZ ENDP			; MapClass::GetWeather
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?WeatherVariationProcess@MapClass@@QAEXXZ
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_weather$ = -9						; size = 1
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
?WeatherVariationProcess@MapClass@@QAEXXZ PROC		; MapClass::WeatherVariationProcess, COMDAT
; _this$ = ecx

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 282  : 	LPOBJECTSTRUCT	lpObj;
; 283  : 	BYTE	weather;
; 284  : 
; 285  : 	if( (GetTickCount()-m_WeatherTimer) > m_NextWeatherTimer )

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	2b 41 08	 sub	 eax, DWORD PTR [ecx+8]
  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0001e	0f 86 cf 00 00
	00		 jbe	 $LN1@WeatherVar

; 286  : 	{
; 287  : 		m_WeatherTimer		= GetTickCount();

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 288  : 		m_NextWeatherTimer  = (10*1000)+(rand()%(10*1000));

  00030	e8 00 00 00 00	 call	 _rand
  00035	99		 cdq
  00036	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0003b	f7 f9		 idiv	 ecx
  0003d	81 c2 10 27 00
	00		 add	 edx, 10000		; 00002710H
  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 289  : 		m_WeatherVariation  = rand()%10;

  00049	e8 00 00 00 00	 call	 _rand
  0004e	99		 cdq
  0004f	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00054	f7 f9		 idiv	 ecx
  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	88 50 05	 mov	 BYTE PTR [eax+5], dl

; 290  : 		m_Weather		    = rand()%3;

  0005c	e8 00 00 00 00	 call	 _rand
  00061	99		 cdq
  00062	b9 03 00 00 00	 mov	 ecx, 3
  00067	f7 f9		 idiv	 ecx
  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 291  : 		
; 292  : 		weather  = m_Weather<<4;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00076	c1 e1 04	 shl	 ecx, 4
  00079	88 4d f7	 mov	 BYTE PTR _weather$[ebp], cl

; 293  : 		weather |= m_WeatherVariation;

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00083	0f b6 55 f7	 movzx	 edx, BYTE PTR _weather$[ebp]
  00087	0b d1		 or	 edx, ecx
  00089	88 55 f7	 mov	 BYTE PTR _weather$[ebp], dl

; 294  : 		
; 295  : 		for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  0008c	c7 45 f0 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00093	eb 09		 jmp	 SHORT $LN4@WeatherVar
$LN2@WeatherVar:
  00095	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  00098	83 c0 01	 add	 eax, 1
  0009b	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@WeatherVar:
  0009e	81 7d f0 e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  000a5	7d 4c		 jge	 SHORT $LN1@WeatherVar

; 296  : 		{
; 297  : 			lpObj = (LPOBJECTSTRUCT)&gObj[n];			

  000a7	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  000ae	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b4	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 298  : 			if( lpObj->Connected > 1 && lpObj->Live && (lpObj->MapNumber == thisMapNumber) )

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ba	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  000be	7e 31		 jle	 SHORT $LN6@WeatherVar
  000c0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c3	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  000c7	85 c9		 test	 ecx, ecx
  000c9	74 26		 je	 SHORT $LN6@WeatherVar
  000cb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ce	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000d5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	3b 8a 88 04 05
	00		 cmp	 ecx, DWORD PTR [edx+328840]
  000de	75 11		 jne	 SHORT $LN6@WeatherVar

; 299  : 			{
; 300  : 				CGWeatherSend(n, weather);

  000e0	0f b6 45 f7	 movzx	 eax, BYTE PTR _weather$[ebp]
  000e4	50		 push	 eax
  000e5	8b 4d f0	 mov	 ecx, DWORD PTR _n$1[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 ?CGWeatherSend@@YAXHE@Z	; CGWeatherSend
  000ee	83 c4 08	 add	 esp, 8
$LN6@WeatherVar:

; 301  : 			}
; 302  : 		}

  000f1	eb a2		 jmp	 SHORT $LN2@WeatherVar
$LN1@WeatherVar:

; 303  : 	}
; 304  : }

  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
?WeatherVariationProcess@MapClass@@QAEXXZ ENDP		; MapClass::WeatherVariationProcess
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?MoneyItemDrop@MapClass@@QAEHHHH@Z
_TEXT	SEGMENT
_attr$ = -13						; size = 1
_counttot$ = -12					; size = 4
_count$ = -8						; size = 4
_this$ = -4						; size = 4
_money$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?MoneyItemDrop@MapClass@@QAEHHHH@Z PROC			; MapClass::MoneyItemDrop, COMDAT
; _this$ = ecx

; 582  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 583  : 	int  count, counttot=0;

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _counttot$[ebp], 0

; 584  : 	
; 585  : 	BYTE	attr;
; 586  : 
; 587  : 	//못가는 곳이라면 아이템도 못 버리게..
; 588  : 	attr = GetAttr(x, y);

  00013	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00023	88 45 f3	 mov	 BYTE PTR _attr$[ebp], al

; 589  : 	if( ((attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK) ||

  00026	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0002a	83 e0 04	 and	 eax, 4
  0002d	75 09		 jne	 SHORT $LN5@MoneyItemD
  0002f	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00033	83 e0 08	 and	 eax, 8
  00036	74 07		 je	 SHORT $LN4@MoneyItemD
$LN5@MoneyItemD:

; 590  : 		((attr&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW) ) 
; 591  : 	{		
; 592  : 		return FALSE;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 77 01 00 00	 jmp	 $LN1@MoneyItemD
$LN4@MoneyItemD:

; 593  : 	}
; 594  : 
; 595  : 	count = m_ItemCount;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 88 80 04 05
	00		 mov	 ecx, DWORD PTR [eax+328832]
  00048	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
$LN2@MoneyItemD:

; 596  : 	while( TRUE )

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	85 c0		 test	 eax, eax
  00052	0f 84 5c 01 00
	00		 je	 $LN3@MoneyItemD

; 597  : 	{
; 598  : 
; 599  : 		// 비어있는 공간을 찾아서..
; 600  : 		if( m_cItem[count].IsItem() == FALSE )

  00058	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00066	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006b	85 c0		 test	 eax, eax
  0006d	0f 85 0d 01 00
	00		 jne	 $LN6@MoneyItemD

; 601  : 		//if( m_cItem[count].live == 0 && m_cItem[count].m_State == OBJST_NONE )
; 602  : 		{
; 603  : 			//m_cItem[count].Clear();
; 604  : 			m_cItem[count].m_Type		= GOLD_TYPE_INDEX;

  00073	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  0007a	b9 cf 01 00 00	 mov	 ecx, 463		; 000001cfH
  0007f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00082	66 89 4c 02 2a	 mov	 WORD PTR [edx+eax+42], cx

; 605  : 			m_cItem[count].m_SellMoney  = money;

  00087	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	8b 55 08	 mov	 edx, DWORD PTR _money$[ebp]
  00094	89 94 01 84 00
	00 00		 mov	 DWORD PTR [ecx+eax+132], edx

; 606  : 			m_cItem[count].m_BuyMoney	= money;

  0009b	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 55 08	 mov	 edx, DWORD PTR _money$[ebp]
  000a8	89 94 01 88 00
	00 00		 mov	 DWORD PTR [ecx+eax+136], edx

; 607  : 			m_cItem[count].px			= x;

  000af	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	8a 55 0c	 mov	 dl, BYTE PTR _x$[ebp]
  000bc	88 94 01 cc 00
	00 00		 mov	 BYTE PTR [ecx+eax+204], dl

; 608  : 			m_cItem[count].py			= y;

  000c3	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	8a 55 10	 mov	 dl, BYTE PTR _y$[ebp]
  000d0	88 94 01 cd 00
	00 00		 mov	 BYTE PTR [ecx+eax+205], dl

; 609  : 			m_cItem[count].live			= 1;

  000d7	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  000de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	c6 84 01 ce 00
	00 00 01	 mov	 BYTE PTR [ecx+eax+206], 1

; 610  : 			m_cItem[count].Give         = 0;

  000e9	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	c6 84 01 cf 00
	00 00 00	 mov	 BYTE PTR [ecx+eax+207], 0

; 611  : 			m_cItem[count].m_State		= OBJST_CREATE;

  000fb	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  00102	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	c7 84 01 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+208], 1

; 612  : 			m_cItem[count].m_Time       = GetTickCount()+((1000*gZenDurationTime));

  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00116	69 0d 00 00 00
	00 e8 03 00 00	 imul	 ecx, DWORD PTR ?gZenDurationTime@@3HA, 1000 ; gZenDurationTime
  00120	03 c1		 add	 eax, ecx
  00122	69 55 f8 48 04
	00 00		 imul	 edx, DWORD PTR _count$[ebp], 1096
  00129	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	89 84 11 d4 00
	00 00		 mov	 DWORD PTR [ecx+edx+212], eax

; 613  : 			m_cItem[count].m_LootTime	= 0;//GetTickCount()+(1000*gLootingTime);

  00133	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  0013a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	c7 84 01 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+220], 0

; 614  : 			m_ItemCount++;

  00148	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	8b 88 80 04 05
	00		 mov	 ecx, DWORD PTR [eax+328832]
  00151	83 c1 01	 add	 ecx, 1
  00154	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00157	89 8a 80 04 05
	00		 mov	 DWORD PTR [edx+328832], ecx

; 615  : 			if( m_ItemCount > MAX_MAPITEM-1 ) m_ItemCount = 0;

  0015d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00160	81 b8 80 04 05
	00 2b 01 00 00	 cmp	 DWORD PTR [eax+328832], 299 ; 0000012bH
  0016a	7e 0d		 jle	 SHORT $LN7@MoneyItemD
  0016c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0016f	c7 80 80 04 05
	00 00 00 00 00	 mov	 DWORD PTR [eax+328832], 0
$LN7@MoneyItemD:

; 616  : 			return TRUE;

  00179	b8 01 00 00 00	 mov	 eax, 1
  0017e	eb 36		 jmp	 SHORT $LN1@MoneyItemD
$LN6@MoneyItemD:

; 617  : 		}
; 618  : 		count++;

  00180	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00183	83 c0 01	 add	 eax, 1
  00186	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 619  : 		if( count > MAX_MAPITEM-1 ) count=0;

  00189	81 7d f8 2b 01
	00 00		 cmp	 DWORD PTR _count$[ebp], 299 ; 0000012bH
  00190	7e 07		 jle	 SHORT $LN8@MoneyItemD
  00192	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN8@MoneyItemD:

; 620  : 		counttot++;

  00199	8b 45 f4	 mov	 eax, DWORD PTR _counttot$[ebp]
  0019c	83 c0 01	 add	 eax, 1
  0019f	89 45 f4	 mov	 DWORD PTR _counttot$[ebp], eax

; 621  : 		if( counttot > MAX_MAPITEM-1 ) return FALSE;

  001a2	81 7d f4 2b 01
	00 00		 cmp	 DWORD PTR _counttot$[ebp], 299 ; 0000012bH
  001a9	7e 04		 jle	 SHORT $LN9@MoneyItemD
  001ab	33 c0		 xor	 eax, eax
  001ad	eb 07		 jmp	 SHORT $LN1@MoneyItemD
$LN9@MoneyItemD:

; 622  : 	}

  001af	e9 97 fe ff ff	 jmp	 $LN2@MoneyItemD
$LN3@MoneyItemD:

; 623  : 	return FALSE;

  001b4	33 c0		 xor	 eax, eax
$LN1@MoneyItemD:

; 624  : }

  001b6	5f		 pop	 edi
  001b7	5e		 pop	 esi
  001b8	5b		 pop	 ebx
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c2 0c 00	 ret	 12			; 0000000cH
?MoneyItemDrop@MapClass@@QAEHHHH@Z ENDP			; MapClass::MoneyItemDrop
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z
_TEXT	SEGMENT
_attr$ = -13						; size = 1
_counttot$ = -12					; size = 4
_count$ = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 4
_level$ = 12						; size = 4
_dur$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_Option1$ = 28						; size = 1
_Option2$ = 32						; size = 1
_Option3$ = 36						; size = 1
_NOption$ = 40						; size = 1
_SOption$ = 44						; size = 1
_aIndex$ = 48						; size = 4
_number$ = 52						; size = 4
?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z PROC	; MapClass::MonsterItemDrop, COMDAT
; _this$ = ecx

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 400  : 	int  count, counttot=0;

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _counttot$[ebp], 0

; 401  : 	BYTE	attr;
; 402  : 
; 403  : 	//못가는 곳이라면 아이템도 못 버리게..
; 404  : 	attr = GetAttr(x, y);

  00013	8b 45 18	 mov	 eax, DWORD PTR _y$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00023	88 45 f3	 mov	 BYTE PTR _attr$[ebp], al

; 405  : 	if( ((attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK) ||

  00026	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0002a	83 e0 04	 and	 eax, 4
  0002d	75 09		 jne	 SHORT $LN5@MonsterIte
  0002f	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00033	83 e0 08	 and	 eax, 8
  00036	74 08		 je	 SHORT $LN4@MonsterIte
$LN5@MonsterIte:

; 406  : 		((attr&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW) ) 
; 407  : 	{		
; 408  : 		return -1;

  00038	83 c8 ff	 or	 eax, -1
  0003b	e9 26 01 00 00	 jmp	 $LN1@MonsterIte
$LN4@MonsterIte:

; 409  : 	}
; 410  : 	
; 411  : 	count = m_ItemCount;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 88 80 04 05
	00		 mov	 ecx, DWORD PTR [eax+328832]
  00049	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
$LN2@MonsterIte:

; 412  : 	while( TRUE )

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	85 c0		 test	 eax, eax
  00053	0f 84 e2 00 00
	00		 je	 $LN3@MonsterIte

; 413  : 	{
; 414  : 		// 비어있는 공간을 찾아서..
; 415  : 		if( m_cItem[count].IsItem() == FALSE )

  00059	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00067	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006c	85 c0		 test	 eax, eax
  0006e	0f 85 95 00 00
	00		 jne	 $LN6@MonsterIte

; 416  : 		{
; 417  : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 418  : 			m_cItem[count].CreateItem(type, level, x, y, dur, Option1, Option2, Option3, NOption, SOption, number, ItemEffectEx, SocketOption, SocketBonusOption );
; 419  : #else
; 420  : 	#ifdef ADD_380ITEM_NEWOPTION_20060711
; 421  : 			m_cItem[count].CreateItem(type, level, x, y, dur, Option1, Option2, Option3, NOption, SOption, number, ItemEffectEx);
; 422  : 	#else
; 423  : 			m_cItem[count].CreateItem(type, level, x, y, dur, Option1, Option2, Option3, NOption, SOption, number);

  00074	8b 45 34	 mov	 eax, DWORD PTR _number$[ebp]
  00077	50		 push	 eax
  00078	0f b6 4d 2c	 movzx	 ecx, BYTE PTR _SOption$[ebp]
  0007c	51		 push	 ecx
  0007d	0f b6 55 28	 movzx	 edx, BYTE PTR _NOption$[ebp]
  00081	52		 push	 edx
  00082	0f b6 45 24	 movzx	 eax, BYTE PTR _Option3$[ebp]
  00086	50		 push	 eax
  00087	0f b6 4d 20	 movzx	 ecx, BYTE PTR _Option2$[ebp]
  0008b	51		 push	 ecx
  0008c	0f b6 55 1c	 movzx	 edx, BYTE PTR _Option1$[ebp]
  00090	52		 push	 edx
  00091	51		 push	 ecx
  00092	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _dur$[ebp]
  00097	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009c	8b 45 18	 mov	 eax, DWORD PTR _y$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  000a3	51		 push	 ecx
  000a4	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  000a7	52		 push	 edx
  000a8	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
  000ab	50		 push	 eax
  000ac	69 4d f8 48 04
	00 00		 imul	 ecx, DWORD PTR _count$[ebp], 1096
  000b3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	8d 4c 0a 20	 lea	 ecx, DWORD PTR [edx+ecx+32]
  000ba	e8 00 00 00 00	 call	 ?CreateItem@CMapItem@@QAEXHHHHMEEEEEK@Z ; CMapItem::CreateItem

; 424  : 	#endif // ADD_380ITEM_NEWOPTION_20060711
; 425  : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 426  : 			m_cItem[count].m_UserIndex = aIndex;

  000bf	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	8b 55 30	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000cc	89 94 01 d8 00
	00 00		 mov	 DWORD PTR [ecx+eax+216], edx

; 427  : 			m_ItemCount++;

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 88 80 04 05
	00		 mov	 ecx, DWORD PTR [eax+328832]
  000dc	83 c1 01	 add	 ecx, 1
  000df	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e2	89 8a 80 04 05
	00		 mov	 DWORD PTR [edx+328832], ecx

; 428  : 			if( m_ItemCount > MAX_MAPITEM-1 ) m_ItemCount = 0;

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	81 b8 80 04 05
	00 2b 01 00 00	 cmp	 DWORD PTR [eax+328832], 299 ; 0000012bH
  000f5	7e 0d		 jle	 SHORT $LN7@MonsterIte
  000f7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	c7 80 80 04 05
	00 00 00 00 00	 mov	 DWORD PTR [eax+328832], 0
$LN7@MonsterIte:

; 429  : 			return count;

  00104	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00107	eb 5d		 jmp	 SHORT $LN1@MonsterIte
$LN6@MonsterIte:

; 430  : 		}
; 431  : 		count++;

  00109	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0010c	83 c0 01	 add	 eax, 1
  0010f	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 432  : 		if( count > MAX_MAPITEM-1 ) count=0;

  00112	81 7d f8 2b 01
	00 00		 cmp	 DWORD PTR _count$[ebp], 299 ; 0000012bH
  00119	7e 07		 jle	 SHORT $LN8@MonsterIte
  0011b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN8@MonsterIte:

; 433  : 		counttot++;

  00122	8b 45 f4	 mov	 eax, DWORD PTR _counttot$[ebp]
  00125	83 c0 01	 add	 eax, 1
  00128	89 45 f4	 mov	 DWORD PTR _counttot$[ebp], eax

; 434  : 		if( counttot > MAX_MAPITEM-1 ) break;

  0012b	81 7d f4 2b 01
	00 00		 cmp	 DWORD PTR _counttot$[ebp], 299 ; 0000012bH
  00132	7e 02		 jle	 SHORT $LN9@MonsterIte
  00134	eb 05		 jmp	 SHORT $LN3@MonsterIte
$LN9@MonsterIte:

; 435  : 	}

  00136	e9 11 ff ff ff	 jmp	 $LN2@MonsterIte
$LN3@MonsterIte:

; 436  : 	LogAdd(lMsg.Get(461), __FILE__, __LINE__);

  0013b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z@4JA
  00140	83 c0 25	 add	 eax, 37			; 00000025H
  00143	50		 push	 eax
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00149	68 cd 01 00 00	 push	 461			; 000001cdH
  0014e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00159	50		 push	 eax
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH

; 437  : 	return -1;

  00163	83 c8 ff	 or	 eax, -1
$LN1@MonsterIte:

; 438  : }

  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c2 30 00	 ret	 48			; 00000030H
?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHK@Z ENDP	; MapClass::MonsterItemDrop
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z
_TEXT	SEGMENT
tv159 = -88						; size = 4
tv150 = -88						; size = 4
tv160 = -84						; size = 4
tv151 = -84						; size = 4
_attr$ = -13						; size = 1
_counttot$ = -12					; size = 4
_count$ = -8						; size = 4
_this$ = -4						; size = 4
_type$ = 8						; size = 4
_level$ = 12						; size = 4
_dur$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_Option1$ = 28						; size = 1
_Option2$ = 32						; size = 1
_Option3$ = 36						; size = 1
_NOption$ = 40						; size = 1
_SOption$ = 44						; size = 1
_number$ = 48						; size = 4
_aIndex$ = 52						; size = 4
_PetLevel$ = 56						; size = 4
_PetExp$ = 60						; size = 4
?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z PROC		; MapClass::ItemDrop, COMDAT
; _this$ = ecx

; 491  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 492  : 	int  count, counttot=0;

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _counttot$[ebp], 0

; 493  : 	BYTE	attr;
; 494  : 
; 495  : 	//못가는 곳이라면 아이템도 못 버리게..
; 496  : 	attr = GetAttr(x, y);

  00013	8b 45 18	 mov	 eax, DWORD PTR _y$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00023	88 45 f3	 mov	 BYTE PTR _attr$[ebp], al

; 497  : 	if( ((attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK) ||

  00026	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0002a	83 e0 04	 and	 eax, 4
  0002d	75 09		 jne	 SHORT $LN5@ItemDrop
  0002f	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00033	83 e0 08	 and	 eax, 8
  00036	74 07		 je	 SHORT $LN4@ItemDrop
$LN5@ItemDrop:

; 498  : 		((attr&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW) ) return FALSE;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 d3 02 00 00	 jmp	 $LN1@ItemDrop
$LN4@ItemDrop:

; 499  : 	
; 500  : 	count = m_ItemCount;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 88 80 04 05
	00		 mov	 ecx, DWORD PTR [eax+328832]
  00048	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
$LN2@ItemDrop:

; 501  : 	while( TRUE )

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	85 c0		 test	 eax, eax
  00052	0f 84 90 02 00
	00		 je	 $LN3@ItemDrop

; 502  : 	{
; 503  : 		// 비어있는 공간을 찾아서..
; 504  : 		if( m_cItem[count].IsItem() == FALSE )

  00058	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00066	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006b	85 c0		 test	 eax, eax
  0006d	0f 85 41 02 00
	00		 jne	 $LN6@ItemDrop

; 505  : 		{
; 506  : #ifdef DARKLORD_WORK
; 507  : 	#ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 508  : 			m_cItem[count].DropCreateItem(type, level, x, y, dur, Option1, Option2, Option3, NOption, SOption, number, PetLevel, PetExp, ItemEffectEx, SocketOption, SocketBonusOption);
; 509  : 	#else
; 510  : 		#ifdef ADD_380ITEM_NEWOPTION_20060711
; 511  : 				m_cItem[count].DropCreateItem(type, level, x, y, dur, Option1, Option2, Option3, NOption, SOption, number, PetLevel, PetExp, ItemEffectEx);
; 512  : 		#else
; 513  : 				m_cItem[count].DropCreateItem(type, level, x, y, dur, Option1, Option2, Option3, NOption, SOption, number, PetLevel, PetExp);

  00073	8b 45 3c	 mov	 eax, DWORD PTR _PetExp$[ebp]
  00076	50		 push	 eax
  00077	8b 4d 38	 mov	 ecx, DWORD PTR _PetLevel$[ebp]
  0007a	51		 push	 ecx
  0007b	8b 55 30	 mov	 edx, DWORD PTR _number$[ebp]
  0007e	52		 push	 edx
  0007f	0f b6 45 2c	 movzx	 eax, BYTE PTR _SOption$[ebp]
  00083	50		 push	 eax
  00084	0f b6 4d 28	 movzx	 ecx, BYTE PTR _NOption$[ebp]
  00088	51		 push	 ecx
  00089	0f b6 55 24	 movzx	 edx, BYTE PTR _Option3$[ebp]
  0008d	52		 push	 edx
  0008e	0f b6 45 20	 movzx	 eax, BYTE PTR _Option2$[ebp]
  00092	50		 push	 eax
  00093	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  00097	51		 push	 ecx
  00098	51		 push	 ecx
  00099	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _dur$[ebp]
  0009e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a3	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  000a6	52		 push	 edx
  000a7	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  000ae	51		 push	 ecx
  000af	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  000b2	52		 push	 edx
  000b3	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	8d 4c 01 20	 lea	 ecx, DWORD PTR [ecx+eax+32]
  000c1	e8 00 00 00 00	 call	 ?DropCreateItem@CMapItem@@QAEXHHHHMEEEEEKHH@Z ; CMapItem::DropCreateItem

; 514  : 		#endif // ADD_380ITEM_NEWOPTION_20060711
; 515  : 	#endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 516  : #else
; 517  : 				m_cItem[count].DropCreateItem(type, level, x, y, dur, Option1, Option2, Option3, NOption, SOption, number);
; 518  : #endif
; 519  : 			m_cItem[count].m_UserIndex = aIndex;

  000c6	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 1096
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	8b 55 34	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000d3	89 94 01 d8 00
	00 00		 mov	 DWORD PTR [ecx+eax+216], edx

; 520  : 			m_ItemCount++;

  000da	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 88 80 04 05
	00		 mov	 ecx, DWORD PTR [eax+328832]
  000e3	83 c1 01	 add	 ecx, 1
  000e6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e9	89 8a 80 04 05
	00		 mov	 DWORD PTR [edx+328832], ecx

; 521  : 			if( m_ItemCount > MAX_MAPITEM-1 ) m_ItemCount = 0;

  000ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	81 b8 80 04 05
	00 2b 01 00 00	 cmp	 DWORD PTR [eax+328832], 299 ; 0000012bH
  000fc	7e 0d		 jle	 SHORT $LN7@ItemDrop
  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00101	c7 80 80 04 05
	00 00 00 00 00	 mov	 DWORD PTR [eax+328832], 0
$LN7@ItemDrop:

; 522  : 			
; 523  : #ifdef FOR_BLOODCASTLE
; 524  : 			if (CHECK_BLOODCASTLE(thisMapNumber)) {

  0010b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010e	83 b8 88 04 05
	00 0b		 cmp	 DWORD PTR [eax+328840], 11 ; 0000000bH
  00115	7d 09		 jge	 SHORT $LN19@ItemDrop
  00117	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv151[ebp], 0
  0011e	eb 22		 jmp	 SHORT $LN20@ItemDrop
$LN19@ItemDrop:
  00120	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	83 b9 88 04 05
	00 11		 cmp	 DWORD PTR [ecx+328840], 17 ; 00000011H
  0012a	7e 09		 jle	 SHORT $LN17@ItemDrop
  0012c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv150[ebp], 0
  00133	eb 07		 jmp	 SHORT $LN18@ItemDrop
$LN17@ItemDrop:
  00135	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv150[ebp], 1
$LN18@ItemDrop:
  0013c	8b 55 a8	 mov	 edx, DWORD PTR tv150[ebp]
  0013f	89 55 ac	 mov	 DWORD PTR tv151[ebp], edx
$LN20@ItemDrop:
  00142	83 7d ac 00	 cmp	 DWORD PTR tv151[ebp], 0
  00146	0f 84 61 01 00
	00		 je	 $LN13@ItemDrop

; 525  : 				// 사실 여기가 진짜
; 526  : 				if (type == MAKE_ITEMNUM(13, 19)) {

  0014c	6a 13		 push	 19			; 00000013H
  0014e	6a 0d		 push	 13			; 0000000dH
  00150	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00155	83 c4 08	 add	 esp, 8
  00158	39 45 08	 cmp	 DWORD PTR _type$[ebp], eax
  0015b	0f 85 4c 01 00
	00		 jne	 $LN13@ItemDrop

; 527  : 					if (CHECK_LIMIT(level, 3)) {

  00161	83 7d 0c 00	 cmp	 DWORD PTR _level$[ebp], 0
  00165	7d 09		 jge	 SHORT $LN23@ItemDrop
  00167	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
  0016e	eb 1c		 jmp	 SHORT $LN24@ItemDrop
$LN23@ItemDrop:
  00170	83 7d 0c 02	 cmp	 DWORD PTR _level$[ebp], 2
  00174	7e 09		 jle	 SHORT $LN21@ItemDrop
  00176	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
  0017d	eb 07		 jmp	 SHORT $LN22@ItemDrop
$LN21@ItemDrop:
  0017f	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv159[ebp], 1
$LN22@ItemDrop:
  00186	8b 45 a8	 mov	 eax, DWORD PTR tv159[ebp]
  00189	89 45 ac	 mov	 DWORD PTR tv160[ebp], eax
$LN24@ItemDrop:
  0018c	83 7d ac 00	 cmp	 DWORD PTR tv160[ebp], 0
  00190	0f 84 17 01 00
	00		 je	 $LN13@ItemDrop

; 528  : 						// 블러드캐슬의 대천사 시리즈라면 현재 해당 블러드캐슬의 대천사 시리얼과 비교해서 맞으면 가지고 있는 사람정보 초기화
; 529  : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	// 블러드캐슬 다리 인덱스 변경
; 530  : 						int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( thisMapNumber );
; 531  : 						if (g_BloodCastle.m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL != -1) {
; 532  : 							if (number == g_BloodCastle.m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL) {
; 533  : 								if (g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX != -1) {
; 534  : 									LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Dropped Angel King's Weapon (%d)",
; 535  : 										iBridgeIndex + 1,
; 536  : 										gObj[g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX].AccountID,
; 537  : 										gObj[g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX].Name,
; 538  : 										g_BloodCastle.m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER
; 539  : 										);
; 540  : 
; 541  : 									g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX = -1;
; 542  : 									g_BloodCastle.m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER = 0;
; 543  : 								}
; 544  : 							}
; 545  : 						}
; 546  : #else						
; 547  : 						if (g_BloodCastle.m_BridgeData[thisMapNumber - MAP_INDEX_BLOODCASTLE1].m_nBC_QUESTITEM_SERIAL != -1) {

  00196	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00199	8b 88 88 04 05
	00		 mov	 ecx, DWORD PTR [eax+328840]
  0019f	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  001a2	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  001a8	83 ba 90 01 00
	00 ff		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+400], -1
  001af	0f 84 f8 00 00
	00		 je	 $LN13@ItemDrop

; 548  : 							if (number == g_BloodCastle.m_BridgeData[thisMapNumber - MAP_INDEX_BLOODCASTLE1].m_nBC_QUESTITEM_SERIAL) {

  001b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b8	8b 88 88 04 05
	00		 mov	 ecx, DWORD PTR [eax+328840]
  001be	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  001c1	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  001c7	8b 45 30	 mov	 eax, DWORD PTR _number$[ebp]
  001ca	3b 82 90 01 00
	00		 cmp	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+400]
  001d0	0f 85 d7 00 00
	00		 jne	 $LN13@ItemDrop

; 549  : 								if (g_BloodCastle.m_BridgeData[thisMapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_QUEST_ITEM_USER_INDEX != -1) {

  001d6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d9	8b 88 88 04 05
	00		 mov	 ecx, DWORD PTR [eax+328840]
  001df	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  001e2	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  001e8	83 ba 94 01 00
	00 ff		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+404], -1
  001ef	0f 84 b8 00 00
	00		 je	 $LN13@ItemDrop

; 550  : 									LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Dropped Angel King's Weapon (%d)",

  001f5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001f8	8b 88 88 04 05
	00		 mov	 ecx, DWORD PTR [eax+328840]
  001fe	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00201	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00207	0f b6 82 98 01
	00 00		 movzx	 eax, BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+408]
  0020e	50		 push	 eax
  0020f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00212	8b 91 88 04 05
	00		 mov	 edx, DWORD PTR [ecx+328840]
  00218	83 ea 0b	 sub	 edx, 11			; 0000000bH
  0021b	69 c2 04 02 00
	00		 imul	 eax, edx, 516
  00221	69 88 94 01 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+404], 7072
  0022b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00231	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00235	50		 push	 eax
  00236	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00239	8b 91 88 04 05
	00		 mov	 edx, DWORD PTR [ecx+328840]
  0023f	83 ea 0b	 sub	 edx, 11			; 0000000bH
  00242	69 c2 04 02 00
	00		 imul	 eax, edx, 516
  00248	69 88 94 01 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+404], 7072
  00252	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00258	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0025c	50		 push	 eax
  0025d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00260	8b 91 88 04 05
	00		 mov	 edx, DWORD PTR [ecx+328840]
  00266	83 ea 0a	 sub	 edx, 10			; 0000000aH
  00269	52		 push	 edx
  0026a	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@BKCBEOOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs@
  0026f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00275	83 c4 14	 add	 esp, 20			; 00000014H

; 551  : 										thisMapNumber - MAP_INDEX_BLOODCASTLE1 + 1,
; 552  : 										gObj[g_BloodCastle.m_BridgeData[thisMapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_QUEST_ITEM_USER_INDEX].AccountID,
; 553  : 										gObj[g_BloodCastle.m_BridgeData[thisMapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_QUEST_ITEM_USER_INDEX].Name,
; 554  : 										g_BloodCastle.m_BridgeData[thisMapNumber - MAP_INDEX_BLOODCASTLE1].m_btBC_QUEST_ITEM_NUMBER
; 555  : 										);
; 556  : 
; 557  : 									g_BloodCastle.m_BridgeData[thisMapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_QUEST_ITEM_USER_INDEX = -1;

  00278	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0027b	8b 88 88 04 05
	00		 mov	 ecx, DWORD PTR [eax+328840]
  00281	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00284	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0028a	c7 82 94 01 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+404], -1

; 558  : 									g_BloodCastle.m_BridgeData[thisMapNumber - MAP_INDEX_BLOODCASTLE1].m_btBC_QUEST_ITEM_NUMBER = 0;

  00294	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00297	8b 88 88 04 05
	00		 mov	 ecx, DWORD PTR [eax+328840]
  0029d	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  002a0	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  002a6	c6 82 98 01 00
	00 00		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+408], 0
$LN13@ItemDrop:

; 559  : 								}
; 560  : 							}
; 561  : 						}
; 562  : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 563  : 					}
; 564  : 				}
; 565  : 			}
; 566  : #endif
; 567  : 			return TRUE;

  002ad	b8 01 00 00 00	 mov	 eax, 1
  002b2	eb 5e		 jmp	 SHORT $LN1@ItemDrop
$LN6@ItemDrop:

; 568  : 		}
; 569  : 		count++;

  002b4	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  002b7	83 c0 01	 add	 eax, 1
  002ba	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 570  : 		if( count > MAX_MAPITEM-1 ) count=0;

  002bd	81 7d f8 2b 01
	00 00		 cmp	 DWORD PTR _count$[ebp], 299 ; 0000012bH
  002c4	7e 07		 jle	 SHORT $LN14@ItemDrop
  002c6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN14@ItemDrop:

; 571  : 		counttot++;

  002cd	8b 45 f4	 mov	 eax, DWORD PTR _counttot$[ebp]
  002d0	83 c0 01	 add	 eax, 1
  002d3	89 45 f4	 mov	 DWORD PTR _counttot$[ebp], eax

; 572  : 		if( counttot > MAX_MAPITEM-1 ) return FALSE;

  002d6	81 7d f4 2b 01
	00 00		 cmp	 DWORD PTR _counttot$[ebp], 299 ; 0000012bH
  002dd	7e 04		 jle	 SHORT $LN15@ItemDrop
  002df	33 c0		 xor	 eax, eax
  002e1	eb 2f		 jmp	 SHORT $LN1@ItemDrop
$LN15@ItemDrop:

; 573  : 	}

  002e3	e9 63 fd ff ff	 jmp	 $LN2@ItemDrop
$LN3@ItemDrop:

; 574  : 	LogAdd(lMsg.Get(461), __FILE__, __LINE__);

  002e8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z@4JA
  002ed	83 c0 53	 add	 eax, 83			; 00000053H
  002f0	50		 push	 eax
  002f1	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  002f6	68 cd 01 00 00	 push	 461			; 000001cdH
  002fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00300	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00306	50		 push	 eax
  00307	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0030d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 575  : 	return FALSE;

  00310	33 c0		 xor	 eax, eax
$LN1@ItemDrop:

; 576  : }

  00312	5f		 pop	 edi
  00313	5e		 pop	 esi
  00314	5b		 pop	 ebx
  00315	8b e5		 mov	 esp, ebp
  00317	5d		 pop	 ebp
  00318	c2 38 00	 ret	 56			; 00000038H
?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHH@Z ENDP		; MapClass::ItemDrop
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?ClearItem@MapClass@@QAEHPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_nDis$1 = -28						; size = 4
_nDisY$2 = -24						; size = 4
_nDisX$3 = -20						; size = 4
_pMapItem$4 = -16					; size = 4
_i$5 = -12						; size = 4
_nCount$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_nDistance$ = 12					; size = 4
?ClearItem@MapClass@@QAEHPAVOBJECTSTRUCT@@H@Z PROC	; MapClass::ClearItem, COMDAT
; _this$ = ecx

; 757  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 758  : 	int nCount = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nCount$[ebp], 0

; 759  : 
; 760  : 	for (int i=0; i<m_ItemCount; ++i)

  00013	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@ClearItem
$LN2@ClearItem:
  0001c	8b 45 f4	 mov	 eax, DWORD PTR _i$5[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 f4	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@ClearItem:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 4d f4	 mov	 ecx, DWORD PTR _i$5[ebp]
  0002b	3b 88 80 04 05
	00		 cmp	 ecx, DWORD PTR [eax+328832]
  00031	0f 8d fe 00 00
	00		 jge	 $LN3@ClearItem

; 761  : 	{
; 762  : 		CMapItem* pMapItem = &m_cItem[i];

  00037	69 45 f4 48 04
	00 00		 imul	 eax, DWORD PTR _i$5[ebp], 1096
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	8d 54 01 20	 lea	 edx, DWORD PTR [ecx+eax+32]
  00045	89 55 f0	 mov	 DWORD PTR _pMapItem$4[ebp], edx

; 763  : 		if( pMapItem->IsItem() && !pMapItem->Give && pMapItem->live && gLootingTime > 0)

  00048	8b 4d f0	 mov	 ecx, DWORD PTR _pMapItem$4[ebp]
  0004b	83 c1 04	 add	 ecx, 4
  0004e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00053	85 c0		 test	 eax, eax
  00055	0f 84 d5 00 00
	00		 je	 $LN7@ClearItem
  0005b	8b 45 f0	 mov	 eax, DWORD PTR _pMapItem$4[ebp]
  0005e	0f b6 88 af 00
	00 00		 movzx	 ecx, BYTE PTR [eax+175]
  00065	85 c9		 test	 ecx, ecx
  00067	0f 85 c3 00 00
	00		 jne	 $LN7@ClearItem
  0006d	8b 45 f0	 mov	 eax, DWORD PTR _pMapItem$4[ebp]
  00070	0f b6 88 ae 00
	00 00		 movzx	 ecx, BYTE PTR [eax+174]
  00077	85 c9		 test	 ecx, ecx
  00079	0f 84 b1 00 00
	00		 je	 $LN7@ClearItem
  0007f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLootingTime@@3HA, 0 ; gLootingTime
  00086	0f 8e a4 00 00
	00		 jle	 $LN7@ClearItem

; 764  : 		{
; 765  : #ifndef GMCOMMAND_EX_1ST_BUGFIX
; 766  : 			if (pMapItem->m_UserIndex < 0)

  0008c	8b 45 f0	 mov	 eax, DWORD PTR _pMapItem$4[ebp]
  0008f	83 b8 b8 00 00
	00 00		 cmp	 DWORD PTR [eax+184], 0
  00096	7d 02		 jge	 SHORT $LN6@ClearItem

; 767  : 				continue;

  00098	eb 82		 jmp	 SHORT $LN2@ClearItem
$LN6@ClearItem:

; 768  : #endif // GMCOMMAND_EX_1ST_BUGFIX
; 769  : 
; 770  : 			int nDisX = lpObj->X-pMapItem->px;

  0009a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009d	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000a4	8b 55 f0	 mov	 edx, DWORD PTR _pMapItem$4[ebp]
  000a7	0f b6 82 ac 00
	00 00		 movzx	 eax, BYTE PTR [edx+172]
  000ae	2b c8		 sub	 ecx, eax
  000b0	89 4d ec	 mov	 DWORD PTR _nDisX$3[ebp], ecx

; 771  : 			int nDisY = lpObj->Y-pMapItem->py;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b6	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000bd	8b 55 f0	 mov	 edx, DWORD PTR _pMapItem$4[ebp]
  000c0	0f b6 82 ad 00
	00 00		 movzx	 eax, BYTE PTR [edx+173]
  000c7	2b c8		 sub	 ecx, eax
  000c9	89 4d e8	 mov	 DWORD PTR _nDisY$2[ebp], ecx

; 772  : 			int nDis = (int)( sqrt((double)(nDisX*nDisX)+(nDisY*nDisY)) );

  000cc	8b 45 ec	 mov	 eax, DWORD PTR _nDisX$3[ebp]
  000cf	0f af 45 ec	 imul	 eax, DWORD PTR _nDisX$3[ebp]
  000d3	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  000d7	8b 4d e8	 mov	 ecx, DWORD PTR _nDisY$2[ebp]
  000da	0f af 4d e8	 imul	 ecx, DWORD PTR _nDisY$2[ebp]
  000de	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  000e2	f2 0f 58 c1	 addsd	 xmm0, xmm1
  000e6	83 ec 08	 sub	 esp, 8
  000e9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000ee	e8 00 00 00 00	 call	 _sqrt
  000f3	83 c4 08	 add	 esp, 8
  000f6	e8 00 00 00 00	 call	 __ftol2_sse
  000fb	89 45 e4	 mov	 DWORD PTR _nDis$1[ebp], eax

; 773  : 			//if ( GetTickCount() < pMapItem->m_LootTime && nDis <= nDistance )
; 774  : 			if ( nDis <= nDistance )

  000fe	8b 45 e4	 mov	 eax, DWORD PTR _nDis$1[ebp]
  00101	3b 45 0c	 cmp	 eax, DWORD PTR _nDistance$[ebp]
  00104	7f 2a		 jg	 SHORT $LN7@ClearItem

; 775  : 			{
; 776  : 				pMapItem->m_State	= OBJST_DIECMD;

  00106	8b 45 f0	 mov	 eax, DWORD PTR _pMapItem$4[ebp]
  00109	c7 80 b0 00 00
	00 08 00 00 00	 mov	 DWORD PTR [eax+176], 8

; 777  : 				pMapItem->Give		= 1;

  00113	8b 45 f0	 mov	 eax, DWORD PTR _pMapItem$4[ebp]
  00116	c6 80 af 00 00
	00 01		 mov	 BYTE PTR [eax+175], 1

; 778  : 				pMapItem->live		= 0;

  0011d	8b 45 f0	 mov	 eax, DWORD PTR _pMapItem$4[ebp]
  00120	c6 80 ae 00 00
	00 00		 mov	 BYTE PTR [eax+174], 0

; 779  : 
; 780  : 				++nCount;

  00127	8b 45 f8	 mov	 eax, DWORD PTR _nCount$[ebp]
  0012a	83 c0 01	 add	 eax, 1
  0012d	89 45 f8	 mov	 DWORD PTR _nCount$[ebp], eax
$LN7@ClearItem:

; 781  : 			}
; 782  : 		}
; 783  : 	}

  00130	e9 e7 fe ff ff	 jmp	 $LN2@ClearItem
$LN3@ClearItem:

; 784  : 
; 785  : 	return nCount;

  00135	8b 45 f8	 mov	 eax, DWORD PTR _nCount$[ebp]

; 786  : }

  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 08 00	 ret	 8
?ClearItem@MapClass@@QAEHPAVOBJECTSTRUCT@@H@Z ENDP	; MapClass::ClearItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?ItemGive@MapClass@@QAEHHH_N@Z
_TEXT	SEGMENT
tv289 = -348						; size = 4
tv240 = -348						; size = 4
tv66 = -348						; size = 4
tv290 = -344						; size = 4
tv241 = -344						; size = 4
tv67 = -344						; size = 4
_szTemp$1 = -276					; size = 256
_lootresult$ = -20					; size = 4
_disy$ = -16						; size = 4
_disx$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item_num$ = 12						; size = 4
_bFailNotSend$ = 16					; size = 1
?ItemGive@MapClass@@QAEHHH_N@Z PROC			; MapClass::ItemGive, COMDAT
; _this$ = ecx

; 634  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 635  : 	if( !CHECK_LIMIT( item_num, MAX_MAPITEM ) )

  00019	83 7d 0c 00	 cmp	 DWORD PTR _item_num$[ebp], 0
  0001d	7d 0c		 jge	 SHORT $LN28@ItemGive
  0001f	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00029	eb 2b		 jmp	 SHORT $LN29@ItemGive
$LN28@ItemGive:
  0002b	81 7d 0c 2b 01
	00 00		 cmp	 DWORD PTR _item_num$[ebp], 299 ; 0000012bH
  00032	7e 0c		 jle	 SHORT $LN26@ItemGive
  00034	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003e	eb 0a		 jmp	 SHORT $LN27@ItemGive
$LN26@ItemGive:
  00040	c7 85 a4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN27@ItemGive:
  0004a	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  00050	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN29@ItemGive:
  00056	83 bd a8 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005d	75 2f		 jne	 SHORT $LN2@ItemGive

; 636  : 	{
; 637  : 		LogAdd(lMsg.Get(462), __FILE__, __LINE__);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ItemGive@MapClass@@QAEHHH_N@Z@4JA
  00064	83 c0 03	 add	 eax, 3
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0006d	68 ce 01 00 00	 push	 462			; 000001ceH
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0007d	50		 push	 eax
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 638  : 		return FALSE;

  00087	33 c0		 xor	 eax, eax
  00089	e9 1f 04 00 00	 jmp	 $LN1@ItemGive
$LN2@ItemGive:

; 639  : 	}
; 640  : 
; 641  : 	if( gObj[aIndex].MapNumber != thisMapNumber )

  0008e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00095	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009b	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000a3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	3b 90 88 04 05
	00		 cmp	 edx, DWORD PTR [eax+328840]
  000ac	74 57		 je	 SHORT $LN3@ItemGive

; 642  : 	{
; 643  : 		LogAdd(lMsg.Get(463),__FILE__, __LINE__,  gObj[aIndex].MapNumber, gObj[aIndex].Name);

  000ae	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bb	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000bf	52		 push	 edx
  000c0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cd	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000d5	52		 push	 edx
  000d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ItemGive@MapClass@@QAEHHH_N@Z@4JA
  000db	83 c0 09	 add	 eax, 9
  000de	50		 push	 eax
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000e4	68 cf 01 00 00	 push	 463			; 000001cfH
  000e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000f4	50		 push	 eax
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fb	83 c4 14	 add	 esp, 20			; 00000014H

; 644  : 		return FALSE;

  000fe	33 c0		 xor	 eax, eax
  00100	e9 a8 03 00 00	 jmp	 $LN1@ItemGive
$LN3@ItemGive:

; 645  : 	}
; 646  : 	if( m_cItem[item_num].IsItem() == FALSE ) {

  00105	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  0010c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	8d 4c 01 24	 lea	 ecx, DWORD PTR [ecx+eax+36]
  00113	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00118	85 c0		 test	 eax, eax
  0011a	75 41		 jne	 SHORT $LN4@ItemGive

; 647  : 		LogAdd(lMsg.Get(464), __FILE__, __LINE__, gObj[aIndex].Name);

  0011c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00123	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00129	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0012d	52		 push	 edx
  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??ItemGive@MapClass@@QAEHHH_N@Z@4JA
  00133	83 c0 0d	 add	 eax, 13			; 0000000dH
  00136	50		 push	 eax
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0013c	68 d0 01 00 00	 push	 464			; 000001d0H
  00141	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0014c	50		 push	 eax
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00153	83 c4 10	 add	 esp, 16			; 00000010H

; 648  : 		return FALSE;

  00156	33 c0		 xor	 eax, eax
  00158	e9 50 03 00 00	 jmp	 $LN1@ItemGive
$LN4@ItemGive:

; 649  : 	}
; 650  : 	if( m_cItem[item_num].Give == 1 ) {

  0015d	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  00164	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	0f b6 94 01 cf
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+207]
  0016f	83 fa 01	 cmp	 edx, 1
  00172	75 07		 jne	 SHORT $LN5@ItemGive

; 651  : 		return FALSE;

  00174	33 c0		 xor	 eax, eax
  00176	e9 32 03 00 00	 jmp	 $LN1@ItemGive
$LN5@ItemGive:

; 652  : 	}
; 653  : 	if( m_cItem[item_num].live == 0 ) 

  0017b	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  00182	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00185	0f b6 94 01 ce
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+206]
  0018d	85 d2		 test	 edx, edx
  0018f	75 07		 jne	 SHORT $LN6@ItemGive

; 654  : 	{
; 655  : 		return FALSE;

  00191	33 c0		 xor	 eax, eax
  00193	e9 15 03 00 00	 jmp	 $LN1@ItemGive
$LN6@ItemGive:

; 656  : 	}		
; 657  : 
; 658  : 	int disx= m_cItem[item_num].px-gObj[aIndex].X;

  00198	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  0019f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	0f b6 94 01 cc
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+204]
  001aa	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b7	0f bf 84 01 04
	01 00 00	 movsx	 eax, WORD PTR [ecx+eax+260]
  001bf	2b d0		 sub	 edx, eax
  001c1	89 55 f4	 mov	 DWORD PTR _disx$[ebp], edx

; 659  : 	int disy= m_cItem[item_num].py-gObj[aIndex].Y;

  001c4	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  001cb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ce	0f b6 94 01 cd
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+205]
  001d6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e3	0f bf 84 01 06
	01 00 00	 movsx	 eax, WORD PTR [ecx+eax+262]
  001eb	2b d0		 sub	 edx, eax
  001ed	89 55 f0	 mov	 DWORD PTR _disy$[ebp], edx

; 660  : 
; 661  : 	// 멀리 있는 아이템을 주울수 없다..
; 662  : 	if( disx > 2 || disx < -2 ) return FALSE;

  001f0	83 7d f4 02	 cmp	 DWORD PTR _disx$[ebp], 2
  001f4	7f 06		 jg	 SHORT $LN8@ItemGive
  001f6	83 7d f4 fe	 cmp	 DWORD PTR _disx$[ebp], -2 ; fffffffeH
  001fa	7d 07		 jge	 SHORT $LN7@ItemGive
$LN8@ItemGive:
  001fc	33 c0		 xor	 eax, eax
  001fe	e9 aa 02 00 00	 jmp	 $LN1@ItemGive
$LN7@ItemGive:

; 663  : 	if( disy > 2 || disy < -2 ) return FALSE;

  00203	83 7d f0 02	 cmp	 DWORD PTR _disy$[ebp], 2
  00207	7f 06		 jg	 SHORT $LN10@ItemGive
  00209	83 7d f0 fe	 cmp	 DWORD PTR _disy$[ebp], -2 ; fffffffeH
  0020d	7d 07		 jge	 SHORT $LN9@ItemGive
$LN10@ItemGive:
  0020f	33 c0		 xor	 eax, eax
  00211	e9 97 02 00 00	 jmp	 $LN1@ItemGive
$LN9@ItemGive:

; 664  : 
; 665  : 	int lootresult=1;

  00216	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _lootresult$[ebp], 1

; 666  : 
; 667  : 	if( gLootingTime > 0 )

  0021d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLootingTime@@3HA, 0 ; gLootingTime
  00224	0f 8e eb 01 00
	00		 jle	 $LN11@ItemGive

; 668  : 	{
; 669  : 		if( m_cItem[item_num].m_UserIndex != -1 )

  0022a	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  00231	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	83 bc 01 d8 00
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+216], -1
  0023c	0f 84 d3 01 00
	00		 je	 $LN11@ItemGive

; 670  : 		{
; 671  : 			if( GetTickCount() < m_cItem[item_num].m_LootTime )

  00242	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00248	69 4d 0c 48 04
	00 00		 imul	 ecx, DWORD PTR _item_num$[ebp], 1096
  0024f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00252	3b 84 0a dc 00
	00 00		 cmp	 eax, DWORD PTR [edx+ecx+220]
  00259	0f 83 b6 01 00
	00		 jae	 $LN11@ItemGive

; 672  : 			{
; 673  : 				//LogAddL("루팅 체크 %d %d 아이템 체크", aIndex, m_cItem[item_num].m_UserIndex);
; 674  : 				
; 675  : 				// 자기 아이템이 아니면..
; 676  : 				if( aIndex != m_cItem[item_num].m_UserIndex )

  0025f	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  00266	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0026c	3b 94 01 d8 00
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+216]
  00273	0f 84 9c 01 00
	00		 je	 $LN11@ItemGive

; 677  : 				{
; 678  : 					lootresult = 0;

  00279	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lootresult$[ebp], 0

; 679  : #ifndef THIRD_CHANGEUP_SYSTEM_20070507	// 퀘스트 아이템도 파티체크를한다.
; 680  : #ifdef NEW_SKILL_FORSKYLAND
; 681  : 					if( !m_cItem[item_num].m_QuestItem )

  00280	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  00287	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0028a	0f b6 94 01 b5
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+181]
  00292	85 d2		 test	 edx, edx
  00294	0f 85 7b 01 00
	00		 jne	 $LN11@ItemGive

; 682  : 					{	// 퀘스트 아이템이 아닐때는 파티 체크를 한다
; 683  : #endif
; 684  : #endif	// THIRD_CHANGEUP_SYSTEM_20070507
; 685  : 						// 파티가 있고..
; 686  : 						if( gObj[aIndex].PartyNumber >= 0 )

  0029a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a7	83 bc 01 88 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+648], 0
  002af	0f 8c 60 01 00
	00		 jl	 $LN11@ItemGive

; 687  : 						{
; 688  : 							// 나의 파티원 들 이라면..
; 689  : 							if( gObj[aIndex].PartyNumber == gObj[m_cItem[item_num].m_UserIndex].PartyNumber )

  002b5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002bc	69 4d 0c 48 04
	00 00		 imul	 ecx, DWORD PTR _item_num$[ebp], 1096
  002c3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  002c6	69 8c 0a d8 00
	00 00 a0 1b 00
	00		 imul	 ecx, DWORD PTR [edx+ecx+216], 7072
  002d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002dd	8b 84 02 88 02
	00 00		 mov	 eax, DWORD PTR [edx+eax+648]
  002e4	3b 84 0e 88 02
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+648]
  002eb	0f 85 24 01 00
	00		 jne	 $LN11@ItemGive

; 690  : 							{
; 691  : #ifdef FOR_BLOODCASTLE
; 692  : 								if (CHECK_BLOODCASTLE(gObj[aIndex].MapNumber)) {

  002f1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002fe	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00306	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00309	7d 0c		 jge	 SHORT $LN32@ItemGive
  0030b	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv241[ebp], 0
  00315	eb 3c		 jmp	 SHORT $LN33@ItemGive
$LN32@ItemGive:
  00317	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0031e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00324	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0032c	83 fa 11	 cmp	 edx, 17			; 00000011H
  0032f	7e 0c		 jle	 SHORT $LN30@ItemGive
  00331	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv240[ebp], 0
  0033b	eb 0a		 jmp	 SHORT $LN31@ItemGive
$LN30@ItemGive:
  0033d	c7 85 a4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv240[ebp], 1
$LN31@ItemGive:
  00347	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv240[ebp]
  0034d	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv241[ebp], eax
$LN33@ItemGive:
  00353	83 bd a8 fe ff
	ff 00		 cmp	 DWORD PTR tv241[ebp], 0
  0035a	0f 84 ae 00 00
	00		 je	 $LN18@ItemGive

; 693  : 									// 같은 파티원 
; 694  : 									if ((m_cItem[item_num].m_Type == MAKE_ITEMNUM(12, 15)) ||

  00360	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  00367	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0036a	0f bf 74 01 2a	 movsx	 esi, WORD PTR [ecx+eax+42]
  0036f	6a 0f		 push	 15			; 0000000fH
  00371	6a 0c		 push	 12			; 0000000cH
  00373	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00378	83 c4 08	 add	 esp, 8
  0037b	3b f0		 cmp	 esi, eax
  0037d	74 7d		 je	 SHORT $LN22@ItemGive
  0037f	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  00386	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00389	0f bf 74 01 2a	 movsx	 esi, WORD PTR [ecx+eax+42]
  0038e	6a 13		 push	 19			; 00000013H
  00390	6a 0d		 push	 13			; 0000000dH
  00392	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00397	83 c4 08	 add	 esp, 8
  0039a	3b f0		 cmp	 esi, eax
  0039c	75 67		 jne	 SHORT $LN20@ItemGive
  0039e	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  003a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	0f bf 54 01 2c	 movsx	 edx, WORD PTR [ecx+eax+44]
  003ad	85 d2		 test	 edx, edx
  003af	7d 0c		 jge	 SHORT $LN36@ItemGive
  003b1	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv290[ebp], 0
  003bb	eb 36		 jmp	 SHORT $LN37@ItemGive
$LN36@ItemGive:
  003bd	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  003c4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003c7	0f bf 54 01 2c	 movsx	 edx, WORD PTR [ecx+eax+44]
  003cc	83 fa 02	 cmp	 edx, 2
  003cf	7e 0c		 jle	 SHORT $LN34@ItemGive
  003d1	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv289[ebp], 0
  003db	eb 0a		 jmp	 SHORT $LN35@ItemGive
$LN34@ItemGive:
  003dd	c7 85 a4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv289[ebp], 1
$LN35@ItemGive:
  003e7	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv289[ebp]
  003ed	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv290[ebp], eax
$LN37@ItemGive:
  003f3	83 bd a8 fe ff
	ff 00		 cmp	 DWORD PTR tv290[ebp], 0
  003fa	74 09		 je	 SHORT $LN20@ItemGive
$LN22@ItemGive:

; 695  : 										((m_cItem[item_num].m_Type == MAKE_ITEMNUM(13, 19)) && (CHECK_LIMIT(m_cItem[item_num].m_Level, 3))))
; 696  : 									{
; 697  : 										lootresult = 0;

  003fc	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lootresult$[ebp], 0

; 698  : 									}

  00403	eb 07		 jmp	 SHORT $LN21@ItemGive
$LN20@ItemGive:

; 699  : 									else
; 700  : 										lootresult = 1;

  00405	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _lootresult$[ebp], 1
$LN21@ItemGive:

; 701  : 								}

  0040c	eb 07		 jmp	 SHORT $LN11@ItemGive
$LN18@ItemGive:

; 702  : 								else
; 703  : 									lootresult = 1;

  0040e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _lootresult$[ebp], 1
$LN11@ItemGive:

; 704  : 
; 705  : #else
; 706  : 								lootresult = 1;
; 707  : #endif
; 708  : 
; 709  : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	// 사원이벤트중 혼석은 자신만 루팅가능
; 710  : 								if(CHECK_ILLUSION_TEMPLE(gObj[aIndex].MapNumber))
; 711  : 								{
; 712  : 									if (m_cItem[item_num].m_Type == MAKE_ITEMNUM(12, 15))
; 713  : 									{
; 714  : 										lootresult = 0;
; 715  : 									}
; 716  : 								}
; 717  : #endif
; 718  : 
; 719  : 								//LogAddL("파티중 아이템 줍기 : %s %s", gObj[aIndex].Name, gObj[m_cItem[item_num].m_UserIndex].Name);
; 720  : 							}
; 721  : 						}
; 722  : #ifndef THIRD_CHANGEUP_SYSTEM_20070507	// 퀘스트 아이템도 파티체크를한다. 
; 723  : #ifdef NEW_SKILL_FORSKYLAND
; 724  : 					}
; 725  : #endif
; 726  : #endif
; 727  : 				}
; 728  : 			}
; 729  : 		}
; 730  : 	}
; 731  : 
; 732  : 	if( lootresult == 0 )

  00415	83 7d ec 00	 cmp	 DWORD PTR _lootresult$[ebp], 0
  00419	75 54		 jne	 SHORT $LN23@ItemGive

; 733  : 	{
; 734  : #ifdef ADD_NEW_MAP_KALIMA_20040518
; 735  : 		if (!bFailNotSend) {

  0041b	0f b6 45 10	 movzx	 eax, BYTE PTR _bFailNotSend$[ebp]
  0041f	85 c0		 test	 eax, eax
  00421	75 48		 jne	 SHORT $LN24@ItemGive

; 736  : 			char szTemp[256];
; 737  : 			//LogAddL("error-L3 : 자신의 아이템이 아니다.%s %d/%d", gObj[aIndex].Name, aIndex, m_cItem[item_num].m_UserIndex);
; 738  : 			wsprintf(szTemp,lMsg.Get(1152), gObj[aIndex].Name);

  00423	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0042a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00430	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00434	52		 push	 edx
  00435	68 80 04 00 00	 push	 1152			; 00000480H
  0043a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0043f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00445	50		 push	 eax
  00446	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  0044c	50		 push	 eax
  0044d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00453	83 c4 0c	 add	 esp, 12			; 0000000cH

; 739  : 			GCServerMsgStringSend(szTemp, aIndex, 1);

  00456	6a 01		 push	 1
  00458	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0045b	50		 push	 eax
  0045c	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$1[ebp]
  00462	51		 push	 ecx
  00463	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00468	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@ItemGive:

; 740  : 		}
; 741  : #endif
; 742  : 		return FALSE;

  0046b	33 c0		 xor	 eax, eax
  0046d	eb 3e		 jmp	 SHORT $LN1@ItemGive
$LN23@ItemGive:

; 743  : 	}
; 744  : 
; 745  : 	m_cItem[item_num].m_State	= OBJST_DIECMD;

  0046f	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  00476	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00479	c7 84 01 d0 00
	00 00 08 00 00
	00		 mov	 DWORD PTR [ecx+eax+208], 8

; 746  : 	m_cItem[item_num].Give		= 1;

  00484	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  0048b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0048e	c6 84 01 cf 00
	00 00 01	 mov	 BYTE PTR [ecx+eax+207], 1

; 747  : 	m_cItem[item_num].live		= 0;

  00496	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  0049d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004a0	c6 84 01 ce 00
	00 00 00	 mov	 BYTE PTR [ecx+eax+206], 0

; 748  : 
; 749  : 
; 750  : 
; 751  : 	//LogAdd("OBJST_DIECMD1");
; 752  : 	return TRUE;

  004a8	b8 01 00 00 00	 mov	 eax, 1
$LN1@ItemGive:

; 753  : }

  004ad	5f		 pop	 edi
  004ae	5e		 pop	 esi
  004af	5b		 pop	 ebx
  004b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b3	33 cd		 xor	 ecx, ebp
  004b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ba	8b e5		 mov	 esp, ebp
  004bc	5d		 pop	 ebp
  004bd	c2 0c 00	 ret	 12			; 0000000cH
?ItemGive@MapClass@@QAEHHH_N@Z ENDP			; MapClass::ItemGive
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?ItemInit@MapClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ItemInit@MapClass@@QAEXXZ PROC				; MapClass::ItemInit, COMDAT
; _this$ = ecx

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 384  : 
; 385  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?ItemInit@MapClass@@QAEXXZ ENDP				; MapClass::ItemInit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?CheckWall2@MapClass@@QAEEHHHH@Z
_TEXT	SEGMENT
_Shadow$ = -56						; size = 4
_count$ = -52						; size = 4
_error$ = -48						; size = 4
_start$ = -44						; size = 4
_py1$ = -40						; size = 4
_px1$ = -36						; size = 4
_len2$ = -32						; size = 4
_len1$ = -28						; size = 4
_d2$ = -24						; size = 4
_d1$ = -20						; size = 4
_ny1$ = -16						; size = 4
_nx1$ = -12						; size = 4
_Index$ = -8						; size = 4
_this$ = -4						; size = 4
_sx1$ = 8						; size = 4
_sy1$ = 12						; size = 4
_sx2$ = 16						; size = 4
_sy2$ = 20						; size = 4
?CheckWall2@MapClass@@QAEEHHHH@Z PROC			; MapClass::CheckWall2, COMDAT
; _this$ = ecx

; 1209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1210 : 	int Index = TERRAIN_INDEX_REPEAT(sx1,sy1);//sy1*256+sy1

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _sy1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _sx1$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?TERRAIN_INDEX_REPEAT@@YAHHH@Z ; TERRAIN_INDEX_REPEAT
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 1211 : 
; 1212 :     int nx1,ny1,d1,d2,len1,len2;
; 1213 :     int px1 = sx2-sx1;

  0001f	8b 45 10	 mov	 eax, DWORD PTR _sx2$[ebp]
  00022	2b 45 08	 sub	 eax, DWORD PTR _sx1$[ebp]
  00025	89 45 dc	 mov	 DWORD PTR _px1$[ebp], eax

; 1214 :     int py1 = sy2-sy1;

  00028	8b 45 14	 mov	 eax, DWORD PTR _sy2$[ebp]
  0002b	2b 45 0c	 sub	 eax, DWORD PTR _sy1$[ebp]
  0002e	89 45 d8	 mov	 DWORD PTR _py1$[ebp], eax

; 1215 :     if(px1 < 0  ) {px1 = -px1;nx1 =-1           ;} else nx1 = 1;

  00031	83 7d dc 00	 cmp	 DWORD PTR _px1$[ebp], 0
  00035	7d 11		 jge	 SHORT $LN5@CheckWall2
  00037	8b 45 dc	 mov	 eax, DWORD PTR _px1$[ebp]
  0003a	f7 d8		 neg	 eax
  0003c	89 45 dc	 mov	 DWORD PTR _px1$[ebp], eax
  0003f	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _nx1$[ebp], -1
  00046	eb 07		 jmp	 SHORT $LN6@CheckWall2
$LN5@CheckWall2:
  00048	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _nx1$[ebp], 1
$LN6@CheckWall2:

; 1216 :     if(py1 < 0  ) {py1 = -py1;ny1 =-TERRAIN_SIZE;} else ny1 = TERRAIN_SIZE;

  0004f	83 7d d8 00	 cmp	 DWORD PTR _py1$[ebp], 0
  00053	7d 11		 jge	 SHORT $LN7@CheckWall2
  00055	8b 45 d8	 mov	 eax, DWORD PTR _py1$[ebp]
  00058	f7 d8		 neg	 eax
  0005a	89 45 d8	 mov	 DWORD PTR _py1$[ebp], eax
  0005d	c7 45 f0 00 ff
	ff ff		 mov	 DWORD PTR _ny1$[ebp], -256 ; ffffff00H
  00064	eb 07		 jmp	 SHORT $LN8@CheckWall2
$LN7@CheckWall2:
  00066	c7 45 f0 00 01
	00 00		 mov	 DWORD PTR _ny1$[ebp], 256 ; 00000100H
$LN8@CheckWall2:

; 1217 :     if(px1 > py1) {len1 = px1;len2 = py1;d1 = ny1;d2 = nx1;}

  0006d	8b 45 dc	 mov	 eax, DWORD PTR _px1$[ebp]
  00070	3b 45 d8	 cmp	 eax, DWORD PTR _py1$[ebp]
  00073	7e 1a		 jle	 SHORT $LN9@CheckWall2
  00075	8b 45 dc	 mov	 eax, DWORD PTR _px1$[ebp]
  00078	89 45 e4	 mov	 DWORD PTR _len1$[ebp], eax
  0007b	8b 45 d8	 mov	 eax, DWORD PTR _py1$[ebp]
  0007e	89 45 e0	 mov	 DWORD PTR _len2$[ebp], eax
  00081	8b 45 f0	 mov	 eax, DWORD PTR _ny1$[ebp]
  00084	89 45 ec	 mov	 DWORD PTR _d1$[ebp], eax
  00087	8b 45 f4	 mov	 eax, DWORD PTR _nx1$[ebp]
  0008a	89 45 e8	 mov	 DWORD PTR _d2$[ebp], eax
  0008d	eb 18		 jmp	 SHORT $LN10@CheckWall2
$LN9@CheckWall2:

; 1218 :     else          {len1 = py1;len2 = px1;d1 = nx1;d2 = ny1;}

  0008f	8b 45 d8	 mov	 eax, DWORD PTR _py1$[ebp]
  00092	89 45 e4	 mov	 DWORD PTR _len1$[ebp], eax
  00095	8b 45 dc	 mov	 eax, DWORD PTR _px1$[ebp]
  00098	89 45 e0	 mov	 DWORD PTR _len2$[ebp], eax
  0009b	8b 45 f4	 mov	 eax, DWORD PTR _nx1$[ebp]
  0009e	89 45 ec	 mov	 DWORD PTR _d1$[ebp], eax
  000a1	8b 45 f0	 mov	 eax, DWORD PTR _ny1$[ebp]
  000a4	89 45 e8	 mov	 DWORD PTR _d2$[ebp], eax
$LN10@CheckWall2:

; 1219 : 
; 1220 : 	int   start=0;

  000a7	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0

; 1221 : 	int   error = 0,count = 0;

  000ae	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _error$[ebp], 0
  000b5	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 1222 : 	float Shadow = 0.f;

  000bc	0f 57 c0	 xorps	 xmm0, xmm0
  000bf	f3 0f 11 45 c8	 movss	 DWORD PTR _Shadow$[ebp], xmm0
$LN4@CheckWall2:

; 1223 :     do
; 1224 : 	{
; 1225 : 		if( start == 0 ) 

  000c4	83 7d d4 00	 cmp	 DWORD PTR _start$[ebp], 0
  000c8	75 18		 jne	 SHORT $LN11@CheckWall2

; 1226 : 		{
; 1227 : 			if((m_attrbuf[Index]&MAP_ATTR_STAND) == MAP_ATTR_STAND) return MAP_ATTR_STAND;//케릭터

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000d0	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  000d3	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000d7	83 e0 02	 and	 eax, 2
  000da	74 04		 je	 SHORT $LN13@CheckWall2
  000dc	b0 02		 mov	 al, 2
  000de	eb 63		 jmp	 SHORT $LN1@CheckWall2
$LN13@CheckWall2:

; 1228 : 		}

  000e0	eb 07		 jmp	 SHORT $LN12@CheckWall2
$LN11@CheckWall2:

; 1229 : 		else start = 1;

  000e2	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _start$[ebp], 1
$LN12@CheckWall2:

; 1230 : 
; 1231 : 		if((m_attrbuf[Index]&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK) return MAP_ATTR_BLOCK;//벽

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ef	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  000f2	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000f6	83 e0 04	 and	 eax, 4
  000f9	74 04		 je	 SHORT $LN14@CheckWall2
  000fb	b0 04		 mov	 al, 4
  000fd	eb 44		 jmp	 SHORT $LN1@CheckWall2
$LN14@CheckWall2:

; 1232 : 		error += len2;

  000ff	8b 45 d0	 mov	 eax, DWORD PTR _error$[ebp]
  00102	03 45 e0	 add	 eax, DWORD PTR _len2$[ebp]
  00105	89 45 d0	 mov	 DWORD PTR _error$[ebp], eax

; 1233 : 		if(error > len1/2) 

  00108	8b 45 e4	 mov	 eax, DWORD PTR _len1$[ebp]
  0010b	99		 cdq
  0010c	2b c2		 sub	 eax, edx
  0010e	d1 f8		 sar	 eax, 1
  00110	39 45 d0	 cmp	 DWORD PTR _error$[ebp], eax
  00113	7e 12		 jle	 SHORT $LN15@CheckWall2

; 1234 : 		{
; 1235 : 			Index += d1;

  00115	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00118	03 45 ec	 add	 eax, DWORD PTR _d1$[ebp]
  0011b	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 1236 : 			error -= len1;

  0011e	8b 45 d0	 mov	 eax, DWORD PTR _error$[ebp]
  00121	2b 45 e4	 sub	 eax, DWORD PTR _len1$[ebp]
  00124	89 45 d0	 mov	 DWORD PTR _error$[ebp], eax
$LN15@CheckWall2:

; 1237 : 		}
; 1238 : 		Index += d2;

  00127	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0012a	03 45 e8	 add	 eax, DWORD PTR _d2$[ebp]
  0012d	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 1239 : 	} while(++count <= len1);

  00130	8b 45 cc	 mov	 eax, DWORD PTR _count$[ebp]
  00133	83 c0 01	 add	 eax, 1
  00136	89 45 cc	 mov	 DWORD PTR _count$[ebp], eax
  00139	8b 4d cc	 mov	 ecx, DWORD PTR _count$[ebp]
  0013c	3b 4d e4	 cmp	 ecx, DWORD PTR _len1$[ebp]
  0013f	7e 83		 jle	 SHORT $LN4@CheckWall2

; 1240 : 	
; 1241 : 	return 0x01;

  00141	b0 01		 mov	 al, 1
$LN1@CheckWall2:

; 1242 : }

  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx
  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c2 10 00	 ret	 16			; 00000010H
?CheckWall2@MapClass@@QAEEHHHH@Z ENDP			; MapClass::CheckWall2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?CheckWall@MapClass@@QAEHHHHH@Z
_TEXT	SEGMENT
_Shadow$ = -52						; size = 4
_count$ = -48						; size = 4
_error$ = -44						; size = 4
_py1$ = -40						; size = 4
_px1$ = -36						; size = 4
_len2$ = -32						; size = 4
_len1$ = -28						; size = 4
_d2$ = -24						; size = 4
_d1$ = -20						; size = 4
_ny1$ = -16						; size = 4
_nx1$ = -12						; size = 4
_Index$ = -8						; size = 4
_this$ = -4						; size = 4
_sx1$ = 8						; size = 4
_sy1$ = 12						; size = 4
_sx2$ = 16						; size = 4
_sy2$ = 20						; size = 4
?CheckWall@MapClass@@QAEHHHHH@Z PROC			; MapClass::CheckWall, COMDAT
; _this$ = ecx

; 1015 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1016 : 	int Index = TERRAIN_INDEX_REPEAT(sx1,sy1);//sy1*256+sy1

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _sy1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _sx1$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?TERRAIN_INDEX_REPEAT@@YAHHH@Z ; TERRAIN_INDEX_REPEAT
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 1017 : 
; 1018 :     int nx1,ny1,d1,d2,len1,len2;
; 1019 :     int px1 = sx2-sx1;

  0001f	8b 45 10	 mov	 eax, DWORD PTR _sx2$[ebp]
  00022	2b 45 08	 sub	 eax, DWORD PTR _sx1$[ebp]
  00025	89 45 dc	 mov	 DWORD PTR _px1$[ebp], eax

; 1020 :     int py1 = sy2-sy1;

  00028	8b 45 14	 mov	 eax, DWORD PTR _sy2$[ebp]
  0002b	2b 45 0c	 sub	 eax, DWORD PTR _sy1$[ebp]
  0002e	89 45 d8	 mov	 DWORD PTR _py1$[ebp], eax

; 1021 :     if(px1 < 0  ) {px1 = -px1;nx1 =-1           ;} else nx1 = 1;

  00031	83 7d dc 00	 cmp	 DWORD PTR _px1$[ebp], 0
  00035	7d 11		 jge	 SHORT $LN5@CheckWall
  00037	8b 45 dc	 mov	 eax, DWORD PTR _px1$[ebp]
  0003a	f7 d8		 neg	 eax
  0003c	89 45 dc	 mov	 DWORD PTR _px1$[ebp], eax
  0003f	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _nx1$[ebp], -1
  00046	eb 07		 jmp	 SHORT $LN6@CheckWall
$LN5@CheckWall:
  00048	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _nx1$[ebp], 1
$LN6@CheckWall:

; 1022 :     if(py1 < 0  ) {py1 = -py1;ny1 =-TERRAIN_SIZE;} else ny1 = TERRAIN_SIZE;

  0004f	83 7d d8 00	 cmp	 DWORD PTR _py1$[ebp], 0
  00053	7d 11		 jge	 SHORT $LN7@CheckWall
  00055	8b 45 d8	 mov	 eax, DWORD PTR _py1$[ebp]
  00058	f7 d8		 neg	 eax
  0005a	89 45 d8	 mov	 DWORD PTR _py1$[ebp], eax
  0005d	c7 45 f0 00 ff
	ff ff		 mov	 DWORD PTR _ny1$[ebp], -256 ; ffffff00H
  00064	eb 07		 jmp	 SHORT $LN8@CheckWall
$LN7@CheckWall:
  00066	c7 45 f0 00 01
	00 00		 mov	 DWORD PTR _ny1$[ebp], 256 ; 00000100H
$LN8@CheckWall:

; 1023 :     if(px1 > py1) {len1 = px1;len2 = py1;d1 = ny1;d2 = nx1;}

  0006d	8b 45 dc	 mov	 eax, DWORD PTR _px1$[ebp]
  00070	3b 45 d8	 cmp	 eax, DWORD PTR _py1$[ebp]
  00073	7e 1a		 jle	 SHORT $LN9@CheckWall
  00075	8b 45 dc	 mov	 eax, DWORD PTR _px1$[ebp]
  00078	89 45 e4	 mov	 DWORD PTR _len1$[ebp], eax
  0007b	8b 45 d8	 mov	 eax, DWORD PTR _py1$[ebp]
  0007e	89 45 e0	 mov	 DWORD PTR _len2$[ebp], eax
  00081	8b 45 f0	 mov	 eax, DWORD PTR _ny1$[ebp]
  00084	89 45 ec	 mov	 DWORD PTR _d1$[ebp], eax
  00087	8b 45 f4	 mov	 eax, DWORD PTR _nx1$[ebp]
  0008a	89 45 e8	 mov	 DWORD PTR _d2$[ebp], eax
  0008d	eb 18		 jmp	 SHORT $LN10@CheckWall
$LN9@CheckWall:

; 1024 :     else          {len1 = py1;len2 = px1;d1 = nx1;d2 = ny1;}

  0008f	8b 45 d8	 mov	 eax, DWORD PTR _py1$[ebp]
  00092	89 45 e4	 mov	 DWORD PTR _len1$[ebp], eax
  00095	8b 45 dc	 mov	 eax, DWORD PTR _px1$[ebp]
  00098	89 45 e0	 mov	 DWORD PTR _len2$[ebp], eax
  0009b	8b 45 f4	 mov	 eax, DWORD PTR _nx1$[ebp]
  0009e	89 45 ec	 mov	 DWORD PTR _d1$[ebp], eax
  000a1	8b 45 f0	 mov	 eax, DWORD PTR _ny1$[ebp]
  000a4	89 45 e8	 mov	 DWORD PTR _d2$[ebp], eax
$LN10@CheckWall:

; 1025 : 
; 1026 : 	int   error = 0,count = 0;

  000a7	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _error$[ebp], 0
  000ae	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 1027 : 	float Shadow = 0.f;

  000b5	0f 57 c0	 xorps	 xmm0, xmm0
  000b8	f3 0f 11 45 cc	 movss	 DWORD PTR _Shadow$[ebp], xmm0
$LN4@CheckWall:

; 1028 :     do
; 1029 : 	{
; 1030 : 		if((m_attrbuf[Index]&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK) return 0;//벽

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c3	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  000c6	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000ca	83 e0 04	 and	 eax, 4
  000cd	74 04		 je	 SHORT $LN11@CheckWall
  000cf	33 c0		 xor	 eax, eax
  000d1	eb 47		 jmp	 SHORT $LN1@CheckWall
$LN11@CheckWall:

; 1031 : 		//if((m_attrbuf[Index]&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW) return 0;//땅뚤림
; 1032 : 		error += len2;

  000d3	8b 45 d4	 mov	 eax, DWORD PTR _error$[ebp]
  000d6	03 45 e0	 add	 eax, DWORD PTR _len2$[ebp]
  000d9	89 45 d4	 mov	 DWORD PTR _error$[ebp], eax

; 1033 : 		if(error > len1/2) 

  000dc	8b 45 e4	 mov	 eax, DWORD PTR _len1$[ebp]
  000df	99		 cdq
  000e0	2b c2		 sub	 eax, edx
  000e2	d1 f8		 sar	 eax, 1
  000e4	39 45 d4	 cmp	 DWORD PTR _error$[ebp], eax
  000e7	7e 12		 jle	 SHORT $LN12@CheckWall

; 1034 : 		{
; 1035 : 			Index += d1;

  000e9	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  000ec	03 45 ec	 add	 eax, DWORD PTR _d1$[ebp]
  000ef	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 1036 : 			error -= len1;

  000f2	8b 45 d4	 mov	 eax, DWORD PTR _error$[ebp]
  000f5	2b 45 e4	 sub	 eax, DWORD PTR _len1$[ebp]
  000f8	89 45 d4	 mov	 DWORD PTR _error$[ebp], eax
$LN12@CheckWall:

; 1037 : 		}
; 1038 : 		Index += d2;

  000fb	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  000fe	03 45 e8	 add	 eax, DWORD PTR _d2$[ebp]
  00101	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 1039 : 	} while(++count <= len1);

  00104	8b 45 d0	 mov	 eax, DWORD PTR _count$[ebp]
  00107	83 c0 01	 add	 eax, 1
  0010a	89 45 d0	 mov	 DWORD PTR _count$[ebp], eax
  0010d	8b 4d d0	 mov	 ecx, DWORD PTR _count$[ebp]
  00110	3b 4d e4	 cmp	 ecx, DWORD PTR _len1$[ebp]
  00113	7e a8		 jle	 SHORT $LN4@CheckWall

; 1040 : 	
; 1041 : 	return 1;

  00115	b8 01 00 00 00	 mov	 eax, 1
$LN1@CheckWall:

; 1042 : }

  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 10 00	 ret	 16			; 00000010H
?CheckWall@MapClass@@QAEHHHHH@Z ENDP			; MapClass::CheckWall
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?LoadMapAttr@MapClass@@QAEXPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
_MapNumber$ = 12					; size = 4
?LoadMapAttr@MapClass@@QAEXPADH@Z PROC			; MapClass::LoadMapAttr, COMDAT
; _this$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  : 	if( AttrLoad(filename) == FALSE ) 

  0000c	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?AttrLoad@MapClass@@QAEHPAD@Z ; MapClass::AttrLoad
  00018	85 c0		 test	 eax, eax
  0001a	75 19		 jne	 SHORT $LN2@LoadMapAtt

; 239  : 	{
; 240  : 		MsgBox(lMsg.Get(564));

  0001c	68 34 02 00 00	 push	 564			; 00000234H
  00021	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00032	83 c4 04	 add	 esp, 4
$LN2@LoadMapAtt:

; 241  : 	}
; 242  : 	thisMapNumber = MapNumber;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _MapNumber$[ebp]
  0003b	89 88 88 04 05
	00		 mov	 DWORD PTR [eax+328840], ecx

; 243  : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
?LoadMapAttr@MapClass@@QAEXPADH@Z ENDP			; MapClass::LoadMapAttr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?AttrLoad@MapClass@@QAEHPAD@Z
_TEXT	SEGMENT
_head$ = -9						; size = 1
_fp$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?AttrLoad@MapClass@@QAEHPAD@Z PROC			; MapClass::AttrLoad, COMDAT
; _this$ = ecx

; 838  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 839  : 	FILE *fp;
; 840  : 	BYTE  head;
; 841  : 	
; 842  : 	fp = fopen(filename, "rb");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00011	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _fopen
  0001a	83 c4 08	 add	 esp, 8
  0001d	89 45 f8	 mov	 DWORD PTR _fp$[ebp], eax

; 843  : 	
; 844  : 	if( fp == NULL ) 

  00020	83 7d f8 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00024	75 07		 jne	 SHORT $LN2@AttrLoad

; 845  : 	{ 
; 846  : 		return FALSE; 

  00026	33 c0		 xor	 eax, eax
  00028	e9 0c 01 00 00	 jmp	 $LN1@AttrLoad
$LN2@AttrLoad:

; 847  : 	}
; 848  : 
; 849  : #ifdef ENC_TILE_ATTR
; 850  : 	int iSize = 65539;
; 851  : 	BYTE byBuffer[65539];
; 852  : 	fread( byBuffer, iSize, 1, fp);
; 853  : 	BuxConvert( byBuffer, iSize);
; 854  : 	head = byBuffer[0];
; 855  : 	m_width = byBuffer[1];
; 856  : 	m_height = byBuffer[2];
; 857  : 
; 858  : 	if( (m_width > MAX_TERRAIN_SIZE_MASK ) || (m_height > MAX_TERRAIN_SIZE_MASK) ) {
; 859  : 		MsgBox(lMsg.Get(563));
; 860  : 		fclose(fp);
; 861  : 		return FALSE;
; 862  : 	}
; 863  : 	if( m_attrbuf != NULL ) 
; 864  : 	{
; 865  : 		GlobalFree(m_attrbuf);
; 866  : 		m_attrbuf = NULL;
; 867  : 	}
; 868  : 
; 869  : 	m_attrbuf = (LPBYTE)GlobalAlloc(GPTR, (MAX_TERRAIN_SIZE*MAX_TERRAIN_SIZE));
; 870  : 	memcpy( m_attrbuf, &byBuffer[3], TERRAIN_SIZE*TERRAIN_SIZE);
; 871  : 
; 872  : 	fclose(fp);
; 873  : 
; 874  : 	path->SetMapDimensions(MAX_TERRAIN_SIZE,MAX_TERRAIN_SIZE,m_attrbuf);
; 875  : #else
; 876  : 	fread(&head,     1, 1, fp);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _fp$[ebp]
  00030	50		 push	 eax
  00031	6a 01		 push	 1
  00033	6a 01		 push	 1
  00035	8d 4d f7	 lea	 ecx, DWORD PTR _head$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _fread
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 877  : 	fread(&m_width,  1, 1, fp);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _fp$[ebp]
  00044	50		 push	 eax
  00045	6a 01		 push	 1
  00047	6a 01		 push	 1
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 c1 14	 add	 ecx, 20			; 00000014H
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _fread
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 878  : 	fread(&m_height, 1, 1, fp);

  00058	8b 45 f8	 mov	 eax, DWORD PTR _fp$[ebp]
  0005b	50		 push	 eax
  0005c	6a 01		 push	 1
  0005e	6a 01		 push	 1
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	83 c1 18	 add	 ecx, 24			; 00000018H
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 _fread
  0006c	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 
; 880  : 	if( (m_width > MAX_TERRAIN_SIZE_MASK ) || (m_height > MAX_TERRAIN_SIZE_MASK) ) {

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	81 78 14 ff 00
	00 00		 cmp	 DWORD PTR [eax+20], 255	; 000000ffH
  00079	7f 0c		 jg	 SHORT $LN4@AttrLoad
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	81 78 18 ff 00
	00 00		 cmp	 DWORD PTR [eax+24], 255	; 000000ffH
  00085	7e 2c		 jle	 SHORT $LN3@AttrLoad
$LN4@AttrLoad:

; 881  : 		MsgBox(lMsg.Get(563));

  00087	68 33 02 00 00	 push	 563			; 00000233H
  0008c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0009d	83 c4 04	 add	 esp, 4

; 882  : 		fclose(fp);

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _fp$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _fclose
  000a9	83 c4 04	 add	 esp, 4

; 883  : 		return FALSE;

  000ac	33 c0		 xor	 eax, eax
  000ae	e9 86 00 00 00	 jmp	 $LN1@AttrLoad
$LN3@AttrLoad:

; 884  : 	}
; 885  : 	if( m_attrbuf != NULL ) 

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000ba	74 17		 je	 SHORT $LN5@AttrLoad

; 886  : 	{
; 887  : 		GlobalFree(m_attrbuf);

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000c2	51		 push	 ecx
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 888  : 		m_attrbuf = NULL;

  000c9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN5@AttrLoad:

; 889  : 	}
; 890  : 	m_attrbuf = (LPBYTE)GlobalAlloc(GPTR, (MAX_TERRAIN_SIZE*MAX_TERRAIN_SIZE));

  000d3	68 00 00 01 00	 push	 65536			; 00010000H
  000d8	6a 40		 push	 64			; 00000040H
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 891  : 	if(m_attrbuf != NULL)

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000ed	74 39		 je	 SHORT $LN6@AttrLoad

; 892  : 	{
; 893  : 		fread(m_attrbuf, MAX_TERRAIN_SIZE, MAX_TERRAIN_SIZE, fp);

  000ef	8b 45 f8	 mov	 eax, DWORD PTR _fp$[ebp]
  000f2	50		 push	 eax
  000f3	68 00 01 00 00	 push	 256			; 00000100H
  000f8	68 00 01 00 00	 push	 256			; 00000100H
  000fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 _fread
  00109	83 c4 10	 add	 esp, 16			; 00000010H

; 894  : 		path->SetMapDimensions(MAX_TERRAIN_SIZE,MAX_TERRAIN_SIZE,m_attrbuf);

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00112	51		 push	 ecx
  00113	68 00 01 00 00	 push	 256			; 00000100H
  00118	68 00 01 00 00	 push	 256			; 00000100H
  0011d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00120	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00123	e8 00 00 00 00	 call	 ?SetMapDimensions@PATH@@QAEXHHPAE@Z ; PATH::SetMapDimensions
$LN6@AttrLoad:

; 895  : 	}
; 896  : 	
; 897  : 	fclose(fp);

  00128	8b 45 f8	 mov	 eax, DWORD PTR _fp$[ebp]
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 _fclose
  00131	83 c4 04	 add	 esp, 4

; 898  : #endif
; 899  : 	return TRUE;

  00134	b8 01 00 00 00	 mov	 eax, 1
$LN1@AttrLoad:

; 900  : }

  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 04 00	 ret	 4
?AttrLoad@MapClass@@QAEHPAD@Z ENDP			; MapClass::AttrLoad
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?SearchStandAttr@MapClass@@QAEXAAF0@Z
_TEXT	SEGMENT
tv74 = -92						; size = 4
_subx$ = -24						; size = 4
_tindex$ = -20						; size = 4
_ty$ = -16						; size = 4
_tx$ = -12						; size = 4
_scount$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SearchStandAttr@MapClass@@QAEXAAF0@Z PROC		; MapClass::SearchStandAttr, COMDAT
; _this$ = ecx

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 931  : 	int scount=10;

  0000c	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _scount$[ebp], 10 ; 0000000aH

; 932  : 	int tx, ty, tindex;
; 933  : 	int subx=1;

  00013	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _subx$[ebp], 1

; 934  : 
; 935  : 	tx = x;

  0001a	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0001d	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00020	89 4d f4	 mov	 DWORD PTR _tx$[ebp], ecx

; 936  : 	ty = y;

  00023	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00026	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00029	89 4d f0	 mov	 DWORD PTR _ty$[ebp], ecx

; 937  : 	tindex = y*MAX_TERRAIN_SIZE;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0002f	0f bf 08	 movsx	 ecx, WORD PTR [eax]
  00032	c1 e1 08	 shl	 ecx, 8
  00035	89 4d ec	 mov	 DWORD PTR _tindex$[ebp], ecx

; 938  : 
; 939  : 	if( (tx-10) < 0 ) subx = 1;

  00038	8b 45 f4	 mov	 eax, DWORD PTR _tx$[ebp]
  0003b	83 e8 0a	 sub	 eax, 10			; 0000000aH
  0003e	79 07		 jns	 SHORT $LN4@SearchStan
  00040	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _subx$[ebp], 1
$LN4@SearchStan:

; 940  : 	if( (tx+10) > MAX_TERRAIN_SIZE_MASK ) subx = -1;

  00047	8b 45 f4	 mov	 eax, DWORD PTR _tx$[ebp]
  0004a	83 c0 0a	 add	 eax, 10			; 0000000aH
  0004d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00052	7e 07		 jle	 SHORT $LN2@SearchStan
  00054	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _subx$[ebp], -1
$LN2@SearchStan:

; 941  : 
; 942  : 	while(scount--)

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _scount$[ebp]
  0005e	89 45 a4	 mov	 DWORD PTR tv74[ebp], eax
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _scount$[ebp]
  00064	83 e9 01	 sub	 ecx, 1
  00067	89 4d f8	 mov	 DWORD PTR _scount$[ebp], ecx
  0006a	83 7d a4 00	 cmp	 DWORD PTR tv74[ebp], 0
  0006e	74 60		 je	 SHORT $LN1@SearchStan

; 943  : 	{
; 944  : 		if( ((m_attrbuf[tindex+tx]&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) && 
; 945  : 			((m_attrbuf[tindex+tx]&MAP_ATTR_STAND) != MAP_ATTR_STAND) &&

  00070	8b 45 ec	 mov	 eax, DWORD PTR _tindex$[ebp]
  00073	03 45 f4	 add	 eax, DWORD PTR _tx$[ebp]
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0007c	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  00080	83 e0 04	 and	 eax, 4
  00083	75 40		 jne	 SHORT $LN6@SearchStan
  00085	8b 45 ec	 mov	 eax, DWORD PTR _tindex$[ebp]
  00088	03 45 f4	 add	 eax, DWORD PTR _tx$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00091	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  00095	83 e0 02	 and	 eax, 2
  00098	75 2b		 jne	 SHORT $LN6@SearchStan
  0009a	8b 45 ec	 mov	 eax, DWORD PTR _tindex$[ebp]
  0009d	03 45 f4	 add	 eax, DWORD PTR _tx$[ebp]
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000a6	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  000aa	83 e0 08	 and	 eax, 8
  000ad	75 16		 jne	 SHORT $LN6@SearchStan

; 946  : 			((m_attrbuf[tindex+tx]&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW)) // 비어있다면..
; 947  : 		{
; 948  : 			x = tx;

  000af	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000b2	66 8b 4d f4	 mov	 cx, WORD PTR _tx$[ebp]
  000b6	66 89 08	 mov	 WORD PTR [eax], cx

; 949  : 			y = ty;

  000b9	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  000bc	66 8b 4d f0	 mov	 cx, WORD PTR _ty$[ebp]
  000c0	66 89 08	 mov	 WORD PTR [eax], cx

; 950  : 			return;

  000c3	eb 0b		 jmp	 SHORT $LN1@SearchStan
$LN6@SearchStan:

; 951  : 		}
; 952  : 		tx += subx;

  000c5	8b 45 f4	 mov	 eax, DWORD PTR _tx$[ebp]
  000c8	03 45 e8	 add	 eax, DWORD PTR _subx$[ebp]
  000cb	89 45 f4	 mov	 DWORD PTR _tx$[ebp], eax

; 953  : 	}

  000ce	eb 8b		 jmp	 SHORT $LN2@SearchStan
$LN1@SearchStan:

; 954  : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 08 00	 ret	 8
?SearchStandAttr@MapClass@@QAEXAAF0@Z ENDP		; MapClass::SearchStandAttr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?GetRandomLengthPos@MapClass@@QAEXAAF0H@Z
_TEXT	SEGMENT
tv68 = -92						; size = 4
_maxlen$ = -24						; size = 4
_attr$ = -17						; size = 1
_py$ = -16						; size = 4
_px$ = -12						; size = 4
_lc$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_length$ = 16						; size = 4
?GetRandomLengthPos@MapClass@@QAEXAAF0H@Z PROC		; MapClass::GetRandomLengthPos, COMDAT
; _this$ = ecx

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : 	int lc=10;

  0000c	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _lc$[ebp], 10	; 0000000aH

; 147  : 	int px, py;
; 148  : 	BYTE attr;
; 149  : 	int maxlen;
; 150  : 	
; 151  : 	if( length < 1 ) length = 1;

  00013	83 7d 10 01	 cmp	 DWORD PTR _length$[ebp], 1
  00017	7d 07		 jge	 SHORT $LN4@GetRandomL
  00019	c7 45 10 01 00
	00 00		 mov	 DWORD PTR _length$[ebp], 1
$LN4@GetRandomL:

; 152  : 	maxlen = length*2;

  00020	8b 45 10	 mov	 eax, DWORD PTR _length$[ebp]
  00023	d1 e0		 shl	 eax, 1
  00025	89 45 e8	 mov	 DWORD PTR _maxlen$[ebp], eax
$LN2@GetRandomL:

; 153  : 
; 154  : 	while(lc--)

  00028	8b 45 f8	 mov	 eax, DWORD PTR _lc$[ebp]
  0002b	89 45 a4	 mov	 DWORD PTR tv68[ebp], eax
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _lc$[ebp]
  00031	83 e9 01	 sub	 ecx, 1
  00034	89 4d f8	 mov	 DWORD PTR _lc$[ebp], ecx
  00037	83 7d a4 00	 cmp	 DWORD PTR tv68[ebp], 0
  0003b	74 6b		 je	 SHORT $LN1@GetRandomL

; 155  : 	{
; 156  : 		px = (x-length)+(rand()%maxlen);

  0003d	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00040	0f bf 30	 movsx	 esi, WORD PTR [eax]
  00043	2b 75 10	 sub	 esi, DWORD PTR _length$[ebp]
  00046	e8 00 00 00 00	 call	 _rand
  0004b	99		 cdq
  0004c	f7 7d e8	 idiv	 DWORD PTR _maxlen$[ebp]
  0004f	03 f2		 add	 esi, edx
  00051	89 75 f4	 mov	 DWORD PTR _px$[ebp], esi

; 157  : 		py = (y-length)+(rand()%maxlen);

  00054	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00057	0f bf 30	 movsx	 esi, WORD PTR [eax]
  0005a	2b 75 10	 sub	 esi, DWORD PTR _length$[ebp]
  0005d	e8 00 00 00 00	 call	 _rand
  00062	99		 cdq
  00063	f7 7d e8	 idiv	 DWORD PTR _maxlen$[ebp]
  00066	03 f2		 add	 esi, edx
  00068	89 75 f0	 mov	 DWORD PTR _py$[ebp], esi

; 158  : 		
; 159  : 		attr = GetAttr(px, py);

  0006b	8b 45 f0	 mov	 eax, DWORD PTR _py$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _px$[ebp]
  00072	51		 push	 ecx
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0007b	88 45 ef	 mov	 BYTE PTR _attr$[ebp], al

; 160  : 		if( ((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) && 

  0007e	0f b6 45 ef	 movzx	 eax, BYTE PTR _attr$[ebp]
  00082	83 e0 04	 and	 eax, 4
  00085	75 1f		 jne	 SHORT $LN5@GetRandomL
  00087	0f b6 45 ef	 movzx	 eax, BYTE PTR _attr$[ebp]
  0008b	83 e0 08	 and	 eax, 8
  0008e	75 16		 jne	 SHORT $LN5@GetRandomL

; 161  : 			((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW)) 
; 162  : 		{
; 163  : 			x = px;

  00090	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00093	66 8b 4d f4	 mov	 cx, WORD PTR _px$[ebp]
  00097	66 89 08	 mov	 WORD PTR [eax], cx

; 164  : 			y = py;

  0009a	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0009d	66 8b 4d f0	 mov	 cx, WORD PTR _py$[ebp]
  000a1	66 89 08	 mov	 WORD PTR [eax], cx

; 165  : 			return;

  000a4	eb 02		 jmp	 SHORT $LN1@GetRandomL
$LN5@GetRandomL:

; 166  : 		}
; 167  : 	}

  000a6	eb 80		 jmp	 SHORT $LN2@GetRandomL
$LN1@GetRandomL:

; 168  : }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 0c 00	 ret	 12			; 0000000cH
?GetRandomLengthPos@MapClass@@QAEXAAF0H@Z ENDP		; MapClass::GetRandomLengthPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?GetMapPos@MapClass@@QAEXFAAF0@Z
_TEXT	SEGMENT
tv73 = -124						; size = 4
_h$ = -56						; size = 4
_w$ = -52						; size = 4
_attr$ = -45						; size = 1
_loopcount$ = -44					; size = 4
_levelpos$ = -40					; size = 4
_y$ = -36						; size = 4
_x$ = -32						; size = 4
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_Map$ = 8						; size = 2
_ox$ = 12						; size = 4
_oy$ = 16						; size = 4
?GetMapPos@MapClass@@QAEXFAAF0@Z PROC			; MapClass::GetMapPos, COMDAT
; _this$ = ecx

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetMapPos@MapClass@@QAEXFAAF0@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 c4 94	 add	 esp, -108		; ffffff94H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 173  : 	if( Map != 8 )

  00036	0f bf 45 08	 movsx	 eax, WORD PTR _Map$[ebp]
  0003a	83 f8 08	 cmp	 eax, 8
  0003d	74 18		 je	 SHORT $LN4@GetMapPos

; 174  : 	{
; 175  : #ifdef ADD_NEW_MAP_AIDA_20050617
; 176  : 		if( Map == MAP_INDEX_AIDA )
; 177  : 		{
; 178  : 			Map = MAP_INDEX_AIDA;
; 179  : 		}
; 180  : 		else
; 181  : #endif
; 182  : 
; 183  : #ifdef ADD_NEW_MAP_CRYWOLF_FIRSTZONE_20050414
; 184  : 		if( Map == MAP_INDEX_CRYWOLF_FIRSTZONE )
; 185  : 		{
; 186  : 			Map = MAP_INDEX_CRYWOLF_FIRSTZONE;
; 187  : 		}
; 188  : 		else
; 189  : #endif
; 190  : 
; 191  : #ifdef ADD_SEASON_3_NEW_MAP_20070910
; 192  : 		if( Map == MAP_INDEX_ELBELAND )
; 193  : 		{
; 194  : 			Map = MAP_INDEX_ELBELAND;
; 195  : 		}
; 196  : 		else
; 197  : #endif
; 198  : 		if( Map > 4 && Map != 7 ) 

  0003f	0f bf 45 08	 movsx	 eax, WORD PTR _Map$[ebp]
  00043	83 f8 04	 cmp	 eax, 4
  00046	7e 0f		 jle	 SHORT $LN4@GetMapPos
  00048	0f bf 45 08	 movsx	 eax, WORD PTR _Map$[ebp]
  0004c	83 f8 07	 cmp	 eax, 7
  0004f	74 06		 je	 SHORT $LN4@GetMapPos

; 199  : 			Map = 0;

  00051	33 c0		 xor	 eax, eax
  00053	66 89 45 08	 mov	 WORD PTR _Map$[ebp], ax
$LN4@GetMapPos:

; 200  : 
; 201  : 	}
; 202  : 
; 203  : 	int x, y, levelpos=Map;

  00057	0f bf 45 08	 movsx	 eax, WORD PTR _Map$[ebp]
  0005b	89 45 d8	 mov	 DWORD PTR _levelpos$[ebp], eax

; 204  : 	int loopcount=50;

  0005e	c7 45 d4 32 00
	00 00		 mov	 DWORD PTR _loopcount$[ebp], 50 ; 00000032H
$LN2@GetMapPos:

; 205  : 	BYTE attr;
; 206  : 	int w, h;
; 207  : 
; 208  : 	while( loopcount-- )

  00065	8b 45 d4	 mov	 eax, DWORD PTR _loopcount$[ebp]
  00068	89 45 84	 mov	 DWORD PTR tv73[ebp], eax
  0006b	8b 4d d4	 mov	 ecx, DWORD PTR _loopcount$[ebp]
  0006e	83 e9 01	 sub	 ecx, 1
  00071	89 4d d4	 mov	 DWORD PTR _loopcount$[ebp], ecx
  00074	83 7d 84 00	 cmp	 DWORD PTR tv73[ebp], 0
  00078	0f 84 0a 01 00
	00		 je	 $LN3@GetMapPos

; 209  : 	{
; 210  : 		w = gRegenRect[levelpos].right-gRegenRect[levelpos].left;

  0007e	8b 45 d8	 mov	 eax, DWORD PTR _levelpos$[ebp]
  00081	c1 e0 04	 shl	 eax, 4
  00084	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	8b 91 84 04 05
	00		 mov	 edx, DWORD PTR [ecx+328836]
  0008d	8b 4d d8	 mov	 ecx, DWORD PTR _levelpos$[ebp]
  00090	c1 e1 04	 shl	 ecx, 4
  00093	8b 75 e4	 mov	 esi, DWORD PTR _this$[ebp]
  00096	8b b6 84 04 05
	00		 mov	 esi, DWORD PTR [esi+328836]
  0009c	8b 54 02 08	 mov	 edx, DWORD PTR [edx+eax+8]
  000a0	2b 14 0e	 sub	 edx, DWORD PTR [esi+ecx]
  000a3	89 55 cc	 mov	 DWORD PTR _w$[ebp], edx

; 211  : 		h = gRegenRect[levelpos].bottom-gRegenRect[levelpos].top;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR _levelpos$[ebp]
  000a9	c1 e0 04	 shl	 eax, 4
  000ac	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	8b 91 84 04 05
	00		 mov	 edx, DWORD PTR [ecx+328836]
  000b5	8b 4d d8	 mov	 ecx, DWORD PTR _levelpos$[ebp]
  000b8	c1 e1 04	 shl	 ecx, 4
  000bb	8b 75 e4	 mov	 esi, DWORD PTR _this$[ebp]
  000be	8b b6 84 04 05
	00		 mov	 esi, DWORD PTR [esi+328836]
  000c4	8b 54 02 0c	 mov	 edx, DWORD PTR [edx+eax+12]
  000c8	2b 54 0e 04	 sub	 edx, DWORD PTR [esi+ecx+4]
  000cc	89 55 c8	 mov	 DWORD PTR _h$[ebp], edx

; 212  : 		__try

  000cf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 213  : 		{
; 214  : 			x = (short)(gRegenRect[levelpos].left+(rand()%w));

  000d6	8b 75 d8	 mov	 esi, DWORD PTR _levelpos$[ebp]
  000d9	c1 e6 04	 shl	 esi, 4
  000dc	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b b8 84 04 05
	00		 mov	 edi, DWORD PTR [eax+328836]
  000e5	e8 00 00 00 00	 call	 _rand
  000ea	8b 4d cc	 mov	 ecx, DWORD PTR _w$[ebp]
  000ed	99		 cdq
  000ee	f7 f9		 idiv	 ecx
  000f0	8b 04 37	 mov	 eax, DWORD PTR [edi+esi]
  000f3	03 c2		 add	 eax, edx
  000f5	0f bf c8	 movsx	 ecx, ax
  000f8	89 4d e0	 mov	 DWORD PTR _x$[ebp], ecx

; 215  : 			y = (short)(gRegenRect[levelpos].top +(rand()%h));

  000fb	8b 75 d8	 mov	 esi, DWORD PTR _levelpos$[ebp]
  000fe	c1 e6 04	 shl	 esi, 4
  00101	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00104	8b b8 84 04 05
	00		 mov	 edi, DWORD PTR [eax+328836]
  0010a	e8 00 00 00 00	 call	 _rand
  0010f	8b 4d c8	 mov	 ecx, DWORD PTR _h$[ebp]
  00112	99		 cdq
  00113	f7 f9		 idiv	 ecx
  00115	8b 44 37 04	 mov	 eax, DWORD PTR [edi+esi+4]
  00119	03 c2		 add	 eax, edx
  0011b	0f bf c8	 movsx	 ecx, ax
  0011e	89 4d dc	 mov	 DWORD PTR _y$[ebp], ecx

; 216  : 		}

  00121	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00128	eb 1e		 jmp	 SHORT $LN13@GetMapPos
$LN10@GetMapPos:
$LN15@GetMapPos:

; 217  : 		__except(w=1, h=1, EXCEPTION_EXECUTE_HANDLER )

  0012a	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _w$[ebp], 1
  00131	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _h$[ebp], 1
  00138	b8 01 00 00 00	 mov	 eax, 1
$LN12@GetMapPos:
$LN14@GetMapPos:
  0013d	c3		 ret	 0
$LN11@GetMapPos:
  0013e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 216  : 		}

  00141	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN13@GetMapPos:

; 218  : 		{
; 219  : 		}	
; 220  : 
; 221  : 		attr = GetAttr(x, y);

  00148	8b 45 dc	 mov	 eax, DWORD PTR _y$[ebp]
  0014b	50		 push	 eax
  0014c	8b 4d e0	 mov	 ecx, DWORD PTR _x$[ebp]
  0014f	51		 push	 ecx
  00150	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00158	88 45 d3	 mov	 BYTE PTR _attr$[ebp], al

; 222  : 		if( ((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) && 

  0015b	0f b6 45 d3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0015f	83 e0 04	 and	 eax, 4
  00162	75 1f		 jne	 SHORT $LN7@GetMapPos
  00164	0f b6 45 d3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00168	83 e0 08	 and	 eax, 8
  0016b	75 16		 jne	 SHORT $LN7@GetMapPos

; 223  : 			//((attr&MAP_ATTR_STAND) != MAP_ATTR_STAND) &&
; 224  : 			((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW)) 
; 225  : 		{
; 226  : 			ox = x;

  0016d	8b 45 0c	 mov	 eax, DWORD PTR _ox$[ebp]
  00170	66 8b 4d e0	 mov	 cx, WORD PTR _x$[ebp]
  00174	66 89 08	 mov	 WORD PTR [eax], cx

; 227  : 			oy = y;

  00177	8b 45 10	 mov	 eax, DWORD PTR _oy$[ebp]
  0017a	66 8b 4d dc	 mov	 cx, WORD PTR _y$[ebp]
  0017e	66 89 08	 mov	 WORD PTR [eax], cx

; 228  : 			return;

  00181	eb 58		 jmp	 SHORT $LN9@GetMapPos
$LN7@GetMapPos:

; 229  : 		}
; 230  : 	}

  00183	e9 dd fe ff ff	 jmp	 $LN2@GetMapPos
$LN3@GetMapPos:

; 231  : 	LogAdd(lMsg.Get(460),__FILE__, __LINE__);

  00188	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetMapPos@MapClass@@QAEXFAAF0@Z@4JA
  0018d	83 c0 3b	 add	 eax, 59			; 0000003bH
  00190	50		 push	 eax
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00196	68 cc 01 00 00	 push	 460			; 000001ccH
  0019b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001a6	50		 push	 eax
  001a7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  : 	x = gRegenRect[levelpos].left;

  001b0	8b 45 d8	 mov	 eax, DWORD PTR _levelpos$[ebp]
  001b3	c1 e0 04	 shl	 eax, 4
  001b6	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b9	8b 91 84 04 05
	00		 mov	 edx, DWORD PTR [ecx+328836]
  001bf	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  001c2	89 45 e0	 mov	 DWORD PTR _x$[ebp], eax

; 233  : 	y = gRegenRect[levelpos].top;

  001c5	8b 45 d8	 mov	 eax, DWORD PTR _levelpos$[ebp]
  001c8	c1 e0 04	 shl	 eax, 4
  001cb	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ce	8b 91 84 04 05
	00		 mov	 edx, DWORD PTR [ecx+328836]
  001d4	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  001d8	89 45 dc	 mov	 DWORD PTR _y$[ebp], eax
$LN9@GetMapPos:

; 234  : }

  001db	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  001de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e5	59		 pop	 ecx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c2 0c 00	 ret	 12			; 0000000cH
?GetMapPos@MapClass@@QAEXFAAF0@Z ENDP			; MapClass::GetMapPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?GetLevelPos@MapClass@@QAEXFAAF0@Z
_TEXT	SEGMENT
tv66 = -124						; size = 4
_h$ = -56						; size = 4
_w$ = -52						; size = 4
_attr$ = -45						; size = 1
_loopcount$ = -44					; size = 4
_levelpos$ = -40					; size = 4
_y$ = -36						; size = 4
_x$ = -32						; size = 4
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_level$ = 8						; size = 2
_ox$ = 12						; size = 4
_oy$ = 16						; size = 4
?GetLevelPos@MapClass@@QAEXFAAF0@Z PROC			; MapClass::GetLevelPos, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetLevelPos@MapClass@@QAEXFAAF0@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 c4 94	 add	 esp, -108		; ffffff94H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 102  : 	int x, y, levelpos=0;

  00036	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _levelpos$[ebp], 0

; 103  : 	int loopcount=50;

  0003d	c7 45 d4 32 00
	00 00		 mov	 DWORD PTR _loopcount$[ebp], 50 ; 00000032H
$LN2@GetLevelPo:

; 104  : 	BYTE attr;
; 105  : 	int w, h;
; 106  : 	
; 107  : 	/*
; 108  : 	if( level > 0 && level <= 5 ) levelpos = 0;
; 109  : 	else if( level > 5 && level <= 10 ) levelpos = 1;
; 110  : 	else if( level > 10 && level <= 15 ) levelpos = 2;
; 111  : 	else levelpos = 3;
; 112  : 	*/
; 113  : 	while( loopcount-- )

  00044	8b 45 d4	 mov	 eax, DWORD PTR _loopcount$[ebp]
  00047	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  0004a	8b 4d d4	 mov	 ecx, DWORD PTR _loopcount$[ebp]
  0004d	83 e9 01	 sub	 ecx, 1
  00050	89 4d d4	 mov	 DWORD PTR _loopcount$[ebp], ecx
  00053	83 7d 84 00	 cmp	 DWORD PTR tv66[ebp], 0
  00057	0f 84 0a 01 00
	00		 je	 $LN3@GetLevelPo

; 114  : 	{
; 115  : 		w = gRegenRect[levelpos].right-gRegenRect[levelpos].left;

  0005d	8b 45 d8	 mov	 eax, DWORD PTR _levelpos$[ebp]
  00060	c1 e0 04	 shl	 eax, 4
  00063	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 91 84 04 05
	00		 mov	 edx, DWORD PTR [ecx+328836]
  0006c	8b 4d d8	 mov	 ecx, DWORD PTR _levelpos$[ebp]
  0006f	c1 e1 04	 shl	 ecx, 4
  00072	8b 75 e4	 mov	 esi, DWORD PTR _this$[ebp]
  00075	8b b6 84 04 05
	00		 mov	 esi, DWORD PTR [esi+328836]
  0007b	8b 54 02 08	 mov	 edx, DWORD PTR [edx+eax+8]
  0007f	2b 14 0e	 sub	 edx, DWORD PTR [esi+ecx]
  00082	89 55 cc	 mov	 DWORD PTR _w$[ebp], edx

; 116  : 		h = gRegenRect[levelpos].bottom-gRegenRect[levelpos].top;

  00085	8b 45 d8	 mov	 eax, DWORD PTR _levelpos$[ebp]
  00088	c1 e0 04	 shl	 eax, 4
  0008b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8b 91 84 04 05
	00		 mov	 edx, DWORD PTR [ecx+328836]
  00094	8b 4d d8	 mov	 ecx, DWORD PTR _levelpos$[ebp]
  00097	c1 e1 04	 shl	 ecx, 4
  0009a	8b 75 e4	 mov	 esi, DWORD PTR _this$[ebp]
  0009d	8b b6 84 04 05
	00		 mov	 esi, DWORD PTR [esi+328836]
  000a3	8b 54 02 0c	 mov	 edx, DWORD PTR [edx+eax+12]
  000a7	2b 54 0e 04	 sub	 edx, DWORD PTR [esi+ecx+4]
  000ab	89 55 c8	 mov	 DWORD PTR _h$[ebp], edx

; 117  : 		
; 118  : 		__try

  000ae	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 119  : 		{
; 120  : 			x = (short)(gRegenRect[levelpos].left+(rand()%w));

  000b5	8b 75 d8	 mov	 esi, DWORD PTR _levelpos$[ebp]
  000b8	c1 e6 04	 shl	 esi, 4
  000bb	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b b8 84 04 05
	00		 mov	 edi, DWORD PTR [eax+328836]
  000c4	e8 00 00 00 00	 call	 _rand
  000c9	8b 4d cc	 mov	 ecx, DWORD PTR _w$[ebp]
  000cc	99		 cdq
  000cd	f7 f9		 idiv	 ecx
  000cf	8b 04 37	 mov	 eax, DWORD PTR [edi+esi]
  000d2	03 c2		 add	 eax, edx
  000d4	0f bf c8	 movsx	 ecx, ax
  000d7	89 4d e0	 mov	 DWORD PTR _x$[ebp], ecx

; 121  : 			y = (short)(gRegenRect[levelpos].top +(rand()%h));

  000da	8b 75 d8	 mov	 esi, DWORD PTR _levelpos$[ebp]
  000dd	c1 e6 04	 shl	 esi, 4
  000e0	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b b8 84 04 05
	00		 mov	 edi, DWORD PTR [eax+328836]
  000e9	e8 00 00 00 00	 call	 _rand
  000ee	8b 4d c8	 mov	 ecx, DWORD PTR _h$[ebp]
  000f1	99		 cdq
  000f2	f7 f9		 idiv	 ecx
  000f4	8b 44 37 04	 mov	 eax, DWORD PTR [edi+esi+4]
  000f8	03 c2		 add	 eax, edx
  000fa	0f bf c8	 movsx	 ecx, ax
  000fd	89 4d dc	 mov	 DWORD PTR _y$[ebp], ecx

; 122  : 		}

  00100	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00107	eb 1e		 jmp	 SHORT $LN11@GetLevelPo
$LN8@GetLevelPo:
$LN13@GetLevelPo:

; 123  : 		__except( w=1, h=1, EXCEPTION_EXECUTE_HANDLER )

  00109	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _w$[ebp], 1
  00110	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _h$[ebp], 1
  00117	b8 01 00 00 00	 mov	 eax, 1
$LN10@GetLevelPo:
$LN12@GetLevelPo:
  0011c	c3		 ret	 0
$LN9@GetLevelPo:
  0011d	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 122  : 		}

  00120	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN11@GetLevelPo:

; 124  : 		{
; 125  : 		}
; 126  : 		
; 127  : 		attr = GetAttr(x, y);

  00127	8b 45 dc	 mov	 eax, DWORD PTR _y$[ebp]
  0012a	50		 push	 eax
  0012b	8b 4d e0	 mov	 ecx, DWORD PTR _x$[ebp]
  0012e	51		 push	 ecx
  0012f	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00132	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00137	88 45 d3	 mov	 BYTE PTR _attr$[ebp], al

; 128  : 		if( ((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) && 

  0013a	0f b6 45 d3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0013e	83 e0 04	 and	 eax, 4
  00141	75 1f		 jne	 SHORT $LN5@GetLevelPo
  00143	0f b6 45 d3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00147	83 e0 08	 and	 eax, 8
  0014a	75 16		 jne	 SHORT $LN5@GetLevelPo

; 129  : 			//((attr&MAP_ATTR_STAND) != MAP_ATTR_STAND) &&
; 130  : 			((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW)) 
; 131  : 		{
; 132  : 			ox = x;

  0014c	8b 45 0c	 mov	 eax, DWORD PTR _ox$[ebp]
  0014f	66 8b 4d e0	 mov	 cx, WORD PTR _x$[ebp]
  00153	66 89 08	 mov	 WORD PTR [eax], cx

; 133  : 			oy = y;

  00156	8b 45 10	 mov	 eax, DWORD PTR _oy$[ebp]
  00159	66 8b 4d dc	 mov	 cx, WORD PTR _y$[ebp]
  0015d	66 89 08	 mov	 WORD PTR [eax], cx

; 134  : 			return;

  00160	eb 58		 jmp	 SHORT $LN7@GetLevelPo
$LN5@GetLevelPo:

; 135  : 		}
; 136  : 	}

  00162	e9 dd fe ff ff	 jmp	 $LN2@GetLevelPo
$LN3@GetLevelPo:

; 137  : 	LogAdd(lMsg.Get(460),__FILE__, __LINE__);

  00167	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetLevelPos@MapClass@@QAEXFAAF0@Z@4JA
  0016c	83 c0 24	 add	 eax, 36			; 00000024H
  0016f	50		 push	 eax
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GIHCNNAK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00175	68 cc 01 00 00	 push	 460			; 000001ccH
  0017a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00185	50		 push	 eax
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 138  : 	x = gRegenRect[levelpos].left;

  0018f	8b 45 d8	 mov	 eax, DWORD PTR _levelpos$[ebp]
  00192	c1 e0 04	 shl	 eax, 4
  00195	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	8b 91 84 04 05
	00		 mov	 edx, DWORD PTR [ecx+328836]
  0019e	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  001a1	89 45 e0	 mov	 DWORD PTR _x$[ebp], eax

; 139  : 	y = gRegenRect[levelpos].top;

  001a4	8b 45 d8	 mov	 eax, DWORD PTR _levelpos$[ebp]
  001a7	c1 e0 04	 shl	 eax, 4
  001aa	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ad	8b 91 84 04 05
	00		 mov	 edx, DWORD PTR [ecx+328836]
  001b3	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  001b7	89 45 dc	 mov	 DWORD PTR _y$[ebp], eax
$LN7@GetLevelPo:

; 140  : }

  001ba	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  001bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c4	59		 pop	 ecx
  001c5	5f		 pop	 edi
  001c6	5e		 pop	 esi
  001c7	5b		 pop	 ebx
  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c2 0c 00	 ret	 12			; 0000000cH
?GetLevelPos@MapClass@@QAEXFAAF0@Z ENDP			; MapClass::GetLevelPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?SaveItemInfo@MapClass@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SaveItemInfo@MapClass@@QAEXXZ PROC			; MapClass::SaveItemInfo, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 311  : 	/*
; 312  : 	FILE *fp;
; 313  : 	int item_type, count=0;
; 314  : 	
; 315  : 	fp = fopen("iteminfo.txt", "w");
; 316  : 	if( fp == NULL ) 
; 317  : 	{
; 318  : 		MsgBox("File create error %s %d", __FILE__, __LINE__);
; 319  : 		return;
; 320  : 	}
; 321  : 	//int i=0;
; 322  : 	for( int i=0; i<15; i++)
; 323  : 	{
; 324  : 		if( i== 0)
; 325  : 		{
; 326  : 			fprintf(fp, "               이름 : 최소데미지,최대데미지,내구력,요구힘,요구방어력\n");
; 327  : 		}
; 328  : 		else if( i == 6 )
; 329  : 		{
; 330  : 			fprintf(fp, "\n               이름 : 방어율,내구력,요구힘,요구방어력\n");
; 331  : 		}
; 332  : 		else if( i == 7 )
; 333  : 		{
; 334  : 			fprintf(fp, "\n               이름 : 방어력,마법방어력,내구력,요구힘,요구방어력\n");
; 335  : 		}
; 336  : 		
; 337  : 		for( int n=0; n<15; n++, count++)
; 338  : 		{
; 339  :  		    item_type = ItemGetNumberMake( i, n);
; 340  : 			if( item_type >= 0 ) 
; 341  : 			{			
; 342  : 				m_cItem[count].CreateItem(item_type, 0, 180+n, 80+i, 0, 0, 0, 0);
; 343  : 				if( i < 6 )
; 344  : 				{
; 345  : 					fprintf(fp, "%18s : %4d %4d %4d %4d %4d  \n", \
; 346  : 						m_cItem[count].GetName(), 						
; 347  : 						m_cItem[count].m_DamageMin, 
; 348  : 						m_cItem[count].m_DamageMax, 
; 349  : 						m_cItem[count].m_Durability, 
; 350  : 						m_cItem[count].m_RequireStrength, 
; 351  : 						m_cItem[count].m_RequireDexterity);
; 352  : 				}
; 353  : 				else if( i == 6 )
; 354  : 				{
; 355  : 					fprintf(fp, "%18s : %4d %4d %4d %4d  \n", \
; 356  : 						m_cItem[count].GetName(), 						
; 357  : 						m_cItem[count].m_SuccessfulBlocking,
; 358  : 						m_cItem[count].m_Durability, 
; 359  : 						m_cItem[count].m_RequireStrength, 
; 360  : 						m_cItem[count].m_RequireDexterity);
; 361  : 				}
; 362  : 				else if( i >= 7 && i <= 11)
; 363  : 				{
; 364  : 					fprintf(fp, "%18s : %4d %4d %4d %4d %4d  \n", \
; 365  : 						m_cItem[count].GetName(), 						
; 366  : 						m_cItem[count].m_Defense,
; 367  : 						m_cItem[count].m_MagicDefense,
; 368  : 						m_cItem[count].m_Durability, 
; 369  : 						m_cItem[count].m_RequireStrength, 
; 370  : 						m_cItem[count].m_RequireDexterity);
; 371  : 				}
; 372  : 			}
; 373  : 		}
; 374  : 	}
; 375  : 
; 376  : 	fclose(fp);
; 377  : 	*/
; 378  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?SaveItemInfo@MapClass@@QAEXXZ ENDP			; MapClass::SaveItemInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GPATH@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GPATH@@QAEPAXI@Z PROC				; PATH::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1PATH@@QAE@XZ		; PATH::~PATH
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 54 04 00 00	 push	 1108			; 00000454H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GPATH@@QAEPAXI@Z ENDP				; PATH::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?GetPathY@PATH@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPathY@PATH@@QAEPAEXZ PROC				; PATH::GetPathY, COMDAT
; _this$ = ecx

; 581  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 582  : 		return PathY;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	05 00 02 00 00	 add	 eax, 512		; 00000200H

; 583  : 	}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?GetPathY@PATH@@QAEPAEXZ ENDP				; PATH::GetPathY
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?GetPathX@PATH@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPathX@PATH@@QAEPAEXZ PROC				; PATH::GetPathX, COMDAT
; _this$ = ecx

; 577  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 578  : 		return PathX;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH

; 579  : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetPathX@PATH@@QAEPAEXZ ENDP				; PATH::GetPathX
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?GetPath@PATH@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPath@PATH@@QAEHXZ PROC				; PATH::GetPath, COMDAT
; _this$ = ecx

; 573  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 574  : 		return NumPath;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 575  : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetPath@PATH@@QAEHXZ ENDP				; PATH::GetPath
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?SetMapDimensions@PATH@@QAEXHHPAE@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
_this$ = -4						; size = 4
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_map$ = 16						; size = 4
?SetMapDimensions@PATH@@QAEXHHPAE@Z PROC		; PATH::SetMapDimensions, COMDAT
; _this$ = ecx

; 568  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 569  : 		Width = w, Height = h, Map = map;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _w$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 45 0c	 mov	 eax, DWORD PTR _h$[ebp]
  0001a	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8b 55 10	 mov	 edx, DWORD PTR _map$[ebp]
  00023	89 91 3c 04 00
	00		 mov	 DWORD PTR [ecx+1084], edx

; 570  : 		HitMap = new unsigned char[Width*Height];

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 10		 mov	 edx, DWORD PTR [eax]
  00031	0f af 51 04	 imul	 edx, DWORD PTR [ecx+4]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 4d b8	 mov	 ecx, DWORD PTR $T1[ebp]
  00047	89 88 40 04 00
	00		 mov	 DWORD PTR [eax+1088], ecx

; 571  : 	}

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
?SetMapDimensions@PATH@@QAEXHHPAE@Z ENDP		; PATH::SetMapDimensions
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?FindPath2@PATH@@QAE_NHHHH_N@Z
_TEXT	SEGMENT
_First$ = -13						; size = 1
_NumFails$ = -12					; size = 4
_WhichDir$ = -8						; size = 4
_this$ = -4						; size = 4
_startx$ = 8						; size = 4
_starty$ = 12						; size = 4
_endx$ = 16						; size = 4
_endy$ = 20						; size = 4
_ErrorCheck$ = 24					; size = 1
?FindPath2@PATH@@QAE_NHHHH_N@Z PROC			; PATH::FindPath2, COMDAT
; _this$ = ecx

; 462  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		NumPath =0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 464  : 		int WhichDir = 0;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _WhichDir$[ebp], 0

; 465  : 		int NumFails = 0;

  0001d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _NumFails$[ebp], 0

; 466  : 		
; 467  : 		memset (HitMap, 0, Width*Height);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 10		 mov	 edx, DWORD PTR [eax]
  0002c	0f af 51 04	 imul	 edx, DWORD PTR [ecx+4]
  00030	52		 push	 edx
  00031	6a 00		 push	 0
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 88 40 04 00
	00		 mov	 ecx, DWORD PTR [eax+1088]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 468  : 		
; 469  : 		bool First = true;

  00045	c6 45 f3 01	 mov	 BYTE PTR _First$[ebp], 1
$LN2@FindPath2:

; 470  : 		while (startx!=endx || starty!=endy)

  00049	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  0004c	3b 45 10	 cmp	 eax, DWORD PTR _endx$[ebp]
  0004f	75 0c		 jne	 SHORT $LN4@FindPath2
  00051	8b 45 0c	 mov	 eax, DWORD PTR _starty$[ebp]
  00054	3b 45 14	 cmp	 eax, DWORD PTR _endy$[ebp]
  00057	0f 84 13 01 00
	00		 je	 $LN3@FindPath2
$LN4@FindPath2:

; 471  : 		{
; 472  : 			WhichDir = FindNextDir2(startx, starty, endx, endy, WhichDir, First, ErrorCheck);

  0005d	0f b6 45 18	 movzx	 eax, BYTE PTR _ErrorCheck$[ebp]
  00061	50		 push	 eax
  00062	0f b6 4d f3	 movzx	 ecx, BYTE PTR _First$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 f8	 mov	 edx, DWORD PTR _WhichDir$[ebp]
  0006a	52		 push	 edx
  0006b	8b 45 14	 mov	 eax, DWORD PTR _endy$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 10	 mov	 ecx, DWORD PTR _endx$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 0c	 mov	 edx, DWORD PTR _starty$[ebp]
  00076	52		 push	 edx
  00077	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?FindNextDir2@PATH@@AAEHHHHHH_N0@Z ; PATH::FindNextDir2
  00083	89 45 f8	 mov	 DWORD PTR _WhichDir$[ebp], eax

; 473  : 			First = false;

  00086	c6 45 f3 00	 mov	 BYTE PTR _First$[ebp], 0

; 474  : 			if (WhichDir >= 0)

  0008a	83 7d f8 00	 cmp	 DWORD PTR _WhichDir$[ebp], 0
  0008e	7c 78		 jl	 SHORT $LN5@FindPath2

; 475  : 			{
; 476  : 				PathX[NumPath] = startx;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00096	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00099	8a 45 08	 mov	 al, BYTE PTR _startx$[ebp]
  0009c	88 44 0a 0c	 mov	 BYTE PTR [edx+ecx+12], al

; 477  : 				PathY[NumPath] = starty;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	8a 45 0c	 mov	 al, BYTE PTR _starty$[ebp]
  000ac	88 84 0a 00 02
	00 00		 mov	 BYTE PTR [edx+ecx+512], al

; 478  : 				startx += Dir[WhichDir*2  ];

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  000b6	d1 e0		 shl	 eax, 1
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	8b 55 08	 mov	 edx, DWORD PTR _startx$[ebp]
  000be	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  000c5	89 55 08	 mov	 DWORD PTR _startx$[ebp], edx

; 479  : 				starty += Dir[WhichDir*2+1];                

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  000cb	d1 e0		 shl	 eax, 1
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	8b 55 0c	 mov	 edx, DWORD PTR _starty$[ebp]
  000d3	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  000da	89 55 0c	 mov	 DWORD PTR _starty$[ebp], edx

; 480  : 				NumPath ++;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e3	83 c1 01	 add	 ecx, 1
  000e6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e9	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 481  : 				if (NumPath >= MAX_PATH_FIND-1) {

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	83 78 08 0e	 cmp	 DWORD PTR [eax+8], 14	; 0000000eH
  000f3	7c 11		 jl	 SHORT $LN7@FindPath2

; 482  : 					NumPath--;

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000fb	83 e9 01	 sub	 ecx, 1
  000fe	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00101	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 483  : 					break;

  00104	eb 6a		 jmp	 SHORT $LN3@FindPath2
$LN7@FindPath2:

; 484  : 				}
; 485  : 			}

  00106	eb 63		 jmp	 SHORT $LN6@FindPath2
$LN5@FindPath2:

; 486  : 			else
; 487  : 			{
; 488  : 				if(ErrorCheck)

  00108	0f b6 45 18	 movzx	 eax, BYTE PTR _ErrorCheck$[ebp]
  0010c	85 c0		 test	 eax, eax
  0010e	74 59		 je	 SHORT $LN8@FindPath2

; 489  : 				{
; 490  : 					NumPath --;

  00110	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00113	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00116	83 e9 01	 sub	 ecx, 1
  00119	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0011c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 491  : 					if (NumPath < 0)

  0011f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00122	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00126	7d 07		 jge	 SHORT $LN10@FindPath2

; 492  : 						return false;

  00128	32 c0		 xor	 al, al
  0012a	e9 82 00 00 00	 jmp	 $LN1@FindPath2
$LN10@FindPath2:

; 493  : 					startx = PathX[NumPath];

  0012f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00132	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00135	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00138	0f b6 44 0a 0c	 movzx	 eax, BYTE PTR [edx+ecx+12]
  0013d	89 45 08	 mov	 DWORD PTR _startx$[ebp], eax

; 494  : 					starty = PathY[NumPath];

  00140	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00143	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00146	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00149	0f b6 84 0a 00
	02 00 00	 movzx	 eax, BYTE PTR [edx+ecx+512]
  00151	89 45 0c	 mov	 DWORD PTR _starty$[ebp], eax

; 495  : 					NumFails ++;

  00154	8b 45 f4	 mov	 eax, DWORD PTR _NumFails$[ebp]
  00157	83 c0 01	 add	 eax, 1
  0015a	89 45 f4	 mov	 DWORD PTR _NumFails$[ebp], eax

; 496  : 					if (NumFails >= 10)

  0015d	83 7d f4 0a	 cmp	 DWORD PTR _NumFails$[ebp], 10 ; 0000000aH
  00161	7c 04		 jl	 SHORT $LN11@FindPath2

; 497  : 						return false;                               

  00163	32 c0		 xor	 al, al
  00165	eb 4a		 jmp	 SHORT $LN1@FindPath2
$LN11@FindPath2:

; 498  : 				}

  00167	eb 02		 jmp	 SHORT $LN6@FindPath2
$LN8@FindPath2:

; 499  :       			else
; 500  : 					break;

  00169	eb 05		 jmp	 SHORT $LN3@FindPath2
$LN6@FindPath2:

; 501  : 			}
; 502  : 		}

  0016b	e9 d9 fe ff ff	 jmp	 $LN2@FindPath2
$LN3@FindPath2:

; 503  : 		PathX[NumPath] = startx;

  00170	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00173	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00176	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00179	8a 45 08	 mov	 al, BYTE PTR _startx$[ebp]
  0017c	88 44 0a 0c	 mov	 BYTE PTR [edx+ecx+12], al

; 504  : 		PathY[NumPath] = starty;

  00180	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00183	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00186	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00189	8a 45 0c	 mov	 al, BYTE PTR _starty$[ebp]
  0018c	88 84 0a 00 02
	00 00		 mov	 BYTE PTR [edx+ecx+512], al

; 505  : 		NumPath ++;

  00193	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00196	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00199	83 c1 01	 add	 ecx, 1
  0019c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0019f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 506  : 		if (NumPath >= MAX_PATH_FIND)

  001a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	83 78 08 0f	 cmp	 DWORD PTR [eax+8], 15	; 0000000fH
  001a9	7c 04		 jl	 SHORT $LN12@FindPath2

; 507  : 			return false;       

  001ab	32 c0		 xor	 al, al
  001ad	eb 02		 jmp	 SHORT $LN1@FindPath2
$LN12@FindPath2:

; 508  : 		return true;

  001af	b0 01		 mov	 al, 1
$LN1@FindPath2:

; 509  : 	}	

  001b1	5f		 pop	 edi
  001b2	5e		 pop	 esi
  001b3	5b		 pop	 ebx
  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c2 14 00	 ret	 20			; 00000014H
?FindPath2@PATH@@QAE_NHHHH_N@Z ENDP			; PATH::FindPath2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?FindPath@PATH@@QAE_NHHHH_N@Z
_TEXT	SEGMENT
_First$ = -13						; size = 1
_NumFails$ = -12					; size = 4
_WhichDir$ = -8						; size = 4
_this$ = -4						; size = 4
_startx$ = 8						; size = 4
_starty$ = 12						; size = 4
_endx$ = 16						; size = 4
_endy$ = 20						; size = 4
_ErrorCheck$ = 24					; size = 1
?FindPath@PATH@@QAE_NHHHH_N@Z PROC			; PATH::FindPath, COMDAT
; _this$ = ecx

; 414  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 415  : 		NumPath =0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 416  : 		int WhichDir = 0;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _WhichDir$[ebp], 0

; 417  : 		int NumFails = 0;

  0001d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _NumFails$[ebp], 0

; 418  : 		
; 419  : 		memset (HitMap, 0, Width*Height);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 10		 mov	 edx, DWORD PTR [eax]
  0002c	0f af 51 04	 imul	 edx, DWORD PTR [ecx+4]
  00030	52		 push	 edx
  00031	6a 00		 push	 0
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 88 40 04 00
	00		 mov	 ecx, DWORD PTR [eax+1088]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 420  : 		
; 421  : 		bool First = true;

  00045	c6 45 f3 01	 mov	 BYTE PTR _First$[ebp], 1
$LN2@FindPath:

; 422  : 		while (startx!=endx || starty!=endy)

  00049	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  0004c	3b 45 10	 cmp	 eax, DWORD PTR _endx$[ebp]
  0004f	75 0c		 jne	 SHORT $LN4@FindPath
  00051	8b 45 0c	 mov	 eax, DWORD PTR _starty$[ebp]
  00054	3b 45 14	 cmp	 eax, DWORD PTR _endy$[ebp]
  00057	0f 84 09 01 00
	00		 je	 $LN3@FindPath
$LN4@FindPath:

; 423  : 		{
; 424  : 			WhichDir = FindNextDir(startx, starty, endx, endy, WhichDir, First, ErrorCheck);

  0005d	0f b6 45 18	 movzx	 eax, BYTE PTR _ErrorCheck$[ebp]
  00061	50		 push	 eax
  00062	0f b6 4d f3	 movzx	 ecx, BYTE PTR _First$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 f8	 mov	 edx, DWORD PTR _WhichDir$[ebp]
  0006a	52		 push	 edx
  0006b	8b 45 14	 mov	 eax, DWORD PTR _endy$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 10	 mov	 ecx, DWORD PTR _endx$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 0c	 mov	 edx, DWORD PTR _starty$[ebp]
  00076	52		 push	 edx
  00077	8b 45 08	 mov	 eax, DWORD PTR _startx$[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?FindNextDir@PATH@@AAEHHHHHH_N0@Z ; PATH::FindNextDir
  00083	89 45 f8	 mov	 DWORD PTR _WhichDir$[ebp], eax

; 425  : 			First = false;

  00086	c6 45 f3 00	 mov	 BYTE PTR _First$[ebp], 0

; 426  : 			if (WhichDir >= 0)

  0008a	83 7d f8 00	 cmp	 DWORD PTR _WhichDir$[ebp], 0
  0008e	7c 6e		 jl	 SHORT $LN5@FindPath

; 427  : 			{
; 428  : 				PathX[NumPath] = startx;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00096	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00099	8a 45 08	 mov	 al, BYTE PTR _startx$[ebp]
  0009c	88 44 0a 0c	 mov	 BYTE PTR [edx+ecx+12], al

; 429  : 				PathY[NumPath] = starty;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a9	8a 45 0c	 mov	 al, BYTE PTR _starty$[ebp]
  000ac	88 84 0a 00 02
	00 00		 mov	 BYTE PTR [edx+ecx+512], al

; 430  : 				startx += Dir[WhichDir*2  ];

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  000b6	d1 e0		 shl	 eax, 1
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	8b 55 08	 mov	 edx, DWORD PTR _startx$[ebp]
  000be	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  000c5	89 55 08	 mov	 DWORD PTR _startx$[ebp], edx

; 431  : 				starty += Dir[WhichDir*2+1];                

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  000cb	d1 e0		 shl	 eax, 1
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	8b 55 0c	 mov	 edx, DWORD PTR _starty$[ebp]
  000d3	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  000da	89 55 0c	 mov	 DWORD PTR _starty$[ebp], edx

; 432  : 				NumPath ++;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e3	83 c1 01	 add	 ecx, 1
  000e6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e9	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 433  : 				if (NumPath >= MAX_PATH_FIND)

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	83 78 08 0f	 cmp	 DWORD PTR [eax+8], 15	; 0000000fH
  000f3	7c 07		 jl	 SHORT $LN7@FindPath

; 434  : 					return false;       

  000f5	32 c0		 xor	 al, al
  000f7	e9 ab 00 00 00	 jmp	 $LN1@FindPath
$LN7@FindPath:

; 435  : 			}

  000fc	eb 63		 jmp	 SHORT $LN6@FindPath
$LN5@FindPath:

; 436  : 			else
; 437  : 			{
; 438  : 				if(ErrorCheck)

  000fe	0f b6 45 18	 movzx	 eax, BYTE PTR _ErrorCheck$[ebp]
  00102	85 c0		 test	 eax, eax
  00104	74 59		 je	 SHORT $LN8@FindPath

; 439  : 				{
; 440  : 					NumPath --;

  00106	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00109	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0010c	83 e9 01	 sub	 ecx, 1
  0010f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00112	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 441  : 					if (NumPath < 0)

  00115	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00118	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0011c	7d 07		 jge	 SHORT $LN10@FindPath

; 442  : 						return false;

  0011e	32 c0		 xor	 al, al
  00120	e9 82 00 00 00	 jmp	 $LN1@FindPath
$LN10@FindPath:

; 443  : 					startx = PathX[NumPath];

  00125	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00128	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0012e	0f b6 44 0a 0c	 movzx	 eax, BYTE PTR [edx+ecx+12]
  00133	89 45 08	 mov	 DWORD PTR _startx$[ebp], eax

; 444  : 					starty = PathY[NumPath];

  00136	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00139	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0013c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0013f	0f b6 84 0a 00
	02 00 00	 movzx	 eax, BYTE PTR [edx+ecx+512]
  00147	89 45 0c	 mov	 DWORD PTR _starty$[ebp], eax

; 445  : 					NumFails ++;

  0014a	8b 45 f4	 mov	 eax, DWORD PTR _NumFails$[ebp]
  0014d	83 c0 01	 add	 eax, 1
  00150	89 45 f4	 mov	 DWORD PTR _NumFails$[ebp], eax

; 446  : 					if (NumFails >= 10)

  00153	83 7d f4 0a	 cmp	 DWORD PTR _NumFails$[ebp], 10 ; 0000000aH
  00157	7c 04		 jl	 SHORT $LN11@FindPath

; 447  : 						return false;                               

  00159	32 c0		 xor	 al, al
  0015b	eb 4a		 jmp	 SHORT $LN1@FindPath
$LN11@FindPath:

; 448  : 				}

  0015d	eb 02		 jmp	 SHORT $LN6@FindPath
$LN8@FindPath:

; 449  :       			else
; 450  : 					break;

  0015f	eb 05		 jmp	 SHORT $LN3@FindPath
$LN6@FindPath:

; 451  : 			}
; 452  : 		}

  00161	e9 e3 fe ff ff	 jmp	 $LN2@FindPath
$LN3@FindPath:

; 453  : 		PathX[NumPath] = startx;

  00166	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00169	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0016c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0016f	8a 45 08	 mov	 al, BYTE PTR _startx$[ebp]
  00172	88 44 0a 0c	 mov	 BYTE PTR [edx+ecx+12], al

; 454  : 		PathY[NumPath] = starty;

  00176	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00179	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0017c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0017f	8a 45 0c	 mov	 al, BYTE PTR _starty$[ebp]
  00182	88 84 0a 00 02
	00 00		 mov	 BYTE PTR [edx+ecx+512], al

; 455  : 		NumPath ++;

  00189	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0018f	83 c1 01	 add	 ecx, 1
  00192	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00195	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 456  : 		if (NumPath >= MAX_PATH_FIND)

  00198	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0019b	83 78 08 0f	 cmp	 DWORD PTR [eax+8], 15	; 0000000fH
  0019f	7c 04		 jl	 SHORT $LN12@FindPath

; 457  : 			return false;       

  001a1	32 c0		 xor	 al, al
  001a3	eb 02		 jmp	 SHORT $LN1@FindPath
$LN12@FindPath:

; 458  : 		return true;

  001a5	b0 01		 mov	 al, 1
$LN1@FindPath:

; 459  : 	}

  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c2 14 00	 ret	 20			; 00000014H
?FindPath@PATH@@QAE_NHHHH_N@Z ENDP			; PATH::FindPath
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ??1PATH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PATH@@QAE@XZ PROC					; PATH::~PATH, COMDAT
; _this$ = ecx

; 411  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 412  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1PATH@@QAE@XZ ENDP					; PATH::~PATH
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ??0PATH@@QAE@XZ
_TEXT	SEGMENT
_dir$ = -72						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??0PATH@@QAE@XZ PROC					; PATH::PATH, COMDAT
; _this$ = ecx

; 405  :     PATH()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 406  : 	{
; 407  : 		int dir[] = {-1,-1, 0,-1,  1,-1,  1,0,  1,1,  0,1,  -1,1,  -1,0};// 8dir

  00019	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR _dir$[ebp], -1
  00020	c7 45 bc ff ff
	ff ff		 mov	 DWORD PTR _dir$[ebp+4], -1
  00027	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _dir$[ebp+8], 0
  0002e	c7 45 c4 ff ff
	ff ff		 mov	 DWORD PTR _dir$[ebp+12], -1
  00035	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _dir$[ebp+16], 1
  0003c	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _dir$[ebp+20], -1
  00043	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _dir$[ebp+24], 1
  0004a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _dir$[ebp+28], 0
  00051	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _dir$[ebp+32], 1
  00058	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _dir$[ebp+36], 1
  0005f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _dir$[ebp+40], 0
  00066	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _dir$[ebp+44], 1
  0006d	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _dir$[ebp+48], -1
  00074	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _dir$[ebp+52], 1
  0007b	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _dir$[ebp+56], -1
  00082	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dir$[ebp+60], 0

; 408  : 		memcpy(Dir, dir, sizeof(int)*16);

  00089	6a 40		 push	 64			; 00000040H
  0008b	8d 45 b8	 lea	 eax, DWORD PTR _dir$[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	81 c1 f4 03 00
	00		 add	 ecx, 1012		; 000003f4H
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 _memcpy
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 409  : 	}

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000aa	33 cd		 xor	 ecx, ebp
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
??0PATH@@QAE@XZ ENDP					; PATH::PATH
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?FindNextDir2@PATH@@AAEHHHHHH_N0@Z
_TEXT	SEGMENT
_p$1 = -80						; size = 4
_posdir$2 = -76						; size = 4
_p$3 = -72						; size = 4
_negdir$4 = -68						; size = 4
_p$5 = -64						; size = 4
_LastDist$ = -60					; size = 4
_dist$6 = -56						; size = 4
_newy$7 = -52						; size = 4
_newx$8 = -48						; size = 4
_dist$9 = -44						; size = 4
_newy$10 = -40						; size = 4
_newx$11 = -36						; size = 4
_dist$12 = -32						; size = 4
_newy$13 = -28						; size = 4
_newx$14 = -24						; size = 4
_i$ = -20						; size = 4
_WhichDir$ = -16					; size = 4
_ldir$ = -12						; size = 4
_MinDist$ = -8						; size = 4
_this$ = -4						; size = 4
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_dirstart$ = 24						; size = 4
_First$ = 28						; size = 1
_ErrorCheck$ = 32					; size = 1
?FindNextDir2@PATH@@AAEHHHHHH_N0@Z PROC			; PATH::FindNextDir2, COMDAT
; _this$ = ecx

; 176  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 177  : 		// 안전지대로 가는것을 방지 -> 우선 무리몬스터들만
; 178  : 
; 179  :         //if (LastDir == dirstart)
; 180  :         int MinDist = 10000000, ldir;

  0000f	c7 45 f8 80 96
	98 00		 mov	 DWORD PTR _MinDist$[ebp], 10000000 ; 00989680H

; 181  :         int WhichDir = 0;

  00016	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _WhichDir$[ebp], 0

; 182  : 		int i;
; 183  : 		if(First)

  0001d	0f b6 45 1c	 movzx	 eax, BYTE PTR _First$[ebp]
  00021	85 c0		 test	 eax, eax
  00023	0f 84 a5 00 00
	00		 je	 $LN11@FindNextDi

; 184  : 		{
; 185  : 			for (i=0; i<8; i++)

  00029	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00030	eb 09		 jmp	 SHORT $LN4@FindNextDi
$LN2@FindNextDi:
  00032	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00035	83 c0 01	 add	 eax, 1
  00038	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@FindNextDi:
  0003b	83 7d ec 08	 cmp	 DWORD PTR _i$[ebp], 8
  0003f	0f 8d 84 00 00
	00		 jge	 $LN3@FindNextDi

; 186  : 			{
; 187  : 				ldir=i%8;// only 8 directions in case we wrap

  00045	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00048	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0004d	79 05		 jns	 SHORT $LN27@FindNextDi
  0004f	48		 dec	 eax
  00050	83 c8 f8	 or	 eax, -8			; fffffff8H
  00053	40		 inc	 eax
$LN27@FindNextDi:
  00054	89 45 f4	 mov	 DWORD PTR _ldir$[ebp], eax

; 188  : 				int newx = sx+Dir[ldir*2], newy = sy+Dir[ldir*2+1];

  00057	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  0005a	d1 e0		 shl	 eax, 1
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  00062	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  00069	89 55 e8	 mov	 DWORD PTR _newx$14[ebp], edx
  0006c	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  0006f	d1 e0		 shl	 eax, 1
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00077	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  0007e	89 55 e4	 mov	 DWORD PTR _newy$13[ebp], edx

; 189  : 				int dist = GetDist(newx, newy, dx, dy);

  00081	8b 45 14	 mov	 eax, DWORD PTR _dy$[ebp]
  00084	50		 push	 eax
  00085	8b 4d 10	 mov	 ecx, DWORD PTR _dx$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 e4	 mov	 edx, DWORD PTR _newy$13[ebp]
  0008c	52		 push	 edx
  0008d	8b 45 e8	 mov	 eax, DWORD PTR _newx$14[ebp]
  00090	50		 push	 eax
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?GetDist@PATH@@AAEHHHHH@Z ; PATH::GetDist
  00099	89 45 e0	 mov	 DWORD PTR _dist$12[ebp], eax

; 190  : 				if (MinDist > dist && IsThisSpotOK(newx, newy))

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  0009f	3b 45 e0	 cmp	 eax, DWORD PTR _dist$12[ebp]
  000a2	7e 20		 jle	 SHORT $LN13@FindNextDi
  000a4	8b 45 e4	 mov	 eax, DWORD PTR _newy$13[ebp]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR _newx$14[ebp]
  000ab	51		 push	 ecx
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	e8 00 00 00 00	 call	 ?IsThisSpotOK@PATH@@AAEHHH@Z ; PATH::IsThisSpotOK
  000b4	85 c0		 test	 eax, eax
  000b6	74 0c		 je	 SHORT $LN13@FindNextDi

; 191  : 				{MinDist = dist; WhichDir = ldir;} 

  000b8	8b 45 e0	 mov	 eax, DWORD PTR _dist$12[ebp]
  000bb	89 45 f8	 mov	 DWORD PTR _MinDist$[ebp], eax
  000be	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  000c1	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax
$LN13@FindNextDi:

; 192  : 			}

  000c4	e9 69 ff ff ff	 jmp	 $LN2@FindNextDi
$LN3@FindNextDi:

; 193  : 		}

  000c9	e9 5b 01 00 00	 jmp	 $LN12@FindNextDi
$LN11@FindNextDi:

; 194  : 		else
; 195  : 		{
; 196  : 			for (i=dirstart+8-1; i<=dirstart+8+1; i++)

  000ce	8b 45 18	 mov	 eax, DWORD PTR _dirstart$[ebp]
  000d1	83 c0 07	 add	 eax, 7
  000d4	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
  000d7	eb 09		 jmp	 SHORT $LN7@FindNextDi
$LN5@FindNextDi:
  000d9	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN7@FindNextDi:
  000e2	8b 45 18	 mov	 eax, DWORD PTR _dirstart$[ebp]
  000e5	83 c0 09	 add	 eax, 9
  000e8	39 45 ec	 cmp	 DWORD PTR _i$[ebp], eax
  000eb	0f 8f 84 00 00
	00		 jg	 $LN6@FindNextDi

; 197  : 			{
; 198  : 				ldir=i%8;// only 8 directions in case we wrap

  000f1	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  000f9	79 05		 jns	 SHORT $LN28@FindNextDi
  000fb	48		 dec	 eax
  000fc	83 c8 f8	 or	 eax, -8			; fffffff8H
  000ff	40		 inc	 eax
$LN28@FindNextDi:
  00100	89 45 f4	 mov	 DWORD PTR _ldir$[ebp], eax

; 199  : 				int newx = sx+Dir[ldir*2], newy = sy+Dir[ldir*2+1];

  00103	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  00106	d1 e0		 shl	 eax, 1
  00108	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  0010e	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  00115	89 55 dc	 mov	 DWORD PTR _newx$11[ebp], edx
  00118	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  0011b	d1 e0		 shl	 eax, 1
  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00123	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  0012a	89 55 d8	 mov	 DWORD PTR _newy$10[ebp], edx

; 200  : 				int dist = GetDist(newx, newy, dx, dy);

  0012d	8b 45 14	 mov	 eax, DWORD PTR _dy$[ebp]
  00130	50		 push	 eax
  00131	8b 4d 10	 mov	 ecx, DWORD PTR _dx$[ebp]
  00134	51		 push	 ecx
  00135	8b 55 d8	 mov	 edx, DWORD PTR _newy$10[ebp]
  00138	52		 push	 edx
  00139	8b 45 dc	 mov	 eax, DWORD PTR _newx$11[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00140	e8 00 00 00 00	 call	 ?GetDist@PATH@@AAEHHHHH@Z ; PATH::GetDist
  00145	89 45 d4	 mov	 DWORD PTR _dist$9[ebp], eax

; 201  : 				if (MinDist > dist && IsThisSpotOK(newx, newy))

  00148	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  0014b	3b 45 d4	 cmp	 eax, DWORD PTR _dist$9[ebp]
  0014e	7e 20		 jle	 SHORT $LN14@FindNextDi
  00150	8b 45 d8	 mov	 eax, DWORD PTR _newy$10[ebp]
  00153	50		 push	 eax
  00154	8b 4d dc	 mov	 ecx, DWORD PTR _newx$11[ebp]
  00157	51		 push	 ecx
  00158	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	e8 00 00 00 00	 call	 ?IsThisSpotOK@PATH@@AAEHHH@Z ; PATH::IsThisSpotOK
  00160	85 c0		 test	 eax, eax
  00162	74 0c		 je	 SHORT $LN14@FindNextDi

; 202  : 				{MinDist = dist; WhichDir = ldir;} 

  00164	8b 45 d4	 mov	 eax, DWORD PTR _dist$9[ebp]
  00167	89 45 f8	 mov	 DWORD PTR _MinDist$[ebp], eax
  0016a	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  0016d	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax
$LN14@FindNextDi:

; 203  : 			}

  00170	e9 64 ff ff ff	 jmp	 $LN5@FindNextDi
$LN6@FindNextDi:

; 204  : 			if (MinDist == 10000000)//in case we didn't find a spot the first time

  00175	81 7d f8 80 96
	98 00		 cmp	 DWORD PTR _MinDist$[ebp], 10000000 ; 00989680H
  0017c	0f 85 a7 00 00
	00		 jne	 $LN12@FindNextDi

; 205  : 			{
; 206  : 				for (i=dirstart+2; i<=dirstart+6; i++)// 5 directions left

  00182	8b 45 18	 mov	 eax, DWORD PTR _dirstart$[ebp]
  00185	83 c0 02	 add	 eax, 2
  00188	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
  0018b	eb 09		 jmp	 SHORT $LN10@FindNextDi
$LN8@FindNextDi:
  0018d	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00190	83 c0 01	 add	 eax, 1
  00193	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN10@FindNextDi:
  00196	8b 45 18	 mov	 eax, DWORD PTR _dirstart$[ebp]
  00199	83 c0 06	 add	 eax, 6
  0019c	39 45 ec	 cmp	 DWORD PTR _i$[ebp], eax
  0019f	0f 8f 84 00 00
	00		 jg	 $LN12@FindNextDi

; 207  : 				{
; 208  : 					ldir=i%8;

  001a5	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  001a8	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  001ad	79 05		 jns	 SHORT $LN29@FindNextDi
  001af	48		 dec	 eax
  001b0	83 c8 f8	 or	 eax, -8			; fffffff8H
  001b3	40		 inc	 eax
$LN29@FindNextDi:
  001b4	89 45 f4	 mov	 DWORD PTR _ldir$[ebp], eax

; 209  : 					int newx = sx+Dir[ldir*2], newy = sy+Dir[ldir*2+1];

  001b7	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  001ba	d1 e0		 shl	 eax, 1
  001bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  001c2	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  001c9	89 55 d0	 mov	 DWORD PTR _newx$8[ebp], edx
  001cc	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  001cf	d1 e0		 shl	 eax, 1
  001d1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d4	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  001d7	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  001de	89 55 cc	 mov	 DWORD PTR _newy$7[ebp], edx

; 210  : 					int dist = GetDist(newx, newy, dx, dy);

  001e1	8b 45 14	 mov	 eax, DWORD PTR _dy$[ebp]
  001e4	50		 push	 eax
  001e5	8b 4d 10	 mov	 ecx, DWORD PTR _dx$[ebp]
  001e8	51		 push	 ecx
  001e9	8b 55 cc	 mov	 edx, DWORD PTR _newy$7[ebp]
  001ec	52		 push	 edx
  001ed	8b 45 d0	 mov	 eax, DWORD PTR _newx$8[ebp]
  001f0	50		 push	 eax
  001f1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f4	e8 00 00 00 00	 call	 ?GetDist@PATH@@AAEHHHHH@Z ; PATH::GetDist
  001f9	89 45 c8	 mov	 DWORD PTR _dist$6[ebp], eax

; 211  : 					if (MinDist > dist && IsThisSpotOK(newx, newy))

  001fc	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  001ff	3b 45 c8	 cmp	 eax, DWORD PTR _dist$6[ebp]
  00202	7e 20		 jle	 SHORT $LN16@FindNextDi
  00204	8b 45 cc	 mov	 eax, DWORD PTR _newy$7[ebp]
  00207	50		 push	 eax
  00208	8b 4d d0	 mov	 ecx, DWORD PTR _newx$8[ebp]
  0020b	51		 push	 ecx
  0020c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0020f	e8 00 00 00 00	 call	 ?IsThisSpotOK@PATH@@AAEHHH@Z ; PATH::IsThisSpotOK
  00214	85 c0		 test	 eax, eax
  00216	74 0c		 je	 SHORT $LN16@FindNextDi

; 212  : 					{MinDist = dist; WhichDir = ldir;} 

  00218	8b 45 c8	 mov	 eax, DWORD PTR _dist$6[ebp]
  0021b	89 45 f8	 mov	 DWORD PTR _MinDist$[ebp], eax
  0021e	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  00221	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax
$LN16@FindNextDi:

; 213  : 				}

  00224	e9 64 ff ff ff	 jmp	 $LN8@FindNextDi
$LN12@FindNextDi:

; 214  : 			}
; 215  : 		}
; 216  :         LastDir = dirstart;

  00229	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0022c	8b 4d 18	 mov	 ecx, DWORD PTR _dirstart$[ebp]
  0022f	89 88 34 04 00
	00		 mov	 DWORD PTR [eax+1076], ecx

; 217  : 		int LastDist = GetDist(sx, sy, sx+Dir[LastDir*2], sy+Dir[LastDir*2+1]);

  00235	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00238	8b 88 34 04 00
	00		 mov	 ecx, DWORD PTR [eax+1076]
  0023e	d1 e1		 shl	 ecx, 1
  00240	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00243	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  00246	03 84 8a f8 03
	00 00		 add	 eax, DWORD PTR [edx+ecx*4+1016]
  0024d	50		 push	 eax
  0024e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00251	8b 91 34 04 00
	00		 mov	 edx, DWORD PTR [ecx+1076]
  00257	d1 e2		 shl	 edx, 1
  00259	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025c	8b 4d 08	 mov	 ecx, DWORD PTR _sx$[ebp]
  0025f	03 8c 90 f4 03
	00 00		 add	 ecx, DWORD PTR [eax+edx*4+1012]
  00266	51		 push	 ecx
  00267	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  0026a	52		 push	 edx
  0026b	8b 45 08	 mov	 eax, DWORD PTR _sx$[ebp]
  0026e	50		 push	 eax
  0026f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00272	e8 00 00 00 00	 call	 ?GetDist@PATH@@AAEHHHHH@Z ; PATH::GetDist
  00277	89 45 c4	 mov	 DWORD PTR _LastDist$[ebp], eax

; 218  : 		if (LastDist>MinDist-6 && LastDist<MinDist+6 && MinDist>=25)//???

  0027a	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  0027d	83 e8 06	 sub	 eax, 6
  00280	39 45 c4	 cmp	 DWORD PTR _LastDist$[ebp], eax
  00283	7e 1d		 jle	 SHORT $LN17@FindNextDi
  00285	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  00288	83 c0 06	 add	 eax, 6
  0028b	39 45 c4	 cmp	 DWORD PTR _LastDist$[ebp], eax
  0028e	7d 12		 jge	 SHORT $LN17@FindNextDi
  00290	83 7d f8 19	 cmp	 DWORD PTR _MinDist$[ebp], 25 ; 00000019H
  00294	7c 0c		 jl	 SHORT $LN17@FindNextDi

; 219  : 			WhichDir = LastDir;

  00296	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00299	8b 88 34 04 00
	00		 mov	 ecx, DWORD PTR [eax+1076]
  0029f	89 4d f0	 mov	 DWORD PTR _WhichDir$[ebp], ecx
$LN17@FindNextDi:

; 220  : 		if (MinDist == 10000000)// we could not find a good spot

  002a2	81 7d f8 80 96
	98 00		 cmp	 DWORD PTR _MinDist$[ebp], 10000000 ; 00989680H
  002a9	75 08		 jne	 SHORT $LN18@FindNextDi

; 221  : 			return -1;

  002ab	83 c8 ff	 or	 eax, -1
  002ae	e9 d5 01 00 00	 jmp	 $LN1@FindNextDi
$LN18@FindNextDi:

; 222  : 
; 223  : 		// now we know the shortset distance but...
; 224  : 		if (CanWeMoveForward2(sx+Dir[WhichDir*2], sy+Dir[WhichDir*2+1]))

  002b3	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  002b6	d1 e0		 shl	 eax, 1
  002b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002bb	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  002be	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  002c5	52		 push	 edx
  002c6	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  002c9	d1 e0		 shl	 eax, 1
  002cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ce	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  002d1	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  002d8	52		 push	 edx
  002d9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002dc	e8 00 00 00 00	 call	 ?CanWeMoveForward2@PATH@@AAEHHH@Z ; PATH::CanWeMoveForward2
  002e1	85 c0		 test	 eax, eax
  002e3	74 43		 je	 SHORT $LN19@FindNextDi

; 225  : 		{
; 226  : 			int p = VerifyThatOnPath(sx, sy);

  002e5	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  002e8	50		 push	 eax
  002e9	8b 4d 08	 mov	 ecx, DWORD PTR _sx$[ebp]
  002ec	51		 push	 ecx
  002ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f0	e8 00 00 00 00	 call	 ?VerifyThatOnPath@PATH@@AAEHHH@Z ; PATH::VerifyThatOnPath
  002f5	89 45 c0	 mov	 DWORD PTR _p$5[ebp], eax

; 227  : 			if (p!=-1)// we are back on a previous point

  002f8	83 7d c0 ff	 cmp	 DWORD PTR _p$5[ebp], -1
  002fc	74 22		 je	 SHORT $LN20@FindNextDi

; 228  : 			{
; 229  : 				HitMap[sx+sy*Width] = 1;

  002fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00301	8b 4d 0c	 mov	 ecx, DWORD PTR _sy$[ebp]
  00304	0f af 08	 imul	 ecx, DWORD PTR [eax]
  00307	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  0030a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0030d	8b 82 40 04 00
	00		 mov	 eax, DWORD PTR [edx+1088]
  00313	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1

; 230  : 				NumPath = p;

  00317	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0031a	8b 4d c0	 mov	 ecx, DWORD PTR _p$5[ebp]
  0031d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN20@FindNextDi:

; 231  : 			}
; 232  : 			return WhichDir;

  00320	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  00323	e9 60 01 00 00	 jmp	 $LN1@FindNextDi
$LN19@FindNextDi:

; 233  : 		}
; 234  : 		if(ErrorCheck)

  00328	0f b6 45 20	 movzx	 eax, BYTE PTR _ErrorCheck$[ebp]
  0032c	85 c0		 test	 eax, eax
  0032e	0f 84 38 01 00
	00		 je	 $LN21@FindNextDi

; 235  : 		{
; 236  : #ifdef MODIFY_PATHFIND_BUGFIX_20090609
; 237  : 			WhichDir += 4; WhichDir %= 8;

  00334	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  00337	83 c0 04	 add	 eax, 4
  0033a	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax
  0033d	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  00340	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00345	79 05		 jns	 SHORT $LN30@FindNextDi
  00347	48		 dec	 eax
  00348	83 c8 f8	 or	 eax, -8			; fffffff8H
  0034b	40		 inc	 eax
$LN30@FindNextDi:
  0034c	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax

; 238  : #endif	// MODIFY_PATHFIND_BUGFIX_20090609
; 239  : 
; 240  : 			int negdir = (WhichDir+8-1); negdir%=8;

  0034f	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  00352	83 c0 07	 add	 eax, 7
  00355	89 45 bc	 mov	 DWORD PTR _negdir$4[ebp], eax
  00358	8b 45 bc	 mov	 eax, DWORD PTR _negdir$4[ebp]
  0035b	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00360	79 05		 jns	 SHORT $LN31@FindNextDi
  00362	48		 dec	 eax
  00363	83 c8 f8	 or	 eax, -8			; fffffff8H
  00366	40		 inc	 eax
$LN31@FindNextDi:
  00367	89 45 bc	 mov	 DWORD PTR _negdir$4[ebp], eax

; 241  : 			if (CanWeMoveForward2(sx+Dir[negdir*2], sy+Dir[negdir*2+1]))

  0036a	8b 45 bc	 mov	 eax, DWORD PTR _negdir$4[ebp]
  0036d	d1 e0		 shl	 eax, 1
  0036f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00372	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00375	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  0037c	52		 push	 edx
  0037d	8b 45 bc	 mov	 eax, DWORD PTR _negdir$4[ebp]
  00380	d1 e0		 shl	 eax, 1
  00382	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00385	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  00388	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  0038f	52		 push	 edx
  00390	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00393	e8 00 00 00 00	 call	 ?CanWeMoveForward2@PATH@@AAEHHH@Z ; PATH::CanWeMoveForward2
  00398	85 c0		 test	 eax, eax
  0039a	74 43		 je	 SHORT $LN22@FindNextDi

; 242  : 			{
; 243  : 				int p = VerifyThatOnPath(sx, sy);

  0039c	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  0039f	50		 push	 eax
  003a0	8b 4d 08	 mov	 ecx, DWORD PTR _sx$[ebp]
  003a3	51		 push	 ecx
  003a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a7	e8 00 00 00 00	 call	 ?VerifyThatOnPath@PATH@@AAEHHH@Z ; PATH::VerifyThatOnPath
  003ac	89 45 b8	 mov	 DWORD PTR _p$3[ebp], eax

; 244  : 				if (p!=-1)// we are back on a previous point

  003af	83 7d b8 ff	 cmp	 DWORD PTR _p$3[ebp], -1
  003b3	74 22		 je	 SHORT $LN23@FindNextDi

; 245  : 				{
; 246  : 					HitMap[sx+sy*Width] = 1;

  003b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003b8	8b 4d 0c	 mov	 ecx, DWORD PTR _sy$[ebp]
  003bb	0f af 08	 imul	 ecx, DWORD PTR [eax]
  003be	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  003c1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003c4	8b 82 40 04 00
	00		 mov	 eax, DWORD PTR [edx+1088]
  003ca	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1

; 247  : 					NumPath = p;

  003ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003d1	8b 4d b8	 mov	 ecx, DWORD PTR _p$3[ebp]
  003d4	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN23@FindNextDi:

; 248  : 				}
; 249  : 				return negdir;

  003d7	8b 45 bc	 mov	 eax, DWORD PTR _negdir$4[ebp]
  003da	e9 a9 00 00 00	 jmp	 $LN1@FindNextDi
$LN22@FindNextDi:

; 250  : 			}
; 251  : 			int posdir = (WhichDir+8+1); posdir%=8;

  003df	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  003e2	83 c0 09	 add	 eax, 9
  003e5	89 45 b4	 mov	 DWORD PTR _posdir$2[ebp], eax
  003e8	8b 45 b4	 mov	 eax, DWORD PTR _posdir$2[ebp]
  003eb	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  003f0	79 05		 jns	 SHORT $LN32@FindNextDi
  003f2	48		 dec	 eax
  003f3	83 c8 f8	 or	 eax, -8			; fffffff8H
  003f6	40		 inc	 eax
$LN32@FindNextDi:
  003f7	89 45 b4	 mov	 DWORD PTR _posdir$2[ebp], eax

; 252  : 			if (CanWeMoveForward2(sx+Dir[posdir*2], sy+Dir[posdir*2+1]))

  003fa	8b 45 b4	 mov	 eax, DWORD PTR _posdir$2[ebp]
  003fd	d1 e0		 shl	 eax, 1
  003ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00402	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00405	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  0040c	52		 push	 edx
  0040d	8b 45 b4	 mov	 eax, DWORD PTR _posdir$2[ebp]
  00410	d1 e0		 shl	 eax, 1
  00412	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00415	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  00418	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  0041f	52		 push	 edx
  00420	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00423	e8 00 00 00 00	 call	 ?CanWeMoveForward2@PATH@@AAEHHH@Z ; PATH::CanWeMoveForward2
  00428	85 c0		 test	 eax, eax
  0042a	74 40		 je	 SHORT $LN21@FindNextDi

; 253  : 			{
; 254  : 				int p = VerifyThatOnPath(sx, sy);

  0042c	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  0042f	50		 push	 eax
  00430	8b 4d 08	 mov	 ecx, DWORD PTR _sx$[ebp]
  00433	51		 push	 ecx
  00434	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00437	e8 00 00 00 00	 call	 ?VerifyThatOnPath@PATH@@AAEHHH@Z ; PATH::VerifyThatOnPath
  0043c	89 45 b0	 mov	 DWORD PTR _p$1[ebp], eax

; 255  : 				if (p!=-1)// we are back on a previous point

  0043f	83 7d b0 ff	 cmp	 DWORD PTR _p$1[ebp], -1
  00443	74 22		 je	 SHORT $LN25@FindNextDi

; 256  : 				{
; 257  : 					HitMap[sx+sy*Width] = 1;

  00445	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00448	8b 4d 0c	 mov	 ecx, DWORD PTR _sy$[ebp]
  0044b	0f af 08	 imul	 ecx, DWORD PTR [eax]
  0044e	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  00451	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00454	8b 82 40 04 00
	00		 mov	 eax, DWORD PTR [edx+1088]
  0045a	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1

; 258  : 					NumPath = p;

  0045e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00461	8b 4d b0	 mov	 ecx, DWORD PTR _p$1[ebp]
  00464	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN25@FindNextDi:

; 259  : 				}
; 260  : 				return posdir;

  00467	8b 45 b4	 mov	 eax, DWORD PTR _posdir$2[ebp]
  0046a	eb 1c		 jmp	 SHORT $LN1@FindNextDi
$LN21@FindNextDi:

; 261  : 			}
; 262  : 		}
; 263  : 		// if all attempts to move forward were unsuccessful
; 264  : 		// tag the current position and back up one
; 265  : 		HitMap[sx+sy*Width] = 1;

  0046c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0046f	8b 4d 0c	 mov	 ecx, DWORD PTR _sy$[ebp]
  00472	0f af 08	 imul	 ecx, DWORD PTR [eax]
  00475	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  00478	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0047b	8b 82 40 04 00
	00		 mov	 eax, DWORD PTR [edx+1088]
  00481	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1

; 266  : 		return -1;// error

  00485	83 c8 ff	 or	 eax, -1
$LN1@FindNextDi:

; 267  : 	}

  00488	5f		 pop	 edi
  00489	5e		 pop	 esi
  0048a	5b		 pop	 ebx
  0048b	8b e5		 mov	 esp, ebp
  0048d	5d		 pop	 ebp
  0048e	c2 1c 00	 ret	 28			; 0000001cH
?FindNextDir2@PATH@@AAEHHHHHH_N0@Z ENDP			; PATH::FindNextDir2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?FindNextDir@PATH@@AAEHHHHHH_N0@Z
_TEXT	SEGMENT
_p$1 = -80						; size = 4
_posdir$2 = -76						; size = 4
_p$3 = -72						; size = 4
_negdir$4 = -68						; size = 4
_p$5 = -64						; size = 4
_LastDist$ = -60					; size = 4
_dist$6 = -56						; size = 4
_newy$7 = -52						; size = 4
_newx$8 = -48						; size = 4
_dist$9 = -44						; size = 4
_newy$10 = -40						; size = 4
_newx$11 = -36						; size = 4
_dist$12 = -32						; size = 4
_newy$13 = -28						; size = 4
_newx$14 = -24						; size = 4
_i$ = -20						; size = 4
_WhichDir$ = -16					; size = 4
_ldir$ = -12						; size = 4
_MinDist$ = -8						; size = 4
_this$ = -4						; size = 4
_sx$ = 8						; size = 4
_sy$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_dirstart$ = 24						; size = 4
_First$ = 28						; size = 1
_ErrorCheck$ = 32					; size = 1
?FindNextDir@PATH@@AAEHHHHHH_N0@Z PROC			; PATH::FindNextDir, COMDAT
; _this$ = ecx

; 84   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 85   :         //if (LastDir == dirstart)
; 86   :         int MinDist = 10000000, ldir;

  0000f	c7 45 f8 80 96
	98 00		 mov	 DWORD PTR _MinDist$[ebp], 10000000 ; 00989680H

; 87   :         int WhichDir = 0;

  00016	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _WhichDir$[ebp], 0

; 88   : 		int i;
; 89   : 		if(First)

  0001d	0f b6 45 1c	 movzx	 eax, BYTE PTR _First$[ebp]
  00021	85 c0		 test	 eax, eax
  00023	0f 84 a5 00 00
	00		 je	 $LN11@FindNextDi

; 90   : 		{
; 91   : 			for (i=0; i<8; i++)

  00029	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00030	eb 09		 jmp	 SHORT $LN4@FindNextDi
$LN2@FindNextDi:
  00032	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00035	83 c0 01	 add	 eax, 1
  00038	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@FindNextDi:
  0003b	83 7d ec 08	 cmp	 DWORD PTR _i$[ebp], 8
  0003f	0f 8d 84 00 00
	00		 jge	 $LN3@FindNextDi

; 92   : 			{
; 93   : 				ldir=i%8;// only 8 directions in case we wrap

  00045	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00048	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0004d	79 05		 jns	 SHORT $LN27@FindNextDi
  0004f	48		 dec	 eax
  00050	83 c8 f8	 or	 eax, -8			; fffffff8H
  00053	40		 inc	 eax
$LN27@FindNextDi:
  00054	89 45 f4	 mov	 DWORD PTR _ldir$[ebp], eax

; 94   : 				int newx = sx+Dir[ldir*2], newy = sy+Dir[ldir*2+1];

  00057	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  0005a	d1 e0		 shl	 eax, 1
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  00062	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  00069	89 55 e8	 mov	 DWORD PTR _newx$14[ebp], edx
  0006c	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  0006f	d1 e0		 shl	 eax, 1
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00077	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  0007e	89 55 e4	 mov	 DWORD PTR _newy$13[ebp], edx

; 95   : 				int dist = GetDist(newx, newy, dx, dy);

  00081	8b 45 14	 mov	 eax, DWORD PTR _dy$[ebp]
  00084	50		 push	 eax
  00085	8b 4d 10	 mov	 ecx, DWORD PTR _dx$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 e4	 mov	 edx, DWORD PTR _newy$13[ebp]
  0008c	52		 push	 edx
  0008d	8b 45 e8	 mov	 eax, DWORD PTR _newx$14[ebp]
  00090	50		 push	 eax
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?GetDist@PATH@@AAEHHHHH@Z ; PATH::GetDist
  00099	89 45 e0	 mov	 DWORD PTR _dist$12[ebp], eax

; 96   : 				if (MinDist > dist && IsThisSpotOK(newx, newy))

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  0009f	3b 45 e0	 cmp	 eax, DWORD PTR _dist$12[ebp]
  000a2	7e 20		 jle	 SHORT $LN13@FindNextDi
  000a4	8b 45 e4	 mov	 eax, DWORD PTR _newy$13[ebp]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR _newx$14[ebp]
  000ab	51		 push	 ecx
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	e8 00 00 00 00	 call	 ?IsThisSpotOK@PATH@@AAEHHH@Z ; PATH::IsThisSpotOK
  000b4	85 c0		 test	 eax, eax
  000b6	74 0c		 je	 SHORT $LN13@FindNextDi

; 97   : 				{MinDist = dist; WhichDir = ldir;} 

  000b8	8b 45 e0	 mov	 eax, DWORD PTR _dist$12[ebp]
  000bb	89 45 f8	 mov	 DWORD PTR _MinDist$[ebp], eax
  000be	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  000c1	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax
$LN13@FindNextDi:

; 98   : 			}

  000c4	e9 69 ff ff ff	 jmp	 $LN2@FindNextDi
$LN3@FindNextDi:

; 99   : 		}

  000c9	e9 5b 01 00 00	 jmp	 $LN12@FindNextDi
$LN11@FindNextDi:

; 100  : 		else
; 101  : 		{
; 102  : 			for (i=dirstart+8-1; i<=dirstart+8+1; i++)

  000ce	8b 45 18	 mov	 eax, DWORD PTR _dirstart$[ebp]
  000d1	83 c0 07	 add	 eax, 7
  000d4	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
  000d7	eb 09		 jmp	 SHORT $LN7@FindNextDi
$LN5@FindNextDi:
  000d9	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN7@FindNextDi:
  000e2	8b 45 18	 mov	 eax, DWORD PTR _dirstart$[ebp]
  000e5	83 c0 09	 add	 eax, 9
  000e8	39 45 ec	 cmp	 DWORD PTR _i$[ebp], eax
  000eb	0f 8f 84 00 00
	00		 jg	 $LN6@FindNextDi

; 103  : 			{
; 104  : 				ldir=i%8;// only 8 directions in case we wrap

  000f1	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  000f9	79 05		 jns	 SHORT $LN28@FindNextDi
  000fb	48		 dec	 eax
  000fc	83 c8 f8	 or	 eax, -8			; fffffff8H
  000ff	40		 inc	 eax
$LN28@FindNextDi:
  00100	89 45 f4	 mov	 DWORD PTR _ldir$[ebp], eax

; 105  : 				int newx = sx+Dir[ldir*2], newy = sy+Dir[ldir*2+1];

  00103	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  00106	d1 e0		 shl	 eax, 1
  00108	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  0010e	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  00115	89 55 dc	 mov	 DWORD PTR _newx$11[ebp], edx
  00118	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  0011b	d1 e0		 shl	 eax, 1
  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00123	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  0012a	89 55 d8	 mov	 DWORD PTR _newy$10[ebp], edx

; 106  : 				int dist = GetDist(newx, newy, dx, dy);

  0012d	8b 45 14	 mov	 eax, DWORD PTR _dy$[ebp]
  00130	50		 push	 eax
  00131	8b 4d 10	 mov	 ecx, DWORD PTR _dx$[ebp]
  00134	51		 push	 ecx
  00135	8b 55 d8	 mov	 edx, DWORD PTR _newy$10[ebp]
  00138	52		 push	 edx
  00139	8b 45 dc	 mov	 eax, DWORD PTR _newx$11[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00140	e8 00 00 00 00	 call	 ?GetDist@PATH@@AAEHHHHH@Z ; PATH::GetDist
  00145	89 45 d4	 mov	 DWORD PTR _dist$9[ebp], eax

; 107  : 				if (MinDist > dist && IsThisSpotOK(newx, newy))

  00148	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  0014b	3b 45 d4	 cmp	 eax, DWORD PTR _dist$9[ebp]
  0014e	7e 20		 jle	 SHORT $LN14@FindNextDi
  00150	8b 45 d8	 mov	 eax, DWORD PTR _newy$10[ebp]
  00153	50		 push	 eax
  00154	8b 4d dc	 mov	 ecx, DWORD PTR _newx$11[ebp]
  00157	51		 push	 ecx
  00158	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	e8 00 00 00 00	 call	 ?IsThisSpotOK@PATH@@AAEHHH@Z ; PATH::IsThisSpotOK
  00160	85 c0		 test	 eax, eax
  00162	74 0c		 je	 SHORT $LN14@FindNextDi

; 108  : 				{MinDist = dist; WhichDir = ldir;} 

  00164	8b 45 d4	 mov	 eax, DWORD PTR _dist$9[ebp]
  00167	89 45 f8	 mov	 DWORD PTR _MinDist$[ebp], eax
  0016a	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  0016d	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax
$LN14@FindNextDi:

; 109  : 			}

  00170	e9 64 ff ff ff	 jmp	 $LN5@FindNextDi
$LN6@FindNextDi:

; 110  : 			if (MinDist == 10000000)//in case we didn't find a spot the first time

  00175	81 7d f8 80 96
	98 00		 cmp	 DWORD PTR _MinDist$[ebp], 10000000 ; 00989680H
  0017c	0f 85 a7 00 00
	00		 jne	 $LN12@FindNextDi

; 111  : 			{
; 112  : 				for (i=dirstart+2; i<=dirstart+6; i++)// 5 directions left

  00182	8b 45 18	 mov	 eax, DWORD PTR _dirstart$[ebp]
  00185	83 c0 02	 add	 eax, 2
  00188	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
  0018b	eb 09		 jmp	 SHORT $LN10@FindNextDi
$LN8@FindNextDi:
  0018d	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00190	83 c0 01	 add	 eax, 1
  00193	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN10@FindNextDi:
  00196	8b 45 18	 mov	 eax, DWORD PTR _dirstart$[ebp]
  00199	83 c0 06	 add	 eax, 6
  0019c	39 45 ec	 cmp	 DWORD PTR _i$[ebp], eax
  0019f	0f 8f 84 00 00
	00		 jg	 $LN12@FindNextDi

; 113  : 				{
; 114  : 					ldir=i%8;

  001a5	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  001a8	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  001ad	79 05		 jns	 SHORT $LN29@FindNextDi
  001af	48		 dec	 eax
  001b0	83 c8 f8	 or	 eax, -8			; fffffff8H
  001b3	40		 inc	 eax
$LN29@FindNextDi:
  001b4	89 45 f4	 mov	 DWORD PTR _ldir$[ebp], eax

; 115  : 					int newx = sx+Dir[ldir*2], newy = sy+Dir[ldir*2+1];

  001b7	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  001ba	d1 e0		 shl	 eax, 1
  001bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001bf	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  001c2	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  001c9	89 55 d0	 mov	 DWORD PTR _newx$8[ebp], edx
  001cc	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  001cf	d1 e0		 shl	 eax, 1
  001d1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d4	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  001d7	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  001de	89 55 cc	 mov	 DWORD PTR _newy$7[ebp], edx

; 116  : 					int dist = GetDist(newx, newy, dx, dy);

  001e1	8b 45 14	 mov	 eax, DWORD PTR _dy$[ebp]
  001e4	50		 push	 eax
  001e5	8b 4d 10	 mov	 ecx, DWORD PTR _dx$[ebp]
  001e8	51		 push	 ecx
  001e9	8b 55 cc	 mov	 edx, DWORD PTR _newy$7[ebp]
  001ec	52		 push	 edx
  001ed	8b 45 d0	 mov	 eax, DWORD PTR _newx$8[ebp]
  001f0	50		 push	 eax
  001f1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f4	e8 00 00 00 00	 call	 ?GetDist@PATH@@AAEHHHHH@Z ; PATH::GetDist
  001f9	89 45 c8	 mov	 DWORD PTR _dist$6[ebp], eax

; 117  : 					if (MinDist > dist && IsThisSpotOK(newx, newy))

  001fc	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  001ff	3b 45 c8	 cmp	 eax, DWORD PTR _dist$6[ebp]
  00202	7e 20		 jle	 SHORT $LN16@FindNextDi
  00204	8b 45 cc	 mov	 eax, DWORD PTR _newy$7[ebp]
  00207	50		 push	 eax
  00208	8b 4d d0	 mov	 ecx, DWORD PTR _newx$8[ebp]
  0020b	51		 push	 ecx
  0020c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0020f	e8 00 00 00 00	 call	 ?IsThisSpotOK@PATH@@AAEHHH@Z ; PATH::IsThisSpotOK
  00214	85 c0		 test	 eax, eax
  00216	74 0c		 je	 SHORT $LN16@FindNextDi

; 118  : 					{MinDist = dist; WhichDir = ldir;} 

  00218	8b 45 c8	 mov	 eax, DWORD PTR _dist$6[ebp]
  0021b	89 45 f8	 mov	 DWORD PTR _MinDist$[ebp], eax
  0021e	8b 45 f4	 mov	 eax, DWORD PTR _ldir$[ebp]
  00221	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax
$LN16@FindNextDi:

; 119  : 				}

  00224	e9 64 ff ff ff	 jmp	 $LN8@FindNextDi
$LN12@FindNextDi:

; 120  : 			}
; 121  : 		}
; 122  :         LastDir = dirstart;

  00229	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0022c	8b 4d 18	 mov	 ecx, DWORD PTR _dirstart$[ebp]
  0022f	89 88 34 04 00
	00		 mov	 DWORD PTR [eax+1076], ecx

; 123  : 		int LastDist = GetDist(sx, sy, sx+Dir[LastDir*2], sy+Dir[LastDir*2+1]);

  00235	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00238	8b 88 34 04 00
	00		 mov	 ecx, DWORD PTR [eax+1076]
  0023e	d1 e1		 shl	 ecx, 1
  00240	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00243	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  00246	03 84 8a f8 03
	00 00		 add	 eax, DWORD PTR [edx+ecx*4+1016]
  0024d	50		 push	 eax
  0024e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00251	8b 91 34 04 00
	00		 mov	 edx, DWORD PTR [ecx+1076]
  00257	d1 e2		 shl	 edx, 1
  00259	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0025c	8b 4d 08	 mov	 ecx, DWORD PTR _sx$[ebp]
  0025f	03 8c 90 f4 03
	00 00		 add	 ecx, DWORD PTR [eax+edx*4+1012]
  00266	51		 push	 ecx
  00267	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  0026a	52		 push	 edx
  0026b	8b 45 08	 mov	 eax, DWORD PTR _sx$[ebp]
  0026e	50		 push	 eax
  0026f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00272	e8 00 00 00 00	 call	 ?GetDist@PATH@@AAEHHHHH@Z ; PATH::GetDist
  00277	89 45 c4	 mov	 DWORD PTR _LastDist$[ebp], eax

; 124  : 		if (LastDist>MinDist-6 && LastDist<MinDist+6 && MinDist>=25)//???

  0027a	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  0027d	83 e8 06	 sub	 eax, 6
  00280	39 45 c4	 cmp	 DWORD PTR _LastDist$[ebp], eax
  00283	7e 1d		 jle	 SHORT $LN17@FindNextDi
  00285	8b 45 f8	 mov	 eax, DWORD PTR _MinDist$[ebp]
  00288	83 c0 06	 add	 eax, 6
  0028b	39 45 c4	 cmp	 DWORD PTR _LastDist$[ebp], eax
  0028e	7d 12		 jge	 SHORT $LN17@FindNextDi
  00290	83 7d f8 19	 cmp	 DWORD PTR _MinDist$[ebp], 25 ; 00000019H
  00294	7c 0c		 jl	 SHORT $LN17@FindNextDi

; 125  : 			WhichDir = LastDir;

  00296	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00299	8b 88 34 04 00
	00		 mov	 ecx, DWORD PTR [eax+1076]
  0029f	89 4d f0	 mov	 DWORD PTR _WhichDir$[ebp], ecx
$LN17@FindNextDi:

; 126  : 		if (MinDist == 10000000)// we could not find a good spot

  002a2	81 7d f8 80 96
	98 00		 cmp	 DWORD PTR _MinDist$[ebp], 10000000 ; 00989680H
  002a9	75 08		 jne	 SHORT $LN18@FindNextDi

; 127  : 			return -1;

  002ab	83 c8 ff	 or	 eax, -1
  002ae	e9 d5 01 00 00	 jmp	 $LN1@FindNextDi
$LN18@FindNextDi:

; 128  : 
; 129  : 		// now we know the shortset distance but...
; 130  : 		if (CanWeMoveForward(sx+Dir[WhichDir*2], sy+Dir[WhichDir*2+1]))

  002b3	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  002b6	d1 e0		 shl	 eax, 1
  002b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002bb	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  002be	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  002c5	52		 push	 edx
  002c6	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  002c9	d1 e0		 shl	 eax, 1
  002cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ce	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  002d1	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  002d8	52		 push	 edx
  002d9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002dc	e8 00 00 00 00	 call	 ?CanWeMoveForward@PATH@@AAEHHH@Z ; PATH::CanWeMoveForward
  002e1	85 c0		 test	 eax, eax
  002e3	74 43		 je	 SHORT $LN19@FindNextDi

; 131  : 		{
; 132  : 			int p = VerifyThatOnPath(sx, sy);

  002e5	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  002e8	50		 push	 eax
  002e9	8b 4d 08	 mov	 ecx, DWORD PTR _sx$[ebp]
  002ec	51		 push	 ecx
  002ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f0	e8 00 00 00 00	 call	 ?VerifyThatOnPath@PATH@@AAEHHH@Z ; PATH::VerifyThatOnPath
  002f5	89 45 c0	 mov	 DWORD PTR _p$5[ebp], eax

; 133  : 			if (p!=-1)// we are back on a previous point

  002f8	83 7d c0 ff	 cmp	 DWORD PTR _p$5[ebp], -1
  002fc	74 22		 je	 SHORT $LN20@FindNextDi

; 134  : 			{
; 135  : 				HitMap[sx+sy*Width] = 1;

  002fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00301	8b 4d 0c	 mov	 ecx, DWORD PTR _sy$[ebp]
  00304	0f af 08	 imul	 ecx, DWORD PTR [eax]
  00307	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  0030a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0030d	8b 82 40 04 00
	00		 mov	 eax, DWORD PTR [edx+1088]
  00313	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1

; 136  : 				NumPath = p;

  00317	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0031a	8b 4d c0	 mov	 ecx, DWORD PTR _p$5[ebp]
  0031d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN20@FindNextDi:

; 137  : 			}
; 138  : 			return WhichDir;

  00320	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  00323	e9 60 01 00 00	 jmp	 $LN1@FindNextDi
$LN19@FindNextDi:

; 139  : 		}
; 140  : 		if(ErrorCheck)

  00328	0f b6 45 20	 movzx	 eax, BYTE PTR _ErrorCheck$[ebp]
  0032c	85 c0		 test	 eax, eax
  0032e	0f 84 38 01 00
	00		 je	 $LN21@FindNextDi

; 141  : 		{
; 142  : #ifdef MODIFY_PATHFIND_BUGFIX_20090609
; 143  : 			WhichDir += 4; WhichDir %= 8;

  00334	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  00337	83 c0 04	 add	 eax, 4
  0033a	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax
  0033d	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  00340	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00345	79 05		 jns	 SHORT $LN30@FindNextDi
  00347	48		 dec	 eax
  00348	83 c8 f8	 or	 eax, -8			; fffffff8H
  0034b	40		 inc	 eax
$LN30@FindNextDi:
  0034c	89 45 f0	 mov	 DWORD PTR _WhichDir$[ebp], eax

; 144  : #endif	// MODIFY_PATHFIND_BUGFIX_20090609
; 145  : 
; 146  : 			int negdir = (WhichDir+8-1); negdir%=8;

  0034f	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  00352	83 c0 07	 add	 eax, 7
  00355	89 45 bc	 mov	 DWORD PTR _negdir$4[ebp], eax
  00358	8b 45 bc	 mov	 eax, DWORD PTR _negdir$4[ebp]
  0035b	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00360	79 05		 jns	 SHORT $LN31@FindNextDi
  00362	48		 dec	 eax
  00363	83 c8 f8	 or	 eax, -8			; fffffff8H
  00366	40		 inc	 eax
$LN31@FindNextDi:
  00367	89 45 bc	 mov	 DWORD PTR _negdir$4[ebp], eax

; 147  : 			if (CanWeMoveForward(sx+Dir[negdir*2], sy+Dir[negdir*2+1]))

  0036a	8b 45 bc	 mov	 eax, DWORD PTR _negdir$4[ebp]
  0036d	d1 e0		 shl	 eax, 1
  0036f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00372	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00375	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  0037c	52		 push	 edx
  0037d	8b 45 bc	 mov	 eax, DWORD PTR _negdir$4[ebp]
  00380	d1 e0		 shl	 eax, 1
  00382	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00385	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  00388	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  0038f	52		 push	 edx
  00390	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00393	e8 00 00 00 00	 call	 ?CanWeMoveForward@PATH@@AAEHHH@Z ; PATH::CanWeMoveForward
  00398	85 c0		 test	 eax, eax
  0039a	74 43		 je	 SHORT $LN22@FindNextDi

; 148  : 			{
; 149  : 				int p = VerifyThatOnPath(sx, sy);

  0039c	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  0039f	50		 push	 eax
  003a0	8b 4d 08	 mov	 ecx, DWORD PTR _sx$[ebp]
  003a3	51		 push	 ecx
  003a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a7	e8 00 00 00 00	 call	 ?VerifyThatOnPath@PATH@@AAEHHH@Z ; PATH::VerifyThatOnPath
  003ac	89 45 b8	 mov	 DWORD PTR _p$3[ebp], eax

; 150  : 				if (p!=-1)// we are back on a previous point

  003af	83 7d b8 ff	 cmp	 DWORD PTR _p$3[ebp], -1
  003b3	74 22		 je	 SHORT $LN23@FindNextDi

; 151  : 				{
; 152  : 					HitMap[sx+sy*Width] = 1;

  003b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003b8	8b 4d 0c	 mov	 ecx, DWORD PTR _sy$[ebp]
  003bb	0f af 08	 imul	 ecx, DWORD PTR [eax]
  003be	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  003c1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003c4	8b 82 40 04 00
	00		 mov	 eax, DWORD PTR [edx+1088]
  003ca	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1

; 153  : 					NumPath = p;

  003ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003d1	8b 4d b8	 mov	 ecx, DWORD PTR _p$3[ebp]
  003d4	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN23@FindNextDi:

; 154  : 				}
; 155  : 				return negdir;

  003d7	8b 45 bc	 mov	 eax, DWORD PTR _negdir$4[ebp]
  003da	e9 a9 00 00 00	 jmp	 $LN1@FindNextDi
$LN22@FindNextDi:

; 156  : 			}
; 157  : 			int posdir = (WhichDir+8+1); posdir%=8;

  003df	8b 45 f0	 mov	 eax, DWORD PTR _WhichDir$[ebp]
  003e2	83 c0 09	 add	 eax, 9
  003e5	89 45 b4	 mov	 DWORD PTR _posdir$2[ebp], eax
  003e8	8b 45 b4	 mov	 eax, DWORD PTR _posdir$2[ebp]
  003eb	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  003f0	79 05		 jns	 SHORT $LN32@FindNextDi
  003f2	48		 dec	 eax
  003f3	83 c8 f8	 or	 eax, -8			; fffffff8H
  003f6	40		 inc	 eax
$LN32@FindNextDi:
  003f7	89 45 b4	 mov	 DWORD PTR _posdir$2[ebp], eax

; 158  : 			if (CanWeMoveForward(sx+Dir[posdir*2], sy+Dir[posdir*2+1]))

  003fa	8b 45 b4	 mov	 eax, DWORD PTR _posdir$2[ebp]
  003fd	d1 e0		 shl	 eax, 1
  003ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00402	8b 55 0c	 mov	 edx, DWORD PTR _sy$[ebp]
  00405	03 94 81 f8 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1016]
  0040c	52		 push	 edx
  0040d	8b 45 b4	 mov	 eax, DWORD PTR _posdir$2[ebp]
  00410	d1 e0		 shl	 eax, 1
  00412	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00415	8b 55 08	 mov	 edx, DWORD PTR _sx$[ebp]
  00418	03 94 81 f4 03
	00 00		 add	 edx, DWORD PTR [ecx+eax*4+1012]
  0041f	52		 push	 edx
  00420	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00423	e8 00 00 00 00	 call	 ?CanWeMoveForward@PATH@@AAEHHH@Z ; PATH::CanWeMoveForward
  00428	85 c0		 test	 eax, eax
  0042a	74 40		 je	 SHORT $LN21@FindNextDi

; 159  : 			{
; 160  : 				int p = VerifyThatOnPath(sx, sy);

  0042c	8b 45 0c	 mov	 eax, DWORD PTR _sy$[ebp]
  0042f	50		 push	 eax
  00430	8b 4d 08	 mov	 ecx, DWORD PTR _sx$[ebp]
  00433	51		 push	 ecx
  00434	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00437	e8 00 00 00 00	 call	 ?VerifyThatOnPath@PATH@@AAEHHH@Z ; PATH::VerifyThatOnPath
  0043c	89 45 b0	 mov	 DWORD PTR _p$1[ebp], eax

; 161  : 				if (p!=-1)// we are back on a previous point

  0043f	83 7d b0 ff	 cmp	 DWORD PTR _p$1[ebp], -1
  00443	74 22		 je	 SHORT $LN25@FindNextDi

; 162  : 				{
; 163  : 					HitMap[sx+sy*Width] = 1;

  00445	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00448	8b 4d 0c	 mov	 ecx, DWORD PTR _sy$[ebp]
  0044b	0f af 08	 imul	 ecx, DWORD PTR [eax]
  0044e	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  00451	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00454	8b 82 40 04 00
	00		 mov	 eax, DWORD PTR [edx+1088]
  0045a	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1

; 164  : 					NumPath = p;

  0045e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00461	8b 4d b0	 mov	 ecx, DWORD PTR _p$1[ebp]
  00464	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN25@FindNextDi:

; 165  : 				}
; 166  : 				return posdir;

  00467	8b 45 b4	 mov	 eax, DWORD PTR _posdir$2[ebp]
  0046a	eb 1c		 jmp	 SHORT $LN1@FindNextDi
$LN21@FindNextDi:

; 167  : 			}
; 168  : 		}
; 169  : 		// if all attempts to move forward were unsuccessful
; 170  : 		// tag the current position and back up one
; 171  : 		HitMap[sx+sy*Width] = 1;

  0046c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0046f	8b 4d 0c	 mov	 ecx, DWORD PTR _sy$[ebp]
  00472	0f af 08	 imul	 ecx, DWORD PTR [eax]
  00475	03 4d 08	 add	 ecx, DWORD PTR _sx$[ebp]
  00478	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0047b	8b 82 40 04 00
	00		 mov	 eax, DWORD PTR [edx+1088]
  00481	c6 04 08 01	 mov	 BYTE PTR [eax+ecx], 1

; 172  : 		return -1;// error

  00485	83 c8 ff	 or	 eax, -1
$LN1@FindNextDi:

; 173  : 	}

  00488	5f		 pop	 edi
  00489	5e		 pop	 esi
  0048a	5b		 pop	 ebx
  0048b	8b e5		 mov	 esp, ebp
  0048d	5d		 pop	 ebp
  0048e	c2 1c 00	 ret	 28			; 0000001cH
?FindNextDir@PATH@@AAEHHHHHH_N0@Z ENDP			; PATH::FindNextDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?IsThisSpotOK@PATH@@AAEHHH@Z
_TEXT	SEGMENT
_pos$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?IsThisSpotOK@PATH@@AAEHHH@Z PROC			; PATH::IsThisSpotOK, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   :         int pos = x+y*Width;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00012	0f af 08	 imul	 ecx, DWORD PTR [eax]
  00015	03 4d 08	 add	 ecx, DWORD PTR _x$[ebp]
  00018	89 4d f8	 mov	 DWORD PTR _pos$[ebp], ecx

; 75   :         if (x<0 || x>=Width || y<0 || y>=Width)

  0001b	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  0001f	7c 1a		 jl	 SHORT $LN3@IsThisSpot
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00027	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00029	7d 10		 jge	 SHORT $LN3@IsThisSpot
  0002b	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  0002f	7c 0a		 jl	 SHORT $LN3@IsThisSpot
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00037	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00039	7c 04		 jl	 SHORT $LN2@IsThisSpot
$LN3@IsThisSpot:

; 76   : 			return 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 1d		 jmp	 SHORT $LN1@IsThisSpot
$LN2@IsThisSpot:

; 77   :         if (HitMap[pos])

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 88 40 04 00
	00		 mov	 ecx, DWORD PTR [eax+1088]
  00048	8b 55 f8	 mov	 edx, DWORD PTR _pos$[ebp]
  0004b	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  0004f	85 c0		 test	 eax, eax
  00051	74 04		 je	 SHORT $LN4@IsThisSpot

; 78   :         {
; 79   :             return 0;

  00053	33 c0		 xor	 eax, eax
  00055	eb 05		 jmp	 SHORT $LN1@IsThisSpot
$LN4@IsThisSpot:

; 80   :         }        
; 81   :         return 1;

  00057	b8 01 00 00 00	 mov	 eax, 1
$LN1@IsThisSpot:

; 82   :     }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
?IsThisSpotOK@PATH@@AAEHHH@Z ENDP			; PATH::IsThisSpotOK
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?CanWeMoveForward2@PATH@@AAEHHH@Z
_TEXT	SEGMENT
_which$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?CanWeMoveForward2@PATH@@AAEHHH@Z PROC			; PATH::CanWeMoveForward2, COMDAT
; _this$ = ecx

; 46   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   :         int which = x+y*Width;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00012	0f af 08	 imul	 ecx, DWORD PTR [eax]
  00015	03 4d 08	 add	 ecx, DWORD PTR _x$[ebp]
  00018	89 4d f8	 mov	 DWORD PTR _which$[ebp], ecx

; 48   :         if (x>=Width || x<0 || y>=Height ||y<0)//off of the map

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00021	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00023	7d 17		 jge	 SHORT $LN3@CanWeMoveF
  00025	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00029	7c 11		 jl	 SHORT $LN3@CanWeMoveF
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00031	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00034	7d 06		 jge	 SHORT $LN3@CanWeMoveF
  00036	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  0003a	7d 04		 jge	 SHORT $LN2@CanWeMoveF
$LN3@CanWeMoveF:

; 49   :             return 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	eb 42		 jmp	 SHORT $LN1@CanWeMoveF
$LN2@CanWeMoveF:

; 50   :         if (Map[which]>=1 || HitMap[which])

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 88 3c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1084]
  00049	8b 55 f8	 mov	 edx, DWORD PTR _which$[ebp]
  0004c	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  00050	83 f8 01	 cmp	 eax, 1
  00053	7d 14		 jge	 SHORT $LN5@CanWeMoveF
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 88 40 04 00
	00		 mov	 ecx, DWORD PTR [eax+1088]
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _which$[ebp]
  00061	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  00065	85 c0		 test	 eax, eax
  00067	74 14		 je	 SHORT $LN4@CanWeMoveF
$LN5@CanWeMoveF:

; 51   :         {          
; 52   :             HitMap[which] = 1;// fill this area as checked already

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 88 40 04 00
	00		 mov	 ecx, DWORD PTR [eax+1088]
  00072	8b 55 f8	 mov	 edx, DWORD PTR _which$[ebp]
  00075	c6 04 11 01	 mov	 BYTE PTR [ecx+edx], 1

; 53   :             return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	eb 05		 jmp	 SHORT $LN1@CanWeMoveF
$LN4@CanWeMoveF:

; 54   :         }
; 55   :         return 1;

  0007d	b8 01 00 00 00	 mov	 eax, 1
$LN1@CanWeMoveF:

; 56   :     }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
?CanWeMoveForward2@PATH@@AAEHHH@Z ENDP			; PATH::CanWeMoveForward2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?CanWeMoveForward@PATH@@AAEHHH@Z
_TEXT	SEGMENT
_which$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?CanWeMoveForward@PATH@@AAEHHH@Z PROC			; PATH::CanWeMoveForward, COMDAT
; _this$ = ecx

; 33   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 34   :         int which = x+y*Width;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00012	0f af 08	 imul	 ecx, DWORD PTR [eax]
  00015	03 4d 08	 add	 ecx, DWORD PTR _x$[ebp]
  00018	89 4d f8	 mov	 DWORD PTR _which$[ebp], ecx

; 35   :         if (x>=Width || x<0 || y>=Height ||y<0)//off of the map

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00021	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00023	7d 17		 jge	 SHORT $LN3@CanWeMoveF
  00025	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00029	7c 11		 jl	 SHORT $LN3@CanWeMoveF
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00031	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00034	7d 06		 jge	 SHORT $LN3@CanWeMoveF
  00036	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  0003a	7d 04		 jge	 SHORT $LN2@CanWeMoveF
$LN3@CanWeMoveF:

; 36   :             return 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	eb 42		 jmp	 SHORT $LN1@CanWeMoveF
$LN2@CanWeMoveF:

; 37   :         if (Map[which]>1 || HitMap[which])

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 88 3c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1084]
  00049	8b 55 f8	 mov	 edx, DWORD PTR _which$[ebp]
  0004c	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  00050	83 f8 01	 cmp	 eax, 1
  00053	7f 14		 jg	 SHORT $LN5@CanWeMoveF
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 88 40 04 00
	00		 mov	 ecx, DWORD PTR [eax+1088]
  0005e	8b 55 f8	 mov	 edx, DWORD PTR _which$[ebp]
  00061	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  00065	85 c0		 test	 eax, eax
  00067	74 14		 je	 SHORT $LN4@CanWeMoveF
$LN5@CanWeMoveF:

; 38   :         {          
; 39   :             HitMap[which] = 1;// fill this area as checked already

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 88 40 04 00
	00		 mov	 ecx, DWORD PTR [eax+1088]
  00072	8b 55 f8	 mov	 edx, DWORD PTR _which$[ebp]
  00075	c6 04 11 01	 mov	 BYTE PTR [ecx+edx], 1

; 40   :             return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	eb 05		 jmp	 SHORT $LN1@CanWeMoveF
$LN4@CanWeMoveF:

; 41   :         }
; 42   :         return 1;

  0007d	b8 01 00 00 00	 mov	 eax, 1
$LN1@CanWeMoveF:

; 43   :     }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
?CanWeMoveForward@PATH@@AAEHHH@Z ENDP			; PATH::CanWeMoveForward
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?VerifyThatOnPath@PATH@@AAEHHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?VerifyThatOnPath@PATH@@AAEHHH@Z PROC			; PATH::VerifyThatOnPath, COMDAT
; _this$ = ecx

; 25   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   :         for (int i=0; i<NumPath; i++)

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@VerifyThat
$LN2@VerifyThat:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@VerifyThat:
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00024	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00027	7d 28		 jge	 SHORT $LN3@VerifyThat

; 27   :         {
; 28   :             if (x==PathX[i] && y == PathY[i]) return i;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	03 45 f8	 add	 eax, DWORD PTR _i$1[ebp]
  0002f	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00033	39 4d 08	 cmp	 DWORD PTR _x$[ebp], ecx
  00036	75 17		 jne	 SHORT $LN5@VerifyThat
  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	03 45 f8	 add	 eax, DWORD PTR _i$1[ebp]
  0003e	0f b6 88 00 02
	00 00		 movzx	 ecx, BYTE PTR [eax+512]
  00045	39 4d 0c	 cmp	 DWORD PTR _y$[ebp], ecx
  00048	75 05		 jne	 SHORT $LN5@VerifyThat
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0004d	eb 05		 jmp	 SHORT $LN1@VerifyThat
$LN5@VerifyThat:

; 29   :         }

  0004f	eb c4		 jmp	 SHORT $LN2@VerifyThat
$LN3@VerifyThat:

; 30   :         return -1;

  00051	83 c8 ff	 or	 eax, -1
$LN1@VerifyThat:

; 31   :     }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
?VerifyThatOnPath@PATH@@AAEHHH@Z ENDP			; PATH::VerifyThatOnPath
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Common\zzzPath.h
;	COMDAT ?GetDist@PATH@@AAEHHHHH@Z
_TEXT	SEGMENT
_disty$ = -12						; size = 4
_distx$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?GetDist@PATH@@AAEHHHHH@Z PROC				; PATH::GetDist, COMDAT
; _this$ = ecx

; 20   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 21   :         int distx = x2-x1, disty = y2-y1;

  0000c	8b 45 10	 mov	 eax, DWORD PTR _x2$[ebp]
  0000f	2b 45 08	 sub	 eax, DWORD PTR _x1$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _distx$[ebp], eax
  00015	8b 45 14	 mov	 eax, DWORD PTR _y2$[ebp]
  00018	2b 45 0c	 sub	 eax, DWORD PTR _y1$[ebp]
  0001b	89 45 f4	 mov	 DWORD PTR _disty$[ebp], eax

; 22   :         return distx*distx + disty*disty;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _distx$[ebp]
  00021	0f af 45 f8	 imul	 eax, DWORD PTR _distx$[ebp]
  00025	8b 4d f4	 mov	 ecx, DWORD PTR _disty$[ebp]
  00028	0f af 4d f4	 imul	 ecx, DWORD PTR _disty$[ebp]
  0002c	03 c1		 add	 eax, ecx

; 23   :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 10 00	 ret	 16			; 00000010H
?GetDist@PATH@@AAEHHHHH@Z ENDP				; PATH::GetDist
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TerrainManager.h
;	COMDAT ?Size@CTerrainManager@@QAE?BHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Size@CTerrainManager@@QAE?BHXZ PROC			; CTerrainManager::Size, COMDAT
; _this$ = ecx

; 22   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 		return m_iSize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 24   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Size@CTerrainManager@@QAE?BHXZ ENDP			; CTerrainManager::Size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MapClass.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
